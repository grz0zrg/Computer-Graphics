"sketch ID","title","code title","code"
"1245654","minsky overflow layered","mySketch","// layered / offseted + colors

let xx = []
let yy = []
let co = 64*2

function setup() {
	pixelDensity(1);
	createCanvas(512, 512)
	
	background(0)
	
	rectMode(CORNERS)
	
	for (let i = 0; i < co; i += 1){
		xx[i] = 0
		yy[i] = 1000000000000
	}
}

function draw() {
/*
	stroke(255)
	fill(0)
	rect(0, 0, width, height)
*/
	background(0)
	
	loadPixels()
	
	let t = frameCount * 50
	
	for (let i = 0; i < width*16; i += 1) {
		for (let j = 0; j < co; j += 1){

		xx[j] -= (yy[j] / 3) + t + j * 1

		yy[j] += (xx[j] / 1)
		yy[j] %= 65536
		xx[j] -= (yy[j] / 3) + t + j * 1

		
		let px = (((xx[j] >> 7) + width / 2) & 511)
		let py = (((yy[j] >> 7)/* + height/2*/) & 511)
	
		let index1 = (px + (py << 9)) << 2
		let index2 = (~px + (py << 9)) << 2
	
		let nj = j / co
		let c = 48 * nj // (i|xx) // (i/xx)
		/*
		if (j%2 == 0) {
			c = -48
		}
		*/
		let len = width * height * 4
		
		if (index1 >= 0 && index1 < len) {
			pixels[index1 + 0] += c
			pixels[index1 + 1] += c & (0x2 + j + frameCount / 4)
			pixels[index1 + 2] += c ^ (0x2 + j)
			/*pixels[index2 + 0] += c
			pixels[index2 + 1] += c
			pixels[index2 + 2] += c
			
			index1 = len - index1
			index2 = len - index2
			
			pixels[index1 + 0] += c
			pixels[index1 + 1] += c
			pixels[index1 + 2] += c
			pixels[index2 + 0] += c
			pixels[index2 + 1] += c
			pixels[index2 + 2] += c*/
		}
		}
	}

	updatePixels()
}

"
"1242611","ifs polar log 11","mySketch","// ifs
// https://flam3.com/flame_draves.pdf

var xmotion = 0;
var ymotion = 0;

let rx = 0;
let ry = 0;
let ax = 0;
let ay = 0;

let histo = [];

function setup() {
  createCanvas(1000, 1000);
  background(0);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 100, 100, 1);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	rx = width /1;
	ry = height/3;
	ax = random(0, 1);
	ay = random(0, 1);
	
	for (let i = 0; i < width * height; i += 1) {
		histo[i] = 0;
	}
	
	generate();
}

function r1(x, y) {
	return { x: x, y: y };
}

function r2(x, y) {
	return { x: (width / 0.5 + x / 3) , y: y };
}

function r3(x, y) {
	return { x: (width / 1 + x / 1.5) - y /0.5, y: y };
}

function a1(x, y) {
	return { x: (1 - x / (PI * 2.5)), y: y / 1 - x / (PI * 2.) };
}

function a2(x, y) {
	return { x: x - 0.75, y: (1 + y * 1) / 1.25 };
}

function a3(x, y) {
	return { x: x / (3.14 / 2) - y / (3.14 / 2), y: y * 0.25 + x * PI / 16};
}

var r1 = [r1, r2, r3];
var a1 = [a1, a2, a3];

var iter = 0;

function draw() {
	//fill(0, 0, 0, 1);
	//rect(0, 0, width, height);
	
	let renderAtFrame = 60 * 16;
	
	if (frameCount <= renderAtFrame) {
		for (let i = 0; i < 5000; i += 1) {
			let index1 = floor(random(0, 3));
			let r = r1[index1](rx, ry);

			rx = r.x; ry = r.y;

			let index2 = floor(random(0, 3));
			let a = a1[index1](ax, ay);

			ax = a.x; ay = a.y;

			stroke(0, 0, 255, 0.035);

			if (iter > 20) {
				let x = width / 2 + rx * (sin(ax/2)); //* sqrt((ax+ax) * (ay+ay)*0.05)*2);//(sin(ax * PI * 2) * cos(ay * PI * 2));
				let y = height / 2 + ry * (cos(ay/0.01)); //* sqrt((ax+ax) * (ay+ay)*0.05)*2);
				// / 0.125 is kinda fun also
				
				let px = /*width / 2 - */x;
				let py = /*height / 2 -*/ y;

				if (x < width && x > 0 && y < height && y > 0) {
					push();
					translate(width / 2, height / 2);
					rotate(0.5+round(iter / 100) * PI + round(x/100 | y/100));
					point(px/1.5, py/1.5);
					point(width - px/1.5, py/1.5);
					//point(width / 6 +py, px);
					//point(-(width / 6 +py), px);
					//translate(0, 0);
					//rotate(round(iter / 100) * PI / 20);
					//point(px, py);
					//point(x - width / 2.125, y - height / 1.25);
					let index = floor(x) + floor(y) * width;
					if (index >= 0 && index < (width * height)) {
						histo[index] += 1;
					}
					pop();
				}
			}

			iter += 1;
		}

		let cx = random(width / 4, width - width / 4);
		let cy = random(height / 4, height - height / 4);
/*
		if (frameCount % (renderAtFrame) == 0) {
		//	background(0);

			generate();

			let m = 0;
			for (let j = 0; j < width * height; j += 1) {
				let value = Math.log10(histo[j]);
				m = max(m, value);
			}

			if (m > 0) {
				for (let y = 0; y < height; y += 1) {
					for (let x = 0; x < width; x += 1) {
						let index = x + y * width;
						let value = Math.log10(histo[index]);
						let gamma = 2.2;

						if (value > 0) {
							let brightness = pow(value / (1+m), 1 / gamma);
							stroke(180 + value / m * 80, 25 + value / m * 50, brightness * 100, 1);
							let shapes = 8;
							for (let j = 0; j < shapes; j += 1) {
								let nj = j / shapes;

								push();
								//scale(nj);
								translate(width / 2, height / 2);
								//rotate(j * PI / (shapes / 2));
								point(width / 2 - x, height / 2 - y);
								//translate(width / 2, 0);
								//point(width / 2 - x, height / 2 - y);
								//point(x - width / 2.125, y - height / 1.25);
								pop();
							}
						}
					}
				}
			}
		}*/
	}
	
	xmotion += 0.01;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.00125);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.01);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"1242608","ifs polar log 10","mySketch","// ifs
// https://flam3.com/flame_draves.pdf

var xmotion = 0;
var ymotion = 0;

let rx = 0;
let ry = 0;
let ax = 0;
let ay = 0;

let histo = [];

function setup() {
  createCanvas(1000, 1000);
  background(0);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 100, 100, 1);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	rx = width /1;
	ry = height/3;
	ax = random(0, 1);
	ay = random(0, 1);
	
	for (let i = 0; i < width * height; i += 1) {
		histo[i] = 0;
	}
	
	generate();
}

function r1(x, y) {
	return { x: x, y: y };
}

function r2(x, y) {
	return { x: (width / 1 + x / 4) , y: y };
}

function r3(x, y) {
	return { x: (width / 1 + x / 1.5) - y / 1, y: y };
}

function a1(x, y) {
	return { x: (1 - x / (PI * 1.25)), y: y / 8 - x / (PI * 1.) };
}

function a2(x, y) {
	return { x: x - 0.25, y: (1 + y * 0.7) / 1.25 };
}

function a3(x, y) {
	return { x: x / (3.14 / 1) - y / (3.14 / 2), y: y * 0.25 + x * PI / 8};
}

var r1 = [r1, r2, r3];
var a1 = [a1, a2, a3];

var iter = 0;

function draw() {
	//fill(0, 0, 0, 1);
	//rect(0, 0, width, height);
	
	let renderAtFrame = 60 * 8;
	
	if (frameCount <= renderAtFrame) {
		for (let i = 0; i < 5000; i += 1) {
			let index1 = floor(random(0, 3));
			let r = r1[index1](rx, ry);

			rx = r.x; ry = r.y;

			let index2 = floor(random(0, 3));
			let a = a1[index1](ax, ay);

			ax = a.x; ay = a.y;

			stroke(0, 0, 255, 0.025);

			if (iter > 20) {
				let x = width / 2 + rx * (sin(ax/3)); //* sqrt((ax+ax) * (ay+ay)*0.05)*2);//(sin(ax * PI * 2) * cos(ay * PI * 2));
				let y = height / 2 + ry * (cos(ay/0.125)); //* sqrt((ax+ax) * (ay+ay)*0.05)*2);
				// / 0.125 is kinda fun also
				
				let px = width / 2 - x;
				let py = height / 2 - y;

				if (x < width && x > 0 && y < height && y > 0) {
					push();
					translate(width / 2, height / 2);
					rotate(round(iter / 100) * PI / 4.);
					point(width / 6 +px, -py);
					point(-(width / 6 +px), -py);
					//translate(0, 0);
					//rotate(round(iter / 100) * PI / 20);
					//point(px, py);
					//point(x - width / 2.125, y - height / 1.25);
					let index = floor(x) + floor(y) * width;
					if (index >= 0 && index < (width * height)) {
						histo[index] += 1;
					}
					pop();
				}
			}

			iter += 1;
		}

		let cx = random(width / 4, width - width / 4);
		let cy = random(height / 4, height - height / 4);
/*
		if (frameCount % (renderAtFrame) == 0) {
		//	background(0);

			generate();

			let m = 0;
			for (let j = 0; j < width * height; j += 1) {
				let value = Math.log10(histo[j]);
				m = max(m, value);
			}

			if (m > 0) {
				for (let y = 0; y < height; y += 1) {
					for (let x = 0; x < width; x += 1) {
						let index = x + y * width;
						let value = Math.log10(histo[index]);
						let gamma = 2.2;

						if (value > 0) {
							let brightness = pow(value / (1+m), 1 / gamma);
							stroke(180 + value / m * 80, 25 + value / m * 50, brightness * 100, 1);
							let shapes = 8;
							for (let j = 0; j < shapes; j += 1) {
								let nj = j / shapes;

								push();
								//scale(nj);
								translate(width / 2, height / 2);
								//rotate(j * PI / (shapes / 2));
								point(width / 2 - x, height / 2 - y);
								//translate(width / 2, 0);
								//point(width / 2 - x, height / 2 - y);
								//point(x - width / 2.125, y - height / 1.25);
								pop();
							}
						}
					}
				}
			}
		}*/
	}
	
	xmotion += 0.01;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.00125);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.01);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"1241335","Stacking patterns sp4","mySketch","// same as parallax checkerboard with static render goal

function setup() {
	createCanvas(960, 960);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseDetail(6, 0.7);
	
	noStroke();
	
	rectMode(CENTER);
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	//background(0);
	noStroke();
	//fill(0, 0, 0, 0.05);
	//rect(0, 0, width, height);
	
	var context = drawingContext
	context.shadowOffsetX = sin(xmotion*2)/2;
	context.shadowOffsetY = cos(ymotion*2)/2;
	context.shadowBlur = 16; // more can be fun also
	context.shadowColor = ""rgba(0, 0, 0, 0.125)"";
	
	let planes = 4;

	let sw = 5;
	let sh = 5;
	
	let xp_offset = 0;
	let yp_offset = 0;
	
	let w = width;
	let h = height;
	
	for (let p = 2; p <= planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let ainp = 1-np;
		
		let sf = pow(256, ainp*2)/ 8;
		let sf2 = pow(92, ainp)/16;

		push();
		translate(width / 2, height / 2);

		let sx = max(0.0, sf2 - xmotion/148)
		if (sx <= 0.1/pow(p, 1)) continue;
		scale(sx, sx);

			let offset = 1;
		for (let y = 0; y <= h; y += sw) {
			for (let x = 0; x <= w; x += sh) {
				
				if (x <= 0 || x >= w || y <= 0 || y >= h) { // checkerboard pattern
					let nx = abs(0.5 - x / w) * 2;
					let ny = abs(0.5 - y / h) * 2;
				
					
				
					let no = noise(nx * 0.5, ny * 0.5);
					//let no2 = noise(p*x*y/10/p);
					//if (no2 > 0.5) continue
					rotate(sf*512 * (nx*ny)+offset+(1 - frameCount /200000));
					let ss = abs(sin((1-nx * ny) * PI * 1 + inp * PI * 2 + xmotion / 1/p)) * 16.0;
					
					let si=  abs(sin(frameCount/50))
				
					if (si <= 0.01) offset +=0.15;
					
					stroke(0, 0, 0, sf / 2);
					strokeWeight(0.25);
					fill((ss * 90 * ainp/30) % 360 + sx, 32 + 92 * sf + ainp * 64, 220 * np *(frameCount/200), sf / 0.025);
					
					let vw = sw * ss - frameCount/13.5;
					let vh = sh * ss - frameCount/13.5;
					
					if (vw > 0 && vh > 0) {
						if (noise(nx * 2, ny * 2) > 0.5) {
							rect(-width / 2 + (x + abs(cos(xmotion / 8 + ainp * PI * 2)) * 10 * no+offset/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y + abs(sin(ymotion / 8 + ainp * PI * 2)) * 10 * no+offset /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						} else {
							ellipse(-width / 2 + (x + abs(cos(xmotion / 8 + ainp * PI * 2)) * 10 * no+offset/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y + abs(sin(ymotion / 8 + ainp * PI * 2)) * 10 * no+offset /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						}
					}
				}
			}
		}
		pop();
	}
	
	xmotion += 0.25;
	ymotion += 0.25;
}"
"1241333","Stacking patterns sp2 twist reduced","mySketch","// same as parallax checkerboard with static render goal

function setup() {
	createCanvas(960, 960);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseDetail(6, 0.7);
	
	noStroke();
	
	rectMode(CENTER);
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	//background(0);
	noStroke();
	//fill(0, 0, 0, 0.05);
	//rect(0, 0, width, height);
	
	var context = drawingContext
	context.shadowOffsetX = sin(xmotion*2)/2;
	context.shadowOffsetY = cos(ymotion*2)/2;
	context.shadowBlur = 16; // more can be fun also
	context.shadowColor = ""rgba(0, 0, 0, 0.125)"";
	
	let planes = 4;

	let sw = 5;
	let sh = 5;
	
	let xp_offset = 0;
	let yp_offset = 0;
	
	let w = width;
	let h = height;
	
	for (let p = 2; p <= planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let ainp = 1-np;
		
		let sf = pow(256, ainp*2)/ 8;
		let sf2 = pow(92, ainp)/16;

		push();
		translate(width / 2, height / 2);

		let sx = max(0.0, sf2 - xmotion/148)
		if (sx <= 0.1/pow(p, 1)) continue;
		scale(sx, sx);

			let offset = 1;
		for (let y = 0; y <= h; y += sw) {
			for (let x = 0; x <= w; x += sh) {
				
				if (x <= 0 || x >= w || y <= 0 || y >= h) { // checkerboard pattern
					let nx = abs(0.5 - x / w) * 2;
					let ny = abs(0.5 - y / h) * 2;
				
					
				
					let no = noise(nx * 0.5, ny * 0.5);
					//let no2 = noise(p*x*y/10/p);
					//if (no2 > 0.5) continue
					rotate(sf*512 * (nx*ny)+offset+(1 - frameCount /200000));
					let ss = abs(sin((1-nx * ny) * PI * 2 + inp * PI * 2 + xmotion / 8/p)) * 16.0;
					
					let si=  abs(sin(frameCount/50))
				
					if (si <= 0.01) offset +=0.15;
					
					stroke(0, 0, 0, sf / 2);
					strokeWeight(0.25);
					fill((ss * 90 * ainp/30) % 360 + sx, 32 + 92 * sf + ainp * 64, 220 * np *(frameCount/200), sf / 0.025);
					
					let vw = sw * ss - frameCount/13.5;
					let vh = sh * ss - frameCount/13.5;
					
					if (vw > 0 && vh > 0) {
						if (noise(nx * 2, ny * 2) > 0.5) {
							rect(-width / 2 + (x + abs(cos(xmotion / 8 + ainp * PI * 2)) * 10 * no+offset/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y + abs(sin(ymotion / 8 + ainp * PI * 2)) * 10 * no+offset /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						} else {
							ellipse(-width / 2 + (x + abs(cos(xmotion / 8 + ainp * PI * 2)) * 10 * no+offset/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y + abs(sin(ymotion / 8 + ainp * PI * 2)) * 10 * no+offset /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						}
					}
				}
			}
		}
		pop();
	}
	
	xmotion += 0.25;
	ymotion += 0.25;
}"
"1241330","Stacking patterns sp3","mySketch","// same as parallax checkerboard with static render goal

function setup() {
	createCanvas(960, 960);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseDetail(6, 0.7);
	
	noStroke();
	
	rectMode(CENTER);
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	//background(0);
	noStroke();
	//fill(0, 0, 0, 0.05);
	//rect(0, 0, width, height);
	
	var context = drawingContext
	context.shadowOffsetX = sin(xmotion*2)/2;
	context.shadowOffsetY = cos(ymotion*2)/2;
	context.shadowBlur = 16; // more can be fun also
	context.shadowColor = ""rgba(0, 0, 0, 0.125)"";
	
	let planes = 6;

	let sw = 20;
	let sh = 20;
	
	let xp_offset = 0;
	let yp_offset = 0;
	
	let w = width;
	let h = height;
	
	for (let p = 2; p <= planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let ainp = 1-np;
		
		let sf = pow(256, ainp*2)/ 1;
		let sf2 = pow(92, ainp)/16;

		push();
		translate(width / 2, height / 2);

		let sx = max(0.0, sf2 - xmotion/148)
		//if (sx <= 0.15/pow(p, 1)) continue;
		scale(sx, sx);

			let offset = 1;
		for (let y = 0; y <= h; y += sw) {
			for (let x = 0; x <= w; x += sh) {
				
				if (x <= 0 || x >= w || y <= 0 || y >= h) { // checkerboard pattern
					let nx = abs(0.5 - x / w) * 2;
					let ny = abs(0.5 - y / h) * 2;
				
					
				
					let no = noise(nx * 100, ny * 100);
				//	if (no > 0.75) continue

					//let no2 = noise(p*x*y/10/p);
					//if (no2 > 0.5) continue
					rotate(p/1000);
					//if (x&y > width / 2) continue
					let ss = abs(sin((1-nx * ny) * PI * 8 + inp * PI * 0.5 + xmotion / 8)) * 16.0;
					
					let si=  abs(sin(frameCount/40))
				
					if (si <= 0.01) offset +=2;
					
					stroke(0, 0, 0, sf / 2);
					strokeWeight(0.5);
					fill((0 + ss * 100 * ainp/20) % 360, 32 + 32 * sf + ainp * 64, 220 * np *(frameCount/200), sf / 0.025);
					
					let vw = sw * ss - frameCount/4.5;
					let vh = sh * ss - frameCount/4.5;
					
					if (vw > 0 && vh > 0) {
						if (noise(nx * 2, ny * 2) > 0.5) {
							rect(-width / 2 + (x + abs(cos(xmotion / 8 + ainp * PI * 2)) * 10 * no/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y + abs(sin(ymotion / 8 + ainp * PI * 2)) * 10 * no /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						} else {
							ellipse(-width / 2 + (x + abs(cos(xmotion / 8 + ainp * PI * 2)) * 10 * no/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y + abs(sin(ymotion / 8 + ainp * PI * 2)) * 10 * no /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						}
					}
				}
			}
		}
		pop();
	}
	
	xmotion += 0.25;
	ymotion += 0.25;
}"
"1241319","Stacking patterns sp2","mySketch","// same as parallax checkerboard with static render goal

function setup() {
	createCanvas(960, 960);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseDetail(6, 0.7);
	
	noStroke();
	
	rectMode(CENTER);
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	//background(0);
	noStroke();
	//fill(0, 0, 0, 0.05);
	//rect(0, 0, width, height);
	
	var context = drawingContext
	context.shadowOffsetX = sin(xmotion*2)/2;
	context.shadowOffsetY = cos(ymotion*2)/2;
	context.shadowBlur = 16; // more can be fun also
	context.shadowColor = ""rgba(0, 0, 0, 0.125)"";
	
	let planes = 6;

	let sw = 5;
	let sh = 5;
	
	let xp_offset = 0;
	let yp_offset = 0;
	
	let w = width;
	let h = height;
	
	for (let p = 2; p <= planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let ainp = 1-np;
		
		let sf = pow(256, ainp*2)/ 8;
		let sf2 = pow(92, ainp)/16;

		push();
		translate(width / 2, height / 2);

		let sx = max(0.0, sf2 - xmotion/148)
		if (sx <= 0.1/pow(p, 8)) continue;
		scale(sx, sx);

			let offset = 1;
		for (let y = 0; y <= h; y += sw) {
			for (let x = 0; x <= w; x += sh) {
				
				if (x <= 0 || x >= w || y <= 0 || y >= h) { // checkerboard pattern
					let nx = abs(0.5 - x / w) * 2;
					let ny = abs(0.5 - y / h) * 2;
				
					
				
					let no = noise(nx * 0.5, ny * 0.5);
					//let no2 = noise(p*x*y/10/p);
					//if (no2 > 0.5) continue
					rotate(sf*512 * (nx*ny)+offset);
					let ss = abs(sin((1-nx * ny) * PI * 2 + inp * PI * 2 + xmotion / 8/p)) * 16.0;
					
					let si=  abs(sin(frameCount/50))
				
					if (si <= 0.01) offset +=0.15;
					
					stroke(0, 0, 0, sf / 2);
					strokeWeight(0.25);
					fill((ss * 90 * ainp/30) % 360 + sx, 32 + 92 * sf + ainp * 64, 220 * np *(frameCount/500), sf / 0.025);
					
					let vw = sw * ss - frameCount/13.5;
					let vh = sh * ss - frameCount/13.5;
					
					if (vw > 0 && vh > 0) {
						if (noise(nx * 2, ny * 2) > 0.5) {
							rect(-width / 2 + (x + abs(cos(xmotion / 8 + ainp * PI * 2)) * 10 * no+offset/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y + abs(sin(ymotion / 8 + ainp * PI * 2)) * 10 * no+offset /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						} else {
							ellipse(-width / 2 + (x + abs(cos(xmotion / 8 + ainp * PI * 2)) * 10 * no+offset/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y + abs(sin(ymotion / 8 + ainp * PI * 2)) * 10 * no+offset /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						}
					}
				}
			}
		}
		pop();
	}
	
	xmotion += 0.25;
	ymotion += 0.25;
}"
"1241317","Stacking patterns sp1","mySketch","// same as parallax checkerboard with static render goal

function setup() {
	createCanvas(960, 960);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseDetail(6, 0.7);
	
	noStroke();
	
	rectMode(CENTER);
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	//background(0);
	noStroke();
	//fill(0, 0, 0, 0.05);
	//rect(0, 0, width, height);
	
	var context = drawingContext
	context.shadowOffsetX = sin(xmotion*2)/2;
	context.shadowOffsetY = cos(ymotion*2)/2;
	context.shadowBlur = 16; // more can be fun also
	context.shadowColor = ""rgba(0, 0, 0, 0.125)"";
	
	let planes = 6;

	let sw = 5;
	let sh = 5;
	
	let xp_offset = 0;
	let yp_offset = 0;
	
	let w = width;
	let h = height;
	
	for (let p = 2; p <= planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let ainp = 1-np;
		
		let sf = pow(256, ainp*2)/ 4;
		let sf2 = pow(92, ainp)/16;

		push();
		translate(width / 2+p+sin(xmotion/10+p*10)*20, height / 2+cos(xmotion/10+p*10)*20);

		let sx = max(0.0, sf2 - xmotion/148)
		if (sx <= 0.25/pow(p, 1)) continue;
		scale(sx, sx);

			let offset = 1;
		for (let y = 0; y <= h; y += sw) {
			for (let x = 0; x <= w; x += sh) {
				
				if (x <= 0 || x >= w || y <= 0 || y >= h) { // checkerboard pattern
					let nx = abs(0.5 - x / w) * 2;
					let ny = abs(0.5 - y / h) * 2;
				
					
				
					let no = noise(nx * 0.5, ny * 0.5);
					//let no2 = noise(p*x*y/10/p);
					//if (no2 > 0.5) continue
					rotate(sf*512 * (nx*ny)+offset);
					let ss = abs(sin((1-nx * ny) * PI * 1 + inp * PI * 0.5 + xmotion / 8)) * 16.0;
					
					let si=  abs(sin(frameCount/40))
				
					if (si <= 0.01) offset +=4;
					
					stroke(0, 0, 0, sf / 2);
					strokeWeight(0.5);
					fill((10 + ss * 100 * ainp/20) % 360, 32 + 64 * sf + ainp * 64, 220 * np *(frameCount/200), sf / 0.025);
					
					let vw = sw * ss - frameCount/13.5;
					let vh = sh * ss - frameCount/13.5;
					
					if (vw > 0 && vh > 0) {
						if (noise(nx * 2, ny * 2) > 0.5) {
							rect(-width / 2 + (x + abs(cos(xmotion / 8 + ainp * PI * 2)) * 10 * no/offset/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y + abs(sin(ymotion / 8 + ainp * PI * 2)) * 10 * no/offset /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						} else {
							ellipse(-width / 2 + (x + abs(cos(xmotion / 8 + ainp * PI * 2)) * 10 * no/offset/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y + abs(sin(ymotion / 8 + ainp * PI * 2)) * 10 * no/offset /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						}
					}
				}
			}
		}
		pop();
	}
	
	xmotion += 0.25;
	ymotion += 0.25;
}"
"1240565","Bits 3","mySketch","function setup() {
	pixelDensity(1)
	createCanvas(512, 512)
	
	background(0)
	
	rectMode(CORNERS)
}

//floor(map(mouseX, 0, width, 1, 8));
function draw() {
/*
	stroke(255)
	fill(0)
	rect(0, 0, width, height)
*/
	background(0)
	
	loadPixels()
	
	let p = floor(map(mouseX, 0, width, 1, 256))
	
	//frameCount = 0
/*
	for (let l = 1; l < 10; l += 1) {
		for (let i = 0; i < width * height / 8; i += 1) {
			let x = i % 32 + l * 10 + frameCount//floor(frameCount / (1 + (10-l) / 10))
			let y = floor(i / 32 + frameCount*8)
			x += (y * 8) * 32
			// 45°
			//x += floor(i / 64) & 64
			x += floor(i / 64) & 64

			let index = x*4
			
			index %= width * height * 4

			pixels[index] = abs(((l+15) % 20) - 10) * (255 / 11);//l * (255 / 9)
			
			//let index2 = (x*4)^(y*64)
			//pixels[index2] &= l * 64
		}
	}
*/
	
	let xx = 0
	let yy = 0
	for (let i = 0; i < width * height; i += 1) {
		let x = i & 511
		let y = i >> 9
		
		//let index = (((x - y * frameCount/256) & (x * frameCount/256 + y)) + (y << 9)) << 2
		//xx += (x & (y + frameCount))
		//yy += (y & (x + frameCount))
		xx = x & (0xfff) // 0xfff
		yy = (y + i) ^ i >> 1
		
		yy -= x ^ ((i&0xeff) >> (y >> 16))
		xx -= (y & 0xff) - frameCount
		
		let index = ((yy & 511) + ((xx & 511) << 9)) << 2
	
		let c = 255 & y // (i|xx) // (i/xx)
		
		if (index >= 0 && index < width * height * 4) {
			pixels[index + 0] = c
			pixels[index + 1] = c
			pixels[index + 2] = c
		}
	}
/*
	for (let i = 0; i < width * height; i += 1) {
		let x = i & 511
		let y = i >> 9
		
		let index = (x + (y << 9)) << 2
		
		let c = ((x ^ y) & 255) | 63
		
		pixels[index + 0] = c
		pixels[index + 1] = c
		pixels[index + 2] = c
	}
*/
	updatePixels()
}

"
"1239864","minsky overflow tilable","mySketch","function setup() {
	pixelDensity(1);
	createCanvas(1024, 1024)
	
	background(0)
	
	rectMode(CORNERS)
}

//floor(map(mouseX, 0, width, 1, 8));
function draw() {
/*
	stroke(255)
	fill(0)
	rect(0, 0, width, height)
*/
	background(0)
	
	loadPixels()
	
	let p = floor(map(mouseX, 0, width, 1, 20000000))
	
	//frameCount = 0
/*
	for (let l = 1; l < 10; l += 1) {
		for (let i = 0; i < width * height / 8; i += 1) {
			let x = i % 32 + l * 10 + frameCount//floor(frameCount / (1 + (10-l) / 10))
			let y = floor(i / 32 + frameCount*8)
			x += (y * 8) * 32
			// 45°
			//x += floor(i / 64) & 64
			x += floor(i / 64) & 64

			let index = x*4
			
			index %= width * height * 4

			pixels[index] = abs(((l+15) % 20) - 10) * (255 / 11);//l * (255 / 9)
			
			//let index2 = (x*4)^(y*64)
			//pixels[index2] &= l * 64
		}
	}
*/
	
	let t = frameCount
	
	let xx = 10
	let yy = 0
	for (let i = 0; i < width*height; i += 1) {
		let x = i & 1023
		let y = i >> 9
		
		//let index = (((x - y * frameCount/256) & (x * frameCount/256 + y)) + (y << 9)) << 2
		//xx += (x & (y + frameCount))
		//yy += (y & (x + frameCount))
		xx -= (yy / 3) + p
		//xx %= 65536
		yy += (xx / 1)
		yy %= 65536
		xx -= (yy / 3) + p
		xx %= 65536
		
		let px = (((xx >> 6) + width / 2) & 1023)
		if (px >= width / 2) continue
	
		let py = (((yy >> 6) + height/2) & 1023)
		if (py < height / 2) continue
		
		let index1 = (px + (py << 10)) << 2
		let index2 = (~px + (py << 10)) << 2
	
		let c = 48 // (i|xx) // (i/xx)
		
		let len = width * height * 4
		
		if (index1 >= 0 && index1 < len) {
			pixels[index1 + 0] += c
			pixels[index1 + 1] += c
			pixels[index1 + 2] += c
			pixels[index2 + 0] += c
			pixels[index2 + 1] += c
			pixels[index2 + 2] += c
			
			index1 = len - index1
			index2 = len - index2
			
			pixels[index1 + 0] += c
			pixels[index1 + 1] += c
			pixels[index1 + 2] += c
			pixels[index2 + 0] += c
			pixels[index2 + 1] += c
			pixels[index2 + 2] += c
		}
	}
/*
	for (let i = 0; i < width * height; i += 1) {
		let x = i & 511
		let y = i >> 9
		
		let index = (x + (y << 9)) << 2
		
		let c = ((x ^ y) & 255) | 63
		
		pixels[index + 0] = c
		pixels[index + 1] = c
		pixels[index + 2] = c
	}
*/
	updatePixels()
}

"
"1239857","Bits 2","mySketch","function setup() {
	createCanvas(1024, 1024)
	
	background(0)
	
	rectMode(CORNERS)
}

//floor(map(mouseX, 0, width, 1, 8));
function draw() {
/*
	stroke(255)
	fill(0)
	rect(0, 0, width, height)
*/
	background(0)
	
	loadPixels()
	
	let p = floor(map(mouseX, 0, width, 1, 200))
	
	//frameCount = 0
/*
	for (let l = 1; l < 10; l += 1) {
		for (let i = 0; i < width * height / 8; i += 1) {
			let x = i % 32 + l * 10 + frameCount//floor(frameCount / (1 + (10-l) / 10))
			let y = floor(i / 32 + frameCount*8)
			x += (y * 8) * 32
			// 45°
			//x += floor(i / 64) & 64
			x += floor(i / 64) & 64

			let index = x*4
			
			index %= width * height * 4

			pixels[index] = abs(((l+15) % 20) - 10) * (255 / 11);//l * (255 / 9)
			
			//let index2 = (x*4)^(y*64)
			//pixels[index2] &= l * 64
		}
	}
*/
	
	let t = frameCount
	
	let xx = 10
	let yy = 0
	for (let i = 0; i < width*height; i += 1) {
		let x = i & 1023
		let y = i >> 9
		
		//let index = (((x - y * frameCount/256) & (x * frameCount/256 + y)) + (y << 9)) << 2
		//xx += (x & (y + frameCount))
		//yy += (y & (x + frameCount))
		xx -= (yy / 16) + 1000000000000
		xx %= 65536
		yy += (xx / 8)
		yy %= 65536
		xx -= (yy / 16) + 1000000000000
		xx %= 65536
		
		let px = (((xx >> 6) + width / 2) & 1023)
		if (px >= width / 2) continue;
		
		let index1 = (px + ((((yy >> 6)) & 1023) << 10)) << 2
		let index2 = (~px + ((((yy >> 6)) & 1023) << 10)) << 2
	
		let c = 48 // (i|xx) // (i/xx)
		
		if (index1 >= 0 && index1 < width * height * 4) {
			pixels[index1 + 0] += c
			pixels[index1 + 1] += c
			pixels[index1 + 2] += c
			pixels[index2 + 0] += c
			pixels[index2 + 1] += c
			pixels[index2 + 2] += c
		}
	}
/*
	for (let i = 0; i < width * height; i += 1) {
		let x = i & 511
		let y = i >> 9
		
		let index = (x + (y << 9)) << 2
		
		let c = ((x ^ y) & 255) | 63
		
		pixels[index + 0] = c
		pixels[index + 1] = c
		pixels[index + 2] = c
	}
*/
	updatePixels()
}

"
"1239570","Bits","mySketch","function setup() {
	createCanvas(512, 512)
	
	background(0)
	
	rectMode(CORNERS)
}

//floor(map(mouseX, 0, width, 1, 8));
function draw() {
/*
	stroke(255)
	fill(0)
	rect(0, 0, width, height)
*/
	background(0)
	
	loadPixels()
	
	let p = floor(map(mouseX, 0, width, 1, 200))
	
	//frameCount = 0
/*
	for (let l = 1; l < 10; l += 1) {
		for (let i = 0; i < width * height / 8; i += 1) {
			let x = i % 32 + l * 10 + frameCount//floor(frameCount / (1 + (10-l) / 10))
			let y = floor(i / 32 + frameCount*8)
			x += (y * 8) * 32
			// 45°
			//x += floor(i / 64) & 64
			x += floor(i / 64) & 64

			let index = x*4
			
			index %= width * height * 4

			pixels[index] = abs(((l+15) % 20) - 10) * (255 / 11);//l * (255 / 9)
			
			//let index2 = (x*4)^(y*64)
			//pixels[index2] &= l * 64
		}
	}
*/
	
	let xx = 0
	let yy = 0
	for (let i = 0; i < width * height; i += 1) {
		let x = i & 511
		let y = i >> 9
		
		//let index = (((x - y * frameCount/256) & (x * frameCount/256 + y)) + (y << 9)) << 2
		//xx += (x & (y + frameCount))
		//yy += (y & (x + frameCount))
		xx = x & 0xfff // 0xfff
		yy = (y + (i >> 16)) ^ x >> 16
		
		yy -= x ^ ((i&0xeff) >> (y >> 1))
		xx += (y & 0xf) + frameCount
		
		let index = ((yy & 511) + ((xx & 511) << 9)) << 2
	
		let c = 255 & i // (i|xx) // (i/xx)
		
		if (index >= 0 && index < width * height * 4) {
			pixels[index + 0] = c
			pixels[index + 1] = c
			pixels[index + 2] = c
		}
	}
/*
	for (let i = 0; i < width * height; i += 1) {
		let x = i & 511
		let y = i >> 9
		
		let index = (x + (y << 9)) << 2
		
		let c = ((x ^ y) & 255) | 63
		
		pixels[index + 0] = c
		pixels[index + 1] = c
		pixels[index + 2] = c
	}
*/
	updatePixels()
}

"
"1236859","Apollonian float 2 rt","mySketch","// with float

let x = 0, y = 0, frame = 200000000, index = 0, index2 = 0;
function setup() {
	createCanvas(1024, 940);
	
	background(0);
}

function draw() {
	
	if (frameCount % 1 == 0) {
		background(0);
		x = 0; y = 0; frame = 200000000; index = 0; index2 = 0;
	}
	
	loadPixels();
	
	let params = [28, // increase for more details (aka iteration)
								8,
								6, // scale
								18, // 13 for less details
								4,24,12,22];

	for(let iter = 0; iter < 1422000; iter += 1) {
		let r = (2.0 + frameCount  /1000) % 10
		x = (x + (x >> params[0])) - (y * r) + ((frame >> params[1]));
		y = (y - (x >> params[2])) + (floor(x /((1+abs(r/1.747 - frameCount  /1000))%10)) - (y >> params[3])) - ((frame >> params[4]) & ((x << params[5])));
		x = (x + (x >> params[6])) - (y * r) + ((frame >> params[1]));

    index = (((width >> 1) + (x >> params[7])) + ((height >> 1) + (y >> (params[7]))) * width) * 4;

		// smoother greyscale / colors
    let rf = (frame >> 23) & 3;
    let gf = (frame >> 22) & 3;
    let bf = (frame >> 24) & 3;

		pixels[index + 1] += 5;
		pixels[index + 2] += 5;
		pixels[index + 0] += 5;

    frame += 0.01;
	}

	updatePixels();
}

"
"1236855","Apollonian float 2","mySketch","// with float

let x = 0, y = 0, frame = 200000000, index = 0, index2 = 0;
function setup() {
	createCanvas(1024, 940);
	
	background(0);
}

function draw() {
	loadPixels();
	
	if (frameCount > 8) return
	
	let params = [28, // increase for more details (aka iteration)
								26,
								5, // scale
								14, // 13 for less details
								6,28,12,22];
	
	let d = pixelDensity();

	for(let iter = 0; iter < 422000; iter += 1) {
		let r = 2.7425 - frame  /390000000
		x = (x + (x >> params[0])) - (y * r) + ((frame >> params[1]));
		y = (y - (x >> params[2])) + (floor(x /(r/1.747)) - (y >> params[3])) - ((frame >> params[4]) & ((x << params[5])));
		x = (x + (x >> params[6])) - (y * r) + ((frame >> params[1]));

    index = (((width >> 1) + (x >> params[7])) + ((height >> 1) + (y >> (params[7]))) * width) * 4 * d;
		
		if (index >= 0 && index < width * height * 4 * d) {
			// smoother greyscale / colors
			let rf = (frame >> 23) & 3;
			let gf = (frame >> 22) & 3;
			let bf = (frame >> 24) & 3;

			pixels[index + 1] += 5;
			pixels[index + 2] += 5;
			pixels[index + 0] += 5;
		}

    frame += 1;
	}

	updatePixels();
}

"
"1236674","Apollonian float","mySketch","// with float

let x = 0, y = 0, frame = 200000000, index = 0, index2 = 0;
function setup() {
	createCanvas(1024, 900);
	
	background(0);
}

function draw() {
	loadPixels();
	
	if (frameCount > 50) return
	
	let params = [28, // increase for more details (aka iteration)
								24,
								5, // scale
								13, // 13 for less details
								8,20,12,22];

	for(let iter = 0; iter < 422000; iter += 1) {
		let r = 2.15
		x = (x + (x >> params[0])) - (y * r) + ((frame >> params[1]));
		y = (y - (x >> params[2])) + (floor(x /(r/1.75)) - (y >> params[3])) - ((frame >> params[4]) & ((x << params[5])));
		x = (x + (x >> params[6])) - (y * r) + ((frame >> params[1]));

    index = (((width >> 1) + (x >> params[7])) + ((height >> 1) + (y >> (params[7]))) * width) * 4;

		// smoother greyscale / colors
    let rf = (frame >> 23) & 3;
    let gf = (frame >> 22) & 3;
    let bf = (frame >> 24) & 3;

		pixels[index + 1] += 1;
		pixels[index + 2] += 1;
		pixels[index + 0] += 1;

    frame += 1;
	}

	updatePixels();
}

"
"1234923","Wooden walls 2","mySketch","// digging the oldies, trying to do some materials (wood) with feedback / aa automaton tech
// the differences with the early ones is mostly on how color is handled (by somewhat using a 'wood' palette) by the noise function
// the noise also is acting bit differently and i guess some others materials could be done by just tweaking the noise (replacing it with white noise for example is bit like sand)
// maybe more controls / advanced materials could be done by having some sort of metadata
// associated to the 'structure' (the lines) which would also be propagated (and thus individual structures could have different materials!)

int reset = 0;
int perlin_amount = 1;

void draw_func() {
	noStroke();
	
	loadPixels();
	for (int y = 0; y < height; y += 1) {
		int yy = y * width;
		for (int x = 0; x < width; x += 1) {
			color p = pixels[yy + x];
			
			float xm = 0;
			float ym = 92 - (frameCount - reset);
			
			if ((brightness(p) > xm && brightness(p) < ym)) {
				float normx = (float)x / width;
				float normy = (float)y / height;
				float anormx = 1.0 - abs(0.5 - normx) * 2;
				float anormy = 1.0 - abs(0.5 - normy) * 2;
				
				float xk = frameCount / 2;
				float yk = frameCount / 2;
				
				float n = abs(0.5 - noise(anormx*xk,anormy*yk)) * 2;
				
				fill(/*0+hue(p)/4, saturation(p)+4, */20 + 10 * abs(n), 256 * 0.52 - abs(n) * 10, brightness(p)*(18 + 8 * abs(n)), 24);
				
				ellipse(x + n, y + n-1, 2, 2);
				ellipse(width - x + n, y + n-1, 2, 2);
			}
		}
	}
}

void setup() {
  size(800, 800);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	noiseDetail(6,0.65);
	
	rectMode(CENTER);
	
	frameRate(60);
	
		stroke(0, 0, 255, 4);
		strokeWeight(1);
		noFill();
		for (int i = 1; i < 16; i += 1) {
			float ni = (i - 1) / 16;
			float ix = 0.3+pow(ni, 4);
			rect(width / 2, height / 2, width * ix, height * ix);

			//bezier(random(width/2), random(height/2), random(width/2), random(height/2), random(width/2), random(height/2), random(width/2), random(height/2));
		}
	
	for (int i = 0; i < 12; i += 1) {
		float ni = i / 11;
		
		line(0, ni * height, width / 3, height / 3 + height / 3 * ni);
		line(ni * height, 0, height / 3 + height / 3 * ni, width / 3);
	}
	line(0, height - 1, width, height - 1);
}

void mouseClicked() {
	background(0);
	
	reset = frameCount;
	
	perlin_amount = random(2, 4);
}

void draw() {
  draw_func();
}"
"1233760","Wooden walls","mySketch","// digging the oldies, trying to do some materials (wood) with feedback / aa automaton tech
// the differences with the early ones is mostly on how color is handled (by somewhat using a 'wood' palette) by the noise function
// the noise also is acting bit differently and i guess some others materials could be done by just tweaking the noise (replacing it with white noise for example is bit like sand)
// maybe more controls / advanced materials could be done by having some sort of metadata
// associated to the 'structure' (the lines) which would also be propagated (and thus individual structures could have different materials!)

let reset = 0;
let perlin_amount = 1;

function draw_func() {
	noStroke();
	
	loadPixels();
	for (let y = 0; y < height; y += 1) {
		let yy = y * width;
		for (let x = 0; x < width; x += 1) {
			let p = pixels[(yy + x) * 4];
			
			let xm = 0;
			let ym = 92 - (frameCount - reset);
			
			if ((p > xm && p < ym)) {
				let normx = x / width;
				let normy = y / height;
				let anormx = 1.0 - abs(0.5 - normx) * 2;
				let anormy = 1.0 - abs(0.5 - normy) * 2;
				
				let xk = frameCount / 2;
				let yk = frameCount / 2;
				
				let n = abs(0.5 - noise(anormx*xk,anormy*yk)) * 2;
				
				fill(/*0+hue(p)/4, saturation(p)+4, */20 + 10 * abs(n), 256 * 0.52 - abs(n) * 10, p*(18 + 8 * abs(n)), 24);
				
				ellipse(x + n, y + n, 2, 2);
				ellipse(width - x + n, y + n, 2, 2);
			}
		}
	}
}

function setup() {
  createCanvas(800, 800);

  background(0);
	
	colorMode(HSB, 360, 256, 256, 255);
	
	noiseDetail(6,0.65);
	
	rectMode(CENTER);
	
	frameRate(60);
	
		stroke(0, 0, 255, 4);
		strokeWeight(1);
		noFill();
		for (let i = 1; i < 16; i += 1) {
			let ni = (i - 1) / 16;
			let ix = 0.3+pow(ni, 4);
			rect(width / 2, height / 2, width * ix, height * ix);

			//bezier(random(width/2), random(height/2), random(width/2), random(height/2), random(width/2), random(height/2), random(width/2), random(height/2));
		}
	
	for (let i = 0; i < 12; i += 1) {
		let ni = i / 11;
		
		line(0, ni * height, width / 3, height / 3 + height / 3 * ni);
		line(ni * height, 0, height / 3 + height / 3 * ni, width / 3);
	}
}

function mouseClicked() {
	background(0);
	
	reset = frameCount;
	
	perlin_amount = random(2, 4);
}

function draw() {
  draw_func();
}"
"1231375","Multi Minsky 2","mySketch","// trying 16 bits

// xy pairs
let minskies = [0, 0, 0, 0, 0, 0]
let frame = 0;

setup = () => {
	createCanvas(800, 800);
	
	background(0);
}

// draw
let d = (px, py, t) => {
		px += width / 2
		py += height / 2
		
		if (px < 0 || py < 0) return
		if (px > width || py > height) return
		
		let index = (px + py * width) * 4;
		
		if (index < 0) return
		if (index > width * height * 4) return

		pixels[index + 1] += (frame&(3+frameCount / 20 % 2))+(frameCount % 3);
		pixels[index + 2] += (frame&4)+(frameCount % 3);
		pixels[index + 0] += (frame&3)+(frameCount % 3);
}

minsky1 = (iter) => {
		minskies[0] -= (minskies[1]>>28)^(410)
		//x %= 65536
		minskies[1] += (minskies[0]>>1)
		//y %= 65536
		minskies[0] -= (minskies[1]>>2)-(minskies[0]>>10 + iter/500)
		//x %= 65536
		minskies[1] += (minskies[0]>>1)
		minskies[1] %= 65536
}

minsky2 = (iter) => {
		minskies[2] -= (minskies[3]>>28)^(200)
		//x %= 65536
		minskies[3] += (minskies[2]>>1)
		//y %= 65536
		minskies[2] -= (minskies[3]>>2)-(minskies[2]>>12 + iter/1000)
		//x %= 65536
		minskies[3] += (minskies[2]>>1)
		minskies[3] %= 65536
}

minsky3 = (iter) => {
		minskies[4] -= (minskies[5]>>28)^(2800)
		//x %= 65536
		minskies[5] += (minskies[4]>>1)
		//y %= 65536
		minskies[4] -= (minskies[5]>>2)-(minskies[4]>>8 + iter/500)
		//x %= 65536
		minskies[5] += (minskies[4]>>1)
		minskies[5] %= 65536
}

draw = () => {
	loadPixels();

	for(let iter = 0; iter < 100000; iter += 1) {
		minsky1(iter)
		minsky2(iter)
		minsky3(iter)
		
		let px1 = (minskies[0] >> 3)
		let py1 = (minskies[1] >> 4)
		let px2 = (minskies[2] >> 5)
		let py2 = (minskies[3] >> 6)
		let px3 = (minskies[4] >> 6)
		let py3 = (minskies[5] >> 7)
		
		let dst1 = dist(px1, py1, 0, 0)
		let dst2 = dist(px2, py2, 0, 0)
		let dst3 = dist(px3, py3, 0, 0)
		
		if (dst1 < width / 8) {
			//if (dst1 >= width / 64) {
				d(px1, py1/* - height / 5*/, frame)
			//}
		}
		
		if (dst2 < width / 2.55) {
			if (dst2 >= width / 7.5) {
				d(px2, py2/* - height / 5*/, frame)
			}
		}
		
		if (dst3 >= width / 2.5) {
			d(px3, py3/* - height / 5*/, frame)
		}

		frame += 1
	}

	updatePixels();
}"
"1231160","Multi Minsky","mySketch","// trying 16 bits

// xy pairs
let minskies = [0, 0, 0, 0, 0, 0]
let frame = 0;

setup = () => {
	createCanvas(800, 800);
	
	background(0);
}

// draw
let d = (px, py, t) => {
		px += width / 2
		py += height / 2
		
		if (px < 0 || py < 0) return
		if (px > width || py > height) return
		
		let index = (px + py * width) * 4;
		
		if (index < 0) return
		if (index > width * height * 4) return

		pixels[index + 1] += (frame&(3+frameCount / 20 % 2))+(frameCount % 3);
		pixels[index + 2] += (frame&4)+(frameCount % 3);
		pixels[index + 0] += (frame&3)+(frameCount % 3);
}

minsky1 = (iter) => {
		minskies[0] -= (minskies[1]>>28)^(100)
		//x %= 65536
		minskies[1] += (minskies[0]>>1)
		//y %= 65536
		minskies[0] -= (minskies[1]>>2)-(minskies[0]>>12 + iter/50)
		//x %= 65536
		minskies[1] += (minskies[0]>>1)
		minskies[1] %= 65536
}

minsky2 = (iter) => {
		minskies[2] -= (minskies[3]>>28)^(1000)
		//x %= 65536
		minskies[3] += (minskies[2]>>1)
		//y %= 65536
		minskies[2] -= (minskies[3]>>2)-(minskies[2]>>12 + iter/50)
		//x %= 65536
		minskies[3] += (minskies[2]>>1)
		minskies[3] %= 65536
}

minsky3 = (iter) => {
		minskies[4] -= (minskies[5]>>28)^(4000)
		//x %= 65536
		minskies[5] += (minskies[4]>>1)
		//y %= 65536
		minskies[4] -= (minskies[5]>>2)-(minskies[4]>>8 + iter/50)
		//x %= 65536
		minskies[5] += (minskies[4]>>1)
		minskies[5] %= 65536
}

draw = () => {
	loadPixels();

	for(let iter = 0; iter < 100000; iter += 1) {
		minsky1(iter)
		minsky2(iter)
		minsky3(iter)
		
		let px1 = (minskies[0] >> 3)
		let py1 = (minskies[1] >> 4)
		let px2 = (minskies[2] >> 5)
		let py2 = (minskies[3] >> 6)
		let px3 = (minskies[4] >> 6)
		let py3 = (minskies[5] >> 7)
		
		let dst1 = dist(px1, py1, 0, 0)
		let dst2 = dist(px2, py2, 0, 0)
		let dst3 = dist(px3, py3, 0, 0)
		
		if (dst1 < width / 8) {
			if (dst1 >= width / 64) {
				d(px1, py1/* - height / 5*/, frame)
			}
		}
		
		if (dst2 < width / 2.55) {
			if (dst2 >= width / 7.5) {
				d(px2, py2/* - height / 5*/, frame)
			}
		}
		
		if (dst3 >= width / 2.5) {
			d(px3, py3/* - height / 5*/, frame)
		}

		frame += 1
	}

	updatePixels();
}"
"1231156","Apollonian 256b prototype","mySketch","// Apollonian prototype
// This is a prototype of a 256 bytes executable graphics presented at the Shadow Party 2021
// This code was converted to C, the final version which is 256 bytes in size (single executable) output graphics on Linux framebuffer with SIMD saturated arithmetic
// https://www.pouet.net/prod.php?which=89067

let x = 0, y = 0, frame = 15000000, index = 0, index2 = 0;
function setup() {
	pixelDensity(1);
	createCanvas(1024, 900);
	
	background(0);
}

function draw() {
	loadPixels();
	
	let params = [28, // increase for more details (aka iteration)
								24,
								5, // scale
								12, // 13 for less details
								6,18,12,22];
  let d = pixelDensity();
	
	for(let iter = 0; iter < 222000; iter += 1) {
		x = (x + (x >> params[0])) - (y << 2) + ((frame >> params[1]));
		y = (y - (x >> params[2])) + ((x >> 1) - (y >> params[3])) - ((frame >> params[4]) & ((x << params[5])));
		x = (x + (x >> params[6])) - (y << 2) + ((frame >> params[1]));

    index = (((width >> 1) + (x >> params[7])) + ((height >> 1) + (y >> (params[7]))) * width) * 4 * d;

/*
		// colors like final
    int r = (frame >> 23) & 3;
    int g = (frame >> 22) & 3;
    int b = (frame >> 24) & 3;
*/
		
		var rf = 3&iter;
		var gf = 2;
		var bf = 1;
		
		pixels[index + 1] += rf;
		pixels[index + 2] += gf;
		pixels[index + 0] += bf;

    frame += 1;
	}

	updatePixels();
}

"
"1231143","Multi Minsky greyscale","mySketch","// trying 16 bits

// xy pairs
let minskies = [0, 0, 0, 0, 0, 0]
let frame = 0;

setup = () => {
	createCanvas(800, 800);
	
	background(255);
}

// draw
let d = (px, py, tn, d) => {
		px += width / 2
		py += height / 2
		
		if (px < 0 || py < 0) return
		if (px > width || py > height) return
		
		let index = (px + py * width) * 4;
		
		if (index < 0) return
		if (index > width * height * 4) return

		pixels[index + 1] -= d
		pixels[index + 2] -= d
		pixels[index + 0] -= d
}

minsky1 = (iter) => {
		minskies[0] -= (minskies[1]>>28)^(1000)
		//x %= 65536
		minskies[1] += (minskies[0]>>1)
		//y %= 65536
		minskies[0] -= (minskies[1]>>2)-(minskies[0]>>6 + iter/500)
		//x %= 65536
		minskies[1] += (minskies[0]>>1)
		minskies[1] %= 65536*2
}

minsky2 = (iter) => {
		minskies[2] -= (minskies[3]>>28)^(1000)
		//x %= 65536
		minskies[3] += (minskies[2]>>1)
		//y %= 65536
		minskies[2] -= (minskies[3]>>2)-(minskies[2]>>12 + iter/500)
		//x %= 65536
		minskies[3] += (minskies[2]>>1)
		minskies[3] %= 65536*2
}

minsky3 = (iter) => {
		minskies[4] -= (minskies[5]>>28)^(2000)
		//x %= 65536
		minskies[5] += (minskies[4]>>1)
		//y %= 65536
		minskies[4] -= (minskies[5]>>2)-(minskies[4]>>24 + iter/500)
		//x %= 65536
		minskies[5] += (minskies[4]>>1)
		minskies[5] %= 65536*2
}

draw = () => {
	loadPixels();

	for(let iter = 0; iter < 100000; iter += 1) {
		minsky1(iter)
		minsky2(iter)
		minsky3(iter)
		
		let px1 = (minskies[0] >> 7)
		let py1 = (minskies[1] >> 8)
		let px2 = (minskies[2] >> 5)
		let py2 = (minskies[3] >> 6)
		let px3 = (minskies[4] >> 4)
		let py3 = (minskies[5] >> 5)
		
		let dst1 = dist(px1, py1, 0, 0)
		let dst2 = dist(px2, py2, 0, 0)
		let dst3 = dist(px3, py3, 0, 0)
		
		if (dst1 < width / 8) {
			if (dst1 >= width / 128) {
				d(px1, py1 - height / 5, frame, 1)
			}
		}
		
		if (dst2 < width / 2.5) {
			if (dst2 >= width / 8) {
				d(px2, py2 - height / 5, frame, 4)
			}
		}
		
		if (dst3 >= width / 2.5) {
			d(px3, py3 - height / 5, frame, 5)
		}

		frame += 1
	}

	updatePixels();
}"
"1230848","Minsky wide + colors cycle","mySketch","// trying 16 bits

let x = 10, y = 0, frame = 0, index = 0;
function setup() {
	createCanvas(windowWidth, windowHeight);
	
	background(0);
}

function draw() {
	loadPixels();
	
	for(let iter = 0; iter < 100000; iter += 1) {
		x -= (y>>28)^(500+(iter/y) + (index >> 12))
		//x %= 65536
		y += (x>>1)
		//y %= 65536
		x -= (y>>2)-(x>>6 + iter/50000)
		//x %= 65536
		y += (x>>1)
		y %= 65536
		index = (floor(width / 2.1 + (x >> 5)) + floor(height / 1.9 + (y >> 6)) * width) * 4;

		pixels[index + 1] += (frame >> 23) & 3//(frame&(1+frameCount / 20 % 2))+(frameCount % 3);
		pixels[index + 2] += (frame >> 22) & 3//(frame&3)+(frameCount % 3);
		pixels[index + 0] += (frame >> 24) & 3//(frame&1)+(frameCount % 3);

    frame += 1;
	}

	updatePixels();
}

function mouseReleased() {
	y += 1
	
	background(0)
}
"
"1230845","Minsky 4","mySketch","// trying 16 bits

let x = 10, y = 0, frame = 0, index = 0;
function setup() {
	createCanvas(windowWidth, windowHeight);
	
	background(0);
}

function draw() {
	loadPixels();
	
	for(let iter = 0; iter < 100000; iter += 1) {
		x -= (y>>28)^(2000)
		//x %= 65536
		y += (x>>1)
		//y %= 65536
		x -= (y>>2)-(x>>6 + iter/50)
		//x %= 65536
		y += (x>>1)
		y %= 65536
		index = (floor(width / 2.1 + (x >> 5)) + floor(height / 1.9 + (y >> 6)) * width) * 4;
		if (index < 0) index = 0
		if (index > width * height * 4) index = width * height * 4

		pixels[index + 1] += (frame&(3+frameCount / 20 % 2))+(frameCount % 3);
		pixels[index + 2] += (frame&4)+(frameCount % 3);
		pixels[index + 0] += (frame&3)+(frameCount % 3);

    frame += 1;
	}

	updatePixels();
}

function mouseReleased() {
	y += 1
	
	background(0)
}
"
"1229382","Spiral 2 colors 3","mySketch","// same concept as others circles sketchs (draw circles iteratively but stop when bumping on other circles)
// this is the accurate version which ignore self bump, it use an array to track all already drawn objects to accurately guess when current circle bump and ignore self bump
// + decrease radius over time

// without coords rounding (less aliasing but bit blurry)

let pa = []
let ci = 0

function setup() {
	createCanvas(800, 800)
	background(0)
	
	noStroke()
	
	colorMode(HSL, 360, 255, 255)
	
	for (let i = 0; i < width * height; i += 1) {
		pa[i] = []
	}
}

function draw() {
	let count = 1 + (1 * min(1, frameCount / 240))
	for (let c = 0; c < count; c += 1) {
		let nc = c / count
		let nc1 = 1+c / count
		let t = max(0, 1.35-pow(frameCount / 400, 0.15))
		let x = width / 2 + width / 2 * sin(frameCount / 30 * PI * (4 + 10 * t))* t//random(0, width)
		let y = height / 2 + height / 2 * cos(frameCount / 30 * PI * (4 +10 * t))* t//random(0, height)
		
		if (t >= 2) { break }
		
		let rmax = height / 8 * max(0.1, pow(frameCount / 100, 0.085))
		let r = random(4, rmax)
		
		let rc = pow(r / rmax, 1)
		
		

		let cpm = false
		let cpp = false
		
		let pc = rmax*2.5 // precision (less = may show quantization gaps, high = overdraw + aliasing but less gaps)
		for (let i = 0; i < pc; i += 1) {
			let ni = i / pc
			fill(100 *ni+frameCount, 0, 255)
			let cxm = (x + r * sin(ni * PI *r)*ni)
			let cym = (y + r * cos(ni * PI* r )*ni)
			
			fill((100+(rc * 10))*(sin(ni*PI*2 + frameCount)), 128+128 * rc, 128+192 * rc*(sin(ni*PI*4 + frameCount/2)))
			
			if (cxm >= 0 && cxm < width && cym > 0 && cym < height && !cpm) {
				let pal = pa[floor(cxm) + floor(cym) * width]
				let f = false
				for (let k = 0; k < pal.length; k += 1) {
					if (pal[k] != ci) {
						f = true
						break
					}
				}

				if (!f) {
					rect(cxm, cym, 1, 1)

					pal.push(ci)
				} else {
					cpm = true
				}
			}
			
			let cxp = (x - r * sin(ni * PI *r)*ni )
			let cyp = (y - r * cos(ni * PI *r)*ni )
			
			if (cxp >= 0 && cxp < width && cyp > 0 && cyp < height && !cpp) {
				pal = pa[floor(cxp) + floor(cyp) * width]
				f = false
				for (let k = 0; k < pal.length; k += 1) {
					if (pal[k] != ci) {
						f = true
						break
					}
				}

				if (!f) {
					rect(cxp, cyp, 1, 1)

					pal.push(ci)
				} else {
					cpp = true
				}
			}
			
			if (cpm && cpp) {
				break
			}
		}
		
		ci += 1
	}
}"
"1229307","Minsky 3","mySketch","// trying 16 bits

let x = 10, y = 0, frame = 0, index = 0;
function setup() {
	createCanvas(windowWidth, windowHeight);
	
	background(0);
}

function draw() {
	loadPixels();
	
	for(let iter = 0; iter < 100000; iter += 1) {
		x -= (y>>12-(x>>31))&(3000+((iter/y)))
		x %= 65536/5
		y += (x>>0)
		y %= 65536/2
		x -= (y>>1)-(x>>4 + iter/50000)
		x %= 65536/3
		y += (x>>0)
		y %= 65536/1
		index = (floor(width / 2.1 + (x >> 5)) + floor(height / 1.9 + (y >> 6)) * width) * 4;

		pixels[index + 1] += frame&(3+frameCount / 20 % 2);
		pixels[index + 2] += frame&4;
		pixels[index + 0] += frame&3;

    frame += 1;
	}

	updatePixels();
}

function mouseReleased() {
	y += 1
	
	background(0)
}
"
"1229300","Minsky 2","mySketch","// trying 16 bits

let x = 200, y = 0, frame = 0, index = 0;
function setup() {
	createCanvas(windowWidth, windowHeight);
	
	background(0);
}

function draw() {
	loadPixels();
	
	for(let iter = 0; iter < 100000; iter += 1) {
		x -= (y>>10-(x>>20))&(1500^((frame&y)/1000000))
		x %= 65536/7
		y += (x>>1)
		y %= 65536/1
		x -= (y>>1)-(x>>31 + iter/50000)
		x %= 65536/3
		
		index = (floor(width / 2 + (x >> 4)) + floor(height / 2 + (y >> 4)) * width) * 4;

		pixels[index + 1] += frame&(3+frameCount / 10 % 2);
		pixels[index + 2] += frame&4;
		pixels[index + 0] += frame&3;

    frame += 1;
	}

	updatePixels();
}

function mouseReleased() {
	y += 1
	
	background(0)
}
"
"1229293","Minsky","mySketch","// trying 16 bits

let x = 200, y = 0, frame = 0, index = 0;
function setup() {
	createCanvas(windowWidth, windowHeight);
	
	background(0);
}

function draw() {
	loadPixels();
	
	for(let iter = 0; iter < 100000; iter += 1) {
		x -= (y>>3-(y>>28))&(2050)
		x %= 65536/2
		y += (x>>1) + frame / 1000000
		y %= 65536/2.5
		x -= (y>>1)-(x>>28)
		x %= 65536/2.5
		
		index = (floor(width / 2 + (x >> 6)) + floor(height / 2 + (y >> 6)) * width) * 4;

		pixels[index + 1] += frame&(3+frameCount / 10 % 2);
		pixels[index + 2] += frame&4;
		pixels[index + 0] += frame&3;

    frame += 1;
	}

	updatePixels();
}

function mouseReleased() {
	y += 1
	
	background(0)
}
"
"1229231","C","mySketch","// Flagship prototype - a 256 bytes Linux framebuffer intro presented at Revision 2021 demoparty
// It is all integers and is sorta a CORDIC algorithm
// This was ported to C code which use SIMD saturated arithmetic (to be released soon)
// The Linux binary has a platform overhead (48 bytes of headers + ~58 bytes of framebuffer setup code) so its not very far to be 128 bytes.
// Video on Linux : https://www.youtube.com/watch?v=ru-X4updvrU
// https://www.pouet.net/prod.php?which=88636
// There is some differences with the C code but not very far from this

let x = 8000, y = 10, frame = 0, index = 0;
function setup() {
	// 1920x1080 is Flagship as it was presented
	// i find this one (original one) more interesting visually but because Linux framebuffer has fixed display size it would have required bit more code (and wouldn't be fullscreen)
	createCanvas(800, 800);
	
	background(0);
}

function draw() {
	//background(0);
	
	loadPixels();
	
	//y = frameCount / 10 % 100

	for(let iter = 0; iter < 100000; iter += 1) {
		x -= (y>>9)-(x>>16);
		x %= 65536
		y += (x>>8)+(y>>16);
		y %= 65536
		x -= (y>>9)-(x>>16);
		x %= 65536
		
		
		
		index = (floor(width / 2 + (x >> 8)) + floor(height / 2 + (y >> 8)) * width) * 4;
		//let index2 = (floor(width / 2 + ~(x >> 2)) + floor(height / 2 + (y >> 2)) * width) * 4;
		
		// don't need this in JS but C code does
		//if (index > (width * height * 4)) { index = width / 2 * 4; index2 = width / 2 * 4; }

		// C code didn't use logical operators here (nor the 'iter' loop)
		pixels[index + 1] += 1&iter;
		pixels[index + 2] += 1;
		pixels[index + 0] += 1;
		/*pixels[index2 + 1] += 1&iter;
		pixels[index2 + 2] += 1&iter;
		pixels[index2 + 0] += 1;*/

    frame += 1;
	}

	updatePixels();
}

function mouseReleased() {
	y += 1
	
	background(0)
}
"
"1228776","Attractor 2","mySketch","let n = 500
let x = 0
let y = 0
let t = 0

function setup() {
	createCanvas(800, 800)
	
	background(0)
	
	noStroke()
	
	rectMode(CORNER)
	
	colorMode(HSB, 360, 128, 128)
}

function draw() {
	//fill(0, 0, 0, 92)
	//rect(0, 0, width, height)
	
	for (let l = 0; l < 10; l += 1) {
		for (let i = 0; i < n; i += 1) {
			//for (let j = 0; j < n; j += 1) {
				f(i, 0)
			//}
		}

		t += 0.0001
	}
}

function f(i, c) {
	let u = sin(x + t)/(1+x+t) + y/0.75
	let v = cos(y / 2 - t) - x
	
	x = exp(u) + t
	y = v - t
	
	fill(0, 0, 255, 0.03)
	ellipse(
		u * width / 10 + width / 1.25,
		v * height / 10 + height / 1.5, 2)
}"
"1228756","Attractor","mySketch","let n = 20
let x = 0
let y = 0
let t = 0

function setup() {
	createCanvas(800, 800)
	
	background(0)
	
	noStroke()
	
	rectMode(CORNER)
	
	colorMode(HSB, 360, 128, 128)
}

function draw() {
	//fill(0, 0, 0, 92)
	//rect(0, 0, width, height)
	
	for (let l = 0; l < 2; l += 1) {
		for (let i = 0; i < n; i += 1) {
			for (let j = 0; j < n; j += 1) {
				f(i, j)
			}
		}

		t += 0.0001
	}
}

function f(i, c) {
	let u = sin(x + t) + y/0.75
	let v = cos(y - t) - x
	
	x = exp(u) + t
	y = v - t
	
	fill(i, 0, 255, 0.03)
	ellipse(
		u * width / 8 + width / 1.5,
		v * height / 8 + height / 1.25, 2)
}"
"1227374","Faster sand","mySketch","float xmotion = 8.8;
float ymotion = 2.2;
float color_wheel = 2;
float start_colors1 = 224;

void draw_func() {
	if ((frameCount % 220) == 0) {
		frameCount = 0;
		background(0);
		color_wheel = random(0.5, 2);
		start_colors1 = random(210, 240);
	}
	
	noStroke();
	
	loadPixels();
	for (int y = 0; y < height; y += 2) {
		int yy = y * width;
		for (int x = 0; x < width; x += 2) {
			color p = pixels[yy + x];
			
			if (brightness(p) > 0 && brightness(p) < 92) {
				fill(hue(p)+1, 128, 255, 33);
				
				ellipse(x + random(), y + random(), 4, 4);
				ellipse(width - x  - random(), y - random(), 4, 4);
			}
		}
	}
	
	noFill();
	noStroke();
  strokeWeight(1);
	
	rectMode(CENTER);
	ellipseMode(CENTER);

	for (int i = 1; i < 32; i += 1) {
		float norm_i = 1-((float)(i - 1) / 32);
		
		stroke(16+random(0, 128), 128 * norm_i, 255 * norm_i, 1);

		//int sw = (float)width/2 / (i * 1) + abs(cos(ymotion/2) * 256);
		//int sh = height/2 / (i * 1)+ abs(sin(xmotion/2) * 64);
		
		float n = random(0, 1);
		//line(width/64*i, 0, width/64*i, height);
		line(0, height/32*i, width/i*pow(i, 0.01), height/32*i);
	}
	rectMode(CORNER);
	
	if (frameCount < 2) {
		fill(start_colors1, 128, 255, 8);
		ellipse(width / 3.25, height / 1.75, 64, 64);
		arc(width / 2, height / 1.25, 200, 12, 0, PI, CHORD);
	}

	xmotion += 0.4;
	ymotion += 0.8;
}

void setup() {
  size(800, 800);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	noiseDetail(7,0.65);
	
	frameRate(30);
	
	//smooth();
}

void draw() {
  draw_func();
}"
"1227360","Structures new","mySketch","// random bezier with feedback rules
// reducing shapes size uniformly has some interesting properties as well

float xmotion = 8.8;
float ymotion = 2.2;

int reset = 0;
int perlin_amount = 1;

void draw_func() {
	noStroke();
	
	loadPixels();
	for (int y = 0; y < height; y += 1) {
		int yy = y * width;
		for (int x = 0; x < width; x += 1) {
			color p = pixels[yy + x];
			
			float xm = 0;
			float ym = 92 - (frameCount - reset);
			
			if ((brightness(p) > xm && brightness(p) < ym)) {
				float normx = (float)x / width;
				float normy = (float)y / height;
				float anormx = 1.0 - abs(0.5 - normx) * 2;
				float anormy = 1.0 - abs(0.5 - normy) * 2;
				
				float xk = xmotion / 2;
				float yk = ymotion / 2;
				
				float n = (noise(normx+xk,normy+yk)) * perlin_amount;
				
				fill(/*0+hue(p)/4, saturation(p)+4, */0, 0, brightness(p)*20, 24);
				
				ellipse(x + n, y + n, 3, 2);
				ellipse(width - x + n, y + n, 3, 2);
			}
		}
	}
	
	noFill();
	noStroke();

	rectMode(CENTER);
	ellipseMode(CENTER);


	
	//bezier(random(width), random(height), random(width), random(height), random(width), random(height), random(width), random(height));

	rectMode(CORNER);
	
	xmotion += 0.75;
	ymotion += 0.5;
}

void setup() {
  size(800, 800);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	noiseDetail(6,0.65);
	
	frameRate(60);
	
		stroke(0, 0, 255, 4);
		strokeWeight(1);
		noFill();
		for (int i = 1; i < 8; i += 1) {
			float ix = 0.4+pow(i / 8, 4)
			ellipse(width / 2, height / 2, width * ix, height * ix);
			//bezier(random(width/2), random(height/2), random(width/2), random(height/2), random(width/2), random(height/2), random(width/2), random(height/2));
		}
	/*
	for (int i = 1; i < 32; i += 1) {
		int x = random(0, width);
		int h = random(height / 2, height/1.15);
		line(x, h, x, height);
	}
	*/
	//smooth();
}

void mouseClicked() {
	background(0);
	
	reset = frameCount;
	
	perlin_amount = random(2, 4);
}

void draw() {
  draw_func();
}"
"1226698","grid","mySketch","function setup() {
	createCanvas(800, 800)
	background(0)
	
	//rectMode(CENTER)
}

function draw() {
	noStroke()
	fill(0, 0, 0, 92)
	rect(0, 0, width, height)

	noFill()
	
	let substep = width / 32
	let substep_m1 = substep - 1 // avoid overlaping
	let depth = 400
	let depth_step = depth / 32
	
	//let u = 1 / subfactor
	//let uw = u * width
	//let uh = u * height

	for (let z = 0; z < depth; z += depth_step) {
		let nz = z / (depth - depth_step)
		
		push()
		
		translate(width / 2, height / 2)
		scale(1.5) // make sure it fill the display (due to rotation)
		rotate(PI / 180 * 45)
		translate(-width / 2, -height / 2)
		
		//let nzd = sin(nz * PI * 2 + frameCount / 100)
		//let c = nzd * 255
		//stroke(c, c, c, abs(0.5 - nzd) * 255)
		let nzd = abs(sin(nz * PI * 2 + frameCount / 100))
		//fill(nzd * 255)
		
		for (let s = 0; s < width; s += substep) {
			let ns = s / (width - substep)
			
			//fill(abs(sin(ns * PI * 8 + frameCount / 10)) * nzd * 255)
			fill(255);
			stroke(255, 0, 0)
			
			let x1 = s, x2 = s + substep, x3 = s + substep, x4 = s
			let y1 = z, y2 = z, y3 = z + depth_step, y4 = z + depth_step
			quad(x1, y1, x2, y2, x3, y3, x4, y4)
			//quad(y1, x1, y2, x2, y3, x3, y4, x4)
			quad(x1, height - y1, x2, height - y2, x3, height - y3, x4, height - y4)
			//quad(width - y1, height - x1, width - y2, height - x2, width - y3, height - x3, width - y4, height - x4)
			
			/*
			let x1 = s
			let y1 = 0
			y1 += z*4
			line(x1, y1, x1 + substep_m1, y1)
			let x2 = 0
			let y2 = s
			x2 += z*4
			line(x2, y2, x2, y2 + substep_m1)
			let x3 = 0
			let y3 = s
			x3 -= z*4
			line(x3 + width, y3, x3 + width, y3 + substep_m1)
			let x4 = s
			let y4 = 0
			y4 -= z*4
			line(x4, y4 + height, x4 + substep_m1, y4 + height)
			*/
		}
		
		/*
		for (let y = 0; y < height; y += uw) {
			let ny = y / height
			stroke(255 * ny)
			for (let x = 0; x < width; x += uh) {
				rect(x, y, uw, uh)
				//line(x, y, x, y + uh)
			}
		}
		*/
		pop()
	}
}"
"1224388","Test","mySketch","// same concept as others circles sketchs (draw circles iteratively but stop when bumping on other circles)
// this is the accurate version which ignore self bump, it use an array to track all already drawn objects to accurately guess when current circle bump and ignore self bump
// + decrease radius over time

let pa = []
let ci = 0

function setup() {
	createCanvas(900, 900)
	background(0)
	
	noStroke()
	
	colorMode(HSL, 360, 255, 255)
	
	for (let i = 0; i < width * height; i += 1) {
		pa[i] = []
	}
}

function draw() {
	let count = 20;
	for (let c = 0; c < count; c += 1) {
		let t = pow(1-frameCount / 1000, 0.45)
		let x = width / 2 + width / 2 * sin(frameCount / 400 * PI * 31)* max(0.05, t)//random(0, width)
		let y = height / 2 + height / 2 * cos(frameCount / 400 * PI * 31)* max(0.05, t)//random(0, height)
		
		let rmax = height / 1 * max(0.1, 1 - pow(frameCount / 300, 1.5))
		let r = random(4, rmax)
		
		let rc = pow(r / rmax, 0.75)
		
		fill(0 - rc * 100* (frameCount / 500 ), 128, (pow(rc, 2.75) * 255) * (1-frameCount / 3000))
		//fill(255, 255, 255)

		let cpm = false
		let cpp = false
		
		let pc = rmax * 2.5 // precision (less = may show quantization gaps, high = overdraw + aliasing but less gaps)
		for (let i = 0; i < pc; i += 1) {
			let ni = i / pc
			
			let cxm = (x + r * sin(ni * PI * (1 + (frameCount / 100))) * (ni))
			let cym = (y + r * cos(ni * PI * (1 + (frameCount / 100))) * (ni))
			
			if (cxm >= 0 && cxm < width && cym > 0 && cym < height && !cpm) {
				let pal = pa[floor(cxm) + floor(cym) * width]
				let f = false
				for (let k = 0; k < pal.length; k += 1) {
					if (pal[k] != ci) {
						f = true
						break
					}
				}

				if (!f) {
					rect(cxm, cym, 1, 1)

					pal.push(ci)
				} else {
					cpm = true
				}
			}

			if (cpm) {
				break
			}
		}
		
		fill(320-rc * 300, random(128, 255), (pow(rc, 2.75) * 255) * (1-frameCount / 3000))
		
		if (cpm) {
		for (let i = 0; i < 2000; i += 1) {
			let ni = i / 2000
			
			let cxm = (x + (r / 92) * sin(ni * PI * 64)*ni)
			let cym = (y + (r / 92) * cos(ni * PI * 64)*ni)
			
			if (cxm >= 0 && cxm < width && cym > 0 && cym < height) {
				let pal = pa[floor(cxm) + floor(cym) * width]
				let f = false
				for (let k = 0; k < pal.length; k += 1) {
					if (pal[k] != ci) {
						f = true
						break
					}
				}
				
				if (!f) {
					rect(cxm, cym, 1, 1)
					pal.push(ci)
				}
				else break
		}
		}}
		
		ci += 1
	}
}"
"1224387","Floraison reduced aliasing","mySketch","// same concept as others circles sketchs (draw circles iteratively but stop when bumping on other circles)
// this is the accurate version which ignore self bump, it use an array to track all already drawn objects to accurately guess when current circle bump and ignore self bump
// + decrease radius over time

let pa = []
let ci = 0

function setup() {
	createCanvas(900, 900)
	background(0)
	
	noStroke()
	
	colorMode(HSL, 360, 255, 255)
	
	for (let i = 0; i < width * height; i += 1) {
		pa[i] = []
	}
}

function draw() {
	for (let c = 0; c < 20; c += 1) {
		let x = random(0, width)
		let y = random(0, height)
		
		let rmax = height / 4 * max(0.1, 1 - pow(frameCount / 300, 1.5))
		let r = random(4, rmax)
		
		let rc = pow(r / rmax, 0.75)
		
		fill(10+ rc * 100* (frameCount / 500 ), 192, (pow(rc, 2.75) * 255) * (1-frameCount / 600))
		//fill(255, 255, 255)

		let cpm = false
		let cpp = false
		
		let pc = rmax * 3 // precision (less = may show quantization gaps, high = overdraw + aliasing but less gaps)
		for (let i = 0; i < pc; i += 1) {
			let ni = i / pc
			
			let cxm = (x + r * sin(ni * PI * (2 + (frameCount / 5))) * (ni))
			let cym = (y + r * cos(ni * PI * (2 + (frameCount / 5))) * (ni))
			
			if (cxm >= 0 && cxm < width && cym > 0 && cym < height && !cpm) {
				let pal = pa[floor(cxm) + floor(cym) * width]
				let f = false
				for (let k = 0; k < pal.length; k += 1) {
					if (pal[k] != ci) {
						f = true
						break
					}
				}

				if (!f) {
					rect(cxm, cym, 1, 1)

					pal.push(ci)
				} else {
					cpm = true
				}
			}

			if (cpm) {
				break
			}
		}
		
		fill(rc * 200 * 2.25, random(128, 255), (pow(rc, 2.75) * 255) * (1-frameCount / 600))
		
		if (cpm) {
		for (let i = 0; i < 500; i += 1) {
			let ni = i / 500
			
			let cxm = (x + (r / 32) * sin(ni * PI * 64)*ni)
			let cym = (y + (r / 32) * cos(ni * PI * 64)*ni)
			
			if (cxm >= 0 && cxm < width && cym > 0 && cym < height) {
				let pal = pa[floor(cxm) + floor(cym) * width]
				let f = false
				for (let k = 0; k < pal.length; k += 1) {
					if (pal[k] != ci) {
						f = true
						break
					}
				}
				
				if (!f) {
					rect(cxm, cym, 1, 1)
					pal.push(ci)
				}
				else break
		}
		}}
		
		ci += 1
	}
}"
"1221429","Spiral 2 colors 2","mySketch","// same concept as others circles sketchs (draw circles iteratively but stop when bumping on other circles)
// this is the accurate version which ignore self bump, it use an array to track all already drawn objects to accurately guess when current circle bump and ignore self bump
// + decrease radius over time

// without coords rounding (less aliasing but bit blurry)

let pa = []
let ci = 0

function setup() {
	createCanvas(800, 800)
	background(0)
	
	noStroke()
	
	colorMode(HSL, 360, 255, 255)
	
	for (let i = 0; i < width * height; i += 1) {
		pa[i] = []
	}
}

function draw() {
	let count = 1 + (1 * min(1, frameCount / 240))
	for (let c = 0; c < count; c += 1) {
		let nc = c / count
		let nc1 = 1+c / count
		let t = pow(frameCount / 400, 0.95)
		let x = width / 2 + width / 2 * sin(frameCount / 300 * PI * (10 + 20 * t))* t//random(0, width)
		let y = height / 2 + height / 2 * cos(frameCount / 300 * PI * (10 + 20 * t))* t//random(0, height)
		
		if (t >= 2) { break }
		
		let rmax = height / 4 * max(0.05, pow(frameCount / 400, 0.85))
		let r = random(4, rmax)
		
		let rc = pow(r / rmax, 1)
		
		

		let cpm = false
		let cpp = false
		
		let pc = rmax*2.5 // precision (less = may show quantization gaps, high = overdraw + aliasing but less gaps)
		for (let i = 0; i < pc; i += 1) {
			let ni = i / pc
			fill(100 *ni+frameCount, 0, 255)
			let cxm = (x + r * sin(ni * PI *r)*ni)
			let cym = (y + r * cos(ni * PI* r )*ni)
			
			fill((100+(rc * 10))*(sin(ni*PI*2 + frameCount)), 128+128 * rc, 128+192 * rc*(sin(ni*PI*4 + frameCount/2)))
			
			if (cxm >= 0 && cxm < width && cym > 0 && cym < height && !cpm) {
				let pal = pa[floor(cxm) + floor(cym) * width]
				let f = false
				for (let k = 0; k < pal.length; k += 1) {
					if (pal[k] != ci) {
						f = true
						break
					}
				}

				if (!f) {
					rect(cxm, cym, 1, 1)

					pal.push(ci)
				} else {
					cpm = true
				}
			}
			
			let cxp = (x - r * sin(ni * PI *r)*ni )
			let cyp = (y - r * cos(ni * PI *r)*ni )
			
			if (cxp >= 0 && cxp < width && cyp > 0 && cyp < height && !cpp) {
				pal = pa[floor(cxp) + floor(cyp) * width]
				f = false
				for (let k = 0; k < pal.length; k += 1) {
					if (pal[k] != ci) {
						f = true
						break
					}
				}

				if (!f) {
					rect(cxp, cyp, 1, 1)

					pal.push(ci)
				} else {
					cpp = true
				}
			}
			
			if (cpm && cpp) {
				break
			}
		}
		
		ci += 1
	}
}"
"1221427","Spiral 2 colors","mySketch","// same concept as others circles sketchs (draw circles iteratively but stop when bumping on other circles)
// this is the accurate version which ignore self bump, it use an array to track all already drawn objects to accurately guess when current circle bump and ignore self bump
// + decrease radius over time

// without coords rounding (less aliasing but bit blurry)

let pa = []
let ci = 0

function setup() {
	createCanvas(800, 800)
	background(0)
	
	noStroke()
	
	colorMode(HSL, 360, 255, 255)
	
	for (let i = 0; i < width * height; i += 1) {
		pa[i] = []
	}
}

function draw() {
	let count = 1 + (1 * min(1, frameCount / 240))
	for (let c = 0; c < count; c += 1) {
		let nc = c / count
		let nc1 = 1+c / count
		let t = pow(frameCount / 400, 0.95)
		let x = width / 2 + width / 2 * sin(frameCount / 300 * PI * (10 + 2 * t))* t//random(0, width)
		let y = height / 2 + height / 2 * cos(frameCount / 300 * PI * (10 + 2 * t))* t//random(0, height)
		
		if (t >= 2) { break }
		
		let rmax = height / 4 * max(0.05, pow(frameCount / 400, 0.85))
		let r = random(4, rmax)
		
		let rc = pow(r / rmax, 1)
		
		

		let cpm = false
		let cpp = false
		
		let pc = rmax*2.5 // precision (less = may show quantization gaps, high = overdraw + aliasing but less gaps)
		for (let i = 0; i < pc; i += 1) {
			let ni = i / pc
			fill(100 *ni+frameCount, 0, 255)
			let cxm = (x + r * sin(ni * PI *r)*ni)
			let cym = (y + r * cos(ni * PI* r )*ni)
			
			fill((100+(rc * 10))*(sin(ni*PI*2 + frameCount)), 128+128 * rc, 128+192 * rc*(sin(ni*PI*4 + frameCount/2)))
			
			if (cxm >= 0 && cxm < width && cym > 0 && cym < height && !cpm) {
				let pal = pa[floor(cxm) + floor(cym) * width]
				let f = false
				for (let k = 0; k < pal.length; k += 1) {
					if (pal[k] != ci) {
						f = true
						break
					}
				}

				if (!f) {
					rect(cxm, cym, 1, 1)

					pal.push(ci)
				} else {
					cpm = true
				}
			}
			
			let cxp = (x - r * sin(ni * PI *r)*ni )
			let cyp = (y - r * cos(ni * PI *r)*ni )
			
			if (cxp >= 0 && cxp < width && cyp > 0 && cyp < height && !cpp) {
				pal = pa[floor(cxp) + floor(cyp) * width]
				f = false
				for (let k = 0; k < pal.length; k += 1) {
					if (pal[k] != ci) {
						f = true
						break
					}
				}

				if (!f) {
					rect(cxp, cyp, 1, 1)

					pal.push(ci)
				} else {
					cpp = true
				}
			}
			
			if (cpm && cpp) {
				break
			}
		}
		
		ci += 1
	}
}"
"1221422","Spiral 2","mySketch","// same concept as others circles sketchs (draw circles iteratively but stop when bumping on other circles)
// this is the accurate version which ignore self bump, it use an array to track all already drawn objects to accurately guess when current circle bump and ignore self bump
// + decrease radius over time

// without coords rounding (less aliasing but bit blurry)

let pa = []
let ci = 0

function setup() {
	createCanvas(800, 800)
	background(0)
	
	noStroke()
	
	colorMode(HSL, 360, 255, 255)
	
	for (let i = 0; i < width * height; i += 1) {
		pa[i] = []
	}
}

function draw() {
	let count = 1 + (64 * min(1, frameCount / 240))
	for (let c = 0; c < count; c += 1) {
		let nc = c / count
		let nc1 = 1+c / count
		let t = pow(frameCount / 1000, 0.85)
		let x = width / 2 + width / 2 * sin(frameCount / 300 * PI * 2)* t//random(0, width)
		let y = height / 2 + height / 2 * cos(frameCount / 300 * PI * 2)* t//random(0, height)
		
		if (t >= 1.3) { break }
		
		let rmax = height / 4 * max(0.05, pow(frameCount / 400, 0.85))
		let r = random(4, rmax)
		
		let rc = pow(r / rmax, 1)
		
		

		let cpm = false
		let cpp = false
		
		let pc = rmax*2.5 // precision (less = may show quantization gaps, high = overdraw + aliasing but less gaps)
		for (let i = 0; i < pc; i += 1) {
			let ni = i / pc
			fill(100 *ni+frameCount, 0, 255)
			let cxm = (x + r * sin(ni * PI *2+ r)*ni)
			let cym = (y + r * cos(ni * PI* 2 + r)*ni)
			
			//fill((100+(rc * 10))*(sin(ni*PI*2 + frameCount)), 128+128 * rc, 128+128 * rc*(sin(ni*PI*4 + frameCount/20)))
			
			if (cxm >= 0 && cxm < width && cym > 0 && cym < height && !cpm) {
				let pal = pa[floor(cxm) + floor(cym) * width]
				let f = false
				for (let k = 0; k < pal.length; k += 1) {
					if (pal[k] != ci) {
						f = true
						break
					}
				}

				if (!f) {
					rect(cxm, cym, 1, 1)

					pal.push(ci)
				} else {
					cpm = true
				}
			}
			
			let cxp = (x - r * sin(-ni * PI *2+ r)*ni )
			let cyp = (y - r * cos(-ni * PI *2+ r)*ni )
			
			if (cxp >= 0 && cxp < width && cyp > 0 && cyp < height && !cpp) {
				pal = pa[floor(cxp) + floor(cyp) * width]
				f = false
				for (let k = 0; k < pal.length; k += 1) {
					if (pal[k] != ci) {
						f = true
						break
					}
				}

				if (!f) {
					rect(cxp, cyp, 1, 1)

					pal.push(ci)
				} else {
					cpp = true
				}
			}
			
			if (cpm && cpp) {
				break
			}
		}
		
		ci += 1
	}
}"
"1220413","Spiral","mySketch","// same concept as others circles sketchs (draw circles iteratively but stop when bumping on other circles)
// this is the accurate version which ignore self bump, it use an array to track all already drawn objects to accurately guess when current circle bump and ignore self bump
// + decrease radius over time

// without coords rounding (less aliasing but bit blurry)

let pa = []
let ci = 0

function setup() {
	createCanvas(800, 800)
	background(0)
	
	noStroke()
	
	colorMode(HSL, 360, 255, 255)
	
	for (let i = 0; i < width * height; i += 1) {
		pa[i] = []
	}
}

function draw() {
	let count = 1 + (64 * min(1, frameCount / 240))
	for (let c = 0; c < count; c += 1) {
		let nc = c / count
		let nc1 = 1+c / count
		let t = pow(frameCount / 400, 0.85)
		let x = width / 2 + width / 2 * sin(frameCount / 300 * PI * 2*nc1)* t//random(0, width)
		let y = height / 2 + height / 2 * cos(frameCount / 300 * PI * 2*nc1)* t//random(0, height)
		
		if (t >= 0.9) { break }
		
		let rmax = height / 1 * max(0.05, pow(frameCount / 100, 0.85))
		let r = random(4, rmax)
		
		let rc = pow(r / rmax, 1)
		
		

		let cpm = false
		let cpp = false
		
		let pc = rmax*2 // precision (less = may show quantization gaps, high = overdraw + aliasing but less gaps)
		for (let i = 0; i < pc; i += 1) {
			let ni = i / pc
			fill(100 *ni+frameCount, 0, 255)
			let cxm = (x + r * sin(ni * PI *2+ r)*ni)
			let cym = (y + r * cos(ni * PI* 2 + r)*ni)
			
			//fill((100+(rc * 10))*(sin(ni*PI*2 + frameCount)), 128+128 * rc, 128+128 * rc*(sin(ni*PI*4 + frameCount/20)))
			
			if (cxm >= 0 && cxm < width && cym > 0 && cym < height && !cpm) {
				let pal = pa[floor(cxm) + floor(cym) * width]
				let f = false
				for (let k = 0; k < pal.length; k += 1) {
					if (pal[k] != ci) {
						f = true
						break
					}
				}

				if (!f) {
					rect(cxm, cym, 1, 1)

					pal.push(ci)
				} else {
					cpm = true
				}
			}
			
			let cxp = (x - r * sin(-ni * PI *2+ r)*ni )
			let cyp = (y - r * cos(-ni * PI *2+ r)*ni )
			
			if (cxp >= 0 && cxp < width && cyp > 0 && cyp < height && !cpp) {
				pal = pa[floor(cxp) + floor(cyp) * width]
				f = false
				for (let k = 0; k < pal.length; k += 1) {
					if (pal[k] != ci) {
						f = true
						break
					}
				}

				if (!f) {
					rect(cxp, cyp, 1, 1)

					pal.push(ci)
				} else {
					cpp = true
				}
			}
			
			if (cpm && cpp) {
				break
			}
		}
		
		ci += 1
	}
}"
"1220359","Circles","mySketch","// same concept as others circles sketchs (draw circles iteratively but stop when bumping on other circles)
// this is the accurate version which ignore self bump, it use an array to track all already drawn objects to accurately guess when current circle bump and ignore self bump
// + decrease radius over time

// without coords rounding (less aliasing but bit blurry)

let pa = []
let ci = 0

function setup() {
	createCanvas(800, 800)
	background(0)
	
	noStroke()
	
	colorMode(HSL, 360, 255, 255)
	
	for (let i = 0; i < width * height; i += 1) {
		pa[i] = []
	}
}

function draw() {
	for (let c = 0; c < 32; c += 1) {
		let t = pow(frameCount / 100, 0.85)
		let x = width / 2 + width / 3 * sin(frameCount / 40 * PI * 8)* max(0.1, t)//random(0, width)
		let y = height / 2 + height / 3 * cos(frameCount / 40 * PI * 6)* max(0.1, t)//random(0, height)
		
		if (t >= 1.3) { break }
		
		let rmax = height / 12 * max(0.05, pow(frameCount / 100, 0.85))
		let r = random(4, rmax)
		
		let rc = pow(r / rmax, 1)
		
		fill(340 - frameCount / 60, 90+frameCount / 4 % 255, 240 - rc * 255)

		let cpm = false
		let cpp = false
		
		let pc = rmax*3 // precision (less = may show quantization gaps, high = overdraw + aliasing but less gaps)
		for (let i = 0; i < pc; i += 1) {
			let ni = i / pc
			
			let cxm = (x - r * sin(ni * PI * r))
			let cym = (y - r * cos(ni * PI * r))
			
			//fill((100+(rc * 10))*(sin(ni*PI*2 + frameCount)), 128+128 * rc, 128+128 * rc*(sin(ni*PI*4 + frameCount/20)))
			
			if (cxm >= 0 && cxm < width && cym > 0 && cym < height && !cpm) {
				let pal = pa[floor(cxm) + floor(cym) * width]
				let f = false
				for (let k = 0; k < pal.length; k += 1) {
					if (pal[k] != ci) {
						f = true
						break
					}
				}

				if (!f) {
					rect(cxm, cym, 1, 1)

					pal.push(ci)
				} else {
					cpm = true
				}
			}
			
			let cxp = (x - r * sin(-ni * PI * r) )
			let cyp = (y - r * cos(-ni * PI * r) )
			
			if (cxp >= 0 && cxp < width && cyp > 0 && cyp < height && !cpp) {
				pal = pa[floor(cxp) + floor(cyp) * width]
				f = false
				for (let k = 0; k < pal.length; k += 1) {
					if (pal[k] != ci) {
						f = true
						break
					}
				}

				if (!f) {
					rect(cxp, cyp, 1, 1)

					pal.push(ci)
				} else {
					cpp = true
				}
			}
			
			if (cpm && cpp) {
				break
			}
		}
		
		ci += 1
	}
}"
"1220336","Plurality 2","mySketch","// same concept as others circles sketchs (draw circles iteratively but stop when bumping on other circles)
// this is the accurate version which ignore self bump, it use an array to track all already drawn objects to accurately guess when current circle bump and ignore self bump
// + decrease radius over time

// without coords rounding (less aliasing but bit blurry)

let pa = []
let ci = 0

function setup() {
	createCanvas(800, 800)
	background(0)
	
	noStroke()
	
	colorMode(HSL, 360, 255, 255)
	
	for (let i = 0; i < width * height; i += 1) {
		pa[i] = []
	}
}

function draw() {
	for (let c = 0; c < 8; c += 1) {
		let t = pow(1-frameCount / 600, 0.5)
		let x = width / 2 + width / 2 * sin(frameCount / 400 * PI * 30)* max(0.05, t)//random(0, width)
		let y = height / 2 + height / 2 * cos(frameCount / 400 * PI * 30)* max(0.05, t)//random(0, height)
		
		if (t <= 0.05) { break }
		
		let rmax = height / 2 * max(0.05, 1 - pow(frameCount / 400, 0.5))
		let r = random(4, rmax)
		
		let rc = pow(r / rmax, 1)
		
		fill(150 + rc * 100, 192 * rc, 255 - rc * 255)

		let cpm = false
		let cpp = false
		
		let pc = rmax*3 // precision (less = may show quantization gaps, high = overdraw + aliasing but less gaps)
		for (let i = 0; i < pc; i += 1) {
			let ni = i / pc
			
			let cxm = (x - r * sin(ni * PI * 2))
			let cym = (y - r * cos(ni * PI * 2))
			
			//fill((100+(rc * 10))*(sin(ni*PI*2 + frameCount)), 128+128 * rc, 128+128 * rc*(sin(ni*PI*4 + frameCount/20)))
			
			if (cxm >= 0 && cxm < width && cym > 0 && cym < height && !cpm) {
				let pal = pa[floor(cxm) + floor(cym) * width]
				let f = false
				for (let k = 0; k < pal.length; k += 1) {
					if (pal[k] != ci) {
						f = true
						break
					}
				}

				if (!f) {
					rect(cxm, cym, 1, 1)

					pal.push(ci)
				} else {
					cpm = true
				}
			}
			
			let cxp = (x - r * sin(-ni * PI * 2) )
			let cyp = (y - r * cos(-ni * PI * 2) )
			
			if (cxp >= 0 && cxp < width && cyp > 0 && cyp < height && !cpp) {
				pal = pa[floor(cxp) + floor(cyp) * width]
				f = false
				for (let k = 0; k < pal.length; k += 1) {
					if (pal[k] != ci) {
						f = true
						break
					}
				}

				if (!f) {
					rect(cxp, cyp, 1, 1)

					pal.push(ci)
				} else {
					cpp = true
				}
			}
			
			if (cpm && cpp) {
				break
			}
		}
		
		ci += 1
	}
}"
"1220309","Plurality","mySketch","// same concept as others circles sketchs (draw circles iteratively but stop when bumping on other circles)
// this is the accurate version which ignore self bump, it use an array to track all already drawn objects to accurately guess when current circle bump and ignore self bump
// + decrease radius over time

let pa = []
let ci = 0

function setup() {
	createCanvas(800, 800)
	background(0)
	
	noStroke()
	
	colorMode(HSL, 360, 255, 255)
	
	for (let i = 0; i < width * height; i += 1) {
		pa[i] = []
	}
}

function draw() {
	for (let c = 0; c < 4; c += 1) {
		let t = pow(frameCount / 600, 0.5)
		let x = width / 2 + width / 2 * sin(frameCount / 400 * PI * 30)* max(0.2, t)//random(0, width)
		let y = height / 2 + height / 2 * cos(frameCount / 400 * PI * 30)* max(0.2, t)//random(0, height)
		
		if (t <= 0.2) { break }
		
		let rmax = height / 2 * max(0.05, 1 - pow(frameCount / 400, 0.5))
		let r = random(4, rmax)
		
		let rc = pow(r / rmax, 1)
		
		fill(150 + rc * 100, 192 * rc, 255 - rc * 255)

		let cpm = false
		let cpp = false
		
		let pc = 4000 // precision (less = may show quantization gaps, high = overdraw + aliasing but less gaps)
		for (let i = 0; i < pc; i += 1) {
			let ni = i / pc
			
			let cxm = round(x - r * sin(ni * PI * 2))
			let cym = round(y - r * cos(ni * PI * 2))
			
			//fill((100+(rc * 10))*(sin(ni*PI*2 + frameCount)), 128+128 * rc, 128+128 * rc*(sin(ni*PI*4 + frameCount/20)))
			
			if (cxm >= 0 && cxm < width && cym > 0 && cym < height && !cpm) {
				let pal = pa[cxm + cym * width]
				let f = false
				for (let k = 0; k < pal.length; k += 1) {
					if (pal[k] != ci) {
						f = true
						break
					}
				}

				if (!f) {
					rect(cxm, cym, 1, 1)

					pal.push(ci)
				} else {
					cpm = true
				}
			}
			
			let cxp = round(x - r * sin(-ni * PI * 2) )
			let cyp = round(y - r * cos(-ni * PI * 2) )
			
			if (cxp >= 0 && cxp < width && cyp > 0 && cyp < height && !cpp) {
				pal = pa[cxp + cyp * width]
				f = false
				for (let k = 0; k < pal.length; k += 1) {
					if (pal[k] != ci) {
						f = true
						break
					}
				}

				if (!f) {
					rect(cxp, cyp, 1, 1)

					pal.push(ci)
				} else {
					cpp = true
				}
			}
			
			if (cpm && cpp) {
				break
			}
		}
		
		ci += 1
	}
}"
"1217821","Poly bump + morph + sym","mySketch","// same concept as others circles / shapes stop sketchs (draw shape iteratively but stop when bumping on other shapes)
// this ignore self bump, it use an array to track all already drawn objects to accurately guess when current shape bump and ignore self bump
// + ability to draw any shapes made out of linearly interpolated lines (polygon)
// + draw each segments (from start to end and backward)
// + decrease radius over time
// + morph between two polygons (and variations in Y)

let pa = []
let ci = 0

let poly1

function setup() {
	createCanvas(800, 800)
	background(0)
	
	noStroke()
	
	colorMode(HSL, 360, 255, 255)
	
	noiseDetail(6, 0.6)
	
	for (let i = 0; i < width * height; i += 1) {
		pa[i] = []
	}
	/*
	for (let i = 512; i > 0; i -= 1) {
		let ni = i / 512;
		fill(200 + (1-pow(ni, 4)) * 60 + random(5), 255, 255 * pow(1-ni, 2.75), pow(ni, 0.25));
		ellipse(width / 2, height / 10, (width / 10) * ni, (width / 10) * ni);
	}
	*/
	//frameRate(1)
	
		//let plx = random(-1,1) // since poly1 & poly2 are different we pad it
		//let ply = random(-1,1)
		//poly1 = [random(-1,1), random(-1,1), random(-1,1), random(-1,1), plx, ply, plx, ply]
}

function draw() {
	for (let c = 0; c < 10; c += 1) {
		//let x = random(0, width)//random(width / 2.5, width - width / 2.5)
		//let y = random(0, height)//random(height / 2.5, height - height / 2.5)
		let fy = (((height/1.5) - frameCount) / (height/1.5))
		let x = random(width / 2 - width / 2, width / 2 + width / 2)
		let y = height - frameCount*1.5
		
		if (x < 0 || x > width) continue
		if (y < 0 || y > height) continue
		
		if (y < height /1.75 ) continue
		
		let rmax = height /1. * pow(max(0.1, 1-frameCount / height), 2.0) * noise(x / width * 8, y / height * 8) * fy
		let r = random(4, rmax)
		
		let rc = max(0, min(1, pow(r / rmax, 0.7)))
		
		
		//let poly = [-1, -1, 1, -1, 0, 1]

		let poly1 = [-1, 0, 0, -1, 0, -1, 1, 0, 0, -1] // rhombus
		//let poly2 = [-1, -1, 1, -1, 1, 1, -1, 1] // square
		let poly2 = [-1, -1, 1, -1, 1, -1, 1, 1, -1, 1] // cross
		
		// morph over time
		let poly = []
		for (let p = 0; p < poly1.length; p += 1) {
			poly[p] = lerp(poly1[p], poly2[p], min(1, abs(sin(frameCount / (height / 2) * PI * 2))))
		}
		
		let pc = 800 // precision per segment (less = may show quantization gaps, high = overdraw + aliasing but less gaps)
		for (let s = 0; s < (poly.length / 2); s += 1) {
			let cpm = false
			let cpp = false
			
			// poly point states
			// forward state
			let fpx = 0
			let fpy = 0
			// backward state
			let bpx = 0
			let bpy = 0
		
			for (let i = 0; i < pc; i += 1) {
				let pi = s * 2 // current vertex index
				let ni = i / pc // position on the segment
				
				fill((-40+(rc * 80)), 128+64 * rc, 255 * rc*abs(sin(ni*PI*2)))

				// line
				fpx = round(lerp(x + r * poly[(pi) % poly.length], x + r * poly[(pi + 2) % poly.length], ni))
				fpy = round(lerp(y + r * poly[(pi + 1) % poly.length], y + r * poly[(pi + 3) % poly.length], ni))

				// check bounds && if it hit something
				if (fpx >= 0 && fpx < width && fpy > 0 && fpy < height && !cpm) {
					let pal = pa[fpx + fpy * width]
					let f = false
					for (let k = 0; k < pal.length; k += 1) {
						if (pal[k] != ci) {
							f = true
							break
						}
					}

					if (!f) {
						rect(fpx, fpy, 1, 1)

						pal.push(ci)
					} else {
						cpm = true
					}
				}

				// going backward
				let bip = pi
				let bip2 = pi - 2
				if (bip2 < 0) bip2 += poly.length
				let fpx2 = round(lerp(x + r * poly[bip], x + r * poly[bip2], ni))
				let fpy2 = round(lerp(y + r * poly[bip + 1], y + r * poly[bip2 + 1], ni))

				// check bounds && if it hit something
				if (fpx2 >= 0 && fpx2 < width && fpy2 > 0 && fpy2 < height && !cpp) {
					let pal = pa[fpx2 + fpy2 * width]
					let f = false
					for (let k = 0; k < pal.length; k += 1) {
						if (pal[k] != ci) {
							f = true
							break
						}
					}

					if (!f) {
						rect(fpx2, fpy2, 1, 1)

						pal.push(ci)
					} else {
						cpp = true
					}
				}

				if (cpm && cpp) {
					break
				}
			}
			
		
		}
			ci += 1
		
	}
}"
"1217562","Poly bump + morph + sym","mySketch","// same concept as others circles / shapes stop sketchs (draw shape iteratively but stop when bumping on other shapes)
// this ignore self bump, it use an array to track all already drawn objects to accurately guess when current shape bump and ignore self bump
// + ability to draw any shapes made out of linearly interpolated lines (polygon)
// + draw each segments (from start to end and backward)
// + decrease radius over time
// + morph between two polygons (and variations in Y)

let pa = []
let ci = 0

let poly1

function setup() {
	createCanvas(800, 800)
	background(0)
	
	noStroke()
	
	colorMode(HSL, 360, 255, 255)
	
	for (let i = 0; i < width * height; i += 1) {
		pa[i] = []
	}
	/*
	for (let i = 512; i > 0; i -= 1) {
		let ni = i / 512;
		fill(200 + (1-pow(ni, 4)) * 60 + random(5), 255, 255 * pow(1-ni, 2.75), pow(ni, 0.25));
		ellipse(width / 2, height / 10, (width / 10) * ni, (width / 10) * ni);
	}
	*/
	//frameRate(1)
	
		let plx = random(-1,1) // since poly1 & poly2 are different we pad it
		let ply = random(-1,1)
		poly1 = [random(-1,1), random(-1,1), random(-1,1), random(-1,1), plx, ply, plx, ply]
}

function draw() {
	for (let c = 0; c < 4; c += 1) {
		//let x = random(0, width)//random(width / 2.5, width - width / 2.5)
		//let y = random(0, height)//random(height / 2.5, height - height / 2.5)
		let fy = (((height/1.5) - frameCount) / (height/1.5))
		let x = random(width / 2 - width / 2, width / 2 + width / 2)
		let y = height - frameCount/2
		
		if (x < 0 || x > width) continue
		if (y < 0 || y > height) continue
		
		if (y < height /1.75 ) continue
		
		let rmax = height / 2. * pow(max(0.1, 1-frameCount / height), 2.0)
		let r = random(4, rmax)
		
		let rc = max(0, min(1, pow(r / rmax, 0.7)))
		fill((-60+(rc * 60)), 128+64 * rc, 255 * rc)
		
		//let poly = [-1, -1, 1, -1, 0, 1]

	//	let poly1 = [-1, 0, 0, -1, 0, -1, 1, 0, 0, -1] // rhombus
		//let poly2 = [-1, -1, 1, -1, 1, 1, -1, 1] // square
		let poly2 = [-1, 0, 0, -1, 1, 0, 0, -1] // cross
		
		// morph over time
		let poly = []
		for (let p = 0; p < poly1.length; p += 1) {
			poly[p] = lerp(poly1[p], poly2[p], min(1, frameCount / (height / 2)))
		}
		
		let pc = 1000 // precision per segment (less = may show quantization gaps, high = overdraw + aliasing but less gaps)
		for (let s = 0; s < (poly.length / 2); s += 1) {
			let cpm = false
			let cpp = false
			
			// poly point states
			// forward state
			let fpx = 0
			let fpy = 0
			// backward state
			let bpx = 0
			let bpy = 0
		
			for (let i = 0; i < pc; i += 1) {
				let pi = s * 2 // current vertex index
				let ni = i / pc // position on the segment

				// line
				fpx = round(lerp(x + r * poly[(pi) % poly.length], x + r * poly[(pi + 2) % poly.length], ni))
				fpy = round(lerp(y + r * poly[(pi + 1) % poly.length], y + r * poly[(pi + 3) % poly.length], ni))

				// check bounds && if it hit something
				if (fpx >= 0 && fpx < width && fpy > 0 && fpy < height && !cpm) {
					let pal = pa[fpx + fpy * width]
					let f = false
					for (let k = 0; k < pal.length; k += 1) {
						if (pal[k] != ci) {
							f = true
							break
						}
					}

					if (!f) {
						rect(fpx, fpy, 1, 1)
rect(width - fpx, height - fpy, 1, 1)
						
						pal.push(ci)
					} else {
						cpm = true
					}
				}

				// going backward
				let bip = pi
				let bip2 = pi - 2
				if (bip2 < 0) bip2 += poly.length
				let fpx2 = round(lerp(x + r * poly[bip], x + r * poly[bip2], ni))
				let fpy2 = round(lerp(y + r * poly[bip + 1], y + r * poly[bip2 + 1], ni))

				// check bounds && if it hit something
				if (fpx2 >= 0 && fpx2 < width && fpy2 > 0 && fpy2 < height && !cpp) {
					let pal = pa[fpx2 + fpy2 * width]
					let f = false
					for (let k = 0; k < pal.length; k += 1) {
						if (pal[k] != ci) {
							f = true
							break
						}
					}

					if (!f) {
						rect(fpx2, fpy2, 1, 1)
rect(width - fpx2, height - fpy2, 1, 1)
						pal.push(ci)
					} else {
						cpp = true
					}
				}

				if (cpm && cpp) {
					break
				}
			}
			
		
		}
			ci += 1
		
	}
}"
"1217545","Poly bump + morph","mySketch","// same concept as others circles / shapes stop sketchs (draw shape iteratively but stop when bumping on other shapes)
// this ignore self bump, it use an array to track all already drawn objects to accurately guess when current shape bump and ignore self bump
// + ability to draw any shapes made out of linearly interpolated lines (polygon)
// + draw each segments (from start to end and backward)
// + decrease radius over time
// + morph between two polygons (and variations in Y)

let pa = []
let ci = 0

let poly = [-1, 1, 1, 1, 0, -1]

function setup() {
	createCanvas(800, 800)
	background(0)
	
	noStroke()
	
	colorMode(HSL, 360, 255, 255)
	
	for (let i = 0; i < width * height; i += 1) {
		pa[i] = []
	}
	
	for (let i = 512; i > 0; i -= 1) {
		let ni = i / 512;
		fill(200 + (1-pow(ni, 4)) * 60 + random(5), 255, 255 * pow(1-ni, 2.75), pow(ni, 0.25));
		ellipse(width / 2, height / 10, (width / 10) * ni, (width / 10) * ni);
	}
	
	//frameRate(1)
}

function draw() {
	for (let c = 0; c < 4; c += 1) {
		//let x = random(0, width)//random(width / 2.5, width - width / 2.5)
		//let y = random(0, height)//random(height / 2.5, height - height / 2.5)
		let fy = (((height/1.5) - frameCount) / (height/1.5))
		let x = random(width / 2 - width / 2 * fy, width / 2 + width / 2 * fy) 
		let y = height - frameCount
		
		if (x < 0 || x > width) continue
		if (y < 0 || y > height) continue
		
		if (y < height / 3.1) continue
		
		let rmax = height / 1.5 * pow(max(0.5, 1-frameCount / height), 0.5)* (height/180 - height / 200)
		let r = random(16, rmax)
		
		let rc = pow(r / rmax, 1.5)
		fill(((200+rc * 60)), 64 + 192-192 * rc, 255 * rc * pow(fy, 0.25))
		
		//let poly = [-1, -1, 1, -1, 0, 1]
		let plx = random(-1,1) // since poly1 & poly2 are different we pad it
		let ply = random(-1,1)
		//let poly1 = [random(-1,1), random(-1,1), random(-1,1), random(-1,1), plx, ply, plx, ply]
		let poly1 = [-1, -1, 1, -1, 0, 1, 0, 1] // triangle
		//let poly2 = [-1, -1, 1, -1, 1, 1, -1, 1] // square
		let poly2 = [-1, 1, 1, 1, 0, -1, 0, -1] // triangle invert
		
		// morph over time
		let poly = []
		for (let p = 0; p < poly1.length; p += 1) {
			poly[p] = lerp(poly1[p], poly2[p], min(1, frameCount / (height / 2)))
		}
		
		let pc = 1000 // precision per segment (less = may show quantization gaps, high = overdraw + aliasing but less gaps)
		for (let s = 0; s < (poly.length / 2); s += 1) {
			let cpm = false
			let cpp = false
			
			// poly point states
			// forward state
			let fpx = 0
			let fpy = 0
			// backward state
			let bpx = 0
			let bpy = 0
		
			for (let i = 0; i < pc; i += 1) {
				let pi = s * 2 // current vertex index
				let ni = i / pc // position on the segment

				// line
				fpx = round(lerp(x + r * poly[(pi) % poly.length], x + r * poly[(pi + 2) % poly.length], ni))
				fpy = round(lerp(y + r * poly[(pi + 1) % poly.length], y + r * poly[(pi + 3) % poly.length], ni))

				// check bounds && if it hit something
				if (fpx >= 0 && fpx < width && fpy > 0 && fpy < height && !cpm) {
					let pal = pa[fpx + fpy * width]
					let f = false
					for (let k = 0; k < pal.length; k += 1) {
						if (pal[k] != ci) {
							f = true
							break
						}
					}

					if (!f) {
						rect(fpx, fpy, 1, 1)

						pal.push(ci)
					} else {
						cpm = true
					}
				}

				// going backward
				let bip = pi
				let bip2 = pi - 2
				if (bip2 < 0) bip2 += poly.length
				let fpx2 = round(lerp(x + r * poly[bip], x + r * poly[bip2], ni))
				let fpy2 = round(lerp(y + r * poly[bip + 1], y + r * poly[bip2 + 1], ni))

				// check bounds && if it hit something
				if (fpx2 >= 0 && fpx2 < width && fpy2 > 0 && fpy2 < height && !cpp) {
					let pal = pa[fpx2 + fpy2 * width]
					let f = false
					for (let k = 0; k < pal.length; k += 1) {
						if (pal[k] != ci) {
							f = true
							break
						}
					}

					if (!f) {
						rect(fpx2, fpy2, 1, 1)

						pal.push(ci)
					} else {
						cpp = true
					}
				}

				if (cpm && cpp) {
					break
				}
			}
			
		
		}
			ci += 1
		
	}
}"
"1217513","Poly bump","mySketch","// same concept as others circles / shapes stop sketchs (draw shape iteratively but stop when bumping on other shapes)
// this ignore self bump, it use an array to track all already drawn objects to accurately guess when current shape bump and ignore self bump
// + ability to draw any shapes made out of linearly interpolated lines (polygon)
// + decrease radius over time

let pa = []
let ci = 0

let poly = [-1, -1, 1, -1, 0, 1]

function setup() {
	createCanvas(800, 800)
	background(0)
	
	noStroke()
	
	colorMode(HSL, 360, 255, 255)
	
	for (let i = 0; i < width * height; i += 1) {
		pa[i] = []
	}
}

function draw() {
	for (let c = 0; c < 10; c += 1) {
		let x = random(width / 6, width - width / 6)
		let y = random(height / 6, height - height / 6)
		
		let rmax = height / 4 * max(1, pow(frameCount / 600, 8.5))
		let r = random(4, rmax)
		
		let rc = pow(r / rmax, 0.95)
		fill((4-rc) * 100, 255-192 * rc, 255 - rc * 192)

		let cpm = false
		let cpp = false
		
		let poly = [random(-1,1), random(-1,1), random(-1,1), random(-1,1), random(-1,1), random(-1,1)]
		
		// poly point states
		// forward state
		let fpx = 0
		let fpy = 0
		// backward state
		let bpx = 0
		let bpy = 0
		
		let pc = 6000 // precision (less = may show quantization gaps, high = overdraw + aliasing but less gaps)
		let pcs = pc / (poly.length / 2) // precision per segment
		for (let i = 0; i < pc; i += 1) {
			let pi = floor(i / pcs) * 2 // current vertex index
			let ni = (i % pcs) / pcs // position on the segment

			// line
			fpx = round(lerp(x + r * poly[(pi) % poly.length], x + r * poly[(pi + 2) % poly.length], ni))
			fpy = round(lerp(y + r * poly[(pi + 1) % poly.length], y + r * poly[(pi + 3) % poly.length], ni))
			
			// check bounds && if it hit something
			if (fpx >= 0 && fpx < width && fpy > 0 && fpy < height && !cpm) {
				let pal = pa[fpx + fpy * width]
				let f = false
				for (let k = 0; k < pal.length; k += 1) {
					if (pal[k] != ci) {
						f = true
						break
					}
				}

				if (!f) {
					rect(fpx, fpy, 1, 1)

					pal.push(ci)
				} else {
					cpm = true
				}
			}
			
			// going backward
			let bip = pi
			let bip2 = pi - 2
			if (bip2 < 0) bip2 += poly.length
			let fpx2 = round(lerp(x + r * poly[bip], x + r * poly[bip2], ni))
			let fpy2 = round(lerp(y + r * poly[bip + 1], y + r * poly[bip2 + 1], ni))
			
			// check bounds && if it hit something
			if (fpx2 >= 0 && fpx2 < width && fpy2 > 0 && fpy2 < height && !cpp) {
				let pal = pa[fpx2 + fpy2 * width]
				let f = false
				for (let k = 0; k < pal.length; k += 1) {
					if (pal[k] != ci) {
						f = true
						break
					}
				}

				if (!f) {
					rect(fpx2, fpy2, 1, 1)

					pal.push(ci)
				} else {
					cpp = true
				}
			}

			if (cpm && cpp) {
				break
			}
		}
		
		ci += 1
	}
}"
"1217390","Square bump","mySketch","// same concept as others circles sketchs (draw circles iteratively but stop when bumping on other circles)
// this is the accurate version which ignore self bump, it use an array to track all already drawn objects to accurately guess when current circle bump and ignore self bump
// + decrease radius over time

let pa = []
let ci = 0

function setup() {
	createCanvas(800, 800)
	background(0)
	
	noStroke()
	
	colorMode(HSL, 360, 255, 255)
	
	for (let i = 0; i < width * height; i += 1) {
		pa[i] = []
	}
}

function draw() {
	for (let c = 0; c < 10; c += 1) {
		let x = random(width / 6, width - width / 6)
		let y = random(height / 6, height - height / 6)
		
		let rmax = height / 4 * max(1, pow(frameCount / 600, 8.5))
		let r = random(4, rmax)
		
		let rc = pow(r / rmax, 0.95)
		fill(150 + rc * 100, 192 * rc, 255 - rc * 255)

		let cpm = false
		let cpp = false
		
		let pc = 4000 // precision (less = may show quantization gaps, high = overdraw + aliasing but less gaps)
		for (let i = 0; i < pc; i += 1) {
			let ni = i / pc
			
			let cxm = round(x - r * Math.sign(sin(ni * PI * 2)))
			let cym = round(y - r * cos(ni * PI * 2))
			
			if (cxm >= 0 && cxm < width && cym > 0 && cym < height && !cpm) {
				let pal = pa[cxm + cym * width]
				let f = false
				for (let k = 0; k < pal.length; k += 1) {
					if (pal[k] != ci) {
						f = true
						break
					}
				}

				if (!f) {
					rect(cxm, cym, 1, 1)

					pal.push(ci)
				} else {
					cpm = true
				}
			}
			
			let cxp = round(x - r * sin(ni * PI * 2))
			let cyp = round(y - r * Math.sign(cos(ni * PI * 2)))
			
			if (cxp >= 0 && cxp < width && cyp > 0 && cyp < height && !cpp) {
				pal = pa[cxp + cyp * width]
				f = false
				for (let k = 0; k < pal.length; k += 1) {
					if (pal[k] != ci) {
						f = true
						break
					}
				}

				if (!f) {
					rect(cxp, cyp, 1, 1)

					pal.push(ci)
				} else {
					cpp = true
				}
			}
			
			if (cpm && cpp) {
				break
			}
		}
		
		ci += 1
	}
}"
"1216177","Floraison","mySketch","// same concept as others circles sketchs (draw circles iteratively but stop when bumping on other circles)
// this is the accurate version which ignore self bump, it use an array to track all already drawn objects to accurately guess when current circle bump and ignore self bump
// + decrease radius over time

let pa = []
let ci = 0

function setup() {
	createCanvas(800, 800)
	background(0)
	
	noStroke()
	
	colorMode(HSL, 360, 255, 255)
	
	for (let i = 0; i < width * height; i += 1) {
		pa[i] = []
	}
}

function draw() {
	for (let c = 0; c < 10; c += 1) {
		let x = random(0, width)
		let y = random(0, height)
		
		let rmax = height / 4 * max(0.1, 1 - pow(frameCount / 300, 1.5))
		let r = random(4, rmax)
		
		let rc = pow(r / rmax, 0.75)
		
		fill(160 - rc * 100* (frameCount / 500 ), 192, (pow(rc, 2.75) * 255) * (1-frameCount / 600))
		//fill(255, 255, 255)

		let cpm = false
		let cpp = false
		
		let pc = 1000 // precision (less = may show quantization gaps, high = overdraw + aliasing but less gaps)
		for (let i = 0; i < pc; i += 1) {
			let ni = i / pc
			
			let cxm = round(x + r * sin(ni * PI * (2 + (frameCount / 50))) * (ni))
			let cym = round(y + r * cos(ni * PI * (2 + (frameCount / 50))) * (ni))
			
			if (cxm >= 0 && cxm < width && cym > 0 && cym < height && !cpm) {
				let pal = pa[cxm + cym * width]
				let f = false
				for (let k = 0; k < pal.length; k += 1) {
					if (pal[k] != ci) {
						f = true
						break
					}
				}

				if (!f) {
					rect(cxm, cym, 1, 1)

					pal.push(ci)
				} else {
					cpm = true
				}
			}

			if (cpm) {
				break
			}
		}
		
		fill(rc * 200 * 2.25, random(128, 255), (pow(rc, 2.75) * 255) * (1-frameCount / 600))
		
		if (cpm) {
		for (let i = 0; i < 4000; i += 1) {
			let ni = i / 4000
			
			let cxm = round(x + (r / 32) * sin(ni * PI * 64)*ni)
			let cym = round(y + (r / 32) * cos(ni * PI * 64)*ni)
			
			if (cxm >= 0 && cxm < width && cym > 0 && cym < height) {
				let pal = pa[cxm + cym * width]
				let f = false
				for (let k = 0; k < pal.length; k += 1) {
					if (pal[k] != ci) {
						f = true
						break
					}
				}
				
				if (!f) {
					rect(cxm, cym, 1, 1)
					pal.push(ci)
				}
				else break
		}
		}}
		
		ci += 1
	}
}"
"1215337","Shapes bump 8","mySketch","// same concept as others circles sketchs (draw circles iteratively but stop when bumping on other circles)
// this is the accurate version which ignore self bump, it use an array to track all already drawn objects to accurately guess when current circle bump and ignore self bump
// + decrease radius over time

let pa = []
let ci = 0

function setup() {
	createCanvas(800, 800)
	background(0)
	
	noStroke()
	
	colorMode(HSL, 360, 255, 255)
	
	for (let i = 0; i < width * height; i += 1) {
		pa[i] = []
	}
}

function draw() {
	for (let c = 0; c < 10; c += 1) {
		let x = random(0, width)
		let y = random(0, height)
		
		let rmax = height / 4 * max(0.1, 1 - pow(frameCount / 300, 1.5))
		let r = random(4, rmax)
		
		let rc = pow(r / rmax, 0.75)
		
		fill(160 - rc * 100* (frameCount / 500 ), 192, (pow(rc, 2.75) * 255) * (1-frameCount / 600))
		//fill(255, 255, 255)

		let cpm = false
		let cpp = false
		
		let pc = 1000 // precision (less = may show quantization gaps, high = overdraw + aliasing but less gaps)
		for (let i = 0; i < pc; i += 1) {
			let ni = i / pc
			
			let cxm = round(x + r * sin(ni * PI * 2 * (1 + frameCount / 500)) * (ni))
			let cym = round(y + r * cos(ni * PI * 2 * (1 + frameCount / 500)) * (ni))
			
			if (cxm >= 0 && cxm < width && cym > 0 && cym < height && !cpm) {
				let pal = pa[cxm + cym * width]
				let f = false
				for (let k = 0; k < pal.length; k += 1) {
					if (pal[k] != ci) {
						f = true
						break
					}
				}

				if (!f) {
					rect(cxm, cym, 1, 1)

					pal.push(ci)
				} else {
					cpm = true
				}
			}

			if (cpm) {
				break
			}
		}
		
		ci += 1
	}
}"
"1214241","Circles bump vegetation with noise 2","mySketch","// same concept as others circles sketchs (draw circles iteratively but stop when bumping on other circles)
// this is the accurate version which ignore self bump, it use an array to track all already drawn objects to accurately guess when current circle bump and ignore self bump
// + decrease radius over time

let pa = []
let ci = 0

let pg = null

function setup() {
	createCanvas(800, 800)
	background(0)
	
	colorMode(HSL, 360, 255, 255)
	
	for (let i = 0; i < width * height; i += 1) {
		pa[i] = []
	}
	
	noiseDetail(6, 0.6)
	
	pg = createGraphics(width, height);
	pg.strokeWeight(8)
	pg.stroke(255);
	pg.textAlign(CENTER, CENTER);
	pg.textSize(114);
	pg.text(""PROCESSING"", width / 2, height / 3);
	/*
	stroke(255);
	textAlign(CENTER, CENTER);
	textSize(114);
	text(""PROCESSING"", width / 2, height / 2);
	*/
	noStroke();
	/*
	pg.loadPixels();
	for (let i = 0; i < width * height; i += 1) {
		let v = pg.pixels[i * 4]
		if (v) {
			pa[i].push(v * 100000)
		}
	}*/
}

function draw() {
	pg.loadPixels();
	for (let c = 0; c < 20; c += 1) {
		let x = random(0, width)
		let y = height - frameCount
		
		let rmax = max(0.1, height / 4 * max(0.1, 1 - pow(frameCount / 300, 4.5)) * (1-pg.pixels[(floor(x) + y * height) * 4] / 255) - (height / 24) * (1 - y / height) * noise(x / width * 8, y / height * 8))
		let r = random(4, rmax)
		
		let rc = r / rmax
		
		let cpm = false
		let cpp = false
		
		let pc = 1000 // precision (less = may show quantization gaps, high = overdraw + aliasing but less gaps)
		for (let i = 0; i < pc; i += 1) {
			let ni = i / pc
			fill(200 - rc * 240* (frameCount / 1000 ), 192, (255 - pow(rc, 0.95) * 255))
			let cxm = round(x - r * sin(ni * PI * 2))
			let cym = round(y - r * cos(ni * PI * 2))
			
			if (cxm >= 0 && cxm < width && cym > 0 && cym < height && !cpm) {
				let pal = pa[cxm + cym * width]
				let f = false
				for (let k = 0; k < pal.length; k += 1) {
					if (pal[k] != ci) {
						f = true
						break
					}
				}

				if (!f) {
					rect(cxm, cym, 1, 1)

					pal.push(ci)
				} else {
					cpm = true
				}
			}
			
			let cxp = round(x - r * sin(-ni * PI * 2))
			let cyp = round(y - r * cos(-ni * PI * 2))
			
			if (cxp >= 0 && cxp < width && cyp > 0 && cyp < height && !cpp) {
				pal = pa[cxp + cyp * width]
				f = false
				for (let k = 0; k < pal.length; k += 1) {
					if (pal[k] != ci) {
						f = true
						break
					}
				}

				if (!f) {
					rect(cxp, cyp, 1, 1)

					pal.push(ci)
				} else {
					cpp = true
				}
			}
			
			if (cpm && cpp) {
				break
			}
		}
		
		ci += 1
	}
}"
"1214199","Circles bump vegetation with noise","mySketch","// same concept as others circles sketchs (draw circles iteratively but stop when bumping on other circles)
// this is the accurate version which ignore self bump, it use an array to track all already drawn objects to accurately guess when current circle bump and ignore self bump
// + decrease radius over time

let pa = []
let ci = 0

let pg = null

function setup() {
	createCanvas(800, 800)
	background(0)
	
	colorMode(HSL, 360, 255, 255)
	
	for (let i = 0; i < width * height; i += 1) {
		pa[i] = []
	}
	
	noiseDetail(6, 0.6)
	
	pg = createGraphics(width, height);
	pg.strokeWeight(8)
	pg.stroke(255);
	pg.textAlign(CENTER, CENTER);
	pg.textSize(114);
	pg.text(""PROCESSING"", width / 2, height / 2);
	/*
	stroke(255);
	textAlign(CENTER, CENTER);
	textSize(114);
	text(""PROCESSING"", width / 2, height / 2);
	*/
	noStroke();
	
	pg.loadPixels();
	for (let i = 0; i < width * height; i += 1) {
		let v = pg.pixels[i * 4]
		if (v) {
			pa[i].push(v * 100000)
		}
	}
}

function draw() {
	pg.loadPixels();
	for (let c = 0; c < 30; c += 1) {
		let x = random(0, width)
		let y = height - frameCount
		
		let rmax = max(0.1, height / 6 * max(0.1, 1 - pow(frameCount / 300, 4.5)) * (1-pg.pixels[(floor(x) + y * height) * 4] / 255) - (height / 48) * (1 - y / height) * noise(x / width * 8, y / height * 8))
		let r = random(4, rmax)
		
		let rc = r / rmax
		
		let cpm = false
		let cpp = false
		
		let pc = 4000 // precision (less = may show quantization gaps, high = overdraw + aliasing but less gaps)
		for (let i = 0; i < pc; i += 1) {
			let ni = i / pc
			fill(0 + rc * 200* (frameCount / 800 ), 192, (255 - pow(rc, 0.75) * 255))
			let cxm = round(x - r * sin(ni * PI * 2))
			let cym = round(y - r * cos(ni * PI * 2))
			
			if (cxm >= 0 && cxm < width && cym > 0 && cym < height && !cpm) {
				let pal = pa[cxm + cym * width]
				let f = false
				for (let k = 0; k < pal.length; k += 1) {
					if (pal[k] != ci) {
						f = true
						break
					}
				}

				if (!f) {
					rect(cxm, cym, 1, 1)

					pal.push(ci)
				} else {
					cpm = true
				}
			}
			
			let cxp = round(x - r * sin(-ni * PI * 2))
			let cyp = round(y - r * cos(-ni * PI * 2))
			
			if (cxp >= 0 && cxp < width && cyp > 0 && cyp < height && !cpp) {
				pal = pa[cxp + cyp * width]
				f = false
				for (let k = 0; k < pal.length; k += 1) {
					if (pal[k] != ci) {
						f = true
						break
					}
				}

				if (!f) {
					rect(cxp, cyp, 1, 1)

					pal.push(ci)
				} else {
					cpp = true
				}
			}
			
			if (cpm && cpp) {
				break
			}
		}
		
		ci += 1
	}
}"
"1213993","Circles bump text","mySketch","// same concept as others circles sketchs (draw circles iteratively but stop when bumping on other circles)
// this is the accurate version which ignore self bump, it use an array to track all already drawn objects to accurately guess when current circle bump and ignore self bump
// + decrease radius over time

let pa = []
let ci = 0

let pg = null

function setup() {
	createCanvas(800, 800)
	background(0)
	
	noStroke()
	
	colorMode(HSL, 360, 255, 255)
	
	for (let i = 0; i < width * height; i += 1) {
		pa[i] = []
	}
	
	pg = createGraphics(width, height);
	pg.fill(255);
	pg.textAlign(CENTER, CENTER);
	pg.textSize(114);
	pg.text(""PROCESSING"", width / 2, height / 2);
	
	fill(255);
	textAlign(CENTER, CENTER);
	textSize(114);
	text(""PROCESSING"", width / 2, height / 2);
	/*
	pg.loadPixels();
	for (let i = 0; i < width * height; i += 1) {
		let v = pg.pixels[i * 4]
		if (v) {
			pa[i].push(v * 100000)
		}
	}*/
}

function draw() {
	pg.loadPixels();
	for (let c = 0; c < 10; c += 1) {
		let x = random(0, width)
		let y = height - frameCount
		
		let rmax = height / 6 * max(0.1, 1 - pow(frameCount / 300, 4.5)) * (1-pg.pixels[(floor(x) + y * height) * 4] / 255)
		let r = random(4, rmax)
		
		let rc = r / rmax
		
		let cpm = false
		let cpp = false
		
		let pc = 4000 // precision (less = may show quantization gaps, high = overdraw + aliasing but less gaps)
		for (let i = 0; i < pc; i += 1) {
			let ni = i / pc
			fill(0 + rc * 200* (frameCount / 800 ), 192, (255 - pow(rc, 0.75) * 255))
			let cxm = round(x - r * sin(ni * PI * 2))
			let cym = round(y - r * cos(ni * PI * 2))
			
			if (cxm >= 0 && cxm < width && cym > 0 && cym < height && !cpm) {
				let pal = pa[cxm + cym * width]
				let f = false
				for (let k = 0; k < pal.length; k += 1) {
					if (pal[k] != ci) {
						f = true
						break
					}
				}

				if (!f) {
					rect(cxm, cym, 1, 1)

					pal.push(ci)
				} else {
					cpm = true
				}
			}
			
			let cxp = round(x - r * sin(-ni * PI * 2))
			let cyp = round(y - r * cos(-ni * PI * 2))
			
			if (cxp >= 0 && cxp < width && cyp > 0 && cyp < height && !cpp) {
				pal = pa[cxp + cyp * width]
				f = false
				for (let k = 0; k < pal.length; k += 1) {
					if (pal[k] != ci) {
						f = true
						break
					}
				}

				if (!f) {
					rect(cxp, cyp, 1, 1)

					pal.push(ci)
				} else {
					cpp = true
				}
			}
			
			if (cpm && cpp) {
				break
			}
		}
		
		ci += 1
	}
}"
"1213974","Circles bump V","mySketch","// same concept as others circles sketchs (draw circles iteratively but stop when bumping on other circles)
// this is the accurate version which ignore self bump, it use an array to track all already drawn objects to accurately guess when current circle bump and ignore self bump
// + decrease radius over time

let pa = []
let ci = 0

function setup() {
	createCanvas(800, 800)
	background(0)
	
	noStroke()
	
	colorMode(HSL, 360, 255, 255)
	
	for (let i = 0; i < width * height; i += 1) {
		pa[i] = []
	}
}

function draw() {
	for (let c = 0; c < 10; c += 1) {
		let x = random(0, width)
		let y = frameCount
		
		let rmax = height / 8 * max(0.01, 1 - pow(frameCount / 800, 1.5)) * sin(abs(0.5-x / width)*2 * PI * 2 + frameCount / 120)
		let r = random(4, rmax)
		
		let rc = r / rmax
		

		let cpm = false
		let cpp = false
		
		let pc = 4000 // precision (less = may show quantization gaps, high = overdraw + aliasing but less gaps)
		for (let i = 0; i < pc; i += 1) {
			let ni = i / pc
			fill(0 + rc * 200* (frameCount / 800 ), 192*ni, (255 - pow(rc, 0.75) * 255))
			let cxm = round(x + r * sin(ni * PI * 2))
			let cym = round(y + r * cos(ni * PI * 2))
			
			if (cxm >= 0 && cxm < width && cym > 0 && cym < height && !cpm) {
				let pal = pa[cxm + cym * width]
				let f = false
				for (let k = 0; k < pal.length; k += 1) {
					if (pal[k] != ci) {
						f = true
						break
					}
				}

				if (!f) {
					rect(cxm, cym, 1, 1)

					pal.push(ci)
				} else {
					cpm = true
				}
			}
			
			let cxp = round(x + r * sin(-ni * PI * 2))
			let cyp = round(y + r * cos(-ni * PI * 2))
			
			if (cxp >= 0 && cxp < width && cyp > 0 && cyp < height && !cpp) {
				pal = pa[cxp + cyp * width]
				f = false
				for (let k = 0; k < pal.length; k += 1) {
					if (pal[k] != ci) {
						f = true
						break
					}
				}

				if (!f) {
					rect(cxp, cyp, 1, 1)

					pal.push(ci)
				} else {
					cpp = true
				}
			}
			
			if (cpm && cpp) {
				break
			}
		}
		
		ci += 1
	}
}"
"1213963","Circles bump accurate 5","mySketch","// same concept as others circles sketchs (draw circles iteratively but stop when bumping on other circles)
// this is the accurate version which ignore self bump, it use an array to track all already drawn objects to accurately guess when current circle bump and ignore self bump
// + decrease radius over time

let pa = []
let ci = 0

function setup() {
	createCanvas(800, 800)
	background(0)
	
	noStroke()
	
	colorMode(HSL, 360, 255, 255)
	
	for (let i = 0; i < width * height; i += 1) {
		pa[i] = []
	}
}

function draw() {
	for (let c = 0; c < 10; c += 1) {
		let x = random(0, width)
		let y = random(0, height)
		
		let rmax = height / 1 * max(0.1, 1 - pow(frameCount / 800, 1.5))
		let r = random(4, rmax)
		
		let rc = pow(r / rmax, 0.75)
		

		let cpm = false
		let cpp = false
		
		let pc = 4000 // precision (less = may show quantization gaps, high = overdraw + aliasing but less gaps)
		for (let i = 0; i < pc; i += 1) {
			let ni = i / pc
			fill(0 + rc * 200* (frameCount / 800 ), 192*ni, (255 - pow(rc, 1.75) * 255) * (1-frameCount / 1900) * ni)
			let cxm = round(x + r * sin(ni * PI * 2))
			let cym = round(y + r * cos(ni * PI * 2))
			
			if (cxm >= 0 && cxm < width && cym > 0 && cym < height && !cpm) {
				let pal = pa[cxm + cym * width]
				let f = false
				for (let k = 0; k < pal.length; k += 1) {
					if (pal[k] != ci) {
						f = true
						break
					}
				}

				if (!f) {
					rect(cxm, cym, 1, 1)

					pal.push(ci)
				} else {
					cpm = true
				}
			}
			
			let cxp = round(x + r * sin(-ni * PI * 2))
			let cyp = round(y + r * cos(-ni * PI * 2))
			
			if (cxp >= 0 && cxp < width && cyp > 0 && cyp < height && !cpp) {
				pal = pa[cxp + cyp * width]
				f = false
				for (let k = 0; k < pal.length; k += 1) {
					if (pal[k] != ci) {
						f = true
						break
					}
				}

				if (!f) {
					rect(cxp, cyp, 1, 1)

					pal.push(ci)
				} else {
					cpp = true
				}
			}
			
			if (cpm && cpp) {
				break
			}
		}
		
		ci += 1
	}
}"
"1213104","Bump eyes","mySketch","// same concept as others circles sketchs (draw circles iteratively but stop when bumping on other circles)
// this is the accurate version which ignore self bump, it use an array to track all already drawn objects to accurately guess when current circle bump and ignore self bump
// + decrease radius over time

let pa = []
let ci = 0

function setup() {
	createCanvas(800, 800)
	background(0)
	
	noStroke()
	
	colorMode(HSL, 360, 255, 255)
	
	for (let i = 0; i < width * height; i += 1) {
		pa[i] = []
	}
}

function draw() {
	for (let c = 0; c < 10; c += 1) {
		let x = width / 2 + width / 2.5 * sin(frameCount / 100 * PI * 16)* max(0.1, 1 - pow(frameCount / 600, 1.25 - 1 * frameCount / 300))//random(0, width)
		let y = height / 2 + height / 2.5 * cos(frameCount / 100 * PI * 16)* max(0.1, 1 - pow(frameCount / 600, 1.25 - 1 * frameCount / 300 ))//random(0, height)
		
		let rmax = height / 8.5 * max(0.1, 1 - pow(frameCount / 300, 0.5))
		let r = random(4, rmax)
		
		let rc = pow(r / rmax, 2)
		
		fill((200 + rc * 100* (frameCount / 200 )) % 360, 192, (pow(rc, 1.75) * 255) * pow(1-frameCount / 600, 2))

		let cpm = false
		let cpp = false
		
		let pc = 4000 // precision (less = may show quantization gaps, high = overdraw + aliasing but less gaps)
		for (let i = 0; i < pc; i += 1) {
			let ni = i / pc
			
			let cxm = round(x + r * sin(ni * PI * 2))
			let cym = round(y + r * cos(ni * PI * 2))
			
			if (cxm >= 0 && cxm < width && cym > 0 && cym < height && !cpm) {
				let pal = pa[cxm + cym * width]
				let f = false
				for (let k = 0; k < pal.length; k += 1) {
					if (pal[k] != ci) {
						f = true
						break
					}
				}

				if (!f) {
					rect(cxm, cym, 1, 1)

					pal.push(ci)
				} else {
					cpm = true
				}
			}
			
			let cxp = round(x + r * sin(-ni * PI * 2) )
			let cyp = round(y + r * cos(-ni * PI * 2) )
			
			if (cxp >= 0 && cxp < width && cyp > 0 && cyp < height && !cpp) {
				pal = pa[cxp + cyp * width]
				f = false
				for (let k = 0; k < pal.length; k += 1) {
					if (pal[k] != ci) {
						f = true
						break
					}
				}

				if (!f) {
					rect(cxp, cyp, 1, 1)

					pal.push(ci)
				} else {
					cpp = true
				}
			}
			
			if (cpm && cpp) {
				break
			}
		}
		
		ci += 1
	}
}"
"1213089","Bump","mySketch","// same concept as others circles sketchs (draw circles iteratively but stop when bumping on other circles)
// this is the accurate version which ignore self bump, it use an array to track all already drawn objects to accurately guess when current circle bump and ignore self bump
// + decrease radius over time

let pa = []
let ci = 0

function setup() {
	createCanvas(800, 800)
	background(0)
	
	noStroke()
	
	colorMode(HSL, 360, 255, 255)
	
	for (let i = 0; i < width * height; i += 1) {
		pa[i] = []
	}
}

function draw() {
	for (let c = 0; c < 10; c += 1) {
		let x = width / 2 + width / 3 * sin(frameCount / 100 * PI * 8)* max(0.1, 1 - pow(frameCount / 300, 0.5))//random(0, width)
		let y = height / 2 + height / 3 * cos(frameCount / 100 * PI * 8)* max(0.1, 1 - pow(frameCount / 300, 0.5))//random(0, height)
		
		let rmax = height / 8 //* max(0.1, 1 - pow(frameCount / 300, 0.5))
		let r = random(4, rmax)
		
		let rc = pow(r / rmax, 1)
		
		fill(200 + rc * 100* (frameCount / 200 ), 192, (pow(rc, 1.75) * 255) * (1-frameCount / 600))

		let cpm = false
		let cpp = false
		
		let pc = 4000 // precision (less = may show quantization gaps, high = overdraw + aliasing but less gaps)
		for (let i = 0; i < pc; i += 1) {
			let ni = i / pc
			
			let cxm = round(x - r * sin(ni * PI * 2))
			let cym = round(y - r * cos(ni * PI * 2))
			
			if (cxm >= 0 && cxm < width && cym > 0 && cym < height && !cpm) {
				let pal = pa[cxm + cym * width]
				let f = false
				for (let k = 0; k < pal.length; k += 1) {
					if (pal[k] != ci) {
						f = true
						break
					}
				}

				if (!f) {
					rect(cxm, cym, 1, 1)

					pal.push(ci)
				} else {
					cpm = true
				}
			}
			
			let cxp = round(x - r * sin(-ni * PI * 2) )
			let cyp = round(y - r * cos(-ni * PI * 2) )
			
			if (cxp >= 0 && cxp < width && cyp > 0 && cyp < height && !cpp) {
				pal = pa[cxp + cyp * width]
				f = false
				for (let k = 0; k < pal.length; k += 1) {
					if (pal[k] != ci) {
						f = true
						break
					}
				}

				if (!f) {
					rect(cxp, cyp, 1, 1)

					pal.push(ci)
				} else {
					cpp = true
				}
			}
			
			if (cpm && cpp) {
				break
			}
		}
		
		ci += 1
	}
}"
"1213084","Shapes bump 4","mySketch","// same concept as others circles sketchs (draw circles iteratively but stop when bumping on other circles)
// this is the accurate version which ignore self bump, it use an array to track all already drawn objects to accurately guess when current circle bump and ignore self bump
// + decrease radius over time

let pa = []
let ci = 0

function setup() {
	createCanvas(800, 800)
	background(0)
	
	noStroke()
	
	colorMode(HSL, 360, 255, 255)
	
	for (let i = 0; i < width * height; i += 1) {
		pa[i] = []
	}
}

function draw() {
	for (let c = 0; c < 10; c += 1) {
		let x = random(0, width)
		let y = random(0, height)
		
		let rmax = height / 4 * max(0.1, 1 - pow(frameCount / 300, 1.5))
		let r = random(4, rmax)
		
		let rc = pow(r / rmax, 0.75)
		
		fill(200 + rc * 200* (frameCount / 200 ), 192, (pow(rc, 2.75) * 255) * (1-frameCount / 600))

		let cpm = false
		let cpp = false
		
		let pc = 4000 // precision (less = may show quantization gaps, high = overdraw + aliasing but less gaps)
		for (let i = 0; i < pc; i += 1) {
			let ni = i / pc
			
			let cxm = round(x - r - sin(ni * PI * 1) * (ni))
			let cym = round(y - r - cos(ni * PI * 1) * (-ni*800))
			
			if (cxm >= 0 && cxm < width && cym > 0 && cym < height && !cpm) {
				let pal = pa[cxm + cym * width]
				let f = false
				for (let k = 0; k < pal.length; k += 1) {
					if (pal[k] != ci) {
						f = true
						break
					}
				}

				if (!f) {
					rect(cxm, cym, 1, 1)

					pal.push(ci)
				} else {
					cpm = true
				}
			}
			
			let cxp = round(x - r * sin(ni * PI * 2) )
			let cyp = round(y - r * cos(ni * PI * 2) )
			
			if (cxp >= 0 && cxp < width && cyp > 0 && cyp < height && !cpp) {
				pal = pa[cxp + cyp * width]
				f = false
				for (let k = 0; k < pal.length; k += 1) {
					if (pal[k] != ci) {
						f = true
						break
					}
				}

				if (!f) {
					rect(cxp, cyp, 1, 1)

					pal.push(ci)
				} else {
					cpp = true
				}
			}
			
			if (cpm && cpp) {
				break
			}
		}
		
		ci += 1
	}
}"
"1212995","Spiral bump 2","mySketch","// same concept as others circles sketchs (draw circles iteratively but stop when bumping on other circles)
// this is the accurate version which ignore self bump, it use an array to track all already drawn objects to accurately guess when current circle bump and ignore self bump
// + decrease radius over time

let pa = []
let ci = 0

function setup() {
	createCanvas(800, 800)
	background(0)
	
	noStroke()
	
	colorMode(HSL, 360, 255, 255)
	
	for (let i = 0; i < width * height; i += 1) {
		pa[i] = []
	}
}

function draw() {
	for (let c = 0; c < 10; c += 1) {
		let x = random(0, width)
		let y = random(0, height)
		
		let rmax = height / 64 * max(0.1, 1 - pow(frameCount / 300, 1.5))
		let r = random(4, rmax)
		
		let rc = pow(r / rmax, 0.75)
		
		fill(200 + rc * 200* (frameCount / 200 ), 192, (pow(rc, 2.75) * 255) * (1-frameCount / 600))

		let cpm = false
		let cpp = false
		
		let pc = 4000 // precision (less = may show quantization gaps, high = overdraw + aliasing but less gaps)
		for (let i = 0; i < pc; i += 1) {
			let ni = i / pc
			
			let cxm = round(x - r - sin(ni * PI * 8) * (ni*200))
			let cym = round(y - r - cos(ni * PI * 8) * (-ni*200))
			
			if (cxm >= 0 && cxm < width && cym > 0 && cym < height && !cpm) {
				let pal = pa[cxm + cym * width]
				let f = false
				for (let k = 0; k < pal.length; k += 1) {
					if (pal[k] != ci) {
						f = true
						break
					}
				}

				if (!f) {
					rect(cxm, cym, 1, 1)

					pal.push(ci)
				} else {
					cpm = true
				}
			}
			
			let cxp = round(x - r + sin(ni * PI * 64) * (ni*100))
			let cyp = round(y - r + cos(ni * PI * 64) * (-ni*100))
			
			if (cxp >= 0 && cxp < width && cyp > 0 && cyp < height && !cpp) {
				pal = pa[cxp + cyp * width]
				f = false
				for (let k = 0; k < pal.length; k += 1) {
					if (pal[k] != ci) {
						f = true
						break
					}
				}

				if (!f) {
					rect(cxp, cyp, 1, 1)

					pal.push(ci)
				} else {
					cpp = true
				}
			}
			
			if (cpm && cpp) {
				break
			}
		}
		
		ci += 1
	}
}"
"1212992","Spiral bump","mySketch","// same concept as others circles sketchs (draw circles iteratively but stop when bumping on other circles)
// this is the accurate version which ignore self bump, it use an array to track all already drawn objects to accurately guess when current circle bump and ignore self bump
// + decrease radius over time

let pa = []
let ci = 0

function setup() {
	createCanvas(800, 800)
	background(0)
	
	noStroke()
	
	colorMode(HSL, 360, 255, 255)
	
	for (let i = 0; i < width * height; i += 1) {
		pa[i] = []
	}
}

function draw() {
	for (let c = 0; c < 10; c += 1) {
		let x = random(0, width)
		let y = random(0, height)
		
		let rmax = height / 64 * max(0.1, 1 - pow(frameCount / 300, 1.5))
		let r = random(4, rmax)
		
		let rc = pow(r / rmax, 0.75)
		
		fill(200 + rc * 200* (frameCount / 200 ), 192, (pow(rc, 2.75) * 255) * (1-frameCount / 600))

		let cpm = false
		let cpp = false
		
		let pc = 4000 // precision (less = may show quantization gaps, high = overdraw + aliasing but less gaps)
		for (let i = 0; i < pc; i += 1) {
			let ni = i / pc
			
			let cxm = round(x - r - sin(ni * PI * 16) * (ni*100))
			let cym = round(y - r - cos(ni * PI * 16) * (ni*100))
			
			if (cxm >= 0 && cxm < width && cym > 0 && cym < height && !cpm) {
				let pal = pa[cxm + cym * width]
				let f = false
				for (let k = 0; k < pal.length; k += 1) {
					if (pal[k] != ci) {
						f = true
						break
					}
				}

				if (!f) {
					rect(cxm, cym, 1, 1)

					pal.push(ci)
				} else {
					cpm = true
				}
			}
			
			let cxp = round(x - r + sin(ni * PI * 16) * (ni*100))
			let cyp = round(y - r + cos(ni * PI * 16) * (ni*100))
			
			if (cxp >= 0 && cxp < width && cyp > 0 && cyp < height && !cpp) {
				pal = pa[cxp + cyp * width]
				f = false
				for (let k = 0; k < pal.length; k += 1) {
					if (pal[k] != ci) {
						f = true
						break
					}
				}

				if (!f) {
					rect(cxp, cyp, 1, 1)

					pal.push(ci)
				} else {
					cpp = true
				}
			}
			
			if (cpm && cpp) {
				break
			}
		}
		
		ci += 1
	}
}"
"1212990","Gribouillis bump","mySketch","// same concept as others circles sketchs (draw circles iteratively but stop when bumping on other circles)
// this is the accurate version which ignore self bump, it use an array to track all already drawn objects to accurately guess when current circle bump and ignore self bump
// + decrease radius over time

let pa = []
let ci = 0

function setup() {
	createCanvas(800, 800)
	background(0)
	
	noStroke()
	
	colorMode(HSL, 360, 255, 255)
	
	for (let i = 0; i < width * height; i += 1) {
		pa[i] = []
	}
}

function draw() {
	for (let c = 0; c < 10; c += 1) {
		let x = random(0, width)
		let y = random(0, height)
		
		let rmax = height / 8 * max(0.1, 1 - pow(frameCount / 300, 1.5))
		let r = random(4, rmax)
		
		let rc = pow(r / rmax, 0.75)
		
		fill(200 + rc * 200* (frameCount / 200 ), 192, (pow(rc, 2.75) * 255) * (1-frameCount / 600))

		let cpm = false
		let cpp = false
		
		let pc = 4000 // precision (less = may show quantization gaps, high = overdraw + aliasing but less gaps)
		for (let i = 0; i < pc; i += 1) {
			let ni = i / pc
			
			let cxm = round(x - r * sin(ni * PI * 16 * cos(frameCount / 4)) * (ni))
			let cym = round(y - r * cos(ni * PI * 16 * sin(frameCount / 4)) * (ni))
			
			if (cxm >= 0 && cxm < width && cym > 0 && cym < height && !cpm) {
				let pal = pa[cxm + cym * width]
				let f = false
				for (let k = 0; k < pal.length; k += 1) {
					if (pal[k] != ci) {
						f = true
						break
					}
				}

				if (!f) {
					rect(cxm, cym, 1, 1)

					pal.push(ci)
				} else {
					cpm = true
				}
			}
			
			let cxp = round(x - r * sin(-ni * PI * 8) * (1-ni))
			let cyp = round(y - r * cos(-ni * PI * 8) * (1-ni))
			
			if (cxp >= 0 && cxp < width && cyp > 0 && cyp < height && !cpp) {
				pal = pa[cxp + cyp * width]
				f = false
				for (let k = 0; k < pal.length; k += 1) {
					if (pal[k] != ci) {
						f = true
						break
					}
				}

				if (!f) {
					rect(cxp, cyp, 1, 1)

					pal.push(ci)
				} else {
					cpp = true
				}
			}
			
			if (cpm && cpp) {
				break
			}
		}
		
		ci += 1
	}
}"
"1212986","Shapes bump 4","mySketch","// same concept as others circles sketchs (draw circles iteratively but stop when bumping on other circles)
// this is the accurate version which ignore self bump, it use an array to track all already drawn objects to accurately guess when current circle bump and ignore self bump
// + decrease radius over time

let pa = []
let ci = 0

function setup() {
	createCanvas(800, 800)
	background(0)
	
	noStroke()
	
	colorMode(HSL, 360, 255, 255)
	
	for (let i = 0; i < width * height; i += 1) {
		pa[i] = []
	}
}

function draw() {
	for (let c = 0; c < 10; c += 1) {
		let x = random(0, width)
		let y = random(0, height)
		
		let rmax = height / 8 * max(0.1, 1 - pow(frameCount / 300, 1.5))
		let r = random(4, rmax)
		
		let rc = pow(r / rmax, 0.75)
		
		fill(200 + rc * 120* (frameCount / 200 ), 192, (pow(rc, 2.75) * 255) * (1-frameCount / 600))

		let cpm = false
		let cpp = false
		
		let pc = 4000 // precision (less = may show quantization gaps, high = overdraw + aliasing but less gaps)
		for (let i = 0; i < pc; i += 1) {
			let ni = i / pc
			
			let cxm = round(x - r * sin(rc * PI * 16) * (ni))
			let cym = round(y - r * cos(rc * PI * 16) * (ni))
			
			if (cxm >= 0 && cxm < width && cym > 0 && cym < height && !cpm) {
				let pal = pa[cxm + cym * width]
				let f = false
				for (let k = 0; k < pal.length; k += 1) {
					if (pal[k] != ci) {
						f = true
						break
					}
				}

				if (!f) {
					rect(cxm, cym, 1, 1)

					pal.push(ci)
				} else {
					cpm = true
				}
			}
			
			let cxp = round(x - r * sin(-ni * PI * 16) * (ni))
			let cyp = round(y - r * cos(-ni * PI * 16) * (ni))
			
			if (cxp >= 0 && cxp < width && cyp > 0 && cyp < height && !cpp) {
				pal = pa[cxp + cyp * width]
				f = false
				for (let k = 0; k < pal.length; k += 1) {
					if (pal[k] != ci) {
						f = true
						break
					}
				}

				if (!f) {
					rect(cxp, cyp, 1, 1)

					pal.push(ci)
				} else {
					cpp = true
				}
			}
			
			if (cpm && cpp) {
				break
			}
		}
		
		ci += 1
	}
}"
"1212979","Circles bump accurate 3","mySketch","// same concept as others circles sketchs (draw circles iteratively but stop when bumping on other circles)
// this is the accurate version which ignore self bump, it use an array to track all already drawn objects to accurately guess when current circle bump and ignore self bump
// + decrease radius over time

let pa = []
let ci = 0

function setup() {
	createCanvas(800, 800)
	background(0)
	
	noStroke()
	
	colorMode(HSL, 360, 255, 255)
	
	for (let i = 0; i < width * height; i += 1) {
		pa[i] = []
	}
}

function draw() {
	for (let c = 0; c < 10; c += 1) {
		let x = random(0, width)
		let y = random(0, height)
		
		let rmax = height / 8 * max(0.1, 1 - pow(frameCount / 300, 1.5))
		let r = random(4, rmax)
		
		let rc = pow(r / rmax, 0.75)
		

		let cpm = false
		let cpp = false
		
		let pc = 4000 // precision (less = may show quantization gaps, high = overdraw + aliasing but less gaps)
		for (let i = 0; i < pc; i += 1) {
			let ni = i / pc
			fill(0 + rc * 200* (frameCount / 400 ), 192*ni, (255 - pow(rc, 1.75) * 255) * (1-frameCount / 600) * ni)
			let cxm = round(x - r * sin(ni * PI * 2))
			let cym = round(y - r * cos(ni * PI * 2))
			
			if (cxm >= 0 && cxm < width && cym > 0 && cym < height && !cpm) {
				let pal = pa[cxm + cym * width]
				let f = false
				for (let k = 0; k < pal.length; k += 1) {
					if (pal[k] != ci) {
						f = true
						break
					}
				}

				if (!f) {
					rect(cxm, cym, 1, 1)

					pal.push(ci)
				} else {
					cpm = true
				}
			}
			
			let cxp = round(x - r * sin(-ni * PI * 2))
			let cyp = round(y - r * cos(-ni * PI * 2))
			
			if (cxp >= 0 && cxp < width && cyp > 0 && cyp < height && !cpp) {
				pal = pa[cxp + cyp * width]
				f = false
				for (let k = 0; k < pal.length; k += 1) {
					if (pal[k] != ci) {
						f = true
						break
					}
				}

				if (!f) {
					rect(cxp, cyp, 1, 1)

					pal.push(ci)
				} else {
					cpp = true
				}
			}
			
			if (cpm && cpp) {
				break
			}
		}
		
		ci += 1
	}
}"
"1212881","Circles bump accurate 3","mySketch","// same concept as others circles sketchs (draw circles iteratively but stop when bumping on other circles)
// this is the accurate version which ignore self bump, it use an array to track all already drawn objects to accurately guess when current circle bump and ignore self bump
// + decrease radius over time

let pa = []
let ci = 0

function setup() {
	createCanvas(800, 800)
	background(0)
	
	noStroke()
	
	colorMode(HSL, 360, 255, 255)

	for (let i = 0; i < width * height; i += 1) {
		pa[i] = []
	}
}

function draw() {
	for (let c = 0; c < 10; c += 1) {
		let x = random(0, width)
		let y = random(0, height)
		
		let rmax = height / 32 * max(0.1, 1 - pow(frameCount / 300, 0.5))
		let r = random(4, rmax)
		
		let rc = pow(r / rmax, 1)
		fill(0 + ((rc + frameCount / 300) % 1) * 30 + pow(frameCount, 1.25), 192, 255 - ((rc + frameCount / 300) % 1) * 255)

		let cpm = false
		let cpp = false
		
		let pc = 4000 // precision (less = may show quantization gaps, high = overdraw + aliasing but less gaps)
		for (let i = 0; i < pc; i += 1) {
			let ni = i / pc
			
			let cxm = round(x - r * sin(ni * PI * 2))
			let cym = round(y - r * cos(ni * PI * 2))
			
			if (cxm >= 0 && cxm < width && cym > 0 && cym < height && !cpm) {
				let pal = pa[cxm + cym * width]
				let f = false
				for (let k = 0; k < pal.length; k += 1) {
					if (pal[k] != ci) {
						f = true
						break
					}
				}

				if (!f) {
					rect(cxm, cym, 1, 1)

					pal.push(ci)
				} else {
					cpm = true
				}
			}
			
			let cxp = round(x - r * sin(-ni * PI * 2))
			let cyp = round(y - r * cos(-ni * PI * 2))
			
			if (cxp >= 0 && cxp < width && cyp > 0 && cyp < height && !cpp) {
				pal = pa[cxp + cyp * width]
				f = false
				for (let k = 0; k < pal.length; k += 1) {
					if (pal[k] != ci) {
						f = true
						break
					}
				}

				if (!f) {
					rect(cxp, cyp, 1, 1)

					pal.push(ci)
				} else {
					cpp = true
				}
			}
			
			if (cpm && cpp) {
				break
			}
		}
		
		ci += 1
	}
}"
"1212878","Circles bump accurate 2","mySketch","// same concept as others circles sketchs (draw circles iteratively but stop when bumping on other circles)
// this is the accurate version which ignore self bump, it use an array to track all already drawn objects to accurately guess when current circle bump and ignore self bump
// + decrease radius over time

let pa = []
let ci = 0

function setup() {
	createCanvas(800, 800)
	background(0)
	
	noStroke()
	
	colorMode(HSL, 360, 255, 255)
	
	for (let i = 0; i < width * height; i += 1) {
		pa[i] = []
	}
}

function draw() {
	for (let c = 0; c < 10; c += 1) {
		let x = random(0, width)
		let y = random(0, height)
		
		let rmax = height / 1 * max(0.1, 1 - pow(frameCount / 300, 0.5))
		let r = random(4, rmax)
		
		let rc = pow(r / rmax, 0.75)
		fill(0 + rc * 100, 192, 255 - rc * 255)

		let cpm = false
		let cpp = false
		
		let pc = 4000 // precision (less = may show quantization gaps, high = overdraw + aliasing but less gaps)
		for (let i = 0; i < pc; i += 1) {
			let ni = i / pc
			
			let cxm = round(x - r * sin(ni * PI * 2))
			let cym = round(y - r * cos(ni * PI * 2))
			
			if (cxm >= 0 && cxm < width && cym > 0 && cym < height && !cpm) {
				let pal = pa[cxm + cym * width]
				let f = false
				for (let k = 0; k < pal.length; k += 1) {
					if (pal[k] != ci) {
						f = true
						break
					}
				}

				if (!f) {
					rect(cxm, cym, 1, 1)

					pal.push(ci)
				} else {
					cpm = true
				}
			}
			
			let cxp = round(x - r * sin(-ni * PI * 2))
			let cyp = round(y - r * cos(-ni * PI * 2))
			
			if (cxp >= 0 && cxp < width && cyp > 0 && cyp < height && !cpp) {
				pal = pa[cxp + cyp * width]
				f = false
				for (let k = 0; k < pal.length; k += 1) {
					if (pal[k] != ci) {
						f = true
						break
					}
				}

				if (!f) {
					rect(cxp, cyp, 1, 1)

					pal.push(ci)
				} else {
					cpp = true
				}
			}
			
			if (cpm && cpp) {
				break
			}
		}
		
		ci += 1
	}
}"
"1212875","Circles bump accurate","mySketch","// same concept as others circles sketchs (draw circles iteratively but stop when bumping on other circles)
// this is the accurate version which ignore self bump, it use an array to track all already drawn objects to accurately guess when current circle bump and ignore self bump

let pa = []
let ci = 0

function setup() {
	createCanvas(800, 800)
	background(0)
	
	noStroke()
	
	colorMode(HSL, 360, 255, 255)
	
	for (let i = 0; i < width * height; i += 1) {
		pa[i] = []
	}
}

function draw() {
	for (let c = 0; c < 10; c += 1) {
		let x = random(0, width)
		let y = random(0, height)
		let rmax = height / 1
		let r = random(8, rmax)
		
		let rc = r / rmax
		fill(0 + rc * 100, 192, 255 - rc * 255)

		let cpm = false
		let cpp = false
		
		let pc = 4000 // precision (less = may show quantization gaps, high = overdraw + aliasing but less gaps)
		for (let i = 0; i < pc; i += 1) {
			let ni = i / pc
			
			let cxm = round(x - r * sin(ni * PI * 2))
			let cym = round(y - r * cos(ni * PI * 2))
			
			if (cxm >= 0 && cxm < width && cym > 0 && cym < height && !cpm) {
				let pal = pa[cxm + cym * width]
				let f = false
				for (let k = 0; k < pal.length; k += 1) {
					if (pal[k] != ci) {
						f = true
						break
					}
				}

				if (!f) {
					rect(cxm, cym, 1, 1)

					pal.push(ci)
				} else {
					cpm = true
				}
			}
			
			let cxp = round(x - r * sin(-ni * PI * 2))
			let cyp = round(y - r * cos(-ni * PI * 2))
			
			if (cxp >= 0 && cxp < width && cyp > 0 && cyp < height && !cpp) {
				pal = pa[cxp + cyp * width]
				f = false
				for (let k = 0; k < pal.length; k += 1) {
					if (pal[k] != ci) {
						f = true
						break
					}
				}

				if (!f) {
					rect(cxp, cyp, 1, 1)

					pal.push(ci)
				} else {
					cpp = true
				}
			}
			
			if (cpm && cpp) {
				break
			}
		}
		
		ci += 1
	}
}"
"1212863","Circles 2","mySketch","// simple idea based on drawing random circles iteratively and stop drawing when it bump upon others
// due to the way circles are drawn the detection isn't really accurate so it stop sometimes (better that way ?)

function setup() {
	createCanvas(800, 800)
	background(0)
	
	noStroke()
	
	colorMode(HSL, 360, 255, 255)
}

function draw() {
	
	for (let c = 0; c < 10; c += 1) {
		let x = 0
		let y = 0
		
		let rnd = random()
		if (rnd >= 0.25) {
			x = random(-width, 0);
			y = random(-height, 0);
		} /*else if (rnd >= 0.5) {
			x = random(0,  width);
			y = random(-height, 0);
		} else if (rnd >= 0.75) {
			x = random(width,  width * 2);
			y = random(height, height * 2);
		}*/ else {
			x = random(0,  width);
			y = random(height, height * 2);
		}
		
		let rmax = height * 2
		let r = random(8, rmax)
		
		let rc = r / rmax
		fill(0+rc*40, 192*rc,rc* 255)

		loadPixels()
		
		let cpm = 0
		let cpp = 0
		
		let cxmp = 0, cymp = 0
		let cxpp = 0, cypp = 0
		
		let pc = 10000 // precision (less = may show quantization gaps)
		for (let i = 0; i < pc; i += 1) {
			let ni = i / pc
			
			if (cpm < 1) {
				let cxm = round(x + r * sin(ni * PI * 2))
				let cym = round(y + r * cos(ni * PI * 2))
				
				if (cxm != cxmp || cym != cymp) {
					let pm = get(cxm, cym)

					if (pm[0] > 0) {
						cpm += 1
					} else {
						rect(cxm, cym, 1, 1)
					}
				}
				
				cxmp = cxm
				cymp = cym
			}
			
			if (cpp < 1) {
				let cxp = round(x - r * sin(ni * PI * 2))
				let cyp = round(y - r * cos(ni * PI * 2))

				if (cxp != cxpp || cyp != cypp) {
					let pp = get(cxp, cyp)
					if (pp[0] > 0) {
						cpp += 1
					} else {
						rect(cxp, cyp, 1, 1)
					}
				}
				
				cxpp = cxp
				cypp = cyp
			}
			
			if (cpm >= 1 && cpp >= 1) {
				continue
			}
		}
	}
}"
"1212733","Circles invert","mySketch","// simple idea based on drawing random circles iteratively and stop drawing when it bump upon others
// due to the way circles are drawn the detection isn't really accurate so it stop sometimes (better that way ?)

function setup() {
	createCanvas(800, 800)
	background(0)
	
	noStroke()
	
	colorMode(HSL, 360, 255, 255)
}

function draw() {
	
	for (let c = 0; c < 10; c += 1) {
		let x = random(width / 2 - 300, width / 2 + 300)
		let y = random(width / 2 - 300, width / 2 + 300)
		let rmax = height / 8
		let r = random(8, rmax)
		
		let rc = r / rmax
		fill(0+rc*80, 192, 255-rc* 255)

		loadPixels()
		
		let cpm = 0
		let cpp = 0
		
		let cxmp = 0, cymp = 0
		let cxpp = 0, cypp = 0
		
		let pc = 2000 // precision (less = may show quantization gaps)
		for (let i = 0; i < pc; i += 1) {
			let ni = i / pc
			
			if (cpm < 1) {
				let cxm = round(x + r * sin(ni * PI * 2))
				let cym = round(y + r * cos(ni * PI * 2))
				
				if (cxm != cxmp || cym != cymp) {
					let pm = get(cxm, cym)

					if (pm[0] > 0) {
						cpm += 1
					} else {
						rect(cxm, cym, 1, 1)
					}
				}
				
				cxmp = cxm
				cymp = cym
			}
			
			if (cpp < 1) {
				let cxp = round(x - r * sin(ni * PI * 2))
				let cyp = round(y - r * cos(ni * PI * 2))

				if (cxp != cxpp || cyp != cypp) {
					let pp = get(cxp, cyp)
					if (pp[0] > 0) {
						cpp += 1
					} else {
						rect(cxp, cyp, 1, 1)
					}
				}
				
				cxpp = cxp
				cypp = cyp
			}
			
			if (cpm >= 1 && cpp >= 1) {
				continue
			}
		}
	}
}"
"1212729","Circles","mySketch","// simple idea based on drawing random circles iteratively and stop drawing when it bump upon others
// due to the way circles are drawn the detection isn't really accurate so it stop sometimes (better that way ?)

function setup() {
	createCanvas(800, 800)
	background(0)
	
	noStroke()
	
	colorMode(HSL, 360, 255, 255)
}

function draw() {
	
	for (let c = 0; c < 10; c += 1) {
		let x = random(width / 2 - 300, width / 2 + 300)
		let y = random(width / 2 - 300, width / 2 + 300)
		let rmax = height / 8
		let r = random(8, rmax)
		
		let rc = r / rmax
		fill(0+rc*80, 192, rc* 255)

		loadPixels()
		
		let cpm = 0
		let cpp = 0
		
		let cxmp = 0, cymp = 0
		let cxpp = 0, cypp = 0
		
		let pc = 2000 // precision (less = may show quantization gaps)
		for (let i = 0; i < pc; i += 1) {
			let ni = i / pc
			
			if (cpm < 1) {
				let cxm = round(x + r * sin(ni * PI * 2))
				let cym = round(y + r * cos(ni * PI * 2))
				
				if (cxm != cxmp || cym != cymp) {
					let pm = get(cxm, cym)

					if (pm[0] > 0) {
						cpm += 1
					} else {
						rect(cxm, cym, 1, 1)
					}
				}
				
				cxmp = cxm
				cymp = cym
			}
			
			if (cpp < 1) {
				let cxp = round(x - r * sin(ni * PI * 2))
				let cyp = round(y - r * cos(ni * PI * 2))

				if (cxp != cxpp || cyp != cypp) {
					let pp = get(cxp, cyp)
					if (pp[0] > 0) {
						cpp += 1
					} else {
						rect(cxp, cyp, 1, 1)
					}
				}
				
				cxpp = cxp
				cypp = cyp
			}
			
			if (cpm >= 1 && cpp >= 1) {
				continue
			}
		}
	}
}"
"1195793","QuasiSpace (128b prototype)","mySketch","// QuasiSpace prototype - a 128 bytes Linux framebuffer intro presented at Outline Online demoparty 2021
// It is all integers and is sorta a CORDIC algorithm
// explanation : https://nbickford.wordpress.com/2011/04/03/the-minsky-circle-algorithm/
// This was ported to C code and 32 bits ASM code (for setup and ELF headers) to generate a very small standalone Linux executable.
// The final binary size is 128 bytes with approximately 52 bytes of graphics code, one can say it is 64 bytes without headers and framebuffer setup which is platform dependent.
// Video on Linux : https://youtu.be/VP84juto-pY

// tried to give it more depth by slow drifting but it also look blurrier

// look different because of different variables initialization and framebuffer type
// differences are annotated in comments

let x = 0, y = 0, i = 0;
// change this (with big values) for different patterns
// the final code does not initialize any variables so the values are lileky random on different machines
let f = 0;
function setup() {
	createCanvas(1920, 1080);
	
	background(0);
}

function draw() {
	loadPixels();

	// there is no loop in the final code but make it faster here
	for(let iter = 0; iter < 200000; iter += 1) {
		// core algorithm
		x = x - y + (f + (i << 4)); // 5 was 7
		y = y + x + (f - (x >> 1));
		
		// final code is a linear framebuffer with 32 bits values, not 8 bits
		i = (((width >> 1) + (x >> 22)) + ((height >> 1) + (y >> 22)) * width) * 4;

		pixels[i + 0] += 2;
		pixels[i + 1] += 2;
		pixels[i + 2] += 2;

    f += 1;
	}

	updatePixels();
}

"
"1186567","CORDIC many 3","mySketch","let x = 0, y = 0;

function setup() {
	createCanvas(940, 940);
	
	background(0);

	noStroke();
}

let frame = 100000;

function draw() {
	loadPixels();

	for(let iter = 0; iter < 12200; iter += 1) {
			x = (x+(y>>1)) - ((y>>0)) + ((frame));
			y = (y+(x>>1)) + (x>>2-(y>>22)) + ((frame>>4)&((x>>4)));
			x = (x+(x>>20)) - ((y>>1)) + ((frame>>8));
		
			let index = (floor(width / 2 + (x>>14)) + floor(height / 2 + (y>>14)) * width) * 4;
			let index2 =(floor(width / 2 + ~(x>>14)) + floor(height / 2 - (y>>14)) * width) * 4;
			pixels[index + 1] += 1&iter;
			pixels[index + 2] += 1;
			pixels[index + 0] += 1;
			pixels[index2 + 1] += 1;
			pixels[index2 + 2] += 1&iter;
			pixels[index2 + 0] += 1;

			index =(floor(width / 1.25 + (x>>14)) + floor(height / 2 + (y>>14)) * width) * 4;
			index2 =(floor(width / 1.25 + ~(x>>14)) + floor(height / 2 - (y>>14)) * width) * 4;
			pixels[index + 1] += 1;
			pixels[index + 2] += 1;
			pixels[index + 0] += 1&iter;
			pixels[index2 + 1] += 1&iter;
			pixels[index2 + 2] += 1&iter;
			pixels[index2 + 0] += 1;
		
			index =(floor(width / 5 + (x>>14)) + floor(height / 2 + (y>>14)) * width) * 4;
			index2 =(floor(width / 5 + ~(x>>14)) + floor(height / 2 - (y>>14)) * width) * 4;
			pixels[index + 1] += 1&iter;
			pixels[index + 2] += 1;
			pixels[index + 0] += 1&iter;
			pixels[index2 + 1] += 1;
			pixels[index2 + 2] += 1&iter;
			pixels[index2 + 0] += 1&iter;

			index =(floor(height / 2 + (y>>14)) + floor(width / 5 + (x>>14)) * width) * 4;
			index2 =(floor(height / 2 - (y>>14)) + floor(width / 5 + ~(x>>14)) * width) * 4;
			pixels[index + 1] += 1&iter;
			pixels[index + 2] += 1;
			pixels[index + 0] += 1;
			pixels[index2 + 1] += 1;
			pixels[index2 + 2] += 1&iter;
			pixels[index2 + 0] += 1;
		
			index =(floor(height / 2 + (y>>14)) + floor(width / 2 + (x>>14)) * width) * 4;
			index2 =(floor(height / 2 - (y>>14)) + floor(width / 2 + ~(x>>14)) * width) * 4;
			pixels[index + 1] += 1&iter;
			pixels[index + 2] += 1;
			pixels[index + 0] += 1;
			pixels[index2 + 1] += 1;
			pixels[index2 + 2] += 1&iter;
			pixels[index2 + 0] += 1;
		
			index =(floor(height / 2 + (y>>14)) + floor(width / 1.25 + (x>>14)) * width) * 4;
			index2 =(floor(height / 2 - (y>>14)) + floor(width / 1.25 + ~(x>>14)) * width) * 4;
			pixels[index + 1] += 1&iter;
			pixels[index + 2] += 1;
			pixels[index + 0] += 1;
			pixels[index2 + 1] += 1;
			pixels[index2 + 2] += 1&iter;
			pixels[index2 + 0] += 1;
		
    	oldX = x;
    	oldY = y;
		
    frame += 1;
	}

	updatePixels();
}
"
"1186564","CORDIC many 2","mySketch","let x = 0, y = 0;

function setup() {
	createCanvas(940, 940);
	
	background(0);

	noStroke();
}

let frame = 0;

function draw() {
	loadPixels();

	for(let iter = 0; iter < 12200; iter += 1) {
			x = (x+(y>>14)) - ((y>>0)) + ((frame));
			y = (y+(x>>1)) + (x>>2-(y>>22)) + ((frame>>4)&((x>>20)));
			x = (x+(x>>14)) - ((y>>1)) + ((frame>>8));
		
			let index = (floor(width / 2 + (x>>14)) + floor(height / 2 + (y>>14)) * width) * 4;
			let index2 =(floor(width / 2 + ~(x>>14)) + floor(height / 2 - (y>>14)) * width) * 4;
			pixels[index + 1] += 1&iter;
			pixels[index + 2] += 1;
			pixels[index + 0] += 1;
			pixels[index2 + 1] += 1;
			pixels[index2 + 2] += 1&iter;
			pixels[index2 + 0] += 1;

			index =(floor(width / 1.25 + (x>>14)) + floor(height / 2 + (y>>14)) * width) * 4;
			index2 =(floor(width / 1.25 + ~(x>>14)) + floor(height / 2 - (y>>14)) * width) * 4;
			pixels[index + 1] += 1;
			pixels[index + 2] += 1;
			pixels[index + 0] += 1&iter;
			pixels[index2 + 1] += 1&iter;
			pixels[index2 + 2] += 1&iter;
			pixels[index2 + 0] += 1;
		
			index =(floor(width / 5 + (x>>14)) + floor(height / 2 + (y>>14)) * width) * 4;
			index2 =(floor(width / 5 + ~(x>>14)) + floor(height / 2 - (y>>14)) * width) * 4;
			pixels[index + 1] += 1&iter;
			pixels[index + 2] += 1;
			pixels[index + 0] += 1&iter;
			pixels[index2 + 1] += 1;
			pixels[index2 + 2] += 1&iter;
			pixels[index2 + 0] += 1&iter;

			index =(floor(height / 2 + (y>>14)) + floor(width / 5 + (x>>14)) * width) * 4;
			index2 =(floor(height / 2 - (y>>14)) + floor(width / 5 + ~(x>>14)) * width) * 4;
			pixels[index + 1] += 1&iter;
			pixels[index + 2] += 1;
			pixels[index + 0] += 1;
			pixels[index2 + 1] += 1;
			pixels[index2 + 2] += 1&iter;
			pixels[index2 + 0] += 1;
		
			index =(floor(height / 2 + (y>>14)) + floor(width / 2 + (x>>14)) * width) * 4;
			index2 =(floor(height / 2 - (y>>14)) + floor(width / 2 + ~(x>>14)) * width) * 4;
			pixels[index + 1] += 1&iter;
			pixels[index + 2] += 1;
			pixels[index + 0] += 1;
			pixels[index2 + 1] += 1;
			pixels[index2 + 2] += 1&iter;
			pixels[index2 + 0] += 1;
		
			index =(floor(height / 2 + (y>>14)) + floor(width / 1.25 + (x>>14)) * width) * 4;
			index2 =(floor(height / 2 - (y>>14)) + floor(width / 1.25 + ~(x>>14)) * width) * 4;
			pixels[index + 1] += 1&iter;
			pixels[index + 2] += 1;
			pixels[index + 0] += 1;
			pixels[index2 + 1] += 1;
			pixels[index2 + 2] += 1&iter;
			pixels[index2 + 0] += 1;
		
    	oldX = x;
    	oldY = y;
		
    frame += 1;
	}

	updatePixels();
}
"
"1186445","CORDIC many","mySketch","let x = 0, y = 0;

function setup() {
	createCanvas(940, 940);
	
	background(0);

	noStroke();
}

let frame = 0;

function draw() {
	loadPixels();

	for(let iter = 0; iter < 12200; iter += 1) {
			x = (x+(y>>14)) - ((y>>0)) + ((frame));
			y = (y+(x>>14)) + (x>>1-(y>>22)) + ((frame>>2)&((x>>20)));
			x = (x+(x>>14)) - ((y>>1)) + ((frame>>8));
		
			let index = (floor(width / 2 + (x>>14)) + floor(height / 2 + (y>>14)) * width) * 4;
			let index2 =(floor(width / 2 + ~(x>>14)) + floor(height / 2 - (y>>14)) * width) * 4;
			pixels[index + 1] += 1&iter;
			pixels[index + 2] += 1;
			pixels[index + 0] += 1;
			pixels[index2 + 1] += 1;
			pixels[index2 + 2] += 1&iter;
			pixels[index2 + 0] += 1;

			index =(floor(width / 1.25 + (x>>14)) + floor(height / 2 + (y>>14)) * width) * 4;
			index2 =(floor(width / 1.25 + ~(x>>14)) + floor(height / 2 - (y>>14)) * width) * 4;
			pixels[index + 1] += 1;
			pixels[index + 2] += 1;
			pixels[index + 0] += 1&iter;
			pixels[index2 + 1] += 1&iter;
			pixels[index2 + 2] += 1&iter;
			pixels[index2 + 0] += 1;
		
			index =(floor(width / 5 + (x>>14)) + floor(height / 2 + (y>>14)) * width) * 4;
			index2 =(floor(width / 5 + ~(x>>14)) + floor(height / 2 - (y>>14)) * width) * 4;
			pixels[index + 1] += 1&iter;
			pixels[index + 2] += 1;
			pixels[index + 0] += 1&iter;
			pixels[index2 + 1] += 1;
			pixels[index2 + 2] += 1&iter;
			pixels[index2 + 0] += 1&iter;

			index =(floor(height / 2 + (y>>14)) + floor(width / 5 + (x>>14)) * width) * 4;
			index2 =(floor(height / 2 - (y>>14)) + floor(width / 5 + ~(x>>14)) * width) * 4;
			pixels[index + 1] += 1&iter;
			pixels[index + 2] += 1;
			pixels[index + 0] += 1;
			pixels[index2 + 1] += 1;
			pixels[index2 + 2] += 1&iter;
			pixels[index2 + 0] += 1;
		
			index =(floor(height / 2 + (y>>14)) + floor(width / 2 + (x>>14)) * width) * 4;
			index2 =(floor(height / 2 - (y>>14)) + floor(width / 2 + ~(x>>14)) * width) * 4;
			pixels[index + 1] += 1&iter;
			pixels[index + 2] += 1;
			pixels[index + 0] += 1;
			pixels[index2 + 1] += 1;
			pixels[index2 + 2] += 1&iter;
			pixels[index2 + 0] += 1;
		
			index =(floor(height / 2 + (y>>14)) + floor(width / 1.25 + (x>>14)) * width) * 4;
			index2 =(floor(height / 2 - (y>>14)) + floor(width / 1.25 + ~(x>>14)) * width) * 4;
			pixels[index + 1] += 1&iter;
			pixels[index + 2] += 1;
			pixels[index + 0] += 1;
			pixels[index2 + 1] += 1;
			pixels[index2 + 2] += 1&iter;
			pixels[index2 + 0] += 1;
		
    	oldX = x;
    	oldY = y;
		
    frame += 1;
	}

	updatePixels();
}
"
"1183027","Space 14","mySketch","// base code of the skyscraper may fit into 256b (even less)
let xoff, yoff;

function setup() {
	createCanvas(800, 600);
	
	background(0);

	colorMode(HSL, 360, 255, 255, 1);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
	/*
	for (let y = 0; y < height; y += 1) {
		let ny = pow(y / height, 4);
		fill(ny * 70, random(64, 128), ny * 255, 1);
		rect(0, y, width, 1);
	}
	*/
	for (let y = 0; y < height; y += 1) {
		fill(random(0, 120), random(0, 128), random(0, 255), 1);
		rect(random(0, width), y + random(0, height / 3), random(1, 2), random(1, 2));
	}
	/*
	for (let i = 8048; i > 0; i -= 1) {
		let ni = i / 8048;
		fill(14 + (1-pow(ni, 4)) * 20 + random(5), 255, 128, 1 - pow(ni, 0.25));
		ellipse(width / 2, height / 3.25, (width / 2) * ni, (width / 2) * ni);
	}
	*/
//	fill(0);
	//ellipse(width / 2, height / 1.0, 32, 32);
	//arc(0, 64, 64, 64, -PI/2, PI/2);
}

function draw() {
	let sx = frameCount/width;
	let sy = frameCount/height;
	
	let h2 = height*2;

	for (let y = -h2; y < h2; y += 1) {
		const yy = y;
		//const yyy = y - sin(frameCount / 100) * h2;

		const t = yy & (frameCount*1);
		const brightness = t % 255;
		
		let x = noise(abs((frameCount) | ((y*1)+t)) /1000) * width / 16 + t / 8;//abs((frameCount) | ((y/8)+t));
		//fill((brightness ^ frameCount) % 192, (brightness & frameCount) % 192, (brightness | frameCount) % 192);
		
		let xxx = (width / 3 + x + width / 2 * sx);
		if (xxx < width / 2) {
			fill(200 + t % (0 + frameCount % 100) - random(0, 8), 64&t, brightness % 255, 1);
			rect(xxx, height / 2 + y * (sy/0.75), 1, 1);
			rect(width - xxx, height / 2 + y * (sy/0.75), 1, 1);
		}
		fill(0 + t % (0 + frameCount % 10) - random(0, 8), 64&t, brightness % 255, 1);
		rect(width / 2 + y * sy/2, (height / 2.5 + x + height / 2 * sx), 1, 1);
		rect(width - (width / 2 + y * sy/2), (height / 2.5 + x + height / 2 * sx), 1, 1);
		//ect(width / 2 + y * sy, height - (height / 1 + x + height / 2 * sx), 1, 1);
		//rect(width - (width / 2 + y * sy), height - (height / 2.5 + x + height / 2 * sx), 1, 1);
	}

}
"
"1175591","Static raymarching (software)","mySketch","// static raymarcher (sphere tracing method aka variable step; software rendering)
// done for fun and to learn; bare metal without higher level stuff that GPU code provide, also id like to implement it with fixed point later on :)
// based on 'gyroid' (simplified) : https://www.shadertoy.com/view/fdl3R7

let renderTime = 0;

function setup() {
	const dim = floor(min(windowWidth, windowHeight) / 1.2); // get away with aspect ratio issues by going square
	createCanvas(dim, dim);
	
	background(0);

	noiseSeed(0);
	noiseDetail(6, 0.7);

	noStroke();
	
	// start
	let renderStart = millis();
	
	loadPixels();
	
	// go high for smoother surfaces / reduce bands issues
	const iterations = 32;
	
	const wd2 = width / 2;
	const hd2 = height / 2;

	for (let y = -hd2; y < hd2; y += 1) {
		const ny = y / hd2; // normalize to -1,1

		for (let x = -wd2; x < wd2; x += 1) {
			const nx = x / wd2; // normalize to -1,1

			// position vector
			let rtx = -0.4; // look into hole
			let rty = 0; let rtz = 0;
			
			// raymarching
			for (let z = iterations; z > 0; z -= 1) {
				// gyroid implicit surface : https://en.wikipedia.org/wiki/Gyroid
				// you can also try any implicit surface formula here (but you might have to tweak position, scale etc)
				let distance = sin(rtx) * cos(rty) + sin(rty) * cos(rtz) + sin(rtz) * cos(rtx);
				// inverse it so we trace the gyroid 'tubes'
				distance = (1.0 - distance);
				
				// direction; variable step based on current estimation
				rtx += distance * nx;
				rty += distance * ny;
				rtz += distance * 0.359;

				if (distance < 0.041) { // we hit ?
					// go back to screen coords
					const px = floor(x + wd2);
					const py = floor(y + hd2);
					
					// shading
					const nz = z / iterations;
					const shade = floor(255 * nz);
					
					// plotting
					const index = (px + py * width) * 4 * pixelDensity();
					pixels[index + 0] = shade;
					pixels[index + 1] = shade;
					pixels[index + 2] = shade;

					break;
				}
			}
		}
	}
	
	updatePixels();
	// end
	
	// render time stuff
	renderTime = millis() - renderStart;
	
	let renderTimeStr = nf(renderTime / 1000, '', 2) + 's';
	let fontSize = 24;
	
	fill(0);
	
	let rw = renderTimeStr.length * fontSize;
	let rh = fontSize;
	rectMode(CORNER);
	rect(dim - rw / 2 - 2, dim - rh - 4, rw + 2, rh + 4);
	
	noStroke();
	fill(255);
	
	textSize(fontSize);
	
	textAlign(RIGHT, BOTTOM);
	text(renderTimeStr, dim, dim);
}

function draw() {
	
}
"
"1162451","CORDIC 12","mySketch","function pal(t, a, b, c, d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

let x = 0, y = 0, frame = 66000000, index = 0, index2 = 0;
function setup() {
	createCanvas(900, 900);
	
	background(0);
}

function draw() {
	loadPixels();
	
	let params = [24,20,26,21,15,10,28,14];
	
		var pa1 = 1, pa2 = 1, pa3 = 1;
		var pb1 = 1, pb2 = 0.75, pb3 = 1.0;
		var pc1 = 1, pc2 = 0.75, pc3 = 0.75;

		var pdr = 0.25;
		var pdg = 0.1;
		var pdb = 0.2;

		var pt = abs(sin(frame / 1000000 * PI * 2));

	for(let iter = 0; iter < 222000; iter += 1) {
		x = (x - (x >> params[0])) - y + ((frame >> params[1]));
		y = (y - (x >> params[2])) + ((x/* >> 1*/) - (y >> params[3])) - ((frame >> params[4]) & ((x << params[5])));
		x = (x - (x >> params[6])) - y + ((frame >> params[1]));

    index = (((width >> 1) + (x >> params[7])) + ((height >> 1) + (y >> (params[7]))) * width) * 4;
    index2 = (((width >> 1) - (x >> params[7])) + (((height >> 1) + (y >> params[7]))) * width) * 4;
		/*
		if (index > (width * height * 4)) { index = 0; }
		if (index2 > (width * height * 4)) { index2 = 0; }
	*/

		var rf = 1;//round(pal(pt, pa1, pb1, pc1, pdr));
		var gf = 1;//round(pal(pt, pa2, pb2, pc2, pdg));
		var bf = 2&iter;//round(pal(pt, pa3, pb3, pc3, pdb));
		
		pixels[index + 1] += rf;
		pixels[index + 2] += gf;
		pixels[index + 0] += bf;
		pixels[index2 + 1] += rf;
		pixels[index2 + 2] += gf;
		pixels[index2 + 0] += bf;

    frame += 1;
	}

	updatePixels();
}

"
"1162448","CORDIC 11","mySketch","let x = 0, y = 0, frame = 0, index = 0, index2 = 0;
function setup() {
	createCanvas(900, 900);
	
	background(0);
}

function draw() {
	loadPixels();
	
	let params = [25,18,14,14,5,19,21,12];

	for(let iter = 0; iter < 222000; iter += 1) {
		x = (x - (x >> params[0])) - y + ((frame >> params[1]));
		y = (y - (x >> params[2])) + ((x/* >> 1*/) - (y >> params[3])) - ((frame >> params[4]) & ((x << params[5])));
		x = (x - (x >> params[6])) - y + ((frame >> params[1]));

    index = (((width >> 1) + (x >> params[7])) + ((height >> 1) + (y >> (params[7]))) * width) * 4;
    index2 = (((width >> 1) - (x >> params[7])) + (((height >> 1) + (y >> params[7]))) * width) * 4;
		/*
		if (index > (width * height * 4)) { index = 0; }
		if (index2 > (width * height * 4)) { index2 = 0; }
	*/
		pixels[index + 1] += 2;
		pixels[index + 2] += 2;
		pixels[index + 0] += 1&iter;
		pixels[index2 + 1] += 1&iter;
		pixels[index2 + 2] += 2;
		pixels[index2 + 0] += 2;

    frame += 1;
	}

	updatePixels();
}

"
"1162447","CORDIC 10","mySketch","let x = 0, y = 0, frame = 0, index = 0, index2 = 0;
function setup() {
	createCanvas(900, 900);
	
	background(0);
}

function draw() {
	loadPixels();
	
	let params = [15,15,12,12,8,15,15,8];

	for(let iter = 0; iter < 222000; iter += 1) {
		x = (x - (x >> params[0])) - y + ((frame >> params[1]));
		y = (y - (x >> params[2])) + ((x << 0) - (y >> params[3])) - ((frame >> params[4]) & ((x << params[5])));
		x = (x - (x >> params[6])) - y + ((frame >> params[1]));

    index = (((width >> 1) + (x >> params[7])) + ((height >> 1) + (y >> (params[7]))) * width) * 4;
    index2 = (((width >> 1) - (x >> params[7])) + (((height >> 1) + (y >> params[7]))) * width) * 4;
		/*
		if (index > (width * height * 4)) { index = 0; }
		if (index2 > (width * height * 4)) { index2 = 0; }
	*/
		pixels[index + 1] += 2;
		pixels[index + 2] += 2;
		pixels[index + 0] += 1&iter;
		pixels[index2 + 1] += 1&iter;
		pixels[index2 + 2] += 2;
		pixels[index2 + 0] += 2;

    frame += 1;
	}

	updatePixels();
}

"
"1156274","Flagship (256b prototype)","mySketch","// Flagship prototype - a 256 bytes Linux framebuffer intro presented at Revision 2021 demoparty
// It is all integers and is sorta a CORDIC algorithm
// This was ported to C code which use SIMD saturated arithmetic (to be released soon)
// The Linux binary has a platform overhead (48 bytes of headers + ~58 bytes of framebuffer setup code) so its not very far to be 128 bytes.
// Video on Linux : https://www.youtube.com/watch?v=ru-X4updvrU
// https://www.pouet.net/prod.php?which=88636
// There is some differences with the C code but not very far from this

let x = 0, y = 0, frame = 0, index = 0;
function setup() {
	// 1920x1080 is Flagship as it was presented
	// i find this one (original one) more interesting visually but because Linux framebuffer has fixed display size it would have required bit more code (and wouldn't be fullscreen)
	createCanvas(1920/1.25, 1080/1.25);
	
	background(0);
}

function draw() {
	loadPixels();

	for(let iter = 0; iter < 122000; iter += 1) {
		x = (x - (x >> 12)) - y + (frame >> 7);
		y = (y - (x >> 8)) + (x >> 1 - (y >> 23)) + ((frame >> 7) & (x >> 2));

		index = (floor(width / 2 + (x >> 13)) + floor((y >> 13)) * width) * 4;
		let index2 = (floor(width / 2 + ~(x >> 13)) + floor((y >> 13)) * width) * 4;
		
		// don't need this in JS but C code does
		if (index > (width * height * 4)) { index = width / 2 * 4; index2 = width / 2 * 4; }

		// C code didn't use logical operators here (nor the 'iter' loop)
		pixels[index + 1] += 1&iter;
		pixels[index + 2] += 1&iter;
		pixels[index + 0] += 1;
		pixels[index2 + 1] += 1&iter;
		pixels[index2 + 2] += 1&iter;
		pixels[index2 + 0] += 1;

    frame += 16;
	}

	updatePixels();
}


"
"1155709","ifs polar log7","mySketch","// ifs
// https://flam3.com/flame_draves.pdf

var xmotion = 0;
var ymotion = 0;

let rx = 0;
let ry = 0;
let ax = 0;
let ay = 0;

let histo = [];

function setup() {
  createCanvas(900, 900);
  background(0);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 100, 100, 1);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	rx = width /2;
	ry = height/2;
	ax = random(0, 1);
	ay = random(0, 1);
	
	for (let i = 0; i < width * height; i += 1) {
		histo[i] = 0;
	}
	
	generate();
}

function r1(x, y) {
	return { x: x, y: y };
}

function r2(x, y) {
	return { x: (width / 1 + x / 16) , y: y };
}

function r3(x, y) {
	return { x: (width / 1 + x / 4) - y / 2, y: y };
}

function a1(x, y) {
	return { x: (1 - x / (PI * 1)), y: y / 3 - x / (PI * 32.) };
}

function a2(x, y) {
	return { x: x / 1.5, y: (1 + y * 0.5) / 1.25 };
}

function a3(x, y) {
	return { x: x / (3.14 / 2) - y / (3.14 / 2), y: y * 0.5 + x * PI / 8};
}

var r1 = [r1, r2, r3];
var a1 = [a1, a2, a3];

var iter = 0;

function draw() {
	//fill(0, 0, 0, 1);
	//rect(0, 0, width, height);
	
	let renderAtFrame = 60 * 8;
	
	if (frameCount <= renderAtFrame) {
		for (let i = 0; i < 5000; i += 1) {
			let index1 = floor(random(0, 3));
			let r = r1[index1](rx, ry);

			rx = r.x; ry = r.y;

			let index2 = floor(random(0, 3));
			let a = a1[index1](ax, ay);

			ax = a.x; ay = a.y;

			stroke(0, 0, 255, 0.05);

			if (iter > 20) {
				let x = width / 2 + rx * (sin(ax/2)); //* sqrt((ax+ax) * (ay+ay)*0.05)*2);//(sin(ax * PI * 2) * cos(ay * PI * 2));
				let y = height / 2 + ry * (cos(ay/0.5)); //* sqrt((ax+ax) * (ay+ay)*0.05)*2);
				// / 0.125 is kinda fun also
				
				let px = width / 2 - x;
				let py = height / 2 - y;

				if (x < width && x > 0 && y < height && y > 0) {
					push();
					translate(width / 2, height / 2);
					//rotate(round(iter / 100) * PI / 4.);
					point(px, -py);
					point(-px, -py);
					//translate(0, 0);
					//rotate(round(iter / 100) * PI / 20);
					//point(px, py);
					//point(x - width / 2.125, y - height / 1.25);
					let index = floor(x) + floor(y) * width;
					if (index >= 0 && index < (width * height)) {
						histo[index] += 1;
					}
					pop();
				}
			}

			iter += 1;
		}

		let cx = random(width / 4, width - width / 4);
		let cy = random(height / 4, height - height / 4);
/*
		if (frameCount % (renderAtFrame) == 0) {
		//	background(0);

			generate();

			let m = 0;
			for (let j = 0; j < width * height; j += 1) {
				let value = Math.log10(histo[j]);
				m = max(m, value);
			}

			if (m > 0) {
				for (let y = 0; y < height; y += 1) {
					for (let x = 0; x < width; x += 1) {
						let index = x + y * width;
						let value = Math.log10(histo[index]);
						let gamma = 2.2;

						if (value > 0) {
							let brightness = pow(value / (1+m), 1 / gamma);
							stroke(180 + value / m * 80, 25 + value / m * 50, brightness * 100, 1);
							let shapes = 8;
							for (let j = 0; j < shapes; j += 1) {
								let nj = j / shapes;

								push();
								//scale(nj);
								translate(width / 2, height / 2);
								//rotate(j * PI / (shapes / 2));
								point(width / 2 - x, height / 2 - y);
								//translate(width / 2, 0);
								//point(width / 2 - x, height / 2 - y);
								//point(x - width / 2.125, y - height / 1.25);
								pop();
							}
						}
					}
				}
			}
		}*/
	}
	
	xmotion += 0.01;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.00125);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.01);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"1155701","ifs polar log6","mySketch","// ifs
// https://flam3.com/flame_draves.pdf

var xmotion = 0;
var ymotion = 0;

let rx = 0;
let ry = 0;
let ax = 0;
let ay = 0;

let histo = [];

function setup() {
  createCanvas(1000, 1000);
  background(0);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 100, 100, 1);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	rx = width /1;
	ry = height/3;
	ax = random(0, 1);
	ay = random(0, 1);
	
	for (let i = 0; i < width * height; i += 1) {
		histo[i] = 0;
	}
	
	generate();
}

function r1(x, y) {
	return { x: x, y: y };
}

function r2(x, y) {
	return { x: (width / 1 + x / 4) , y: y };
}

function r3(x, y) {
	return { x: (width / 1 + x / 1.5) - y / 1, y: y };
}

function a1(x, y) {
	return { x: (1 - x / (PI * 1.25)), y: y / 8 - x / (PI * 1.) };
}

function a2(x, y) {
	return { x: x - 0.75, y: (1 + y * 0.7) / 1.25 };
}

function a3(x, y) {
	return { x: x / (3.14 / 2) - y / (3.14 / 2), y: y * 0.25 + x * PI / 8};
}

var r1 = [r1, r2, r3];
var a1 = [a1, a2, a3];

var iter = 0;

function draw() {
	//fill(0, 0, 0, 1);
	//rect(0, 0, width, height);
	
	let renderAtFrame = 60 * 8;
	
	if (frameCount <= renderAtFrame) {
		for (let i = 0; i < 5000; i += 1) {
			let index1 = floor(random(0, 3));
			let r = r1[index1](rx, ry);

			rx = r.x; ry = r.y;

			let index2 = floor(random(0, 3));
			let a = a1[index1](ax, ay);

			ax = a.x; ay = a.y;

			stroke(0, 0, 255, 0.025);

			if (iter > 20) {
				let x = width / 2 + rx * (sin(ax/3)); //* sqrt((ax+ax) * (ay+ay)*0.05)*2);//(sin(ax * PI * 2) * cos(ay * PI * 2));
				let y = height / 2 + ry * (cos(ay/0.125)); //* sqrt((ax+ax) * (ay+ay)*0.05)*2);
				// / 0.125 is kinda fun also
				
				let px = width / 2 - x;
				let py = height / 2 - y;

				if (x < width && x > 0 && y < height && y > 0) {
					push();
					translate(width / 2, height / 2);
					//rotate(round(iter / 100) * PI / 1.);
					point(width / 6 +px, -py);
					point(-(width / 6 +px), -py);
					//translate(0, 0);
					//rotate(round(iter / 100) * PI / 20);
					//point(px, py);
					//point(x - width / 2.125, y - height / 1.25);
					let index = floor(x) + floor(y) * width;
					if (index >= 0 && index < (width * height)) {
						histo[index] += 1;
					}
					pop();
				}
			}

			iter += 1;
		}

		let cx = random(width / 4, width - width / 4);
		let cy = random(height / 4, height - height / 4);
/*
		if (frameCount % (renderAtFrame) == 0) {
		//	background(0);

			generate();

			let m = 0;
			for (let j = 0; j < width * height; j += 1) {
				let value = Math.log10(histo[j]);
				m = max(m, value);
			}

			if (m > 0) {
				for (let y = 0; y < height; y += 1) {
					for (let x = 0; x < width; x += 1) {
						let index = x + y * width;
						let value = Math.log10(histo[index]);
						let gamma = 2.2;

						if (value > 0) {
							let brightness = pow(value / (1+m), 1 / gamma);
							stroke(180 + value / m * 80, 25 + value / m * 50, brightness * 100, 1);
							let shapes = 8;
							for (let j = 0; j < shapes; j += 1) {
								let nj = j / shapes;

								push();
								//scale(nj);
								translate(width / 2, height / 2);
								//rotate(j * PI / (shapes / 2));
								point(width / 2 - x, height / 2 - y);
								//translate(width / 2, 0);
								//point(width / 2 - x, height / 2 - y);
								//point(x - width / 2.125, y - height / 1.25);
								pop();
							}
						}
					}
				}
			}
		}*/
	}
	
	xmotion += 0.01;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.00125);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.01);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"1155693","ifs polar log5","mySketch","// ifs
// https://flam3.com/flame_draves.pdf

var xmotion = 0;
var ymotion = 0;

let rx = 0;
let ry = 0;
let ax = 0;
let ay = 0;

let histo = [];

function setup() {
  createCanvas(800, 800);
  background(0);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 100, 100, 1);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	rx = width /1;
	ry = height/3;
	ax = random(0, 1);
	ay = random(0, 1);
	
	for (let i = 0; i < width * height; i += 1) {
		histo[i] = 0;
	}
	
	generate();
}

function r1(x, y) {
	return { x: x, y: y };
}

function r2(x, y) {
	return { x: (width / 2 + x / 2) , y: y };
}

function r3(x, y) {
	return { x: (width / 1 + x / 2) - y / 2, y: y };
}

function a1(x, y) {
	return { x: (1 - x / (PI * 1.25)), y: y / 4 - x / (PI * 1.25) };
}

function a2(x, y) {
	return { x: x * 0.25 + 0.75, y: (1.25 + y * 0.7) / 1.5 };
}

function a3(x, y) {
	return { x: x / (3.14 / 2) - y / (3.14 / 2), y: y + x * PI};
}

var r1 = [r1, r2, r3];
var a1 = [a1, a2, a3];

var iter = 0;

function draw() {
	//fill(0, 0, 0, 1);
	//rect(0, 0, width, height);
	
	let renderAtFrame = 60 * 2;
	
	if (frameCount <= renderAtFrame) {
		for (let i = 0; i < 5000; i += 1) {
			let index1 = floor(random(0, 3));
			let r = r1[index1](rx, ry);

			rx = r.x; ry = r.y;

			let index2 = floor(random(0, 3));
			let a = a1[index1](ax, ay);

			ax = a.x; ay = a.y;

			stroke(0, 0, 255, 0.025);

			if (iter > 20) {
				let x = width / 2 + rx * (sin(ax/4)); //* sqrt((ax+ax) * (ay+ay)*0.05)*2);//(sin(ax * PI * 2) * cos(ay * PI * 2));
				let y = height / 2 + ry * (cos(ay/2)); //* sqrt((ax+ax) * (ay+ay)*0.05)*2);
				
				let px = width / 2 - x;
				let py = height / 2 - y;

				if (x < width && x > 0 && y < height && y > 0) {
					push();
					translate(width / 2, height / 2);
					rotate(round(iter / 100) * PI / 3);
					point(px, py);
					point(-px, py);
					//translate(0, 0);
					//rotate(round(iter / 100) * PI / 20);
					//point(px, py);
					//point(x - width / 2.125, y - height / 1.25);
					let index = floor(x) + floor(y) * width;
					if (index >= 0 && index < (width * height)) {
						histo[index] += 1;
					}
					pop();
				}
			}

			iter += 1;
		}

		let cx = random(width / 4, width - width / 4);
		let cy = random(height / 4, height - height / 4);
/*
		if (frameCount % (renderAtFrame) == 0) {
		//	background(0);

			generate();

			let m = 0;
			for (let j = 0; j < width * height; j += 1) {
				let value = Math.log10(histo[j]);
				m = max(m, value);
			}

			if (m > 0) {
				for (let y = 0; y < height; y += 1) {
					for (let x = 0; x < width; x += 1) {
						let index = x + y * width;
						let value = Math.log10(histo[index]);
						let gamma = 2.2;

						if (value > 0) {
							let brightness = pow(value / (1+m), 1 / gamma);
							stroke(180 + value / m * 80, 25 + value / m * 50, brightness * 100, 1);
							let shapes = 8;
							for (let j = 0; j < shapes; j += 1) {
								let nj = j / shapes;

								push();
								//scale(nj);
								translate(width / 2, height / 2);
								//rotate(j * PI / (shapes / 2));
								point(width / 2 - x, height / 2 - y);
								//translate(width / 2, 0);
								//point(width / 2 - x, height / 2 - y);
								//point(x - width / 2.125, y - height / 1.25);
								pop();
							}
						}
					}
				}
			}
		}*/
	}
	
	xmotion += 0.01;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.00125);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.01);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"1150617","Tiny struct","mySketch","// experiment with Cordic algorithm to generate something interesting in very little code
// may fit into 256b on Linux (128b probably even lower on Dos)

  let oldX = 0, oldY = 0, ep = 0.0000001;
	let x = 0, y = 0;
function setup() {
	createCanvas(900, 900);
	
	background(0);

	// colorMode(HSL, 360, 255, 255);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
	
	oldX = 0;
}

let frame = 0;
let index = 1;

function draw() {
	loadPixels();

	for(let iter = 0; iter < 42000; iter += 1) {
		
  	//for(let i = 0;i < width/32;i += 1) {
			// cordic
		//	index /= width * height * 4/* + frame*/;
			x = (oldX+y/2048-x/4096) - ((oldY>>0)) + ((frame>>10));//index * oldY;
			y = (oldY-x/512) + (x>>1-(y>>21)) + ((frame>>16)|(x*2));//index * x;

			index = (floor(width / 3 + (x>>11)) + floor(height / 2 + (y>>11)) * width) * 4;
		let index2 = (width * height * 4) - index;
//index %= width * height * 4;
			
			// plot
			//pixels[index + 0] += 1;
			pixels[index + 1] += 1&iter;
			pixels[index + 2] += 1&iter;
			pixels[index + 0] += 1;
			pixels[index2 + 1] += 1;
			pixels[index2 + 2] += 1;
			pixels[index2 + 0] += 2&iter;
			/*pixels[index + 0]%=255;
			pixels[index + 1]%=255;
			pixels[index + 2]%=255;*/
			// pixels[index + 3] = 255;

    	oldX = x;
    	oldY = y;
  	//}
		
		
    frame += 8;
	//if (frame > 500000*6) frame = -frame;
  	//frame += 0.00005;
		//oldX += frame;
	}

	updatePixels();
}
"
"1150607","Full of stars 2","mySketch","// experiment with Cordic algorithm to generate something interesting in very little code
// may fit into 256b on Linux (128b probably even lower on Dos)

  let oldX = 0, oldY = 0, ep = 0.0000001;
	let x = 0, y = 0;
function setup() {
	createCanvas(1920/2, 1080/2);
	
	background(0);

	// colorMode(HSL, 360, 255, 255);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
	
	oldX = width / 2;
}

let frame = 0;
let index = 1;

function draw() {
	loadPixels();

	for(let iter = 0; iter < 42000; iter += 1) {
		
  	//for(let i = 0;i < width/32;i += 1) {
			// cordic
		//	index /= width * height * 4/* + frame*/;
			x = (oldX+y/512-x/512) - (oldY>>0) + ((frame>>10));//index * oldY;
			y = (oldY-x/512) + (x>>2-(y>>24)) + ((frame>>4)&x);//index * x;

			index = (floor(width / 1 + (x>>11)) + floor(height / 3 + (y>>11)) * width) * 4;
		let index2 = (width * height * 4) - index;
//index %= width * height * 4;
			
			// plot
			//pixels[index + 0] += 1;
			pixels[index + 1] += 1&iter;
			pixels[index + 2] += 1;
			pixels[index + 0] += 2;
			pixels[index2 + 1] += 1;
			pixels[index2 + 2] += 2;
			pixels[index2 + 0] += 2&iter;
			/*pixels[index + 0]%=255;
			pixels[index + 1]%=255;
			pixels[index + 2]%=255;*/
			// pixels[index + 3] = 255;

    	oldX = x;
    	oldY = y;
  	//}
		
		
    frame += 8;
	//if (frame > 500000*6) frame = -frame;
  	//frame += 0.00005;
		//oldX += frame;
	}

	updatePixels();
}
"
"1150605","Full of stars","mySketch","// experiment with Cordic algorithm to generate something interesting in very little code
// may fit into 256b on Linux (128b probably even lower on Dos)

  let oldX = 0, oldY = 0, ep = 0.0000001;
	let x = 0, y = 0;
function setup() {
	createCanvas(1920/2, 1080/2);
	
	background(0);

	// colorMode(HSL, 360, 255, 255);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
	
	oldX = width / 2;
}

let frame = 0;
let index = 1;

function draw() {
	loadPixels();

	for(let iter = 0; iter < 42000; iter += 1) {
		
  	//for(let i = 0;i < width/32;i += 1) {
			// cordic
		//	index /= width * height * 4/* + frame*/;
			x = (oldX+y/256-x/64) - (oldY>>0) + ((frame>>10));//index * oldY;
			y = (oldY-x/512) + (x>>1-(y>>20)) + ((frame>>4)&x);//index * x;

			index = (floor(width / 1 + (x>>11)) + floor(height / 3 + (y>>11)) * width) * 4;
		let index2 = (width * height * 4) - index;
//index %= width * height * 4;
			
			// plot
			//pixels[index + 0] += 1;
			pixels[index + 1] += 1;
			pixels[index + 2] += 2;
			pixels[index + 0] += 1&iter;
			pixels[index2 + 1] += 1;
			pixels[index2 + 2] += 2;
			pixels[index2 + 0] += 1&iter;
			/*pixels[index + 0]%=255;
			pixels[index + 1]%=255;
			pixels[index + 2]%=255;*/
			// pixels[index + 3] = 255;

    	oldX = x;
    	oldY = y;
  	//}
		
		
    frame += 10;
	//if (frame > 500000*6) frame = -frame;
  	//frame += 0.00005;
		//oldX += frame;
	}

	updatePixels();
}
"
"1148791","Space 12","mySketch","// base code of the skyscraper may fit into 256b (even less)
let xoff, yoff;

function setup() {
	createCanvas(800, 600);
	
	background(0);

	colorMode(HSL, 360, 255, 255, 1);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
	/*
	for (let y = 0; y < height; y += 1) {
		let ny = pow(y / height, 4);
		fill(ny * 70, random(64, 128), ny * 255, 1);
		rect(0, y, width, 1);
	}
	*/
	for (let y = 0; y < height; y += 1) {
		fill(random(0, 120), random(0, 128), random(0, 255), 1);
		rect(random(0, width), y + random(0, height / 3), random(1, 2), random(1, 2));
	}
	
	for (let i = 512; i > 0; i -= 1) {
		let ni = i / 512;
		fill(14 + (1-pow(ni, 4)) * 20 + random(10), 255, 128, 1 - pow(ni, 0.25));
		ellipse(width / 2, height / 3, (width / 20) * ni, (width / 20) * ni);
	}
	
//	fill(0);
	//ellipse(width / 2, height / 1.0, 32, 32);
	//arc(0, 64, 64, 64, -PI/2, PI/2);
}

function draw() {
	let sx = frameCount/width;
	let sy = frameCount/height;
	
	let h2 = height *2;

	for (let y = -h2; y < h2; y += 1) {
		const yy = y;
		//const yyy = y - sin(frameCount / 100) * h2;

		const t = yy & (frameCount/1.5);
		const fade = sin(frameCount/1000 * PI * 2);
		const brightness = t % 255;
		fill(200 + t % 200 - random(0, 8), 255&t, brightness % 255, 1);
		let x = abs((frameCount) | ((y/8)+t));
		//fill((brightness ^ frameCount) % 192, (brightness & frameCount) % 192, (brightness | frameCount) % 192);
		
		rect((width / 1.75 + x + width / 2 * sx), height / 2 + y * (sy/4), 1, 1);
		rect(width - (width / 1.75 + x + width / 2 * sx), height / 2 + y * (sy/4), 1, 1);
		rect(width / 2 + y * sy, (height / 2.5 + x + height / 2 * sx), 1, 1);
		rect(width - (width / 2 + y * sy), (height / 2.5 + x + height / 2 * sx), 1, 1);
	}

}
"
"1148734","ifs polar 7","mySketch","// ifs
// https://flam3.com/flame_draves.pdf

var xmotion = 0;
var ymotion = 0;

let rx = 0;
let ry = 0;
let ax = 0;
let ay = 0;

function setup() {
  createCanvas(800, 800);
  background(0);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 100, 100, 1);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	rx = random(0, width);
	ry = random(0, height);
	ax = random(0, 1);
	ay = random(0, 1);
}

function r1(x, y) {
	return { x: x / 2, y: y / 2 };
}

function r2(x, y) {
	return { x: (width / 8 + x) / 1.25, y: (height / 2 + y) / 2 };
}

function r3(x, y) {
	return { x: (width / 8 + x) / 1.25, y: y / 2 };
}

function a1(x, y) {
	return { x: x / 1, y: y / 1 };
}

function a2(x, y) {
	return { x: (0.75 + x) / 14.75, y: (PI + y) / 4 };
}

function a3(x, y) {
	return { x: (0.75 + pow(x, 0.5)) / 8, y: y /0.75};
}

var r1 = [r1, r2, r3];
var a1 = [a1, a2, a3];

var iter = 0;

function draw() {
	//fill(0, 0, 0, 1);
	//rect(0, 0, width, height);
	
	for (let i = 0; i < 2000; i += 1) {
		let index1 = floor(random(0, 3));
		let r = r1[index1](rx, ry);

		rx = r.x; ry = r.y;
		
		let index2 = floor(random(0, 3));
		let a = a1[(index1 + 1) % a1.length](ax, ay);

		ax = a.x; ay = a.y;

		stroke(0, 0, 255, 0.05);

		if (iter > 20) {
			let x = width / 2 + rx * (sin(ax * PI * 2.5)/**(1-abs(0.5-rx / width)*2)*//* + cos(ax * PI * 1)*/);//(sin(ax * PI * 2) * cos(ay * PI * 2));
			let y = height / 2 + ry * (sin(ay * PI * 2.5)/**(1-abs(0.5-ry / height)*2)*/ /*- cos(ay * PI * 2)*/);
			
			push();
			translate(width / 2, height / 2);
			rotate(round(iter / 100) * PI / 4/* + frameCount / 1000*/);
			point(width / 2.5 - x, height / 2.5 - y);
			//rect(width - x, height - y, 1, 1);	
			pop();
		}
		
		iter += 1;
	}
	
	xmotion += 0.01;
	ymotion += 1;
}"
"1147468","cordic 9","mySketch","// experiment with Cordic algorithm to generate something interesting in very little code
// may fit into 512b at least on Linux (256b probably even lower on Dos)

  let oldX = 0, oldY = 0, ep = 0.0000001;
	let x = 0, y = 0;
function setup() {
	createCanvas(1920/2, 1080/2);
	
	background(0);

	// colorMode(HSL, 360, 255, 255);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
	
	//oldX;
}

let frame = 0;
let index = 1;

function draw() {
	loadPixels();

	for(let iter = 0; iter < 42000; iter += 1) {
		
  	//for(let i = 0;i < width/32;i += 1) {
			// cordic
		//	index /= width * height * 4/* + frame*/;
			x = (oldX - (oldY<<1) + (((frame>>8))));//index * oldY;
			y = ((oldY) + (x>>0) - ((frame>>20)&x));//index * x;

			index = (floor(((width >> 1) + (x>>5^(y>>5)) + (frame>>24))) + floor(height - (height / 2 + (y>>4))) * width) * 4;
		  let index2 = (floor((width >> 1) + (x>>6) + (frame>>16)) + floor((/*height / 2 + */(y>>6))) * width) * 4;
index2 %= width * height * 4;
		//if (index > width * height * 4) index = 0;
		//if (index < 0) index = 0;
			
			// plot
			//pixels[index + 0] += 1;
		/*	pixels[index + 1] += 1;
			pixels[index + 2] += 1;
			pixels[index + 0] += 1;*/
			pixels[index2 + 1] += 1;
			pixels[index2 + 2] += 1;
			pixels[index2 + 0] += 1;
			/*pixels[index + 0]%=255;
			pixels[index + 1]%=255;
			pixels[index + 2]%=255;*/
			// pixels[index + 3] = 255;

    	oldX = x;
    	oldY = y;
  	//}
		
		
    frame += 1;
	//if (frame > 500000*6) frame = -frame;
  	//frame += 0.00005;
		//oldX += frame;
	}

	updatePixels();
}
"
"1147441","cordic 8","mySketch","// experiment with Cordic algorithm to generate something interesting in very little code
// may fit into 512b at least on Linux (256b probably even lower on Dos)

  let oldX = 0, oldY = 0, ep = 0.0000001;
	let x = 0, y = 0;
function setup() {
	createCanvas(1920/2, 1080/2);
	
	background(0);

	// colorMode(HSL, 360, 255, 255);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
	
	//oldX;
}

let frame = 0;
let index = 1;

function draw() {
	loadPixels();

	for(let iter = 0; iter < 42000; iter += 1) {
		
  	//for(let i = 0;i < width/32;i += 1) {
			// cordic
		//	index /= width * height * 4/* + frame*/;
			x = round(floor(oldX) - (oldY>>0) + (((frame>>8))));//index * oldY;
			y = round((oldY) + (x>>2) - ((frame>>16)&x));//index * x;

			index = (floor(((width >> 1) + (x>>5^(y>>5)) + (frame>>24))) + floor(height - (height / 2 + (y>>4))) * width) * 4;
		  let index2 = (floor((width >> 1) + (x>>6) + (frame>>28)) + floor((height / 2 + (y>>6))) * width) * 4;
//index %= width * height * 4;
		//if (index > width * height * 4) index = 0;
		//if (index < 0) index = 0;
			
			// plot
			//pixels[index + 0] += 1;
		/*	pixels[index + 1] += 1;
			pixels[index + 2] += 1;
			pixels[index + 0] += 1;*/
			pixels[index2 + 1] += 1;
			pixels[index2 + 2] += 1;
			pixels[index2 + 0] += 1;
			/*pixels[index + 0]%=255;
			pixels[index + 1]%=255;
			pixels[index + 2]%=255;*/
			// pixels[index + 3] = 255;

    	oldX = x;
    	oldY = y;
  	//}
		
		
    frame += 1;
	//if (frame > 500000*6) frame = -frame;
  	//frame += 0.00005;
		//oldX += frame;
	}

	updatePixels();
}
"
"1147440","cordic patterns","mySketch","// experiment with Cordic algorithm to generate something interesting in very little code
// may fit into 512b at least on Linux (256b probably even lower on Dos)

  let oldX = 0, oldY = 0, ep = 0.0000001;
	let x = 0, y = 0;
function setup() {
	createCanvas(1920/2, 1080/2);
	
	background(0);

	// colorMode(HSL, 360, 255, 255);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
	
	//oldX;
}

let frame = 0;
let index = 1;

function draw() {
	loadPixels();

	for(let iter = 0; iter < 42000; iter += 1) {
		
  	//for(let i = 0;i < width/32;i += 1) {
			// cordic
		//	index /= width * height * 4/* + frame*/;
			x = round(floor(oldX) - (oldY>>0) + (((frame>>8))));//index * oldY;
			y = round((oldY) + (x>>0) - ((frame>>16)&x));//index * x;

			index = (floor(((width >> 1) + (x>>5^(y>>5)) + (frame>>24))) + floor(height - (height / 2 + (y>>4))) * width) * 4;
		  let index2 = (floor((width >> 1) + (x>>6) + (frame>>28)) + floor((height / 2 + (y>>6))) * width) * 4;
//index %= width * height * 4;
		//if (index > width * height * 4) index = 0;
		//if (index < 0) index = 0;
			
			// plot
			//pixels[index + 0] += 1;
		/*	pixels[index + 1] += 1;
			pixels[index + 2] += 1;
			pixels[index + 0] += 1;*/
			pixels[index2 + 1] += 1;
			pixels[index2 + 2] += 1;
			pixels[index2 + 0] += 1;
			/*pixels[index + 0]%=255;
			pixels[index + 1]%=255;
			pixels[index + 2]%=255;*/
			// pixels[index + 3] = 255;

    	oldX = x;
    	oldY = y;
  	//}
		
		
    frame += 1;
	//if (frame > 500000*6) frame = -frame;
  	//frame += 0.00005;
		//oldX += frame;
	}

	updatePixels();
}
"
"1144323","droplet 5 int","mySketch","// experiment with Cordic algorithm to generate something interesting in very little code
// may fit into 512b at least on Linux (256b probably even lower on Dos)

  let oldX = 0, oldY = 0, ep = 0.0000001;
	let x = 0, y = 0;
function setup() {
	createCanvas(1920/2, 1080/2);
	
	background(0);

	// colorMode(HSL, 360, 255, 255);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
	
	//oldX;
}

let frame = 0;
let index = 1;

function draw() {
	loadPixels();

	for(let iter = 0; iter < 42000; iter += 1) {
		
  	//for(let i = 0;i < width/32;i += 1) {
			// cordic
		//	index /= width * height * 4/* + frame*/;
			x = round((oldX) - (oldY>>2) + ((frame>>8)));//index * oldY;
			y = round((oldY/*/1.001*/-(oldY>>10)) + (x>>6) + ((frame>>12)&x));//index * x;
		
		//oldX = x;

			oldX = (floor((width >> 1) + (x>>4) + (frame>>11)) + floor((height>>1) + (y>>6)) * width) * 4;
		  let index2 = (width * height * 4) - oldX;//(floor(width - ((width >> 1) + (x>>5) + (frame>>10))) + floor(height - (height/2 + (y>>6))) * width) * 4;
//index %= width * height * 4;
		//if (index > width * height * 4) index = 0;
		//if (index < 0) index = 0;
			
			// plot
			//pixels[index + 0] += 1;
			pixels[oldX + 1] += 1;
			pixels[oldX + 2] += 1&iter;
			pixels[oldX + 0] += 2;
		/*pixels[index2 + 1] += 1;
			pixels[index2 + 2] += 1&iter;
			pixels[index2 + 0] += 2;*/
			//pixels[index + 0]%=256;
			//pixels[index + 1]%=256;
			//pixels[index + 2]%=256;
			// pixels[index + 3] = 255;

    	oldX = x;
    	oldY = y;
  	//}
		
		
    frame += 1;
	//if (frame > 500000*6) frame = -frame;
  	//frame += 0.00005;
		//oldX += frame;
	}

	updatePixels();
}
"
"1144225","hall of mirrors int","mySketch","// experiment with Cordic algorithm to generate something interesting in very little code
// may fit into 512b at least on Linux (256b probably even lower on Dos)

  let oldX = 0, oldY = 0, ep = 0.0000001;
	let x = 0, y = 0;
function setup() {
	createCanvas(1920/2, 1080/2);
	
	background(0);

	// colorMode(HSL, 360, 255, 255);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
	
	//oldX;
}

let frame = 0;
let index = 1;

function draw() {
	loadPixels();

	for(let iter = 0; iter < 42000; iter += 1) {
		
  	//for(let i = 0;i < width/32;i += 1) {
			// cordic
		//	index /= width * height * 4/* + frame*/;
			x = round((oldX) - (oldY>>1) + ((frame>>20) * iter/80000));//index * oldY;
			y = round(((oldY)-(oldY>>8)) + (x>>14) + ((frame>>15)&x));//index * x;

			index = (floor((width >> 1) + (x>>14)) + floor(height/2 + (y>>3)) * width) * 4;
		  
//index %= width * height * 4;
		if (index > width * height * 4) index = 0;
		if (index < 0) index = 0;
			let index2 = (width * height * 4) - index;//(floor(width - ((width >> 1) + (x>>5) + (frame>>10))) + floor(height - (height/2 + (y>>6))) * width) * 4;
			// plot
			//pixels[index + 0] += 1;
			pixels[index + 1] += 1;
			pixels[index + 2] += 2;
			pixels[index + 0] += 1&iter;
			pixels[index2 + 1] += 1;
			pixels[index2 + 2] += 2;
			pixels[index2 + 0] += 1&iter;
			/*pixels[index + 0]%=255;
			pixels[index + 1]%=255;
			pixels[index + 2]%=255;*/
			// pixels[index + 3] = 255;

    	oldX = x;
    	oldY = y;
  	//}
		
		
    frame += 1;
	//if (frame > 500000*6) frame = -frame;
  	//frame += 0.00005;
		//oldX += frame;
	}

	updatePixels();
}
"
"1144196","ifs polar 6","mySketch","// ifs
// https://flam3.com/flame_draves.pdf

var xmotion = 0;
var ymotion = 0;

let rx = 0;
let ry = 0;
let ax = 0;
let ay = 0;

function setup() {
  createCanvas(800, 800);
  background(0);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 100, 100, 1);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	rx = random(0, width);
	ry = random(0, height);
	ax = random(0, 1);
	ay = random(0, 1);
}

function r1(x, y) {
	return { x: x / 2, y: y / 2 };
}

function r2(x, y) {
	return { x: (width / 32 + x) / 2, y: (height / 2 + y) / 1.5 };
}

function r3(x, y) {
	return { x: (width / 8 + x) / 1.25, y: y / 2 };
}

function a1(x, y) {
	return { x: x / 1, y: y / 1 };
}

function a2(x, y) {
	return { x: (0.25 + x) / 2, y: y / 8 };
}

function a3(x, y) {
	return { x: (1 + x) / 1, y: y};
}

var r1 = [r1, r2, r3];
var a1 = [a1, a2, a3];

var iter = 0;

function draw() {
	//fill(0, 0, 0, 1);
	//rect(0, 0, width, height);
	
	for (let i = 0; i < 5000; i += 1) {
		let index1 = floor(random(0, 3));
		let r = r1[index1](rx, ry);

		rx = r.x; ry = r.y;
		
		let index2 = floor(random(0, 3));
		let a = a1[(index1 + 1) % a1.length](ax, ay);

		ax = a.x; ay = a.y;

		stroke(0, 0, 255, 0.035);

		if (iter > 20) {
			let x = width / 2*noise(rx/width*16) + rx * (sin(ax * PI * 0.025)*64/**(1-abs(0.5-rx / width)*2)*//* + cos(ax * PI * 1)*/);//(sin(ax * PI * 2) * cos(ay * PI * 2));
			let y = height / 2 + ry * (sin(ay * PI * 0.025)*64/**(1-abs(0.5-ry / height)*2)*/ /*- cos(ay * PI * 2)*/);
			
			push();
			translate(width / 2, height / 2);
			rotate((0.5-rx / width)*2 *8+ (0.5-ry / height)*2*8 + frameCount / 2000);
			point(width / 1.1 - x, height / 1.1 - y);
			point(width / 1.5 - x, height / 1.5 - y);
			point(width / 1.75 - x, height / 1.75 - y);

			//rect(width - x, height - y, 1, 1);	
			pop();
		}
		
		iter += 1;
	}
	
	xmotion += 0.01;
	ymotion += 1;
}"
"1143828","ifs polar","mySketch","// ifs
// https://flam3.com/flame_draves.pdf

var xmotion = 0;
var ymotion = 0;

let rx = 0;
let ry = 0;
let ax = 0;
let ay = 0;

function setup() {
  createCanvas(800, 800);
  background(0);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 100, 100, 1);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	rx = random(0, width);
	ry = random(0, height);
	ax = random(0, 1);
	ay = random(0, 1);
}

function r1(x, y) {
	return { x: x / 2, y: y / 2 };
}

function r2(x, y) {
	return { x: (width / 32 + x) / 4, y: (height / 2 + y) / 2 };
}

function r3(x, y) {
	return { x: (width / 8 + x) / 1.25, y: y / 2 };
}

function a1(x, y) {
	return { x: x / 2, y: y / 2 };
}

function a2(x, y) {
	return { x: (0.5 + x) / 2, y: (PI + y) / 4 };
}

function a3(x, y) {
	return { x: (4 + x) / 2, y: y };
}

var r1 = [r1, r2, r3];
var a1 = [a1, a2, a3];

var iter = 0;

function draw() {
	//fill(0, 0, 0, 1);
	//rect(0, 0, width, height);
	
	for (let i = 0; i < 2000; i += 1) {
		let index1 = floor(random(0, 3));
		let r = r1[index1](rx, ry);

		rx = r.x; ry = r.y;
		
		let index2 = floor(random(0, 3));
		let a = a1[(index1 + 1) % a1.length](ax, ay);

		ax = a.x; ay = a.y;

		stroke(0, 0, 255, 0.01);

		if (iter > 20) {
			let x = width / 2 + rx * (sin(ax * PI * 1)/**(1-abs(0.5-rx / width)*2)*//* + cos(ax * PI * 1)*/);//(sin(ax * PI * 2) * cos(ay * PI * 2));
			let y = height / 2 + ry * (sin(ay * PI * 1)/**(1-abs(0.5-ry / height)*2)*/ /*- cos(ay * PI * 2)*/);
			
			push();
			translate(width / 2, height / 2);
			rotate(round(iter / 100) * PI / 4/* + frameCount / 1000*/);
			point(width / 2 - x, height / 2 - y);
			//rect(width - x, height - y, 1, 1);	
			pop();
		}
		
		iter += 1;
	}
	
	xmotion += 0.01;
	ymotion += 1;
}"
"1143769","Green text 2","mySketch","// more automatic drawing by generating L-systems rules + switching rules randomly

let img;
function preload() {
  img = loadImage('tree.png');
}

function pal(t, a, b, c, d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

function weightedRandom(prob) {
  let i, sum=0, r=Math.random();
  for (i in prob) {
    sum += prob[i];
    if (r <= sum) return i;
  }
}

class lm {
	constructor(axiom, rules, angle, step, iter) {
		this.ax = width / 2;
		this.ay = height / 2;
		this.px = this.ax;
		this.py = this.ay;
		this.ta = angle;
		this.ca = PI;
		this.fs = step;
		this.col = [0,0,0,0];
		
		this.stack = [];
		
		this.axiom = axiom;
		this.rules = rules;
		this.itera = iter;
		
		this.rule = 0;
		
		this.cycles = 0;
		
		this.b = false;
		
		this.where = 1;
		
		this.initialize();
	}
	
	initialize() {
		let rule = this.axiom;
		for (let i = 0; i < this.itera; i++) {
			rule = this.lindenmayer(rule);
		}
		
		this.rule = rule;
	}
	
	lindenmayer(s) {
		let outputstring = '';

		for (let i = 0; i < s.length; i++) {
			let ismatch = 0;
			for (let j = 0; j < this.rules.length; j++) {
				if (s[i] == this.rules[j][0])  {
					let rule_index = 1;
					if (this.rules[j].length > 2) { // stochastic
						let probs = {};
						for (let k = 1; k < this.rules[j].length; k+=2) {
							probs[k+1] = this.rules[j][k];
						}
						rule_index = weightedRandom(probs);
					}
					outputstring += this.rules[j][rule_index];
					ismatch = 1;
					break;
				}
			}

			if (ismatch == 0) outputstring+= s[i];
		}
		
		return outputstring;
	}
	
	computeParameters(w) {
		
	}
	
	compute(cb_trigger) {
		let k = this.rule[this.where];
		if (k == 'F' || k == 'f') {
			var polx = this.fs * sin(this.ca);
			var poly = this.fs * cos(this.ca);
			let x1 = this.b ? this.px - polx : this.px + polx;
			let y1 = this.b ? this.py - poly : this.py + poly;

			if (x1 < 0 || y1 < 0 || x1 > width || y1 > height) {
				this.b = !this.b;
				this.ta = -this.ta;//random() * PI * 2;
				
				if (x1 < 0) { x1 = width; this.px = width; if (random() > 0.99995) { y1 += 1; if (y1 >= height) { y1 -= height; this.py = y1; } } }
				if (y1 < 0) { y1 = height; this.py = height; if (random() > 0.99995) { x1 += 1; if (x1 >= width) { x1 %= width; this.px = x1; } } }
				if (x1 > width) { x1 = 0; this.px = 0; }
				if (y1 > height) { y1 = 0; this.py = 0; }
			}

			this.ax = this.px;
			this.ay = this.py;
			this.px = x1;
			this.py = y1;
		} else if (k == '[') {
			this.stack.push(this.px);
			this.stack.push(this.py);
			this.stack.push(this.ca);
		} else if (k == ']') {
			this.ca = this.stack.pop();
			this.py = this.stack.pop();
			this.px = this.stack.pop();
		} else if (k == '+') {
			this.ca += this.ta;
		} else if (k == '-') {
			this.ca -= this.ta;
		}
		
		this.where++;
  	if (this.where > this.rule.length-1 || random() > 0.9995) {
			this.where = 0;
			this.cycles += 1;
			
			cb_trigger(this);
		}
		
		if (k == 'F') {
			return true;
		} else {
			return false;
		}
	}
}

var xmotion = 0;
var ymotion = 0;

let lms = [];

function getRule() {
	let len = 16 + random() * 64;
	let rule = [''];
	let stak = [];
	let last = '';
	for (let i = 0; i < len; i += 1) {
		let c = ['X', '+', '-', 'F', '[', ']']
		let chosen = c[floor((c.length-1) * random())];
		
		if (last == '' && chosen == '[') {
			chosen = c[floor((c.length-2) * random())];
		}
		
		if (chosen == '[') {
			stak.push(']');
		} else if (chosen == ']' && stak.length == 0) {
			chosen = c[floor((c.length-2) * random())];
		} else if (chosen == ']' && last == '[') {
			chosen = c[floor((c.length-2) * random())];
		}
		
		rule[0] += chosen;
		
		last = chosen;
	}
	
	while (stak.length) {
		let last = rule[0][rule[0].length - 1];
		
		if (last == '[') {
			rule[0] = rule[0].slice(0, rule[0].length - 1)
			stak.pop();	
		} else {
			rule[0] += stak.pop();	
		}
	}
	
	return rule;
}

function setup() {
  createCanvas(1280, 840);

  background(0);
	
	noiseDetail(7, 0.7);
	
	let pg = createGraphics(1280, 840);
	/*pg.fill(255);
	pg.textAlign(CENTER, CENTER);
	pg.textSize(192);
	pg.text(""PROCESSING"", width / 2, height / 2);
	pg.loadPixels();*/
	pg.image(img, width / 2 - img.width / 2, height - img.height);
	
	
	
	img.loadPixels();
	for (let j = 0; j < img.height; j += 1) {
		for (let i = 0; i < img.width; i += 1) {
			let index = (i + j * img.width) * 4
			if (img.pixels[index] >= 128) {
				img.pixels[index] = 0;
				img.pixels[index+1] = 0;
				img.pixels[index+2] = 0;
			}
		}
	}
	img.updatePixels();
	
	image(img, width / 2 - img.width / 2, height - img.height);
	//filter(INVERT);
	//colorMode(HSB, 360, 100, 100, 255);
	
	//blendMode(LIGHTEST);
	
	stroke(0, 0, 100, 255);
 // lms[0] = new lm('X', [['X', 0.5, 'XFFFF-[F-X+]FX+', 0.5, 'FFFFF[f+F]------------F'], ['F', '+F--F+']], radians(45), 1);
	let amount = 1500;
	for (let i = 0; i < amount; i += 1) {
		lms[i] = new lm('X', [['X', getRule()[0]], ['F', 'F+FF']], sin(i / amount * PI * 16)*8, 1, 3);
		//if (random() < 0.05) {
		//	lms[i].px = width / 2;
		//	lms[i].py = height / 2;
		//} else {
		let px = [0];
		while (px[0] < 128) {
			let pxx = random(0, width);
			let pyy = random(0, height);
			px = pg.get(pxx, pyy);
			lms[i].px = pxx;//width / 2 + width / 2.75 * sin(i / amount * PI * 7) * (i / 100);//random(0, width); lms[i].py = random(0, height);
			lms[i].py = pyy;//height / 2 + height / 2.75 * cos(i / amount * PI * 7) * (i / 100);
			lms[i].col = px;
		}
		//}
	}
	//lms[1] = new lm('X', [['X', 'F-[[X]+X]+F[+FX]-X'], ['F', 'FF']], radians(90), 1);
}

function change(lm) {
	let max_cycles = 1;
	noStroke();
	if (lm.cycles % max_cycles == 0) {
		lm.ta += 0.00001;
		lm.fs = random(0.125, 0.5);
		
		let rule = getRule()[0];
		
		if (rule.length < 64) {
			lm.itera = 1 + floor(random() * 4);
		} else if (rule.length < 128) {
			lm.itera = 1 + floor(random() * 3);
		} else if (rule.length < 256) {
			lm.itera = 1 + floor(random() * 2);
		} else {
			lm.itera = 1 + floor(random() * 2);
		}
		lm.cycles = 0;

		lm.rules = [['X', rule], ['F', 'FF']];
		lm.initialize();
		
		//fill(0, 0, 0, 92);
		//rect(0, 0, width, height);
	}
	
	/*
	if (lm.cycles % 16 == 0) {
		fill(0, 0, 0, 48);
		rect(0, 0, width, height);
	}
	*/
	
	let nc = (lm.cycles % 8) / 8;
	stroke(0, 0, 100, random(0, 10));
	
	//if (random() > 0.25) {
		lm.iter = 1;
		lm.initialize();
	/*} else {
		lm.iter = 2;
		lm.initialize();
	}*/
}

let pale = [""#005A04"", ""#CCFFBB"", ""#3A5F0B"", ""#005502"", ""#40a040""];
function draw() {
	for (let k = 0; k < 10; k += 1) {
		for (let i = 0; i < lms.length; i += 1) {
			let lm = lms[i];
			
			let result = lm.compute(change);
			
			if (result) {
				//stroke(k / 3 + abs(sin(xmotion/24))*180, 30, 255, 255);
			var pa1 = 1, pa2 = 1, pa3 = 1;
			var pb1 = 0.7, pb2 = 0.25, pb3 =0.5;
			var pc1 = 0.91, pc2 = 0.5, pc3 = 0.14;

			var pdr = 0.4;
			var pdg = 0.71;
			var pdb = 0.6;

				var pt = abs(sin(xmotion/k/300 + i/4));
				
				var br = pow(abs(sin(i / lms.length * PI * 2 + xmotion / 400)), 20.);
				//if (br < 0.25) br = 0;

				var rf = pal(pt, pa1, pb1, pc1, pdr) * 255*br;
				var gf = pal(pt, pa2, pb2, pc2, pdg) * 255*br;
				var bf = pal(pt, pa3, pb3, pc3, pdb) * 255*br;

				stroke(rf, gf, bf, 255);/*lm.col[0], lm.col[1], lm.col[2], 255);*///
				
				strokeWeight(1/* + abs(sin(xmotion/16+i))*8*/);
				var context = drawingContext
        context.shadowBlur = 1;
				if (br > 0.25) {
					context.shadowOffsetX = random(-1, 1);
					context.shadowOffsetY = random(-1, 1);
        	context.shadowColor = ""black"";
				} else {
      	  context.shadowOffsetX = random(0, 1);
    	    context.shadowOffsetY = random(0, 1);
					context.shadowColor = pale[i % pal.length];
				}
				line(lm.px, lm.py, lm.ax, lm.ay);
			}
		}
	}
	
	xmotion += 0.5;
	ymotion += 0.25;
}"
"1142757","ifs polar log5","mySketch","// ifs
// https://flam3.com/flame_draves.pdf

var xmotion = 0;
var ymotion = 0;

let rx = 0;
let ry = 0;
let ax = 0;
let ay = 0;

let histo = [];

function setup() {
  createCanvas(800, 800);
  background(0);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 100, 100, 1);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	rx = width /2;
	ry = height/2;
	ax = random(0, 1);
	ay = random(0, 1);
	
	for (let i = 0; i < width * height; i += 1) {
		histo[i] = 0;
	}
}

function r1(x, y) {
	return { x: x, y: y };
}

function r2(x, y) {
	return { x: (width / 1.5 + x / 3), y: y };
}

function r3(x, y) {
	return { x: (width / 2.0 + x / 8) - y / 4, y: y};
}

function a1(x, y) {
	return { x: (1.0 - x / (PI * 0.75 + x / 2)), y: y / 2 + x / (PI * 2.25) };
}

function a2(x, y) {
	return { x: x * 0.5 + 0.5, y: (2.25 + y * 0.5 - x / 2) / 1 };
}

function a3(x, y) {
	return { x: x / 3 - y / 4, y: y/2.5 + x * PI};
}

var r1 = [r1, r2, r3];
var a1 = [a1, a2, a3];

var iter = 0;

function draw() {
	//fill(0, 0, 0, 1);
	//rect(0, 0, width, height);
	
	let renderAtFrame = 60 * 2;
	
	if (frameCount <= renderAtFrame) {
		for (let i = 0; i < 5000; i += 1) {
			let index1 = floor(random(0, 3));
			let r = r1[index1](rx, ry);

			rx = r.x; ry = r.y;

			let index2 = floor(random(0, 3));
			let a = a1[index1](ax, ay);

			ax = a.x; ay = a.y;

			stroke(0, 0, 255, 0.05);

			if (iter > 20) {
				let x = width / 2 + rx * (sin(ax/2)); //* sqrt((ax+ax) * (ay+ay)*0.05)*2);//(sin(ax * PI * 2) * cos(ay * PI * 2));
				let y = height / 2 + ry * (cos(ay/2)); //* sqrt((ax+ax) * (ay+ay)*0.05)*2);

				let px = width / 2 - x;
				let py = height / 2 - y;

				if (x < width && x > 0 && y < height && y > 0) {
					push();
					translate(width / 2, height / 2);
					//rotate(round(iter / 100) * PI / 4);
					point(px, py);
					point(-px, py);
					//translate(0, 0);
					//rotate(round(iter / 100) * PI / 20);
					//point(px, py);
					//point(x - width / 2.125, y - height / 1.25);
					let index = floor(x) + floor(y) * width;
					if (index >= 0 && index < (width * height)) {
						histo[index] += 1;
					}
					pop();
				}
			}

			iter += 1;
		}

		let cx = random(width / 4, width - width / 4);
		let cy = random(height / 4, height - height / 4);
/*
		if (frameCount % (renderAtFrame) == 0) {
		//	background(0);

			generate();

			let m = 0;
			for (let j = 0; j < width * height; j += 1) {
				let value = Math.log10(histo[j]);
				m = max(m, value);
			}

			if (m > 0) {
				for (let y = 0; y < height; y += 1) {
					for (let x = 0; x < width; x += 1) {
						let index = x + y * width;
						let value = Math.log10(histo[index]);
						let gamma = 2.2;

						if (value > 0) {
							let brightness = pow(value / (1+m), 1 / gamma);
							stroke(180 + value / m * 80, 25 + value / m * 50, brightness * 100, 1);
							let shapes = 8;
							for (let j = 0; j < shapes; j += 1) {
								let nj = j / shapes;

								push();
								//scale(nj);
								translate(width / 2, height / 2);
								//rotate(j * PI / (shapes / 2));
								point(width / 2 - x, height / 2 - y);
								//translate(width / 2, 0);
								//point(width / 2 - x, height / 2 - y);
								//point(x - width / 2.125, y - height / 1.25);
								pop();
							}
						}
					}
				}
			}
		}*/
	}
	
	xmotion += 0.01;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.00125);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.01);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"1141804","Tiny inf","mySketch","// experiment with Cordic algorithm to generate something interesting in very little code
// may fit into 512b at least on Linux (256b probably even lower on Dos)

  let oldX = 0, oldY = 0, ep = 0.0000001;
	let x = 0, y = 0;
function setup() {
	createCanvas(1920/2, 1080/2);
	
	background(0);

	// colorMode(HSL, 360, 255, 255);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
	
	//oldX;
}

let frame = 0;
let index = 1;

function draw() {
	loadPixels();

	for(let iter = 0; iter < 42000; iter += 1) {
		
  	//for(let i = 0;i < width/32;i += 1) {
			// cordic
		//	index /= width * height * 4/* + frame*/;
			x = round((oldX) - (oldY>>1) + ((frame>>6) * iter/100000));//index * oldY;
			y = round(((oldY)/*/1.001*/-(oldY>>13)) + (x>>10) + ((frame>>18)&x));//index * x;

			index = (floor((width >> 1) + (x>>11)) + floor(height/2 + (y>>9+(iter>>10))) * width) * 4;
		  let index2 = (width * height * 4) - index;//(floor(width - ((width >> 1) + (x>>5) + (frame>>10))) + floor(height - (height/2 + (y>>6))) * width) * 4;
index %= width * height * 4;
//		if (index > width * height * 4) index = 0;
	//	if (index < 0) index = 0;
			
			// plot
			//pixels[index + 0] += 1;
			pixels[index + 1] += 1;
			pixels[index + 2] += 2&iter;
			pixels[index + 0] += 1;
			pixels[index2 + 1] += 1;
			pixels[index2 + 2] += 2&iter;
			pixels[index2 + 0] += 1;
			/*pixels[index + 0]%=255;
			pixels[index + 1]%=255;
			pixels[index + 2]%=255;*/
			// pixels[index + 3] = 255;

    	oldX = x;
    	oldY = y;
  	//}
		
		
    frame += 1;
	//if (frame > 500000*6) frame = -frame;
  	//frame += 0.00005;
		//oldX += frame;
	}

	updatePixels();
}
"
"1141785","droplet 4 int","mySketch","// experiment with Cordic algorithm to generate something interesting in very little code
// may fit into 512b at least on Linux (256b probably even lower on Dos)

  let oldX = 0, oldY = 0, ep = 0.0000001;
	let x = 0, y = 0;
function setup() {
	createCanvas(1920/2, 1080/2);
	
	background(0);

	// colorMode(HSL, 360, 255, 255);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
	
	//oldX;
}

let frame = 0;
let index = 1;

function draw() {
	loadPixels();

	for(let iter = 0; iter < 42000; iter += 1) {
		
  	//for(let i = 0;i < width/32;i += 1) {
			// cordic
		//	index /= width * height * 4/* + frame*/;
			x = round((oldX) - (oldY>>1) + ((frame>>6) * iter/80000));//index * oldY;
			y = round((oldY/*/1.001*/-(oldY>>12)) + (x>>10) + ((frame>>15)&x));//index * x;

			index = (floor((width >> 1) + (x>>10)) + floor(height/2 + (y>>8)) * width) * 4;
		  let index2 = (width * height * 4) - index;//(floor(width - ((width >> 1) + (x>>5) + (frame>>10))) + floor(height - (height/2 + (y>>6))) * width) * 4;
//index %= width * height * 4;
		//if (index > width * height * 4) index = 0;
		//if (index < 0) index = 0;
			
			// plot
			//pixels[index + 0] += 1;
			pixels[index + 1] += 1;
			pixels[index + 2] += 2;
			pixels[index + 0] += 1&iter;
			pixels[index2 + 1] += 1;
			pixels[index2 + 2] += 2;
			pixels[index2 + 0] += 1&iter;
			/*pixels[index + 0]%=255;
			pixels[index + 1]%=255;
			pixels[index + 2]%=255;*/
			// pixels[index + 3] = 255;

    	oldX = x;
    	oldY = y;
  	//}
		
		
    frame += 1;
	//if (frame > 500000*6) frame = -frame;
  	//frame += 0.00005;
		//oldX += frame;
	}

	updatePixels();
}
"
"1141781","droplet 3 int","mySketch","// experiment with Cordic algorithm to generate something interesting in very little code
// may fit into 512b at least on Linux (256b probably even lower on Dos)

  let oldX = 0, oldY = 0, ep = 0.0000001;
	let x = 0, y = 0;
function setup() {
	createCanvas(1920/2, 1080/2);
	
	background(0);

	// colorMode(HSL, 360, 255, 255);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
	
	//oldX;
}

let frame = 0;
let index = 1;

function draw() {
	loadPixels();

	for(let iter = 0; iter < 42000; iter += 1) {
		
  	//for(let i = 0;i < width/32;i += 1) {
			// cordic
		//	index /= width * height * 4/* + frame*/;
			x = round((oldX) - (oldY>>2) + ((frame>>6) * iter/80000));//index * oldY;
			y = round((oldY/*/1.001*/-(oldY>>10)) + (x>>8) + ((frame>>12)&x));//index * x;

			index = (floor((width >> 1) + (x>>5) + (frame>>10)) + floor(height/2 + (y>>6)) * width) * 4;
		  let index2 = (width * height * 4) - index;//(floor(width - ((width >> 1) + (x>>5) + (frame>>10))) + floor(height - (height/2 + (y>>6))) * width) * 4;
//index %= width * height * 4;
		//if (index > width * height * 4) index = 0;
		//if (index < 0) index = 0;
			
			// plot
			//pixels[index + 0] += 1;
			pixels[index + 1] += 1;
			pixels[index + 2] += 2;
			pixels[index + 0] += 1&iter;
			pixels[index2 + 1] += 1;
			pixels[index2 + 2] += 2;
			pixels[index2 + 0] += 1&iter;
			/*pixels[index + 0]%=255;
			pixels[index + 1]%=255;
			pixels[index + 2]%=255;*/
			// pixels[index + 3] = 255;

    	oldX = x;
    	oldY = y;
  	//}
		
		
    frame += 1;
	//if (frame > 500000*6) frame = -frame;
  	//frame += 0.00005;
		//oldX += frame;
	}

	updatePixels();
}
"
"1140102","Green text","mySketch","// more automatic drawing by generating L-systems rules + switching rules randomly

function pal(t, a, b, c, d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

function weightedRandom(prob) {
  let i, sum=0, r=Math.random();
  for (i in prob) {
    sum += prob[i];
    if (r <= sum) return i;
  }
}

class lm {
	constructor(axiom, rules, angle, step, iter) {
		this.ax = width / 2;
		this.ay = height / 2;
		this.px = this.ax;
		this.py = this.ay;
		this.ta = angle;
		this.ca = PI;
		this.fs = step;
		this.col = [0,0,0,0];
		
		this.stack = [];
		
		this.axiom = axiom;
		this.rules = rules;
		this.itera = iter;
		
		this.rule = 0;
		
		this.cycles = 0;
		
		this.b = false;
		
		this.where = 1;
		
		this.initialize();
	}
	
	initialize() {
		let rule = this.axiom;
		for (let i = 0; i < this.itera; i++) {
			rule = this.lindenmayer(rule);
		}
		
		this.rule = rule;
	}
	
	lindenmayer(s) {
		let outputstring = '';

		for (let i = 0; i < s.length; i++) {
			let ismatch = 0;
			for (let j = 0; j < this.rules.length; j++) {
				if (s[i] == this.rules[j][0])  {
					let rule_index = 1;
					if (this.rules[j].length > 2) { // stochastic
						let probs = {};
						for (let k = 1; k < this.rules[j].length; k+=2) {
							probs[k+1] = this.rules[j][k];
						}
						rule_index = weightedRandom(probs);
					}
					outputstring += this.rules[j][rule_index];
					ismatch = 1;
					break;
				}
			}

			if (ismatch == 0) outputstring+= s[i];
		}
		
		return outputstring;
	}
	
	computeParameters(w) {
		
	}
	
	compute(cb_trigger) {
		let k = this.rule[this.where];
		if (k == 'F' || k == 'f') {
			var polx = this.fs * sin(this.ca);
			var poly = this.fs * cos(this.ca);
			let x1 = this.b ? this.px - polx : this.px + polx;
			let y1 = this.b ? this.py - poly : this.py + poly;

			if (x1 < 0 || y1 < 0 || x1 > width || y1 > height) {
				this.b = !this.b;
				this.ta = -this.ta;//random() * PI * 2;
				
				if (x1 < 0) { x1 = width; this.px = width; if (random() > 0.99995) { y1 += 1; if (y1 >= height) { y1 -= height; this.py = y1; } } }
				if (y1 < 0) { y1 = height; this.py = height; if (random() > 0.99995) { x1 += 1; if (x1 >= width) { x1 %= width; this.px = x1; } } }
				if (x1 > width) { x1 = 0; this.px = 0; }
				if (y1 > height) { y1 = 0; this.py = 0; }
			}

			this.ax = this.px;
			this.ay = this.py;
			this.px = x1;
			this.py = y1;
		} else if (k == '[') {
			this.stack.push(this.px);
			this.stack.push(this.py);
			this.stack.push(this.ca);
		} else if (k == ']') {
			this.ca = this.stack.pop();
			this.py = this.stack.pop();
			this.px = this.stack.pop();
		} else if (k == '+') {
			this.ca += this.ta;
		} else if (k == '-') {
			this.ca -= this.ta;
		}
		
		this.where++;
  	if (this.where > this.rule.length-1 || random() > 0.9995) {
			this.where = 0;
			this.cycles += 1;
			
			cb_trigger(this);
		}
		
		if (k == 'F') {
			return true;
		} else {
			return false;
		}
	}
}

var xmotion = 0;
var ymotion = 0;

let lms = [];

function getRule() {
	let len = 16 + random() * 64;
	let rule = [''];
	let stak = [];
	let last = '';
	for (let i = 0; i < len; i += 1) {
		let c = ['X', '+', '-', 'F', '[', ']']
		let chosen = c[floor((c.length-1) * random())];
		
		if (last == '' && chosen == '[') {
			chosen = c[floor((c.length-2) * random())];
		}
		
		if (chosen == '[') {
			stak.push(']');
		} else if (chosen == ']' && stak.length == 0) {
			chosen = c[floor((c.length-2) * random())];
		} else if (chosen == ']' && last == '[') {
			chosen = c[floor((c.length-2) * random())];
		}
		
		rule[0] += chosen;
		
		last = chosen;
	}
	
	while (stak.length) {
		let last = rule[0][rule[0].length - 1];
		
		if (last == '[') {
			rule[0] = rule[0].slice(0, rule[0].length - 1)
			stak.pop();	
		} else {
			rule[0] += stak.pop();	
		}
	}
	
	return rule;
}

function setup() {
  createCanvas(1280, 840);
  background(0);
	
	noiseDetail(7, 0.7);
	
	let pg = createGraphics(1280, 840);
	pg.fill(255);
	pg.textAlign(CENTER, CENTER);
	pg.textSize(192);
	pg.text(""PROCESSING"", width / 2, height / 2);
	pg.loadPixels();
	
	//colorMode(HSB, 360, 100, 100, 255);
	
	//blendMode(LIGHTEST);
	
	stroke(0, 0, 100, 255);
 // lms[0] = new lm('X', [['X', 0.5, 'XFFFF-[F-X+]FX+', 0.5, 'FFFFF[f+F]------------F'], ['F', '+F--F+']], radians(45), 1);
	let amount = 1500;
	for (let i = 0; i < amount; i += 1) {
		lms[i] = new lm('X', [['X', getRule()[0]], ['F', 'F+FF']], sin(i / amount * PI * 16)*8, 1, 3);
		//if (random() < 0.05) {
		//	lms[i].px = width / 2;
		//	lms[i].py = height / 2;
		//} else {
		let px = [0];
		while (px[0] < 128) {
			let pxx = random(0, width);
			let pyy = random(0, height);
			px = pg.get(pxx, pyy);
			lms[i].px = pxx;//width / 2 + width / 2.75 * sin(i / amount * PI * 7) * (i / 100);//random(0, width); lms[i].py = random(0, height);
			lms[i].py = pyy;//height / 2 + height / 2.75 * cos(i / amount * PI * 7) * (i / 100);
			lms[i].col = px;
		}
		//}
	}
	//lms[1] = new lm('X', [['X', 'F-[[X]+X]+F[+FX]-X'], ['F', 'FF']], radians(90), 1);
}

function change(lm) {
	let max_cycles = 1;
	noStroke();
	if (lm.cycles % max_cycles == 0) {
		lm.ta += 0.00001;
		lm.fs = random(0.125, 0.5);
		
		let rule = getRule()[0];
		
		if (rule.length < 64) {
			lm.itera = 1 + floor(random() * 4);
		} else if (rule.length < 128) {
			lm.itera = 1 + floor(random() * 3);
		} else if (rule.length < 256) {
			lm.itera = 1 + floor(random() * 2);
		} else {
			lm.itera = 1 + floor(random() * 2);
		}
		lm.cycles = 0;

		lm.rules = [['X', rule], ['F', 'FF']];
		lm.initialize();
		
		//fill(0, 0, 0, 92);
		//rect(0, 0, width, height);
	}
	
	/*
	if (lm.cycles % 16 == 0) {
		fill(0, 0, 0, 48);
		rect(0, 0, width, height);
	}
	*/
	
	let nc = (lm.cycles % 8) / 8;
	stroke(0, 0, 100, random(0, 10));
	
	//if (random() > 0.25) {
		lm.iter = 1;
		lm.initialize();
	/*} else {
		lm.iter = 2;
		lm.initialize();
	}*/
}

let pale = [""#005A04"", ""#CCFFBB"", ""#3A5F0B"", ""#005502"", ""#40a040""];
function draw() {
	for (let k = 0; k < 10; k += 1) {
		for (let i = 0; i < lms.length; i += 1) {
			let lm = lms[i];
			
			let result = lm.compute(change);
			
			if (result) {
				//stroke(k / 3 + abs(sin(xmotion/24))*180, 30, 255, 255);
			var pa1 = 1, pa2 = 1, pa3 = 1;
			var pb1 = 0.7, pb2 = 0.25, pb3 =0.5;
			var pc1 = 0.91, pc2 = 0.5, pc3 = 0.14;

			var pdr = 0.4;
			var pdg = 0.71;
			var pdb = 0.6;

				var pt = abs(sin(xmotion/k/300 + i/4));
				
				var br = pow(abs(sin(i / lms.length * PI * 2 + xmotion / 400)), 20.);
				//if (br < 0.25) br = 0;

				var rf = pal(pt, pa1, pb1, pc1, pdr) * 255*br;
				var gf = pal(pt, pa2, pb2, pc2, pdg) * 255*br;
				var bf = pal(pt, pa3, pb3, pc3, pdb) * 255*br;

				stroke(rf, gf, bf, 255);/*lm.col[0], lm.col[1], lm.col[2], 255);*///
				
				strokeWeight(1/* + abs(sin(xmotion/16+i))*8*/);
				var context = drawingContext
        context.shadowBlur = 1;
				if (br > 0.25) {
					context.shadowOffsetX = random(-1, 1);
					context.shadowOffsetY = random(-1, 1);
        	context.shadowColor = ""black"";
				} else {
      	  context.shadowOffsetX = random(0, 1);
    	    context.shadowOffsetY = random(0, 1);
					context.shadowColor = pale[i % pal.length];
				}
				line(lm.px, lm.py, lm.ax, lm.ay);
			}
		}
	}
	
	xmotion += 0.5;
	ymotion += 0.25;
}"
"1137382","Green ball","mySketch","// more automatic drawing by generating L-systems rules + switching rules randomly

function pal(t, a, b, c, d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

function weightedRandom(prob) {
  let i, sum=0, r=Math.random();
  for (i in prob) {
    sum += prob[i];
    if (r <= sum) return i;
  }
}

class lm {
	constructor(axiom, rules, angle, step, iter) {
		this.ax = width / 2;
		this.ay = height / 2;
		this.px = this.ax;
		this.py = this.ay;
		this.ta = angle;
		this.ca = PI;
		this.fs = step;
		
		this.stack = [];
		
		this.axiom = axiom;
		this.rules = rules;
		this.itera = iter;
		
		this.rule = 0;
		
		this.cycles = 0;
		
		this.b = false;
		
		this.where = 1;
		
		this.initialize();
	}
	
	initialize() {
		let rule = this.axiom;
		for (let i = 0; i < this.itera; i++) {
			rule = this.lindenmayer(rule);
		}
		
		this.rule = rule;
	}
	
	lindenmayer(s) {
		let outputstring = '';

		for (let i = 0; i < s.length; i++) {
			let ismatch = 0;
			for (let j = 0; j < this.rules.length; j++) {
				if (s[i] == this.rules[j][0])  {
					let rule_index = 1;
					if (this.rules[j].length > 2) { // stochastic
						let probs = {};
						for (let k = 1; k < this.rules[j].length; k+=2) {
							probs[k+1] = this.rules[j][k];
						}
						rule_index = weightedRandom(probs);
					}
					outputstring += this.rules[j][rule_index];
					ismatch = 1;
					break;
				}
			}

			if (ismatch == 0) outputstring+= s[i];
		}
		
		return outputstring;
	}
	
	computeParameters(w) {
		
	}
	
	compute(cb_trigger) {
		let k = this.rule[this.where];
		if (k == 'F' || k == 'f') {
			var polx = this.fs * sin(this.ca);
			var poly = this.fs * cos(this.ca);
			let x1 = this.b ? this.px - polx : this.px + polx;
			let y1 = this.b ? this.py - poly : this.py + poly;

			if (x1 < 0 || y1 < 0 || x1 > width || y1 > height) {
				this.b = !this.b;
				this.ta = -this.ta;//random() * PI * 2;
				
				if (x1 < 0) { x1 = width; this.px = width; if (random() > 0.99995) { y1 += 1; if (y1 >= height) { y1 -= height; this.py = y1; } } }
				if (y1 < 0) { y1 = height; this.py = height; if (random() > 0.99995) { x1 += 1; if (x1 >= width) { x1 %= width; this.px = x1; } } }
				if (x1 > width) { x1 = 0; this.px = 0; }
				if (y1 > height) { y1 = 0; this.py = 0; }
			}

			this.ax = this.px;
			this.ay = this.py;
			this.px = x1;
			this.py = y1;
		} else if (k == '[') {
			this.stack.push(this.px);
			this.stack.push(this.py);
			this.stack.push(this.ca);
		} else if (k == ']') {
			this.ca = this.stack.pop();
			this.py = this.stack.pop();
			this.px = this.stack.pop();
		} else if (k == '+') {
			this.ca += this.ta;
		} else if (k == '-') {
			this.ca -= this.ta;
		}
		
		this.where++;
  	if (this.where > this.rule.length-1 || random() > 0.9995) {
			this.where = 0;
			this.cycles += 1;
			
			cb_trigger(this);
		}
		
		if (k == 'F') {
			return true;
		} else {
			return false;
		}
	}
}

var xmotion = 0;
var ymotion = 0;

let lms = [];

function getRule() {
	let len = 48 + random() * 128;
	let rule = [''];
	let stak = [];
	let last = '';
	for (let i = 0; i < len; i += 1) {
		let c = ['X', '+', '-', 'F', '[', ']']
		let chosen = c[floor((c.length-1) * random())];
		
		if (last == '' && chosen == '[') {
			chosen = c[floor((c.length-2) * random())];
		}
		
		if (chosen == '[') {
			stak.push(']');
		} else if (chosen == ']' && stak.length == 0) {
			chosen = c[floor((c.length-2) * random())];
		} else if (chosen == ']' && last == '[') {
			chosen = c[floor((c.length-2) * random())];
		}
		
		rule[0] += chosen;
		
		last = chosen;
	}
	
	while (stak.length) {
		let last = rule[0][rule[0].length - 1];
		
		if (last == '[') {
			rule[0] = rule[0].slice(0, rule[0].length - 1)
			stak.pop();	
		} else {
			rule[0] += stak.pop();	
		}
	}
	
	return rule;
}

function setup() {
  createCanvas(840, 840);
  background(0);
	
	noiseDetail(7, 0.7);
	//colorMode(HSB, 360, 100, 100, 255);
	
	//blendMode(LIGHTEST);
	
	stroke(0, 0, 100, 255);
 // lms[0] = new lm('X', [['X', 0.5, 'XFFFF-[F-X+]FX+', 0.5, 'FFFFF[f+F]------------F'], ['F', '+F--F+']], radians(45), 1);
	let amount = 100;
	for (let i = 0; i < amount; i += 1) {
		lms[i] = new lm('X', [['X', getRule()[0]], ['F', 'F++++']], radians((10+360 * (((1+i) / amount)*2)-1)), 1, 4);
		//if (random() < 0.05) {
		//	lms[i].px = width / 2;
		//	lms[i].py = height / 2;
		//} else {
			lms[i].px = width / 2 + width / 2.75 * sin(i / amount * PI * 2);//random(0, width); lms[i].py = random(0, height);
			lms[i].py = height / 2 + height / 2.75 * cos(i / amount * PI * 2);
		//}
	}
	//lms[1] = new lm('X', [['X', 'F-[[X]+X]+F[+FX]-X'], ['F', 'FF']], radians(90), 1);
}

function change(lm) {
	let max_cycles = 1;
	noStroke();
	if (lm.cycles % max_cycles == 0) {
		lm.ta += 0.1;
		lm.fs = random(0.25, 2.5);
		
		let rule = getRule()[0];
		
		if (rule.length < 64) {
			lm.itera = 1 + floor(random() * 4);
		} else if (rule.length < 128) {
			lm.itera = 1 + floor(random() * 3);
		} else if (rule.length < 256) {
			lm.itera = 1 + floor(random() * 2);
		} else {
			lm.itera = 1 + floor(random() * 2);
		}
		lm.cycles = 0;

		lm.rules = [['X', rule], ['F', 'FF']];
		lm.initialize();
		
		//fill(0, 0, 0, 92);
		//rect(0, 0, width, height);
	}
	
	/*
	if (lm.cycles % 16 == 0) {
		fill(0, 0, 0, 48);
		rect(0, 0, width, height);
	}
	*/
	
	let nc = (lm.cycles % 8) / 8;
	stroke(0, 0, 100, random(0, 10));
	
	//if (random() > 0.25) {
		lm.iter = 1;
		lm.initialize();
	/*} else {
		lm.iter = 2;
		lm.initialize();
	}*/
}

let pale = [""#005A04"", ""#CCFFBB"", ""#3A5F0B"", ""#005502"", ""#40a040""];
function draw() {
	translate(width / 2, height / 2);
	scale(1-xmotion/1000, 1-xmotion/1000);
	rotate(xmotion / 1000);
	for (let k = 0; k < 50; k += 1) {
		for (let i = 0; i < lms.length; i += 1) {
			let lm = lms[i];
			
			let result = lm.compute(change);
			
			if (result) {
				//stroke(k / 3 + abs(sin(xmotion/24))*180, 30, 255, 255);
			var pa1 = 1, pa2 = 1, pa3 = 1;
			var pb1 = 0.7, pb2 = 0.25, pb3 =0.5;
			var pc1 = 0.91, pc2 = 0.5, pc3 = 0.14;

			var pdr = 0.4;
			var pdg = 0.71;
			var pdb = 0.6;

				var pt = abs(sin(xmotion/k/300 + i/4));
				
				var br = pow(abs(sin(i / lms.length * PI * 2 + xmotion / 200)), 10.);
				//if (br < 0.25) br = 0;

				var rf = pal(pt, pa1, pb1, pc1, pdr) * 255*br;
				var gf = pal(pt, pa2, pb2, pc2, pdg) * 255*br;
				var bf = pal(pt, pa3, pb3, pc3, pdb) * 255*br;

				stroke(rf, gf, bf, 255);
				
				strokeWeight(1/* + abs(sin(xmotion/16+i))*8*/);
				var context = drawingContext
        context.shadowBlur = 1;
				if (br > 0.25) {
					context.shadowOffsetX = random(-1, 1);
					context.shadowOffsetY = random(-1, 1);
        	context.shadowColor = ""black"";
				} else {
      	  context.shadowOffsetX = random(0, 1);
    	    context.shadowOffsetY = random(0, 1);
					context.shadowColor = pale[i % pal.length];
				}
				line(-width / 2 + lm.px, -width / 2 +lm.py, -width / 2 +lm.ax, -width / 2 +lm.ay);
			}
		}
	}
	
	xmotion += 0.5;
	ymotion += 0.25;
}"
"1137359","cordic 2","mySketch","// experiment with Cordic algorithm to generate something interesting in very little code
// may fit into 512b at least on Linux (256b probably even lower on Dos)

  let oldX = 0, oldY = 0, ep = 0.0000001;
	let x = 0, y = 0;
function setup() {
	createCanvas(1920/2, 1080/2);
	
	background(0);

	// colorMode(HSL, 360, 255, 255);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
	
	//oldX;
}

let frame = 0;
let index = 1;

function draw() {
	loadPixels();

	for(let iter = 0; iter < 42000; iter += 1) {
		
  	//for(let i = 0;i < width/32;i += 1) {
			// cordic
		//	index /= width * height * 4/* + frame*/;
			x = round(floor(oldX) - (oldY>>1) + (((frame>>8))));//index * oldY;
			y = round((oldY) + (x>>5) - ((frame>>16)&x));//index * x;

			index = (floor(((width >> 1) + (x>>5^(y/32)) + (frame>>24))) + floor(height - (height / 2 + (y>>4))) * width) * 4;
		  let index2 = (floor((width >> 1) + (x>>5) + (frame>>24)) + floor((height / 2 + (y>>5))) * width) * 4;
//index %= width * height * 4;
		//if (index > width * height * 4) index = 0;
		//if (index < 0) index = 0;
			
			// plot
			//pixels[index + 0] += 1;
			pixels[index + 1] += 1;
			pixels[index + 2] += 1&iter;
			pixels[index + 0] += 2;
			pixels[index2 + 1] += 1;
			pixels[index2 + 2] += 1&iter;
			pixels[index2 + 0] += 2;
			/*pixels[index + 0]%=255;
			pixels[index + 1]%=255;
			pixels[index + 2]%=255;*/
			// pixels[index + 3] = 255;

    	oldX = x;
    	oldY = y;
  	//}
		
		
    frame += 1;
	//if (frame > 500000*6) frame = -frame;
  	//frame += 0.00005;
		//oldX += frame;
	}

	updatePixels();
}
"
"1137328","Wreath 2 tight","mySketch","// more automatic drawing by generating L-systems rules + switching rules randomly

function pal(t, a, b, c, d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

function weightedRandom(prob) {
  let i, sum=0, r=Math.random();
  for (i in prob) {
    sum += prob[i];
    if (r <= sum) return i;
  }
}

class lm {
	constructor(axiom, rules, angle, step, iter) {
		this.ax = width / 2;
		this.ay = height / 2;
		this.px = this.ax;
		this.py = this.ay;
		this.ta = angle;
		this.ca = PI;
		this.fs = step;
		
		this.stack = [];
		
		this.axiom = axiom;
		this.rules = rules;
		this.itera = iter;
		
		this.rule = 0;
		
		this.cycles = 0;
		
		this.b = false;
		
		this.where = 1;
		
		this.initialize();
	}
	
	initialize() {
		let rule = this.axiom;
		for (let i = 0; i < this.itera; i++) {
			rule = this.lindenmayer(rule);
		}
		
		this.rule = rule;
	}
	
	lindenmayer(s) {
		let outputstring = '';

		for (let i = 0; i < s.length; i++) {
			let ismatch = 0;
			for (let j = 0; j < this.rules.length; j++) {
				if (s[i] == this.rules[j][0])  {
					let rule_index = 1;
					if (this.rules[j].length > 2) { // stochastic
						let probs = {};
						for (let k = 1; k < this.rules[j].length; k+=2) {
							probs[k+1] = this.rules[j][k];
						}
						rule_index = weightedRandom(probs);
					}
					outputstring += this.rules[j][rule_index];
					ismatch = 1;
					break;
				}
			}

			if (ismatch == 0) outputstring+= s[i];
		}
		
		return outputstring;
	}
	
	computeParameters(w) {
		
	}
	
	compute(cb_trigger) {
		let k = this.rule[this.where];
		if (k == 'F' || k == 'f') {
			var polx = this.fs * sin(this.ca);
			var poly = this.fs * cos(this.ca);
			let x1 = this.b ? this.px - polx : this.px + polx;
			let y1 = this.b ? this.py - poly : this.py + poly;

			if (x1 < 0 || y1 < 0 || x1 > width || y1 > height) {
				this.b = !this.b;
				this.ta = -this.ta;//random() * PI * 2;
				
				if (x1 < 0) { x1 = width; this.px = width; if (random() > 0.99995) { y1 += 1; if (y1 >= height) { y1 -= height; this.py = y1; } } }
				if (y1 < 0) { y1 = height; this.py = height; if (random() > 0.99995) { x1 += 1; if (x1 >= width) { x1 %= width; this.px = x1; } } }
				if (x1 > width) { x1 = 0; this.px = 0; }
				if (y1 > height) { y1 = 0; this.py = 0; }
			}

			this.ax = this.px;
			this.ay = this.py;
			this.px = x1;
			this.py = y1;
		} else if (k == '[') {
			this.stack.push(this.px);
			this.stack.push(this.py);
			this.stack.push(this.ca);
		} else if (k == ']') {
			this.ca = this.stack.pop();
			this.py = this.stack.pop();
			this.px = this.stack.pop();
		} else if (k == '+') {
			this.ca -= this.ta;
		} else if (k == '-') {
			this.ca -= this.ta;
		}
		
		this.where++;
  	if (this.where > this.rule.length-1 || random() > 0.9995) {
			this.where = 0;
			this.cycles += 1;
			
			cb_trigger(this);
		}
		
		if (k == 'F') {
			return true;
		} else {
			return false;
		}
	}
}

var xmotion = 0;
var ymotion = 0;

let lms = [];

function getRule() {
	let len = 12 + random() * 48;
	let rule = [''];
	let stak = [];
	let last = '';
	for (let i = 0; i < len; i += 1) {
		let c = ['X', '+', '-', 'F', '[', ']']
		let chosen = c[floor((c.length-1) * random())];
		
		if (last == '' && chosen == '[') {
			chosen = c[floor((c.length-2) * random())];
		}
		
		if (chosen == '[') {
			stak.push(']');
		} else if (chosen == ']' && stak.length == 0) {
			chosen = c[floor((c.length-2) * random())];
		} else if (chosen == ']' && last == '[') {
			chosen = c[floor((c.length-2) * random())];
		}
		
		rule[0] += chosen;
		
		last = chosen;
	}
	
	while (stak.length) {
		let last = rule[0][rule[0].length - 1];
		
		if (last == '[') {
			rule[0] = rule[0].slice(0, rule[0].length - 1)
			stak.pop();	
		} else {
			rule[0] += stak.pop();	
		}
	}
	
	return rule;
}

function setup() {
  createCanvas(800, 800);
  background(0);
	
	noiseDetail(7, 0.7);
	//colorMode(HSB, 360, 100, 100, 255);
	
	//blendMode(LIGHTEST);
	
	stroke(0, 0, 100, 255);
 // lms[0] = new lm('X', [['X', 0.5, 'XFFFF-[F-X+]FX+', 0.5, 'FFFFF[f+F]------------F'], ['F', '+F--F+']], radians(45), 1);
	let amount = 300;
	for (let i = 0; i < amount; i += 1) {
		lms[i] = new lm('X', [['X', getRule()[0]], ['F', 'F++++']], radians(1+360 * (((1+i) / amount/10)*2)-1), 1, 3);
		//if (random() < 0.05) {
		//	lms[i].px = width / 2;
		//	lms[i].py = height / 2;
		//} else {
			lms[i].px = width / 2 + width / 2.75 * sin(i / amount * PI * 20);//random(0, width); lms[i].py = random(0, height);
			lms[i].py = height / 2 + height / 2.75 * cos(i / amount * PI * 20);
		//}
	}
	//lms[1] = new lm('X', [['X', 'F-[[X]+X]+F[+FX]-X'], ['F', 'FF']], radians(90), 1);
}

function change(lm) {
	let max_cycles = 1;
	noStroke();
	if (lm.cycles % max_cycles == 0) {
		lm.ta += 0.001;
		lm.fs = random(0.25, 0.5);
		
		let rule = getRule()[0];
		
		if (rule.length < 64) {
			lm.itera = 1 + floor(random() * 4);
		} else if (rule.length < 128) {
			lm.itera = 1 + floor(random() * 3);
		} else if (rule.length < 256) {
			lm.itera = 1 + floor(random() * 2);
		} else {
			lm.itera = 1 + floor(random() * 2);
		}
		lm.cycles = 0;

		lm.rules = [['X', rule], ['F', 'FF']];
		lm.initialize();
		
		//fill(0, 0, 0, 92);
		//rect(0, 0, width, height);
	}
	
	/*
	if (lm.cycles % 16 == 0) {
		fill(0, 0, 0, 48);
		rect(0, 0, width, height);
	}
	*/
	
	let nc = (lm.cycles % 8) / 8;
	stroke(0, 0, 100, random(0, 10));
	
	//if (random() > 0.25) {
		lm.iter = 1;
		lm.initialize();
	/*} else {
		lm.iter = 2;
		lm.initialize();
	}*/
}

let pale = [""#005A04"", ""#CCFFBB"", ""#3A5F0B"", ""#005502"", ""#40a040""];
function draw() {
	for (let k = 0; k < 50; k += 1) {
		for (let i = 0; i < lms.length; i += 1) {
			let lm = lms[i];
			
			let result = lm.compute(change);
			
			if (result) {
				//stroke(k / 3 + abs(sin(xmotion/24))*180, 30, 255, 255);
			var pa1 = 1, pa2 = 1, pa3 = 1;
			var pb1 = 0.7, pb2 = 0.25, pb3 =0.5;
			var pc1 = 0.91, pc2 = 0.95, pc3 = 0.14;

			var pdr = 0.4;
			var pdg = 0.71;
			var pdb = 0.6;

				var pt = abs(sin(xmotion/k/300 + i/4));
				
				var br = pow(abs(sin(i / lms.length * PI * 2 + xmotion / 200)), 10.);
				//if (br < 0.25) br = 0;

				var rf = pal(pt, pa1, pb1, pc1, pdr) * 255*br;
				var gf = pal(pt, pa2, pb2, pc2, pdg) * 255*br;
				var bf = pal(pt, pa3, pb3, pc3, pdb) * 255*br;

				stroke(rf, gf, bf, 255);
				
				strokeWeight(1/* + abs(sin(xmotion/16+i))*8*/);
				var context = drawingContext
        context.shadowBlur = 1;
				if (br > 0.25) {
					context.shadowOffsetX = random(-1, 1);
					context.shadowOffsetY = random(-1, 1);
        	context.shadowColor = ""black"";
				} else {
      	  context.shadowOffsetX = random(0, 1);
    	    context.shadowOffsetY = random(0, 1);
					context.shadowColor = pale[i % pal.length];
				}
				line(lm.px, lm.py, lm.ax, lm.ay);
			}
		}
	}
	
	xmotion += 0.5;
	ymotion += 0.25;
}"
"1137301","Wreath 2","mySketch","// more automatic drawing by generating L-systems rules + switching rules randomly

function pal(t, a, b, c, d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

function weightedRandom(prob) {
  let i, sum=0, r=Math.random();
  for (i in prob) {
    sum += prob[i];
    if (r <= sum) return i;
  }
}

class lm {
	constructor(axiom, rules, angle, step, iter) {
		this.ax = width / 2;
		this.ay = height / 2;
		this.px = this.ax;
		this.py = this.ay;
		this.ta = angle;
		this.ca = PI;
		this.fs = step;
		
		this.stack = [];
		
		this.axiom = axiom;
		this.rules = rules;
		this.itera = iter;
		
		this.rule = 0;
		
		this.cycles = 0;
		
		this.b = false;
		
		this.where = 1;
		
		this.initialize();
	}
	
	initialize() {
		let rule = this.axiom;
		for (let i = 0; i < this.itera; i++) {
			rule = this.lindenmayer(rule);
		}
		
		this.rule = rule;
	}
	
	lindenmayer(s) {
		let outputstring = '';

		for (let i = 0; i < s.length; i++) {
			let ismatch = 0;
			for (let j = 0; j < this.rules.length; j++) {
				if (s[i] == this.rules[j][0])  {
					let rule_index = 1;
					if (this.rules[j].length > 2) { // stochastic
						let probs = {};
						for (let k = 1; k < this.rules[j].length; k+=2) {
							probs[k+1] = this.rules[j][k];
						}
						rule_index = weightedRandom(probs);
					}
					outputstring += this.rules[j][rule_index];
					ismatch = 1;
					break;
				}
			}

			if (ismatch == 0) outputstring+= s[i];
		}
		
		return outputstring;
	}
	
	computeParameters(w) {
		
	}
	
	compute(cb_trigger) {
		let k = this.rule[this.where];
		if (k == 'F' || k == 'f') {
			var polx = this.fs * sin(this.ca);
			var poly = this.fs * cos(this.ca);
			let x1 = this.b ? this.px - polx : this.px + polx;
			let y1 = this.b ? this.py - poly : this.py + poly;

			if (x1 < 0 || y1 < 0 || x1 > width || y1 > height) {
				this.b = !this.b;
				this.ta = -this.ta;//random() * PI * 2;
				
				if (x1 < 0) { x1 = width; this.px = width; if (random() > 0.99995) { y1 += 1; if (y1 >= height) { y1 -= height; this.py = y1; } } }
				if (y1 < 0) { y1 = height; this.py = height; if (random() > 0.99995) { x1 += 1; if (x1 >= width) { x1 %= width; this.px = x1; } } }
				if (x1 > width) { x1 = 0; this.px = 0; }
				if (y1 > height) { y1 = 0; this.py = 0; }
			}

			this.ax = this.px;
			this.ay = this.py;
			this.px = x1;
			this.py = y1;
		} else if (k == '[') {
			this.stack.push(this.px);
			this.stack.push(this.py);
			this.stack.push(this.ca);
		} else if (k == ']') {
			this.ca = this.stack.pop();
			this.py = this.stack.pop();
			this.px = this.stack.pop();
		} else if (k == '+') {
			this.ca += this.ta;
		} else if (k == '-') {
			this.ca -= this.ta;
		}
		
		this.where++;
  	if (this.where > this.rule.length-1 || random() > 0.9995) {
			this.where = 0;
			this.cycles += 1;
			
			cb_trigger(this);
		}
		
		if (k == 'F') {
			return true;
		} else {
			return false;
		}
	}
}

var xmotion = 0;
var ymotion = 0;

let lms = [];

function getRule() {
	let len = 12 + random() * 48;
	let rule = [''];
	let stak = [];
	let last = '';
	for (let i = 0; i < len; i += 1) {
		let c = ['X', '+', '-', 'F', '[', ']']
		let chosen = c[floor((c.length-1) * random())];
		
		if (last == '' && chosen == '[') {
			chosen = c[floor((c.length-2) * random())];
		}
		
		if (chosen == '[') {
			stak.push(']');
		} else if (chosen == ']' && stak.length == 0) {
			chosen = c[floor((c.length-2) * random())];
		} else if (chosen == ']' && last == '[') {
			chosen = c[floor((c.length-2) * random())];
		}
		
		rule[0] += chosen;
		
		last = chosen;
	}
	
	while (stak.length) {
		let last = rule[0][rule[0].length - 1];
		
		if (last == '[') {
			rule[0] = rule[0].slice(0, rule[0].length - 1)
			stak.pop();	
		} else {
			rule[0] += stak.pop();	
		}
	}
	
	return rule;
}

function setup() {
  createCanvas(800, 800);
  background(0);
	
	noiseDetail(7, 0.7);
	//colorMode(HSB, 360, 100, 100, 255);
	
	//blendMode(LIGHTEST);
	
	stroke(0, 0, 100, 255);
 // lms[0] = new lm('X', [['X', 0.5, 'XFFFF-[F-X+]FX+', 0.5, 'FFFFF[f+F]------------F'], ['F', '+F--F+']], radians(45), 1);
	let amount = 300;
	for (let i = 0; i < amount; i += 1) {
		lms[i] = new lm('X', [['X', getRule()[0]], ['F', 'F++++']], radians(1+360 * (((1+i) / amount/10)*2)-1), 1, 3);
		//if (random() < 0.05) {
		//	lms[i].px = width / 2;
		//	lms[i].py = height / 2;
		//} else {
			lms[i].px = width / 2 + width / 2.75 * sin(i / amount * PI * 20);//random(0, width); lms[i].py = random(0, height);
			lms[i].py = height / 2 + height / 2.75 * cos(i / amount * PI * 20);
		//}
	}
	//lms[1] = new lm('X', [['X', 'F-[[X]+X]+F[+FX]-X'], ['F', 'FF']], radians(90), 1);
}

function change(lm) {
	let max_cycles = 1;
	noStroke();
	if (lm.cycles % max_cycles == 0) {
		lm.ta += 0.001;
		lm.fs = random(0.25, 0.5);
		
		let rule = getRule()[0];
		
		if (rule.length < 64) {
			lm.itera = 1 + floor(random() * 4);
		} else if (rule.length < 128) {
			lm.itera = 1 + floor(random() * 3);
		} else if (rule.length < 256) {
			lm.itera = 1 + floor(random() * 2);
		} else {
			lm.itera = 1 + floor(random() * 2);
		}
		lm.cycles = 0;

		lm.rules = [['X', rule], ['F', 'FF']];
		lm.initialize();
		
		//fill(0, 0, 0, 92);
		//rect(0, 0, width, height);
	}
	
	/*
	if (lm.cycles % 16 == 0) {
		fill(0, 0, 0, 48);
		rect(0, 0, width, height);
	}
	*/
	
	let nc = (lm.cycles % 8) / 8;
	stroke(0, 0, 100, random(0, 10));
	
	//if (random() > 0.25) {
		lm.iter = 1;
		lm.initialize();
	/*} else {
		lm.iter = 2;
		lm.initialize();
	}*/
}

let pale = [""#005A04"", ""#CCFFBB"", ""#3A5F0B"", ""#005502"", ""#40a040""];
function draw() {
	for (let k = 0; k < 50; k += 1) {
		for (let i = 0; i < lms.length; i += 1) {
			let lm = lms[i];
			
			let result = lm.compute(change);
			
			if (result) {
				//stroke(k / 3 + abs(sin(xmotion/24))*180, 30, 255, 255);
			var pa1 = 1, pa2 = 1, pa3 = 1;
			var pb1 = 0.7, pb2 = 0.25, pb3 =0.5;
			var pc1 = 0.91, pc2 = 0.5, pc3 = 0.14;

			var pdr = 0.4;
			var pdg = 0.71;
			var pdb = 0.6;

				var pt = abs(sin(xmotion/k/300 + i/4));
				
				var br = pow(abs(sin(i / lms.length * PI * 2 + xmotion / 200)), 10.);
				//if (br < 0.25) br = 0;

				var rf = pal(pt, pa1, pb1, pc1, pdr) * 255*br;
				var gf = pal(pt, pa2, pb2, pc2, pdg) * 255*br;
				var bf = pal(pt, pa3, pb3, pc3, pdb) * 255*br;

				stroke(rf, gf, bf, 255);
				
				strokeWeight(1/* + abs(sin(xmotion/16+i))*8*/);
				var context = drawingContext
        context.shadowBlur = 1;
				if (br > 0.25) {
					context.shadowOffsetX = random(-1, 1);
					context.shadowOffsetY = random(-1, 1);
        	context.shadowColor = ""black"";
				} else {
      	  context.shadowOffsetX = random(0, 1);
    	    context.shadowOffsetY = random(0, 1);
					context.shadowColor = pale[i % pal.length];
				}
				line(lm.px, lm.py, lm.ax, lm.ay);
			}
		}
	}
	
	xmotion += 0.5;
	ymotion += 0.25;
}"
"1136997","Wreath","mySketch","// more automatic drawing by generating L-systems rules + switching rules randomly

function pal(t, a, b, c, d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

function weightedRandom(prob) {
  let i, sum=0, r=Math.random();
  for (i in prob) {
    sum += prob[i];
    if (r <= sum) return i;
  }
}

class lm {
	constructor(axiom, rules, angle, step, iter) {
		this.ax = width / 2;
		this.ay = height / 2;
		this.px = this.ax;
		this.py = this.ay;
		this.ta = angle;
		this.ca = PI;
		this.fs = step;
		
		this.stack = [];
		
		this.axiom = axiom;
		this.rules = rules;
		this.itera = iter;
		
		this.rule = 0;
		
		this.cycles = 0;
		
		this.b = false;
		
		this.where = 1;
		
		this.initialize();
	}
	
	initialize() {
		let rule = this.axiom;
		for (let i = 0; i < this.itera; i++) {
			rule = this.lindenmayer(rule);
		}
		
		this.rule = rule;
	}
	
	lindenmayer(s) {
		let outputstring = '';

		for (let i = 0; i < s.length; i++) {
			let ismatch = 0;
			for (let j = 0; j < this.rules.length; j++) {
				if (s[i] == this.rules[j][0])  {
					let rule_index = 1;
					if (this.rules[j].length > 2) { // stochastic
						let probs = {};
						for (let k = 1; k < this.rules[j].length; k+=2) {
							probs[k+1] = this.rules[j][k];
						}
						rule_index = weightedRandom(probs);
					}
					outputstring += this.rules[j][rule_index];
					ismatch = 1;
					break;
				}
			}

			if (ismatch == 0) outputstring+= s[i];
		}
		
		return outputstring;
	}
	
	computeParameters(w) {
		
	}
	
	compute(cb_trigger) {
		let k = this.rule[this.where];
		if (k == 'F' || k == 'f') {
			var polx = this.fs * sin(this.ca);
			var poly = this.fs * cos(this.ca);
			let x1 = this.b ? this.px - polx : this.px + polx;
			let y1 = this.b ? this.py - poly : this.py + poly;

			if (x1 < 0 || y1 < 0 || x1 > width || y1 > height) {
				this.b = !this.b;
				this.ta = -this.ta;//random() * PI * 2;
				
				if (x1 < 0) { x1 = width; this.px = width; if (random() > 0.99995) { y1 += 1; if (y1 >= height) { y1 -= height; this.py = y1; } } }
				if (y1 < 0) { y1 = height; this.py = height; if (random() > 0.99995) { x1 += 1; if (x1 >= width) { x1 %= width; this.px = x1; } } }
				if (x1 > width) { x1 = 0; this.px = 0; }
				if (y1 > height) { y1 = 0; this.py = 0; }
			}

			this.ax = this.px;
			this.ay = this.py;
			this.px = x1;
			this.py = y1;
		} else if (k == '[') {
			this.stack.push(this.px);
			this.stack.push(this.py);
			this.stack.push(this.ca);
		} else if (k == ']') {
			this.ca = this.stack.pop();
			this.py = this.stack.pop();
			this.px = this.stack.pop();
		} else if (k == '+') {
			this.ca += this.ta;
		} else if (k == '-') {
			this.ca -= this.ta;
		}
		
		this.where++;
  	if (this.where > this.rule.length-1 || random() > 0.9995) {
			this.where = 0;
			this.cycles += 1;
			
			cb_trigger(this);
		}
		
		if (k == 'F') {
			return true;
		} else {
			return false;
		}
	}
}

var xmotion = 0;
var ymotion = 0;

let lms = [];

function getRule() {
	let len = 48 + random() * 128;
	let rule = [''];
	let stak = [];
	let last = '';
	for (let i = 0; i < len; i += 1) {
		let c = ['X', '+', '-', 'F', '[', ']']
		let chosen = c[floor((c.length-1) * random())];
		
		if (last == '' && chosen == '[') {
			chosen = c[floor((c.length-2) * random())];
		}
		
		if (chosen == '[') {
			stak.push(']');
		} else if (chosen == ']' && stak.length == 0) {
			chosen = c[floor((c.length-2) * random())];
		} else if (chosen == ']' && last == '[') {
			chosen = c[floor((c.length-2) * random())];
		}
		
		rule[0] += chosen;
		
		last = chosen;
	}
	
	while (stak.length) {
		let last = rule[0][rule[0].length - 1];
		
		if (last == '[') {
			rule[0] = rule[0].slice(0, rule[0].length - 1)
			stak.pop();	
		} else {
			rule[0] += stak.pop();	
		}
	}
	
	return rule;
}

function setup() {
  createCanvas(840, 840);
  background(0);
	
	noiseDetail(7, 0.7);
	//colorMode(HSB, 360, 100, 100, 255);
	
	//blendMode(LIGHTEST);
	
	stroke(0, 0, 100, 255);
 // lms[0] = new lm('X', [['X', 0.5, 'XFFFF-[F-X+]FX+', 0.5, 'FFFFF[f+F]------------F'], ['F', '+F--F+']], radians(45), 1);
	let amount = 300;
	for (let i = 0; i < amount; i += 1) {
		lms[i] = new lm('X', [['X', getRule()[0]], ['F', 'F++++']], radians(10+360 * (((1+i) / amount)*2)-1), 1, 3);
		//if (random() < 0.05) {
		//	lms[i].px = width / 2;
		//	lms[i].py = height / 2;
		//} else {
			lms[i].px = width / 2 + width / 2.75 * sin(i / amount * PI * 20);//random(0, width); lms[i].py = random(0, height);
			lms[i].py = height / 2 + height / 2.75 * cos(i / amount * PI * 20);
		//}
	}
	//lms[1] = new lm('X', [['X', 'F-[[X]+X]+F[+FX]-X'], ['F', 'FF']], radians(90), 1);
}

function change(lm) {
	let max_cycles = 1;
	noStroke();
	if (lm.cycles % max_cycles == 0) {
		lm.ta += 0.001;
		lm.fs = random(0.25, 1.5);
		
		let rule = getRule()[0];
		
		if (rule.length < 64) {
			lm.itera = 1 + floor(random() * 4);
		} else if (rule.length < 128) {
			lm.itera = 1 + floor(random() * 3);
		} else if (rule.length < 256) {
			lm.itera = 1 + floor(random() * 2);
		} else {
			lm.itera = 1 + floor(random() * 2);
		}
		lm.cycles = 0;

		lm.rules = [['X', rule], ['F', 'FF']];
		lm.initialize();
		
		//fill(0, 0, 0, 92);
		//rect(0, 0, width, height);
	}
	
	/*
	if (lm.cycles % 16 == 0) {
		fill(0, 0, 0, 48);
		rect(0, 0, width, height);
	}
	*/
	
	let nc = (lm.cycles % 8) / 8;
	stroke(0, 0, 100, random(0, 10));
	
	//if (random() > 0.25) {
		lm.iter = 1;
		lm.initialize();
	/*} else {
		lm.iter = 2;
		lm.initialize();
	}*/
}

let pale = [""#005A04"", ""#CCFFBB"", ""#3A5F0B"", ""#005502"", ""#40a040""];
function draw() {
	for (let k = 0; k < 50; k += 1) {
		for (let i = 0; i < lms.length; i += 1) {
			let lm = lms[i];
			
			let result = lm.compute(change);
			
			if (result) {
				//stroke(k / 3 + abs(sin(xmotion/24))*180, 30, 255, 255);
			var pa1 = 1, pa2 = 1, pa3 = 1;
			var pb1 = 0.7, pb2 = 0.25, pb3 =0.5;
			var pc1 = 0.91, pc2 = 0.5, pc3 = 0.14;

			var pdr = 0.4;
			var pdg = 0.71;
			var pdb = 0.6;

				var pt = abs(sin(xmotion/k/300 + i/4));
				
				var br = pow(abs(sin(i / lms.length * PI * 2 + xmotion / 200)), 10.);
				//if (br < 0.25) br = 0;

				var rf = pal(pt, pa1, pb1, pc1, pdr) * 255*br;
				var gf = pal(pt, pa2, pb2, pc2, pdg) * 255*br;
				var bf = pal(pt, pa3, pb3, pc3, pdb) * 255*br;

				stroke(rf, gf, bf, 255);
				
				strokeWeight(1/* + abs(sin(xmotion/16+i))*8*/);
				var context = drawingContext
        context.shadowBlur = 1;
				if (br > 0.25) {
					context.shadowOffsetX = random(-1, 1);
					context.shadowOffsetY = random(-1, 1);
        	context.shadowColor = ""black"";
				} else {
      	  context.shadowOffsetX = random(0, 1);
    	    context.shadowOffsetY = random(0, 1);
					context.shadowColor = pale[i % pal.length];
				}
				line(lm.px, lm.py, lm.ax, lm.ay);
			}
		}
	}
	
	xmotion += 0.5;
	ymotion += 0.25;
}"
"1136059","ifs polar log4","mySketch","// ifs
// https://flam3.com/flame_draves.pdf

var xmotion = 0;
var ymotion = 0;

let rx = 0;
let ry = 0;
let ax = 0;
let ay = 0;

let histo = [];

function setup() {
  createCanvas(800, 800);
  background(0);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 100, 100, 1);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	rx = width /1;
	ry = height/3;
	ax = random(0, 1);
	ay = random(0, 1);
	
	for (let i = 0; i < width * height; i += 1) {
		histo[i] = 0;
	}
}

function r1(x, y) {
	return { x: x, y: y };
}

function r2(x, y) {
	return { x: (width / 2 + x / 2) , y: y };
}

function r3(x, y) {
	return { x: (width / 1 + x / 2) - y / 2, y: y };
}

function a1(x, y) {
	return { x: (1.0 - x / (PI * 1.25)), y: y / 2 - x / (PI * 1.25) };
}

function a2(x, y) {
	return { x: x * 0.25 + 0.5, y: (1.25 + y * 0.7) / 1.25 };
}

function a3(x, y) {
	return { x: x / 3 - y / 3, y: y + x * PI};
}

var r1 = [r1, r2, r3];
var a1 = [a1, a2, a3];

var iter = 0;

function draw() {
	//fill(0, 0, 0, 1);
	//rect(0, 0, width, height);
	
	let renderAtFrame = 60 * 2;
	
	if (frameCount <= renderAtFrame) {
		for (let i = 0; i < 5000; i += 1) {
			let index1 = floor(random(0, 3));
			let r = r1[index1](rx, ry);

			rx = r.x; ry = r.y;

			let index2 = floor(random(0, 3));
			let a = a1[index1](ax, ay);

			ax = a.x; ay = a.y;

			stroke(0, 0, 255, 0.05);

			if (iter > 20) {
				let x = width / 2 + rx * (sin(ax/4)); //* sqrt((ax+ax) * (ay+ay)*0.05)*2);//(sin(ax * PI * 2) * cos(ay * PI * 2));
				let y = height / 2 + ry * (cos(ay/2)); //* sqrt((ax+ax) * (ay+ay)*0.05)*2);

				let px = width / 2 - x;
				let py = height / 2 - y;

				if (x < width && x > 0 && y < height && y > 0) {
					push();
					translate(width / 2, height / 2);
					//rotate(round(iter / 100) * PI / 4);
					point(px, py);
					//translate(0, 0);
					//rotate(round(iter / 100) * PI / 20);
					//point(px, py);
					//point(x - width / 2.125, y - height / 1.25);
					let index = floor(x) + floor(y) * width;
					if (index >= 0 && index < (width * height)) {
						histo[index] += 1;
					}
					pop();
				}
			}

			iter += 1;
		}

		let cx = random(width / 4, width - width / 4);
		let cy = random(height / 4, height - height / 4);
/*
		if (frameCount % (renderAtFrame) == 0) {
		//	background(0);

			generate();

			let m = 0;
			for (let j = 0; j < width * height; j += 1) {
				let value = Math.log10(histo[j]);
				m = max(m, value);
			}

			if (m > 0) {
				for (let y = 0; y < height; y += 1) {
					for (let x = 0; x < width; x += 1) {
						let index = x + y * width;
						let value = Math.log10(histo[index]);
						let gamma = 2.2;

						if (value > 0) {
							let brightness = pow(value / (1+m), 1 / gamma);
							stroke(180 + value / m * 80, 25 + value / m * 50, brightness * 100, 1);
							let shapes = 8;
							for (let j = 0; j < shapes; j += 1) {
								let nj = j / shapes;

								push();
								//scale(nj);
								translate(width / 2, height / 2);
								//rotate(j * PI / (shapes / 2));
								point(width / 2 - x, height / 2 - y);
								//translate(width / 2, 0);
								//point(width / 2 - x, height / 2 - y);
								//point(x - width / 2.125, y - height / 1.25);
								pop();
							}
						}
					}
				}
			}
		}*/
	}
	
	xmotion += 0.01;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.00125);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.01);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"1135889","cordic","mySketch","// experiment with Cordic algorithm to generate something interesting in very little code
// may fit into 512b at least on Linux (256b probably even lower on Dos)

  let oldX = 0, oldY = 0, ep = 0.0000001;
	let x = 0, y = 0;
function setup() {
	createCanvas(1920/2, 1080/2);
	
	background(0);

	// colorMode(HSL, 360, 255, 255);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
	
	//oldX;
}

let frame = 0;
let index = 1;

function draw() {
	loadPixels();

	for(let iter = 0; iter < 42000; iter += 1) {
		
  	//for(let i = 0;i < width/32;i += 1) {
			// cordic
		//	index /= width * height * 4/* + frame*/;
			x = round(floor(oldX) - (oldY>>2) + (((frame>>8))));//index * oldY;
			y = round((oldY) + (x>>5) - ((frame>>14)&x));//index * x;

			index = (floor((width >> 1) + (x>>5) + (frame>>24)) + floor(height / 3 + (y>>4)) * width) * 4;
//index %= width * height * 4;
		//if (index > width * height * 4) index = 0;
		if (index < 0) index = 0;
			
			// plot
			//pixels[index + 0] += 1;
			pixels[index + 1] += 1;
			pixels[index + 2] += 1&iter;
			pixels[index + 0] += 2;
			/*pixels[index + 0]%=255;
			pixels[index + 1]%=255;
			pixels[index + 2]%=255;*/
			// pixels[index + 3] = 255;

    	oldX = x;
    	oldY = y;
  	//}
		
		
    frame += 0.1;
	//if (frame > 500000*6) frame = -frame;
  	//frame += 0.00005;
		//oldX += frame;
	}

	updatePixels();
}
"
"1135857","undersea int","mySketch","// experiment with Cordic algorithm to generate something interesting in very little code
// may fit into 512b at least on Linux (256b probably even lower on Dos)

  let oldX=-9933, oldY = 5579, ep = 0.0000001;
	let x = 0, y = 0;
function setup() {
	createCanvas(1920/2, 1080/2);
	
	background(0);

	// colorMode(HSL, 360, 255, 255);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
}

let frame = 0;
let index = 1;
let iter = 0;

function draw() {
	loadPixels();

	for(let i = 0; i < 65535; i += 1) {
		
  	//for(let i = 0;i < width/32;i += 1) {
			// cordic
		//	index /= width * height * 4/* + frame*/;
			x = round(floor(oldX/1.001) - (oldY>>2) + (((frame>>9) * i)>>16));//index * oldY;
			y = round((oldY) + (x>>5) - ((frame>>14)&x));//index * x;

			index = (floor((width >> 3) + (x>>5)/* + (frame>>16)*/) + floor(/*height/2 +*/ ((y>>6)-64)) * width) * 4;
//index %= width * height * 4;
		//if (index > width * height * 4) index = 0;
		if (index < 0) index = 0;
			
			// plot
			//pixels[index + 0] += 1;
			pixels[index + 1] += 1;
			pixels[index + 2] += 2;
			pixels[index + 0] += 1&i;
			pixels[index + 0]%=255;
			pixels[index + 1]%=255;
			pixels[index + 2]%=255;
			// pixels[index + 3] = 255;

    	oldX = x;
    	oldY = y;
  	//}
		

		
		
    frame += 1;
	}
	//if (frame > 500000*6) frame = -frame;
  	//frame += 0.00005;
		//oldX += frame;
//	}
	//	if (frameCount % 100 == 0) {
	//		console.log(oldX, oldY);
		
	//iter += 1;
	updatePixels();
}
"
"1135772","droplet 2","mySketch","// experiment with Cordic algorithm to generate something interesting in very little code
// may fit into 512b at least on Linux (256b probably even lower on Dos)

  let oldX = 0, oldY = 0, ep = 0.0000001;
	let x = 0, y = 0;
function setup() {
	createCanvas(1920/2, 1080/2);
	
	background(0);

	// colorMode(HSL, 360, 255, 255);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
	
	//oldX;
}

let frame = 0;
let index = 1;

function draw() {
	loadPixels();

	for(let iter = 0; iter < 42000; iter += 1) {
		
  	//for(let i = 0;i < width/32;i += 1) {
			// cordic
		//	index /= width * height * 4/* + frame*/;
			x = round(oldX - (oldY>>2) + ((frame>>6) * iter/80000));//index * oldY;
			y = round((oldY) + (x>>6) + ((frame>>12)&x));//index * x;

			index = (floor((width >> 1) + (x>>5) + (frame>>11)) + floor(height/2 + (y>>6)) * width) * 4;
//index %= width * height * 4;
		if (index > width * height * 4) index = 0;
		if (index < 0) index = 0;
			
			// plot
			//pixels[index + 0] += 1;
			pixels[index + 1] += 1;
			pixels[index + 2] += 2;
			pixels[index + 0] += 1&iter;
			/*pixels[index + 0]%=255;
			pixels[index + 1]%=255;
			pixels[index + 2]%=255;*/
			// pixels[index + 3] = 255;

    	oldX = x;
    	oldY = y;
  	//}
		
		
    frame += 0.2;
	//if (frame > 500000*6) frame = -frame;
  	//frame += 0.00005;
		//oldX += frame;
	}

	updatePixels();
}
"
"1135684","undersea","mySketch","// experiment with Cordic algorithm to generate something interesting in very little code
// may fit into 512b at least on Linux (256b probably even lower on Dos)

  let oldX = 0, oldY = 0, ep = 0.0000001;
	let x = 0, y = 0;
function setup() {
	createCanvas(1920/2, 1080/2);
	
	background(0);

	// colorMode(HSL, 360, 255, 255);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
	
	oldX = width / 2;
}

let frame = 0;
let index = 1;

function draw() {
	loadPixels();

	for(let iter = 0; iter < 42000; iter += 1) {
		
  	//for(let i = 0;i < width/32;i += 1) {
			// cordic
		//	index /= width * height * 4/* + frame*/;
			x = oldX/1.001 - oldY/3 + (frame/40 * iter/80000);//index * oldY;
			y = (oldY/1.00001) + x/64 + (frame/4000&x);//index * x;

			index = (floor(width / 4 + x/32 + frame /2000) + floor(/*height/2*/ + y/64 - iter/20000) * width) * 4;
//index %= width * height * 4;
			
			// plot
			//pixels[index + 0] += 1;
			pixels[index + 1] += 1;
			pixels[index + 2] += 2;
			pixels[index + 0] += 1&iter;
			/*pixels[index + 0]%=255;
			pixels[index + 1]%=255;
			pixels[index + 2]%=255;*/
			// pixels[index + 3] = 255;

    	oldX = x;
    	oldY = y;
  	//}
		
		
    frame += 0.2;
	//if (frame > 500000*6) frame = -frame;
  	//frame += 0.00005;
		//oldX += frame;
	}

	updatePixels();
}
"
"1135653","droplet","mySketch","// experiment with Cordic algorithm to generate something interesting in very little code
// may fit into 256b on Linux (128b probably even lower on Dos)

  let oldX = 0, oldY = 0, ep = 0.0000001;
	let x = 0, y = 0;
function setup() {
	createCanvas(1920/2, 1080/2);
	
	background(0);

	// colorMode(HSL, 360, 255, 255);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
	
	oldX = width / 2;
}

let frame = 0;
let index = 1;

function draw() {
	loadPixels();

	for(let iter = 0; iter < 42000; iter += 1) {
		
  	//for(let i = 0;i < width/32;i += 1) {
			// cordic
		//	index /= width * height * 4/* + frame*/;
			x = oldX/1.00001 - oldY/3 + (frame/100 * iter/80000);//index * oldY;
			y = (oldY/1.0001) + x/16 + (frame/4000&x);//index * x;

			index = (floor(width / 2 + x/64) + floor(height / 3 + y/64 + iter/62000) * width) * 4;
//index %= width * height * 4;
			
			// plot
			//pixels[index + 0] += 1;
			pixels[index + 1] += 1;
			pixels[index + 2] += 2;
			pixels[index + 0] += 1&iter;
			/*pixels[index + 0]%=255;
			pixels[index + 1]%=255;
			pixels[index + 2]%=255;*/
			// pixels[index + 3] = 255;

    	oldX = x;
    	oldY = y;
  	//}
		
		
    frame += 1;
	//if (frame > 500000*6) frame = -frame;
  	//frame += 0.00005;
		//oldX += frame;
	}

	updatePixels();
}
"
"1134185","ifs polar log3","mySketch","// ifs
// https://flam3.com/flame_draves.pdf

var xmotion = 0;
var ymotion = 0;

let rx = 0;
let ry = 0;
let ax = 0;
let ay = 0;

let histo = [];

function setup() {
  createCanvas(800, 800);
  background(0);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 100, 100, 1);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	rx = width /8;
	ry = height/2;
	ax = random(0, 1);
	ay = random(0, 1);
	
	for (let i = 0; i < width * height; i += 1) {
		histo[i] = 0;
	}
}

function r1(x, y) {
	return { x: x, y: y };
}

function r2(x, y) {
	return { x: (width / 2 + x / 2) , y: y };
}

function r3(x, y) {
	return { x: (width / 1 + x / 2) - y / 2, y: y };
}

function a1(x, y) {
	return { x: (1.0 - x / (PI * 1.25)), y: y / 2 - x / (PI * 1.25) };
}

function a2(x, y) {
	return { x: x * 0.25 + 0.5, y: (1.25 + y * 0.7) / 1.25 };
}

function a3(x, y) {
	return { x: x / 3 - y / 3, y: y + x * PI};
}

var r1 = [r1, r2, r3];
var a1 = [a1, a2, a3];

var iter = 0;

function draw() {
	//fill(0, 0, 0, 1);
	//rect(0, 0, width, height);
	
	let renderAtFrame = 60 * 2;
	
	if (frameCount <= renderAtFrame) {
		for (let i = 0; i < 5000; i += 1) {
			let index1 = floor(random(0, 3));
			let r = r1[index1](rx, ry);

			rx = r.x; ry = r.y;

			let index2 = floor(random(0, 3));
			let a = a1[index1](ax, ay);

			ax = a.x; ay = a.y;

			stroke(0, 0, 255, 0.05);

			if (iter > 20) {
				let x = width / 2 + rx * (sin(ax/4)); //* sqrt((ax+ax) * (ay+ay)*0.05)*2);//(sin(ax * PI * 2) * cos(ay * PI * 2));
				let y = height / 2 + ry * (cos(ay/2)); //* sqrt((ax+ax) * (ay+ay)*0.05)*2);

				let px = width / 2 - x;
				let py = height / 2 - y;

				if (x < width && x > 0 && y < height && y > 0) {
					push();
					translate(width / 2, height / 2);
					//rotate(round(iter / 100) * PI / 4);
					point(px, py);
					//translate(0, 0);
					//rotate(round(iter / 100) * PI / 20);
					//point(px, py);
					//point(x - width / 2.125, y - height / 1.25);
					let index = floor(x) + floor(y) * width;
					if (index >= 0 && index < (width * height)) {
						histo[index] += 1;
					}
					pop();
				}
			}

			iter += 1;
		}

		let cx = random(width / 4, width - width / 4);
		let cy = random(height / 4, height - height / 4);
/*
		if (frameCount % (renderAtFrame) == 0) {
		//	background(0);

			generate();

			let m = 0;
			for (let j = 0; j < width * height; j += 1) {
				let value = Math.log10(histo[j]);
				m = max(m, value);
			}

			if (m > 0) {
				for (let y = 0; y < height; y += 1) {
					for (let x = 0; x < width; x += 1) {
						let index = x + y * width;
						let value = Math.log10(histo[index]);
						let gamma = 2.2;

						if (value > 0) {
							let brightness = pow(value / (1+m), 1 / gamma);
							stroke(180 + value / m * 80, 25 + value / m * 50, brightness * 100, 1);
							let shapes = 8;
							for (let j = 0; j < shapes; j += 1) {
								let nj = j / shapes;

								push();
								//scale(nj);
								translate(width / 2, height / 2);
								//rotate(j * PI / (shapes / 2));
								point(width / 2 - x, height / 2 - y);
								//translate(width / 2, 0);
								//point(width / 2 - x, height / 2 - y);
								//point(x - width / 2.125, y - height / 1.25);
								pop();
							}
						}
					}
				}
			}
		}*/
	}
	
	xmotion += 0.01;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.00125);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.01);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"1132720","Tiny skyscraper 2","mySketch","// base code of the skyscraper may fit into 256b (even less)
let xoff, yoff;

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
	
	for (let y = 0; y < height; y += 1) {
		let ny = pow(y / height, 2);
		fill(ny * 70, random(64, 128), ny * 255, 1);
		rect(0, y, width, 1);
	}
	
	for (let y = 0; y < 256; y += 1) {
		fill(random(0, 120), random(0, 128), random(0, 255), 1);
		rect(random(0, width), random(0, height), random(1, 2), random(1, 2));
	}
	
	for (let i = 512; i > 0; i -= 1) {
		let ni = i / 512;
		fill(20 + (1-pow(ni, 4)) * 20 + random(10), 255, 128, 1 - pow(ni, 0.05));
		ellipse(width / 2, 0, (width / 3.5) * ni, (width / 3.5) * ni);
	}
}

function draw() {
	let sx = (frameCount/width+0.3);
	let sy = (frameCount/height + 0.3);
	
	let h2 = height / 2;

	for (let y = -h2; y < h2; y += 1) {
		const yy = y & h2;

		const t = yy ^ (frameCount / 800 + (sin(yy / height * PI * 1 * (frameCount / 800)) * 255));
		const brightness = 255 * sin(frameCount/6000 * PI * 2) - t % 255;
		fill(t % 360 + random(0, 64), t % 255, brightness, 1);

		rect(height / 2 + y * sy, 0+width / 2 * sx, 2, 2);
	}
	for (let y = -h2; y < h2; y += 1) {
		const yy = y & h2;

		const t = yy ^ (frameCount / 800 + (sin(yy / height * PI * 1 * (frameCount / 800)) * 255));
		const brightness = 255 * sin(frameCount/6000 * PI * 2) - t % 255;
		fill(t % 360 + random(0, 64), t % 255, brightness, 1);

		rect(height / 8 + y * sy, height / 4 +width / 2 * sx, 2, 2);
	}
	for (let y = -h2; y < h2; y += 1) {
		const yy = y & h2;

		const t = yy ^ (frameCount / 800 + (sin(yy / height * PI * 1 * (frameCount / 800)) * 255));
		const brightness = 255 * sin(frameCount/6000 * PI * 2) - t % 255;
		fill(t % 360 + random(0, 64), t % 255, brightness, 1);

		rect(width - (height / 8 + y * sy), height / 4 +width / 2 * sx, 2, 2);
	}
}
"
"1130239","Space 11","mySketch","// base code of the skyscraper may fit into 256b (even less)
let xoff, yoff;

function setup() {
	createCanvas(800, 600);
	
	background(0);

	colorMode(HSL, 360, 255, 255, 1);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
	/*
	for (let y = 0; y < height; y += 1) {
		let ny = pow(y / height, 4);
		fill(ny * 70, random(64, 128), ny * 255, 1);
		rect(0, y, width, 1);
	}
	*/
	for (let y = 0; y < height; y += 1) {
		fill(random(0, 120), random(0, 128), random(0, 255), 1);
		rect(random(0, width), y + random(0, height / 3), random(1, 2), random(1, 2));
	}
	
	for (let i = 512; i > 0; i -= 1) {
		let ni = i / 512;
		fill(20 + (1-pow(ni, 4)) * 20 + random(10), 255, 128, 1 - pow(ni, 0.25));
		ellipse(width / 2, height / 3.5, (width / 10) * ni, (width / 10) * ni);
	}
	
//	fill(0);
	//ellipse(width / 2, height / 1.0, 32, 32);
	//arc(0, 64, 64, 64, -PI/2, PI/2);
}

function draw() {
	let sx = frameCount/width;
	let sy = frameCount/height;
	
	let h2 = height *2;

	for (let y = -h2; y < h2; y += 1) {
		const yy = y;
		//const yyy = y - sin(frameCount / 100) * h2;

		const t = yy & (frameCount/2);
		const fade = sin(frameCount/1000 * PI * 2);
		const brightness = t % 192;
		fill(20 + t % 50 - random(0, 24), 128, brightness % 255, 1);
		let x = abs((frameCount) | (y/16));
		//fill((brightness ^ frameCount) % 192, (brightness & frameCount) % 192, (brightness | frameCount) % 192);
		
		rect((width / 1.75 + x + width / 2 * sx), height / 2 + y * (sy/4), 1, 1);
		rect(width - (width / 1.75 + x + width / 2 * sx), height / 2 + y * (sy/4), 1, 1);
		rect(width / 2 + y * sy, (height / 2.5 + x + height / 2 * sx), 1, 1);
		rect(width - (width / 2 + y * sy), (height / 2.5 + x + height / 2 * sx), 1, 1);
	}

}
"
"1130195","Space 10","mySketch","// base code of the skyscraper may fit into 256b (even less)
let xoff, yoff;

function setup() {
	createCanvas(800, 600);
	
	background(0);

	colorMode(HSL, 360, 255, 255, 1);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
	/*
	for (let y = 0; y < height; y += 1) {
		let ny = pow(y / height, 4);
		fill(ny * 70, random(64, 128), ny * 255, 1);
		rect(0, y, width, 1);
	}
	*/
	for (let y = 0; y < height; y += 1) {
		fill(random(0, 120), random(0, 128), random(0, 255), 1);
		rect(random(0, width), y + random(0, height / 3), random(1, 2), random(1, 2));
	}
	
	for (let i = 512; i > 0; i -= 1) {
		let ni = i / 512;
		fill(20 + (1-pow(ni, 4)) * 20 + random(10), 255, 128, 1 - pow(ni, 0.25));
		ellipse(width / 2, height / 4, (width / 8.5) * ni, (width / 8.5) * ni);
	}
	
//	fill(0);
	//ellipse(width / 2, height / 1.0, 32, 32);
	//arc(0, 64, 64, 64, -PI/2, PI/2);
}

function draw() {
	let sx = frameCount/width;
	let sy = frameCount/height;
	
	let h2 = height *2;

	for (let y = -h2; y < h2; y += 1) {
		const yy = y;

		const t = yy & (frameCount);
		const fade = sin(frameCount/1000 * PI * 2);
		const brightness = t % 192;
		fill(20 + t % 50 - random(0, 24), 128, brightness % 255, 1);
		let x = abs((frameCount) | (y/1));
		//fill((brightness ^ frameCount) % 192, (brightness & frameCount) % 192, (brightness | frameCount) % 192);
		
		rect((width / 1.25 + x + width / 2 * sx), height / 2 + y * sy, 1, 1);
		rect(width - (width / 1.25 + x + width / 2 * sx), height / 2 + y * sy, 1, 1);
		rect(width / 2 + y * sy, (height / 2 + x + height / 2 * sx), 1, 1);
		rect(width - (width / 2 + y * sy), (height / 2 + x + height / 2 * sx), 1, 1);
	}

}
"
"1130189","Space 9","mySketch","// base code of the skyscraper may fit into 256b (even less)
let xoff, yoff;

function setup() {
	createCanvas(800, 600);
	
	background(0);

	colorMode(HSL, 360, 255, 255, 1);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
	/*
	for (let y = 0; y < height; y += 1) {
		let ny = pow(y / height, 4);
		fill(ny * 70, random(64, 128), ny * 255, 1);
		rect(0, y, width, 1);
	}
	*/
	for (let y = 0; y < height; y += 1) {
		fill(random(0, 120), random(0, 128), random(0, 255), 1);
		rect(random(0, width), y + random(0, height / 3), random(1, 2), random(1, 2));
	}
	
	for (let i = 512; i > 0; i -= 1) {
		let ni = i / 512;
		fill(20 + (1-pow(ni, 4)) * 20 + random(10), 255, 128, 1 - pow(ni, 0.25));
		ellipse(width / 2, height / 4, (width / 8.5) * ni, (width / 8.5) * ni);
	}
	
//	fill(0);
	//ellipse(width / 2, height / 1.0, 32, 32);
	//arc(0, 64, 64, 64, -PI/2, PI/2);
}

function draw() {
	let sx = frameCount/width;
	let sy = frameCount/height;
	
	let h2 = height *2;

	for (let y = -h2; y < h2; y += 1) {
		const yy = y;

		const t = yy & (frameCount);
		const fade = sin(frameCount/1000 * PI * 2);
		const brightness = t % 192;
		fill(20 + t % 50 - random(0, 24), 128, brightness % 255, 1);
		let x = abs((frameCount) | (y/4));
		//fill((brightness ^ frameCount) % 192, (brightness & frameCount) % 192, (brightness | frameCount) % 192);

		rect((width / 2 + x + width / 2 * sx), height / 2 + y * sy, 1, 1);
		rect(width - (width / 2 + x + width / 2 * sx), height / 2 + y * sy, 1, 1);
		rect(width / 2 + y * sy, (height / 2 + x + height / 2 * sx), 1, 1);
		rect(width - (width / 2 + y * sy), (height / 2 + x + height / 2 * sx), 1, 1);
	}

}
"
"1130184","Space 8","mySketch","// base code of the skyscraper may fit into 256b (even less)
let xoff, yoff;

function setup() {
	createCanvas(800, 600);
	
	background(0);

	colorMode(HSL, 360, 255, 255, 1);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
	/*
	for (let y = 0; y < height; y += 1) {
		let ny = pow(y / height, 4);
		fill(ny * 70, random(64, 128), ny * 255, 1);
		rect(0, y, width, 1);
	}
	*/
	for (let y = 0; y < height; y += 1) {
		fill(random(0, 120), random(0, 128), random(0, 255), 1);
		rect(random(0, width), y + random(0, height / 3), random(1, 2), random(1, 2));
	}
	
	for (let i = 512; i > 0; i -= 1) {
		let ni = i / 512;
		fill(20 + (1-pow(ni, 4)) * 20 + random(10), 255, 128, 1 - pow(ni, 0.25));
		ellipse(width / 2, height / 4.0, (width / 3.5) * ni, (width / 3.5) * ni);
	}
	
	fill(0);
	ellipse(width / 2, height / 2.0, 32, 32);
	//arc(0, 64, 64, 64, -PI/2, PI/2);
}

function draw() {
	let sx = frameCount/width;
	let sy = frameCount/height;
	
	let h2 = height *2;

	for (let y = -h2; y < h2; y += 1) {
		const yy = y;

		const t = yy & (frameCount);
		const fade = sin(frameCount/1000 * PI * 2);
		const brightness = t % 192;
		fill(20 + t % 50 - random(0, 24), 128, brightness % 255, 1);
		let x = ((frameCount) - (y/4));
		//fill((brightness ^ frameCount) % 192, (brightness & frameCount) % 192, (brightness | frameCount) % 192);

		rect((width / 2 + x + width / 2 * sx), height / 2 + y * sy, 1, 1);
		rect(width - (width / 2 + x + width / 2 * sx), height / 2 + y * sy, 1, 1);
		//rect(width / 2 + y * sy, (height / 2 + x + height / 2 * sx), 1, 1);
		//rect(width - (width / 2 + y * sy), (height / 2 + x + height / 2 * sx), 1, 1);
	}

}
"
"1130181","Space 7 -","mySketch","// base code of the skyscraper may fit into 256b (even less)
let xoff, yoff;

function setup() {
	createCanvas(800, 600);
	
	background(0);

	colorMode(HSL, 360, 255, 255, 1);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
	/*
	for (let y = 0; y < height; y += 1) {
		let ny = pow(y / height, 4);
		fill(ny * 70, random(64, 128), ny * 255, 1);
		rect(0, y, width, 1);
	}
	*/
	for (let y = 0; y < height; y += 1) {
		fill(random(0, 120), random(0, 128), random(0, 255), 1);
		rect(random(0, width), y + random(0, height / 3), random(1, 2), random(1, 2));
	}
	
	for (let i = 512; i > 0; i -= 1) {
		let ni = i / 512;
		fill(20 + (1-pow(ni, 4)) * 20 + random(10), 255, 128, 1 - pow(ni, 0.25));
		ellipse(width / 2, height / 4.0, (width / 3.5) * ni, (width / 3.5) * ni);
	}
	
	fill(0);
	ellipse(width / 2, height / 2.0, 32, 32);
	//arc(0, 64, 64, 64, -PI/2, PI/2);
}

function draw() {
	let sx = frameCount/width;
	let sy = frameCount/height;
	
	let h2 = height ;

	for (let y = -h2; y < h2; y += 1) {
		const yy = y;

		const t = yy & (frameCount);
		const fade = sin(frameCount/1000 * PI * 2);
		const brightness = t % 192;
		fill(220 + t % 70 - random(0, 32), 0/*128*/, brightness % 255, 1);
		let x = abs((frameCount) - (y*1)) % width;
		//fill((brightness ^ frameCount) % 192, (brightness & frameCount) % 192, (brightness | frameCount) % 192);

		rect((width / 2 + x + width / 2 * sx), height / 2 + y * sy, 1, 1);
		rect(width - (width / 2 + x + width / 2 * sx), height / 2 + y * sy, 1, 1);
		rect(width / 2 + y * sy, (height / 2 + x + height / 2 * sx), 1, 1);
		rect(width - (width / 2 + y * sy), (height / 2 + x + height / 2 * sx), 1, 1);
	}

}
"
"1130172","Space 6 |","mySketch","// base code of the skyscraper may fit into 256b (even less)
let xoff, yoff;

function setup() {
	createCanvas(800, 600);
	
	background(0);

	colorMode(HSL, 360, 255, 255, 1);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
	/*
	for (let y = 0; y < height; y += 1) {
		let ny = pow(y / height, 4);
		fill(ny * 70, random(64, 128), ny * 255, 1);
		rect(0, y, width, 1);
	}
	*/
	for (let y = 0; y < height; y += 1) {
		fill(random(0, 120), random(0, 128), random(0, 255), 1);
		rect(random(0, width), y + random(0, height / 3), random(1, 2), random(1, 2));
	}
	
	for (let i = 512; i > 0; i -= 1) {
		let ni = i / 512;
		fill(20 + (1-pow(ni, 4)) * 20 + random(10), 255, 128, 1 - pow(ni, 0.25));
		ellipse(width / 2, height / 4.0, (width / 3.5) * ni, (width / 3.5) * ni);
	}
	
	fill(0);
	ellipse(width / 2, height / 2.0, 32, 32);
	//arc(0, 64, 64, 64, -PI/2, PI/2);
}

function draw() {
	let sx = frameCount/width;
	let sy = frameCount/height;
	
	let h2 = height / 2;

	for (let y = -h2; y < h2; y += 1) {
		const yy = y;

		const t = yy & (frameCount / 1);
		const fade = sin(frameCount/1000 * PI * 2);
		const brightness = t % 192;
		fill(0 + t % 70 - random(0, 32), 255 - t % 255/*128*/, brightness % 224, 1);
		let x = abs(frameCount | (y)) % width;
		//fill((brightness ^ frameCount) % 192, (brightness & frameCount) % 192, (brightness | frameCount) % 192);

		rect((width / 2 + x + width / 2 * sx), height / 2 + y * sy, 1, 1);
		rect(width - (width / 2 + x + width / 2 * sx), height / 2 + y * sy, 1, 1);
		rect(width / 2 + y * sy, (height / 2 + x + height / 2 * sx), 1, 1);
		rect(width - (width / 2 + y * sy), (height / 2 + x + height / 2 * sx), 1, 1);
	}

}
"
"1130171","Space 5 ^","mySketch","// base code of the skyscraper may fit into 256b (even less)
let xoff, yoff;

function setup() {
	createCanvas(800, 600);
	
	background(0);

	colorMode(HSL, 360, 255, 255, 1);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
	/*
	for (let y = 0; y < height; y += 1) {
		let ny = pow(y / height, 4);
		fill(ny * 70, random(64, 128), ny * 255, 1);
		rect(0, y, width, 1);
	}
	*/
	for (let y = 0; y < height; y += 1) {
		fill(random(0, 120), random(0, 128), random(0, 255), 1);
		rect(random(0, width), y + random(0, height / 3), random(1, 2), random(1, 2));
	}
	
	for (let i = 512; i > 0; i -= 1) {
		let ni = i / 512;
		fill(20 + (1-pow(ni, 4)) * 20 + random(10), 255, 128, 1 - pow(ni, 0.25));
		ellipse(width / 2, height / 4.0, (width / 3.5) * ni, (width / 3.5) * ni);
	}
	
	fill(0);
	ellipse(width / 2, height / 2.0, 32, 32);
	//arc(0, 64, 64, 64, -PI/2, PI/2);
}

function draw() {
	let sx = frameCount/width;
	let sy = frameCount/height;
	
	let h2 = height / 2;

	for (let y = -h2; y < h2; y += 1) {
		const yy = y;

		const t = yy & (frameCount / 1);
		const fade = sin(frameCount/1000 * PI * 2);
		const brightness = t % 192;
		fill(0 + t % 70 - random(0, 32), 255 - t % 255/*128*/, brightness % 224, 1);
		let x = abs(frameCount ^ (y)) % width;
		//fill((brightness ^ frameCount) % 192, (brightness & frameCount) % 192, (brightness | frameCount) % 192);

		rect((width / 2 + x + width / 2 * sx), height / 2 + y * sy, 1, 1);
		rect(width - (width / 2 + x + width / 2 * sx), height / 2 + y * sy, 1, 1);
		rect(width / 2 + y * sy, (height / 2 + x + height / 2 * sx), 1, 1);
		rect(width - (width / 2 + y * sy), (height / 2 + x + height / 2 * sx), 1, 1);
	}

}
"
"1130167","Space 4","mySketch","// base code of the skyscraper may fit into 256b (even less)
let xoff, yoff;

function setup() {
	createCanvas(800, 600);
	
	background(0);

	colorMode(HSL, 360, 255, 255, 1);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
	/*
	for (let y = 0; y < height; y += 1) {
		let ny = pow(y / height, 4);
		fill(ny * 70, random(64, 128), ny * 255, 1);
		rect(0, y, width, 1);
	}
	*/
	for (let y = 0; y < height; y += 1) {
		fill(random(0, 120), random(0, 128), random(0, 255), 1);
		rect(random(0, width), y + random(0, height / 3), random(1, 2), random(1, 2));
	}
	
	for (let i = 512; i > 0; i -= 1) {
		let ni = i / 512;
		fill(20 + (1-pow(ni, 4)) * 20 + random(10), 255, 128, 1 - pow(ni, 0.25));
		ellipse(width / 2, height / 4.0, (width / 3.5) * ni, (width / 3.5) * ni);
	}
	
	fill(0);
	ellipse(width / 2, height / 2.0, 32, 32);
	//arc(0, 64, 64, 64, -PI/2, PI/2);
}

function draw() {
	let sx = frameCount/width;
	let sy = frameCount/height;
	
	let h2 = height / 2;

	for (let y = -h2; y < h2; y += 1) {
		const yy = y;

		const t = yy & (frameCount / 1);
		const fade = sin(frameCount/1000 * PI * 2);
		const brightness = t % 192;
		fill(0 + t % 70 - random(0, 32), 255 - t % 255/*128*/, brightness % 224, 1);
		let x = (frameCount & y) % width;
		//fill((brightness ^ frameCount) % 192, (brightness & frameCount) % 192, (brightness | frameCount) % 192);

		rect((width / 2 + x + width / 2 * sx), height / 2 + y * sy, 1, 1);
		rect(width - (width / 2 + x + width / 2 * sx), height / 2 + y * sy, 1, 1);
		rect(width / 2 + y * sy, (height / 2 + x + height / 2 * sx), 1, 1);
		rect(width - (width / 2 + y * sy), (height / 2 + x + height / 2 * sx), 1, 1);
	}

}
"
"1129704","Space3","mySketch","// base code of the skyscraper may fit into 256b (even less)
let xoff, yoff;

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
	/*
	for (let y = 0; y < height; y += 1) {
		let ny = pow(y / height, 4);
		fill(ny * 70, random(64, 128), ny * 255, 1);
		rect(0, y, width, 1);
	}
	*/
	for (let y = 0; y < height; y += 1) {
		fill(random(0, 120), random(0, 128), random(0, 255), 1);
		rect(random(0, width), y + random(0, height / 3), random(1, 2), random(1, 2));
	}
	
	fill(60, 128, 255, 1);
	ellipse(width / 2, 0, 128, 128);
	//arc(0, 64, 64, 64, -PI/2, PI/2);
}

function draw() {
	let sx = frameCount/width;
	let sy = frameCount/height;
	
	let h2 = height / 2;

	for (let y = -h2; y < h2; y += 1) {
		const yy = y;

		const t = yy & (frameCount / 1);
		const fade = sin(frameCount/3000 * PI * 2);
		const brightness = t % 192;
		fill(180 + t % 360 + random(0, 48), 255 - t % 255/*128*/, brightness % 192, 1);
		let x = (frameCount & y) % width;
		//fill((brightness ^ frameCount) % 192, (brightness & frameCount) % 192, (brightness | frameCount) % 192);

		rect((x + width / 2 * sx), height / 2 + y * sy, 1, 1);
	}

}
"
"1126505","logical night sky int","mySketch","// experiment with Cordic algorithm to generate something interesting in very little code
// this one is a mistake when converting my UFO code to use integer (note: it still use floating point)
// may fit into 256b on Linux (128b probably even lower on Dos)

  let oldX = 0, oldY = 0, ep = 0.0000001;
	let x = 0, y = 0;
function setup() {
	createCanvas(1920/2, 1080/2);
	
	background(0);

	// colorMode(HSL, 360, 255, 255);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
	
	oldX = 0;
}

let frame = 0;
let index = 1;

function draw() {
	loadPixels();

	for(let iter = 0; iter < 42000; iter += 1) {
		
  	//for(let i = 0;i < width/32;i += 1) {
			// cordic
		//	index /= width * height * 4/* + frame*/;
			x = floor(oldX) - floor(oldY/2);//index * oldY;
			y = floor(oldY/1) + (x - (floor(index/1850)));//index * x;

			index = (floor((x^y)/2) + floor(y + floor(frame / 6000)) * width) * 4;
index %= width * height * 4;
			
			// plot
			//pixels[index + 0] += 1;
			pixels[index + 1] += 1;
			pixels[index + 2] += 2;
			pixels[index + 0] += 1;
			/*pixels[index + 0]%=255;
			pixels[index + 1]%=255;
			pixels[index + 2]%=255;*/
			// pixels[index + 3] = 255;

    	oldX = x;
    	oldY = y;
  	//}
		
		
    frame += 1;
  	//frame += 0.00005;
		//oldX += frame;
	}

	updatePixels();
}
"
"1126502","Looking down","mySketch","// experiment with Cordic algorithm to generate something interesting in very little code
// may fit into 256b on Linux (128b probably even lower on Dos)

  let oldX = 0, oldY = 0, ep = 0.0000001;
	let x = 0, y = 0;
function setup() {
	createCanvas(1920/2, 1080/2);
	
	background(0);

	// colorMode(HSL, 360, 255, 255);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
	
	oldX = width / 4.5;
}

let frame = 0;
let index = 1;

function draw() {
	loadPixels();

	for(let iter = 0; iter < 42000; iter += 1) {
		
  	//for(let i = 0;i < width/32;i += 1) {
			// cordic
		//	index /= width * height * 4/* + frame*/;
			x = oldX - oldY;//index * oldY;
			y = oldY + (x - (index/2100));//index * x;

			index = (floor((/*width / 2 + */x)) + floor(/*height / 2 + */y + frame / 100000) * width) * 4;
index %= width * height * 4;
			
			// plot
			//pixels[index + 0] += 1;
			pixels[index + 1] += 2;
			pixels[index + 2] += 2;
			pixels[index + 0] += 1;
		/*	pixels[index + 0]%=255;
			pixels[index + 1]%=255;
			pixels[index + 2]%=255;*/
			// pixels[index + 3] = 255;

    	oldX = x;
    	oldY = y;
  	//}
		
		
    frame += 1;
  	//frame += 0.00005;
		//oldX += frame;
	}

	updatePixels();
}
"
"1126485","logical night sky","mySketch","// experiment with Cordic algorithm to generate something interesting in very little code
// this one is a mistake when converting my UFO code to use integer (note: it still use floating point)
// may fit into 256b on Linux (128b probably even lower on Dos)

  let oldX = 0, oldY = 0, ep = 0.0000001;
	let x = 0, y = 0;
function setup() {
	createCanvas(1920/2, 1080/2);
	
	background(0);

	// colorMode(HSL, 360, 255, 255);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
	
	oldX = width / 0.5;
}

let frame = 0;
let index = 1;

function draw() {
	loadPixels();

	for(let iter = 0; iter < 42000; iter += 1) {
		
  	//for(let i = 0;i < width/32;i += 1) {
			// cordic
		//	index /= width * height * 4/* + frame*/;
			x = oldX - oldY/2;//index * oldY;
			y = oldY/2 + (x - (index/2000));//index * x;

			index = (floor((x^y)) + floor(y + frame / 100000) * width) * 4;
index %= width * height * 4;
			
			// plot
			//pixels[index + 0] += 1;
			pixels[index + 1] += 1;
			pixels[index + 2] += 2;
			pixels[index + 0] += 1;
			/*pixels[index + 0]%=255;
			pixels[index + 1]%=255;
			pixels[index + 2]%=255;*/
			// pixels[index + 3] = 255;

    	oldX = x;
    	oldY = y;
  	//}
		
		
    frame += 1;
  	//frame += 0.00005;
		//oldX += frame;
	}

	updatePixels();
}
"
"1126472","Texture","mySketch","// experiment with Cordic algorithm to generate something interesting in very little code
// may fit into 256b on Linux (128b probably even lower on Dos)

  let oldX = 0, oldY = 0, ep = 0.0000001;
	let x = 0, y = 0;
function setup() {
	createCanvas(1920/2, 1080/2);
	
	background(0);

	// colorMode(HSL, 360, 255, 255);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
	
	oldX = width / 4.5;
}

let frame = 0;
let index = 1;

function draw() {
	loadPixels();

	for(let iter = 0; iter < 42000; iter += 1) {
		
  	//for(let i = 0;i < width/32;i += 1) {
			// cordic
		//	index /= width * height * 4/* + frame*/;
			x = oldX - oldY;//index * oldY;
			y = oldY + (x - (index/2000));//index * x;

			index = (floor((width / 2 + x)) + floor(height / 2 + y + frame / 100000) * width) * 4;
index %= width * height * 4;
			
			// plot
			//pixels[index + 0] += 1;
			pixels[index + 1] += 1;
			pixels[index + 2] += 1;
			pixels[index + 0] += 1;
			pixels[index + 0]%=255;
			pixels[index + 1]%=255;
			pixels[index + 2]%=255;
			// pixels[index + 3] = 255;

    	oldX = x;
    	oldY = y;
  	//}
		
		
    frame += 1;
  	//frame += 0.00005;
		//oldX += frame;
	}

	updatePixels();
}
"
"1126431","UFO","mySketch","// experiment with Cordic algorithm to generate something interesting in very little code
// may fit into 256b on Linux (128b probably even lower on Dos)

  let oldX = 0, oldY = 0, ep = 0.0000001;
	let x = 0, y = 0;
function setup() {
	createCanvas(800, 800);
	
	background(0);

	// colorMode(HSL, 360, 255, 255);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
	
	oldX = width / 2.25;
}

let frame = 0;
let index = 1;

function draw() {
	loadPixels();

	for(let iter = 0; iter < 3200; iter += 1) {
		
  	//for(let i = 0;i < width/32;i += 1) {
			// cordic
			index /= width * height * 4 + frame;
			x = oldX - index * oldY;
			y = oldY + index * x;

			index = (round((width / 2 + x)) + round(height / 2 + y - frame) * width) * 4;
index %= width * height * 4;
			
			// plot
			//pixels[index + 0] += 1;
			pixels[index + 1] += 1;
			pixels[index + 2] += 1;
			pixels[index + 0] += 1;
			//pixels[index + 0]%=255;
			//pixels[index + 1]%=255;
			//pixels[index + 2]%=255;
			// pixels[index + 3] = 255;

    	oldX = x;
    	oldY = y;
  	//}
		
		
    
  	frame -= 0.00005;
		//oldX += frame;
	}

	updatePixels();
}
"
"1126074","Fake raycast patterns 2","mySketch","// toward smaller codesize

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
}

function draw() {
	let sx = 1 - min(1, frameCount/512);
	let sy = 1 - min(1, frameCount/512);
	
	let h2 = height / 1;

	push()
	translate(width / 2, height / 2);
//	rotate((sin(frameCount / 100)/1) * min(1, frameCount/600));
	for (let y = -h2; y < h2; y += 1) {
		//let x = 0;

		const yy = y | (h2 - frameCount);
//
		const t = yy + (frameCount & (sin(yy / height * PI * 64) * 255 * (1 - frameCount / 2000)));
		const brightness = (255 * abs(sin(frameCount/1000 * PI * 1.5)) - t % 256) * min(1.5, frameCount/600);
		fill(t % 360, 128, brightness, 1);

/*
		if (brightness < 32 || brightness > 224) {
			continue;
		}

		*/
		let yyy = y;
		let xxx = (width / 2)/* * (sin(PI/4+frameCount / 1000 * PI * 1 + yy / 1000))*/;
		
		rect(-width / 2 + width / 2 - xxx * sx, -height / 2 + height / 2 + yyy * sy, 1, 1);
		rect(-width / 2 + width / 2 + xxx * sx, -height / 2 + height / 2 + yyy * -sy, 1, 1);
		rect(-height / 2 + height / 2 + yyy * sy, -width / 2 + width / 2 + xxx * sx, 1, 1);
		rect(-height / 2 + height / 2 + yyy * -sy, -width / 2 + width / 2 - xxx * sx, 1, 1);
/*
		rect(width / 2 + (-width / 2 + x) * sx, height / 2 + y * sy, 1, 1);
		rect(width - (width / 2 + (-width / 2 + x) * sx), height / 2 + y * -sy, 1, 1);
		rect(height / 2 + y * sy, width - (width / 2 + (-width / 2 + x) * sx), 1, 1);
		rect(height / 2 + y * -sy, (width / 2 + (-width / 2 + x) * sx), 1, 1);
*/
	}
	pop();
}
"
"1126063","Fake raycast patterns","mySketch","// toward smaller codesize

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
}

function draw() {
	let sx = frameCount/512;
	let sy = frameCount/512;
	
	let h2 = height / 2;

	push()
	translate(width / 2, height / 2);
//	rotate((sin(frameCount / 100)/1) * min(1, frameCount/600));
	for (let y = -h2; y < h2; y += 1) {
		//let x = 0;

		const yy = y | (h2 - frameCount);
//
		const t = yy + (frameCount & (sin(yy / height * PI * 64) * 255 * (1 - frameCount / 2000)));
		const brightness = (255 * abs(sin(frameCount/1000 * PI * 1.5)) - t % 256) * min(1.5, frameCount/600);
		fill(t % 360, 128, brightness, 1);

/*
		if (brightness < 32 || brightness > 224) {
			continue;
		}

		*/
		let yyy = y;
		
		rect(-width / 2 + width / 2 - (width / 2) * sx, -height / 2 + height / 2 + yyy * sy, 1, 1);
		rect(-width / 2 + width / 2 + (width / 2) * sx, -height / 2 + height / 2 + yyy * -sy, 1, 1);
		rect(-height / 2 + height / 2 + yyy * sy, -width / 2 + width / 2 + width / 2 * sx, 1, 1);
		rect(-height / 2 + height / 2 + yyy * -sy, -width / 2 + width / 2 - width / 2 * sx, 1, 1);
/*
		rect(width / 2 + (-width / 2 + x) * sx, height / 2 + y * sy, 1, 1);
		rect(width - (width / 2 + (-width / 2 + x) * sx), height / 2 + y * -sy, 1, 1);
		rect(height / 2 + y * sy, width - (width / 2 + (-width / 2 + x) * sx), 1, 1);
		rect(height / 2 + y * -sy, (width / 2 + (-width / 2 + x) * sx), 1, 1);
*/
	}
	pop();
}
"
"1125095","Stone stab","mySketch","// experiment with Cordic algorithm to generate grainy textures and shades in few lines of code
// may fit into 256b on Linux but i have yet to try (128b probably on more obscure platforms like Dos)
function setup() {
	createCanvas(800, 800);
	
	background(0);

	// colorMode(HSL, 360, 255, 255);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
}

let frame = 0;

function draw() {
	loadPixels();
  let oldX = width / 2, oldY = 0, ep = 0.0001;
	for(let iter = 0; iter < 32; iter += 1) {
		let x = 0, y = 0;
  	for(let i = 0;i < 3000;i += 1) {
			// cordic
			x = oldX - ep * oldY;
			y = oldY + ep * x;

			const index = round(((x / 0.5) * (frame + y / (x / 500000)) * 0.0009) + (400 + (y ^ x / 100)) * width) * 4;

			// plot
			//pixels[index + 0] += 1;
			pixels[index + 1] += 1;
			pixels[index + 2] += 2;
			// pixels[index + 3] = 255;

    	oldX = x;
    	oldY = y;
  	}
    
  	frame += 16;
	}

	updatePixels();
}
"
"1123176","Cordic playground","mySketch","// base code of the skyscraper may fit into 256b (even less)
let xoff, yoff;

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
	

	/*
	for (let y = 0; y < height; y += 1) {
		let ny = pow(y / height, 4);
		fill(ny * 70, random(64, 128), ny * 255, 1);
		rect(0, y, width, 1);
	}
	
	for (let y = 0; y < height / 3; y += 1) {
		fill(random(0, 120), random(0, 128), random(0, 255), 1);
		rect(random(0, width), y + random(0, height / 3), random(1, 2), random(1, 2));
	}
	*/
	fill(60, 128, 255, 1);
//	ellipse(width / 2, 0, 192, 192);
	//arc(0, 64, 64, 64, -PI/2, PI/2);
}

function draw() {
	let sx = frameCount/width / 2;
	let sy = frameCount/height/2;
	
	let h2 = height/4;
/*for (let y = -h2; y < h2; y += 1) {
		const yy = y;

		const t = yy & (frameCount / 1);
		const fade = 1;//sin(frameCount/4000 * PI * 1);
		const brightness = (255 * fade - t % 255);
		fill(t, t % 255, brightness % 192, 1);

		let x = ((frameCount / 1.5) & y) % width;

		rect((x + width / 2 * sx), height / 2 + y * sy, 0.25, 0.25);
	}
*/
let sin = 0;
let cos = 8192;     // Amplitude, need not be any special value. Larger the better.
                    // I find it blows up after 0x7fffffe6 using 32 bit math.
const steps = 6487; // This number of  steps gives a full circle for the shift size used below.
	fill(0, 0, 255, 1);
for (let step = 0; step < steps; step += 1) {
    sin = sin - (cos >> 10);         // Use bigger or smaller shifts for different
    cos = cos + (sin >> 10);         // angular step sizes around the circle.
let s = sin / 8192;
	let c = cos / 8192;
	fill(abs(s * c) * 360, 128, abs(s) * 255, 1);
	rect(width / 2 + sin / 50, height / 2 + cos / 50, abs(s*c) * 8192 / 1, 1);
}
}
"
"1122275","Space 2","mySketch","// base code of the skyscraper may fit into 256b (even less)
let xoff, yoff;

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
	
	for (let y = 0; y < height; y += 1) {
		let ny = pow(y / height, 4);
		fill(ny * 70, random(64, 128), ny * 255, 1);
		rect(0, y, width, 1);
	}
	
	for (let y = 0; y < height / 3; y += 1) {
		fill(random(0, 120), random(0, 128), random(0, 255), 1);
		rect(random(0, width), y + random(0, height / 3), random(1, 2), random(1, 2));
	}
	
	fill(60, 128, 255, 1);
	ellipse(width / 2, 0, 192, 192);
	//arc(0, 64, 64, 64, -PI/2, PI/2);
}

function draw() {
	let sx = frameCount/width / 2;
	let sy = frameCount/height/2;
	
	let h2 = height / 2;

	for (let y = -h2; y < h2; y += 1) {
		const yy = y / 2;

		const t = yy & (frameCount / 1);
		const fade = sin(frameCount/4000 * PI * 1);
		const brightness = 255 - (255 * fade - t % 255);
		fill(190 + t % 240 - random(0, 16), 255 - t % 255, brightness % 192, 1);

		let x = ((frameCount / 1.5) & y) % width;

		rect((x + width / 2 * sx), height / 2 + y * sy, 1, 1);
	}

}
"
"1122198","Space","mySketch","// base code of the skyscraper may fit into 256b (even less)
let xoff, yoff;

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
	
	for (let y = 0; y < height; y += 1) {
		let ny = pow(y / height, 4);
		fill(ny * 70, random(64, 128), ny * 255, 1);
		rect(0, y, width, 1);
	}
	
	for (let y = 0; y < height / 3; y += 1) {
		fill(random(0, 120), random(0, 128), random(0, 255), 1);
		rect(random(0, width), y + random(0, height / 3), random(1, 2), random(1, 2));
	}
	
	fill(60, 128, 255, 1);
	ellipse(width / 2, 0, 192, 192);
	//arc(0, 64, 64, 64, -PI/2, PI/2);
}

function draw() {
	let sx = frameCount/width;
	let sy = frameCount/height;
	
	let h2 = height / 2;

	for (let y = -h2; y < h2; y += 1) {
		const yy = y;

		const t = yy & (frameCount / 10);
		const fade = sin(frameCount/6000 * PI * 2);
		const brightness = 255 * fade - t % 255;
		fill(180 + t % 360 + random(0, 32), 255 - t % 255, brightness % 192, 1);

		let x = (frameCount & y) % width;

		rect((x + width / 2 * sx), height / 2 + y * sy, 1, 1);
	}

}
"
"1121303","Twist 6","mySketch","// toward smaller codesize

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
}

function draw() {
	let sx = frameCount/1024;
	let sy = frameCount/1024;
	
	let h2 = height / 2;

	push()
	translate(width / 2, height / 2);

	for (let y = -h2; y < h2; y += 1) {
		//let x = 0;

		const yy = y^h2;

		const t = yy | (frameCount / 32 + (sin(yy / height * PI * 32 * max(0, 1-frameCount/450)) * 255 * (1 - frameCount / 200)));
		const brightness = 255-(255 * (sin(frameCount/1300 * PI * 1.5)) - t % 255);
		fill(120 + t % 200, t % 255, brightness, 1);
	rotate(t / 20000 * max(0,1- frameCount/800));
/*
		if (brightness < 32 || brightness > 224) {
			continue;
		}
*/
		
		let yyy = y%t;
		
		rect(-width / 2 + width / 2 - (width / 2) * sx, -height / 2 + height / 2 + yyy * sy, 1, 1);
		rect(-width / 2 + width / 2 + (width / 2) * sx, -height / 2 + height / 2 + yyy * -sy, 1, 1);
		rect(-height / 2 + height / 2 + yyy * sy, -width / 2 + width / 2 + width / 2 * sx, 1, 1);
		rect(-height / 2 + height / 2 + yyy * -sy, -width / 2 + width / 2 - width / 2 * sx, 1, 1);
/*
		rect(width / 2 + (-width / 2 + x) * sx, height / 2 + y * sy, 1, 1);
		rect(width - (width / 2 + (-width / 2 + x) * sx), height / 2 + y * -sy, 1, 1);
		rect(height / 2 + y * sy, width - (width / 2 + (-width / 2 + x) * sx), 1, 1);
		rect(height / 2 + y * -sy, (width / 2 + (-width / 2 + x) * sx), 1, 1);
*/
	}
	pop();
}
"
"1121269","Twist 5","mySketch","// toward smaller codesize

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
}

function draw() {
	let sx = frameCount/1024;
	let sy = frameCount/1024;
	
	let h2 = height / 2;

	push()
	translate(width / 2, height / 2);

	for (let y = -h2; y < h2; y += 1) {
		//let x = 0;

		const yy = y | h2;
	rotate((sin(frameCount / 10000)) * max(0,1- frameCount/800));
		const t = yy & (frameCount / 2 + (sin(yy / height * PI * 1 * max(0, 1-frameCount/450)) * 255 * (1 - frameCount / 2000)));
		const brightness = 255 - (255 * (sin(frameCount/1300 * PI * 1.5)) - t % 255);
		fill(t % 360, t % 255, brightness, 1);

/*
		if (brightness < 32 || brightness > 224) {
			continue;
		}
*/
		
		let yyy = y;
		
		rect(-width / 2 + width / 2 - (width / 2) * sx, -height / 2 + height / 2 + yyy * sy, 1, 1);
		rect(-width / 2 + width / 2 + (width / 2) * sx, -height / 2 + height / 2 + yyy * -sy, 1, 1);
		rect(-height / 2 + height / 2 + yyy * sy, -width / 2 + width / 2 + width / 2 * sx, 1, 1);
		rect(-height / 2 + height / 2 + yyy * -sy, -width / 2 + width / 2 - width / 2 * sx, 1, 1);
/*
		rect(width / 2 + (-width / 2 + x) * sx, height / 2 + y * sy, 1, 1);
		rect(width - (width / 2 + (-width / 2 + x) * sx), height / 2 + y * -sy, 1, 1);
		rect(height / 2 + y * sy, width - (width / 2 + (-width / 2 + x) * sx), 1, 1);
		rect(height / 2 + y * -sy, (width / 2 + (-width / 2 + x) * sx), 1, 1);
*/
	}
	pop();
}
"
"1121257","Twist 4","mySketch","// toward smaller codesize

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
}

function draw() {
	let sx = frameCount/1024;
	let sy = frameCount/1024;
	
	let h2 = height / 2;

	push()
	translate(width / 2, height / 2);

	for (let y = -h2; y < h2; y += 1) {
		//let x = 0;

		const yy = y | h2;
	rotate((sin(frameCount / 10000)) * (1 - min(1, frameCount/800)));
		const t = yy ^ (frameCount / 2 + (sin(yy / height * PI * 1 * max(0, 1-frameCount/450)) * 255 * (1 - frameCount / 2000)));
		const brightness = 255 - (255 * (sin(frameCount/1300 * PI * 1.5)) - t % 255);
		fill(t % 360, t % 255, brightness, 1);

/*
		if (brightness < 32 || brightness > 224) {
			continue;
		}
*/
		
		let yyy = y;
		
		rect(-width / 2 + width / 2 - (width / 2) * sx, -height / 2 + height / 2 + yyy * sy, 1, 1);
		rect(-width / 2 + width / 2 + (width / 2) * sx, -height / 2 + height / 2 + yyy * -sy, 1, 1);
		rect(-height / 2 + height / 2 + yyy * sy, -width / 2 + width / 2 + width / 2 * sx, 1, 1);
		rect(-height / 2 + height / 2 + yyy * -sy, -width / 2 + width / 2 - width / 2 * sx, 1, 1);
/*
		rect(width / 2 + (-width / 2 + x) * sx, height / 2 + y * sy, 1, 1);
		rect(width - (width / 2 + (-width / 2 + x) * sx), height / 2 + y * -sy, 1, 1);
		rect(height / 2 + y * sy, width - (width / 2 + (-width / 2 + x) * sx), 1, 1);
		rect(height / 2 + y * -sy, (width / 2 + (-width / 2 + x) * sx), 1, 1);
*/
	}
	pop();
}
"
"1121248","Twist 3","mySketch","// toward smaller codesize

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
}

function draw() {
	let sx = frameCount/1024;
	let sy = frameCount/1024;
	
	let h2 = height / 2;

	push()
	translate(width / 2, height / 2);
	rotate((sin(frameCount / 100)) * (1 - min(1, frameCount/800)));
	for (let y = -h2; y < h2; y += 1) {
		//let x = 0;

		const yy = y | h2;

		const t = yy ^ (frameCount / 16 + (sin(yy / height * PI * 64 * max(0, 1-frameCount/450)) * 255 * (1 - frameCount / 2000)));
		const brightness = (255 * (sin(frameCount/1300 * PI * 1.5)) - t % 255);
		fill(t % 360, t % 255, brightness, 1);

/*
		if (brightness < 32 || brightness > 224) {
			continue;
		}
*/
		
		let yyy = y & t;
		
		rect(-width / 2 + width / 2 - (width / 2) * sx, -height / 2 + height / 2 + yyy * sy, 1, 1);
		rect(-width / 2 + width / 2 + (width / 2) * sx, -height / 2 + height / 2 + yyy * -sy, 1, 1);
		rect(-height / 2 + height / 2 + yyy * sy, -width / 2 + width / 2 + width / 2 * sx, 1, 1);
		rect(-height / 2 + height / 2 + yyy * -sy, -width / 2 + width / 2 - width / 2 * sx, 1, 1);
/*
		rect(width / 2 + (-width / 2 + x) * sx, height / 2 + y * sy, 1, 1);
		rect(width - (width / 2 + (-width / 2 + x) * sx), height / 2 + y * -sy, 1, 1);
		rect(height / 2 + y * sy, width - (width / 2 + (-width / 2 + x) * sx), 1, 1);
		rect(height / 2 + y * -sy, (width / 2 + (-width / 2 + x) * sx), 1, 1);
*/
	}
	pop();
}
"
"1121212","Twist 2","mySketch","// toward smaller codesize

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
}

function draw() {
	let sx = frameCount/1024;
	let sy = frameCount/1024;
	
	let h2 = height / 2;

	push()
	translate(width / 2, height / 2);
	rotate((sin(frameCount / 100)) * max(0, 1-frameCount/600));
	for (let y = -h2; y < h2; y += 1) {
		//let x = 0;

		const yy = y | h2;

		const t = yy | (frameCount + (sin(yy / height * PI * 64 * max(0, 1-frameCount/450)) * 255 * (1 - frameCount / 2000)));
		const brightness = (255 * abs(sin(frameCount/2000 * PI * 1.5)) - t % 255);
		fill(t % 360, 128, brightness, 1);

/*
		if (brightness < 32 || brightness > 224) {
			continue;
		}
*/
		
		let yyy = y & t;
		
		rect(-width / 2 + width / 2 - (width / 2) * sx, -height / 2 + height / 2 + yyy * sy, 1, 1);
		rect(-width / 2 + width / 2 + (width / 2) * sx, -height / 2 + height / 2 + yyy * -sy, 1, 1);
		rect(-height / 2 + height / 2 + yyy * sy, -width / 2 + width / 2 + width / 2 * sx, 1, 1);
		rect(-height / 2 + height / 2 + yyy * -sy, -width / 2 + width / 2 - width / 2 * sx, 1, 1);
/*
		rect(width / 2 + (-width / 2 + x) * sx, height / 2 + y * sy, 1, 1);
		rect(width - (width / 2 + (-width / 2 + x) * sx), height / 2 + y * -sy, 1, 1);
		rect(height / 2 + y * sy, width - (width / 2 + (-width / 2 + x) * sx), 1, 1);
		rect(height / 2 + y * -sy, (width / 2 + (-width / 2 + x) * sx), 1, 1);
*/
	}
	pop();
}
"
"1121203","Twist 1","mySketch","// toward smaller codesize

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
}

function draw() {
	let sx = frameCount/1024;
	let sy = frameCount/1024;
	
	let h2 = height / 2;

	push()
	translate(width / 2, height / 2);
	rotate((sin(frameCount / 100)) * max(0, 1-frameCount/600));
	for (let y = -h2; y < h2; y += 1) {
		//let x = 0;

		const yy = y | h2;

		const t = yy ^ (frameCount + (sin(yy / height * PI * 32 * (frameCount / 10)) * 255 * (1 - frameCount / 2000)));
		const brightness = 255-(255 * abs(sin(frameCount/2000 * PI * 1.5)) - t % 255);
		fill(t % 360, 128, brightness, 1);

/*
		if (brightness < 32 || brightness > 224) {
			continue;
		}
*/
		
		let yyy = y & t;
		
		rect(-width / 2 + width / 2 - (width / 2) * sx, -height / 2 + height / 2 + yyy * sy, 1, 1);
		rect(-width / 2 + width / 2 + (width / 2) * sx, -height / 2 + height / 2 + yyy * -sy, 1, 1);
		rect(-height / 2 + height / 2 + yyy * sy, -width / 2 + width / 2 + width / 2 * sx, 1, 1);
		rect(-height / 2 + height / 2 + yyy * -sy, -width / 2 + width / 2 - width / 2 * sx, 1, 1);
/*
		rect(width / 2 + (-width / 2 + x) * sx, height / 2 + y * sy, 1, 1);
		rect(width - (width / 2 + (-width / 2 + x) * sx), height / 2 + y * -sy, 1, 1);
		rect(height / 2 + y * sy, width - (width / 2 + (-width / 2 + x) * sx), 1, 1);
		rect(height / 2 + y * -sy, (width / 2 + (-width / 2 + x) * sx), 1, 1);
*/
	}
	pop();
}
"
"1121101","Tiny skyscraper","mySketch","// base code of the skyscraper may fit into 256b (even less)
let xoff, yoff;

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
	
	for (let y = 0; y < height; y += 1) {
		let ny = pow(y / height, 2);
		fill(ny * 70, random(64, 128), ny * 255, 1);
		rect(0, y, width, 1);
	}
	
	for (let y = 0; y < 256; y += 1) {
		fill(random(0, 120), random(0, 128), random(0, 255), 1);
		rect(random(0, width), random(0, height), random(1, 2), random(1, 2));
	}
	
	for (let i = 512; i > 0; i -= 1) {
		let ni = i / 512;
		fill(20 + (1-pow(ni, 4)) * 20 + random(10), 255, 128, 1 - pow(ni, 0.25));
		ellipse(width / 2, 0, (width / 3.5) * ni, (width / 3.5) * ni);
	}
}

function draw() {
	let sx = frameCount/width;
	let sy = frameCount/height;
	
	let h2 = height / 2;

	for (let y = -h2; y < h2; y += 1) {
		const yy = y & h2;

		const t = yy ^ (frameCount / 800 + (sin(yy / height * PI * 1 * (frameCount / 800)) * 255));
		const brightness = 255 * sin(frameCount/6000 * PI * 2) - t % 255;
		fill(t % 360 + random(0, 64), t % 255, brightness, 1);

		rect(height / 2 + y * sy, 0+width / 2 * sx, 2, 2);
	}

}
"
"1120930","Fake raycast depth 4 transforms","mySketch","// toward smaller codesize

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
}

function draw() {
	let h2 = height / 2;

	for (let y = -h2; y < h2; y += 1) {
		//let x = 0;
let sx = frameCount/2048;
let sy = frameCount/2048;

		const yy = y + h2;

		const t = yy ^ (frameCount / 2);
		
		let yyy = y + (sin(frameCount / 2000 * PI * 2 + cos(t / width * PI * 2) * PI * 2)) * width / 8;
		let xx = ((frameCount / 1000 + t / 2) | yy) + y;

		const brightness = 255 * sin(frameCount/3000 * PI * 1.5 + xx / width * PI * 1) - t % 255;
		fill(t % 360, t % 255, brightness, 1);

		rect(width / 2 - (width / 2 + xx) * sx, height / 2 + yyy * sy, 1, 1);
		rect(width / 2 + (width / 2 + xx) * sx, height / 2 + yyy * -sy, 1, 1);
		rect(height / 2 + yyy * sy, width / 2 + (width / 2 + xx) * sx, 1, 1);
		rect(height / 2 + yyy * -sy, width / 2 - (width / 2 + xx) * sx, 1, 1);
/*
		rect(width / 2 + (-width / 2 + x) * sx, height / 2 + y * sy, 1, 1);
		rect(width - (width / 2 + (-width / 2 + x) * sx), height / 2 + y * -sy, 1, 1);
		rect(height / 2 + y * sy, width - (width / 2 + (-width / 2 + x) * sx), 1, 1);
		rect(height / 2 + y * -sy, (width / 2 + (-width / 2 + x) * sx), 1, 1);
*/
	}
}
"
"1120903","Fake raycast depth 3","mySketch","// toward smaller codesize

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
}

function draw() {
	let h2 = height / 2;

	for (let y = -h2; y < h2; y += 1) {
		//let x = 0;
let sx = frameCount/2048;
let sy = frameCount/2048;

		const yy = y + h2;

		const t = yy & (frameCount / 2);
		
		let yyy = y + (sin(frameCount / 2000 * PI * 2 + cos(t / width * PI * 2) * PI * 2)) * width / 8;
		let xx = ((frameCount / 1000 + t / 2) | yy) + y;

		const brightness = 255 * sin(frameCount/3000 * PI * 1.5 + xx / width * PI * 1) - t % 255;
		fill(70 + t % 180, 64 + t % 192, brightness, 1);

		rect(width / 2 - (width / 2 + xx) * sx, height / 2 + yyy * sy, 1, 1);
		rect(width / 2 + (width / 2 + xx) * sx, height / 2 + yyy * -sy, 1, 1);
		rect(height / 2 + yyy * sy, width / 2 + (width / 2 + xx) * sx, 1, 1);
		rect(height / 2 + yyy * -sy, width / 2 - (width / 2 + xx) * sx, 1, 1);
/*
		rect(width / 2 + (-width / 2 + x) * sx, height / 2 + y * sy, 1, 1);
		rect(width - (width / 2 + (-width / 2 + x) * sx), height / 2 + y * -sy, 1, 1);
		rect(height / 2 + y * sy, width - (width / 2 + (-width / 2 + x) * sx), 1, 1);
		rect(height / 2 + y * -sy, (width / 2 + (-width / 2 + x) * sx), 1, 1);
*/
	}
}
"
"1120854","Fake raycast depth 2","mySketch","// toward smaller codesize

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
}

function draw() {
	let h2 = height / 2;

	for (let y = -h2; y < h2; y += 1) {
		//let x = 0;
let sx = frameCount/2048;
let sy = frameCount/2048;

		const yy = y + h2;

		const t = yy ^ (frameCount / 2);
		
		let yyy = y - abs(sin(frameCount / 2000 * PI * 2)) * width / 4;
		let xx = ((frameCount / 100 + t * 2) & yy) + y;

		const brightness = 255 * sin(frameCount/3000 * PI * 1.5 + xx / width * PI * 1) - t % 255;
		fill(180 + t % 90, t % 255, brightness, 1);

		rect(width / 2 - (width / 2 + xx) * sx, height / 2 + yyy * sy, 1, 1);
		rect(width / 2 + (width / 2 + xx) * sx, height / 2 + yyy * -sy, 1, 1);
		rect(height / 2 + yyy * sy, width / 2 + (width / 2 + xx) * sx, 1, 1);
		rect(height / 2 + yyy * -sy, width / 2 - (width / 2 + xx) * sx, 1, 1);
/*
		rect(width / 2 + (-width / 2 + x) * sx, height / 2 + y * sy, 1, 1);
		rect(width - (width / 2 + (-width / 2 + x) * sx), height / 2 + y * -sy, 1, 1);
		rect(height / 2 + y * sy, width - (width / 2 + (-width / 2 + x) * sx), 1, 1);
		rect(height / 2 + y * -sy, (width / 2 + (-width / 2 + x) * sx), 1, 1);
*/
	}
}
"
"1120693","Fake raycast small origin 3","mySketch","// toward smaller codesize

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
}

function draw() {
	let sx = frameCount/1024;
	let sy = frameCount/1024;
	
	let h2 = height / 2;

	for (let y = -h2; y < h2; y += 1) {
		//let x = 0;

		const yy = y + h2;

		const t = (yy * 2) & (frameCount / 2 & (sin(yy / height * PI * 2 * (frameCount / 1000)) * 255));
		const brightness = 255 - (255 * abs(cos(frameCount/1500 * PI * 1.5)) - t % 255);
		fill(t % 360, t % 255, brightness, 1);

		/*
		if (brightness < 32 || brightness > 224) {
			continue;
		}
		*/
		const yyy = y;

		
		rect(width / 2 - width / 2 * sx, height / 2 + yyy * sy, 1, 1);
		rect(width / 2 + width / 2 * sx, height / 2 + yyy * -sy, 1, 1);
		rect(height / 2 + yyy * sy, width / 2 + width / 2 * sx, 1, 1);
		rect(height / 2 + yyy * -sy, width / 2 - width / 2 * sx, 1, 1);
/*
		rect(width / 2 + (-width / 2 + x) * sx, height / 2 + y * sy, 1, 1);
		rect(width - (width / 2 + (-width / 2 + x) * sx), height / 2 + y * -sy, 1, 1);
		rect(height / 2 + y * sy, width - (width / 2 + (-width / 2 + x) * sx), 1, 1);
		rect(height / 2 + y * -sy, (width / 2 + (-width / 2 + x) * sx), 1, 1);
*/
	}
}
"
"1120585","Fake raycast small origin","mySketch","// toward smaller codesize

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
}

function draw() {
	let sx = frameCount/1024;
	let sy = frameCount/1024;
	
	let h2 = height / 2;

	for (let y = -h2; y < h2; y += 1) {
		//let x = 0;

		const yy = y + h2;

		const t = yy ^ frameCount;
		const brightness = 255 * sin(frameCount/2000 * PI * 1.5) - t % 255;
		fill(t % 360, t % 255, brightness, 1);

		
		if (brightness < 32 || brightness > 224) {
			continue;
		}

		
		rect(width / 2 - width / 2 * sx, height / 2 + y * sy, 1, 1);
		rect(width / 2 + width / 2 * sx, height / 2 + y * -sy, 1, 1);
		rect(height / 2 + y * sy, width / 2 + width / 2 * sx, 1, 1);
		rect(height / 2 + y * -sy, width / 2 - width / 2 * sx, 1, 1);
/*
		rect(width / 2 + (-width / 2 + x) * sx, height / 2 + y * sy, 1, 1);
		rect(width - (width / 2 + (-width / 2 + x) * sx), height / 2 + y * -sy, 1, 1);
		rect(height / 2 + y * sy, width - (width / 2 + (-width / 2 + x) * sx), 1, 1);
		rect(height / 2 + y * -sy, (width / 2 + (-width / 2 + x) * sx), 1, 1);
*/
	}
}
"
"1120568","Fake raycast small smeared","mySketch","// toward smaller codesize

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
}

function draw() {
	let sx = frameCount/1024;
	let sy = frameCount/1024;
	
	let h2 = height / 2;

	for (let y = -h2; y < h2; y += 1) {
		//let x = 0;

		const yy = y + h2;

		const t = yy ^ (frameCount & (sin(yy / height * PI * 2 * (frameCount / 1000)) * 255));
		const brightness = 255 * sin(frameCount/2000 * PI * 1.5) - t % 255;
		fill(t % 360, t % 255, brightness, 1);

		
		if (brightness < 32 || brightness > 224) {
			continue;
		}

		
		rect(width / 2 - width / 2 * sx, height / 2 + y * sy, 1, 1);
		rect(width / 2 + width / 2 * sx, height / 2 + y * -sy, 1, 1);
		rect(height / 2 + y * sy, width / 2 + width / 2 * sx, 1, 1);
		rect(height / 2 + y * -sy, width / 2 - width / 2 * sx, 1, 1);
/*
		rect(width / 2 + (-width / 2 + x) * sx, height / 2 + y * sy, 1, 1);
		rect(width - (width / 2 + (-width / 2 + x) * sx), height / 2 + y * -sy, 1, 1);
		rect(height / 2 + y * sy, width - (width / 2 + (-width / 2 + x) * sx), 1, 1);
		rect(height / 2 + y * -sy, (width / 2 + (-width / 2 + x) * sx), 1, 1);
*/
	}
}
"
"1120549","Fake raycast small bars","mySketch","// toward smaller codesize

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
}

function draw() {
	let sx = frameCount/1024;
	let sy = frameCount/1024;
	
	let h2 = height / 2;

	for (let y = -h2; y < h2; y += 1) {
		//let x = 0;

		const yy = y + h2;

		const t = yy | (frameCount ^ (sin(yy / height * PI * 1 * (frameCount / 100)) * 255));
		const brightness = 255 * sin(frameCount/2000 * PI * 1.5) - t % 255;
		fill(t % 360, t % 255, brightness, 1);

/*
		if (brightness < 32 || brightness > 224) {
			continue;
		}
*/
		
		rect(width / 2 - width / 2 * sx, height / 2 + y * sy, 1, 1);
		rect(width / 2 + width / 2 * sx, height / 2 + y * -sy, 1, 1);
		rect(height / 2 + y * sy, width / 2 + width / 2 * sx, 1, 1);
		rect(height / 2 + y * -sy, width / 2 - width / 2 * sx, 1, 1);
/*
		rect(width / 2 + (-width / 2 + x) * sx, height / 2 + y * sy, 1, 1);
		rect(width - (width / 2 + (-width / 2 + x) * sx), height / 2 + y * -sy, 1, 1);
		rect(height / 2 + y * sy, width - (width / 2 + (-width / 2 + x) * sx), 1, 1);
		rect(height / 2 + y * -sy, (width / 2 + (-width / 2 + x) * sx), 1, 1);
*/
	}
}
"
"1120534","Fake raycast small | 2","mySketch","// toward smaller codesize

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
}

function draw() {
	let sx = frameCount/1024;
	let sy = frameCount/1024;
	
	let h2 = height / 2;

	for (let y = -h2; y < h2; y += 1) {
		//let x = 0;

		const yy = y + h2;

		const t = yy | (frameCount & (sin(yy / height * PI * 8 * (frameCount / 1000)) * 255));
		const brightness = 255 * sin(frameCount/2000 * PI * 1.5) - t % 255;
		fill(t % 360, t % 255, brightness, 1);

/*
		if (brightness < 32 || brightness > 224) {
			continue;
		}
*/
		
		rect(width / 2 - width / 2 * sx, height / 2 + y * sy, 1, 1);
		rect(width / 2 + width / 2 * sx, height / 2 + y * -sy, 1, 1);
		rect(height / 2 + y * sy, width / 2 + width / 2 * sx, 1, 1);
		rect(height / 2 + y * -sy, width / 2 - width / 2 * sx, 1, 1);
/*
		rect(width / 2 + (-width / 2 + x) * sx, height / 2 + y * sy, 1, 1);
		rect(width - (width / 2 + (-width / 2 + x) * sx), height / 2 + y * -sy, 1, 1);
		rect(height / 2 + y * sy, width - (width / 2 + (-width / 2 + x) * sx), 1, 1);
		rect(height / 2 + y * -sy, (width / 2 + (-width / 2 + x) * sx), 1, 1);
*/
	}
}
"
"1120526","Fake raycast small ^","mySketch","// toward smaller codesize

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
}

function draw() {
	let sx = frameCount/1024;
	let sy = frameCount/1024;
	
	let h2 = height / 2;

	for (let y = -h2; y < h2; y += 1) {
		//let x = 0;

		const yy = y + h2;

		const t = yy ^ (frameCount + sin(yy / height * PI * 4 * (frameCount / 1000)) * 255);
		const brightness = 255 * sin(frameCount/2000 * PI * 1.5) - t % 255;
		fill(t % 360, t % 255, brightness, 1);

/*
		if (brightness < 32 || brightness > 224) {
			continue;
		}
*/
		
		rect(width / 2 - width / 2 * sx, height / 2 + y * sy, 1, 1);
		rect(width / 2 + width / 2 * sx, height / 2 + y * -sy, 1, 1);
		rect(height / 2 + y * sy, width / 2 + width / 2 * sx, 1, 1);
		rect(height / 2 + y * -sy, width / 2 - width / 2 * sx, 1, 1);
/*
		rect(width / 2 + (-width / 2 + x) * sx, height / 2 + y * sy, 1, 1);
		rect(width - (width / 2 + (-width / 2 + x) * sx), height / 2 + y * -sy, 1, 1);
		rect(height / 2 + y * sy, width - (width / 2 + (-width / 2 + x) * sx), 1, 1);
		rect(height / 2 + y * -sy, (width / 2 + (-width / 2 + x) * sx), 1, 1);
*/
	}
}
"
"1120522","Fake raycast small &","mySketch","// toward smaller codesize

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
}

function draw() {
	let sx = frameCount/1024;
	let sy = frameCount/1024;
	
	let h2 = height / 2;

	for (let y = -h2; y < h2; y += 1) {
		//let x = 0;

		const yy = y + h2;

		const t = yy & (frameCount + sin(yy / height * PI * 4 * (frameCount / 1000)) * 255);
		const brightness = 255 * sin(frameCount/2000 * PI * 1.5) - t % 255;
		fill(t % 360, t % 255, brightness, 1);

/*
		if (brightness < 32 || brightness > 224) {
			continue;
		}
*/
		
		rect(width / 2 - width / 2 * sx, height / 2 + y * sy, 1, 1);
		rect(width / 2 + width / 2 * sx, height / 2 + y * -sy, 1, 1);
		rect(height / 2 + y * sy, width / 2 + width / 2 * sx, 1, 1);
		rect(height / 2 + y * -sy, width / 2 - width / 2 * sx, 1, 1);
/*
		rect(width / 2 + (-width / 2 + x) * sx, height / 2 + y * sy, 1, 1);
		rect(width - (width / 2 + (-width / 2 + x) * sx), height / 2 + y * -sy, 1, 1);
		rect(height / 2 + y * sy, width - (width / 2 + (-width / 2 + x) * sx), 1, 1);
		rect(height / 2 + y * -sy, (width / 2 + (-width / 2 + x) * sx), 1, 1);
*/
	}
}
"
"1120519","Fake raycast small","mySketch","// toward smaller codesize

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
}

function draw() {
	let sx = frameCount/1024;
	let sy = frameCount/1024;
	
	let h2 = height / 2;

	for (let y = -h2; y < h2; y += 1) {
		//let x = 0;

		const yy = y + h2;

		const t = yy | (frameCount + sin(yy / height * PI * 4 * (frameCount / 1000)) * 255);
		const brightness = 255 * sin(frameCount/2000 * PI * 1.5) - t % 255;
		fill(t % 360, t % 255, brightness, 1);

/*
		if (brightness < 32 || brightness > 224) {
			continue;
		}
*/
		
		rect(width / 2 - width / 2 * sx, height / 2 + y * sy, 1, 1);
		rect(width / 2 + width / 2 * sx, height / 2 + y * -sy, 1, 1);
		rect(height / 2 + y * sy, width / 2 + width / 2 * sx, 1, 1);
		rect(height / 2 + y * -sy, width / 2 - width / 2 * sx, 1, 1);
/*
		rect(width / 2 + (-width / 2 + x) * sx, height / 2 + y * sy, 1, 1);
		rect(width - (width / 2 + (-width / 2 + x) * sx), height / 2 + y * -sy, 1, 1);
		rect(height / 2 + y * sy, width - (width / 2 + (-width / 2 + x) * sx), 1, 1);
		rect(height / 2 + y * -sy, (width / 2 + (-width / 2 + x) * sx), 1, 1);
*/
	}
}
"
"1116869","Fake raycast rt 6 psyche","mySketch","// fake raycast ry with heavy twisting

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
	
	//rectMode(CENTER);
}

let zmotion = 0;


function draw() {
	background(0);
	noStroke();
	fill(0, 0, 0, 0.05);
	rect(0, 0, width, height);
let xmotion = 0;
let ymotion = 0;
	
	for (let i = 0; i < 100; i += 1) {
		let ni = i / 100;

		// the blocks resolution (lower = better)
		let sw = 20;
		let sh = 20;

		let xp_offset = 0;
		let yp_offset = 0;

		let w = width;
		let h = height;

		let sf = 0.5 * sin(ni * PI * 2.25 + zmotion / 100);

		let sx = sf + xmotion/64;
		let sy = sf + xmotion/64;

		let mw = w - sw;
		let mh = h - sh;
		
		push();
		translate(width / 2, height / 2);
		rotate((sin(xmotion / 32)/8) * ni + zmotion / 500 + cos(zmotion / 200));
		for (let x = 0; x < w/2; x += sh) {
			let nx = x / (w/2);
			
			let anx = abs(0.5 - nx) * 2;
			let smx = (sin(xmotion / 50 + zmotion / 100 + anx * PI * 2)) * anx * width / 2;
			let smy = (cos(xmotion / 50 + zmotion / 100 + ni * PI * 0.5 + nx * PI * 2)) * (width / 2 * sin(zmotion / 100));
			
			let brightness = 0;
						brightness = 128+255 * abs(sin(zmotion / 1000 + ni * PI * 1) * nx) - (x ^ (i * 16 + frameCount * 16)) % 255;
						fill((zmotion + (x + frameCount) | (i / 2 + frameCount * 2)) % 360, 128,
								 brightness, 1);
			
			let vw = sw * sx * (1-ni);
			let vh = sh * sy * (1-ni);
			
			let xx = x;
			if (x <= 0) {
				xx += smx;
			}
			
			if (brightness < 1) {
				continue;
			}
			
			let yy = 0 + smy;
			
			rect(-width / 2 + width / 2 + (-width / 2 + xx) * sx, -height / 2 + height / 2 + (-height / 2 + yy) * sy, vw, vh);
			rect(-width / 2 + width - (width / 2 + (-width / 2 + xx) * sx), -height / 2 + height / 2 + (-height / 2 + yy) * sy, vw, vh);
			rect(-width / 2 + width / 2 + (-width / 2 + xx) * sx, -height / 2 + height - (height / 2 + (-height / 2 + yy) * sy), vw, vh);
			rect(-width / 2 + width - (width / 2 + (-width / 2 + xx) * sx), -height / 2 + height - (height / 2 + (-height / 2 + yy) * sy), vw, vh);
			
			rect(-height / 2 + height / 2 + (-height / 2 + yy) * sy, -width / 2 + width / 2 + (-width / 2 + xx) * sx, vw, vh);
			rect(-height / 2 + height / 2 + (-height / 2 + yy) * sy, -width / 2 + width - (width / 2 + (-width / 2 + xx) * sx), vw, vh);
			rect(-height / 2 + height - (height / 2 + (-height / 2 + yy) * sy), -width / 2 + width / 2 + (-width / 2 + xx) * sx, vw, vh);
			rect(-height / 2 + height - (height / 2 + (-height / 2 + yy) * sy), -width / 2 + width - (width / 2 + (-width / 2 + xx) * sx), vw, vh);
		}
		pop();
	/*
		for (let y = 0; y < h; y += sw) {
			for (let x = 0; x < w / 2; x += sh) {
				if (x <= 0 || x >= w / 2 || y <= 0 || y >= mh) { // checkerboard pattern
					let nx = x / w;
					let ny = y / h;

					let anx = abs(0.5 - nx) * 2;
					let any = abs(0.5 - ny) * 2;

					// surface modulation
					let smx = (sin(ymotion / 2 * max(0, 1 - pow(0.5 + i/600, 0.25)))) * 100 * anx * max(0, 1-i/1000) + 50 * (1- any);
					let smy = (sin(ymotion / 8 * max(0, 1 - i/400))) * 100 * anx * max(0, 1-i/400);

					// shading of the 'surfaces'
					let brightness = 0;
					if (x <= 0 ) {
						// due to symmetry there is only one real 'side'
						brightness = 255 * sin(i/1000 * PI * 2) - (y & (x + i / 3 + zmotion)) % 128 * abs(smx / 16 + 0.5);
						fill(140 + 40 * (1 - ny) + random(0, 32) + (y ^ (x + i / 4)) % 40, 32 + random(0, 64),
								 brightness, 1 * pow(any * (1- any), 0.1));
					} else if (y<= 0) {
						brightness = 255 * sin(pow(i/1000, 1.1) * PI * 2) - (x ^ (y + i * 2)) % 128 * pow(anx, 4);
						fill(140 + random(0, 32) + (x ^ (y + i * 4)) % 40, 32 + random(0, 32),
								 brightness, 1);
					} else {
						brightness = 255 * sin(pow(i/1000, 1.1) * PI * 2) - (x ^ (y + i * 2)) % 128 * pow(anx, 4);
						fill(140 + random(0, 32) + (x ^ (y + i * 4)) % 40, 32 + random(0, 32),
								 brightness, 1);
					}
					//
					
					//if (brightness < 1) {
					//	continue;
					//}
					
					let vw = sw * sx;
					let vh = sh * sy;

					let xx = x;
					if (x <= 0) {
						xx += smx;
					}

					let yy = y + smy;
*/
					//if (y > 0) {
//						rect(/*-width / 2 +*/ width / 2 + (-width / 2 + xx) * sx, /*-height / 2 + */height / 2 + (-height / 2 + yy) * sy, vw, vh);
//						rect(/*-width / 2 +*/ width - (width / 2 + (-width / 2 + xx) * sx + vw), /*-height / 2 + */height / 2 + (-height / 2 + yy) * sy, vw, vh);
					//}
			//	}
		//	}
		
	//	}
		//pop();
		
		xmotion += 0.5;
		ymotion += 0.5;
	}
	
	zmotion += 4.5;
}
"
"1116802","Fake raycast rt 5","mySketch","// fake raycast ry with heavy twisting

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
	
	rectMode(CENTER);
	//draw_sky();
}

let zmotion = 0;


function draw() {
	background(0);
	noStroke();
	fill(0, 0, 0, 0.05);
	rect(0, 0, width, height);
let xmotion = 0;
let ymotion = 0;
	
	for (let i = 0; i < 100; i += 1) {
		let ni = i / 100;

		// the blocks resolution (lower = better)
		let sw = 20;
		let sh = 20;

		let xp_offset = 0;
		let yp_offset = 0;

		let w = width;
		let h = height;

		let sf = 0.25;

		let sx = sf + xmotion/64;
		let sy = sf + xmotion/64;

		let mw = w - sw;
		let mh = h - sh;
		
		push();
		translate(width / 2, height / 2);
		rotate((sin(xmotion / 32)/8) * ni + zmotion / 500 + cos(zmotion / 200));
		for (let x = 0; x < w/2; x += sh) {
			let nx = x / (w/2);
			
			let anx = abs(0.5 - nx) * 2;
			let smx = (sin(xmotion / 50 + zmotion / 100 + anx * PI * 2)) * anx * width / 2;
			let smy = (cos(xmotion / 50 + zmotion / 100 + ni * PI * 0.25 + nx * PI * 8.0)) * (nx * ni) * (width / 2);
			
			let brightness = 0;
						brightness = 128+255 * abs(sin(zmotion / 1000 + ni * PI * 1) * nx) - (x | (i * 1 + frameCount * 1)) % 255;
						fill(224+((x + frameCount) | (i / 2 + frameCount * 2)) % 64, 128,
								 brightness, 1);
			
			let vw = sw * sx * (abs(0.5-ni)*2) * nx;
			let vh = sh * sy * (abs(0.5-ni)*2) * nx;
			
			let xx = x;
			if (x <= 0) {
				xx += smx;
			}
			
			if (brightness < 1) {
				continue;
			}
			
			let yy = 0 + smy;
			
			rect(-width / 2 + width / 2 + (-width / 2 + xx) * sx, -height / 2 + height / 2 + (-height / 2 + yy) * sy, vw, vh);
			rect(-width / 2 + width - (width / 2 + (-width / 2 + xx) * sx), -height / 2 + height / 2 + (-height / 2 + yy) * sy, vw, vh);
			rect(-width / 2 + width / 2 + (-width / 2 + xx) * sx, -height / 2 + height - (height / 2 + (-height / 2 + yy) * sy), vw, vh);
			rect(-width / 2 + width - (width / 2 + (-width / 2 + xx) * sx), -height / 2 + height - (height / 2 + (-height / 2 + yy) * sy), vw, vh);
			
			rect(-height / 2 + height / 2 + (-height / 2 + yy) * sy, -width / 2 + width / 2 + (-width / 2 + xx) * sx, vw, vh);
			rect(-height / 2 + height / 2 + (-height / 2 + yy) * sy, -width / 2 + width - (width / 2 + (-width / 2 + xx) * sx), vw, vh);
			rect(-height / 2 + height - (height / 2 + (-height / 2 + yy) * sy), -width / 2 + width / 2 + (-width / 2 + xx) * sx, vw, vh);
			rect(-height / 2 + height - (height / 2 + (-height / 2 + yy) * sy), -width / 2 + width - (width / 2 + (-width / 2 + xx) * sx), vw, vh);
		}
		pop();
	/*
		for (let y = 0; y < h; y += sw) {
			for (let x = 0; x < w / 2; x += sh) {
				if (x <= 0 || x >= w / 2 || y <= 0 || y >= mh) { // checkerboard pattern
					let nx = x / w;
					let ny = y / h;

					let anx = abs(0.5 - nx) * 2;
					let any = abs(0.5 - ny) * 2;

					// surface modulation
					let smx = (sin(ymotion / 2 * max(0, 1 - pow(0.5 + i/600, 0.25)))) * 100 * anx * max(0, 1-i/1000) + 50 * (1- any);
					let smy = (sin(ymotion / 8 * max(0, 1 - i/400))) * 100 * anx * max(0, 1-i/400);

					// shading of the 'surfaces'
					let brightness = 0;
					if (x <= 0 ) {
						// due to symmetry there is only one real 'side'
						brightness = 255 * sin(i/1000 * PI * 2) - (y & (x + i / 3 + zmotion)) % 128 * abs(smx / 16 + 0.5);
						fill(140 + 40 * (1 - ny) + random(0, 32) + (y ^ (x + i / 4)) % 40, 32 + random(0, 64),
								 brightness, 1 * pow(any * (1- any), 0.1));
					} else if (y<= 0) {
						brightness = 255 * sin(pow(i/1000, 1.1) * PI * 2) - (x ^ (y + i * 2)) % 128 * pow(anx, 4);
						fill(140 + random(0, 32) + (x ^ (y + i * 4)) % 40, 32 + random(0, 32),
								 brightness, 1);
					} else {
						brightness = 255 * sin(pow(i/1000, 1.1) * PI * 2) - (x ^ (y + i * 2)) % 128 * pow(anx, 4);
						fill(140 + random(0, 32) + (x ^ (y + i * 4)) % 40, 32 + random(0, 32),
								 brightness, 1);
					}
					//
					
					//if (brightness < 1) {
					//	continue;
					//}
					
					let vw = sw * sx;
					let vh = sh * sy;

					let xx = x;
					if (x <= 0) {
						xx += smx;
					}

					let yy = y + smy;
*/
					//if (y > 0) {
//						rect(/*-width / 2 +*/ width / 2 + (-width / 2 + xx) * sx, /*-height / 2 + */height / 2 + (-height / 2 + yy) * sy, vw, vh);
//						rect(/*-width / 2 +*/ width - (width / 2 + (-width / 2 + xx) * sx + vw), /*-height / 2 + */height / 2 + (-height / 2 + yy) * sy, vw, vh);
					//}
			//	}
		//	}
		
	//	}
		//pop();
		
		xmotion += 0.5;
		ymotion += 0.5;
	}
	
	zmotion += 4.5;
}

function draw_sky() {
	noStroke();
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width+8; x += 1) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12) / 4;
			let n2 = noise(nx, ny);
			
			let yy = y - n * (height * 3.75);
			fill(200 + 25 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.5 + ny * PI * 2 + 0.25))) * abs(0.5 - nx) * 2, 118, (128 + pow(ny, 1) * 128), 1);
			rect(x, yy, 4, 5);
		}
	}

	for (y = height/1.85; y > 0; y -= 1) {
		let ny = y / height/1.85;
		for (x = 0; x < width; x += 1) {
			if (random() > 0.75) {
				stroke(0, 0, 0, random(0, 0.05));
				let xx = x + random(-4, 4);
				line(xx, y, xx + random(-6, 6)*ny, y + random(-6, 6)*ny);
			}
		}
	}
	
	for (y = 0; y < height / 2; y += 1) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 8) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.05);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-100, 100), y + random(-100, 100));
			}
		}
	}
	
	for (y = 0; y < height / 2; y += 1) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 1) {
			let n = noise(x / width, y / height*4);
			if (random() > 0.25 + n) {
				stroke(0, 0, 255, random() * 0.0075*n);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-100, 100), y + random(-20, 20));
			}
		}
	}
	
	for (y = 0; y < height / 2; y += 16) {
		let ny = y / height;
		let noy = noise(ny);
		for (x = 0; x < width; x += 3) {
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = noise(nx, ny);
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2 * nox2;

			let yy = y;

			if (random() > 0.999) {
				stroke(0, 0, 0, 1);
				strokeWeight(0.5 + random() / 2);
				let tx = x + random(1, 6);
				let ty = yy + random(1, 6);
				line(x, yy, tx, ty);
				line(tx, ty, tx + random(1, 4) * (1-ny), ty - random(1, 4) * (1-ny));
			}
		}
	}
}"
"1116798","Fake raycast rt 4","mySketch","// fake raycast ry with heavy twisting

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
	
	//rectMode(CENTER);
}

let zmotion = 0;


function draw() {
	background(0);
	noStroke();
	fill(0, 0, 0, 0.05);
	rect(0, 0, width, height);
let xmotion = 0;
let ymotion = 0;
	
	for (let i = 0; i < 100; i += 1) {
		let ni = i / 100;

		// the blocks resolution (lower = better)
		let sw = 20;
		let sh = 20;

		let xp_offset = 0;
		let yp_offset = 0;

		let w = width;
		let h = height;

		let sf = 0.25;

		let sx = sf + xmotion/64;
		let sy = sf + xmotion/64;

		let mw = w - sw;
		let mh = h - sh;
		
		push();
		translate(width / 2, height / 2);
		rotate((sin(xmotion / 32)/8) * ni + zmotion / 500 + cos(zmotion / 200));
		for (let x = 0; x < w/2; x += sh) {
			let nx = x / (w/2);
			
			let anx = abs(0.5 - nx) * 2;
			let smx = (sin(xmotion / 50 + zmotion / 100 + anx * PI * 2)) * anx * width / 2;
			let smy = abs(cos(xmotion / 50 + zmotion / 100 + ni * PI * 0.25 + nx * PI * 2)) * (nx * ni) * (width / 3);
			
			let brightness = 0;
						brightness = 128+255 * abs(sin(zmotion / 1000 + ni * PI * 1) * nx) - (x ^ (i * 4 + frameCount * 8)) % 255;
						fill(224+((x + frameCount) | (i / 2 + frameCount * 2)) % 64, 128,
								 brightness, 1);
			
			let vw = sw * sx * (1-ni);
			let vh = sh * sy * (1-ni);
			
			let xx = x;
			if (x <= 0) {
				xx += smx;
			}
			
			if (brightness < 1) {
				continue;
			}
			
			let yy = 0 + smy;
			
			rect(-width / 2 + width / 2 + (-width / 2 + xx) * sx, -height / 2 + height / 2 + (-height / 2 + yy) * sy, vw, vh);
			rect(-width / 2 + width - (width / 2 + (-width / 2 + xx) * sx), -height / 2 + height / 2 + (-height / 2 + yy) * sy, vw, vh);
			rect(-width / 2 + width / 2 + (-width / 2 + xx) * sx, -height / 2 + height - (height / 2 + (-height / 2 + yy) * sy), vw, vh);
			rect(-width / 2 + width - (width / 2 + (-width / 2 + xx) * sx), -height / 2 + height - (height / 2 + (-height / 2 + yy) * sy), vw, vh);
			
			rect(-height / 2 + height / 2 + (-height / 2 + yy) * sy, -width / 2 + width / 2 + (-width / 2 + xx) * sx, vw, vh);
			rect(-height / 2 + height / 2 + (-height / 2 + yy) * sy, -width / 2 + width - (width / 2 + (-width / 2 + xx) * sx), vw, vh);
			rect(-height / 2 + height - (height / 2 + (-height / 2 + yy) * sy), -width / 2 + width / 2 + (-width / 2 + xx) * sx, vw, vh);
			rect(-height / 2 + height - (height / 2 + (-height / 2 + yy) * sy), -width / 2 + width - (width / 2 + (-width / 2 + xx) * sx), vw, vh);
		}
		pop();
	/*
		for (let y = 0; y < h; y += sw) {
			for (let x = 0; x < w / 2; x += sh) {
				if (x <= 0 || x >= w / 2 || y <= 0 || y >= mh) { // checkerboard pattern
					let nx = x / w;
					let ny = y / h;

					let anx = abs(0.5 - nx) * 2;
					let any = abs(0.5 - ny) * 2;

					// surface modulation
					let smx = (sin(ymotion / 2 * max(0, 1 - pow(0.5 + i/600, 0.25)))) * 100 * anx * max(0, 1-i/1000) + 50 * (1- any);
					let smy = (sin(ymotion / 8 * max(0, 1 - i/400))) * 100 * anx * max(0, 1-i/400);

					// shading of the 'surfaces'
					let brightness = 0;
					if (x <= 0 ) {
						// due to symmetry there is only one real 'side'
						brightness = 255 * sin(i/1000 * PI * 2) - (y & (x + i / 3 + zmotion)) % 128 * abs(smx / 16 + 0.5);
						fill(140 + 40 * (1 - ny) + random(0, 32) + (y ^ (x + i / 4)) % 40, 32 + random(0, 64),
								 brightness, 1 * pow(any * (1- any), 0.1));
					} else if (y<= 0) {
						brightness = 255 * sin(pow(i/1000, 1.1) * PI * 2) - (x ^ (y + i * 2)) % 128 * pow(anx, 4);
						fill(140 + random(0, 32) + (x ^ (y + i * 4)) % 40, 32 + random(0, 32),
								 brightness, 1);
					} else {
						brightness = 255 * sin(pow(i/1000, 1.1) * PI * 2) - (x ^ (y + i * 2)) % 128 * pow(anx, 4);
						fill(140 + random(0, 32) + (x ^ (y + i * 4)) % 40, 32 + random(0, 32),
								 brightness, 1);
					}
					//
					
					//if (brightness < 1) {
					//	continue;
					//}
					
					let vw = sw * sx;
					let vh = sh * sy;

					let xx = x;
					if (x <= 0) {
						xx += smx;
					}

					let yy = y + smy;
*/
					//if (y > 0) {
//						rect(/*-width / 2 +*/ width / 2 + (-width / 2 + xx) * sx, /*-height / 2 + */height / 2 + (-height / 2 + yy) * sy, vw, vh);
//						rect(/*-width / 2 +*/ width - (width / 2 + (-width / 2 + xx) * sx + vw), /*-height / 2 + */height / 2 + (-height / 2 + yy) * sy, vw, vh);
					//}
			//	}
		//	}
		
	//	}
		//pop();
		
		xmotion += 0.5;
		ymotion += 0.5;
	}
	
	zmotion += 4.5;
}
"
"1115572","Fake raycast rt 3","mySketch","// fake raycast ry with heavy twisting

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
	
	//rectMode(CENTER);
	//draw_sky();
}

let zmotion = 0;


function draw() {
	background(0);
	noStroke();
	fill(0, 0, 0, 0.05);
	rect(0, 0, width, height);
let xmotion = 0;
let ymotion = 0;
	
	for (let i = 0; i < 100; i += 1) {
		let ni = i / 100;

		// the blocks resolution (lower = better)
		let sw = 20;
		let sh = 20;

		let xp_offset = 0;
		let yp_offset = 0;

		let w = width;
		let h = height;

		let sf = 0.25;

		let sx = sf + xmotion/48;
		let sy = sf + xmotion/48;

		let mw = w - sw;
		let mh = h - sh;
		
		push();
		translate(width / 2, height / 2);
		rotate((sin(xmotion / 32)/8) * ni + zmotion / 500 + cos(zmotion / 200));
		for (let x = 0; x < w/2; x += sh) {
			let nx = x / (w/2);
			
			let anx = abs(0.5 - nx) * 2;
			let smx = (sin(xmotion / 50 + zmotion / 100 + anx * PI * 2)) * anx * 0;
			let smy = abs(cos(xmotion / 50 + zmotion / 100 + ni * PI * 1)) * (1-ni) * (width / 2);
			
			let brightness = 0;
						brightness = 128+255 * abs(sin(zmotion / 1000 + ni * PI * 2.0) * anx) - (x & (i * 8 + frameCount * 16)) % 255;
						fill(190+((x + frameCount) ^ (i * 2 + frameCount)) % 32, 128,
								 brightness, 1);
			
			let vw = sw * sx;
			let vh = sh * sy;
			
			let xx = x;
			if (x <= 0) {
				xx += smx;
			}
			
			if (brightness < 1) {
				continue;
			}
			
			let yy = 0 + smy;
			
			rect(-width / 2 + width / 2 + (-width / 2 + xx) * sx, -height / 2 + height / 2 + (-height / 2 + yy) * sy, vw, vh);
			rect(-width / 2 + width - (width / 2 + (-width / 2 + xx) * sx), -height / 2 + height / 2 + (-height / 2 + yy) * sy, vw, vh);
			rect(-width / 2 + width / 2 + (-width / 2 + xx) * sx, -height / 2 + height - (height / 2 + (-height / 2 + yy) * sy), vw, vh);
			rect(-width / 2 + width - (width / 2 + (-width / 2 + xx) * sx), -height / 2 + height - (height / 2 + (-height / 2 + yy) * sy), vw, vh);
			
			rect(-height / 2 + height / 2 + (-height / 2 + yy) * sy, -width / 2 + width / 2 + (-width / 2 + xx) * sx, vw, vh);
			rect(-height / 2 + height / 2 + (-height / 2 + yy) * sy, -width / 2 + width - (width / 2 + (-width / 2 + xx) * sx), vw, vh);
			rect(-height / 2 + height - (height / 2 + (-height / 2 + yy) * sy), -width / 2 + width / 2 + (-width / 2 + xx) * sx, vw, vh);
			rect(-height / 2 + height - (height / 2 + (-height / 2 + yy) * sy), -width / 2 + width - (width / 2 + (-width / 2 + xx) * sx), vw, vh);
		}
		pop();
	/*
		for (let y = 0; y < h; y += sw) {
			for (let x = 0; x < w / 2; x += sh) {
				if (x <= 0 || x >= w / 2 || y <= 0 || y >= mh) { // checkerboard pattern
					let nx = x / w;
					let ny = y / h;

					let anx = abs(0.5 - nx) * 2;
					let any = abs(0.5 - ny) * 2;

					// surface modulation
					let smx = (sin(ymotion / 2 * max(0, 1 - pow(0.5 + i/600, 0.25)))) * 100 * anx * max(0, 1-i/1000) + 50 * (1- any);
					let smy = (sin(ymotion / 8 * max(0, 1 - i/400))) * 100 * anx * max(0, 1-i/400);

					// shading of the 'surfaces'
					let brightness = 0;
					if (x <= 0 ) {
						// due to symmetry there is only one real 'side'
						brightness = 255 * sin(i/1000 * PI * 2) - (y & (x + i / 3 + zmotion)) % 128 * abs(smx / 16 + 0.5);
						fill(140 + 40 * (1 - ny) + random(0, 32) + (y ^ (x + i / 4)) % 40, 32 + random(0, 64),
								 brightness, 1 * pow(any * (1- any), 0.1));
					} else if (y<= 0) {
						brightness = 255 * sin(pow(i/1000, 1.1) * PI * 2) - (x ^ (y + i * 2)) % 128 * pow(anx, 4);
						fill(140 + random(0, 32) + (x ^ (y + i * 4)) % 40, 32 + random(0, 32),
								 brightness, 1);
					} else {
						brightness = 255 * sin(pow(i/1000, 1.1) * PI * 2) - (x ^ (y + i * 2)) % 128 * pow(anx, 4);
						fill(140 + random(0, 32) + (x ^ (y + i * 4)) % 40, 32 + random(0, 32),
								 brightness, 1);
					}
					//
					
					//if (brightness < 1) {
					//	continue;
					//}
					
					let vw = sw * sx;
					let vh = sh * sy;

					let xx = x;
					if (x <= 0) {
						xx += smx;
					}

					let yy = y + smy;
*/
					//if (y > 0) {
//						rect(/*-width / 2 +*/ width / 2 + (-width / 2 + xx) * sx, /*-height / 2 + */height / 2 + (-height / 2 + yy) * sy, vw, vh);
//						rect(/*-width / 2 +*/ width - (width / 2 + (-width / 2 + xx) * sx + vw), /*-height / 2 + */height / 2 + (-height / 2 + yy) * sy, vw, vh);
					//}
			//	}
		//	}
		
	//	}
		//pop();
		
		xmotion += 0.5;
		ymotion += 0.5;
	}
	
	zmotion += 4.5;
}

function draw_sky() {
	noStroke();
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width+8; x += 1) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12) / 4;
			let n2 = noise(nx, ny);
			
			let yy = y - n * (height * 3.75);
			fill(200 + 25 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.5 + ny * PI * 2 + 0.25))) * abs(0.5 - nx) * 2, 118, (128 + pow(ny, 1) * 128), 1);
			rect(x, yy, 4, 5);
		}
	}

	for (y = height/1.85; y > 0; y -= 1) {
		let ny = y / height/1.85;
		for (x = 0; x < width; x += 1) {
			if (random() > 0.75) {
				stroke(0, 0, 0, random(0, 0.05));
				let xx = x + random(-4, 4);
				line(xx, y, xx + random(-6, 6)*ny, y + random(-6, 6)*ny);
			}
		}
	}
	
	for (y = 0; y < height / 2; y += 1) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 8) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.05);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-100, 100), y + random(-100, 100));
			}
		}
	}
	
	for (y = 0; y < height / 2; y += 1) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 1) {
			let n = noise(x / width, y / height*4);
			if (random() > 0.25 + n) {
				stroke(0, 0, 255, random() * 0.0075*n);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-100, 100), y + random(-20, 20));
			}
		}
	}
	
	for (y = 0; y < height / 2; y += 16) {
		let ny = y / height;
		let noy = noise(ny);
		for (x = 0; x < width; x += 3) {
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = noise(nx, ny);
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2 * nox2;

			let yy = y;

			if (random() > 0.999) {
				stroke(0, 0, 0, 1);
				strokeWeight(0.5 + random() / 2);
				let tx = x + random(1, 6);
				let ty = yy + random(1, 6);
				line(x, yy, tx, ty);
				line(tx, ty, tx + random(1, 4) * (1-ny), ty - random(1, 4) * (1-ny));
			}
		}
	}
}"
"1115552","Fake raycast rt 2","mySketch","// fake raycast ry with heavy twisting

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
	
	//rectMode(CENTER);
	//draw_sky();
}

let zmotion = 0;


function draw() {
	background(0);
	noStroke();
	fill(0, 0, 0, 0.05);
	rect(0, 0, width, height);
let xmotion = 0;
let ymotion = 0;
	
	for (let i = 0; i < 100; i += 1) {
		let ni = i / 100;

		// the blocks resolution (lower = better)
		let sw = 20;
		let sh = 20;

		let xp_offset = 0;
		let yp_offset = 0;

		let w = width;
		let h = height;

		let sf = 0.25;

		let sx = sf + xmotion/40;
		let sy = sf + xmotion/40;

		let mw = w - sw;
		let mh = h - sh;
		
		push();
		translate(width / 2, height / 2);
		rotate((sin(xmotion / 32)/8) * ni + zmotion / 500 + cos(zmotion / 200));
		for (let x = 0; x < w/2; x += sh) {
			let nx = x / (w/2);
			
			let anx = abs(0.5 - nx) * 2;
			let smx = (sin(xmotion / 50 + zmotion / 100 + anx * PI * 2)) * anx * 0;
			let smy = abs(cos(xmotion / 50 + zmotion / 100 + ni * PI * 1)) * (1-ni) * (width / 2.25);
			
			let brightness = 0;
						brightness = 128+255 * abs(sin(zmotion / 1000 + ni * PI * 2.0) * anx) - (x | (i * 1 + frameCount * 2)) % 255;
						fill(200+(x + xmotion) ^ (i * 1 + zmotion / 2) % 170, 128,
								 brightness, 1);
			
			let vw = sw * sx * ni;
			let vh = sh * sy * ni;
			
			let xx = x;
			if (x <= 0) {
				xx += smx;
			}
			
			if (brightness < 1) {
				continue;
			}
			
			let yy = 0 + smy;
			
			rect(-width / 2 + width / 2 + (-width / 2 + xx) * sx, -height / 2 + height / 2 + (-height / 2 + yy) * sy, vw, vh);
			rect(-width / 2 + width - (width / 2 + (-width / 2 + xx) * sx), -height / 2 + height / 2 + (-height / 2 + yy) * sy, vw, vh);
			rect(-width / 2 + width / 2 + (-width / 2 + xx) * sx, -height / 2 + height - (height / 2 + (-height / 2 + yy) * sy), vw, vh);
			rect(-width / 2 + width - (width / 2 + (-width / 2 + xx) * sx), -height / 2 + height - (height / 2 + (-height / 2 + yy) * sy), vw, vh);
			
			rect(-height / 2 + height / 2 + (-height / 2 + yy) * sy, -width / 2 + width / 2 + (-width / 2 + xx) * sx, vw, vh);
			rect(-height / 2 + height / 2 + (-height / 2 + yy) * sy, -width / 2 + width - (width / 2 + (-width / 2 + xx) * sx), vw, vh);
			rect(-height / 2 + height - (height / 2 + (-height / 2 + yy) * sy), -width / 2 + width / 2 + (-width / 2 + xx) * sx, vw, vh);
			rect(-height / 2 + height - (height / 2 + (-height / 2 + yy) * sy), -width / 2 + width - (width / 2 + (-width / 2 + xx) * sx), vw, vh);
		}
		pop();
	/*
		for (let y = 0; y < h; y += sw) {
			for (let x = 0; x < w / 2; x += sh) {
				if (x <= 0 || x >= w / 2 || y <= 0 || y >= mh) { // checkerboard pattern
					let nx = x / w;
					let ny = y / h;

					let anx = abs(0.5 - nx) * 2;
					let any = abs(0.5 - ny) * 2;

					// surface modulation
					let smx = (sin(ymotion / 2 * max(0, 1 - pow(0.5 + i/600, 0.25)))) * 100 * anx * max(0, 1-i/1000) + 50 * (1- any);
					let smy = (sin(ymotion / 8 * max(0, 1 - i/400))) * 100 * anx * max(0, 1-i/400);

					// shading of the 'surfaces'
					let brightness = 0;
					if (x <= 0 ) {
						// due to symmetry there is only one real 'side'
						brightness = 255 * sin(i/1000 * PI * 2) - (y & (x + i / 3 + zmotion)) % 128 * abs(smx / 16 + 0.5);
						fill(140 + 40 * (1 - ny) + random(0, 32) + (y ^ (x + i / 4)) % 40, 32 + random(0, 64),
								 brightness, 1 * pow(any * (1- any), 0.1));
					} else if (y<= 0) {
						brightness = 255 * sin(pow(i/1000, 1.1) * PI * 2) - (x ^ (y + i * 2)) % 128 * pow(anx, 4);
						fill(140 + random(0, 32) + (x ^ (y + i * 4)) % 40, 32 + random(0, 32),
								 brightness, 1);
					} else {
						brightness = 255 * sin(pow(i/1000, 1.1) * PI * 2) - (x ^ (y + i * 2)) % 128 * pow(anx, 4);
						fill(140 + random(0, 32) + (x ^ (y + i * 4)) % 40, 32 + random(0, 32),
								 brightness, 1);
					}
					//
					
					//if (brightness < 1) {
					//	continue;
					//}
					
					let vw = sw * sx;
					let vh = sh * sy;

					let xx = x;
					if (x <= 0) {
						xx += smx;
					}

					let yy = y + smy;
*/
					//if (y > 0) {
//						rect(/*-width / 2 +*/ width / 2 + (-width / 2 + xx) * sx, /*-height / 2 + */height / 2 + (-height / 2 + yy) * sy, vw, vh);
//						rect(/*-width / 2 +*/ width - (width / 2 + (-width / 2 + xx) * sx + vw), /*-height / 2 + */height / 2 + (-height / 2 + yy) * sy, vw, vh);
					//}
			//	}
		//	}
		
	//	}
		//pop();
		
		xmotion += 0.5;
		ymotion += 0.5;
	}
	
	zmotion += 4.5;
}

function draw_sky() {
	noStroke();
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width+8; x += 1) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12) / 4;
			let n2 = noise(nx, ny);
			
			let yy = y - n * (height * 3.75);
			fill(200 + 25 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.5 + ny * PI * 2 + 0.25))) * abs(0.5 - nx) * 2, 118, (128 + pow(ny, 1) * 128), 1);
			rect(x, yy, 4, 5);
		}
	}

	for (y = height/1.85; y > 0; y -= 1) {
		let ny = y / height/1.85;
		for (x = 0; x < width; x += 1) {
			if (random() > 0.75) {
				stroke(0, 0, 0, random(0, 0.05));
				let xx = x + random(-4, 4);
				line(xx, y, xx + random(-6, 6)*ny, y + random(-6, 6)*ny);
			}
		}
	}
	
	for (y = 0; y < height / 2; y += 1) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 8) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.05);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-100, 100), y + random(-100, 100));
			}
		}
	}
	
	for (y = 0; y < height / 2; y += 1) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 1) {
			let n = noise(x / width, y / height*4);
			if (random() > 0.25 + n) {
				stroke(0, 0, 255, random() * 0.0075*n);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-100, 100), y + random(-20, 20));
			}
		}
	}
	
	for (y = 0; y < height / 2; y += 16) {
		let ny = y / height;
		let noy = noise(ny);
		for (x = 0; x < width; x += 3) {
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = noise(nx, ny);
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2 * nox2;

			let yy = y;

			if (random() > 0.999) {
				stroke(0, 0, 0, 1);
				strokeWeight(0.5 + random() / 2);
				let tx = x + random(1, 6);
				let ty = yy + random(1, 6);
				line(x, yy, tx, ty);
				line(tx, ty, tx + random(1, 4) * (1-ny), ty - random(1, 4) * (1-ny));
			}
		}
	}
}"
"1115194","Sea landscape 3","mySketch","// code size optimized / cleaned up mininal fake raycast (with x axis symmetry)
// with logical operators texture and generated background sky from a previous sketch
// note : became more complex than previously thought but its still somewhat the clean and generic version

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
	
	//rectMode(CENTER);
	draw_background();
}

let xmotion = 0;
let ymotion = 0;

function draw() {

}

function draw_background() {
	noStroke();
	
	background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height+64; y += 4) {
		let ny = y / height;
		for (x = 0; x < width+8; x += 1) {
			let nx = x / width;
			let n = noise(nx / 2, ny / 2) / 4;
			let n2 = noise(nx, ny);
			
			let yy = y - n * height/2;
			fill(192 + 24 * (n2 * abs(sin(nx * PI * 0.5 + ny * PI * 2 + 0.25))) * abs(0.5 - nx) * 2, 118, (64 + pow(0.5+(ny%0.5) * (1-abs(0.5 - nx) * 2), 2.25) * 64) + 128 * (1-abs(0.5-ny)*2), 1);
			rect(x, yy, 4, 5);
		}
	}
	
		for (y = 0; y < height/2.35; y += 2) {
		for (x = 0; x < 4; x += 1) {
			fill(random(0, 64), random(0, 128), random(128, 255), 1 * pow(1-y / (height/2.35), 2.25));
			rect(random(0, width), y, random(1, 2), random(1, 2));
		}
	}
	
	for (y = height/1.85; y > 0; y -= 1) {
		let ny = y / height/1.85;
		for (x = 0; x < width; x += 1) {
			if (random() > 0.75) {
				stroke(0, 0, 0, random(0, 0.05));
				let xx = x + random(-4, 4);
				line(xx, y, xx + random(-6, 6)*ny, y + random(-6, 6)*ny);
			}
		}
	}

	for (y = 0; y < height / 2; y += 1) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 8) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.025);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-100, 100), y + random(-100, 100));
			}
		}
	}
	/*
	for (y = 0; y < height / 2; y += 1) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 1) {
			let n = noise(x / width, y / height*4);
			if (random() > 0.25 + n) {
				stroke(0, 0, 255, random() * 0.05*n);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-100, 100), y + random(-20, 20));
			}
		}
	}*/

	
	let wl = 255 * (height / 976);
	let m = 0; // get max y
	for (y = 0; y < (height - m); y += 1) {
		let ny = y / height;
		let noy = noise(ny);
		
		for (x = -32; x < width+32; x += 1) {
			let yy = (height / 2 + noise(x / width) * 8) + y + m;
			
			let nx = x / width;
			let nox = noise(nx * 16, ny * 32);
			let nox2 = (noise(nx*3, ny*3));
			let nox3 = noise(nx / 4, ny / 4);
			let n = (sin(nx * PI * 0.5 + ny * PI * 1 + nox * PI * 15.15 * (1-ny))) / 2 * nox2;
			
			if (random() > 0.25) {
				stroke(random(192, 206) + (nox2) * 20, 140 * nox3, 255*nox3-random(-100, 200) * n, random() * 0.25 * pow(ny, 0.3));
				let xx = x + random(-2, 2);
				line(xx, yy, xx + random(-100, 100) * n * noy * ny + nox3*200*ny, yy + random(-100, 100) * n * ny);
			}
		}
	}

	for (y = 0; y < height / 2; y += 16) {
		let ny = y / height;
		let noy = noise(ny);
		for (x = 0; x < width; x += 3) {
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = noise(nx, ny);
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2 * nox2;

			let yy = y;

			if (random() > 0.9992) {
				stroke(0, 0, 0, 1);
				strokeWeight(0.5);
				let tx = x + random(1, 6);
				let ty = yy + random(1, 6);
				line(x, yy, tx, ty);
				line(tx, ty, tx + random(1, 4) * (1-ny), ty - random(1, 1) * (1-ny));
			}
		}
	}
}"
"1114521","Fake raycast noise","mySketch","// code size optimized / cleaned up mininal fake raycast (with x axis symmetry)
// with logical operators texture and generated background sky from a previous sketch
// note : became more complex than previously thought but its still somewhat the clean and generic version

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
	
	//rectMode(CENTER);
	generate();
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	//background(0);
	noStroke();
	//fill(0, 0, 0, 0.05);
	//rect(0, 0, width, height);

	let planes = 1;

	// the blocks resolution (lower = better)
	let sw = 10;
	let sh = 10;
	
	let xp_offset = 0;
	let yp_offset = 0;
	
	let w = width;
	let h = height;
	
	for (let p = 0; p < planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let ainp = 1-np;
		
		let sf = ainp / 256;
		
		let sx = sf + xmotion/128;
		let sy = sf + xmotion/128;
		
		let mw = w - sw;
		let mh = h - sh;
		
		push();
		translate(width / 2, height / 2);
		rotate((sin(xmotion / 5)/6) * max(0, 1-frameCount/600));
		for (let y = 0; y < h; y += sw) {
			for (let x = 0; x < w / 2; x += sh) {
				if (x <= 0 || x >= w / 2 || y <= 0 || y >= mh) { // checkerboard pattern
					let nx = x / w;
					let ny = y / h;
					
					let anx = abs(0.5 - nx) * 2;
					let any = abs(0.5 - ny) * 2;
					
					// surface modulation
					let smx = (sin(ymotion / 2 * max(0, 1 - pow(0.5 + frameCount/600, 0.25)))) * 100 * anx * max(0, 1-frameCount/1000) + 50 * (1- any);
					let smy = (sin(ymotion / 8 * max(0, 1 - frameCount/400))) * 100 * anx * max(0, 1-frameCount/400);
				
					// shading of the 'surfaces'
					let brightness = 0;
					if (x <= 0 ) {
						// due to symmetry there is only one real 'side'
						brightness = 255 * sin(pow(frameCount/1000 * PI * 2, 1.1)) - (y | (x + frameCount / 2)) % 128 - noise(nx*16, frameCount / 10) * 64;
						fill(48 + 32 * (1 - ny) + random(0, 24) + (y ^ (x + frameCount / 4)) % 40, 32 + random(0, 64),
								 brightness, 1);
					} else if (y<= 0) {
						brightness = 255 * sin(pow(frameCount/1000, 1.1) * PI * 2) - (x ^ (y + frameCount * 2)) % 128 * pow(anx, 4);
						fill(140 + random(0, 32) + (x ^ (y + frameCount * 4)) % 40, 32 + random(0, 32),
								 brightness, 1);
					} else {
						brightness = 255 * sin(pow(frameCount/1000, 1.1) * PI * 2) - (x ^ (y + frameCount * 2)) % 128 * pow(anx, 4) - noise(nx*16, frameCount / 10) * 64;
						fill(0 + random(0, 32) + (x ^ (y + frameCount * 4)) % 40, 32 + random(0, 32),
								 brightness, 1);
					}
					//
					/*
					if (brightness < 1) {
						continue;
					}
					*/
					let vw = sw * sx;
					let vh = sh * sy;
					
					let xx = x;
					if (x <= 0) {
						xx += smx;
					}
					
					let yy = y + smy;

					if (y > 0) {
						rect(-width / 2 + width / 2 + (-width / 2 + xx) * sx, -height / 2 + height / 2 + (-height / 2 + yy) * sy, vw, vh);
						rect(-width / 2 + width - (width / 2 + (-width / 2 + xx) * sx + vw), -height / 2 + height / 2 + (-height / 2 + yy) * sy, vw, vh);
					}
				}
			}
		}
		pop();
	}
	
	xmotion += 0.25;
	ymotion += 0.5;
}

function generate() {
	noStroke();
	
	background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 2) {
		let ny = y / height;
		for (x = 0; x < width+8; x += 1) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx, ny);
			
			let yy = height / 3.1 + y - n * height;
			fill(200 + 25 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.5 + ny * PI * 2 + 0.25))), 118, (128 + pow(0.5+(ny) * (1-abs(0.5 - nx) * 2), 1.25) * 128), 1);
			rect(x, yy, 4, 5);
		}
	}
	
	for (y = height/1.85; y > 0; y -= 1) {
		let ny = y / height/1.85;
		for (x = 0; x < width; x += 1) {
			if (random() > 0.75) {
				stroke(0, 0, 0, random(0, 0.05));
				let xx = x + random(-4, 4);
				line(xx, y, xx + random(-6, 6)*ny, y + random(-6, 6)*ny);
			}
		}
	}

	for (y = 0; y < height / 2; y += 1) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 8) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.05);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-100, 100), y + random(-100, 100));
			}
		}
	}
	
	for (y = 0; y < height / 2; y += 1) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 1) {
			let n = noise(x / width, y / height*4);
			if (random() > 0.25 + n) {
				stroke(0, 0, 255, random() * 0.0075*n);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-100, 100), y + random(-20, 20));
			}
		}
	}
	
	for (y = 0; y < height / 2; y += 16) {
		let ny = y / height;
		let noy = noise(ny);
		for (x = 0; x < width; x += 3) {
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = noise(nx, ny);
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2 * nox2;

			let yy = y;

			if (random() > 0.998) {
				stroke(0, 0, 0, 1);
				strokeWeight(0.5);
				let tx = x + random(1, 6);
				let ty = yy + random(1, 6);
				line(x, yy, tx, ty);
				line(tx, ty, tx + random(1, 4) * (1-ny), ty - random(1, 1) * (1-ny));
			}
		}
	}
}"
"1114518","Fake raycast texture + noise","mySketch","// with texture (foliage) and discard

let img;
function preload() {
  img = loadImage('hedge.jpg');
}

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
	
	img.loadPixels();
	
	//rectMode(CENTER);
	generate();
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	//background(0);
	noStroke();
	//fill(0, 0, 0, 0.05);
	//rect(0, 0, width, height);

	let planes = 1;

	// the blocks resolution (lower = better)
	let sw = 2;
	let sh = 2;
	
	let xp_offset = 0;
	let yp_offset = 0;
	
	let w = width;
	let h = height;
	
	for (let p = 0; p < planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let ainp = 1-np;
		
		let sf = ainp / 256;
		
		let sx = sf + xmotion/128;
		let sy = sf + xmotion/128;
		
		let mw = w - sw;
		let mh = h - sh;
		
		push();
		translate(width / 2, height / 2);
		rotate((sin(xmotion / 8)/10) * max(0, 1-frameCount/900));
		for (let y = 0; y < h; y += sw) {
			for (let x = 0; x < w / 2; x += sh) {
				if (x <= 0 || x >= w / 2 || y <= 0 || y >= mh) { // checkerboard pattern
					let nx = x / w;
					let ny = y / h;
					
					let anx = abs(0.5 - nx) * 2;
					let any = abs(0.5 - ny) * 2;
					
					// surface modulation
					let smx = (sin(ymotion / 2 * max(0, 1 - pow(0.5 + frameCount/600, 0.25)))) * 100 * anx * max(0, 1-frameCount/400) + 50 * (1- any);
					let smy = (cos(ymotion / 8 * max(0, 1 - frameCount/400))) * 100 * anx * max(0, 1-frameCount/400);
					
					// shading of the 'surfaces'
					let surf_brightness = 0;
					if (x <= 0 ) {
						// fetch texture data
						let si = (floor(frameCount * 2) % img.width + floor((ny * img.height) * 2 % img.height) * img.width) * 4;
						let cr = img.pixels[si + 0];
						let cg = img.pixels[si + 1];
						let cb = img.pixels[si + 2];
						let texRgb = [cr, cg, cb];

						// due to symmetry there is only one real 'side'
						surf_brightness = (brightness(texRgb)*3 * sin(pow(frameCount/1000 * PI * 1.1, 1.1)));
						fill(hue(texRgb), saturation(texRgb),
								 surf_brightness, pow(ny, 0.35) * 1 * min(1, frameCount / 200));
					} else if (y<= 0) {
						//surf_brightness = 255 * sin(pow(frameCount/1000, 1.1) * PI * 1.5) - (x ^ (y + frameCount * 2)) % 128 * pow(anx, 4);
						//fill(140 + random(0, 32) + (x ^ (y + frameCount * 4)) % 40, 32 + random(0, 32),
						//		 surf_brightness, 1);
					} else {
						// fetch texture data
						let si = (floor(frameCount * 2) % img.width + floor((anx * img.height) * 2 % img.height) * img.width) * 4;
						let cr = img.pixels[si + 0];
						let cg = img.pixels[si + 1];
						let cb = img.pixels[si + 2];
						let texRgb = [cr, cg, cb];

						if (anx > 0.4) {
							// due to symmetry there is only one real 'side'
							surf_brightness = (brightness(texRgb)*3 * sin(pow(frameCount/1000 * PI * 1.1, 1.1)));
							fill(hue(texRgb), saturation(texRgb),
									 surf_brightness, pow(ny, 0.35) * 1 * min(1, frameCount / 200));
						} else {
							surf_brightness = 255 * sin(pow(frameCount/1000 * PI * 1.1, 1.1)) - (x ^ (y + frameCount * 2)) % 128 * pow(anx, 1.5) - noise(nx*16, frameCount / 10) * 64;
							fill(0 + random(0, 32) + (x ^ (y + frameCount * 4)) % 40, 32 + random(0, 32),
									 surf_brightness, 1);
						}
					}
					//
					
					// discard apply only on foliage
					if (surf_brightness < 32 /*&& x <= 0*/) {
						continue;
					}
					
					let vw = sw * sx + random(1, 2);
					let vh = sh * sy + random(1, 2);
					
					let xx = x;
					if (x <= 0) {
						xx += smx;
					}
					
					let yy = y + smy;

					if (y > 0) {
						rect(-width / 2 + width / 2 + (-width / 2 + xx) * sx, -height / 2 + height / 2 + (-height / 2 + yy) * sy, vw, vh);
						rect(-width / 2 + width - (width / 2 + (-width / 2 + xx) * sx + vw), -height / 2 + height / 2 + (-height / 2 + yy) * sy, vw, vh);
					}
				}
			}
		}
		pop();
	}
	
	xmotion += 0.25;
	ymotion += 0.5;
}

function generate() {
	noStroke();
	
	background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height+64; y += 4) {
		let ny = y / height;
		for (x = 0; x < width+8; x += 1) {
			let nx = x / width;
			let n = noise(nx / 2, ny / 2) / 4;
			let n2 = noise(nx, ny);
			
			let yy = y - n * height/1.5;
			fill(192 + 24 * (n2 * abs(sin(nx * PI * 0.5 + ny * PI * 2 + 0.25))) * abs(0.5 - nx) * 2, 118, (128 + pow(0.5+(ny) * (1-abs(0.5 - nx) * 2), 1.25) * 128), 1);
			rect(x, yy, 4, 5);
		}
	}
	/*
		for (y = 0; y < height/2; y += 2) {
		for (x = 0; x < 32; x += 1) {
			fill(0, 0, 255, 1);
			rect(random(0, width), y, 1, 1);
		}
	}
	*/
	for (y = height/1.85; y > 0; y -= 1) {
		let ny = y / height/1.85;
		for (x = 0; x < width; x += 1) {
			if (random() > 0.75) {
				stroke(0, 0, 0, random(0, 0.05));
				let xx = x + random(-4, 4);
				line(xx, y, xx + random(-6, 6)*ny, y + random(-6, 6)*ny);
			}
		}
	}

	for (y = 0; y < height / 2; y += 1) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 8) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.025);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-100, 100), y + random(-100, 100));
			}
		}
	}
	
	for (y = 0; y < height / 2; y += 1) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 1) {
			let n = noise(x / width, y / height*4);
			if (random() > 0.25 + n) {
				stroke(0, 0, 255, random() * 0.05*n);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-100, 100), y + random(-20, 20));
			}
		}
	}

	
	let wl = 255 * (height / 976);
	let m = 0; // get max y
	for (y = 0; y < (height - m); y += 1) {
		let ny = y / height;
		let noy = noise(ny);
		
		for (x = -32; x < width+32; x += 1) {
			let yy = (height / 2 + noise(x / width) * 8) + y + m;
			
			let nx = x / width;
			let nox = noise(nx * 16, ny * 32);
			let nox2 = (noise(nx*3, ny*3));
			let nox3 = noise(nx / 4, ny / 4);
			let n = (sin(nx * PI * 2.5 + ny * PI * 10 + nox * PI * 20.15)) / 2 * nox2;
			
			if (random() > 0.25) {
				stroke(180 + (nox2) * 20, 140 * nox3, 248*nox3-random(200) * n, random() * 0.45 * pow(ny, 0.1) * pow(0.5+(ny) * (1.-abs(0.5 - nx) * 2), 1.25));
				let xx = x + random(-2, 2);
				line(xx, yy, xx + random(-100, 100) * n * noy * ny + nox3*200*ny, yy + random(-100, 100) * n * ny);
			}
		}
	}
}"
"1114482","Fake raycast texture pier","mySketch","// with texture

let img;
let img2;
function preload() {
  img = loadImage('wood.png');
	img2 = loadImage('fence.png');
}

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
	
	img.loadPixels();
	img2.loadPixels();
	
	//rectMode(CENTER);
	generate();
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	//background(0);
	noStroke();
	//fill(0, 0, 0, 0.05);
	//rect(0, 0, width, height);

	colorMode(RGB, 255, 255, 255);
	
	let planes = 1;

	// the blocks resolution (lower = better)
	let sw = 1;
	let sh = 1;
	
	let xp_offset = 0;
	let yp_offset = 0;
	
	let w = width;
	let h = height;
	
	for (let p = 0; p < planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let ainp = 1-np;
		
		let sf = ainp / 32;
		
		let sx = sf + xmotion/256;
		let sy = sf + xmotion/256;
		
		let mw = w - sw;
		let mh = h - sh;
		
		push();
		translate(width / 2, height / 2);
		rotate((sin(xmotion / 20)/8) * max(0, 1-frameCount/600));
		for (let y = 0; y < h; y += sw) {
			for (let x = 0; x < w; x += sh) {
				if (x <= 0 || x >= w || y <= 0 || y >= mh) { // checkerboard pattern
					let nx = x / w;
					let ny = y / h;
					
					let anx = abs(0.5 - nx) * 2;
					let any = abs(0.5 - ny) * 2;
					
					// surface modulation
					let smx = 0;//(sin(ymotion / 2 * max(0, 1 - pow(0.5 + frameCount/600, 0.25)))) * 100 * anx * max(0, 1-frameCount/400) + 50 * (1- any);
					let smy = 0;//(cos(ymotion / 8 * max(0, 1 - frameCount/400))) * 100 * anx * max(0, 1-frameCount/400);
					
					// shading of the 'surfaces'
					let surf_brightness = 0;
					if (x <= 0 ) {
						// fetch texture data
					/*	let si = (floor(frameCount / 1) % img.width + floor((ny * img.height) * 2 % img.height) * img.width) * 4;
						let cr = img.pixels[si + 0];
						let cg = img.pixels[si + 1];
						let cb = img.pixels[si + 2];
						let texRgb = [cr, cg, cb];

						// due to symmetry there is only one real 'side'
						surf_brightness = (brightness(texRgb)*4 * sin(pow(frameCount/1000 * PI * 1.4, 1.1)));
						if (surf_brightness >= 32) { // all that will be not discarded
							surf_brightness *= pow(max(0, 1-frameCount / 100), 0.25);
						}
						
						fill(hue(texRgb), saturation(texRgb),
								 surf_brightness, pow(ny, 0.35) * 1 * min(1, frameCount / 200));*/
						const d = pixelDensity();
						let si = (floor(frameCount * 2) % img2.width + (floor(ny * img2.height ) % img2.height) * img2.width) * 4 * d;
						let cr = img2.pixels[si + 0];
						let cg = img2.pixels[si + 1];
						let cb = img2.pixels[si + 2];
						//let ca = img2.pixels[si + 3];
						
						surf_brightness = (cr + cg + cb) / 3;//sin(pow(frameCount/1000 * PI * 1.4, 1.1)));
						fill(cr, cg, cb, 255);
					} else if (y<= 0) {
						//surf_brightness = 255 * sin(pow(frameCount/1000, 1.1) * PI * 1.5) - (x ^ (y + frameCount * 2)) % 128 * pow(anx, 4);
						//fill(140 + random(0, 32) + (x ^ (y + frameCount * 4)) % 40, 32 + random(0, 32),
						//		 surf_brightness, 1);
					} else {
						// fetch texture data
						const d = pixelDensity();
						let si = (floor(frameCount * 1 * pow(ny, 0.35)) % img.width + (floor(nx * img.height * 1) % img.height) * img.width) * 4 * d;
						let cr = img.pixels[si + 0];
						let cg = img.pixels[si + 1];
						let cb = img.pixels[si + 2];

						surf_brightness = (cr + cg + cb) / 3;//sin(pow(frameCount/1000 * PI * 1.4, 1.1)));
						fill(cr, cg, cb, 255);
					}
					//
					
					// discard apply only on foliage
					if (surf_brightness < 1) {
						continue;
					}
					
					let vw = sw * sx + random(1,1);
					let vh = sh * sy + random(1,1);
					
					let xx = x;
					if (x <= 1) {
						xx += smx;
					}
					
					let yy = y + smy;

					if (y > 0 && x != 0) {
						rect(-width / 2 + width / 2 + (-width / 2 + xx) * sx, -height / 2 + height / 2 + (-height / 2 + yy) * sy, vw, vh);
						//rect(-width / 2 + width - (width / 2 + (-width / 2 + xx) * sx + vw), -height / 2 + height / 2 + (-height / 2 + yy) * sy, vw, vh);
					}
					/*
					if (y < mh) {
						rect(-width / 2 + width / 2 + (-width / 2 + xx) * sx, -height / 2 + height / 2 + (-height / 2 + yy) * sy, vw, vh);
						rect(-width / 2 + width - (width / 2 + (-width / 2 + xx) * sx), -height / 2 + height / 2 + (-height / 2 + yy) * sy, vw, vh);
					}*/
				}
			}
		}
		pop();
	}
	
	xmotion += 0.25;
	ymotion += 0.5;
}

function generate() {
	noStroke();
	
	background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height+64; y += 4) {
		let ny = y / height;
		for (x = 0; x < width+8; x += 1) {
			let nx = x / width;
			let n = noise(nx / 2, ny / 2) / 4;
			let n2 = noise(nx, ny);
			
			let yy = y - n * height/1.5;
			fill(192 + 24 * (n2 * abs(sin(nx * PI * 0.5 + ny * PI * 2 + 0.25))) * abs(0.5 - nx) * 2, 118, (128 + pow(0.5+(ny) * (1-abs(0.5 - nx) * 2), 1.25) * 128), 1);
			rect(x, yy, 4, 5);
		}
	}
	/*
		for (y = 0; y < height/2; y += 2) {
		for (x = 0; x < 32; x += 1) {
			fill(0, 0, 255, 1);
			rect(random(0, width), y, 1, 1);
		}
	}
	*/
	for (y = height/1.85; y > 0; y -= 1) {
		let ny = y / height/1.85;
		for (x = 0; x < width; x += 1) {
			if (random() > 0.75) {
				stroke(0, 0, 0, random(0, 0.05));
				let xx = x + random(-4, 4);
				line(xx, y, xx + random(-6, 6)*ny, y + random(-6, 6)*ny);
			}
		}
	}

	for (y = 0; y < height / 2; y += 1) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 8) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.025);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-100, 100), y + random(-100, 100));
			}
		}
	}
	
	for (y = 0; y < height / 2; y += 1) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 1) {
			let n = noise(x / width, y / height*4);
			if (random() > 0.25 + n) {
				stroke(0, 0, 255, random() * 0.05*n);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-100, 100), y + random(-20, 20));
			}
		}
	}

	
	let wl = 255 * (height / 976);
	let m = 0; // get max y
	for (y = 0; y < (height - m); y += 1) {
		let ny = y / height;
		let noy = noise(ny);
		
		for (x = -32; x < width+32; x += 1) {
			let yy = (height / 2 + noise(x / width) * 8) + y + m;
			
			let nx = x / width;
			let nox = noise(nx * 16, ny * 32);
			let nox2 = (noise(nx*3, ny*3));
			let nox3 = noise(nx / 4, ny / 4);
			let n = (sin(nx * PI * 2.5 + ny * PI * 10 + nox * PI * 20.15)) / 2 * nox2;
			
			if (random() > 0.25) {
				stroke(180 + (nox2) * 20, 140 * nox3, 248*nox3-random(200) * n, random() * 0.45 * pow(ny, 0.1) * pow(0.5+(ny) * (1.-abs(0.5 - nx) * 2), 1.25));
				let xx = x + random(-2, 2);
				line(xx, yy, xx + random(-100, 100) * n * noy * ny + nox3*200*ny, yy + random(-100, 100) * n * ny);
			}
		}
	}
}"
"1114228","Fake raycast texture pier","mySketch","// with texture and discard

let img;
let img2;
function preload() {
  img = loadImage('wood.png');
	img2 = loadImage('fence.png');
}

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
	
	img.loadPixels();
	img2.loadPixels();
	
	//rectMode(CENTER);
	generate();
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	//background(0);
	noStroke();
	//fill(0, 0, 0, 0.05);
	//rect(0, 0, width, height);

	colorMode(RGB, 255, 255, 255);
	
	let planes = 1;

	// the blocks resolution (lower = better)
	let sw = 1;
	let sh = 1;
	
	let xp_offset = 0;
	let yp_offset = 0;
	
	let w = width;
	let h = height;
	
	for (let p = 0; p < planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let ainp = 1-np;
		
		let sf = ainp / 32;
		
		let sx = sf + xmotion/256;
		let sy = sf + xmotion/256;
		
		let mw = w - sw;
		let mh = h - sh;
		
		push();
		translate(width / 2, height / 2);
		rotate((sin(xmotion / 20)/8) * max(0, 1-frameCount/600));
		for (let y = 0; y < h; y += sw) {
			for (let x = 0; x < w; x += sh) {
				if (x <= 0 || x >= w || y <= 0 || y >= mh) { // checkerboard pattern
					let nx = x / w;
					let ny = y / h;
					
					let anx = abs(0.5 - nx) * 2;
					let any = abs(0.5 - ny) * 2;
					
					// surface modulation
					let smx = 0;//(sin(ymotion / 2 * max(0, 1 - pow(0.5 + frameCount/600, 0.25)))) * 100 * anx * max(0, 1-frameCount/400) + 50 * (1- any);
					let smy = 0;//(cos(ymotion / 8 * max(0, 1 - frameCount/400))) * 100 * anx * max(0, 1-frameCount/400);
					
					// shading of the 'surfaces'
					let surf_brightness = 0;
					if (x <= 0 ) {
						// fetch texture data
					/*	let si = (floor(frameCount / 1) % img.width + floor((ny * img.height) * 2 % img.height) * img.width) * 4;
						let cr = img.pixels[si + 0];
						let cg = img.pixels[si + 1];
						let cb = img.pixels[si + 2];
						let texRgb = [cr, cg, cb];

						// due to symmetry there is only one real 'side'
						surf_brightness = (brightness(texRgb)*4 * sin(pow(frameCount/1000 * PI * 1.4, 1.1)));
						if (surf_brightness >= 32) { // all that will be not discarded
							surf_brightness *= pow(max(0, 1-frameCount / 100), 0.25);
						}
						
						fill(hue(texRgb), saturation(texRgb),
								 surf_brightness, pow(ny, 0.35) * 1 * min(1, frameCount / 200));*/
						const d = pixelDensity();
						let si = (floor(frameCount * 2 * pow(max(1, frameCount / 800) + 0.01, 0.735)) % img2.width + (floor(ny * img2.height ) % img2.height) * img2.width) * 4 * d;
						let cr = img2.pixels[si + 0];
						let cg = img2.pixels[si + 1];
						let cb = img2.pixels[si + 2];
						//let ca = img2.pixels[si + 3];
						
						surf_brightness = (cr + cg + cb) / 3;//sin(pow(frameCount/1000 * PI * 1.4, 1.1)));
						fill(cr, cg, cb, 255);
					} else if (y<= 0) {
						//surf_brightness = 255 * sin(pow(frameCount/1000, 1.1) * PI * 1.5) - (x ^ (y + frameCount * 2)) % 128 * pow(anx, 4);
						//fill(140 + random(0, 32) + (x ^ (y + frameCount * 4)) % 40, 32 + random(0, 32),
						//		 surf_brightness, 1);
					} else {
						// fetch texture data
						const d = pixelDensity();
						let si = (floor(frameCount * 1 * pow(ny, 0.35)) % img.width + (floor(nx * img.height * 1) % img.height) * img.width) * 4 * d;
						let cr = img.pixels[si + 0];
						let cg = img.pixels[si + 1];
						let cb = img.pixels[si + 2];

						surf_brightness = (cr + cg + cb) / 3;//sin(pow(frameCount/1000 * PI * 1.4, 1.1)));
						fill(cr, cg, cb, 255);
					}
					//
					
					// discard apply only on foliage
					if (surf_brightness < 1) {
						continue;
					}
					
					let vw = sw * sx + random(1, 2);
					let vh = sh * sy + random(1, 2);
					
					let xx = x;
					if (x <= 1) {
						xx += smx;
					}
					
					let yy = y + smy;

					if (y > 0 && x != 0) {
						rect(-width / 2 + width / 2 + (-width / 2 + xx) * sx, -height / 2 + height / 2 + (-height / 2 + yy) * sy, vw, vh);
						//rect(-width / 2 + width - (width / 2 + (-width / 2 + xx) * sx + vw), -height / 2 + height / 2 + (-height / 2 + yy) * sy, vw, vh);
					}
					
					if (y < mh) {
						rect(-width / 2 + width / 2 + (-width / 2 + xx) * sx, -height / 2 + height / 2 + (-height / 2 + yy) * sy, vw, vh);
						rect(-width / 2 + width - (width / 2 + (-width / 2 + xx) * sx), -height / 2 + height / 2 + (-height / 2 + yy) * sy, vw, vh);
					}
				}
			}
		}
		pop();
	}
	
	xmotion += 0.25;
	ymotion += 0.5;
}

function generate() {
	noStroke();
	
	background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height+64; y += 4) {
		let ny = y / height;
		for (x = 0; x < width+8; x += 1) {
			let nx = x / width;
			let n = noise(nx / 2, ny / 2) / 4;
			let n2 = noise(nx, ny);
			
			let yy = y - n * height/1.5;
			fill(192 + 24 * (n2 * abs(sin(nx * PI * 0.5 + ny * PI * 2 + 0.25))) * abs(0.5 - nx) * 2, 118, (128 + pow(0.5+(ny) * (1-abs(0.5 - nx) * 2), 1.25) * 128), 1);
			rect(x, yy, 4, 5);
		}
	}
	/*
		for (y = 0; y < height/2; y += 2) {
		for (x = 0; x < 32; x += 1) {
			fill(0, 0, 255, 1);
			rect(random(0, width), y, 1, 1);
		}
	}
	*/
	for (y = height/1.85; y > 0; y -= 1) {
		let ny = y / height/1.85;
		for (x = 0; x < width; x += 1) {
			if (random() > 0.75) {
				stroke(0, 0, 0, random(0, 0.05));
				let xx = x + random(-4, 4);
				line(xx, y, xx + random(-6, 6)*ny, y + random(-6, 6)*ny);
			}
		}
	}

	for (y = 0; y < height / 2; y += 1) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 8) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.025);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-100, 100), y + random(-100, 100));
			}
		}
	}
	
	for (y = 0; y < height / 2; y += 1) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 1) {
			let n = noise(x / width, y / height*4);
			if (random() > 0.25 + n) {
				stroke(0, 0, 255, random() * 0.05*n);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-100, 100), y + random(-20, 20));
			}
		}
	}

	
	let wl = 255 * (height / 976);
	let m = 0; // get max y
	for (y = 0; y < (height - m); y += 1) {
		let ny = y / height;
		let noy = noise(ny);
		
		for (x = -32; x < width+32; x += 1) {
			let yy = (height / 2 + noise(x / width) * 8) + y + m;
			
			let nx = x / width;
			let nox = noise(nx * 16, ny * 32);
			let nox2 = (noise(nx*3, ny*3));
			let nox3 = noise(nx / 4, ny / 4);
			let n = (sin(nx * PI * 2.5 + ny * PI * 10 + nox * PI * 20.15)) / 2 * nox2;
			
			if (random() > 0.25) {
				stroke(180 + (nox2) * 20, 140 * nox3, 248*nox3-random(200) * n, random() * 0.45 * pow(ny, 0.1) * pow(0.5+(ny) * (1.-abs(0.5 - nx) * 2), 1.25));
				let xx = x + random(-2, 2);
				line(xx, yy, xx + random(-100, 100) * n * noy * ny + nox3*200*ny, yy + random(-100, 100) * n * ny);
			}
		}
	}
}"
"1114114","Fake raycast texture + noise","mySketch","// code size optimized / cleaned up mininal fake raycast (with x axis symmetry)
// with logical operators texture and generated background sky from a previous sketch
// note : became more complex than previously thought but its still somewhat the clean and generic version

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
	
	//rectMode(CENTER);
	//generate();
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	//background(0);
	noStroke();
	//fill(0, 0, 0, 0.05);
	//rect(0, 0, width, height);

	let planes = 1;

	// the blocks resolution (lower = better)
	let sw = 10;
	let sh = 10;
	
	let xp_offset = 0;
	let yp_offset = 0;
	
	let w = width;
	let h = height;
	
	for (let p = 0; p < planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let ainp = 1-np;
		
		let sf = ainp / 256;
		
		let sx = sf + xmotion/128;
		let sy = sf + xmotion/128;
		
		let mw = w - sw;
		let mh = h - sh;
		
		push();
		translate(width / 2, height / 2);
		rotate((sin(xmotion / 5)/6) * max(0, 1-frameCount/600));
		for (let y = 0; y < h; y += sw) {
			for (let x = 0; x < w / 2; x += sh) {
				if (x <= 0 || x >= w / 2 || y <= 0 || y >= mh) { // checkerboard pattern
					let nx = x / w;
					let ny = y / h;
					
					let anx = abs(0.5 - nx) * 2;
					let any = abs(0.5 - ny) * 2;
					
					// surface modulation
					let smx = (sin(ymotion / 2 * max(0, 1 - pow(0.5 + frameCount/600, 0.25)))) * 100 * anx * max(0, 1-frameCount/1000) + 50 * (1- any);
					let smy = (cos(ymotion / 8 * max(0, 1 - frameCount/400))) * 100 * anx * max(0, 1-frameCount/400);
				
					// shading of the 'surfaces'
					let brightness = 0;
					if (x <= 0 ) {
						// due to symmetry there is only one real 'side'
						brightness = 255 * sin(pow(frameCount/1000 * PI * 2, 1.1)) - noise(ny*16, frameCount / 10) * 128;
						fill(48 + 128 * (1 - ny) + random(0, 24) + (y ^ (x + frameCount / 4)) % 40, 32 + random(0, 64),
								 brightness, 1);
					} else if (y<= 0) {
						brightness = 255 * sin(pow(frameCount/1000, 1.1) * PI * 2) - (x ^ (y + frameCount * 2)) % 128 * pow(anx, 4);
						fill(140 + random(0, 32) + (x ^ (y + frameCount * 4)) % 40, 32 + random(0, 32),
								 brightness, 1);
					} else {
						brightness = 255 * sin(pow(frameCount/1000, 1.1) * PI * 2) - (x ^ (y + frameCount * 2)) % 128 * pow(anx, 4) - noise(nx*16, frameCount / 10) * 64;
						fill(0 + random(0, 32) + (x ^ (y + frameCount * 4)) % 40, 32 + random(0, 32),
								 brightness, 1);
					}
					//
					/*
					if (brightness < 1) {
						continue;
					}
					*/
					let vw = sw * sx;
					let vh = sh * sy;
					
					let xx = x;
					if (x <= 0) {
						xx += smx;
					}
					
					let yy = y + smy;

					if (y > 0) {
						rect(-width / 2 + width / 2 + (-width / 2 + xx) * sx, -height / 2 + height / 2 + (-height / 2 + yy) * sy, vw, vh);
						rect(-width / 2 + width - (width / 2 + (-width / 2 + xx) * sx + vw), -height / 2 + height / 2 + (-height / 2 + yy) * sy, vw, vh);
					}
				}
			}
		}
		pop();
	}
	
	xmotion += 0.25;
	ymotion += 0.5;
}

function generate() {
	noStroke();
	
	background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 2) {
		let ny = y / height;
		for (x = 0; x < width+8; x += 1) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx, ny);
			
			let yy = height / 3.1 + y - n * height;
			fill(200 + 25 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.5 + ny * PI * 2 + 0.25))), 118, (128 + pow(0.5+(ny) * (1-abs(0.5 - nx) * 2), 1.25) * 128), 1);
			rect(x, yy, 4, 5);
		}
	}
	
	for (y = height/1.85; y > 0; y -= 1) {
		let ny = y / height/1.85;
		for (x = 0; x < width; x += 1) {
			if (random() > 0.75) {
				stroke(0, 0, 0, random(0, 0.05));
				let xx = x + random(-4, 4);
				line(xx, y, xx + random(-6, 6)*ny, y + random(-6, 6)*ny);
			}
		}
	}

	for (y = 0; y < height / 2; y += 1) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 8) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.05);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-100, 100), y + random(-100, 100));
			}
		}
	}
	
	for (y = 0; y < height / 2; y += 1) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 1) {
			let n = noise(x / width, y / height*4);
			if (random() > 0.25 + n) {
				stroke(0, 0, 255, random() * 0.0075*n);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-100, 100), y + random(-20, 20));
			}
		}
	}
	
	for (y = 0; y < height / 2; y += 16) {
		let ny = y / height;
		let noy = noise(ny);
		for (x = 0; x < width; x += 3) {
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = noise(nx, ny);
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2 * nox2;

			let yy = y;

			if (random() > 0.998) {
				stroke(0, 0, 0, 1);
				strokeWeight(0.5);
				let tx = x + random(1, 6);
				let ty = yy + random(1, 6);
				line(x, yy, tx, ty);
				line(tx, ty, tx + random(1, 4) * (1-ny), ty - random(1, 1) * (1-ny));
			}
		}
	}
}"
"1112919","Fake raycast rt 2","mySketch","// realtime version (heavily mirrored)

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
	
	//rectMode(CENTER);
	//draw_sky();
}

let zmotion = 0;


function draw() {
	//background(0);
	noStroke();
	fill(0, 0, 0, 0.35);
	rect(0, 0, width, height);
let xmotion = 0;
let ymotion = 0;
	
	for (let i = 0; i < 100; i += 1) {
		let ni = i / 100;

		// the blocks resolution (lower = better)
		let sw = 20;
		let sh = 20;

		let xp_offset = 0;
		let yp_offset = 0;

		let w = width;
		let h = height;

		let sf = 0.25;

		let sx = sf + xmotion/42;
		let sy = sf + xmotion/42;

		let mw = w - sw;
		let mh = h - sh;
		
		push();
		translate(width / 2, height / 2);
		rotate((sin(xmotion / 5 + zmotion / 100)/6) + ni);
		for (let x = 0; x < w/2; x += sh) {
			let nx = x / (w/2);
			
			let anx = abs(0.5 - nx) * 2;
			let smx = (sin(xmotion / 50 + zmotion / 100 + anx * PI * 2)) * anx * 100;
			let smy = (cos(xmotion / 50 + zmotion / 100 + anx * PI * 2)) * anx * 100;
			
			let brightness = 0;
						brightness = 255 * abs(sin(zmotion / 100 * ni * PI * 0.25) * anx);
						fill(200+(x + xmotion) ^ (i * 2 + zmotion / 1) % 170, 128,
								 brightness, 1);
			
			let vw = sw * sx * 3;
			let vh = sh * sy * 3;
			
			let xx = x;
			if (x <= 0) {
				xx += smx;
			}
			
			if (brightness < 16) {
				continue;
			}
			
			let yy = 0 + smy;
			
			rect(-width / 2 + width / 2 + (-width / 2 + xx) * sx, -height / 2 + height / 2 + (-height / 2 + yy) * sy, vw, vh);
			rect(-width / 2 + width - (width / 2 + (-width / 2 + xx) * sx), -height / 2 + height / 2 + (-height / 2 + yy) * sy, vw, vh);
			rect(-width / 2 + width / 2 + (-width / 2 + xx) * sx, -height / 2 + height - (height / 2 + (-height / 2 + yy) * sy), vw, vh);
			rect(-width / 2 + width - (width / 2 + (-width / 2 + xx) * sx), -height / 2 + height - (height / 2 + (-height / 2 + yy) * sy), vw, vh);
			
			rect(-height / 2 + height / 2 + (-height / 2 + yy) * sy, -width / 2 + width / 2 + (-width / 2 + xx) * sx, vw, vh);
			rect(-height / 2 + height / 2 + (-height / 2 + yy) * sy, -width / 2 + width - (width / 2 + (-width / 2 + xx) * sx), vw, vh);
			rect(-height / 2 + height - (height / 2 + (-height / 2 + yy) * sy), -width / 2 + width / 2 + (-width / 2 + xx) * sx, vw, vh);
			rect(-height / 2 + height - (height / 2 + (-height / 2 + yy) * sy), -width / 2 + width - (width / 2 + (-width / 2 + xx) * sx), vw, vh);
		}
		pop();
	/*
		for (let y = 0; y < h; y += sw) {
			for (let x = 0; x < w / 2; x += sh) {
				if (x <= 0 || x >= w / 2 || y <= 0 || y >= mh) { // checkerboard pattern
					let nx = x / w;
					let ny = y / h;

					let anx = abs(0.5 - nx) * 2;
					let any = abs(0.5 - ny) * 2;

					// surface modulation
					let smx = (sin(ymotion / 2 * max(0, 1 - pow(0.5 + i/600, 0.25)))) * 100 * anx * max(0, 1-i/1000) + 50 * (1- any);
					let smy = (sin(ymotion / 8 * max(0, 1 - i/400))) * 100 * anx * max(0, 1-i/400);

					// shading of the 'surfaces'
					let brightness = 0;
					if (x <= 0 ) {
						// due to symmetry there is only one real 'side'
						brightness = 255 * sin(i/1000 * PI * 2) - (y & (x + i / 3 + zmotion)) % 128 * abs(smx / 16 + 0.5);
						fill(140 + 40 * (1 - ny) + random(0, 32) + (y ^ (x + i / 4)) % 40, 32 + random(0, 64),
								 brightness, 1 * pow(any * (1- any), 0.1));
					} else if (y<= 0) {
						brightness = 255 * sin(pow(i/1000, 1.1) * PI * 2) - (x ^ (y + i * 2)) % 128 * pow(anx, 4);
						fill(140 + random(0, 32) + (x ^ (y + i * 4)) % 40, 32 + random(0, 32),
								 brightness, 1);
					} else {
						brightness = 255 * sin(pow(i/1000, 1.1) * PI * 2) - (x ^ (y + i * 2)) % 128 * pow(anx, 4);
						fill(140 + random(0, 32) + (x ^ (y + i * 4)) % 40, 32 + random(0, 32),
								 brightness, 1);
					}
					//
					
					//if (brightness < 1) {
					//	continue;
					//}
					
					let vw = sw * sx;
					let vh = sh * sy;

					let xx = x;
					if (x <= 0) {
						xx += smx;
					}

					let yy = y + smy;
*/
					//if (y > 0) {
//						rect(/*-width / 2 +*/ width / 2 + (-width / 2 + xx) * sx, /*-height / 2 + */height / 2 + (-height / 2 + yy) * sy, vw, vh);
//						rect(/*-width / 2 +*/ width - (width / 2 + (-width / 2 + xx) * sx + vw), /*-height / 2 + */height / 2 + (-height / 2 + yy) * sy, vw, vh);
					//}
			//	}
		//	}
		
	//	}
		//pop();
		
		xmotion += 0.5;
		ymotion += 0.5;
	}
	
	zmotion += 4.5;
}

function draw_sky() {
	noStroke();
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width+8; x += 1) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12) / 4;
			let n2 = noise(nx, ny);
			
			let yy = y - n * (height * 3.75);
			fill(200 + 25 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.5 + ny * PI * 2 + 0.25))) * abs(0.5 - nx) * 2, 118, (128 + pow(ny, 1) * 128), 1);
			rect(x, yy, 4, 5);
		}
	}

	for (y = height/1.85; y > 0; y -= 1) {
		let ny = y / height/1.85;
		for (x = 0; x < width; x += 1) {
			if (random() > 0.75) {
				stroke(0, 0, 0, random(0, 0.05));
				let xx = x + random(-4, 4);
				line(xx, y, xx + random(-6, 6)*ny, y + random(-6, 6)*ny);
			}
		}
	}
	
	for (y = 0; y < height / 2; y += 1) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 8) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.05);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-100, 100), y + random(-100, 100));
			}
		}
	}
	
	for (y = 0; y < height / 2; y += 1) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 1) {
			let n = noise(x / width, y / height*4);
			if (random() > 0.25 + n) {
				stroke(0, 0, 255, random() * 0.0075*n);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-100, 100), y + random(-20, 20));
			}
		}
	}
	
	for (y = 0; y < height / 2; y += 16) {
		let ny = y / height;
		let noy = noise(ny);
		for (x = 0; x < width; x += 3) {
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = noise(nx, ny);
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2 * nox2;

			let yy = y;

			if (random() > 0.999) {
				stroke(0, 0, 0, 1);
				strokeWeight(0.5 + random() / 2);
				let tx = x + random(1, 6);
				let ty = yy + random(1, 6);
				line(x, yy, tx, ty);
				line(tx, ty, tx + random(1, 4) * (1-ny), ty - random(1, 4) * (1-ny));
			}
		}
	}
}"
"1112909","Fake raycast rt","mySketch","// realtime version (heavily mirrored)

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
	
	//rectMode(CENTER);
	//draw_sky();
}

let zmotion = 0;


function draw() {
	//background(0);
	noStroke();
	fill(0, 0, 0, 0.35);
	rect(0, 0, width, height);
let xmotion = 0;
let ymotion = 0;
	
	for (let i = 0; i < 100; i += 1) {
		let ni = i / 100;

		// the blocks resolution (lower = better)
		let sw = 10;
		let sh = 10;

		let xp_offset = 0;
		let yp_offset = 0;

		let w = width;
		let h = height;

		let sf = 0.25;

		let sx = sf + xmotion/48;
		let sy = sf + xmotion/48;

		let mw = w - sw;
		let mh = h - sh;
		
		push();
		translate(width / 2, height / 2);
		rotate((sin(xmotion / 5)/6) + ni + zmotion / 100 + cos(zmotion / 200));
		for (let x = 0; x < w/2; x += sh) {
			let nx = x / (w/2);
			
			let anx = abs(0.5 - nx) * 2;
			let smx = (sin(xmotion / 50 + zmotion / 100 + anx * PI * 2)) * anx * 100;
			let smy = (cos(xmotion / 50 + zmotion / 100 + anx * PI * 2)) * anx * 100;
			
			let brightness = 0;
						brightness = 255 * abs(sin(zmotion / 100 * ni * PI * 0.25) * anx) - ((x + xmotion) ^ (i * 4 + zmotion * 2)) % 128;
						fill(200+(x + xmotion) ^ (i * 1 + zmotion / 2) % 170, 128,
								 brightness, 1);
			
			let vw = sw * sx * 3;
			let vh = sh * sy * 3;
			
			let xx = x;
			if (x <= 0) {
				xx += smx;
			}
			
			if (brightness < 16) {
				continue;
			}
			
			let yy = 0 + smy;
			
			rect(-width / 2 + width / 2 + (-width / 2 + xx) * sx, -height / 2 + height / 2 + (-height / 2 + yy) * sy, vw, vh);
			rect(-width / 2 + width - (width / 2 + (-width / 2 + xx) * sx), -height / 2 + height / 2 + (-height / 2 + yy) * sy, vw, vh);
			rect(-width / 2 + width / 2 + (-width / 2 + xx) * sx, -height / 2 + height - (height / 2 + (-height / 2 + yy) * sy), vw, vh);
			rect(-width / 2 + width - (width / 2 + (-width / 2 + xx) * sx), -height / 2 + height - (height / 2 + (-height / 2 + yy) * sy), vw, vh);
			
			rect(-height / 2 + height / 2 + (-height / 2 + yy) * sy, -width / 2 + width / 2 + (-width / 2 + xx) * sx, vw, vh);
			rect(-height / 2 + height / 2 + (-height / 2 + yy) * sy, -width / 2 + width - (width / 2 + (-width / 2 + xx) * sx), vw, vh);
			rect(-height / 2 + height - (height / 2 + (-height / 2 + yy) * sy), -width / 2 + width / 2 + (-width / 2 + xx) * sx, vw, vh);
			rect(-height / 2 + height - (height / 2 + (-height / 2 + yy) * sy), -width / 2 + width - (width / 2 + (-width / 2 + xx) * sx), vw, vh);
		}
		pop();
	/*
		for (let y = 0; y < h; y += sw) {
			for (let x = 0; x < w / 2; x += sh) {
				if (x <= 0 || x >= w / 2 || y <= 0 || y >= mh) { // checkerboard pattern
					let nx = x / w;
					let ny = y / h;

					let anx = abs(0.5 - nx) * 2;
					let any = abs(0.5 - ny) * 2;

					// surface modulation
					let smx = (sin(ymotion / 2 * max(0, 1 - pow(0.5 + i/600, 0.25)))) * 100 * anx * max(0, 1-i/1000) + 50 * (1- any);
					let smy = (sin(ymotion / 8 * max(0, 1 - i/400))) * 100 * anx * max(0, 1-i/400);

					// shading of the 'surfaces'
					let brightness = 0;
					if (x <= 0 ) {
						// due to symmetry there is only one real 'side'
						brightness = 255 * sin(i/1000 * PI * 2) - (y & (x + i / 3 + zmotion)) % 128 * abs(smx / 16 + 0.5);
						fill(140 + 40 * (1 - ny) + random(0, 32) + (y ^ (x + i / 4)) % 40, 32 + random(0, 64),
								 brightness, 1 * pow(any * (1- any), 0.1));
					} else if (y<= 0) {
						brightness = 255 * sin(pow(i/1000, 1.1) * PI * 2) - (x ^ (y + i * 2)) % 128 * pow(anx, 4);
						fill(140 + random(0, 32) + (x ^ (y + i * 4)) % 40, 32 + random(0, 32),
								 brightness, 1);
					} else {
						brightness = 255 * sin(pow(i/1000, 1.1) * PI * 2) - (x ^ (y + i * 2)) % 128 * pow(anx, 4);
						fill(140 + random(0, 32) + (x ^ (y + i * 4)) % 40, 32 + random(0, 32),
								 brightness, 1);
					}
					//
					
					//if (brightness < 1) {
					//	continue;
					//}
					
					let vw = sw * sx;
					let vh = sh * sy;

					let xx = x;
					if (x <= 0) {
						xx += smx;
					}

					let yy = y + smy;
*/
					//if (y > 0) {
//						rect(/*-width / 2 +*/ width / 2 + (-width / 2 + xx) * sx, /*-height / 2 + */height / 2 + (-height / 2 + yy) * sy, vw, vh);
//						rect(/*-width / 2 +*/ width - (width / 2 + (-width / 2 + xx) * sx + vw), /*-height / 2 + */height / 2 + (-height / 2 + yy) * sy, vw, vh);
					//}
			//	}
		//	}
		
	//	}
		//pop();
		
		xmotion += 0.5;
		ymotion += 0.5;
	}
	
	zmotion += 4.5;
}

function draw_sky() {
	noStroke();
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width+8; x += 1) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12) / 4;
			let n2 = noise(nx, ny);
			
			let yy = y - n * (height * 3.75);
			fill(200 + 25 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.5 + ny * PI * 2 + 0.25))) * abs(0.5 - nx) * 2, 118, (128 + pow(ny, 1) * 128), 1);
			rect(x, yy, 4, 5);
		}
	}

	for (y = height/1.85; y > 0; y -= 1) {
		let ny = y / height/1.85;
		for (x = 0; x < width; x += 1) {
			if (random() > 0.75) {
				stroke(0, 0, 0, random(0, 0.05));
				let xx = x + random(-4, 4);
				line(xx, y, xx + random(-6, 6)*ny, y + random(-6, 6)*ny);
			}
		}
	}
	
	for (y = 0; y < height / 2; y += 1) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 8) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.05);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-100, 100), y + random(-100, 100));
			}
		}
	}
	
	for (y = 0; y < height / 2; y += 1) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 1) {
			let n = noise(x / width, y / height*4);
			if (random() > 0.25 + n) {
				stroke(0, 0, 255, random() * 0.0075*n);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-100, 100), y + random(-20, 20));
			}
		}
	}
	
	for (y = 0; y < height / 2; y += 16) {
		let ny = y / height;
		let noy = noise(ny);
		for (x = 0; x < width; x += 3) {
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = noise(nx, ny);
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2 * nox2;

			let yy = y;

			if (random() > 0.999) {
				stroke(0, 0, 0, 1);
				strokeWeight(0.5 + random() / 2);
				let tx = x + random(1, 6);
				let ty = yy + random(1, 6);
				line(x, yy, tx, ty);
				line(tx, ty, tx + random(1, 4) * (1-ny), ty - random(1, 4) * (1-ny));
			}
		}
	}
}"
"1112792","Sea landscape 2","mySketch","// code size optimized / cleaned up mininal fake raycast (with x axis symmetry)
// with logical operators texture and generated background sky from a previous sketch
// note : became more complex than previously thought but its still somewhat the clean and generic version

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
	
	//rectMode(CENTER);
	draw_background();
}

let xmotion = 0;
let ymotion = 0;

function draw() {

}

function draw_background() {
	noStroke();
	
	background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height+64; y += 4) {
		let ny = y / height;
		for (x = 0; x < width+8; x += 1) {
			let nx = x / width;
			let n = noise(nx / 2, ny / 2) / 4;
			let n2 = noise(nx, ny);
			
			let yy = y - n * height/1.5;
			fill(192 + 24 * (n2 * abs(sin(nx * PI * 0.5 + ny * PI * 2 + 0.25))) * abs(0.5 - nx) * 2, 118, (128 + pow(0.5+(abs(0.5-ny)*2) * (1-abs(0.5 - nx) * 2), 1.25) * 128), 1);
			rect(x, yy, 4, 5);
		}
	}
	/*
		for (y = 0; y < height/2; y += 2) {
		for (x = 0; x < 32; x += 1) {
			fill(0, 0, 255, 1);
			rect(random(0, width), y, 1, 1);
		}
	}
	*/
	for (y = height/1.85; y > 0; y -= 1) {
		let ny = y / height/1.85;
		for (x = 0; x < width; x += 1) {
			if (random() > 0.75) {
				stroke(0, 0, 0, random(0, 0.05));
				let xx = x + random(-4, 4);
				line(xx, y, xx + random(-6, 6)*ny, y + random(-6, 6)*ny);
			}
		}
	}

	for (y = 0; y < height / 2; y += 1) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 8) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.025);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-100, 100), y + random(-100, 100));
			}
		}
	}
	
	for (y = 0; y < height / 2; y += 1) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 1) {
			let n = noise(x / width, y / height*4);
			if (random() > 0.25 + n) {
				stroke(0, 0, 255, random() * 0.05*n);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-100, 100), y + random(-20, 20));
			}
		}
	}

	
	let wl = 255 * (height / 976);
	let m = 0; // get max y
	for (y = 0; y < (height - m); y += 1) {
		let ny = y / height;
		let noy = noise(ny);
		
		for (x = -32; x < width+32; x += 1) {
			let yy = (height / 2 + noise(x / width) * 8) + y + m;
			
			let nx = x / width;
			let nox = noise(nx * 16, ny * 32);
			let nox2 = (noise(nx*3, ny*3));
			let nox3 = noise(nx / 4, ny / 4);
			let n = (sin(nx * PI * 2.5 + ny * PI * 10 + nox * PI * 20.15)) / 2 * nox2;
			
			if (random() > 0.25) {
				stroke(180 + (nox2) * 20, 140 * nox3, 248*nox3-random(200) * n, random() * 0.45 * pow(ny, 0.1) * pow(0.5+(ny) * (1.-abs(0.5 - nx) * 2), 1.25));
				let xx = x + random(-2, 2);
				line(xx, yy, xx + random(-100, 100) * n * noy * ny + nox3*200*ny, yy + random(-100, 100) * n * ny);
			}
		}
	}
}"
"1112706","Sea landscape","mySketch","// code size optimized / cleaned up mininal fake raycast (with x axis symmetry)
// with logical operators texture and generated background sky from a previous sketch
// note : became more complex than previously thought but its still somewhat the clean and generic version

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
	
	//rectMode(CENTER);
	draw_background();
}

let xmotion = 0;
let ymotion = 0;

function draw() {

}

function draw_background() {
	noStroke();
	
	background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height+64; y += 4) {
		let ny = y / height;
		for (x = 0; x < width+8; x += 1) {
			let nx = x / width;
			let n = noise(nx / 2, ny / 2) / 4;
			let n2 = noise(nx, ny);
			
			let yy = y - n * height/2;
			fill(192 + 42 * (n2 * abs(sin(nx * PI * 0.5 + ny * PI * 2 + 0.25))) * abs(0.5 - nx) * 2, 118, (128 + pow(0.5+(ny%0.5) * (1-abs(0.5 - nx) * 2), 2.25) * 128), 1);
			rect(x, yy, 4, 5);
		}
	}
	
		for (y = 0; y < height/2.35; y += 2) {
		for (x = 0; x < 32; x += 1) {
			fill(0, 0, 255, 1);
			rect(random(0, width), y, 1, 1);
		}
	}
	
	for (y = height/1.85; y > 0; y -= 1) {
		let ny = y / height/1.85;
		for (x = 0; x < width; x += 1) {
			if (random() > 0.75) {
				stroke(0, 0, 0, random(0, 0.05));
				let xx = x + random(-4, 4);
				line(xx, y, xx + random(-6, 6)*ny, y + random(-6, 6)*ny);
			}
		}
	}

	for (y = 0; y < height / 2; y += 1) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 8) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.025);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-100, 100), y + random(-100, 100));
			}
		}
	}
	
	for (y = 0; y < height / 2; y += 1) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 1) {
			let n = noise(x / width, y / height*4);
			if (random() > 0.25 + n) {
				stroke(0, 0, 255, random() * 0.05*n);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-100, 100), y + random(-20, 20));
			}
		}
	}

	
	let wl = 255 * (height / 976);
	let m = 0; // get max y
	for (y = 0; y < (height - m); y += 1) {
		let ny = y / height;
		let noy = noise(ny);
		
		for (x = -32; x < width+32; x += 1) {
			let yy = (height / 2 + noise(x / width) * 8) + y + m;
			
			let nx = x / width;
			let nox = noise(nx * 16, ny * 32);
			let nox2 = (noise(nx*3, ny*3));
			let nox3 = noise(nx / 4, ny / 4);
			let n = (sin(nx * PI * 2.5 + ny * PI * 10 + nox * PI * 20.15)) / 2 * nox2;
			
			if (random() > 0.25) {
				stroke(180 + (nox2) * 20, 140 * nox3, 248*nox3-random(200) * n, random() * 0.45 * pow(ny, 0.3));
				let xx = x + random(-2, 2);
				line(xx, yy, xx + random(-100, 100) * n * noy * ny + nox3*200*ny, yy + random(-100, 100) * n * ny);
			}
		}
	}

	for (y = 0; y < height / 2; y += 16) {
		let ny = y / height;
		let noy = noise(ny);
		for (x = 0; x < width; x += 3) {
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = noise(nx, ny);
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2 * nox2;

			let yy = y;

			if (random() > 0.9991) {
				stroke(0, 0, 0, 1);
				strokeWeight(0.5);
				let tx = x + random(1, 6);
				let ty = yy + random(1, 6);
				line(x, yy, tx, ty);
				line(tx, ty, tx + random(1, 4) * (1-ny), ty - random(1, 1) * (1-ny));
			}
		}
	}
}"
"1112683","Fake raycast minimal dist","mySketch","// code size optimized / cleaned up mininal fake raycast (with x axis symmetry)
// with logical operators texture and generated background sky from a previous sketch
// note : became more complex than previously thought but its still somewhat the clean and generic version

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
	
	//rectMode(CENTER);
	//draw_sky();
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	//background(0);
	noStroke();
	//fill(0, 0, 0, 0.05);
	//rect(0, 0, width, height);

	let planes = 1;

	// the blocks resolution (lower = better)
	let sw = 10;
	let sh = 10;
	
	let xp_offset = 0;
	let yp_offset = 0;
	
	let w = width;
	let h = height;
	
	for (let p = 0; p < planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let ainp = 1-np;
		
		let sf = ainp / 256;
		
		let sx = sf + xmotion/128;
		let sy = sf + xmotion/128;
		
		let mw = w - sw;
		let mh = h - sh;
		
		push();
		translate(width / 2, height / 2);
		rotate((sin(xmotion / 5)/6) * max(0, 1-frameCount/600));
		for (let y = 0; y < h; y += sw) {
			for (let x = 0; x < w / 2; x += sh) {
				if (x <= 0 || x >= w / 2 || y <= 0 || y >= mh) { // checkerboard pattern
					let nx = x / w;
					let ny = y / h;
					
					let anx = abs(0.5 - nx) * 2;
					let any = abs(0.5 - ny) * 2;
					
					// surface modulation
					let smx = (sin(ymotion / 2 * max(0, 1 - pow(0.5 + frameCount/600, 0.25)))) * 100 * anx * max(0, 1-frameCount/1000) + 50 * (1- any);
					let smy = (sin(ymotion / 8 * max(0, 1 - frameCount/400))) * 100 * anx * max(0, 1-frameCount/400);
				
					// shading of the 'surfaces'
					let brightness = 0;
					if (x <= 0 ) {
						// due to symmetry there is only one real 'side'
						brightness = 255 * sin(frameCount/1000 * PI * 2) - (y & (x + frameCount / 3)) % 128 * abs(smx / 16 + 0.5);
						fill(140 + 40 * (1 - ny) + random(0, 32) + (y ^ (x + frameCount / 4)) % 40, 32 + random(0, 64),
								 brightness, 1 * pow(any * (1- any), 0.1));
					} else if (y<= 0) {
						brightness = 255 * sin(pow(frameCount/1000, 1.1) * PI * 2) - (x ^ (y + frameCount * 2)) % 128 * pow(anx, 4);
						fill(140 + random(0, 32) + (x ^ (y + frameCount * 4)) % 40, 32 + random(0, 32),
								 brightness, 1);
					} else {
						brightness = 255 * sin(pow(frameCount/1000, 1.1) * PI * 2) - (x ^ (y + frameCount * 2)) % 128 * pow(anx, 4);
						fill(140 + random(0, 32) + (x ^ (y + frameCount * 4)) % 40, 32 + random(0, 32),
								 brightness, 1);
					}
					//
					/*
					if (brightness < 1) {
						continue;
					}
					*/
					let vw = sw * sx;
					let vh = sh * sy;
					
					let xx = x;
					if (x <= 0) {
						xx += smx;
					}
					
					let yy = y + smy;

					//if (y > 0) {
						rect(-width / 2 + width / 2 + (-width / 2 + xx) * sx, -height / 2 + height / 2 + (-height / 2 + yy) * sy, vw, vh);
						rect(-width / 2 + width - (width / 2 + (-width / 2 + xx) * sx + vw), -height / 2 + height / 2 + (-height / 2 + yy) * sy, vw, vh);
					//}
				}
			}
		}
		pop();
	}
	
	xmotion += 0.25;
	ymotion += 0.5;
}

function draw_sky() {
	noStroke();
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width+8; x += 1) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12) / 4;
			let n2 = noise(nx, ny);
			
			let yy = y - n * (height * 3.75);
			fill(200 + 25 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.5 + ny * PI * 2 + 0.25))) * abs(0.5 - nx) * 2, 118, (128 + pow(ny, 1) * 128), 1);
			rect(x, yy, 4, 5);
		}
	}

	for (y = height/1.85; y > 0; y -= 1) {
		let ny = y / height/1.85;
		for (x = 0; x < width; x += 1) {
			if (random() > 0.75) {
				stroke(0, 0, 0, random(0, 0.05));
				let xx = x + random(-4, 4);
				line(xx, y, xx + random(-6, 6)*ny, y + random(-6, 6)*ny);
			}
		}
	}
	
	for (y = 0; y < height / 2; y += 1) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 8) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.05);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-100, 100), y + random(-100, 100));
			}
		}
	}
	
	for (y = 0; y < height / 2; y += 1) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 1) {
			let n = noise(x / width, y / height*4);
			if (random() > 0.25 + n) {
				stroke(0, 0, 255, random() * 0.0075*n);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-100, 100), y + random(-20, 20));
			}
		}
	}
	
	for (y = 0; y < height / 2; y += 16) {
		let ny = y / height;
		let noy = noise(ny);
		for (x = 0; x < width; x += 3) {
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = noise(nx, ny);
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2 * nox2;

			let yy = y;

			if (random() > 0.999) {
				stroke(0, 0, 0, 1);
				strokeWeight(0.5 + random() / 2);
				let tx = x + random(1, 6);
				let ty = yy + random(1, 6);
				line(x, yy, tx, ty);
				line(tx, ty, tx + random(1, 4) * (1-ny), ty - random(1, 4) * (1-ny));
			}
		}
	}
}"
"1112265","Fake raycast sea / land background","mySketch","// code size optimized / cleaned up mininal fake raycast (with x axis symmetry)
// with logical operators texture and generated background
// added sea / sky background from my other sketches with ceil and value discard
// note : became more complex than previously thought but its still somewhat the clean and generic version

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
	
	//rectMode(CENTER);
	draw_background();
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	//background(0);
	noStroke();
	//fill(0, 0, 0, 0.05);
	//rect(0, 0, width, height);

	let planes = 1;

	// the blocks resolution (lower = better)
	let sw = 10;
	let sh = 10;
	
	let xp_offset = 0;
	let yp_offset = 0;
	
	let w = width;
	let h = height;
	
	for (let p = 0; p < planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let ainp = 1-np;
		
		let sf = ainp / 256;
		
		let sx = sf + xmotion/128;
		let sy = sf + xmotion/128;
		
		let mw = w - sw;
		let mh = h - sh;
		
		for (let y = 0; y < h; y += sw) {
			for (let x = 0; x < w / 2; x += sh) {
				if (x <= 0 || x >= w / 2 || y <= 0 || y >= mh) { // checkerboard pattern
					let nx = x / w;
					let ny = y / h;
					
					let anx = abs(0.5 - nx) * 2;
					let any = abs(0.5 - ny) * 2;
					
					// surface modulation
					let smx = (sin(ymotion / 2 * max(0, 1 - pow(0.5 + frameCount/600, 0.25)))) * 100 * anx * max(0, 1-frameCount/1000);
					let smy = (sin(ymotion / 8 * max(0, 1 - frameCount/400))) * 100 * anx * max(0, 1-frameCount/400);
				
					// shading of the 'surfaces'
					let brightness = 0;
					if (x <= 0 ) {
						// due to symmetry there is only one real 'side'
						brightness = 255-255 * sin(pow(frameCount/2000, 1) * PI * 2) - (y & (x + frameCount / 4)) % 128 * abs(smx / 16 + 0.5);
						fill(100 * (1 - ny) + random(0, 32) + (y ^ (x + frameCount * 4)) % 40, 32 + random(0, 128),
								 brightness, 1 * pow(ny, 0.25));
					} else if (y<= 0) {
						/*brightness = 255-255 * sin(pow(frameCount/2000, 1) * PI * 2) - (x & (y + frameCount / 4)) % 128 * abs(smy / 16 + 0.5);
						fill(100 * (1 - nx) + random(0, 32) + (x ^ (y + frameCount * 4)) % 40, 32 + random(0, 128),
								 brightness, 1);*/
					} else {
						brightness = 255 * sin(pow(frameCount/1000, 1.1) * PI * 2) - (x ^ (y + frameCount * 2)) % 128 * pow(anx, 4);
						fill(0 + random(0, 32) + (x ^ (y + frameCount * 4)) % 40, 32 + random(0, 128),
								 brightness, 1);
					}
					//
					
					if (brightness < 1) {
						continue;
					}
					
					let vw = sw * sx;
					let vh = sh * sy;
					
					let xx = x;
					if (x <= 0) {
						xx += smx;
					}
					
					let yy = y + smy;

					//if (y > 0) {
						rect(width / 2 + (-width / 2 + xx) * sx, height / 2 + (-height / 2 + yy) * sy, vw, vh);
						rect(width - (width / 2 + (-width / 2 + xx) * sx + vw), height / 2 + (-height / 2 + yy) * sy, vw, vh);
					//}
				}
			}
		}
	}
	
	xmotion += 0.25;
	ymotion += 0.5;
}

function draw_background() {
	noStroke();
	
	background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height+64; y += 4) {
		let ny = y / height;
		for (x = 0; x < width+8; x += 1) {
			let nx = x / width;
			let n = noise(nx / 2, ny / 2) / 4;
			let n2 = noise(nx, ny);
			
			let yy = y - n * height/2;
			fill(192 + 42 * (n2 * abs(sin(nx * PI * 0.5 + ny * PI * 2 + 0.25))) * abs(0.5 - nx) * 2, 118, (128 + pow(0.5+(ny%0.5) * (1-abs(0.5 - nx) * 2), 0.25) * 128), 1);
			rect(x, yy, 4, 5);
		}
	}
	
	for (y = height/1.85; y > 0; y -= 1) {
		let ny = y / height/1.85;
		for (x = 0; x < width; x += 1) {
			if (random() > 0.75) {
				stroke(0, 0, 0, random(0, 0.05));
				let xx = x + random(-4, 4);
				line(xx, y, xx + random(-6, 6)*ny, y + random(-6, 6)*ny);
			}
		}
	}

	for (y = 0; y < height / 2; y += 1) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 8) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.025);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-100, 100), y + random(-100, 100));
			}
		}
	}
	
	for (y = 0; y < height / 2; y += 1) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 1) {
			let n = noise(x / width, y / height*4);
			if (random() > 0.25 + n) {
				stroke(0, 0, 255, random() * 0.05*n);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-100, 100), y + random(-20, 20));
			}
		}
	}
	
	for (y = 0; y < height / 3; y += 2) {
		for (x = 0; x < 32; x += 1) {
			fill(0, 0, 255, 1);
			rect(random(0, width), y, 1, 1);
		}
	}
	
	let wl = 255 * (height / 976);
	let m = 0; // get max y
	for (y = 0; y < (height - m); y += 1) {
		let ny = y / height;
		let noy = noise(ny);
		
		for (x = -32; x < width+32; x += 1) {
			let yy = (height / 2 + noise(x / width) * 8) + y + m;
			
			let nx = x / width;
			let nox = noise(nx * 16, ny * 32);
			let nox2 = (noise(nx*3, ny*3));
			let nox3 = noise(nx / 4, ny / 4);
			let n = (sin(nx * PI * 2.5 + ny * PI * 10 + nox * PI * 20.15)) / 2 * nox2;
			
			if (random() > 0.25) {
				stroke(180 + (nox2) * 20, 140 * nox3, 248*nox3-random(200) * n, random() * 0.45 * pow(ny, 0.3));
				let xx = x + random(-2, 2);
				line(xx, yy, xx + random(-100, 100) * n * noy * ny + nox3*200*ny, yy + random(-100, 100) * n * ny);
			}
		}
	}

	for (y = 0; y < height / 2; y += 16) {
		let ny = y / height;
		let noy = noise(ny);
		for (x = 0; x < width; x += 3) {
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = noise(nx, ny);
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2 * nox2;

			let yy = y;

			if (random() > 0.9991) {
				stroke(0, 0, 0, 1);
				strokeWeight(0.5);
				let tx = x + random(1, 6);
				let ty = yy + random(1, 6);
				line(x, yy, tx, ty);
				line(tx, ty, tx + random(1, 4) * (1-ny), ty - random(1, 1) * (1-ny));
			}
		}
	}
}"
"1112255","Fake raycast sea background + ceiling","mySketch","// code size optimized / cleaned up mininal fake raycast (with x axis symmetry)
// with logical operators texture and generated background
// added sea / sky background from my other sketches with ceil and value discard
// note : became more complex than previously thought but its still somewhat the clean and generic version

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
	
	//rectMode(CENTER);
	draw_background();
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	//background(0);
	noStroke();
	//fill(0, 0, 0, 0.05);
	//rect(0, 0, width, height);

	let planes = 1;

	// the blocks resolution (lower = better)
	let sw = 10;
	let sh = 10;
	
	let xp_offset = 0;
	let yp_offset = 0;
	
	let w = width;
	let h = height;
	
	for (let p = 0; p < planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let ainp = 1-np;
		
		let sf = ainp / 256;
		
		let sx = sf + xmotion/128;
		let sy = sf + xmotion/128;
		
		let mw = w - sw;
		let mh = h - sh;
		
		for (let y = 0; y < h; y += sw) {
			for (let x = 0; x < w / 2; x += sh) {
				if (x <= 0 || x >= w / 2 || y <= 0 || y >= mh) { // checkerboard pattern
					let nx = x / w;
					let ny = y / h;
					
					let anx = abs(0.5 - nx) * 2;
					let any = abs(0.5 - ny) * 2;
					
					// surface modulation
					let smx = (sin(ymotion / 2 * max(0, 1 - pow(0.5 + frameCount/600, 0.25)))) * 100 * anx * max(0, 1-frameCount/1000);
					let smy = (sin(ymotion / 8 * max(0, 1 - frameCount/400))) * 100 * anx * max(0, 1-frameCount/400);
				
					// shading of the 'surfaces'
					let brightness = 0;
					if (x <= 0 ) {
						// due to symmetry there is only one real 'side'
						brightness = 255-255 * sin(pow(frameCount/2000, 1) * PI * 2) - (y & (x + frameCount / 4)) % 128 * abs(smx / 16 + 0.5);
						fill(100 * (1 - ny) + random(0, 32) + (y ^ (x + frameCount * 4)) % 40, 32 + random(0, 128),
								 brightness, 1 * pow(ny, 0.25));
					} else if (y<= 0) {
						brightness = 255-255 * sin(pow(frameCount/2000, 1) * PI * 2) - (x & (y + frameCount / 4)) % 128 * abs(smy / 16 + 0.5);
						fill(100 * (1 - nx) + random(0, 32) + (x ^ (y + frameCount * 4)) % 40, 32 + random(0, 128),
								 brightness, 1);
					} else {
						brightness = 255 * sin(pow(frameCount/1000, 1.1) * PI * 2) - (x ^ (y + frameCount * 2)) % 128 * pow(anx, 4);
						fill(0 + random(0, 32) + (x ^ (y + frameCount * 4)) % 40, 32 + random(0, 128),
								 brightness, 1);
					}
					//
					
					if (brightness < 1) {
						continue;
					}
					
					let vw = sw * sx;
					let vh = sh * sy;
					
					let xx = x;
					if (x <= 0) {
						xx += smx;
					}
					
					let yy = y + smy;

					//if (y > 0) {
						rect(width / 2 + (-width / 2 + xx) * sx, height / 2 + (-height / 2 + yy) * sy, vw, vh);
						rect(width - (width / 2 + (-width / 2 + xx) * sx + vw), height / 2 + (-height / 2 + yy) * sy, vw, vh);
					//}
				}
			}
		}
	}
	
	xmotion += 0.25;
	ymotion += 0.5;
}

function draw_background() {
	noStroke();
	
	background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height+64; y += 4) {
		let ny = y / height;
		for (x = 0; x < width+8; x += 1) {
			let nx = x / width;
			let n = noise(nx / 2, ny / 2) / 4;
			let n2 = noise(nx, ny);
			
			let yy = y - n * height/2;
			fill(190 + 24 * (n2 * abs(sin(nx * PI * 0.5 + ny * PI * 2 + 0.25))) * abs(0.5 - nx) * 2, 118, (128 + pow(1-(ny) * (abs(0.5 - nx) * 2), 1.25) * 128), 1);
			rect(x, yy, 4, 5);
		}
	}
	
	for (y = height/1.85; y > 0; y -= 1) {
		let ny = y / height/1.85;
		for (x = 0; x < width; x += 1) {
			if (random() > 0.75) {
				stroke(0, 0, 0, random(0, 0.05));
				let xx = x + random(-4, 4);
				line(xx, y, xx + random(-6, 6)*ny, y + random(-6, 6)*ny);
			}
		}
	}

	for (y = 0; y < height / 2; y += 1) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 8) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.025);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-100, 100), y + random(-100, 100));
			}
		}
	}
	
	for (y = 0; y < height / 2; y += 1) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 1) {
			let n = noise(x / width, y / height*4);
			if (random() > 0.25 + n) {
				stroke(0, 0, 255, random() * 0.05*n);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-100, 100), y + random(-20, 20));
			}
		}
	}
	
	let wl = 255 * (height / 976);
	let m = 0; // get max y
	for (y = 0; y < (height - m); y += 1) {
		let ny = y / height;
		let noy = noise(ny);
		
		for (x = -32; x < width+32; x += 1) {
			let yy = (height / 2 + noise(x / width) * 8) + y + m;
			
			let nx = x / width;
			let nox = noise(nx * 16, ny * 32);
			let nox2 = (noise(nx*3, ny*3));
			let nox3 = noise(nx / 4, ny / 4);
			let n = (sin(nx * PI * 2.5 + ny * PI * 10 + nox * PI * 20.15)) / 2 * nox2;
			
			if (random() > 0.25) {
				stroke(180 + (nox2) * 20, 140 * nox3, 248*nox3-random(200) * n, random() * 0.45 * pow(ny, 0.3));
				let xx = x + random(-2, 2);
				line(xx, yy, xx + random(-100, 100) * n * noy * ny + nox3*200*ny, yy + random(-100, 100) * n * ny);
			}
		}
	}

	for (y = 0; y < height / 2; y += 16) {
		let ny = y / height;
		let noy = noise(ny);
		for (x = 0; x < width; x += 3) {
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = noise(nx, ny);
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2 * nox2;

			let yy = y;

			if (random() > 0.9991) {
				stroke(0, 0, 0, 1);
				strokeWeight(0.5);
				let tx = x + random(1, 6);
				let ty = yy + random(1, 6);
				line(x, yy, tx, ty);
				line(tx, ty, tx + random(1, 4) * (1-ny), ty - random(1, 1) * (1-ny));
			}
		}
	}
}"
"1111486","Fake raycast minimal 4","mySketch","// code size optimized / cleaned up mininal fake raycast (with x axis symmetry)
// with logical operators texture

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
	
	//rectMode(CENTER);
	for (y = 0; y < height; y += 1) {
		let ny = y / height;
		let any = ny * 2 - 1;
		for (x = 0; x < width; x += 1) {
			fill(220 + any * 20, 148, 255 + 64 * any, 1);
			rect(x, y, 4, 4);
		}
	}
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	//background(0);
	noStroke();
	//fill(0, 0, 0, 0.05);
	//rect(0, 0, width, height);
	/*
	var context = drawingContext
	context.shadowOffsetX = sin(xmotion*2)/2;
	context.shadowOffsetY = cos(ymotion*2)/2;
	context.shadowBlur = 1; // more can be fun also
	context.shadowColor = ""rgba(0, 0, 0, 0.25)"";
	*/
	let planes = 1;

	// the blocks resolution (lower = better)
	let sw = 10;
	let sh = 10;
	
	let xp_offset = 0;
	let yp_offset = 0;
	
	let w = width;
	let h = height;
	
	for (let p = 0; p < planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let ainp = pow(np, 0.5);
		
		let sf = pow(ainp, 1) / 256;
		
		let sx = sf + xmotion/128;
		let sy = sf + xmotion/128;
		
		let mw = w - sw;
		let mh = h - sh;
		
		for (let y = 0; y < h; y += sw) {
			for (let x = 0; x < w / 2; x += sh) {
				if (x <= 0 || x >= w / 2 || y <= 0 || y >= mh) { // checkerboard pattern
					let nx = x / w;
					let ny = y / h;
					
					let anx = abs(0.5 - nx) * 2;
					let any = abs(0.5 - ny) * 2;
					
					// surface modulation
					let smx = 1;//(sin(ymotion / 1 * max(0, 1 - pow(0.5 + frameCount/200, 0.75)))) * 100 * anx * min(1, frameCount/100);
					let smy = (sin(ymotion / 8 * max(0, 1 - frameCount/800))) * 100 * anx * max(0, 1-frameCount/400);
				
					// shading of the 'surfaces'
					let brightness = 0;
					if (x <= 0 ) {
						// due to symmetry there is only one real 'side'
						brightness = 255-255 * sin(pow(frameCount/2000, 1.1) * PI * 1.5) - (y & (x + frameCount + (2 + (np + 1) * 8))) % 255 * abs(smx / 2 + 0.5);
						fill(100 * (1 - ny) + random(0, 32) + (y & (x + frameCount * 2)) % 40, 32 + random(0, 128),
								 brightness, 1 * pow(ny, 0.25));
					} else if (y<= 0) {

					} else {
						brightness = 255 * sin(pow(frameCount/2000, 1.1) * PI * 1.5) - (x & (x + frameCount / 64)) % 255;
						fill(100 * (1 - ny) + random(0, 32) + (y & (x + frameCount * 2)) % 40, 32 + random(0, 128),
								 brightness, 1 * pow(ny, 0.25));
					}
					//
					
					if (brightness < 1) {
						continue;
					}
					
					let vw = sw * sx * 8 + 1;
					let vh = sh * sy + 1;
					
					let xx = x;
					if (x <= 0) {
						xx += smx;
					}
					
					let yy = y + smy;

					if (y > 0) {
						rect(width / 2 + (-width / 2 + xx) * sx + np * width / 24, height / 2 + (-height / 2 + yy) * sy - height / 32 + np * height / 4, vw, vh);
						rect(width - (width / 2 + (-width / 2 + xx) * sx + vw) - np * width / 24, height / 2 + (-height / 2 + yy) * sy - height / 32 + np * height / 4, vw, vh);
					}
				}
			}
		}
	}
	
	xmotion += 0.25;
	ymotion += 0.5;
}

function draw_sky() {
	noStroke();
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height+64; y += 4) {
		let ny = y / height;
		for (x = 0; x < width+8; x += 1) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12) / 4;
			let n2 = noise(nx, ny);
			
			let yy = y - n * height/2;
			fill(190 + 64 * (n2 * abs(sin(nx * PI * 0.5 + ny * PI * 2 + 0.25))) * abs(0.5 - nx) * 2, 118, (128 + pow(1-(ny) * (abs(0.5 - nx) * 2), 1.25) * 128), 1);
			rect(x, yy, 4, 5);
		}
	}

	for (y = height; y > 0; y -= 1) {
		let ny = y / height;
		for (x = 0; x < width; x += 1) {
			if (random() > 0.75) {
				stroke(0, 0, 0, random(0, 0.05));
				let xx = x + random(-4, 4);
				line(xx, y, xx + random(-6, 6)*ny, y + random(-6, 6)*ny);
			}
		}
	}
	
	for (y = 0; y < height; y += 1) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 8) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.05);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-100, 100), y + random(-100, 100));
			}
		}
	}
	
	for (y = 0; y < height; y += 1) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 1) {
			let n = noise(x / width, y / height*4);
			if (random() > 0.25 + n) {
				stroke(0, 0, 255, random() * 0.0075*n);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-100, 100), y + random(-20, 20));
			}
		}
	}
	
	for (y = 0; y < height / 2; y += 16) {
		let ny = y / height;
		let noy = noise(ny);
		for (x = 0; x < width; x += 3) {
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = noise(nx, ny);
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2 * nox2;

			let yy = y;

			if (random() > 0.995) {
				stroke(0, 0, 0, 1);
				strokeWeight(0.5 + random() / 2);
				let tx = x + random(1, 6) * (1-ny);
				let ty = yy + random(1, 6) * (1-ny);
				line(x, yy, tx, ty);
				line(tx, ty, tx + random(1, 6) * (1-ny), ty - random(1, 6) * (1-ny));
			}
		}
	}
}"
"1111461","Fake raycast minimal layering 3","mySketch","// code size optimized / cleaned up mininal fake raycast (with x axis symmetry)
// with logical operators texture

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
	
	//rectMode(CENTER);
	draw_sky();
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	//background(0);
	noStroke();
	//fill(0, 0, 0, 0.05);
	//rect(0, 0, width, height);
	/*
	var context = drawingContext
	context.shadowOffsetX = sin(xmotion*2)/2;
	context.shadowOffsetY = cos(ymotion*2)/2;
	context.shadowBlur = 1; // more can be fun also
	context.shadowColor = ""rgba(0, 0, 0, 0.25)"";
	*/
	let planes = 4;

	// the blocks resolution (lower = better)
	let sw = 10;
	let sh = 10;
	
	let xp_offset = 0;
	let yp_offset = 0;
	
	let w = width;
	let h = height;
	
	for (let p = 0; p < planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let ainp = pow(np, 0.5);
		
		let sf = pow(ainp, 1) / 256;
		
		let sx = sf + xmotion/128;
		let sy = sf + xmotion/128;
		
		let mw = w - sw;
		let mh = h - sh;
		
		for (let y = 0; y < h; y += sw) {
			for (let x = 0; x < w / 2; x += sh) {
				if (x <= 0 || x >= w / 2 || y <= 0 || y >= mh) { // checkerboard pattern
					let nx = x / w;
					let ny = y / h;
					
					let anx = abs(0.5 - nx) * 2;
					let any = abs(0.5 - ny) * 2;
					
					// surface modulation
					let smx = 1;//(sin(ymotion / 1 * max(0, 1 - pow(0.5 + frameCount/200, 0.75)))) * 100 * anx * min(1, frameCount/100);
					let smy = (sin(ymotion / 8 * max(0, 1 - frameCount/800))) * 100 * anx * max(0, 1-frameCount/400);
				
					// shading of the 'surfaces'
					let brightness = 0;
					if (x <= 0 ) {
						// due to symmetry there is only one real 'side'
						brightness = 255-255 * sin(pow(frameCount/2000, 1.1) * PI * 1.5) - (y & (x / 64 + frameCount + (2 + (np + 1) * 8))) % 255 * abs(smx / 2 + 0.5);
						fill(100 * (1 - ny) + random(0, 32) + (y & (x + frameCount * 2)) % 40, 32 + random(0, 128),
								 brightness, 1 * pow(ny, 0.25));
					} else if (y<= 0) {

					} else {
						brightness = 255-255 * sin(1.5+pow(frameCount/2200, 1.1) * PI * 1) - (x & (y + frameCount * 1)) % 128;
						fill(100 * (1 - ny) + random(0, 32) + (y ^ (x + frameCount * 4)) % 40, 32 + random(0, 128),
								 brightness, 1);
					}
					//
					
					if (brightness < 1) {
						continue;
					}
					
					let vw = sw * sx + 1;
					let vh = sh * sy + 1;
					
					let xx = x;
					if (x <= 0) {
						xx += smx;
					}
					
					let yy = y + smy;

					if (y > 0) {
						rect(width / 2.15 + (-width / 2 + xx) * sx + np * width / 24, height / 2 + (-height / 2 + yy) * sy - height / 32 + np * height / 4, vw, vh);
						rect(width - (width / 2.15 + (-width / 2 + xx) * sx + vw) - np * width / 24, height / 2 + (-height / 2 + yy) * sy - height / 32 + np * height / 4, vw, vh);
					}
				}
			}
		}
	}
	
	xmotion += 0.25;
	ymotion += 0.5;
}

function draw_sky() {
	noStroke();
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height+64; y += 4) {
		let ny = y / height;
		for (x = 0; x < width+8; x += 1) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12) / 4;
			let n2 = noise(nx, ny);
			
			let yy = y - n * height/2;
			fill(190 + 64 * (n2 * abs(sin(nx * PI * 0.5 + ny * PI * 2 + 0.25))) * abs(0.5 - nx) * 2, 118, (128 + pow(1-(ny) * (abs(0.5 - nx) * 2), 1.25) * 128), 1);
			rect(x, yy, 4, 5);
		}
	}

	for (y = height; y > 0; y -= 1) {
		let ny = y / height;
		for (x = 0; x < width; x += 1) {
			if (random() > 0.75) {
				stroke(0, 0, 0, random(0, 0.05));
				let xx = x + random(-4, 4);
				line(xx, y, xx + random(-6, 6)*ny, y + random(-6, 6)*ny);
			}
		}
	}
	
	for (y = 0; y < height; y += 1) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 8) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.05);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-100, 100), y + random(-100, 100));
			}
		}
	}
	
	for (y = 0; y < height; y += 1) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 1) {
			let n = noise(x / width, y / height*4);
			if (random() > 0.25 + n) {
				stroke(0, 0, 255, random() * 0.0075*n);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-100, 100), y + random(-20, 20));
			}
		}
	}
	
	for (y = 0; y < height / 2; y += 16) {
		let ny = y / height;
		let noy = noise(ny);
		for (x = 0; x < width; x += 3) {
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = noise(nx, ny);
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2 * nox2;

			let yy = y;

			if (random() > 0.995) {
				stroke(0, 0, 0, 1);
				strokeWeight(0.5 + random() / 2);
				let tx = x + random(1, 6) * (1-ny);
				let ty = yy + random(1, 6) * (1-ny);
				line(x, yy, tx, ty);
				line(tx, ty, tx + random(1, 6) * (1-ny), ty - random(1, 6) * (1-ny));
			}
		}
	}
}"
"1111359","Fake raycast minimal layering","mySketch","// code size optimized / cleaned up mininal fake raycast (with x axis symmetry)
// with logical operators texture

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
	
	//rectMode(CENTER);
	//draw_sky();
	for (y = 0; y < height; y += 1) {
		let ny = y / height;
		let any = ny * 2 - 1;
		for (x = 0; x < width; x += 1) {
			fill(220 + any * 20, 148, 255 + 64 * any, 1);
			rect(x, y, 4, 4);
		}
	}
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	//background(0);
	noStroke();
	//fill(0, 0, 0, 0.05);
	//rect(0, 0, width, height);
	/*
	var context = drawingContext
	context.shadowOffsetX = sin(xmotion*2)/2;
	context.shadowOffsetY = cos(ymotion*2)/2;
	context.shadowBlur = 1; // more can be fun also
	context.shadowColor = ""rgba(0, 0, 0, 0.25)"";
	*/
	let planes = 8;

	// the blocks resolution (lower = better)
	let sw = 2;
	let sh = 2;
	
	let xp_offset = 0;
	let yp_offset = 0;
	
	let w = width;
	let h = height;
	
	for (let p = 0; p < planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let ainp = abs(0.5 - np) * 2;
		
		let sf = np / 200;
		
		let sx = sf + xmotion/128;
		let sy = sf + xmotion/128;
		
		let mw = w - sw;
		let mh = h - sh;
		
		for (let y = 0; y < h; y += sw) {
			//for (let x = 0; x < w / 2; x += sh) {
			let x = 0;
				if (x <= 0 || x >= w / 2 || y <= 0 || y >= mh) { // checkerboard pattern
					let nx = x / w;
					let ny = y / h;
					
					let anx = abs(0.5 - nx) * 2;
					let any = abs(0.5 - ny) * 2;
					
					// surface modulation
					let smx = (sin(ymotion / 2 * max(0, 1 - pow(0.5 + frameCount/100, 0.75)))) * 100 * anx * max(0, 1-frameCount/1000);
					let smy = sin(ymotion / 8 * max(0, 1 - frameCount/1000)) * 100 * anx * max(0, 1-frameCount/1000);
				
					// shading of the 'surfaces'
					let brightness = 0;
					if (x <= 0 ) {
						// due to symmetry there is only one real 'side'
						brightness = 255-255 * (sin(frameCount/300 * anx*8) / 2) - (y | (y + frameCount * 1)) % 128 * abs(anx / 2 + 0.5);
						fill(100 * (1 - anx) + random(0, 32) + (y & (x + frameCount * 1)) % 40, 32 + random(0, 128),
								 brightness, 1);
					} else if (y<= 0) {
					/*	brightness = 255-255 * sin(1.5+pow(frameCount/2200, 1.1) * PI * 1) - (x & (y + frameCount * 1)) % 128;
						fill(100 * (1 - ny) + random(0, 32) + (y ^ (x + frameCount * 4)) % 40, 32 + random(0, 128),
								 brightness, 1);*/
					} else {
					/*	brightness = 255 - 255 * sin(frameCount / 1000 * PI * 2.) - (x & (x + frameCount * 8)) % 255;
						fill(100 * (1 - ny) + random(0, 32) + (x ^ (x + frameCount * 8)) % 40, 32 + random(0, 128),
								 brightness, 1);*/
					}
					//
					/*
					if (brightness < 1 || brightness > 254) {
						continue;
					}
					*/
					let vw = sw * sx;
					let vh = sh * sy;
					
					let xx = x;
					//if (x <= 0) {
						xx += smx;
					//}
					
					let yy = y + smy;

					//if (y > 0) {
					rect(width / 2 + (-width / 2 + xx) * sx, (height / 2 + (-height / 2 + yy) * sy), vw, vh);
					rect(width - (width / 2 + (-width / 2 + xx) * sx + vw), height - (height / 2 + (-height / 2 + yy) * sy), vw, vh);
					rect(height / 2 + (-height / 2 + yy) * sy, width - (width / 2 + (-width / 2 + xx) * sx + vw), vw, vh);
					rect(height - (height / 2 + (-height / 2 + yy) * sy), width / 2 + (-width / 2 + xx) * sx, vw, vh);
					//}
				
			}
		}
	}
	
	xmotion += 0.5;
	ymotion += 0.25;
}

function draw_sky() {
	noStroke();
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height+64; y += 4) {
		let ny = y / height;
		for (x = 0; x < width+8; x += 1) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12) / 4;
			let n2 = noise(nx, ny);
			
			let yy = y - n * height/2;
			fill(200 + 25 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.5 + ny * PI * 2 + 0.25))) * abs(0.5 - nx) * 2, 118, (128 + pow(ny+0.45, 4.5) * 128), 1);
			rect(x, yy, 4, 5);
		}
	}

	for (y = height; y > 0; y -= 1) {
		let ny = y / height;
		for (x = 0; x < width; x += 1) {
			if (random() > 0.75) {
				stroke(0, 0, 0, random(0, 0.05));
				let xx = x + random(-4, 4);
				line(xx, y, xx + random(-6, 6)*ny, y + random(-6, 6)*ny);
			}
		}
	}
	
	for (y = 0; y < height; y += 1) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 8) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.05);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-100, 100), y + random(-100, 100));
			}
		}
	}
	
	for (y = 0; y < height; y += 1) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 1) {
			let n = noise(x / width, y / height*4);
			if (random() > 0.25 + n) {
				stroke(0, 0, 255, random() * 0.0075*n);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-100, 100), y + random(-20, 20));
			}
		}
	}
	
	for (y = 0; y < height / 2; y += 16) {
		let ny = y / height;
		let noy = noise(ny);
		for (x = 0; x < width; x += 3) {
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = noise(nx, ny);
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2 * nox2;

			let yy = y;

			if (random() > 0.999) {
				stroke(0, 0, 0, 1);
				strokeWeight(0.5 + random() / 2);
				let tx = x + random(1, 6);
				let ty = yy + random(1, 6);
				line(x, yy, tx, ty);
				line(tx, ty, tx + random(1, 4) * (1-ny), ty - random(1, 4) * (1-ny));
			}
		}
	}
}"
"1111083","Fake raycast minimal layering 2","mySketch","// code size optimized / cleaned up mininal fake raycast (with x axis symmetry)
// with logical operators texture

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
	
	//rectMode(CENTER);
	draw_sky();
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	//background(0);
	noStroke();
	//fill(0, 0, 0, 0.05);
	//rect(0, 0, width, height);
	/*
	var context = drawingContext
	context.shadowOffsetX = sin(xmotion*2)/2;
	context.shadowOffsetY = cos(ymotion*2)/2;
	context.shadowBlur = 1; // more can be fun also
	context.shadowColor = ""rgba(0, 0, 0, 0.25)"";
	*/
	let planes = 4;

	// the blocks resolution (lower = better)
	let sw = 10;
	let sh = 10;
	
	let xp_offset = 0;
	let yp_offset = 0;
	
	let w = width;
	let h = height;
	
	for (let p = 0; p < planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let ainp = 1-np;
		
		let sf = pow(ainp*2, 1) / 256;
		
		let sx = sf + xmotion/128;
		let sy = sf + xmotion/128;
		
		let mw = w - sw;
		let mh = h - sh;
		
		for (let y = 0; y < h; y += sw) {
			for (let x = 0; x < w / 2; x += sh) {
				if (x <= 0 || x >= w / 2 || y <= 0 || y >= mh) { // checkerboard pattern
					let nx = x / w;
					let ny = y / h;
					
					let anx = abs(0.5 - nx) * 2;
					let any = abs(0.5 - ny) * 2;
					
					// surface modulation
					let smx = (sin(ymotion / 2 * max(0, 1 - pow(0.5 + frameCount/100, 0.75)))) * 100 * anx * max(0, 1-frameCount/1000);
					let smy = (sin(ymotion / 8 * max(0, 1 - frameCount/400))) * 100 * anx * max(0, 1-frameCount/400);
				
					// shading of the 'surfaces'
					let brightness = 0;
					if (x <= 0 ) {
						// due to symmetry there is only one real 'side'
						brightness = 255 * sin(pow(frameCount/2000, 1.1) * PI * 1.5) - (y & (y + frameCount * (1 - (np + 1) * 4))) % 255 * abs(smx / 16 + 0.5);
						fill(100 * (1 - ny) + random(0, 32) + (y ^ (x + frameCount * 4)) % 40, 32 + random(0, 128),
								 brightness, 1 * pow(ny, 0.25));
					} else if (y<= 0) {
						/*brightness = 255-255 * sin(1.5+pow(frameCount/2000, 1.1) * PI * 2) - (x & (y + frameCount * 2)) % 128;
						fill(100 * (1 - ny) + random(0, 32) + (y ^ (x + frameCount * 4)) % 40, 32 + random(0, 128),
								 brightness, 1);*/
					} else {
						brightness = 255-255 * (sin(1.5+pow(frameCount/1200, 1.1) * PI * 4)) - (x & (x + frameCount * 2)) % 128;
						fill(0 * (1 - ny) + random(0, 32) + (y ^ (x + frameCount * 4)) % 40, 32 + random(0, 128),
								 brightness, 1 * pow(ny, 0.5));
					}
					//
					
					if (brightness < 1 || brightness > 250) {
						continue;
					}
					
					let vw = sw * sx;
					let vh = sh * sy;
					
					let xx = x;
					if (x <= 0) {
						xx += smx;
					}
					
					let yy = y + smy;

					if (y > 0) {
						rect(width / 2 + (-width / 2 + xx) * sx - np * width / 16, height / 2 + (-height / 2 + yy) * sy - height / 4 + ainp * height / 2, vw, vh);
						rect(width - (width / 2 + (-width / 2 + xx) * sx + vw) + np * width / 16, height / 2 + (-height / 2 + yy) * sy - height / 4 + np * height / 2, vw, vh);
					}
				}
			}
		}
	}
	
	xmotion += 0.25;
	ymotion += 0.5;
}

function draw_sky() {
	noStroke();
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height+64; y += 4) {
		let ny = y / height;
		for (x = 0; x < width+8; x += 1) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12) / 4;
			let n2 = noise(nx, ny);
			
			let yy = y - n * height/2;
			fill(200 + 25 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.5 + ny * PI * 2 + 0.25))) * abs(0.5 - nx) * 2, 118, (128 + pow(ny+0.45, 4.5) * 128), 1);
			rect(x, yy, 4, 5);
		}
	}

	for (y = height; y > 0; y -= 1) {
		let ny = y / height;
		for (x = 0; x < width; x += 1) {
			if (random() > 0.75) {
				stroke(0, 0, 0, random(0, 0.05));
				let xx = x + random(-4, 4);
				line(xx, y, xx + random(-6, 6)*ny, y + random(-6, 6)*ny);
			}
		}
	}
	
	for (y = 0; y < height; y += 1) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 8) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.05);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-100, 100), y + random(-100, 100));
			}
		}
	}
	
	for (y = 0; y < height; y += 1) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 1) {
			let n = noise(x / width, y / height*4);
			if (random() > 0.25 + n) {
				stroke(0, 0, 255, random() * 0.0075*n);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-100, 100), y + random(-20, 20));
			}
		}
	}
	
	for (y = 0; y < height / 2; y += 16) {
		let ny = y / height;
		let noy = noise(ny);
		for (x = 0; x < width; x += 3) {
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = noise(nx, ny);
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2 * nox2;

			let yy = y;

			if (random() > 0.999) {
				stroke(0, 0, 0, 1);
				strokeWeight(0.5 + random() / 2);
				let tx = x + random(1, 6);
				let ty = yy + random(1, 6);
				line(x, yy, tx, ty);
				line(tx, ty, tx + random(1, 4) * (1-ny), ty - random(1, 4) * (1-ny));
			}
		}
	}
}"
"1111051","Fake raycast minimal layering","mySketch","// code size optimized / cleaned up mininal fake raycast (with x axis symmetry)
// with logical operators texture

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
	
	//rectMode(CENTER);
	draw_sky();
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	//background(0);
	noStroke();
	//fill(0, 0, 0, 0.05);
	//rect(0, 0, width, height);
	/*
	var context = drawingContext
	context.shadowOffsetX = sin(xmotion*2)/2;
	context.shadowOffsetY = cos(ymotion*2)/2;
	context.shadowBlur = 1; // more can be fun also
	context.shadowColor = ""rgba(0, 0, 0, 0.25)"";
	*/
	let planes = 4;

	// the blocks resolution (lower = better)
	let sw = 10;
	let sh = 10;
	
	let xp_offset = 0;
	let yp_offset = 0;
	
	let w = width;
	let h = height;
	
	for (let p = 0; p < planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let ainp = 1-np;
		
		let sf = pow(ainp*2, 1) / 256;
		
		let sx = sf + xmotion/128;
		let sy = sf + xmotion/128;
		
		let mw = w - sw;
		let mh = h - sh;
		
		for (let y = 0; y < h; y += sw) {
			for (let x = 0; x < w / 2; x += sh) {
				if (x <= 0 || x >= w / 2 || y <= 0 || y >= mh) { // checkerboard pattern
					let nx = x / w;
					let ny = y / h;
					
					let anx = abs(0.5 - nx) * 2;
					let any = abs(0.5 - ny) * 2;
					
					// surface modulation
					let smx = (sin(ymotion / 2 * max(0, 1 - pow(0.5 + frameCount/100, 0.75)))) * 100 * anx * max(0, 1-frameCount/1000);
					let smy = (sin(ymotion / 8 * max(0, 1 - frameCount/400))) * 100 * anx * max(0, 1-frameCount/400);
				
					// shading of the 'surfaces'
					let brightness = 0;
					if (x <= 0 ) {
						// due to symmetry there is only one real 'side'
						brightness = 255-255 * sin(pow(frameCount/2000, 1.1) * PI * 1.5) - (y & (y + frameCount * (6 + (np + 1) * 2))) % 255 * abs(smx / 16 + 0.5);
						fill(100 * (1 - ny) + random(0, 32) + (y ^ (x + frameCount * 4)) % 40, 32 + random(0, 128),
								 brightness, 1 * pow(ny, 0.25));
					} else if (y<= 0) {
						/*brightness = 255-255 * sin(1.5+pow(frameCount/2000, 1.1) * PI * 2) - (x & (y + frameCount * 2)) % 128;
						fill(100 * (1 - ny) + random(0, 32) + (y ^ (x + frameCount * 4)) % 40, 32 + random(0, 128),
								 brightness, 1);*/
					} else {
						brightness = 255-255 * sin(1.5+pow(frameCount/2200, 1.1) * PI * 1) - (x & (y + frameCount * 1)) % 128;
						fill(100 * (1 - ny) + random(0, 32) + (y ^ (x + frameCount * 4)) % 40, 32 + random(0, 128),
								 brightness, 1);
					}
					//
					
					if (brightness < 1) {
						continue;
					}
					
					let vw = sw * sx;
					let vh = sh * sy;
					
					let xx = x;
					if (x <= 0) {
						xx += smx;
					}
					
					let yy = y + smy;

					if (y > 0) {
						rect(width / 2 + (-width / 2 + xx) * sx - np * width / 16, height / 2 + (-height / 2 + yy) * sy - height / 4 + ainp * height / 2, vw, vh);
						rect(width - (width / 2 + (-width / 2 + xx) * sx + vw) + np * width / 16, height / 2 + (-height / 2 + yy) * sy - height / 4 + np * height / 2, vw, vh);
					}
				}
			}
		}
	}
	
	xmotion += 0.25;
	ymotion += 0.5;
}

function draw_sky() {
	noStroke();
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height+64; y += 4) {
		let ny = y / height;
		for (x = 0; x < width+8; x += 1) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12) / 4;
			let n2 = noise(nx, ny);
			
			let yy = y - n * height/2;
			fill(200 + 25 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.5 + ny * PI * 2 + 0.25))) * abs(0.5 - nx) * 2, 118, (128 + pow(ny+0.45, 4.5) * 128), 1);
			rect(x, yy, 4, 5);
		}
	}

	for (y = height; y > 0; y -= 1) {
		let ny = y / height;
		for (x = 0; x < width; x += 1) {
			if (random() > 0.75) {
				stroke(0, 0, 0, random(0, 0.05));
				let xx = x + random(-4, 4);
				line(xx, y, xx + random(-6, 6)*ny, y + random(-6, 6)*ny);
			}
		}
	}
	
	for (y = 0; y < height; y += 1) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 8) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.05);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-100, 100), y + random(-100, 100));
			}
		}
	}
	
	for (y = 0; y < height; y += 1) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 1) {
			let n = noise(x / width, y / height*4);
			if (random() > 0.25 + n) {
				stroke(0, 0, 255, random() * 0.0075*n);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-100, 100), y + random(-20, 20));
			}
		}
	}
	
	for (y = 0; y < height / 2; y += 16) {
		let ny = y / height;
		let noy = noise(ny);
		for (x = 0; x < width; x += 3) {
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = noise(nx, ny);
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2 * nox2;

			let yy = y;

			if (random() > 0.999) {
				stroke(0, 0, 0, 1);
				strokeWeight(0.5 + random() / 2);
				let tx = x + random(1, 6);
				let ty = yy + random(1, 6);
				line(x, yy, tx, ty);
				line(tx, ty, tx + random(1, 4) * (1-ny), ty - random(1, 4) * (1-ny));
			}
		}
	}
}"
"1111024","Fake raycast minimal 3","mySketch","function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
	
	//rectMode(CENTER);
	draw_sky();
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	//background(0);
	noStroke();
	//fill(0, 0, 0, 0.05);
	//rect(0, 0, width, height);
	/*
	var context = drawingContext
	context.shadowOffsetX = sin(xmotion*2)/2;
	context.shadowOffsetY = cos(ymotion*2)/2;
	context.shadowBlur = 1; // more can be fun also
	context.shadowColor = ""rgba(0, 0, 0, 0.25)"";
	*/
	let planes = 1;

	// the blocks resolution (lower = better)
	let sw = 10;
	let sh = 10;
	
	let xp_offset = 0;
	let yp_offset = 0;
	
	let w = width;
	let h = height;
	
	for (let p = 0; p < planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let ainp = 1-np;
		
		let sf = ainp / 256;
		
		let sx = sf + xmotion/128;
		let sy = sf + xmotion/128;
		
		let mw = w - sw;
		let mh = h - sh;
		
		for (let y = 0; y < h; y += sw) {
			for (let x = 0; x < w / 2; x += sh) {
				if (x <= 0 || x >= w / 2 || y <= 0 || y >= mh) { // checkerboard pattern
					let nx = x / w;
					let ny = y / h;
					
					let anx = abs(0.5 - nx) * 2;
					let any = abs(0.5 - ny) * 2;
					
					// surface modulation
					let smx = (sin(ymotion / 2 * max(0, 1 - pow(0.5 + frameCount/100, 0.75)))) * 100 * anx * max(0, 1-frameCount/1000);
					let smy = (sin(ymotion / 8 * max(0, 1 - frameCount/400))) * 100 * anx * max(0, 1-frameCount/400);
				
					// shading of the 'surfaces'
					let brightness = 0;
					if (x <= 0 ) {
						// due to symmetry there is only one real 'side'
						brightness = 255-255 * sin(pow(frameCount/2000, 1.1) * PI * 2) - (y & (y + frameCount * 6)) % 255 * abs(smx / 16 + 0.5);
						fill(100 * (1 - ny) + random(0, 32) + (y ^ (x + frameCount * 4)) % 40, 32 + random(0, 128),
								 brightness, 1 * pow(ny, 0.25));
					} else if (y<= 0) {
						/*brightness = 255-255 * sin(1.5+pow(frameCount/2000, 1.1) * PI * 2) - (x & (y + frameCount * 2)) % 128;
						fill(100 * (1 - ny) + random(0, 32) + (y ^ (x + frameCount * 4)) % 40, 32 + random(0, 128),
								 brightness, 1);*/
					} else {
						brightness = 255-255 * sin(1.5+pow(frameCount/2000, 1.1) * PI * 2) - (x & (y + frameCount * 1)) % 128;
						fill(100 * (1 - ny) + random(0, 32) + (y ^ (x + frameCount * 4)) % 40, 32 + random(0, 128),
								 brightness, 1);
					}
					//
					
					if (brightness < 1) {
						continue;
					}
					
					let vw = sw * sx;
					let vh = sh * sy;
					
					let xx = x;
					if (x <= 0) {
						xx += smx;
					}
					
					let yy = y + smy;

					if (y > 0) {
						rect(width / 2 + (-width / 2 + xx) * sx, height / 2 + (-height / 2 + yy) * sy, vw, vh);
						rect(width - (width / 2 + (-width / 2 + xx) * sx + vw), height / 2 + (-height / 2 + yy) * sy, vw, vh);
					}
				}
			}
		}
	}
	
	xmotion += 0.25;
	ymotion += 0.5;
}

function draw_sky() {
	noStroke();
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height+64; y += 4) {
		let ny = y / height;
		for (x = 0; x < width+8; x += 1) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12) / 4;
			let n2 = noise(nx, ny);
			
			let yy = y - n * height/2;
			fill(200 + 25 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.5 + ny * PI * 2 + 0.25))) * abs(0.5 - nx) * 2, 118, (128 + pow(ny+0.45, 4.5) * 128), 1);
			rect(x, yy, 4, 5);
		}
	}

	for (y = height; y > 0; y -= 1) {
		let ny = y / height;
		for (x = 0; x < width; x += 1) {
			if (random() > 0.75) {
				stroke(0, 0, 0, random(0, 0.05));
				let xx = x + random(-4, 4);
				line(xx, y, xx + random(-6, 6)*ny, y + random(-6, 6)*ny);
			}
		}
	}
	
	for (y = 0; y < height; y += 1) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 8) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.05);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-100, 100), y + random(-100, 100));
			}
		}
	}
	
	for (y = 0; y < height; y += 1) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 1) {
			let n = noise(x / width, y / height*4);
			if (random() > 0.25 + n) {
				stroke(0, 0, 255, random() * 0.0075*n);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-100, 100), y + random(-20, 20));
			}
		}
	}
	
	for (y = 0; y < height / 2; y += 16) {
		let ny = y / height;
		let noy = noise(ny);
		for (x = 0; x < width; x += 3) {
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = noise(nx, ny);
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2 * nox2;

			let yy = y;

			if (random() > 0.999) {
				stroke(0, 0, 0, 1);
				strokeWeight(0.5 + random() / 2);
				let tx = x + random(1, 6);
				let ty = yy + random(1, 6);
				line(x, yy, tx, ty);
				line(tx, ty, tx + random(1, 4) * (1-ny), ty - random(1, 4) * (1-ny));
			}
		}
	}
}"
"1111021","Fake raycast minimal 2","mySketch","// different logical operator, background sky extended to whole screen and black values discard

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
	
	//rectMode(CENTER);
	draw_sky();
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	//background(0);
	noStroke();
	//fill(0, 0, 0, 0.05);
	//rect(0, 0, width, height);
	/*
	var context = drawingContext
	context.shadowOffsetX = sin(xmotion*2)/2;
	context.shadowOffsetY = cos(ymotion*2)/2;
	context.shadowBlur = 1; // more can be fun also
	context.shadowColor = ""rgba(0, 0, 0, 0.25)"";
	*/
	let planes = 1;

	// the blocks resolution (lower = better)
	let sw = 10;
	let sh = 10;
	
	let xp_offset = 0;
	let yp_offset = 0;
	
	let w = width;
	let h = height;
	
	for (let p = 0; p < planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let ainp = 1-np;
		
		let sf = ainp / 256;
		
		let sx = sf + xmotion/128;
		let sy = sf + xmotion/128;
		
		let mw = w - sw;
		let mh = h - sh;
		
		for (let y = 0; y < h; y += sw) {
			for (let x = 0; x < w / 2; x += sh) {
				if (x <= 0 || x >= w / 2 || y <= 0 || y >= mh) { // checkerboard pattern
					let nx = x / w;
					let ny = y / h;
					
					let anx = abs(0.5 - nx) * 2;
					let any = abs(0.5 - ny) * 2;
					
					// surface modulation
					let smx = (sin(ymotion / 2 * max(0, 1 - pow(0.5 + frameCount/600, 0.25)))) * 100 * anx * max(0, 1-frameCount/1000);
					let smy = (sin(ymotion / 8 * max(0, 1 - frameCount/400))) * 100 * anx * max(0, 1-frameCount/400);
				
					// shading of the 'surfaces'
					let brightness = 0;
					if (x <= 0 ) {
						// due to symmetry there is only one real 'side'
						brightness = 255 * sin(pow(frameCount/2000, 1) * PI * 2) - (y & (y + frameCount * 4)) % 128 * abs(smx / 16 + 0.5);
						fill(100 * (1 - ny) + random(0, 32) + (y ^ (x + frameCount * 4)) % 40, 32 + random(0, 128),
								 brightness, 1 * pow(ny, 0.25));
					} else if (y<= 0) {
						//fill(200 + (x ^ (y + frameCount * 4)) % 40, 64,
						//		 255 * sin(pow(frameCount/1000, 1.1) * PI * 2), 1);
					} else {
						brightness = 255 * sin(pow(frameCount/1000, 1.1) * PI * 2) - (x ^ (y + frameCount * 2)) % 128 * pow(anx, 4);
						fill(0 + random(0, 32) + (x ^ (y + frameCount * 4)) % 40, 32 + random(0, 128),
								 brightness, 1);
					}
					//
					
					if (brightness < 1) {
						continue;
					}
					
					let vw = sw * sx;
					let vh = sh * sy;
					
					let xx = x;
					if (x <= 0) {
						xx += smx;
					}
					
					let yy = y + smy;

					if (y > 0) {
						rect(width / 2 + (-width / 2 + xx) * sx, height / 2 + (-height / 2 + yy) * sy, vw, vh);
						rect(width - (width / 2 + (-width / 2 + xx) * sx + vw), height / 2 + (-height / 2 + yy) * sy, vw, vh);
					}
				}
			}
		}
	}
	
	xmotion += 0.25;
	ymotion += 0.5;
}
function draw_sky() {
	noStroke();
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height+64; y += 4) {
		let ny = y / height;
		for (x = 0; x < width+8; x += 1) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12) / 4;
			let n2 = noise(nx, ny);
			
			let yy = y - n * height/2;
			fill(200 + 25 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.5 + ny * PI * 2 + 0.25))) * abs(0.5 - nx) * 2, 118, (128 + pow(ny+0.45, 4.5) * 128), 1);
			rect(x, yy, 4, 5);
		}
	}

	for (y = height; y > 0; y -= 1) {
		let ny = y / height;
		for (x = 0; x < width; x += 1) {
			if (random() > 0.75) {
				stroke(0, 0, 0, random(0, 0.05));
				let xx = x + random(-4, 4);
				line(xx, y, xx + random(-6, 6)*ny, y + random(-6, 6)*ny);
			}
		}
	}
	
	for (y = 0; y < height; y += 1) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 8) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.05);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-100, 100), y + random(-100, 100));
			}
		}
	}
	
	for (y = 0; y < height; y += 1) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 1) {
			let n = noise(x / width, y / height*4);
			if (random() > 0.25 + n) {
				stroke(0, 0, 255, random() * 0.0075*n);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-100, 100), y + random(-20, 20));
			}
		}
	}
	
	for (y = 0; y < height / 2; y += 16) {
		let ny = y / height;
		let noy = noise(ny);
		for (x = 0; x < width; x += 3) {
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = noise(nx, ny);
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2 * nox2;

			let yy = y;

			if (random() > 0.999) {
				stroke(0, 0, 0, 1);
				strokeWeight(0.5 + random() / 2);
				let tx = x + random(1, 6);
				let ty = yy + random(1, 6);
				line(x, yy, tx, ty);
				line(tx, ty, tx + random(1, 4) * (1-ny), ty - random(1, 4) * (1-ny));
			}
		}
	}
}"
"1110607","Fake raycast minimal","mySketch","// code size optimized / cleaned up mininal fake raycast (with x axis symmetry)
// with logical operators texture and generated background sky from a previous sketch
// note : became more complex than previously thought but its still somewhat the clean and generic version

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseSeed(0);
	noiseDetail(6, 0.7);
	
	noStroke();
	
	//rectMode(CENTER);
	draw_sky();
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	//background(0);
	noStroke();
	//fill(0, 0, 0, 0.05);
	//rect(0, 0, width, height);

	let planes = 1;

	// the blocks resolution (lower = better)
	let sw = 10;
	let sh = 10;
	
	let xp_offset = 0;
	let yp_offset = 0;
	
	let w = width;
	let h = height;
	
	for (let p = 0; p < planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let ainp = 1-np;
		
		let sf = ainp / 256;
		
		let sx = sf + xmotion/128;
		let sy = sf + xmotion/128;
		
		let mw = w - sw;
		let mh = h - sh;
		
		for (let y = 0; y < h; y += sw) {
			for (let x = 0; x < w / 2; x += sh) {
				if (x <= 0 || x >= w / 2 || y <= 0 || y >= mh) { // checkerboard pattern
					let nx = x / w;
					let ny = y / h;
					
					let anx = abs(0.5 - nx) * 2;
					let any = abs(0.5 - ny) * 2;
					
					// surface modulation
					let smx = (sin(ymotion / 2 * max(0, 1 - pow(0.5 + frameCount/600, 0.25)))) * 100 * anx * max(0, 1-frameCount/1000);
					let smy = (sin(ymotion / 8 * max(0, 1 - frameCount/400))) * 100 * anx * max(0, 1-frameCount/400);
				
					// shading of the 'surfaces'
					let brightness = 0;
					if (x <= 0 ) {
						// due to symmetry there is only one real 'side'
						brightness = 255 * sin(pow(frameCount/2000, 1) * PI * 2) - (y & (x + frameCount / 4)) % 128 * abs(smx / 16 + 0.5);
						fill(100 * (1 - ny) + random(0, 32) + (y ^ (x + frameCount * 4)) % 40, 32 + random(0, 128),
								 brightness, 1 * pow(ny, 0.25));
					} else if (y<= 0) {
						//fill(200 + (x ^ (y + frameCount * 4)) % 40, 64,
						//		 255 * sin(pow(frameCount/1000, 1.1) * PI * 2), 1);
					} else {
						brightness = 255 * sin(pow(frameCount/1000, 1.1) * PI * 2) - (x ^ (y + frameCount * 2)) % 128 * pow(anx, 4);
						fill(0 + random(0, 32) + (x ^ (y + frameCount * 4)) % 40, 32 + random(0, 128),
								 brightness, 1);
					}
					//
					/*
					if (brightness < 1) {
						continue;
					}
					*/
					let vw = sw * sx;
					let vh = sh * sy;
					
					let xx = x;
					if (x <= 0) {
						xx += smx;
					}
					
					let yy = y + smy;

					if (y > 0) {
						rect(width / 2 + (-width / 2 + xx) * sx, height / 2 + (-height / 2 + yy) * sy, vw, vh);
						rect(width - (width / 2 + (-width / 2 + xx) * sx + vw), height / 2 + (-height / 2 + yy) * sy, vw, vh);
					}
				}
			}
		}
	}
	
	xmotion += 0.25;
	ymotion += 0.5;
}

function draw_sky() {
	noStroke();
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width+8; x += 1) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12) / 4;
			let n2 = noise(nx, ny);
			
			let yy = y - n * (height * 3.75);
			fill(200 + 25 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.5 + ny * PI * 2 + 0.25))) * abs(0.5 - nx) * 2, 118, (128 + pow(ny, 1) * 128), 1);
			rect(x, yy, 4, 5);
		}
	}

	for (y = height/1.85; y > 0; y -= 1) {
		let ny = y / height/1.85;
		for (x = 0; x < width; x += 1) {
			if (random() > 0.75) {
				stroke(0, 0, 0, random(0, 0.05));
				let xx = x + random(-4, 4);
				line(xx, y, xx + random(-6, 6)*ny, y + random(-6, 6)*ny);
			}
		}
	}
	
	for (y = 0; y < height / 2; y += 1) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 8) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.05);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-100, 100), y + random(-100, 100));
			}
		}
	}
	
	for (y = 0; y < height / 2; y += 1) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 1) {
			let n = noise(x / width, y / height*4);
			if (random() > 0.25 + n) {
				stroke(0, 0, 255, random() * 0.0075*n);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-100, 100), y + random(-20, 20));
			}
		}
	}
	
	for (y = 0; y < height / 2; y += 16) {
		let ny = y / height;
		let noy = noise(ny);
		for (x = 0; x < width; x += 3) {
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = noise(nx, ny);
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2 * nox2;

			let yy = y;

			if (random() > 0.999) {
				stroke(0, 0, 0, 1);
				strokeWeight(0.5 + random() / 2);
				let tx = x + random(1, 6);
				let ty = yy + random(1, 6);
				line(x, yy, tx, ty);
				line(tx, ty, tx + random(1, 4) * (1-ny), ty - random(1, 4) * (1-ny));
			}
		}
	}
}"
"1110167","Fake raycast 9","mySketch","// same as parallax checkerboard with static render goal

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseDetail(6, 0.7);
	
	noStroke();
	
	rectMode(CENTER);
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	//background(0);
	noStroke();
	//fill(0, 0, 0, 0.05);
	//rect(0, 0, width, height);
	/*
	var context = drawingContext
	context.shadowOffsetX = sin(xmotion*2)/2;
	context.shadowOffsetY = cos(ymotion*2)/2;
	context.shadowBlur = 1; // more can be fun also
	context.shadowColor = ""rgba(0, 0, 0, 0.25)"";
	*/
	let planes = 32;

	let sw = 50;
	let sh = 50;
	
	let xp_offset = 0;
	let yp_offset = 0;
	
	let w = width;
	let h = height;
	
	for (let p = 1; p <= planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let ainp = 1-np;
		
		let sf = pow(2, ainp) / 128;
		
		push();
		translate(width / 2, height / 2);
		scale(sf + xmotion/128, sf + xmotion/128);
		
		for (let y = 0; y <= h; y += sw) {
			for (let x = 0; x <= w; x += sh) {
				
				if (x <= 0 || x >= w || y <= 0 || y >= h) { // checkerboard pattern
					let nx = abs(0.5 - x / w) * 2;
					let ny = abs(0.5 - y / h) * 2;
				
					//rotate((sf / 2 + nx * ny));
				
					let no = noise(nx * 0.5, ny * 0.5+frameCount/400*16);
					
					let ss = abs(sin((nx * ny) * PI * (1 + cos(ymotion)*8) + inp * PI * 4 + xmotion / 3)) * 1.5;
					
					stroke(0, 0, 0, sf / 4);
					strokeWeight(0.5);
					fill((20 + ss * 200 * ainp) % 360, 32 + 64 * sf + ainp * 64, 255 * np *abs(sin(PI/8 + (1-frameCount/1000) * PI * 0.5 + no/2)), sf / 0.05/abs(sin((1-frameCount/100) * PI * 16)));
					
					let vw = sw * ss - frameCount/8.5*np;
					let vh = sh * ss - frameCount/8.5*np;
					
					if (vw > 0 && vh > 0) {
						if (noise(nx * 2, ny * 2) > 0.5) {
							rect(-width / 2 + (x + abs(cos(xmotion / 1 + ainp)) * 1 * no/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y - (sin(2+ymotion / 1 * max(0, 1-frameCount/400))) * 300 * (nx) * noise(vw)* max(0, frameCount/400) /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						} else {
							ellipse(-width / 2 + (x + abs(cos(xmotion / 4 + ainp)) * 1 * no/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y + abs(sin(ymotion / 4 + ainp)) * 1 * no /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						}
					}
				}
			}
		}
		pop();
	}
	
	xmotion += 0.25;
	ymotion += 0.25;
}"
"1110158","Fake raycast 8","mySketch","// same as parallax checkerboard with static render goal

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseDetail(6, 0.7);
	noiseSeed(17);
	
	noStroke();
	
	rectMode(CENTER);
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	//background(0);
	noStroke();
	//fill(0, 0, 0, 0.05);
	//rect(0, 0, width, height);
	/*
	var context = drawingContext
	context.shadowOffsetX = sin(xmotion*2)/2;
	context.shadowOffsetY = cos(ymotion*2)/2;
	context.shadowBlur = 1; // more can be fun also
	context.shadowColor = ""rgba(0, 0, 0, 0.25)"";
	*/
	let planes = 32;

	let sw = 50;
	let sh = 50;
	
	let xp_offset = 0;
	let yp_offset = 0;
	
	let w = width;
	let h = height;
	
	for (let p = 1; p <= planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let ainp = np;
		
		let sf = pow(92, ainp) / 32;
		
		push();
		translate(width / 2, height / 2);
		scale(sf + xmotion/128, sf + xmotion/128);
		rotate(sin(xmotion/10) * min(1, 1-(frameCount/1000)));
		for (let y = 0; y <= h; y += sw) {
			for (let x = 0; x <= w; x += sh) {
				
				if (x <= 0 || x >= w || y <= 0 || y >= h) { // checkerboard pattern
					let nx = abs(0.5 - x / w) * 2;
					let ny = abs(0.5 - y / h) * 2;
				
					let no = noise(nx*ny);
					
					let ss = abs(sin((nx * ny) * PI * 32 + inp * PI * 4 + sf * PI * 2 + xmotion / 2)) * 1.25;
					
					stroke(0, 0, 0, sf / 4);
					strokeWeight(0.5);
					fill((190 + ss * 40 * ainp) % 360, 32 + 64 * sf + ainp * 64, 255-255 * sf * 64 *abs(pow(sin(PI/4 + (frameCount/1000) * PI * 1 + no*7), 1.5)), sf / 0.005*abs(sin((frameCount/100) * PI * 2)));
					
					//let vw = sw * ss - frameCount/8.5*np;
					//let vh = sh * ss - frameCount/8.5*np;
					let vw = 0.;
					if ((x <= 0 && y >=0 && y <= h)|| (x >= w && y >= 0 && y<= h)) {
						vw = sw * ss - frameCount/4.5*(0.2+np);
					} else {
						vw = sw * ss - frameCount/4.5*(0.2+np);
					}
					let vh = 0;
					
					if ((x >= 0 && y <= 0 && x <= w) || (x >= 0 && y >= h && x <= w)) {
						vh = sh * ss - frameCount/4.5*(0.2+np);
					} else {
						vh = sh * ss - frameCount/4.5*(0.2+np);
					}
					
					if (vw > 0 && vh > 0) {
						if (y % 7 > 0) {
							rect(-width / 2 + (x /* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						} else {
							ellipse(-width / 2 + (x + abs(cos(xmotion / 4 + ainp)) * 1 * no/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y + abs(sin(ymotion / 4 + ainp)) * 1 * no /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						}
					}
				}
			}
		}
		pop();
	}
	
	xmotion += 0.25;
	ymotion += 0.25;
}"
"1110139","Fake raycast 7","mySketch","// same as parallax checkerboard with static render goal

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseDetail(6, 0.7);
	
	noStroke();
	
	rectMode(CENTER);
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	//background(0);
	noStroke();
	//fill(0, 0, 0, 0.05);
	//rect(0, 0, width, height);
	/*
	var context = drawingContext
	context.shadowOffsetX = sin(xmotion*2)/2;
	context.shadowOffsetY = cos(ymotion*2)/2;
	context.shadowBlur = 1; // more can be fun also
	context.shadowColor = ""rgba(0, 0, 0, 0.25)"";
	*/
	let planes = 32;

	let sw = 50;
	let sh = 50;
	
	let xp_offset = 0;
	let yp_offset = 0;
	
	let w = width;
	let h = height;
	
	for (let p = 1; p <= planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let ainp = np;
		
		let sf = pow(1, ainp) / 92;
		
		push();
		translate(width / 2, height / 2);
		scale(sf + xmotion/128, sf + xmotion/128);
		rotate(xmotion/10);
		for (let y = 0; y <= h; y += sw) {
			for (let x = 0; x <= w; x += sh) {
				
				if (x <= 0 || x >= w || y <= 0 || y >= h) { // checkerboard pattern
					let nx = abs(0.5 - x / w) * 2;
					let ny = abs(0.5 - y / h) * 2;
				
					
				
					let no = noise(nx*ny +frameCount/400*16);
					
					let ss = abs(sin((nx * ny) * PI * (1 + cos(ymotion)*8) + inp * PI * 4 + xmotion / 1)) * 1.25;
					
					stroke(0, 0, 0, sf / 4);
					strokeWeight(0.5);
					fill((190 + ss * 40 * ainp) % 360, 32 + 64 * sf + ainp * 64, 255 * np *abs(sin(PI/4 + (frameCount/1000) * PI * 2 + no)), sf / 0.005/abs(sin((1-frameCount/100) * PI * 16)));
					
					//let vw = sw * ss - frameCount/8.5*np;
					//let vh = sh * ss - frameCount/8.5*np;
					let vw = 0.;
					if ((x <= 0 && y >=0 && y <= h)|| (x >= w && y >= 0 && y<= h)) {
						vw = sw * ss - frameCount/4.5*(0.2+np);
					} else {
						vw = sw * ss - frameCount/4.5*(0.2+np);
					}
					let vh = 0;
					
					if ((x >= 0 && y <= 0 && x <= w) || (x >= 0 && y >= h && x <= w)) {
						vh = sh * ss - frameCount/4.5*(0.2+np);
					} else {
						vh = sh * ss - frameCount/4.5*(0.2+np);
					}
					
					if (vw > 0 && vh > 0) {
						if (y % 7 > 0) {
							rect(-width / 2 + (x + (sin(2+xmotion / 2 * max(0, frameCount/800))) * 200 * (ny) * noise(vw)* max(0, frameCount/1000)/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y - (sin(2+ymotion / 2 * max(0, frameCount/800))) * 200 * max(0, frameCount/800) /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						} else {
							ellipse(-width / 2 + (x + abs(cos(xmotion / 4 + ainp)) * 1 * no/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y + abs(sin(ymotion / 4 + ainp)) * 1 * no /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						}
					}
				}
			}
		}
		pop();
	}
	
	xmotion += 0.25;
	ymotion += 0.25;
}"
"1110129","Fake raycast 6","mySketch","// same as parallax checkerboard with static render goal

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseDetail(6, 0.7);
	
	noStroke();
	
	rectMode(CENTER);
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	//background(0);
	noStroke();
	//fill(0, 0, 0, 0.05);
	//rect(0, 0, width, height);
	/*
	var context = drawingContext
	context.shadowOffsetX = sin(xmotion*2)/2;
	context.shadowOffsetY = cos(ymotion*2)/2;
	context.shadowBlur = 1; // more can be fun also
	context.shadowColor = ""rgba(0, 0, 0, 0.25)"";
	*/
	let planes = 32;

	let sw = 50;
	let sh = 50;
	
	let xp_offset = 0;
	let yp_offset = 0;
	
	let w = width;
	let h = height;
	
	for (let p = 1; p <= planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let ainp = 1-np;
		
		let sf = pow(32, ainp) / 92;
		
		push();
		translate(width / 2, height / 2);
		scale(sf + xmotion/128, sf + xmotion/128);
		
		for (let y = 0; y <= h; y += sw) {
			for (let x = 0; x <= w; x += sh) {
				
				if (x <= 0 || x >= w || y <= 0 || y >= h) { // checkerboard pattern
					let nx = abs(0.5 - x / w) * 2;
					let ny = abs(0.5 - y / h) * 2;
				
					rotate(xmotion/1000);
				
					let no = noise(ny * 0.5+frameCount/400*16);
					
					let ss = abs(sin((nx * ny) * PI * (1 + cos(ymotion)*8) + inp * PI * 4 + xmotion / 1)) * 1;
					
					stroke(0, 0, 0, sf / 4);
					strokeWeight(0.5);
					fill((190 + ss * 40 * ainp) % 360, 32 + 64 * sf + ainp * 64, 255 * np *(sin(PI/0.5 + (frameCount/1000) * PI * 1 + no)), sf / 0.005/abs(sin((1-frameCount/100) * PI * 16)));
					
					//let vw = sw * ss - frameCount/8.5*np;
					//let vh = sh * ss - frameCount/8.5*np;
					let vw = 0.;
					if ((x <= 0 && y >=0 && y <= h)|| (x >= w && y >= 0 && y<= h)) {
						vw = sw * ss - frameCount/4.5*(0.2+np);
					} else {
						vw = sw * ss - frameCount/4.5*(0.2+np);
					}
					let vh = 0;
					
					if ((x >= 0 && y <= 0 && x <= w) || (x >= 0 && y >= h && x <= w)) {
						vh = sh * ss - frameCount/4.5*(0.2+np);
					} else {
						vh = sh * ss - frameCount/4.5*(0.2+np);
					}
					
					if (vw > 0 && vh > 0) {
						if (y % 7 > 0) {
							rect(-width / 2 + (x + (sin(2+xmotion / 2 * max(0, frameCount/800))) * 200 * (ny) * noise(vw)* max(0, frameCount/1000)/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y - (sin(2+ymotion / 2 * max(0, frameCount/800))) * 200 * max(0, frameCount/800) /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						} else {
							ellipse(-width / 2 + (x + abs(cos(xmotion / 4 + ainp)) * 1 * no/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y + abs(sin(ymotion / 4 + ainp)) * 1 * no /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						}
					}
				}
			}
		}
		pop();
	}
	
	xmotion += 0.25;
	ymotion += 0.25;
}"
"1110091","Fake raycast 5","mySketch","// same as parallax checkerboard with static render goal

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseDetail(6, 0.7);
	
	noStroke();
	
	rectMode(CENTER);
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	//background(0);
	noStroke();
	//fill(0, 0, 0, 0.05);
	//rect(0, 0, width, height);
	/*
	var context = drawingContext
	context.shadowOffsetX = sin(xmotion*2)/2;
	context.shadowOffsetY = cos(ymotion*2)/2;
	context.shadowBlur = 1; // more can be fun also
	context.shadowColor = ""rgba(0, 0, 0, 0.25)"";
	*/
	let planes = 32;

	let sw = 50;
	let sh = 50;
	
	let xp_offset = 0;
	let yp_offset = 0;
	
	let w = width;
	let h = height;
	
	for (let p = 1; p <= planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let ainp = 1-np;
		
		let sf = pow(2, ainp) / 128;
		
		push();
		translate(width / 2, height / 2);
		scale(sf + xmotion/128, sf + xmotion/128);
		
		for (let y = 0; y <= h; y += sw) {
			for (let x = 0; x <= w; x += sh) {
				
				if (x <= 0 || x >= w || y <= 0 || y >= h) { // checkerboard pattern
					let nx = abs(0.5 - x / w) * 2;
					let ny = abs(0.5 - y / h) * 2;
				
					rotate((sf / 2 + nx * ny));
				
					let no = noise(nx * 0.5, ny * 0.5+frameCount/400*16);
					
					let ss = abs(sin((nx * ny) * PI * (1 + cos(ymotion)*8) + inp * PI * 4 + xmotion / 3)) * 1.5;
					
					stroke(0, 0, 0, sf / 4);
					strokeWeight(0.5);
					fill((20 + ss * 200 * ainp) % 360, 32 + 64 * sf + ainp * 64, 255 * np *abs(sin(PI/1 + (1-frameCount/400) * PI * 0.5 + no)), sf / 0.05/abs(sin((1-frameCount/100) * PI * 16)));
					
					let vw = sw * ss - frameCount/8.5*np;
					let vh = sh * ss - frameCount/8.5*np;
					
					if (vw > 0 && vh > 0) {
						if (noise(nx * 2, ny * 2) > 0.5) {
							rect(-width / 2 + (x + abs(cos(xmotion / 4 + ainp)) * 1 * no/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y - (sin(2+ymotion / 8 * max(0, 1-frameCount/400))) * 300 * (nx) * noise(vw)* max(0, frameCount/400) /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						} else {
							ellipse(-width / 2 + (x + abs(cos(xmotion / 4 + ainp)) * 1 * no/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y + abs(sin(ymotion / 4 + ainp)) * 1 * no /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						}
					}
				}
			}
		}
		pop();
	}
	
	xmotion += 0.25;
	ymotion += 0.25;
}"
"1110053","Fake raycast 4","mySketch","// same as parallax checkerboard with static render goal

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseDetail(6, 0.7);
	
	noStroke();
	
	rectMode(CENTER);
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	//background(0);
	noStroke();
	//fill(0, 0, 0, 0.05);
	//rect(0, 0, width, height);
	/*
	var context = drawingContext
	context.shadowOffsetX = sin(xmotion*2)/2;
	context.shadowOffsetY = cos(ymotion*2)/2;
	context.shadowBlur = 1; // more can be fun also
	context.shadowColor = ""rgba(0, 0, 0, 0.25)"";
	*/
	let planes = 32;

	let sw = 50;
	let sh = 50;
	
	let xp_offset = 0;
	let yp_offset = 0;
	
	let w = width;
	let h = height;
	
	for (let p = 1; p <= planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let ainp = 1-np;
		
		let sf = pow(2, ainp) / 128;
		
		push();
		translate(width / 2, height / 2);
		scale(sf + xmotion/128, sf + xmotion/128);
		
		for (let y = 0; y <= h; y += sw) {
			for (let x = 0; x <= w; x += sh) {
				
				if (x <= 0 || x >= w || y <= 0 || y >= h) { // checkerboard pattern
					let nx = abs(0.5 - x / w) * 2;
					let ny = abs(0.5 - y / h) * 2;
				
					//rotate((sf / 2 + nx * ny));
				
					let no = noise(nx * 0.5, ny * 0.5) * noise(ainp * 2)*1;
					
					let ss = abs(sin((nx * ny) * PI * (1 + cos(ymotion/4)) + inp * PI * 2 + xmotion / 3)) * 1.0;
					
					stroke(0, 0, 0, sf / 4);
					strokeWeight(0.5);
					fill((60 + ss * 200 * ainp) % 360, 32 + 64 * sf + ainp * 64, 255 * np *abs(sin((1-frameCount/100) * PI * 16)), sf / 0.05*abs(sin((1-frameCount/100) * PI * 16)));
					
					let vw = sw * ss - frameCount/8.5*np;
					let vh = sh * ss - frameCount/8.5*np;
					
					if (vw > 0 && vh > 0) {
						if (noise(nx * 2, ny * 2) > 0.5) {
							rect(-width / 2 + (x + abs(cos(xmotion / 4 + ainp)) * 1 * no/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y + abs(sin(ymotion / 4 + ainp)) * 1 * no /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						} else {
							ellipse(-width / 2 + (x + abs(cos(xmotion / 4 + ainp)) * 1 * no/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y + abs(sin(ymotion / 4 + ainp)) * 1 * no /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						}
					}
				}
			}
		}
		pop();
	}
	
	xmotion += 0.25;
	ymotion += 0.25;
}"
"1110052","Fake raycast 3","mySketch","// same as parallax checkerboard with static render goal

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseDetail(6, 0.7);
	
	noStroke();
	
	rectMode(CENTER);
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	//background(0);
	noStroke();
	//fill(0, 0, 0, 0.05);
	//rect(0, 0, width, height);
	
	var context = drawingContext
	context.shadowOffsetX = sin(xmotion*2)/2;
	context.shadowOffsetY = cos(ymotion*2)/2;
	context.shadowBlur = 1; // more can be fun also
	context.shadowColor = ""rgba(0, 0, 0, 0.25)"";
	
	let planes = 32;

	let sw = 100;
	let sh = 100;
	
	let xp_offset = 0;
	let yp_offset = 0;
	
	let w = width;
	let h = height;
	
	for (let p = 1; p <= planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let ainp = 1-np;
		
		let sf = pow(2, ainp) / 128;
		
		push();
		translate(width / 2, height / 2);
		scale(sf + xmotion/128, sf + xmotion/128);
		
		for (let y = 0; y <= h; y += sw) {
			for (let x = 0; x <= w; x += sh) {
				
				if (x <= 0 || x >= w || y <= 0 || y >= h) { // checkerboard pattern
					let nx = abs(0.5 - x / w) * 2;
					let ny = abs(0.5 - y / h) * 2;
				
					//rotate((sf / 2 + nx * ny));
				
					let no = noise(nx * 0.5, ny * 0.5) * noise(ainp * 2)*1;
					
					let ss = abs(sin((nx * ny) * PI * (1 + cos(ymotion/4)) + inp * PI * 32 + xmotion / 3)) * 1.0;
					
					stroke(0, 0, 0, sf / 4);
					strokeWeight(0.5);
					fill((60 + ss * 200 * ainp) % 360, 32 + 64 * sf + ainp * 64, 255 * np *abs(sin((1-frameCount/100) * PI * 16)), sf / 0.05*abs(sin((1-frameCount/100) * PI * 16)));
					
					let vw = sw * ss - frameCount/8.5*np;
					let vh = sh * ss - frameCount/8.5*np;
					
					if (vw > 0 && vh > 0) {
						if (noise(nx * 2, ny * 2) > 0.5) {
							rect(-width / 2 + (x + abs(cos(xmotion / 4 + ainp)) * 1 * no/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y + abs(sin(ymotion / 4 + ainp)) * 1 * no /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						} else {
							ellipse(-width / 2 + (x + abs(cos(xmotion / 4 + ainp)) * 1 * no/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y + abs(sin(ymotion / 4 + ainp)) * 1 * no /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						}
					}
				}
			}
		}
		pop();
	}
	
	xmotion += 0.25;
	ymotion += 0.25;
}"
"1109978","Stacking patterns 13","mySketch","// same as parallax checkerboard with static render goal

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseDetail(6, 0.7);
	
	noStroke();
	
	rectMode(CENTER);
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	//background(0);
	noStroke();
	//fill(0, 0, 0, 0.05);
	//rect(0, 0, width, height);
	
	var context = drawingContext
	context.shadowOffsetX = sin(xmotion*2);
	context.shadowOffsetY = cos(ymotion*2);
	context.shadowBlur = 4; // more can be fun also
	context.shadowColor = ""rgba(0, 0, 0, 0.25)"";
	
	let planes = 32;

	let sw = 100;
	let sh = 100;
	
	let xp_offset = 0;
	let yp_offset = 0;
	
	let w = width;
	let h = height;
	
	for (let p = 1; p <= planes-2; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let ainp = 1-np;
		
		let sf = pow(128, ainp) / 300;
		
		push();
		translate(width / 2, height / 2);
		scale(sf + xmotion/128, sf + xmotion/128);
		
		for (let y = 0; y <= h; y += sw) {
			for (let x = 0; x <= w; x += sh) {
				
				if (x <= 0 || x >= w || y <= 0 || y >= h) { // checkerboard pattern
					let nx = abs(0.5 - x / w) * 2;
					let ny = abs(0.5 - y / h) * 2;
				
					rotate((sf / 20 + nx * ny));
				
					let no = noise(nx * 0.5, ny * 0.5) * noise(ainp * 2)*1;
					
					let ss = abs(sin((nx * ny) * PI * (1 + cos(ymotion/4)) + inp * PI * 4 + xmotion / 3)) * 1.0;
					
					stroke(0, 0, 0, sf / 4);
					strokeWeight(0.5);
					fill((60 + ss * 200 * ainp) % 360, 32 + 64 * sf + ainp * 64, 200 * np *(frameCount/100), sf / 0.05);
					
					let vw = sw * ss - frameCount/2.5;
					let vh = sh * ss - frameCount/2.5;
					
					if (vw > 0 && vh > 0) {
						if (noise(nx * 2, ny * 2) > 0.5) {
							rect(-width / 2 + (x + abs(cos(xmotion / 1 + ainp)) * 100 * no/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y + abs(sin(ymotion / 1 + ainp)) * 100 * no /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						} else {
							ellipse(-width / 2 + (x + abs(cos(xmotion / 1 + ainp)) * 100 * no/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y + abs(sin(ymotion / 1 + ainp)) * 100 * no /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						}
					}
				}
			}
		}
		pop();
	}
	
	xmotion += 0.25;
	ymotion += 0.25;
}"
"1109975","Fake raycast 2","mySketch","// same as parallax checkerboard with static render goal

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseDetail(6, 0.7);
	
	noStroke();
	
	rectMode(CENTER);
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	//background(0);
	noStroke();
	//fill(0, 0, 0, 0.05);
	//rect(0, 0, width, height);
	
	var context = drawingContext
	context.shadowOffsetX = sin(xmotion*1);
	context.shadowOffsetY = cos(ymotion*1);
	context.shadowBlur = 1; // more can be fun also
	context.shadowColor = ""rgba(0, 0, 0, 0.25)"";
	
	let planes = 2;

	let sw = 50;
	let sh = 50;
	
	let xp_offset = 0;
	let yp_offset = 0;
	
	let w = width;
	let h = height;
	
	for (let p = 1; p <= planes; p += 1) {
		let np = p / planes;
		let inp = np;
		
		let ainp = np;
		
		let sf = pow(np * 16, ainp) / 128;
		
		push();
		translate(width / 2, height / 2);
		scale(sf + xmotion/192, sf + xmotion/192);

		for (let y = 0; y <= h; y += sw) {
			for (let x = 0; x <= w; x += sh) {
				
				if (x <= 0 || x >= w || y <= 0 || y >= h) { // checkerboard pattern
					let nx = abs(0.5 - x / w) * 2;
					let ny = abs(0.5 - y / h) * 2;
				
					rotate((xmotion ^ (ymotion*2))/3800 * PI);
				
					let n = noise(nx * 2, ny * 2);
					
					let ss = abs(1+sin((nx * ny) * PI * 2 + xmotion * 4)) * 2.5 * max(0, 1-(frameCount/1200));
				
					stroke(0, 0, 0, sf / 3);
					strokeWeight(0.5);
					fill(220 - (40 * (1-min(1, (frameCount/1000)))) * nx * ny, 64 *max(0, 1-(frameCount/1000)) + n * 64 * nx * ny, 255 *min(1, pow(frameCount/700, 2.0)) * (1-(nx * ny)/4),sf * 64);
					
					let vw = 0.;
					if (x <= 0 && y >0 || x >= 0 && y > 0 && y< h) {
						vw = sw * ss - frameCount/12.5;
					} else {
						vw = sw * ss + frameCount/12.5;
					}
					let vh = 0;
					
					if (x < 0 && y >=0 || x > 0 && y >= 0 && y<= h) {
						vh = sh * ss - frameCount/12;
					} else {
						vh = sh * ss + frameCount/12;
					}
					
					if (vw > 0 && vh > 0) {
						//if (noise(nx * 2, ny * 2) > 0.5) {
							rect(-width / 2 + x + pow(sin(xmotion / 24), 4) * (100 * (1-min(1, (frameCount/1000)))) /* * np*/ /*+ p * xp_offset * np*/,
											-height / 2 + y  - pow(sin(xmotion / 1), 2) * np * 300 * (1-min(1, (frameCount/1000)))/* * np*/ /*+ p * yp_offset * np*/,
											vw,
											vh);
						//} else {
						//	ellipse(-width / 2 + (x + abs(cos(xmotion / 4 + ainp)) * 1 * no + ny * 100/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
						//					-height / 2 + (y + abs(sin(ymotion / 4 + ainp)) * 1 * no + nx * 100 /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
						//					vw,
						//					vh);
						//}
					}
				}
			}
		}
		pop();
	}
	
	xmotion += 0.25;
	ymotion += 0.25;
}"
"1109926","Fake raycast","mySketch","// same as parallax checkerboard with static render goal

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseDetail(6, 0.7);
	
	noStroke();
	
	rectMode(CENTER);
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	//background(0);
	noStroke();
	//fill(0, 0, 0, 0.05);
	//rect(0, 0, width, height);
	
	var context = drawingContext
	context.shadowOffsetX = sin(xmotion*1);
	context.shadowOffsetY = cos(ymotion*1);
	context.shadowBlur = 1; // more can be fun also
	context.shadowColor = ""rgba(0, 0, 0, 0.25)"";
	
	let planes = 2;

	let sw = 50;
	let sh = 50;
	
	let xp_offset = 0;
	let yp_offset = 0;
	
	let w = width;
	let h = height;
	
	for (let p = 1; p <= planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let ainp = 1-np;
		
		let sf = pow(np * 64, ainp) / 64;
		
		push();
		translate(width / 2, height / 2);
		scale(sf + xmotion/192, sf + xmotion/192);

		for (let y = 0; y <= h; y += sw) {
			for (let x = 0; x <= w; x += sh) {
				
				if (x <= 0 || x >= w || y <= 0 || y >= h) { // checkerboard pattern
					let nx = abs(0.5 - x / w) * 2;
					let ny = abs(0.5 - y / h) * 2;
				
				//	rotate(nx*ny * 1000);
				
					let n = noise(nx * 2, ny * 2);
					
					let ss = abs(sin((nx * ny) * PI * 2 + xmotion * 4)) * 2.5 * min(1, (frameCount/100));
				
					stroke(0, 0, 0, sf / 3);
					strokeWeight(0.5);
					fill(180 + (40 * (1-min(1, (frameCount/1000)))) * nx * ny, 64 *max(0, 1-(frameCount/1000)) + n * 64 * nx * ny, 255 *min(1, pow(frameCount/700, 2.0)) * (1-(nx * ny)/4), sf * 64);
					
					let vw = 0.;
					if (x <= 0 && y >0 || x >= 0 && y > 0 && y< h) {
						vw = sw * ss - frameCount/8.5;
					} else {
						vw = sw * ss + frameCount/8.5;
					}
					let vh = 0;
					
					if (x < 0 && y >=0 || x > 0 && y >= 0 && y<= h) {
						vh = sh * ss - frameCount/8;
					} else {
						vh = sh * ss + frameCount/8;
					}
					
					if (vw > 0 && vh > 0) {
						//if (noise(nx * 2, ny * 2) > 0.5) {
							rect(-width / 2 + x + pow(sin(xmotion / 24), 4) * (500 * (1-min(1, (frameCount/1000)))) /* * np*/ /*+ p * xp_offset * np*/ % (w + sw),
											-height / 2 + y  - pow(sin(xmotion / 4), 2) * np * 600 * (1-min(1, (frameCount/300)))/* * np*/ /*+ p * yp_offset * np*/ % (h + sh),
											vw,
											vh);
						//} else {
						//	ellipse(-width / 2 + (x + abs(cos(xmotion / 4 + ainp)) * 1 * no + ny * 100/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
						//					-height / 2 + (y + abs(sin(ymotion / 4 + ainp)) * 1 * no + nx * 100 /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
						//					vw,
						//					vh);
						//}
					}
				}
			}
		}
		pop();
	}
	
	xmotion += 0.25;
	ymotion += 0.25;
}"
"1109765","Stacking patterns 11","mySketch","// same as parallax checkerboard with static render goal

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseDetail(6, 0.7);
	
	noStroke();
	
	rectMode(CENTER);
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	//background(0);
	noStroke();
	//fill(0, 0, 0, 0.05);
	//rect(0, 0, width, height);
	
	var context = drawingContext
	context.shadowOffsetX = sin(xmotion*2)/2;
	context.shadowOffsetY = cos(ymotion*2)/2;
	context.shadowBlur = 1; // more can be fun also
	context.shadowColor = ""rgba(0, 0, 0, 0.125)"";
	
	let planes = 6;

	let sw = 10;
	let sh = 10;
	
	let xp_offset = 0;
	let yp_offset = 0;
	
	let w = width;
	let h = height;
	
	for (let p = 1; p <= planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let ainp = 1-np;
		
		let sf = pow(128, ainp) / 128;
		
		push();
		translate(width / 2, height / 2);
		scale(sf + xmotion/148, sf + xmotion/148);
		
		for (let y = 0; y <= h; y += sw) {
			for (let x = 0; x <= w; x += sh) {
				
				if (x <= 0 || x >= w || y <= 0 || y >= h) { // checkerboard pattern
					let nx = abs(0.5 - x / w) * 2;
					let ny = abs(0.5 - y / h) * 2;
				
					rotate(sf*32);
				
					let no = noise(nx * 0.5, ny * 0.5);
					
					let ss = abs(sin((1-nx * ny) * PI * 2 + inp * PI * 2 + xmotion / 8)) * 2.0;
					
					stroke(0, 0, 0, sf / 2);
					strokeWeight(0.5);
					fill((60 + ss * 180 * ainp) % 360, 32 + 64 * sf + ainp * 64, 220 * np *(frameCount/100), sf / 0.025);
					
					let vw = sw * ss - frameCount/13.5;
					let vh = sh * ss - frameCount/13.5;
					
					if (vw > 0 && vh > 0) {
						if (noise(nx * 2, ny * 2) > 0.5) {
							rect(-width / 2 + (x + abs(cos(xmotion / 8 + ainp * PI * 2)) * 100 * no/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y + abs(sin(ymotion / 8 + ainp * PI * 2)) * 100 * no /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						} else {
							ellipse(-width / 2 + (x + abs(cos(xmotion / 8 + ainp * PI * 2)) * 100 * no/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y + abs(sin(ymotion / 8 + ainp * PI * 2)) * 100 * no /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						}
					}
				}
			}
		}
		pop();
	}
	
	xmotion += 0.25;
	ymotion += 0.25;
}"
"1109285","Stacking patterns 11","mySketch","// same as parallax checkerboard with static render goal

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseDetail(6, 0.7);
	
	noStroke();
	
	rectMode(CENTER);
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	//background(0);
	noStroke();
	//fill(0, 0, 0, 0.05);
	//rect(0, 0, width, height);
	
	var context = drawingContext
	context.shadowOffsetX = sin(xmotion*20)*8;
	context.shadowOffsetY = cos(ymotion*20)*8;
	context.shadowBlur = 8; // more can be fun also
	context.shadowColor = ""rgba(0, 0, 0, 0.125)"";
	
	let planes = 2;

	let sw = 100;
	let sh = 100;
	
	let xp_offset = 0;
	let yp_offset = 0;
	
	let w = width;
	let h = height;
	
	for (let p = 1; p <= planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let ainp = 1-np;
		
		let sf = pow(1, ainp) / 32;
		
		push();
		translate(width / 2, height / 2);
		scale(sf + xmotion/64, sf + xmotion/64);
		
		for (let y = 0; y <= h; y += sw) {
			for (let x = 0; x <= w; x += sh) {
				
				if (x <= 0 || x >= w || y <= 0 || y >= h) { // checkerboard pattern
					let nx = abs(0.5 - x / w) * 2;
					let ny = abs(0.5 - y / h) * 2;
				
					//rotate(sf * 2 + nx * ny);
				
					let no = noise(nx * 0.5, ny * 0.5) * noise(ainp * 2)*1;
					
					let ss = abs(sin((nx * ny) * PI * 32 + inp * PI * 32 + xmotion / 8)) * 1.25;
					
					stroke(0, 0, 0, sf / 4);
					strokeWeight(0.5);
					fill((20 + ss * 360 * ainp) % 360, 255 * sf + ainp * 255, 200 * np *(frameCount/100), sf / 0.05);
					
					let vw = sw * ss - frameCount/8;
					let vh = sh * ss - frameCount/8;
					
					if (vw > 0 && vh > 0) {
						if (noise(nx * 2, ny * 2) > 0.5) {
							rect(-width / 2 + (x + abs(cos(xmotion / 4 + ainp)) * 1 * no/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y + abs(sin(ymotion / 4 + ainp)) * 1 * no /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						} else {
							ellipse(-width / 2 + (x + abs(cos(xmotion / 4 + ainp)) * 1 * no/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y + abs(sin(ymotion / 4 + ainp)) * 1 * no /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						}
					}
				}
			}
		}
		pop();
	}
	
	xmotion += 0.25;
	ymotion += 0.35;
}"
"1109284","Stacking patterns 10","mySketch","// same as parallax checkerboard with static render goal

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseDetail(6, 0.7);
	
	noStroke();
	
	rectMode(CENTER);
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	//background(0);
	noStroke();
	//fill(0, 0, 0, 0.05);
	//rect(0, 0, width, height);
	
	var context = drawingContext
	context.shadowOffsetX = sin(xmotion*2)/2;
	context.shadowOffsetY = cos(ymotion*2)/2;
	context.shadowBlur = 1; // more can be fun also
	context.shadowColor = ""rgba(0, 0, 0, 0.25)"";
	
	let planes = 32;

	let sw = 100;
	let sh = 100;
	
	let xp_offset = 0;
	let yp_offset = 0;
	
	let w = width;
	let h = height;
	
	for (let p = 1; p <= planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let ainp = 1-np;
		
		let sf = pow(128, ainp) / 24;
		
		push();
		translate(width / 2, height / 2);
		scale(sf + xmotion/128, sf + xmotion/128);
		
		for (let y = 0; y <= h; y += sw) {
			for (let x = 0; x <= w; x += sh) {
				
				if (x <= 0 || x >= w || y <= 0 || y >= h) { // checkerboard pattern
					let nx = abs(0.5 - x / w) * 2;
					let ny = abs(0.5 - y / h) * 2;
				
					//rotate((sf / 2 + nx * ny));
				
					let no = noise(nx * 0.5, ny * 0.5) * noise(ainp * 2)*1;
					
					let ss = abs(sin((nx * ny) * PI * (1 + cos(ymotion/4)) + inp * PI * 4 + xmotion / 3)) * 1.0;
					
					stroke(0, 0, 0, sf / 4);
					strokeWeight(0.5);
					fill((60 + ss * 200 * ainp) % 360, 32 + 64 * sf + ainp * 64, 200 * np *(frameCount/100), sf / 0.05);
					
					let vw = sw * ss - frameCount/3.5*np;
					let vh = sh * ss - frameCount/3.5*np;
					
					if (vw > 0 && vh > 0) {
						if (noise(nx * 2, ny * 2) > 0.5) {
							rect(-width / 2 + (x + abs(cos(xmotion / 4 + ainp)) * 1 * no/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y + abs(sin(ymotion / 4 + ainp)) * 1 * no /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						} else {
							ellipse(-width / 2 + (x + abs(cos(xmotion / 4 + ainp)) * 1 * no/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y + abs(sin(ymotion / 4 + ainp)) * 1 * no /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						}
					}
				}
			}
		}
		pop();
	}
	
	xmotion += 0.25;
	ymotion += 0.25;
}"
"1109279","Stacking patterns 9","mySketch","// same as parallax checkerboard with static render goal

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseDetail(6, 0.7);
	
	noStroke();
	
	rectMode(CENTER);
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	//background(0);
	noStroke();
	//fill(0, 0, 0, 0.05);
	//rect(0, 0, width, height);
	
	var context = drawingContext
	context.shadowOffsetX = sin(xmotion*2);
	context.shadowOffsetY = cos(ymotion*2);
	context.shadowBlur = 4; // more can be fun also
	context.shadowColor = ""rgba(0, 0, 0, 0.25)"";
	
	let planes = 8;

	let sw = 100;
	let sh = 100;
	
	let xp_offset = 0;
	let yp_offset = 0;
	
	let w = width;
	let h = height;
	
	for (let p = 1; p <= planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let ainp = 1-np;
		
		let sf = pow(2, ainp) / 24;
		
		push();
		translate(width / 2, height / 2);
		scale(sf + xmotion/128, sf + xmotion/128);
		
		for (let y = 0; y <= h; y += sw) {
			for (let x = 0; x <= w; x += sh) {
				
				if (x <= 0 || x >= w || y <= 0 || y >= h) { // checkerboard pattern
					let nx = abs(0.5 - x / w) * 2;
					let ny = abs(0.5 - y / h) * 2;
				
					rotate((sf / 2 + nx * ny));
				
					let no = noise(nx * 0.5, ny * 0.5) * noise(ainp * 2)*1;
					
					let ss = abs(sin((nx * ny) * PI * (1 + cos(ymotion/4)) + inp * PI * 4 + xmotion / 3)) * 1.0;
					
					stroke(0, 0, 0, sf / 4);
					strokeWeight(0.5);
					fill((60 + ss * 200 * ainp) % 360, 32 + 64 * sf + ainp * 64, 200 * np *(frameCount/100), sf / 0.05);
					
					let vw = sw * ss - frameCount/3.5;
					let vh = sh * ss - frameCount/3.5;
					
					if (vw > 0 && vh > 0) {
						if (noise(nx * 2, ny * 2) > 0.5) {
							rect(-width / 2 + (x + abs(cos(xmotion / 4 + ainp)) * 1 * no/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y + abs(sin(ymotion / 4 + ainp)) * 1 * no /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						} else {
							ellipse(-width / 2 + (x + abs(cos(xmotion / 4 + ainp)) * 1 * no/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y + abs(sin(ymotion / 4 + ainp)) * 1 * no /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						}
					}
				}
			}
		}
		pop();
	}
	
	xmotion += 0.25;
	ymotion += 0.25;
}"
"1109278","Stacking patterns 8","mySketch","// same as parallax checkerboard with static render goal

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseDetail(6, 0.7);
	
	noStroke();
	
	rectMode(CENTER);
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	//background(0);
	noStroke();
	//fill(0, 0, 0, 0.05);
	//rect(0, 0, width, height);
	
	var context = drawingContext
	context.shadowOffsetX = sin(xmotion*2);
	context.shadowOffsetY = cos(ymotion*2);
	context.shadowBlur = 4; // more can be fun also
	context.shadowColor = ""rgba(0, 0, 0, 0.25)"";
	
	let planes = 8;

	let sw = 100;
	let sh = 100;
	
	let xp_offset = 0;
	let yp_offset = 0;
	
	let w = width;
	let h = height;
	
	for (let p = 1; p <= planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let ainp = 1-np;
		
		let sf = pow(2, ainp) / 24;
		
		push();
		translate(width / 2, height / 2);
		scale(sf + xmotion/128, sf + xmotion/128);
		
		for (let y = 0; y <= h; y += sw) {
			for (let x = 0; x <= w; x += sh) {
				
				if (x <= 0 || x >= w || y <= 0 || y >= h) { // checkerboard pattern
					let nx = abs(0.5 - x / w) * 2;
					let ny = abs(0.5 - y / h) * 2;
				
					rotate((sf / 2 + nx * ny+xmotion / 8));
				
					let no = noise(nx * 0.5, ny * 0.5) * noise(ainp * 2)*1;
					
					let ss = abs(sin((nx * ny) * PI * (1 + cos(ymotion/4)) + inp * PI * 4 + xmotion / 3)) * 1.0;
					
					stroke(0, 0, 0, sf / 4);
					strokeWeight(0.5);
					fill((60 + ss * 200 * ainp) % 360, 32 + 64 * sf + ainp * 64, 200 * np *(frameCount/100), sf / 0.05);
					
					let vw = sw * ss - frameCount/3.5;
					let vh = sh * ss - frameCount/3.5;
					
					if (vw > 0 && vh > 0) {
						if (noise(nx * 2, ny * 2) > 0.5) {
							rect(-width / 2 + (x + abs(cos(xmotion / 4 + ainp)) * 1 * no/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y + abs(sin(ymotion / 4 + ainp)) * 1 * no /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						} else {
							ellipse(-width / 2 + (x + abs(cos(xmotion / 4 + ainp)) * 1 * no/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y + abs(sin(ymotion / 4 + ainp)) * 1 * no /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						}
					}
				}
			}
		}
		pop();
	}
	
	xmotion += 0.25;
	ymotion += 0.25;
}"
"1104400","ifs polar log","mySketch","// ifs
// https://flam3.com/flame_draves.pdf

var xmotion = 0;
var ymotion = 0;

let rx = 0;
let ry = 0;
let ax = 0;
let ay = 0;

let histo = [];

function setup() {
  createCanvas(800, 800);
  background(0);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 100, 100, 1);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	rx = random(0, width);
	ry = random(0, height);
	ax = random(0, 1);
	ay = random(0, 1);
	
	for (let i = 0; i < width * height; i += 1) {
		histo[i] = 0;
	}
}

function r1(x, y) {
	return { x: x / 1, y: y / 1 };
}

function r2(x, y) {
	return { x: (width / 4.5 + x * 1) / 2, y: (height / 4.25 + y / 2.05) / 2.25 };
}

function r3(x, y) {
	return { x: (width / 1 + x) / 16 + y / 1, y: y / 1 };
}

function a1(x, y) {
	return { x: 0.25 + x / PI, y: y / 2 + x / 8.25 };
}

function a2(x, y) {
	return { x: x * 0.75 + 0.25, y: (1.0 + y * 0.5) / 16 };
}

function a3(x, y) {
	return { x: x - y / 8, y: y / 4 + x * PI };
}

var r1 = [r1, r2, r3];
var a1 = [a1, a2, a3];

var iter = 0;

function draw() {
	//fill(0, 0, 0, 1);
	//rect(0, 0, width, height);
	
	let renderAtFrame = 60 * 1;
	
	if (frameCount <= renderAtFrame) {
		for (let i = 0; i < 5000; i += 1) {
			let index1 = floor(random(0, 3));
			let r = r1[index1](rx, ry);

			rx = r.x; ry = r.y;

			let index2 = floor(random(0, 3));
			let a = a1[index1](ax, ay);

			ax = a.x; ay = a.y;

			stroke(0, 0, 255, 0.05);

			if (iter > 20) {
				let x = width / 2 + rx * (sin(ax)); //* sqrt((ax+ax) * (ay+ay)*0.05)*2);//(sin(ax * PI * 2) * cos(ay * PI * 2));
				let y = height / 2 + ry * (cos(ay)); //* sqrt((ax+ax) * (ay+ay)*0.05)*2);

				let px = width / 2 - x;
				let py = height / 2 - y;

				if (x < width && x > 0 && y < height && y > 0) {
					push();
					translate(width / 2, height / 2);
					rotate(round(iter / 100) * PI / 4);
					point(px, py);
					translate(width / 2, 0);
					point(px, py);
					point(x - width / 2.125, y - height / 1.25);
					let index = floor(x) + floor(y) * width;
					if (index >= 0 && index < (width * height)) {
						histo[index] += 1;
					}
					pop();
				}
			}

			iter += 1;
		}

		let cx = random(width / 4, width - width / 4);
		let cy = random(height / 4, height - height / 4);

		if (frameCount % (renderAtFrame) == 0) {
		//	background(0);

			generate();

			let m = 0;
			for (let j = 0; j < width * height; j += 1) {
				let value = Math.log10(histo[j]);
				m = max(m, value);
			}

			if (m > 0) {
				for (let y = 0; y < height; y += 1) {
					for (let x = 0; x < width; x += 1) {
						let index = x + y * width;
						let value = Math.log10(histo[index]);
						let gamma = 2.2;

						if (value > 0) {
							let brightness = pow(value / (1+m), 1 / gamma);
							stroke(value / m * 80, 25 + value / m * 50, brightness * 100, 1);
							let shapes = 8;
							for (let j = 0; j < shapes; j += 1) {
								let nj = j / shapes;

								push();
								//scale(nj);
								translate(width / 2, height / 2);
								rotate(j * PI / (shapes / 2));
								point(width / 2 - x, height / 2 - y);
								translate(width / 2, 0);
								point(width / 2 - x, height / 2 - y);
								point(x - width / 2.125, y - height / 1.25);
								pop();
							}
						}
					}
				}
			}
		}
	}
	
	xmotion += 0.01;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.00125);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.01);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"1097815","ifs polar","mySketch","// ifs
// https://flam3.com/flame_draves.pdf

var xmotion = 0;
var ymotion = 0;

let rx = 0;
let ry = 0;
let ax = 0;
let ay = 0;

function setup() {
  createCanvas(800, 800);
  background(0);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 100, 100, 1);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	rx = random(0, width);
	ry = random(0, height);
	ax = random(0, 1);
	ay = random(0, 1);
}

function r1(x, y) {
	return { x: x / 16, y: y / 2 };
}

function r2(x, y) {
	return { x: (width / 32 + x) / 1, y: (height / 2 + y) / 2 };
}

function r3(x, y) {
	return { x: (width + x) / 1, y: y / 2 };
}

function a1(x, y) {
	return { x: x / 2, y: y / 2 };
}

function a2(x, y) {
	return { x: (1.5 + x) / 2, y: (1 + y) / 24 };
}

function a3(x, y) {
	return { x: (4 + x) / 2, y: y / 1 };
}

var r1 = [r1, r2, r3];
var a1 = [a1, a2, a3];

var iter = 0;

function draw() {
	//fill(0, 0, 0, 1);
	//rect(0, 0, width, height);
	
	for (let i = 0; i < 2000; i += 1) {
		let index1 = floor(random(0, 3));
		let r = r1[index1](rx, ry);

		rx = r.x; ry = r.y;
		
		let index2 = floor(random(0, 3));
		let a = a1[(index1 + 1) % a1.length](ax, ay);

		ax = a.x; ay = a.y;

		stroke(0, 0, 255, 0.05);

		if (iter > 20) {
			let x = width / 2 + rx * (sin(ax * PI * 1) + cos(ax * PI * 1));//(sin(ax * PI * 2) * cos(ay * PI * 2));
			let y = height / 2 + ry * (sin(ay * PI * 2) - cos(ay * PI * 2));
			
			push();
			translate(width / 2, height / 2);
			rotate(round(iter / 100) * PI / 4);
			point(width / 2 - x, height / 2 - y);
			//rect(width - x, height - y, 1, 1);	
			pop();
		}
		
		iter += 1;
	}
	
	xmotion += 0.01;
	ymotion += 1;
}"
"1097777","ifs polar","mySketch","// ifs
// https://flam3.com/flame_draves.pdf

var xmotion = 0;
var ymotion = 0;

let rx = 0;
let ry = 0;
let ax = 0;
let ay = 0;

function setup() {
  createCanvas(800, 800);
  background(0);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 100, 100, 1);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	rx = random(0, width);
	ry = random(0, height);
	ax = random(0, 1);
	ay = random(0, 1);
}

function r1(x, y) {
	return { x: x / 2, y: y / 1 };
}

function r2(x, y) {
	return { x: (width / 2 + x) / 2, y: (height / 2 + y) / 2 };
}

function r3(x, y) {
	return { x: (width / 1 + x) / 2, y: y / 2 };
}

function a1(x, y) {
	return { x: x / 2, y: y / 2 };
}

function a2(x, y) {
	return { x: (0.5 + x) / 24, y: (1 + y) / 24 };
}

function a3(x, y) {
	return { x: (1 + x) / 2, y: y / 2 };
}

var r1 = [r1, r2, r3];
var a1 = [a1, a2, a3];

var iter = 0;

function draw() {
	//fill(0, 0, 0, 1);
	//rect(0, 0, width, height);
	
	for (let i = 0; i < 2000; i += 1) {
		let index1 = floor(random(0, 3));
		let r = r1[index1](rx, ry);

		rx = r.x; ry = r.y;
		
		let index2 = floor(random(0, 3));
		let a = a1[index1](ax, ay);

		ax = a.x; ay = a.y;

		stroke(0, 0, 255, 0.05);

		if (iter > 20) {
			let x = width / 2 + rx * sin(ax * PI * 1);//(sin(ax * PI * 2) * cos(ay * PI * 2));
			let y = height / 2 + ry * cos(ay * PI * 1);
			
			push();
			translate(width / 2, height / 2);
			rotate(round(iter / 100) * PI / 2);
			point(width / 2 - x, height / 2 - y);
			//rect(width - x, height - y, 1, 1);	
			pop();
		}
		
		iter += 1;
	}
	
	xmotion += 0.01;
	ymotion += 1;
}"
"1089297","Bumpy patterns 3","mySketch","// same as parallax checkerboard with static render goal

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseDetail(6, 0.7);
	
	noStroke();
	
	var context = drawingContext
	context.shadowOffsetX = random(-1, 1);
	context.shadowOffsetY = random(-1, 1);
	context.shadowBlur = 2; // more can be fun also
	context.shadowColor = ""black"";
	
	rectMode(CENTER);
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	//background(0);
	noStroke();
	//fill(0, 0, 0, 0.05);
	//rect(0, 0, width, height);
	
	let planes = 2;

	let sw = 100;
	let sh = 100;
	
	let xp_offset = 0;
	let yp_offset = 0;
	
	let w = width;
	let h = height;
	
	noFill();
	
	for (let p = 1; p <= planes; p += 1) {
		let np = p / planes;
		let inp = np;
		
		let ainp = abs(0.5 - np) * 2;
		
		let sf = pow(inp, 2.5);
		
		push();
		translate(width / 2, height / 2);
		//scale(1.5, 1.5);
		//scale(sf - pow(xmotion/128, 4), sf - pow(xmotion/128, 4));
		// slow
		//rotate(sf*PI*2);
		for (let y = 0; y <= h; y += sw) {
			for (let x = 0; x <= w; x += sh) {
				if ((x % (sw * 2)) ^ (y % (sh * 2))) { // checkerboard pattern
					let nx = abs(0.5 - x / w) * 2;
					let ny = abs(0.5 - y / h) * 2;
					
					let no = noise(nx * 8 + xmotion/32);
					
					let ss = (sin((nx * ny) * PI * 2 + inp * PI * 2 + xmotion / 64 * sf)) * 2;
					
					stroke((0 + (1 - np) * 32 * sf + no * 32 + nx * ny * 180) % 360, 128, 255, 1-sf / 4 * ss);
					strokeWeight(1);
					//fill(0, 0, 0, sf);
					
					let vw = sw * ss;
					let vh = sh * ss;
					
					if (vw > 0 && vh > 0) {
						if (noise(nx * 8, ny * 8) > 0.5) {
							rect(-width / 2 + (x/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y/* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						} else {
							ellipse(-width / 2 + (x/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						}
					}
				}
			}
		}
		pop();
	}
	
	xmotion += 0.25;
	ymotion += 0.25;
}"
"1083881","Mould","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 6;

function setup() {
  createCanvas(800, 800);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (1.0 + abs(sin(x / width * PI * 1.25 + cos(y / height * PI * 1.25 + pow(x/ width, 16) * PI * 2.05)))), y: (width / (1) + x - y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.25 * x) / 1 + j * (70), y: (height / 8 - y * 2 / j + (x / 4.0)) / 1.0 + j * (70) };
}

function f3(x, y, j) {
	return { x: (width * 0.5 - x * j) / (24 * (j / 16) + x / (width / (10))), y: y / 3 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.0 + abs(sin(x / width * PI * 0.25 + cos(y / height * PI * 0.25 + pow(x/ width, 2) * PI * 1.05)))), y: (width / (2) + x - y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.25 * x) / 1 + j * (50), y: (height / 4 - y * 3 / j + (x / 4.0)) / 1.0 + j * (20) };
}

function f6(x, y, j) {
	return { x: (width * 0.5 - x * j) / (24 * (j / 16) + x / (width / (10))), y: y / 4 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 5000) {
		for (let i = 0; i < 10000; i += 1) {
			for (let j = 5; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let ny1 = x[j] / width;
				let nx1 = y[j] / height;
				let inx1 =((1.5)+pow((0.25-nx1), 8));
				
				let ny2 = x2[j] / width;
				let nx2 = y2[j] / height;
				let inx2 =((1.5)+pow(nx2, 2));
				/*
				let nx2 = y2[j] / height;
				let inx2 = 0.95+pow((0.5-nx1), 16);
				*/
				let e = 0.75;

				if (iter > 20) {
					stroke((xmotion*64+iter*64)%360, 128, 255, 0.035 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);
					//point(width - x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					//point(x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					
					//point(x2[j] * inx2+5, height / 1 - y2[j]/2.5);
					//point(width - x2[j] * inx2-5, height / 1 - y2[j]/2.5);
					//point(width / 2 - x[j] / 3.0 * inx1 - width / 4 * sin(nx1*PI*0.5), y[j]/4);
					//point(width - (width / 2 - x[j] / 3.0 * inx1 - width / 4 * sin(nx1*PI*0.5)), y[j]/4);
					//point(x[j] / 8, y[j]/4);
					//point(y[j] / 4, x[j]/8);
				//	point(width - y[j] / 6, x[j]/6);
				//	point(y[j] / 6, x[j]/6);
					//point(width / 1.9 + x[j] / 8.0 * inx1 + width / 2 * abs(cos(ny1*PI*0.5 * pow(sin(nx1 * PI *0.25), 4))), height - (y[j]/2.5) - height / 2);
					//point(width - (width / 1.9 + x[j] / 8.0 * inx1 + width / 2 * abs(cos(ny1*PI*0.5 * pow(sin(nx1 * PI *0.25), 4)))), height - (y[j]/2.5) - height / 2);
				//	point(width / 12 + x[j] / 4.5 * inx1 + width / 2 * (cos(ny1*PI*0.25)), height / 8 + y[j]/1.6);
				//	point(width - (width / 12 + x[j] / 4.5 * inx1 + width / 2 * (cos(ny1*PI*0.25))), height / 8 + y[j]/1.6);
					
					//point(width - y2[j] / 6, x2[j]/6);
					//point(y2[j] / 6, x2[j]/6);
					point(width / 12 + x2[j] / 4.5 * inx2 + width / 2 * (cos(ny2*PI*0.25)), height / 8 + y2[j]/1.6);
					point(width - (width / 12 + x2[j] / 4.5 * inx2 + width / 2 * (cos(ny2*PI*0.25))), height / 8 + y2[j]/1.6);
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	} else {
		iter = 0;
		xmotion += 0.01;
	}

	//xmotion += 1;
	ymotion += 0.25;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"1083873","The tree2","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 6;

function setup() {
  createCanvas(800, 800);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (1.0 + abs(sin(x / width * PI * 4.25 + cos(y / height * PI * 1.25 + pow(x/ width, 4) * PI * 4.05)))), y: (width / (1) + x - y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.25 * x) / 1 + j * (70), y: (height / 8 - y * 2 / j + (x / 4.0)) / 1.0 + j * (70) };
}

function f3(x, y, j) {
	return { x: (width * 0.5 - x * j) / (24 * (j / 16) + x / (width / (10))), y: y / 3 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.0 + abs(sin(x / width * PI * 1.25 + cos(y / height * PI * 0.25 + pow(x/ width, 1) * PI * 2.05)))), y: (width / (1) + x - y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.25 * x) / 1 + j * (60), y: (height / 8 - y * 2 / j + (x / 4.0)) / 1.0 + j * (70) };
}

function f6(x, y, j) {
	return { x: (width * 0.5 - x * j) / (24 * (j / 12) + x / (width / (10))), y: y / 3 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 5000) {
		for (let i = 0; i < 10000; i += 1) {
			for (let j = 5; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let ny1 = x[j] / width;
				let nx1 = y[j] / height;
				let inx1 =((1.5)+pow((0.25-nx1), 8));
				
				let ny2 = x2[j] / width;
				let nx2 = y2[j] / height;
				let inx2 =((1.5)+pow((0.25-nx2), 8));
				/*
				let nx2 = y2[j] / height;
				let inx2 = 0.95+pow((0.5-nx1), 16);
				*/
				let e = 0.75;

				if (iter > 20) {
					stroke((xmotion*64+iter*64)%360, 128, 255, 0.035 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);
					//point(width - x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					//point(x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					
					//point(x2[j] * inx2+5, height / 1 - y2[j]/2.5);
					//point(width - x2[j] * inx2-5, height / 1 - y2[j]/2.5);
					//point(width / 2 - x[j] / 3.0 * inx1 - width / 4 * sin(nx1*PI*0.5), y[j]/4);
					//point(width - (width / 2 - x[j] / 3.0 * inx1 - width / 4 * sin(nx1*PI*0.5)), y[j]/4);
					//point(x[j] / 8, y[j]/4);
					//point(y[j] / 4, x[j]/8);
				//	point(width - y[j] / 6, x[j]/6);
				//	point(y[j] / 6, x[j]/6);
					//point(width / 1.9 + x[j] / 8.0 * inx1 + width / 2 * abs(cos(ny1*PI*0.5 * pow(sin(nx1 * PI *0.25), 4))), height - (y[j]/2.5) - height / 2);
					//point(width - (width / 1.9 + x[j] / 8.0 * inx1 + width / 2 * abs(cos(ny1*PI*0.5 * pow(sin(nx1 * PI *0.25), 4)))), height - (y[j]/2.5) - height / 2);
				//	point(width / 12 + x[j] / 4.5 * inx1 + width / 2 * (cos(ny1*PI*0.25)), height / 8 + y[j]/1.6);
				//	point(width - (width / 12 + x[j] / 4.5 * inx1 + width / 2 * (cos(ny1*PI*0.25))), height / 8 + y[j]/1.6);
					
					//point(width - y2[j] / 6, x2[j]/6);
					//point(y2[j] / 6, x2[j]/6);
					point(width / 12 + x2[j] / 4.5 * inx2 + width / 2 * (cos(ny2*PI*0.25)), height / 8 + y2[j]/1.6);
					point(width - (width / 12 + x2[j] / 4.5 * inx2 + width / 2 * (cos(ny2*PI*0.25))), height / 8 + y2[j]/1.6);
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	} else {
		iter = 0;
		xmotion += 0.01;
	}

	//xmotion += 1;
	ymotion += 0.25;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"1083576","Fake 3d","mySketch","// same as parallax checkerboard with static render goal
let zmotion = 0;

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseDetail(6, 0.7);
	
	noStroke();
	
	rectMode(CENTER);
	
	var context = drawingContext
	context.shadowOffsetX = sin(xmotion)/2;
	context.shadowOffsetY = cos(xmotion)/2;
	context.shadowBlur = 1; // more can be fun also
	context.shadowColor = ""black"";
}

let xmotion = 0;
let ymotion = 0;

function d(sf) {
	//background(0);
	noStroke();
	//fill(0, 0, 0, 0.05);
	//rect(0, 0, width, height);
	

	
	let planes = 1;

	let sw = 100;
	let sh = 100;
	
	let xp_offset = 0;
	let yp_offset = 0;
	
	let w = width;
	let h = height;
	
	for (let p = 1; p <= planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let ainp = abs(0.5 - np) * 2;
		
		//let sf = pow(1, ainp) / 8;
		
		push();
		translate(width / 2, height / 2);
		scale(sf, sf);
		
		for (let y = 0; y <= h; y += sw) {
			for (let x = 0; x <= w; x += sh) {
				
				if (x != w / 2 && y != h / 2) { // checkerboard pattern
					let nx = abs(0.5 - x / w) * 2;
					let ny = abs(0.5 - y / h) * 2;
				
					//rotate(sf * 2 + nx * ny);
				
					let no = noise(nx * 0.5, ny * 0.5) * noise(ainp * 2)*1;
					
					let ss = noise(nx, ny + xmotion / 4); //abs(sin((nx * ny) * PI * 2 + inp * PI * 2 + xmotion / 8)) * 1;
					
					stroke(0, 0, 0, sf / 2);
					strokeWeight(0.5);
					fill((80 + no * 360 * ainp) % 360, 255 * sf + ainp * 128, 192 * np *(frameCount/100), sf / 0.05);
					
					let vw = sw * ss - frameCount/3/**(sin(nx * PI * 2 + zmotion) - cos(ny * PI * 2 + zmotion))/2*/;
					let vh = sh * ss - frameCount/3/**(cos(nx * PI * 2 + zmotion) + sin(ny * PI * 2 + zmotion))/2*/;
					
					//if (vw > 0 && vh > 0) {
						//if (noise(nx * 2, ny * 2) > 0.5) {
						//	rect(-width / 2 + (x + abs(cos(xmotion / 4 + ainp)) * 1 * no/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
						//					-height / 2 + (y + abs(sin(ymotion / 4 + ainp)) * 1 * no /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
						//					vw,
						//					vh);
						//} else {
							ellipse(-width / 2 + (x /* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y/* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						//}
					//}
				}
			}
		}
		pop();
	}
	
	xmotion += 0.25;
	ymotion += 0.25;
}

function draw() {
	background(0);
	
	noStroke();
	
	let lastxmotion = xmotion;
	let lastymotion = ymotion;
	for (let i = 0; i < 100; i += 1) {
		let ni = i / 1000;
		let no = ni * width / 1.;
		
		let ns = sin(ni * PI * 0.5 + xmotion) * (128 * (1-ni));
		
		//let nc = sin(ni * PI * 1 + xmotion) * (256 * ni);
		
		//let x = round(width / 2 - 16 - no);
		
		fill(0, 0, 255-ni * 255, 1);
		for (let j = -8; j < 8; j += 1) {
			let nj = j / 8;
			
			rect(width / 2 - 16 - no, height / 2 + nj * (ns * 4), ns, ns);
			rect(width / 2 + 16 + no, height / 2 + nj * (ns * 4), ns, ns);
			rect(width / 2 - 16 - no + nj * (ns * 1), height / 2 + nj * (ns * 2), ns, ns);
			rect(width / 2 + 16 + no - nj * (ns * 1), height / 2 + nj * (ns * 2), ns, ns);
		}
	}
	
	xmotion = lastxmotion;
	ymotion = lastymotion;
	
	xmotion += 0.025;
	ymotion += 0.25;
	
	zmotion += 0.01;
}"
"1079290","The tree2","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 6;

function setup() {
  createCanvas(800, 800);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (1.0 + abs(sin(x / width * PI * 1.25 + cos(y / height * PI * 1.25 + pow(x/ width, 1) * PI * 0.05)))), y: (width / (1) + x - y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.25 * x) / 1 + j * (70), y: (height / 8 - y * 2 / j + (x / 4.0)) / 1.0 + j * (70) };
}

function f3(x, y, j) {
	return { x: (width * 0.5 - x * j) / (24 * (j / 16) + x / (width / (10))), y: y / 3 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.0 + abs(sin(x / width * PI * 1.25 + cos(y / height * PI * 0.25 + pow(x/ width, 1) * PI * 0.05)))), y: (width / (1) + x - y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.25 * x) / 1 + j * (60), y: (height / 8 - y * 2 / j + (x / 4.0)) / 1.0 + j * (70) };
}

function f6(x, y, j) {
	return { x: (width * 0.5 - x * j) / (24 * (j / 12) + x / (width / (10))), y: y / 3 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 5000) {
		for (let i = 0; i < 10000; i += 1) {
			for (let j = 5; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let ny1 = x[j] / width;
				let nx1 = y[j] / height;
				let inx1 =((1.5)+pow((0.25-nx1), 8));
				
				let ny2 = x2[j] / width;
				let nx2 = y2[j] / height;
				let inx2 =((1.5)+pow((0.25-nx2), 8));
				/*
				let nx2 = y2[j] / height;
				let inx2 = 0.95+pow((0.5-nx1), 16);
				*/
				let e = 0.75;

				if (iter > 20) {
					stroke((xmotion*64+iter*64)%360, 128, 255, 0.035 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);
					//point(width - x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					//point(x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					
					//point(x2[j] * inx2+5, height / 1 - y2[j]/2.5);
					//point(width - x2[j] * inx2-5, height / 1 - y2[j]/2.5);
					//point(width / 2 - x[j] / 3.0 * inx1 - width / 4 * sin(nx1*PI*0.5), y[j]/4);
					//point(width - (width / 2 - x[j] / 3.0 * inx1 - width / 4 * sin(nx1*PI*0.5)), y[j]/4);
					//point(x[j] / 8, y[j]/4);
					//point(y[j] / 4, x[j]/8);
				//	point(width - y[j] / 6, x[j]/6);
				//	point(y[j] / 6, x[j]/6);
					//point(width / 1.9 + x[j] / 8.0 * inx1 + width / 2 * abs(cos(ny1*PI*0.5 * pow(sin(nx1 * PI *0.25), 4))), height - (y[j]/2.5) - height / 2);
					//point(width - (width / 1.9 + x[j] / 8.0 * inx1 + width / 2 * abs(cos(ny1*PI*0.5 * pow(sin(nx1 * PI *0.25), 4)))), height - (y[j]/2.5) - height / 2);
				//	point(width / 12 + x[j] / 4.5 * inx1 + width / 2 * (cos(ny1*PI*0.25)), height / 8 + y[j]/1.6);
				//	point(width - (width / 12 + x[j] / 4.5 * inx1 + width / 2 * (cos(ny1*PI*0.25))), height / 8 + y[j]/1.6);
					
					//point(width - y2[j] / 6, x2[j]/6);
					//point(y2[j] / 6, x2[j]/6);
					point(width / 12 + x2[j] / 4.5 * inx2 + width / 2 * (cos(ny2*PI*0.25)), height / 8 + y2[j]/1.6);
					point(width - (width / 12 + x2[j] / 4.5 * inx2 + width / 2 * (cos(ny2*PI*0.25))), height / 8 + y2[j]/1.6);
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	} else {
		iter = 0;
		xmotion += 0.01;
	}

	//xmotion += 1;
	ymotion += 0.25;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"1074674","Colors 2","mySketch","function setup() {
	createCanvas(800, 800);
	
	noStroke();
	
	background(0);
	
	colorMode(HSL, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	generate();
}

function draw() {
	
}

function generate() {
	noStroke();
	
	background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	let wl = 255 * (height / 976);
	let m = 0; // get max y
	for (y = 0; y < (height - m); y += 1) {
		let yy = y + m;

		let ny = y / height;
		let noy = noise(ny);
		
		for (x = 0; x < width; x += 1) {
			let nx = x / width;
			let nox = noise(nx * 2, ny * 4);
			let nox2 = (0.5 - noise(nx, ny)) * 2;
			let nox3 = noise(nx / 4, ny / 4);
			let n = ((sin(nx * PI * 0.25 + ny * PI * 0.5 + nox * PI * 0.15) % abs(cos(ny * PI * 4 * nox3 + nx * PI * 1))))/ 1 * nox2;
			
			if (random() > 0.5) {
				stroke(220 + (nox2 + n) * 18, 200 * nox3, 200*nox3-random(120) * n/2, random() * 0.5);
				let xx = x + random(-2, 2);
				line(xx, yy, xx + random(-200, 200) * n * noy, yy + random(-20, 20) * n);
			}
		}
	}

}"
"1073589","Snowscape","mySketch","function setup() {
	createCanvas(1080, 566);
	
	noStroke();
	
	background(0);
	
	colorMode(HSL, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.8);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	generate();
}

function draw() {
	
}

function generate() {
	noStroke();
	
	background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 24, ny / 24);
			let n2 = noise(nx / 8, ny / 8);
			
			let yy = height / 3.9 + y - n * height;
			fill(210 - 20 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 2.0 + ny * PI * 2 + 1))), 128, 0 + pow(ny, 1) * 190, random(0.125, 0.25));
			//stroke(0, 0, random(0, 128), random(0,0.25));
			ellipse(x + random(-16, 16), yy + random(-8, 8), 24, 24);
		}
	}
	
	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 4, ny / 4);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height / 1;
			fill(0, 32 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))), 48 + pow(ny, 1) * 216, 1);
			stroke(0, 0, random(0, 255), random(0,0.15));
			ellipse(x + random(-1, 1), yy + random(-1, 1), 12, 6 * ((1-ny) * 8));
			
			stroke(0, 0, random(0, 255), random(0,0.15));
			line(random(x - 4, x + 4), random(y - 4, y + 4), random(x - 4, x + 4), random(y - 4, y + 4));
		}
	}
	/*
	for (y = 0; y < height; y += 2) {
		let ny = y / height;
		for (x = 0; x < width; x += 2) {
			let nx = x / width;
			let n = noise(nx / 4, ny / 4);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(0, 0, 120 + pow(ny, 1) * 68, random(0,0.45) * ny);
			line(random(x - 32, x + 32), random(yy-8, yy + 8), random(x - 32, x + 32), random(yy - 8, yy + 8));
		}
	}
	
	
	for (y = height; y > 0; y -= 8) {
		for (x = 0; x < width; x += 8) {
			if (random() > 0.5) {
				stroke(0, 0, 255, random(0, 0.45));
				let xx = x + random(-4, 4);
				line(xx, y, xx + random(-1, 1), y + random(-1, 1));
			}
		}
	}
*/
	
	for (y = 0; y < height / 2.5; y += 2) {
		stroke(224, 128, 0, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.99) {
				stroke(0, 0, 255, random() * 0.25);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
	
	//fill(0, 0, 0, 1);
	//rect(width / 2, height / 2 - height / 2.5 / 2 + 40, width / 10, height / 2.5);
	
	let wl = 255 * (height / 976);
	let m = 0; // get max y
	for (y = 0; y < (height - m); y += 1) {
		let ny = y / height;
		let noy = noise(ny);
		
		for (x = 0; x < width; x += 1) {
			let yy = (height / 2.25 + noise(x / width) * 24) + y + m;
			
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = (0.5 - noise(nx, ny)) * 2;
			let nox3 = noise(nx / 2, ny / 2);
			let n = (sin(nx * PI * 4.5 + ny * PI * 1 + nox * PI * 2.15)) / 2 * nox2;
			
			if (random() > 0.25) {
				
				let xx = x + random(-2, 2);
				let yh2 = random(-100, 100) * n * pow(ny, 1.5);
				noStroke();
				
				let ce = sin(nx * PI * 1) * cos(ny * PI * 1.5) * pow(1-ny, 0.25);
				
				if (random() > (0.25 + 0.75 * pow(abs(0.5 - (1 - ny))*2 * 0.75, 2)) && ce > 0.0) {
					fill(64, 64, 255, 1);
					rect(xx, yy - yh2 + random(-height, height), random(1, 5) * ny, 3 * ny);
				}
				
				stroke(128 + (nox2) * 8, 0 * nox3, (180*nox3-random(100) * n) + ce * 200, random() * 0.45 * pow(ny, 0.3));
				line(xx, yy, xx + random(-70, 70) * n * noy * ny, yy + yh2);
			}
		}
	}

	
/*
	for (y = 0; y < height / 2; y += 16) {
		let ny = y / height;
		let noy = noise(ny);
		for (x = 0; x < width; x += 3) {
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = noise(nx, ny);
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2 * nox2;

			let yy = y;

			if (random() > 0.999) {
				stroke(0, 0, 0, 1);
				strokeWeight(0.5);
				let tx = x + random(1, 6);
				let ty = yy + random(1, 6);
				line(x, yy, tx, ty);
				line(tx, ty, tx + random(1, 6) * (1-ny), ty - random(1, 4) * (1-ny));
			}
		}
	}*/
}"
"1072616","L-systems random","mySketch","// more automatic drawing by generating L-systems rules + switching rules randomly

function pal(t, a, b, c, d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

function weightedRandom(prob) {
  let i, sum=0, r=Math.random();
  for (i in prob) {
    sum += prob[i];
    if (r <= sum) return i;
  }
}

class lm {
	constructor(axiom, rules, angle, step, iter) {
		this.ax = width / 2;
		this.ay = height / 2;
		this.px = this.ax;
		this.py = this.ay;
		this.ta = angle;
		this.ca = PI;
		this.fs = step;
		
		this.stack = [];
		
		this.axiom = axiom;
		this.rules = rules;
		this.itera = iter;
		
		this.rule = 0;
		
		this.cycles = 0;
		
		this.b = false;
		
		this.where = 1;
		
		this.initialize();
	}
	
	initialize() {
		let rule = this.axiom;
		for (let i = 0; i < this.itera; i++) {
			rule = this.lindenmayer(rule);
		}
		
		this.rule = rule;
	}
	
	lindenmayer(s) {
		let outputstring = '';

		for (let i = 0; i < s.length; i++) {
			let ismatch = 0;
			for (let j = 0; j < this.rules.length; j++) {
				if (s[i] == this.rules[j][0])  {
					let rule_index = 1;
					if (this.rules[j].length > 2) { // stochastic
						let probs = {};
						for (let k = 1; k < this.rules[j].length; k+=2) {
							probs[k+1] = this.rules[j][k];
						}
						rule_index = weightedRandom(probs);
					}
					outputstring += this.rules[j][rule_index];
					ismatch = 1;
					break;
				}
			}

			if (ismatch == 0) outputstring+= s[i];
		}
		
		return outputstring;
	}
	
	computeParameters(w) {
		
	}
	
	compute(cb_trigger) {
		let k = this.rule[this.where];
		if (k == 'F' || k == 'f') {
			var polx = this.fs * sin(this.ca);
			var poly = this.fs * cos(this.ca);
			let x1 = this.b ? this.px - polx : this.px + polx;
			let y1 = this.b ? this.py - poly : this.py + poly;

			if (x1 < 0 || y1 < 0 || x1 > width || y1 > height) {
				//this.b = !this.b;
				//this.ta = -this.ta;//random() * PI * 2;
				
				if (x1 < 0) { x1 = width; this.px = width; }
				//if (y1 < 0) { y1 = height; this.py = height; this.ta = 0; }
				if (x1 > width) { x1 = 0; this.px = 0; }
				if (y1 > height) { y1 = height; this.py = height; this.ca = PI; this.ta = 0; }
			}

			this.ax = this.px;
			this.ay = this.py;
			this.px = x1;
			this.py = y1;
		} else if (k == '[') {
			this.stack.push(this.px);
			this.stack.push(this.py);
			this.stack.push(this.ca);
		} else if (k == ']') {
			this.ca = this.stack.pop();
			this.py = this.stack.pop();
			this.px = this.stack.pop();
		} else if (k == '+') {
			this.ca += this.ta;
		} else if (k == '-') {
			this.ca -= this.ta;
		}
		
		this.where++;
  	if (this.where > this.rule.length-1 || random() > 0.9995) {
			this.where = 0;
			this.cycles += 1;
			
			cb_trigger(this);
		}
		
		if (k == 'F') {
			return true;
		} else {
			return false;
		}
	}
}

var xmotion = 0;
var ymotion = 0;

let lms = [];

function getRule(n) {
	let nx = n ? (1 - n / width) : 1;
	
	let len = 24 + random() * 300 * nx;
	let rule = [''];
	let stak = [];
	let last = '';
	for (let i = 0; i < len; i += 1) {
		let c = ['X', '+', '-', 'F', '[', ']']
		let chosen = c[floor((c.length-1) * random())];
		
		if (last == '' && chosen == '[') {
			chosen = c[floor((c.length-2) * random())];
		}
		
		if (chosen == '[') {
			stak.push(']');
		} else if (chosen == ']' && stak.length == 0) {
			chosen = c[floor((c.length-2) * random())];
		} else if (chosen == ']' && last == '[') {
			chosen = c[floor((c.length-2) * random())];
		}
		
		rule[0] += chosen;
		
		last = chosen;
	}
	
	while (stak.length) {
		let last = rule[0][rule[0].length - 1];
		
		if (last == '[') {
			rule[0] = rule[0].slice(0, rule[0].length - 1)
			stak.pop();	
		} else {
			rule[0] += stak.pop();	
		}
	}
	
	return rule;
}

function setup() {
  createCanvas(840, 840);
  background(0);
	
	noiseDetail(6, 0.85);
	//colorMode(HSB, 360, 100, 100, 255);
	
	//blendMode(LIGHTEST);
	
	stroke(0, 0, 100, 255);
 // lms[0] = new lm('X', [['X', 0.5, 'XFFFF-[F-X+]FX+', 0.5, 'FFFFF[f+F]------------F'], ['F', '+F--F+']], radians(45), 1);
	let amount = 100;
	for (let i = 0; i < amount; i += 1) {
		lms[i] = new lm('X', [['X', getRule()[0]], ['F', 'F++++']],0, 1, 2);
		lms[i].px = random(0, width); lms[i].py = height;
	}
	//lms[1] = new lm('X', [['X', 'F-[[X]+X]+F[+FX]-X'], ['F', 'FF']], radians(90), 1);
	
	colorMode(RGB, 255, 255, 255, 255);
}

function change(lm) {
	let max_cycles = 1;
	noStroke();
	if (lm.cycles % max_cycles == 0) {
		lm.ta = random(-PI, PI) * pow(1 - lm.py / height, 2) * (1 - abs(0.5 - lm.px / width) * 2);
		lm.fs = 0.5 + noise(lm.ta) * 0.5;
		
		lm.ca = PI + random(-0.75, 0.75) * (1 - abs(0.5 - lm.px / width) * 2);
		
		let rule = getRule(lm.px)[0];
		/*
		if (rule.length < 64) {
			lm.itera = 1 + floor(random() * 4);
		} else if (rule.length < 128) {
			lm.itera = 1 + floor(random() * 3);
		} else if (rule.length < 256) {
			lm.itera = 1 + floor(random() * 2);
		} else {
			lm.itera = 1 + floor(random() * 2);
		}*/
		lm.cycles = 0;

		lm.rules = [['X', rule], ['F', 'F']];
		lm.initialize();
		
		//fill(0, 0, 0, 92);
		//rect(0, 0, width, height);
	}
	
	/*
	if (lm.cycles % 16 == 0) {
		fill(0, 0, 0, 48);
		rect(0, 0, width, height);
	}
	*/
	
	let nc = (lm.cycles % 8) / 8;
	stroke(0, 0, 100, random(0, 10));
	
	//if (random() > 0.25) {
		//lm.iter = 1;
		//lm.initialize();
	/*} else {
		lm.iter = 2;
		lm.initialize();
	}*/
}

function draw() {
	let km = 100;
	for (let k = 0; k < km; k += 1) {
		for (let i = 0; i < lms.length; i += 1) {
			let lm = lms[i];
			
			let result = lm.compute(change);
			
			if (result) {
				//stroke(k / 3 + abs(sin(xmotion/24))*180, 30, 255, 255);
			var pa1 = 1, pa2 = 1, pa3 = 1;
			var pb1 = 1, pb2 = 0.65, pb3 = 1.0;
			var pc1 = 1, pc2 = 0.25, pc3 = 0.5;

			var pdr = 0.0;
			var pdg = 0.1;
			var pdb = 0.2;

				var pt = abs(sin((xmotion%(km * 100))/k/50 * PI * 2));

				var rf = pal(pt, pa1, pb1, pc1, pdr) * 255;
				var gf = pal(pt, pa2, pb2, pc2, pdg) * 255;
				var bf = pal(pt, pa3, pb3, pc3, pdb) * 255;

				stroke(rf, gf, bf, 255);
				
				strokeWeight(1/* + abs(sin(xmotion/16+i))*8*/);
				var context = drawingContext
        context.shadowOffsetX = random(-8, 8) * pow(1-lm.py / height, 1);
        context.shadowOffsetY = random(-8, 8) * pow(1-lm.py / height, 1);
        context.shadowBlur = 1 + 4 * pow(lm.py / height, 1);
        context.shadowColor = ""black"";
				line(lm.px, lm.py, lm.ax, lm.ay);
				//line(lm.px, height - lm.py, lm.ax, height - lm.ay);
			}
		}
	}
	
	xmotion += 0.5;
	ymotion += 0.25;
}

"
"1068484","Noise1","mySketch","// doing it by following lines instead of per pixels (note : mostly useless in that case but the result look nice)

float xmotion = 8.8;
float ymotion = 2.2;

int reset = 0;
int perlin_amount = 800;

float[] ppx = new float[800 * 800];
float[] ppy = new float[800 * 800];

// https://iquilezles.org/www/articles/palettes/palettes.htm
float pal(float t, float a, float b, float c, float d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

void shapel(float x1, float y1, float x2, float y2, float dirx, float diry) {
	float dx = x2 - x1;
	float dy = y2 - y1;
	
	float xx1 = x1;
	float xx2 = x2;
	if (x1 > x2) {
		xx1 = x2;
		xx2 = x1;
	}
	//noStroke();
	strokeWeight(0.5);
	for (float x = xx1; x < xx2; x += 1) {
		float norm_dst = abs(x - xx2) / abs(xx2);
		float anorm_dst = 1.0 - abs(0.5 - norm_dst) * 8;
		
		float y = y1 + dy * (x - x1) / dx;
		
		float ynorm = (y + ymotion * 1) / (float)height;
		
		float anorm_y = 1.0 - abs(0.5 - ynorm) * 2;
		
		float anorm_y2 = 1.0 - abs(0.5 - ynorm) * 2;
		
		//if (anorm_dst > -0.5 && anorm_dst < 0.5) anorm_dst = lerp(anorm_dst, anorm_dst * 2 * anorm_y, anorm_dst * 2);
		
		float moda = cos(ynorm * PI * 1.5 + n2 * PI * 1);
		float modb = sin(norm_dst * PI * 2.5 + n2 * PI * 1);
		
		float mod = abs(moda % modb);
		
		if (ynorm > 0.5) mod = (lerp(mod - norm_dst, anorm_y, (ynorm - 0.5) * 3.5));
		else mod = (mod - norm_dst);
		
		float n2 = (0.5-noise(anorm_dst + xmotion / 24 * anorm_y2, anorm_y2 + ymotion / 24)) * 2 / (1 + anorm_y * 3);
		float n = (0.5-noise(anorm_dst + xmotion / 32 * anorm_y2, anorm_y2 + ymotion / 32)) * 2 * ynorm * mod; //% (0.5-noise(anorm_dst + xmotion / 8 * anorm_y2, anorm_y2 + ymotion / 8)) * 2;
		
		float pa = 0.5 + abs(n / 2);
		float pb = 0.5 - abs(n / 2);
		float pc = 1;
		
		float pdr = 0.12;
		float pdg = 0.05;
		float pdb = 1;
		
		float rf = pal(ynorm, pa, pb, pc, pdr) * 255;
		float gf = pal(ynorm, pa, pb, pc, pdg) * 255;
		float bf = pal(ynorm, pa, pb, pc, pdb) * 255;
		
		fill(rf, gf, bf, 92 * abs(n) * 6);
		stroke(rf / 0.5, gf / 0.5, bf / 0.5, 48 * abs(n) * 4);
		
		float s = 32 * abs(n);
		
		if (dirx < 0 && diry < 0) {
			ellipse(x - n * 3 + cos(anorm_dst * PI * 3 + xmotion) * 4, y - n * 140 - ymotion * 4.5 + sin(anorm_dst * PI * 0.25 + xmotion) * 8 * anorm_dst * (1-ynorm), s, s);
		} else if (dirx > 0 && diry > 0) {
			ellipse(x + n * 3 + cos(anorm_dst * PI * 3 + xmotion) * 4, y + n * 140 + ymotion * 4.5 + sin(anorm_dst * PI * 0.25 + xmotion) * 8 * anorm_dst * (1-ynorm), s, s);
		} else if (dirx < 0 && diry > 0) {
			ellipse(x - n * 3 + cos(anorm_dst * PI * 3 + xmotion) * 4, y + n * 140 + ymotion * 4.5 + sin(anorm_dst * PI * 0.25 + xmotion) * 8 * anorm_dst * (1-ynorm), s, s);
		} else if (dirx > 0 && diry < 0) {
			ellipse(x + n * 3 + cos(anorm_dst * PI * 3 + xmotion) * 4, y - n * 140 - ymotion * 4.5 + sin(anorm_dst * PI * 0.25 + xmotion) * 8 * anorm_dst * (1-ynorm), s, s);
		}
		
		//stroke(rf, gf, bf, 16 * abs(n));
		//line(x - n * 40 - xmotion * 8, y - n * 40 + ymotion * 8, x + n * 40 - xmotion * 8, y + n * 40 + ymotion * 8);
	}
	
	stroke(0, 0, 255, 1);
}

void draw_func() {
	noStroke();
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	float x1 = -200;
	float y1 = 4;
	float x2 = width;
	float y2 = -4.1 + ymotion * 1;
	
	stroke(0, 0, 255, 1);
	//line(x1, y1, x2, y2);
	
	
	//shapel(x1, y1, x2, y2, 1, 1);
	shapel(x1, y1, x2, y2, -1, 1);
	
	x1 = -200;
	y1 = height;
	x2 = width;
	y2 = (height-0.1);
	//line(x1, y1, x2, y2);

	//shapel(x1, y1, x2, y2, -1, -1);
	/*
	x1 = 0;
	y1 = height - height /1.99;
	x2 = width;
	y2 = height - height /2;
	//line(x1, y1, x2, y2);

	shapel(x1, y1, x2, y2, 1, -1);
	
	x1 = 0;
	y1 = height /1.99;
	x2 = width;
	y2 = height /2;
	//line(x1, y1, x2, y2);

	shapel(x1, y1, x2, y2, 1, -1);
			*/	
				xmotion += 0;
				ymotion += 0.25;
}

void setup() {
  size(800, 800);

  background(0);
	
	//colorMode(HSB, 360, 256, 256);
	
	noiseDetail(7,0.65);
	
	frameRate(60);
	
	
		noFill();
		noStroke();

		rectMode(CENTER);
		ellipseMode(CENTER);

		stroke(0, 0, 255, 255);
		strokeWeight(2);
		strokeCap(ROUND);
		noFill();
		int nx = random(width / 2);
		int ny = random(height / 2);
		
		int lx = nx + random(width - nx);
		
		//line(0, height - 192, width, height - 192);
	  //line(0, height - 192 / 1.15, width, height - 192 / 1.15);
	  //line(0, height - 192 / 1.3, width, height - 192 / 1.3);
	  //line(2 * 92, height + (2 - 1.45 * 512), width / 2, height + (2 - 1.45 * 512));
	  //line(3 * 84, height - 512, width / 2 - 3 * 84, height - 512);
	  //bezier(3.1 * 84, height - 550, 400, 0, 0, 0, 0, height - 2 * 550);
	 // bezier(2.6 * 84, height - 512, 400, 0, 100, 0, -200, height - 2 * 512);
	 // bezier(2 * 84, height - 512, 400, 0, 100, 0, -200, height - 2 * 512);
	  //bezier(1.4 * 84, height - 512, 400, 0, 100, 0, -200, height - 2 * 512);
	  //line(4 * 92, height - 1.25 * 512, width / 2 - 4 * 92, height - 1.25 * 512);
	
	  
	  //rect(width / 2, height / 5, width / 5.5, width / 7);
	  //ellipse(width / 2, height / 5, width / 4, width / 7);
		
	  //line(2 * 92, height - 180, 64 + 2 * 148, height + (2 - 2 * 512));
	  //line(-92, height - 180, 64 + 48, height + (2 - 1 * 512));
	
	for (int i = 0; i < 3; i += 1) {
		//line(i * 92, height - 180, 64 + i * 148, height + (2 - i * 512));
		//line(64 + i * 92, 0, 64 + i * 92, (128 + i * 32));
		//line(64 + i * 92, 0, 256 + i * 92, (128 + i * 32));
	  //line(width / 3 - i * 128, height - 64, width / 3 - i * 128, height / 2 + height / 5);
	}
	//stroke(0, 0, 255, 92);
	
	//line(width / 2, height - 210, width / 2, height - 192);
	/*
	for (int i = 0; i < 8; i += 1) {
		ellipse(random(width / 8), random(height / 2, height / 1.6), 1, 1);
	}*/
	strokeWeight(2);
	//line(300, 64, 300, height / 6);
		//triangle(nx + random(width - nx), ny + random(height - ny), nx + random(width - nx), ny + random(height - ny), nx + random(width - nx), ny + random(height - ny));
		//ellipse(width / 2, height / 2, height / 2, height / 2);
	  //rect(width / 3, height / 2, width / 5, height / 2);
	  //rect(width - width / 3, height / 2, width / 5, height / 2);
		//rect(nx + random(width - nx), ny + random(height - ny), nx, ny);
		//bezier(random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height));
		//strokeWeight(1 + random(8));
		//bezier(random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height));

		rectMode(CORNER);
	
	//smooth();
}

void mouseClicked() {
	background(0);
	
	reset = frameCount;
	
	xmotion = 8.8;
	ymotion = 2.2;
}

void draw() {
  draw_func();
}"
"1068451","Foam2","mySketch","// doing it by following lines instead of per pixels (note : mostly useless in that case but the result look nice)

float xmotion = 8.8;
float ymotion = 2.2;

int reset = 0;
int perlin_amount = 800;

float[] ppx = new float[800 * 800];
float[] ppy = new float[800 * 800];

// https://iquilezles.org/www/articles/palettes/palettes.htm
float pal(float t, float a, float b, float c, float d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

void shapel(float x1, float y1, float x2, float y2, float dirx, float diry) {
	float dx = x2 - x1;
	float dy = y2 - y1;
	
	float xx1 = x1;
	float xx2 = x2;
	if (x1 > x2) {
		xx1 = x2;
		xx2 = x1;
	}
	//noStroke();
	strokeWeight(1);
	for (float x = xx1; x < xx2; x += 1) {
		float norm_dst = abs(x - xx2) / abs(xx2);
		float anorm_dst = 1.0 - abs(0.5 - norm_dst) * 3;
		
		float y = y1 + dy * (x - x1) / dx;
		
		float ynorm = (y + ymotion * 2) / (float)height;
		
		float anorm_y = 1.0 - abs(0.5 - ynorm) * 1;
		
		float anorm_y2 = 1.0 - abs(0.5 - ynorm) * 8;
		
		//if (anorm_dst > -0.5 && anorm_dst < 0.5) anorm_dst = lerp(anorm_dst, anorm_dst * 2 * anorm_y, anorm_dst * 2);
		
		float moda = cos(ynorm * PI * 2.5 + n2 * PI * 2);
		float modb = sin(norm_dst * PI * 3.5 + n2 * PI * 2);
		
		float mod = abs(moda % modb);
		
		if (ynorm > 0.5) mod = (lerp(mod - norm_dst, anorm_y, (ynorm - 0.5) * 1.5));
		else mod = (mod - norm_dst);
		
		float n2 = (0.5-noise(anorm_dst + xmotion / 24 * anorm_y2, anorm_y2 + ymotion / 24)) * 2 / (1 + anorm_y * 32);
		float n = (0.5-noise(anorm_dst + xmotion / 32 * anorm_y2, anorm_y2 + ymotion / 32)) * 2 * ynorm * mod; //% (0.5-noise(anorm_dst + xmotion / 8 * anorm_y2, anorm_y2 + ymotion / 8)) * 2;
		
		float pa = 0.5 + abs(n / 2);
		float pb = 0.5 - abs(n / 2);
		float pc = 1;
		
		float pdr = 0.12;
		float pdg = 0.05;
		float pdb = 1;
		
		float rf = pal(ynorm, pa, pb, pc, pdr) * 255;
		float gf = pal(ynorm, pa, pb, pc, pdg) * 255;
		float bf = pal(ynorm, pa, pb, pc, pdb) * 255;
		
		fill(rf, gf, bf, 92 * abs(n) * 6);
		stroke(rf / 2.5, gf / 2.5, bf / 2.5, 48 * abs(n) * 6);
		
		float s = 34 * abs(n);
		
		if (dirx < 0 && diry < 0) {
			ellipse(x - n * 30 + cos(anorm_dst * PI * 3 + xmotion) * 4, y - n * 140 - ymotion * 4.5 + sin(anorm_dst * PI * 0.25 + xmotion) * 80 * anorm_dst * (1-ynorm), s, s);
		} else if (dirx > 0 && diry > 0) {
			ellipse(x + n * 30 + cos(anorm_dst * PI * 3 + xmotion) * 4, y + n * 140 + ymotion * 4.5 + sin(anorm_dst * PI * 0.25 + xmotion) * 80 * anorm_dst * (1-ynorm), s, s);
		} else if (dirx < 0 && diry > 0) {
			ellipse(x - n * 30 + cos(anorm_dst * PI * 3 + xmotion) * 4, y + n * 140 + ymotion * 4.5 + sin(anorm_dst * PI * 0.25 + xmotion) * 80 * anorm_dst * (1-ynorm), s, s);
		} else if (dirx > 0 && diry < 0) {
			ellipse(x + n * 30 + cos(anorm_dst * PI * 3 + xmotion) * 4, y - n * 140 - ymotion * 4.5 + sin(anorm_dst * PI * 0.25 + xmotion) * 80 * anorm_dst * (1-ynorm), s, s);
		}
		
		//stroke(rf, gf, bf, 16 * abs(n));
		//line(x - n * 40 - xmotion * 8, y - n * 40 + ymotion * 8, x + n * 40 - xmotion * 8, y + n * 40 + ymotion * 8);
	}
	
	stroke(0, 0, 255, 1);
}

void draw_func() {
	noStroke();
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	float x1 = -200;
	float y1 = 4;
	float x2 = width;
	float y2 = -4.1 + ymotion * 2;
	
	stroke(0, 0, 255, 1);
	//line(x1, y1, x2, y2);
	
	
	//shapel(x1, y1, x2, y2, 1, 1);
	shapel(x1, y1, x2, y2, -1, 1);
	
	x1 = -200;
	y1 = height;
	x2 = width;
	y2 = (height-0.1);
	//line(x1, y1, x2, y2);

	//shapel(x1, y1, x2, y2, -1, -1);
	/*
	x1 = 0;
	y1 = height - height /1.99;
	x2 = width;
	y2 = height - height /2;
	//line(x1, y1, x2, y2);

	shapel(x1, y1, x2, y2, 1, -1);
	
	x1 = 0;
	y1 = height /1.99;
	x2 = width;
	y2 = height /2;
	//line(x1, y1, x2, y2);

	shapel(x1, y1, x2, y2, 1, -1);
			*/	
				xmotion += 0;
				ymotion += 0.25;
}

void setup() {
  size(800, 800);

  background(0);
	
	//colorMode(HSB, 360, 256, 256);
	
	noiseDetail(7,0.65);
	
	frameRate(60);
	
	
		noFill();
		noStroke();

		rectMode(CENTER);
		ellipseMode(CENTER);

		stroke(0, 0, 255, 255);
		strokeWeight(2);
		strokeCap(ROUND);
		noFill();
		int nx = random(width / 2);
		int ny = random(height / 2);
		
		int lx = nx + random(width - nx);
		
		//line(0, height - 192, width, height - 192);
	  //line(0, height - 192 / 1.15, width, height - 192 / 1.15);
	  //line(0, height - 192 / 1.3, width, height - 192 / 1.3);
	  //line(2 * 92, height + (2 - 1.45 * 512), width / 2, height + (2 - 1.45 * 512));
	  //line(3 * 84, height - 512, width / 2 - 3 * 84, height - 512);
	  //bezier(3.1 * 84, height - 550, 400, 0, 0, 0, 0, height - 2 * 550);
	 // bezier(2.6 * 84, height - 512, 400, 0, 100, 0, -200, height - 2 * 512);
	 // bezier(2 * 84, height - 512, 400, 0, 100, 0, -200, height - 2 * 512);
	  //bezier(1.4 * 84, height - 512, 400, 0, 100, 0, -200, height - 2 * 512);
	  //line(4 * 92, height - 1.25 * 512, width / 2 - 4 * 92, height - 1.25 * 512);
	
	  
	  //rect(width / 2, height / 5, width / 5.5, width / 7);
	  //ellipse(width / 2, height / 5, width / 4, width / 7);
		
	  //line(2 * 92, height - 180, 64 + 2 * 148, height + (2 - 2 * 512));
	  //line(-92, height - 180, 64 + 48, height + (2 - 1 * 512));
	
	for (int i = 0; i < 3; i += 1) {
		//line(i * 92, height - 180, 64 + i * 148, height + (2 - i * 512));
		//line(64 + i * 92, 0, 64 + i * 92, (128 + i * 32));
		//line(64 + i * 92, 0, 256 + i * 92, (128 + i * 32));
	  //line(width / 3 - i * 128, height - 64, width / 3 - i * 128, height / 2 + height / 5);
	}
	//stroke(0, 0, 255, 92);
	
	//line(width / 2, height - 210, width / 2, height - 192);
	/*
	for (int i = 0; i < 8; i += 1) {
		ellipse(random(width / 8), random(height / 2, height / 1.6), 1, 1);
	}*/
	strokeWeight(2);
	//line(300, 64, 300, height / 6);
		//triangle(nx + random(width - nx), ny + random(height - ny), nx + random(width - nx), ny + random(height - ny), nx + random(width - nx), ny + random(height - ny));
		//ellipse(width / 2, height / 2, height / 2, height / 2);
	  //rect(width / 3, height / 2, width / 5, height / 2);
	  //rect(width - width / 3, height / 2, width / 5, height / 2);
		//rect(nx + random(width - nx), ny + random(height - ny), nx, ny);
		//bezier(random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height));
		//strokeWeight(1 + random(8));
		//bezier(random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height));

		rectMode(CORNER);
	
	//smooth();
}

void mouseClicked() {
	background(0);
	
	reset = frameCount;
	
	xmotion = 8.8;
	ymotion = 2.2;
}

void draw() {
  draw_func();
}"
"1063749","Stacking patterns","mySketch","// same as parallax checkerboard with static render goal
let zmotion = 0;

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseDetail(6, 0.7);
	
	noStroke();
	
	rectMode(CENTER);
}

let xmotion = 0;
let ymotion = 0;

function d() {
	//background(0);
	noStroke();
	//fill(0, 0, 0, 0.05);
	//rect(0, 0, width, height);
	
	var context = drawingContext
	context.shadowOffsetX = sin(xmotion)/4;
	context.shadowOffsetY = cos(xmotion)/4;
	context.shadowBlur = 1; // more can be fun also
	context.shadowColor = ""black"";
	
	let planes = 8;

	let sw = 100;
	let sh = 100;
	
	let xp_offset = 0;
	let yp_offset = 0;
	
	let w = width;
	let h = height;
	
	for (let p = 1; p <= planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let ainp = abs(0.5 - np) * 2;
		
		let sf = ainp;
		
		push();
		translate(width / 2, height / 2);
		scale(sf + xmotion/148, sf + xmotion/148);
		
		for (let y = 0; y <= h; y += sw) {
			for (let x = 0; x <= w; x += sh) {
				
				if (x <= 100 || x >= w-100 || y <= 100 || y >= h-100) { // checkerboard pattern
					let nx = abs(0.5 - x / w) * 2;
					let ny = abs(0.5 - y / h) * 2;
				
					//rotate(sf * 2 + nx * ny);
				
					let no = noise(nx * 0.5, ny * 0.5) * noise(ainp * 2)*1;
					
					let ss = abs(sin((nx * ny) * PI * 2 + inp * PI * 2 + xmotion / 8)) * 1;
					
					//stroke(0, 0, 0, sf / 8);
					noFill();
					strokeWeight(8);
					stroke((0 + no * 100 * ainp) % 360, 255 * sf + ainp * 128, 192 + 48 * (frameCount/40),1);
					
					let vw = sw * ss - frameCount/0.5*(1+(sin(nx * PI * 2 + zmotion) - cos(ny * PI * 2 + zmotion))/2);
					let vh = sh * ss - frameCount/0.5*(1+(cos(nx * PI * 2 + zmotion) + sin(ny * PI * 2 + zmotion))/2);
					
					if (vw > 0 && vh > 0) {
						if (noise(nx * 2, ny * 2) > 0.5) {
							rect(-width / 2 + (x + abs(cos(xmotion / 4 + ainp)) * 1 * no/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y + abs(sin(ymotion / 4 + ainp)) * 1 * no /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						} else {
							ellipse(-width / 2 + (x + abs(cos(xmotion / 4 + ainp)) * 1 * no/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y + abs(sin(ymotion / 4 + ainp)) * 1 * no /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						}
					}
				}
			}
		}
		pop();
	}
	
	xmotion += 0.025;
	ymotion += 0.025;
}

let c = 0;
function draw() {
	d();
	
	if (frameCount > 100 && c < 12) {
		frameCount = 0;
		c += 1;
	}
	
	zmotion += 0.01;
}"
"1062667","Stacking patterns 10 fake raycasting","mySketch","// same as parallax checkerboard with static render goal
let zmotion = 0;

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseDetail(6, 0.7);
	
	noStroke();
	
	rectMode(CENTER);
}

let xmotion = 0;
let ymotion = 0;

function d() {
	//background(0);
	noStroke();
	//fill(0, 0, 0, 0.05);
	//rect(0, 0, width, height);
	
	var context = drawingContext
	context.shadowOffsetX = sin(xmotion)/2;
	context.shadowOffsetY = cos(xmotion)/2;
	context.shadowBlur = 1; // more can be fun also
	context.shadowColor = ""black"";
	
	let planes = 2;

	let sw = 100;
	let sh = 100;
	
	let xp_offset = 0;
	let yp_offset = 0;
	
	let w = width;
	let h = height;
	
	for (let p = 1; p <= planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let ainp = abs(0.5 - np) * 2;
		
		let sf = pow(1, ainp) / 5;
		
		push();
		translate(width / 2, height / 2);
		scale(sf + xmotion/148, sf + xmotion/148);
		
		for (let y = 0; y <= h; y += sw) {
			for (let x = 0; x <= w; x += sh) {
				
				if (x <= 100*2 || x >= w-100*2 || y <= 100*2 || y >= h-100*2) { // checkerboard pattern
					let nx = abs(0.5 - x / w) * 2;
					let ny = abs(0.5 - y / h) * 2;
				
					//rotate(sf * 2 + nx * ny);
				
					let no = noise(nx * 0.5, ny * 0.5) * noise(ainp * 2)*1;
					
					let ss = abs(sin((nx * ny) * PI * 2 + inp * PI * 2 + xmotion / 8)) * 1;
					
					stroke(0, 0, 0, sf / 2);
					strokeWeight(2);
					fill((80 + no * 360 * ainp) % 360, 255 * sf + ainp * 128, 192 * np *(frameCount/100), sf / 0.05);
					
					let vw = sw * ss - frameCount/3*(sin(nx * PI * 2 + zmotion) - cos(ny * PI * 2 + zmotion))/2;
					let vh = sh * ss - frameCount/3*(cos(nx * PI * 2 + zmotion) + sin(ny * PI * 2 + zmotion))/2;
					
					if (vw > 0 && vh > 0) {
						if (noise(nx * 2, ny * 2) > 0.5) {
							rect(-width / 2 + (x + abs(cos(xmotion / 4 + ainp)) * 1 * no/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y + abs(sin(ymotion / 4 + ainp)) * 1 * no /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						} else {
							ellipse(-width / 2 + (x + abs(cos(xmotion / 4 + ainp)) * 1 * no/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y + abs(sin(ymotion / 4 + ainp)) * 1 * no /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						}
					}
				}
			}
		}
		pop();
	}
	
	xmotion += 0.25;
	ymotion += 0.25;
}

function draw() {
	d();
	
	if (frameCount > 300) frameCount = 100;
	
	zmotion += 0.01;
}"
"1062659","Stacking patterns 9","mySketch","// same as parallax checkerboard with static render goal
let zmotion = 0;

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseDetail(6, 0.7);
	
	noStroke();
	
	rectMode(CENTER);
}

let xmotion = 0;
let ymotion = 0;

function d() {
	//background(0);
	noStroke();
	//fill(0, 0, 0, 0.05);
	//rect(0, 0, width, height);
	
	var context = drawingContext
	context.shadowOffsetX = sin(xmotion)/2;
	context.shadowOffsetY = cos(xmotion)/2;
	context.shadowBlur = 1; // more can be fun also
	context.shadowColor = ""black"";
	
	let planes = 2;

	let sw = 100;
	let sh = 100;
	
	let xp_offset = 0;
	let yp_offset = 0;
	
	let w = width;
	let h = height;
	
	for (let p = 1; p <= planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let ainp = abs(0.5 - np) * 2;
		
		let sf = pow(1, ainp) / 5;
		
		push();
		translate(width / 2, height / 2);
		scale(sf + xmotion/148, sf + xmotion/148);
		
		for (let y = 0; y <= h; y += sw) {
			for (let x = 0; x <= w; x += sh) {
				
				if (x <= 100*2 || x >= w-100*2 || y <= 100*2 || y >= h-100*2) { // checkerboard pattern
					let nx = abs(0.5 - x / w) * 2;
					let ny = abs(0.5 - y / h) * 2;
				
					//rotate(sf * 2 + nx * ny);
				
					let no = noise(nx * 0.5, ny * 0.5) * noise(ainp * 2)*1;
					
					let ss = abs(sin((nx * ny) * PI * 2 + inp * PI * 2 + xmotion / 8)) * 0.5;
					
					stroke(0, 0, 0, sf / 2);
					strokeWeight(2);
					fill((80 + no * 360 * ainp) % 360, 255 * sf + ainp * 128, 192 * np *(frameCount/100*2-1), sf / 0.05);
					
					let vw = sw * ss - frameCount/2*(sin(nx * PI * 2 + zmotion) - cos(ny * PI * 2 + zmotion))/2;
					let vh = sh * ss - frameCount/2*(cos(nx * PI * 2 + zmotion) + sin(ny * PI * 2 + zmotion))/2;
					
					if (vw > 0 && vh > 0) {
						if (noise(nx * 2, ny * 2) > 0.5) {
							rect(-width / 2 + (x + abs(cos(xmotion / 4 + ainp)) * 1 * no/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y + abs(sin(ymotion / 4 + ainp)) * 1 * no /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						} else {
							ellipse(-width / 2 + (x + abs(cos(xmotion / 4 + ainp)) * 1 * no/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y + abs(sin(ymotion / 4 + ainp)) * 1 * no /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						}
					}
				}
			}
		}
		pop();
	}
	
	xmotion += 0.25;
	ymotion += 0.25;
}

function draw() {
	d();
	
	if (frameCount > 300) frameCount = 100;
	
	zmotion += 0.01;
}"
"1062599","Stacking patterns 8","mySketch","// same as parallax checkerboard with static render goal

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseDetail(6, 0.7);
	
	noStroke();
	
	rectMode(CENTER);
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	//background(0);
	noStroke();
	//fill(0, 0, 0, 0.05);
	//rect(0, 0, width, height);
	
	var context = drawingContext
	context.shadowOffsetX = sin(xmotion)/2;
	context.shadowOffsetY = cos(xmotion)/2;
	context.shadowBlur = 1; // more can be fun also
	context.shadowColor = ""black"";
	
	let planes = 3;

	let sw = 100;
	let sh = 100;
	
	let xp_offset = 0;
	let yp_offset = 0;
	
	let w = width;
	let h = height;
	
	for (let p = 1; p <= planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let ainp = abs(0.5 - np) * 2;
		
		let sf = pow(1, ainp) / 3;
		
		push();
		translate(width / 2, height / 2);
		scale(sf + xmotion/148, sf + xmotion/148);
		
		for (let y = 0; y <= h; y += sw) {
			for (let x = 0; x <= w; x += sh) {
				
				if (x <= 100 || x >= w-100 || y <= 100 || y >= h-100) { // checkerboard pattern
					let nx = abs(0.5 - x / w) * 2;
					let ny = abs(0.5 - y / h) * 2;
				
					//rotate(sf * 2 + nx * ny);
				
					let no = noise(nx * 0.5, ny * 0.5) * noise(ainp * 2)*1;
					
					let ss = abs(sin((nx * ny) * PI * 2 + inp * PI * 2 + xmotion / 8)) * 2;
					
					stroke(0, 0, 0, sf / 2);
					strokeWeight(0.5);
					fill((140 + no * 360 * ainp) % 360, 255 * sf + ainp * 128, 192 * np *(frameCount/200*2-1), sf / 0.05);
					
					let vw = sw * ss - frameCount/2*nx;
					let vh = sh * ss - frameCount/2*nx;
					
					if (vw > 0 && vh > 0) {
						if (noise(nx * 2, ny * 2) > 0.5) {
							rect(-width / 2 + (x + abs(cos(xmotion / 4 + ainp)) * 1 * no/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y + abs(sin(ymotion / 4 + ainp)) * 1 * no /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						} else {
							ellipse(-width / 2 + (x + abs(cos(xmotion / 4 + ainp)) * 1 * no/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y + abs(sin(ymotion / 4 + ainp)) * 1 * no /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						}
					}
				}
			}
		}
		pop();
	}
	
	xmotion += 0.25;
	ymotion += 0.25;
}"
"1062100","Stacking objects with fake depth (invert)","mySketch","// same as parallax checkerboard with static render goal

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseDetail(6, 0.7);
	
	noStroke();
	
	rectMode(CENTER, CENTER);
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	//background(0);
	noStroke();
	//fill(0, 0, 0, 0.05);
	//rect(0, 0, width, height);
	
	var context = drawingContext
	context.shadowOffsetX = sin(xmotion)/2;
	context.shadowOffsetY = cos(xmotion)/2;
	context.shadowBlur = 1; // more can be fun also
	context.shadowColor = ""black"";
	
	let planes = 3;

	let sw = 100;
	let sh = 100;
	
	let xp_offset = 0;
	let yp_offset = 0;
	
	let w = width;
	let h = height;
	
	for (let p = 1; p <= planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let ainp = abs(0.5 - np) * 2;
		
		let sf = pow(1, ainp) / 3;
		
		push();
		translate(width / 2, height / 2);
		scale(sf + xmotion/148, sf + xmotion/148);
		
		for (let y = 0; y <= h; y += sw) {
			for (let x = 0; x <= w; x += sh) {
				
				if (x <= 0 || x >= w || y <= 0 || y >= h) { // checkerboard pattern
					let nx = abs(0.5 - x / w) * 2;
					let ny = abs(0.5 - y / h) * 2;
				
					rotate(sf * 2 + nx * ny + round(noise(xmotion/100)*32));
				
					let no = noise(nx * 0.5, ny * 0.5) * noise(ainp * 2)*1;
					
					let ss = abs(sin((nx * ny) * PI * 2 + inp * PI * 2 + xmotion / 8)) * 2;
					
					stroke(0, 0, 0, sf / 2);
					strokeWeight(0.5);
					fill((140 + no * 360 * ainp) % 360, 255 * sf + ainp * 128, 192 * np *(1-frameCount/400), sf / 0.05);
					
					let vw = sw * ss - frameCount/2;
					let vh = sh * ss - frameCount/2;
					
					if (vw > 0 && vh > 0) {
						if (noise(nx * 2, ny * 2) > 0.5) {
							rect(-width / 2 + (x + abs(cos(xmotion / 4 + ainp)) * 1 * no/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y + abs(sin(ymotion / 4 + ainp)) * 1 * no /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						} else {
							ellipse(-width / 2 + (x + abs(cos(xmotion / 4 + ainp)) * 1 * no/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y + abs(sin(ymotion / 4 + ainp)) * 1 * no /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						}
					}
				}
			}
		}
		pop();
	}
	
	xmotion += 0.25;
	ymotion += 0.25;
}"
"1062099","Stacking patterns with fake depth","mySketch","// same as parallax checkerboard with static render goal

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseDetail(6, 0.7);
	
	noStroke();
	
	rectMode(CENTER, CENTER);
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	//background(0);
	noStroke();
	//fill(0, 0, 0, 0.05);
	//rect(0, 0, width, height);
	
	var context = drawingContext
	context.shadowOffsetX = sin(xmotion)/2;
	context.shadowOffsetY = cos(xmotion)/2;
	context.shadowBlur = 1; // more can be fun also
	context.shadowColor = ""black"";
	
	let planes = 3;

	let sw = 100;
	let sh = 100;
	
	let xp_offset = 0;
	let yp_offset = 0;
	
	let w = width;
	let h = height;
	
	for (let p = 1; p <= planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let ainp = abs(0.5 - np) * 2;
		
		let sf = pow(1, ainp) / 3;
		
		push();
		translate(width / 2, height / 2);
		scale(sf + xmotion/148, sf + xmotion/148);
		
		for (let y = 0; y <= h; y += sw) {
			for (let x = 0; x <= w; x += sh) {
				
				if (x <= 0 || x >= w || y <= 0 || y >= h) { // checkerboard pattern
					let nx = abs(0.5 - x / w) * 2;
					let ny = abs(0.5 - y / h) * 2;
				
					//rotate(sf * 2 + nx * ny);
				
					let no = noise(nx * 0.5, ny * 0.5) * noise(ainp * 2)*1;
					
					let ss = abs(sin((nx * ny) * PI * 2 + inp * PI * 2 + xmotion / 8)) * 2;
					
					stroke(0, 0, 0, sf / 2);
					strokeWeight(0.5);
					fill((140 + no * 360 * ainp) % 360, 255 * sf + ainp * 128, 192 * np *(frameCount/200), sf / 0.05);
					
					let vw = sw * ss - frameCount/2;
					let vh = sh * ss - frameCount/2;
					
					if (vw > 0 && vh > 0) {
						if (noise(nx * 2, ny * 2) > 0.5) {
							rect(-width / 2 + (x + abs(cos(xmotion / 4 + ainp)) * 1 * no/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y + abs(sin(ymotion / 4 + ainp)) * 1 * no /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						} else {
							ellipse(-width / 2 + (x + abs(cos(xmotion / 4 + ainp)) * 1 * no/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y + abs(sin(ymotion / 4 + ainp)) * 1 * no /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						}
					}
				}
			}
		}
		pop();
	}
	
	xmotion += 0.25;
	ymotion += 0.25;
}"
"1061810","L-systems random2","mySketch","// more automatic drawing by generating L-systems rules + switching rules randomly

function pal(t, a, b, c, d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

function weightedRandom(prob) {
  let i, sum=0, r=Math.random();
  for (i in prob) {
    sum += prob[i];
    if (r <= sum) return i;
  }
}

class lm {
	constructor(axiom, rules, angle, step, iter) {
		this.ax = width / 2;
		this.ay = height / 2;
		this.px = this.ax;
		this.py = this.ay;
		this.ta = angle;
		this.ca = PI;
		this.fs = step;
		
		this.stack = [];
		
		this.axiom = axiom;
		this.rules = rules;
		this.itera = iter;
		
		this.rule = 0;
		
		this.cycles = 0;
		
		this.b = false;
		
		this.where = 1;
		
		this.initialize();
	}
	
	initialize() {
		let rule = this.axiom;
		for (let i = 0; i < this.itera; i++) {
			rule = this.lindenmayer(rule);
		}
		
		this.rule = rule;
	}
	
	lindenmayer(s) {
		let outputstring = '';

		for (let i = 0; i < s.length; i++) {
			let ismatch = 0;
			for (let j = 0; j < this.rules.length; j++) {
				if (s[i] == this.rules[j][0])  {
					let rule_index = 1;
					if (this.rules[j].length > 2) { // stochastic
						let probs = {};
						for (let k = 1; k < this.rules[j].length; k+=2) {
							probs[k+1] = this.rules[j][k];
						}
						rule_index = weightedRandom(probs);
					}
					outputstring += this.rules[j][rule_index];
					ismatch = 1;
					break;
				}
			}

			if (ismatch == 0) outputstring+= s[i];
		}
		
		return outputstring;
	}
	
	computeParameters(w) {
		
	}
	
	compute(cb_trigger) {
		let k = this.rule[this.where];
		if (k == 'F' || k == 'f') {
			var polx = this.fs * sin(this.ca);
			var poly = this.fs * cos(this.ca);
			let x1 = this.b ? this.px - polx : this.px + polx;
			let y1 = this.b ? this.py - poly : this.py + poly;

			if (x1 < 0 || y1 < 0 || x1 > width || y1 > height) {
				this.b = !this.b;
				this.ta = -this.ta;//random() * PI * 2;
				
				if (x1 < 0) { x1 = width; this.px = width; if (random() > 0.99995) { y1 += 1; if (y1 >= height) { y1 -= height; this.py = y1; } } }
				if (y1 < 0) { y1 = height; this.py = height; if (random() > 0.99995) { x1 += 1; if (x1 >= width) { x1 %= width; this.px = x1; } } }
				if (x1 > width) { x1 = 0; this.px = 0; }
				if (y1 > height) { y1 = 0; this.py = 0; }
			}

			this.ax = this.px;
			this.ay = this.py;
			this.px = x1;
			this.py = y1;
		} else if (k == '[') {
			this.stack.push(this.px);
			this.stack.push(this.py);
			this.stack.push(this.ca);
		} else if (k == ']') {
			this.ca = this.stack.pop();
			this.py = this.stack.pop();
			this.px = this.stack.pop();
		} else if (k == '+') {
			this.ca += this.ta;
		} else if (k == '-') {
			this.ca -= this.ta;
		}
		
		this.where++;
  	if (this.where > this.rule.length-1 || random() > 0.9995) {
			this.where = 0;
			this.cycles += 1;
			
			cb_trigger(this);
		}
		
		if (k == 'F') {
			return true;
		} else {
			return false;
		}
	}
}

var xmotion = 0;
var ymotion = 0;

let lms = [];

function getRule() {
	let len = 48 + random() * 128;
	let rule = [''];
	let stak = [];
	let last = '';
	for (let i = 0; i < len; i += 1) {
		let c = ['X', '+', '-', 'F', '[', ']']
		let chosen = c[floor((c.length-1) * random())];
		
		if (last == '' && chosen == '[') {
			chosen = c[floor((c.length-2) * random())];
		}
		
		if (chosen == '[') {
			stak.push(']');
		} else if (chosen == ']' && stak.length == 0) {
			chosen = c[floor((c.length-2) * random())];
		} else if (chosen == ']' && last == '[') {
			chosen = c[floor((c.length-2) * random())];
		}
		
		rule[0] += chosen;
		
		last = chosen;
	}
	
	while (stak.length) {
		let last = rule[0][rule[0].length - 1];
		
		if (last == '[') {
			rule[0] = rule[0].slice(0, rule[0].length - 1)
			stak.pop();	
		} else {
			rule[0] += stak.pop();	
		}
	}
	
	return rule;
}

function setup() {
  createCanvas(840, 840);
  background(0);
	
	noiseDetail(7, 0.7);
	//colorMode(HSB, 360, 100, 100, 255);
	
	//blendMode(LIGHTEST);
	
	stroke(0, 0, 100, 255);
 // lms[0] = new lm('X', [['X', 0.5, 'XFFFF-[F-X+]FX+', 0.5, 'FFFFF[f+F]------------F'], ['F', '+F--F+']], radians(45), 1);
	let amount = 100;
	for (let i = 0; i < 100; i += 1) {
		lms[i] = new lm('X', [['X', getRule()[0]], ['F', 'F++++']], radians(10+360 * (((1+i) / amount)*2)-1), 1, 2);
		lms[i].px = random(0, width); lms[i].py = random(0, height);
	}
	//lms[1] = new lm('X', [['X', 'F-[[X]+X]+F[+FX]-X'], ['F', 'FF']], radians(90), 1);
}

function change(lm) {
	let max_cycles = 1;
	noStroke();
	if (lm.cycles % max_cycles == 0) {
		lm.ta += 2;
		lm.fs = random(0.75, 2);
		
		let rule = getRule()[0];
		
		if (rule.length < 64) {
			lm.itera = 1 + floor(random() * 4);
		} else if (rule.length < 128) {
			lm.itera = 1 + floor(random() * 3);
		} else if (rule.length < 256) {
			lm.itera = 1 + floor(random() * 2);
		} else {
			lm.itera = 1 + floor(random() * 2);
		}
		lm.cycles = 0;

		lm.rules = [['X', rule], ['F', 'FF']];
		lm.initialize();
		
		//fill(0, 0, 0, 92);
		//rect(0, 0, width, height);
	}
	
	/*
	if (lm.cycles % 16 == 0) {
		fill(0, 0, 0, 48);
		rect(0, 0, width, height);
	}
	*/
	
	let nc = (lm.cycles % 8) / 8;
	stroke(0, 0, 100, random(0, 10));
	
	//if (random() > 0.25) {
		lm.iter = 1;
		lm.initialize();
	/*} else {
		lm.iter = 2;
		lm.initialize();
	}*/
}

function draw() {
	for (let k = 0; k < 50; k += 1) {
		for (let i = 0; i < lms.length; i += 1) {
			let lm = lms[i];
			
			let result = lm.compute(change);
			
			if (result) {
				//stroke(k / 3 + abs(sin(xmotion/24))*180, 30, 255, 255);
			var pa1 = 1, pa2 = 1, pa3 = 1;
			var pb1 = 0.7, pb2 = 0.25, pb3 =0.5;
			var pc1 = 0.91, pc2 = 0.5, pc3 = 0.14;

			var pdr = 0.94;
			var pdg = 0.71;
			var pdb = 0.6;

				var pt = abs(sin(xmotion/k/30 + i/4));

				var rf = pal(pt, pa1, pb1, pc1, pdr) * 255*1.25;
				var gf = pal(pt, pa2, pb2, pc2, pdg) * 255*1.25;
				var bf = pal(pt, pa3, pb3, pc3, pdb) * 255*1.25;

				stroke(rf, gf, bf, 255);
				
				strokeWeight(1/* + abs(sin(xmotion/16+i))*8*/);
				var context = drawingContext
        context.shadowOffsetX = random(-4, 4);
        context.shadowOffsetY = random(-4, 4);
        context.shadowBlur = 16;
        context.shadowColor = ""black"";
				line(lm.px, lm.py, lm.ax, lm.ay);
			}
		}
	}
	
	xmotion += 0.5;
	ymotion += 0.25;
}"
"1061475","L-systems random","mySketch","// more automatic drawing by generating L-systems rules + switching rules randomly

function pal(t, a, b, c, d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

function weightedRandom(prob) {
  let i, sum=0, r=Math.random();
  for (i in prob) {
    sum += prob[i];
    if (r <= sum) return i;
  }
}

class lm {
	constructor(axiom, rules, angle, step, iter) {
		this.ax = width / 2;
		this.ay = height / 2;
		this.px = this.ax;
		this.py = this.ay;
		this.ta = angle;
		this.ca = PI;
		this.fs = step;
		
		this.stack = [];
		
		this.axiom = axiom;
		this.rules = rules;
		this.itera = iter;
		
		this.rule = 0;
		
		this.cycles = 0;
		
		this.b = false;
		
		this.where = 1;
		
		this.initialize();
	}
	
	initialize() {
		let rule = this.axiom;
		for (let i = 0; i < this.itera; i++) {
			rule = this.lindenmayer(rule);
		}
		
		this.rule = rule;
	}
	
	lindenmayer(s) {
		let outputstring = '';

		for (let i = 0; i < s.length; i++) {
			let ismatch = 0;
			for (let j = 0; j < this.rules.length; j++) {
				if (s[i] == this.rules[j][0])  {
					let rule_index = 1;
					if (this.rules[j].length > 2) { // stochastic
						let probs = {};
						for (let k = 1; k < this.rules[j].length; k+=2) {
							probs[k+1] = this.rules[j][k];
						}
						rule_index = weightedRandom(probs);
					}
					outputstring += this.rules[j][rule_index];
					ismatch = 1;
					break;
				}
			}

			if (ismatch == 0) outputstring+= s[i];
		}
		
		return outputstring;
	}
	
	computeParameters(w) {
		
	}
	
	compute(cb_trigger) {
		let k = this.rule[this.where];
		if (k == 'F' || k == 'f') {
			var polx = this.fs * sin(this.ca);
			var poly = this.fs * cos(this.ca);
			let x1 = this.b ? this.px - polx : this.px + polx;
			let y1 = this.b ? this.py - poly : this.py + poly;

			if (x1 < 0 || y1 < 0 || x1 > width || y1 > height) {
				this.b = !this.b;
				this.ta = -this.ta;//random() * PI * 2;
				
				if (x1 < 0) { x1 = width; this.px = width; if (random() > 0.99995) { y1 += 1; if (y1 >= height) { y1 -= height; this.py = y1; } } }
				if (y1 < 0) { y1 = height; this.py = height; if (random() > 0.99995) { x1 += 1; if (x1 >= width) { x1 %= width; this.px = x1; } } }
				if (x1 > width) { x1 = 0; this.px = 0; }
				if (y1 > height) { y1 = 0; this.py = 0; }
			}

			this.ax = this.px;
			this.ay = this.py;
			this.px = x1;
			this.py = y1;
		} else if (k == '[') {
			this.stack.push(this.px);
			this.stack.push(this.py);
			this.stack.push(this.ca);
		} else if (k == ']') {
			this.ca = this.stack.pop();
			this.py = this.stack.pop();
			this.px = this.stack.pop();
		} else if (k == '+') {
			this.ca += this.ta;
		} else if (k == '-') {
			this.ca -= this.ta;
		}
		
		this.where++;
  	if (this.where > this.rule.length-1 || random() > 0.9995) {
			this.where = 0;
			this.cycles += 1;
			
			cb_trigger(this);
		}
		
		if (k == 'F') {
			return true;
		} else {
			return false;
		}
	}
}

var xmotion = 0;
var ymotion = 0;

let lms = [];

function getRule() {
	let len = 48 + random() * 128;
	let rule = [''];
	let stak = [];
	let last = '';
	for (let i = 0; i < len; i += 1) {
		let c = ['X', '+', '-', 'F', '[', ']']
		let chosen = c[floor((c.length-1) * random())];
		
		if (last == '' && chosen == '[') {
			chosen = c[floor((c.length-2) * random())];
		}
		
		if (chosen == '[') {
			stak.push(']');
		} else if (chosen == ']' && stak.length == 0) {
			chosen = c[floor((c.length-2) * random())];
		} else if (chosen == ']' && last == '[') {
			chosen = c[floor((c.length-2) * random())];
		}
		
		rule[0] += chosen;
		
		last = chosen;
	}
	
	while (stak.length) {
		let last = rule[0][rule[0].length - 1];
		
		if (last == '[') {
			rule[0] = rule[0].slice(0, rule[0].length - 1)
			stak.pop();	
		} else {
			rule[0] += stak.pop();	
		}
	}
	
	return rule;
}

function setup() {
  createCanvas(840, 840);
  background(0);
	
	noiseDetail(7, 0.7);
	//colorMode(HSB, 360, 100, 100, 255);
	
	//blendMode(LIGHTEST);
	
	stroke(0, 0, 100, 255);
 // lms[0] = new lm('X', [['X', 0.5, 'XFFFF-[F-X+]FX+', 0.5, 'FFFFF[f+F]------------F'], ['F', '+F--F+']], radians(45), 1);
	let amount = 10;
	for (let i = 0; i < 10; i += 1) {
		lms[i] = new lm('X', [['X', getRule()[0]], ['F', 'F++++']], radians(10+360 * (((1+i) / amount)*2)-1), 1, 2);
		lms[i].px = random(0, width); lms[i].py = random(0, height);
	}
	//lms[1] = new lm('X', [['X', 'F-[[X]+X]+F[+FX]-X'], ['F', 'FF']], radians(90), 1);
}

function change(lm) {
	let max_cycles = 4;
	noStroke();
	if (lm.cycles % max_cycles == 0) {
		lm.ta += 0.01;
		lm.fs = 0.5;
		
		let rule = getRule()[0];
		
		if (rule.length < 64) {
			lm.itera = 1 + floor(random() * 4);
		} else if (rule.length < 128) {
			lm.itera = 1 + floor(random() * 3);
		} else if (rule.length < 256) {
			lm.itera = 1 + floor(random() * 2);
		} else {
			lm.itera = 1 + floor(random() * 2);
		}
		lm.cycles = 0;

		lm.rules = [['X', rule], ['F', 'FF']];
		lm.initialize();
		
		//fill(0, 0, 0, 92);
		//rect(0, 0, width, height);
	}
	
	/*
	if (lm.cycles % 16 == 0) {
		fill(0, 0, 0, 48);
		rect(0, 0, width, height);
	}
	*/
	
	let nc = (lm.cycles % 8) / 8;
	stroke(0, 0, 100, random(0, 10));
	
	//if (random() > 0.25) {
		lm.iter = 1;
		lm.initialize();
	/*} else {
		lm.iter = 2;
		lm.initialize();
	}*/
}

function draw() {
	for (let k = 0; k < 200; k += 1) {
		for (let i = 0; i < lms.length; i += 1) {
			let lm = lms[i];
			
			let result = lm.compute(change);
			
			if (result) {
				//stroke(k / 3 + abs(sin(xmotion/24))*180, 30, 255, 255);
			var pa1 = 1, pa2 = 1, pa3 = 1;
			var pb1 = 1, pb2 = 0.5, pb3 =1;
			var pc1 = 1, pc2 = 0.75, pc3 = 0.2;

			var pdr = 0.4;
			var pdg = 0.2;
			var pdb = 0.2;

				var pt = abs(sin(xmotion/k/30 + i/4));

				var rf = pal(pt, pa1, pb1, pc1, pdr) * 255*1.25;
				var gf = pal(pt, pa2, pb2, pc2, pdg) * 255*1.25;
				var bf = pal(pt, pa3, pb3, pc3, pdb) * 255*1.25;

				stroke(rf, gf, bf, 255);
				
				strokeWeight(1/* + abs(sin(xmotion/16+i))*8*/);
				var context = drawingContext
        context.shadowOffsetX = random(-2, 2);
        context.shadowOffsetY = random(-2, 2);
        context.shadowBlur = 1;
        context.shadowColor = ""black"";
				line(lm.px, lm.py, lm.ax, lm.ay);
			}
		}
	}
	
	xmotion += 0.5;
	ymotion += 0.25;
}"
"1059689","Image rotation using 2 shear / skew bilinear","mySketch","// implementation of http://alvyray.com/Papers/CG/2pass80.pdf
// two pass image rotation (skew x then skew y)
// this has visual artefacts when rotated by 90 degree, there is a solution (turn 90 then rotate) but this is not implemented
// could probably be done on oldschool hardware (with hblank / scrolling registers)

/*@pjs preload=""index.png"";*/

let src_image;

let xmotion = 0;

function preload() {
  src_image = loadImage('firefly.png');
}

function lrp(a, b, f) {
    return a*(1-f)+b*f;
}

function skewRotate() {
	noStroke();
	
	// rotation
	let cx = cos(xmotion);
	let sx = sin(xmotion);
	
	// hold h skew bounding box
	let bmaxx = 0;
	
	// compute the x offset (to stay in the upper left corner)
	let n = -min(min(min((src_image.width-1) * cx - (src_image.height - 1) * sx, -(src_image.height - 1) * sx), (src_image.width-1) * cx), 0);
	
	loadPixels();
	src_image.loadPixels();
  for (let y = 0; y < src_image.height; y += 1) {
      let yyd = y * src_image.width;
      
      for (let x = 0; x < src_image.width; x += 1) {
        let xxd = x;

        let cl = floor(xxd + yyd);
        let c1 = src_image.pixels[cl * 4];
				let c2 = src_image.pixels[(cl + 1) * 4];

				// apply horizontal shear / skew
				let xx = x * cx - y * sx;
				let yy = y;
				
				let c = lrp(c1, c2, xx - floor(xx));
				
				// offset so the image stay in the upper left corner
				xx += n;

				bmaxx = max(xx, bmaxx);

				let si = (floor(xx) + floor(yy) * width) * 4;
        
				pixels[si] = c;
				pixels[si+1] = c;
				pixels[si+2] = c;
      }
  }

	fill(255, 255, 255, 32);
	rect(0, 0, bmaxx, src_image.height);

	for (let y = 0; y < src_image.height; y += 1) {
			let yyd = y * width;
      
      for (let x = 0; x < bmaxx; x += 1) {
				let xxd = x;
				
        let cl = floor(xxd + yyd);
        let c1 = pixels[cl * 4];
				let c2 = pixels[floor(xxd + (y + 1) * width) * 4];

				// translation of origin to image center
				let xt = x - bmaxx / 2;
				let yt = y - src_image.height / 2;
				
				// apply vertical shear / skew
				let xx = xt;
				let yy = (sx * xt + yt) / cx;

				// translation to display center
				xx = xx + width / 2;
				yy = yy + height / 2;
				
				let c = lrp(c1, c2, yy - floor(yy));
				
				let si = (floor(xx) + floor(yy) * width) * 4;
        
				pixels[si] = c;
				pixels[si+1] = c;
				pixels[si+2] = c;
      }
  }
	updatePixels();
	
  xmotion += 0.0075;
}

function setup() {
  createCanvas(512, 512);

  frameRate(60); 
  
  src_image = loadImage(""firefly.png"");

  background(0);

	rectMode(CORNER);
}

function draw() {
	background(0);
 
  skewRotate();
}"
"1058335","Image rotation using 2 shear / skew","mySketch","// implementation of http://alvyray.com/Papers/CG/2pass80.pdf
// two pass image rotation (skew x then skew y)
// this has visual artefacts when rotated by 90 degree, there is a solution (turn 90 then rotate) but this is not implemented
// could probably be done on oldschool hardware (with hblank / scrolling registers)

/*@pjs preload=""index.png"";*/

let src_image;

let xmotion = 0;

function preload() {
  src_image = loadImage('03.jpg');
}

function skewRotate() {
	noStroke();
	
	// rotation
	let cx = cos(xmotion);
	let sx = sin(xmotion);
	
	// hold h skew bounding box
	let bmaxx = 0;
	
	// compute the x offset (to stay in the upper left corner)
	let n = -min(min(min((src_image.width-1) * cx - (src_image.height - 1) * sx, -(src_image.height - 1) * sx), (src_image.width-1) * cx), 0);
	
	loadPixels();
	src_image.loadPixels();
  for (let y = 0; y < src_image.height; y += 1) {
      let yyd = y * src_image.width;
      
      for (let x = 0; x < src_image.width; x += 1) {
        let xxd = x;

        let cl = round(xxd + yyd);
        let c = src_image.pixels[cl * 4];
        
				// apply horizontal shear / skew
				let xx = x * cx - y * sx;
				let yy = y;
				
				// offset so the image stay in the upper left corner
				xx += n;

				bmaxx = max(xx, bmaxx);

				let si = (round(xx) + round(yy) * width) * 4;
        
				pixels[si] = c;
				pixels[si+1] = c;
				pixels[si+2] = c;
      }
  }

	fill(255, 255, 255, 32);
	rect(0, 0, bmaxx, src_image.height);

	for (let y = 0; y < src_image.height; y += 1) {
			let yyd = y * width;
      
      for (let x = 0; x < bmaxx; x += 1) {
				let xxd = x;
				
        let cl = round(xxd + yyd);
        let c = pixels[cl * 4];

				// translation of origin to image center
				let xt = x - bmaxx / 2;
				let yt = y - src_image.height / 2;
				
				// apply vertical shear / skew
				let xx = xt;
				let yy = (sx * xt + yt) / cx;

				// translation to display center
				xx = xx + width / 2;
				yy = yy + height / 2;
				
				let si = (round(xx) + round(yy) * width) * 4;
        
				pixels[si] = c;
				pixels[si+1] = c;
				pixels[si+2] = c;
      }
  }
	updatePixels();
	
  xmotion += 0.0175;
}

function setup() {
  createCanvas(512, 512);

  frameRate(60); 
  
  src_image = loadImage(""index.png"");

  background(0);

	rectMode(CORNER);
}

function draw() {
	background(0);
 
  skewRotate();
}"
"1057129","Bumpy patterns 7","mySketch","// same as parallax checkerboard with static render goal

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseDetail(6, 0.7);
	
	noStroke();
	
	var context = drawingContext
	context.shadowOffsetX = random(-1, 1);
	context.shadowOffsetY = random(-1, 1);
	context.shadowBlur = 4; // more can be fun also
	context.shadowColor = ""black"";
	
	rectMode(CENTER);
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	//background(0);
	noStroke();
	//fill(0, 0, 0, 0.05);
	//rect(0, 0, width, height);
	
	let planes = 16;

	let sw = 100;
	let sh = 100;
	
	let xp_offset = 0;
	let yp_offset = 0;
	
	let w = width;
	let h = height;
	
	for (let p = 1; p <= planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let ainp = abs(0.5 - np) * 2;
		
		let sf = pow(4, ainp);
		
		push();
		translate(width / 2, height / 2);
	//	scale(sf - pow(xmotion/128, 4), sf - pow(xmotion/128, 4));
		// slow
		rotate(sf * 2);
		for (let y = 0; y <= h; y += sw) {
			for (let x = 0; x <= w; x += sh) {
				//if ((x % (sw * 2)) ^ (y % (sh * 2))) { // checkerboard pattern
					let nx = abs(0.5 - x / w) * 2;
					let ny = abs(0.5 - y / h) * 2;
					
					let no = noise(nx * 2, ny * 2);
					
					let ss = abs(sin((nx * ny) * PI * 2 + inp * PI * 2 + xmotion / 32)) * 2;
					
					stroke((32 + (1 - np) * 180 * sf + no * 140) % 360, 128 * sf, 128+128 * np, sf / 0.75);
					strokeWeight(1);
					fill((120 + (1 - np) * 180 * sf + no * 140) % 360, 128 * sf, 128+128 * np, sf / 4.5);
					
					let vw = sw * ss;
					let vh = sh * ss - frameCount/1;
				
				if ((noise(np*32+xmotion/16 * ainp)) > 0.5) {
					vw = 0;
					vh = 0;
				}
					
					if (vw > 0 && vh > 0) {
						if (noise(nx * 2, ny * 2) > 0.5) {
							rect(-width / 2 + (x + noise(nx * 8) * width + abs(cos(ainp * PI * 20 + xmotion / 4 * nx + nx * PI * 2)) * 2 * no/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y + noise(ny * 8) * height+ abs(sin(ainp * PI * 20 + ymotion / 4 * ny + ny * PI * 2)) * 2 * no /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						} else {
							ellipse(-width / 2 + (x + noise(nx * 8) * width + abs(cos(ainp * PI * 20 + xmotion / 4 * nx + nx * PI * 2)) * 2 * no/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y + noise(ny * 8) * height + abs(sin(ainp * PI * 20 + ymotion / 4 * ny + ny * PI * 2)) * 2 * no /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						}
					//}
				}
			}
		}
		pop();
	}
	
	xmotion += 0.25;
	ymotion += 0.25;
}"
"1057077","Bumpy patterns 6","mySketch","// same as parallax checkerboard with static render goal

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseDetail(6, 0.7);
	
	noStroke();
	
	var context = drawingContext
	context.shadowOffsetX = random(-1, 1);
	context.shadowOffsetY = random(-1, 1);
	context.shadowBlur = 4; // more can be fun also
	context.shadowColor = ""black"";
	
	rectMode(CENTER);
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	//background(0);
	noStroke();
	//fill(0, 0, 0, 0.05);
	//rect(0, 0, width, height);
	
	let planes = 16;

	let sw = 100;
	let sh = 100;
	
	let xp_offset = 0;
	let yp_offset = 0;
	
	let w = width;
	let h = height;
	
	for (let p = 1; p <= planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let ainp = abs(0.5 - np) * 2;
		
		let sf = pow(4, ainp);
		
		push();
		translate(width / 2, height / 2);
	//	scale(sf - pow(xmotion/128, 4), sf - pow(xmotion/128, 4));
		// slow
		rotate(sf * 2);
		for (let y = 0; y <= h; y += sw) {
			for (let x = 0; x <= w; x += sh) {
				//if ((x % (sw * 2)) ^ (y % (sh * 2))) { // checkerboard pattern
					let nx = abs(0.5 - x / w) * 2;
					let ny = abs(0.5 - y / h) * 2;
					
					let no = noise(nx * 2, ny * 2);
					
					let ss = abs(sin((nx * ny) * PI * 2 + inp * PI * 2 + xmotion / 32)) * 2;
					
					stroke((32 + (1 - np) * 180 * sf + no * 140) % 360, 128 * sf, 128+128 * np, sf / 0.75);
					strokeWeight(1);
					fill((120 + (1 - np) * 180 * sf + no * 140) % 360, 128 * sf, 128+128 * np, sf / 4.5);
					
					let vw = sw * ss - frameCount/1;
					let vh = sh * ss - frameCount/1;
				
				if ((noise(np*32+xmotion/16 * ainp)) > 0.5) {
					vw = 0;
					vh = 0;
				}
					
					if (vw > 0 && vh > 0) {
						if (noise(nx * 2, ny * 2) > 0.5) {
							rect(-width / 2 + (x + noise(nx * 8) * width + abs(cos(ainp * PI * 20 + xmotion / 4 * nx + nx * PI * 2)) * 2 * no/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y + noise(ny * 8) * height+ abs(sin(ainp * PI * 20 + ymotion / 4 * ny + ny * PI * 2)) * 2 * no /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						} else {
							ellipse(-width / 2 + (x + noise(nx * 8) * width + abs(cos(ainp * PI * 20 + xmotion / 4 * nx + nx * PI * 2)) * 2 * no/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y + noise(ny * 8) * height + abs(sin(ainp * PI * 20 + ymotion / 4 * ny + ny * PI * 2)) * 2 * no /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						}
					//}
				}
			}
		}
		pop();
	}
	
	xmotion += 0.25;
	ymotion += 0.25;
}"
"1053684","Bumpy patterns 5","mySketch","// same as parallax checkerboard with static render goal

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseDetail(6, 0.7);
	
	noStroke();
	
	var context = drawingContext
	context.shadowOffsetX = random(-4, 4);
	context.shadowOffsetY = random(-4, 4);
	context.shadowBlur = 1; // more can be fun also
	context.shadowColor = ""white"";
	
	rectMode(CENTER);
}

let xmotion = 0;
let ymotion = 0;
let r = 0;

function draw() {
	//background(0);
	noStroke();
	//fill(0, 0, 0, 0.05);
	//rect(0, 0, width, height);
	
	if (frameCount % round(64 + 64 * random()) == 0) {
		xmotion = random() * 256;
		ymotion = random() * 256;
		r = random() * PI * 2;
	}
	
	let planes = 4;

	let sw = 100;
	let sh = 100;
	
	let xp_offset = 0;
	let yp_offset = 0;
	
	let w = width;
	let h = height;
	
	for (let p = 1; p <= planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let ainp = abs(0.5 - np) * 2;
		
		let sf = pow(1, ainp);
		
		push();
		translate(width / 2, height / 2);
		scale(sf - pow(xmotion/128, 4), sf - pow(xmotion/128, 4));
		// slow
		rotate(r);
		for (let y = 0; y <= h; y += sw) {
			for (let x = 0; x <= w; x += sh) {
				if ((x % (sw * 2)) ^ (y % (sh * 2))) { // checkerboard pattern
					let nx = abs(0.5 - x / w) * 2;
					let ny = abs(0.5 - y / h) * 2;
					
					let no = noise(nx * 0.5, ny * 0.5) * noise(ainp * 2);
					
					let ss = abs(sin((nx * ny) * PI * 2 + inp * PI * 2 + xmotion / 30)) * 2;
					
					stroke((140 + (1 - np) * 180 * sf + no * 140) % 360, 128 * sf, 192 * np, sf / 2.75);
					strokeWeight(1.25);
					fill(0, 0, 0, sf);
					
					let vw = sw * ss;
					let vh = sh * ss;
					
					if (vw > 0 && vh > 0) {
						if (noise(nx * 2, ny * 2) > 0.5) {
							rect(-width / 2 + (x + abs(cos(ainp * PI * 2 + xmotion / 4 * nx + nx * PI * 2)) * 2 * no/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y + abs(sin(ainp * PI * 2 + ymotion / 4 * ny + ny * PI * 2)) * 2 * no /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						} else {
							ellipse(-width / 2 + (x + abs(cos(ainp * PI * 2 + xmotion / 4 * nx + nx * PI * 2)) * 2 * no/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y + abs(sin(ainp * PI * 2 + ymotion / 4 * ny + ny * PI * 2)) * 2 * no /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						}
					}
				}
			}
		}
		pop();
	}
	
	xmotion += 0.25;
	ymotion += 0.25;
}"
"1052830","REYES rendering","mySketch","/**
  * Similar to my first Reyes sketch except it is this time accurate, non realtime and show texturing, how to generate surfaces and displacement.
	*
	* https://en.wikipedia.org/wiki/Reyes_rendering
	*
	* One can play with the subdivision factor and wireframe to look at how the surface is diced (grid of micropolygons),
	* this allow to add any amount of details to a surface via displacement and great shading.
	*
	* With phong shading.
	*/

let texture = null;
let heightmap = null;
function preload() {
  texture = loadImage('G4XAva5.png');
	heightmap = loadImage('cgxJEfN.png');
}

let frame = 0;

let cs = 3800; // also scale :P
let inc = 0.01; // control surface subdivision, lower = higher quality (but too slow for realtime)
let csi = 1.0 / inc; // how much points our surface will have along a specific axis
let scale = 1.0 / 8.0;

let depthbuffer;

function setup() {
  createCanvas(1024, 768);

  background(0);
	
	noStroke();
	
	depthbuffer = createGraphics(width, height);
	depthbuffer.noStroke();
	
	noStroke();
	
	heightmap.loadPixels();
	texture.loadPixels();
	
	draw2();
}

// barycentric interpolation
function edgeInter(a, b, c) { 
  return (c[0] - a[0]) * (b[1] - a[1]) - (c[1] - a[1]) * (b[0] - a[0]); 
}

function fillTriangle(v1, v2, v3, depth, shade) {
	let x1 = v1[0]; let x2 = v2[0]; let x3 = v3[0];
	let y1 = v1[1]; let y2 = v2[1]; let y3 = v3[1];
	
	let maxX = max(x1, max(x2, x3));
	let minX = min(x1, min(x2, x3));
	let maxY = max(y1, max(y2, y3));
	let minY = min(y1, min(y2, y3));
	
	let vs1x = x2 - x1;
	let vs1y = y2 - y1;
	let vs2x = x3 - x1;
	let vs2y = y3 - y1;
	/*
	// compute normals
	let nx1 = v1[2]; let nx2 = v2[2]; let nx3 = v3[2];
	let ny1 = v1[3]; let ny2 = v2[3]; let ny3 = v3[3];
	let nz1 = v1[4]; let nz2 = v2[4]; let nz3 = v3[4];
	
	let ux = nx2 - nx1; let uy = ny2 - ny1; let uz = nz2 - nz1;
	let vx = nx3 - nx1; let vy = ny3 - ny1; let vz = nz3 - nz1;
	
	// normals
	let nx = (ux * vz) - (uz * vy);
	let ny = (uz * vx) - (ux * vz);
	let nz = (ux * vy) - (uy * vx);
	
	// normalize
	let nl = sqrt((nx * nx) + (ny * ny) + (nz * nz));
	nx /= nl; ny /= nl; nz /= nl;
	
	// light pos
	let lpx = 0; let lpy = -2; let lpz = -1;
	// https://en.wikipedia.org/wiki/Phong_shading
	let ln = sqrt(((lpx - nx1) * (lpy - nx1)) + ((lpy - ny1) * (lpy - ny1)) + ((lpz - nz1) * (lpz - nz1)));
	lpx /= ln; lpy /= ln; lpz /= ln;
	
	let lambert = max(0, nx * lpx + ny * lpy + nz * lpz);
	
	let ambient = 0.0;
	let lsv = ambient + lambert;
	
	fill(shade[0] * lsv, shade[1] * lsv, shade[2] * lsv);
	*/
	fill(shade[0], shade[1], shade[2]);
	for (let x = minX; x <= maxX; x += 1) {
  	for (let y = minY; y <= maxY; y += 1) {
			let qx = x - x1;
			let qy = y - y1;

			// http://courses.cms.caltech.edu/cs171/assignments/hw2/hw2-notes/notes-hw2.html#NotesSection1.3
			let a = edgeInter(v2, v3, [x, y]);
			let b = edgeInter(v3, v1, [x, y]);
			let c = edgeInter(v1, v2, [x, y]);

			if (a >= 0 && b >= 0 && c >= 0) {
				// check against Z buffer!
				if (depth >= depthbuffer.get(x, y)[0]) {
					// depth value go into depth buffer
					depthbuffer.fill(depth, depth, depth);
					depthbuffer.rect(x, y, 1, 1);

					rect(x, y, 1, 1);
				}
			}
		}
	}
}

function draw2() {
	// clear z-buffer
	depthbuffer.background(0);

	noStroke();
	
  background(0);

	let rxa = 0.03 * frame-PI / 3;
	let rya = 0.04 * frame;

	// rotation values
	let crx = cos(rxa);
	let cry = cos(rya);
	let srx = sin(rxa);
	let sry = sin(rya);
	
	// rm = rotation matrix
	let rm = [0,0,0,0,0,0,0,0,0];

	rm[0] = cry;     /*rm[1] = 0.0f;*/ rm[2] = -sry;
	rm[3] = sry * srx; rm[4] = crx;    rm[5] = cry * srx;
	rm[6] = sry * crx; rm[7] = -srx;   rm[8] = cry * crx;
	
	let last_point_x = null;
	let points_x = [];
	
	let x2 = width / 2;
	let y2 = height / 2;
	
	// step surface in normalized space
	let x, y, z;
	// the z loop can be used for volumetric rendering
	//for (z = 0.0; z <= 1.0; z += inc) {
		let vr = [0,0,0];

		//let pz = 2.0 * z - 1.0; // normalize screen space

		//vr[2] = pz * scale;
		for (y = 0.0; y <= 1.0; y += inc) {
			let py = 2.0 * (y - 0.5) - 1.0;

			vr[1] = py * scale;
			let xinc = 0;
			for (x = 0.0; x <= 1.0; x += inc) {
				
				// displacement from heightmap
				let h = heightmap.pixels[(round(x * heightmap.width) + round(y * heightmap.height) * heightmap.width) * 4 + 0] / 255;
				z = 0.5 + h / 4;
				// any parametric surfaces can be built easily here :
				// z = abs(sin(x * PI)) * abs(cos(y * PI + PI / 2)) / 2 + 0.5;
				let pz = 2.0 * z - 1.0; // normalize screen space

				vr[2] = pz * scale;
				
				let px = (2.0 * x - 1.0);
				
				vr[0] = px * scale;

				// rotate/transform points
				let vrr = [
						rm[0] * vr[0] + rm[3] * vr[1] + rm[6] * vr[2],
						rm[1] * vr[0] + rm[4] * vr[1] + rm[7] * vr[2],
						rm[2] * vr[0] + rm[5] * vr[1] + rm[8] * vr[2]
				];
			
				// compute length & normalize
				let le = sqrt((vrr[0] * vrr[0]) + (vrr[1] * vrr[1]) + (vrr[2] * vrr[2]));
			  let vrn = [ vrr[0] / le, vrr[1] / le, vrr[2] / le ];

				// point shade based on normalized Z value
				let shadez = pow(vrn[2], 2);
			  let shade = [shadez * texture.pixels[(round(x * texture.width) + round(y * texture.height) * texture.width) * 4 + 0],
											 shadez * texture.pixels[(round(x * texture.width) + round(y * texture.height) * texture.width) * 4 + 1],
											 shadez * texture.pixels[(round(x * texture.width) + round(y * texture.height) * texture.width) * 4 + 2]];
				
				// since we were in normalized space we scale it to screen space and translate it at the center of the screen
				let posx = x2 - (int)(vrr[0] * cs);
				let posy = y2 - (int)(vrr[1] * cs);
				
				// micropolygons rendering
				if (points_x[xinc] && points_x[xinc - 1]) {
					let depth = vrn[2] * 255;
					
					fillTriangle(points_x[xinc - 1], points_x[xinc], last_point_x, depth, shade);
					fillTriangle([posx, posy], points_x[xinc], points_x[xinc - 1], depth, shade);
				}
				
/*
				// wireframe
				stroke(shadez * 255);
				strokeWeight(0.25);
				if (points_x[xinc]) {
					line(points_x[xinc][0], points_x[xinc][1], posx, posy);
				}
				if (points_x[xinc + 1]) {
					line(points_x[xinc + 1][0], points_x[xinc + 1][1], posx, posy);
				}
				if (points_x[xinc-1]) {
					line(points_x[xinc-1][0], points_x[xinc-1][1], posx, posy);
				}
*/
				
				if (y > 0) {
					last_point_x = points_x[xinc];
				}
				
				points_x[xinc] = [posx, posy, vrr[0], vrr[1], vrr[2]];
				
				xinc += 1;
			}
		}

	// display z buffer
	//image(depthbuffer, 0, 0);

	frame += 1;
}"
"1052830","REYES rendering","mySketch","/**
  * Similar to my first Reyes sketch except it is this time accurate, non realtime and show texturing, how to generate surfaces and displacement.
	*
	* https://en.wikipedia.org/wiki/Reyes_rendering
	*
	* One can play with the subdivision factor and wireframe to look at how the surface is diced (grid of micropolygons),
	* this allow to add any amount of details to a surface via displacement and great shading.
	*
	* With phong shading.
	*/

let texture = null;
let heightmap = null;
function preload() {
  texture = loadImage('G4XAva5.png');
	heightmap = loadImage('cgxJEfN.png');
}

let frame = 0;

let cs = 3800; // also scale :P
let inc = 0.01; // control surface subdivision, lower = higher quality (but too slow for realtime)
let csi = 1.0 / inc; // how much points our surface will have along a specific axis
let scale = 1.0 / 8.0;

let depthbuffer;

function setup() {
  createCanvas(1024, 768);

  background(0);
	
	noStroke();
	
	depthbuffer = createGraphics(width, height);
	depthbuffer.noStroke();
	
	noStroke();
	
	heightmap.loadPixels();
	texture.loadPixels();
	
	draw2();
}

// barycentric interpolation
function edgeInter(a, b, c) { 
  return (c[0] - a[0]) * (b[1] - a[1]) - (c[1] - a[1]) * (b[0] - a[0]); 
}

function fillTriangle(v1, v2, v3, depth, shade) {
	let x1 = v1[0]; let x2 = v2[0]; let x3 = v3[0];
	let y1 = v1[1]; let y2 = v2[1]; let y3 = v3[1];
	
	let maxX = max(x1, max(x2, x3));
	let minX = min(x1, min(x2, x3));
	let maxY = max(y1, max(y2, y3));
	let minY = min(y1, min(y2, y3));

	/*
	// compute normals
	let nx1 = v1[2]; let nx2 = v2[2]; let nx3 = v3[2];
	let ny1 = v1[3]; let ny2 = v2[3]; let ny3 = v3[3];
	let nz1 = v1[4]; let nz2 = v2[4]; let nz3 = v3[4];
	
	let ux = nx2 - nx1; let uy = ny2 - ny1; let uz = nz2 - nz1;
	let vx = nx3 - nx1; let vy = ny3 - ny1; let vz = nz3 - nz1;
	
	// normals
	let nx = (ux * vz) - (uz * vy);
	let ny = (uz * vx) - (ux * vz);
	let nz = (ux * vy) - (uy * vx);
	
	// normalize
	let nl = sqrt((nx * nx) + (ny * ny) + (nz * nz));
	nx /= nl; ny /= nl; nz /= nl;
	
	// light pos
	let lpx = 0; let lpy = -2; let lpz = -1;
	// https://en.wikipedia.org/wiki/Phong_shading
	let ln = sqrt(((lpx - nx1) * (lpy - nx1)) + ((lpy - ny1) * (lpy - ny1)) + ((lpz - nz1) * (lpz - nz1)));
	lpx /= ln; lpy /= ln; lpz /= ln;
	
	let lambert = max(0, nx * lpx + ny * lpy + nz * lpz);
	
	let ambient = 0.0;
	let lsv = ambient + lambert;
	
	fill(shade[0] * lsv, shade[1] * lsv, shade[2] * lsv);
	*/
	fill(shade[0], shade[1], shade[2]);
	for (let x = minX; x <= maxX; x += 1) {
  	for (let y = minY; y <= maxY; y += 1) {
			let qx = x - x1;
			let qy = y - y1;

			// http://courses.cms.caltech.edu/cs171/assignments/hw2/hw2-notes/notes-hw2.html#NotesSection1.3
			let a = edgeInter(v2, v3, [x, y]);
			let b = edgeInter(v3, v1, [x, y]);
			let c = edgeInter(v1, v2, [x, y]);

			if (a >= 0 && b >= 0 && c >= 0) {
				// check against Z buffer!
				if (depth >= depthbuffer.get(x, y)[0]) {
					// depth value go into depth buffer
					depthbuffer.fill(depth, depth, depth);
					depthbuffer.rect(x, y, 1, 1);

					rect(x, y, 1, 1);
				}
			}
		}
	}
}

function draw2() {
	// clear z-buffer
	depthbuffer.background(0);

	noStroke();
	
  background(0);

	let rxa = 0.03 * frame-PI / 3;
	let rya = 0.04 * frame;

	// rotation values
	let crx = cos(rxa);
	let cry = cos(rya);
	let srx = sin(rxa);
	let sry = sin(rya);
	
	// rm = rotation matrix
	let rm = [0,0,0,0,0,0,0,0,0];

	rm[0] = cry;     /*rm[1] = 0.0f;*/ rm[2] = -sry;
	rm[3] = sry * srx; rm[4] = crx;    rm[5] = cry * srx;
	rm[6] = sry * crx; rm[7] = -srx;   rm[8] = cry * crx;
	
	let last_point_x = null;
	let points_x = [];
	
	let x2 = width / 2;
	let y2 = height / 2;
	
	// step surface in normalized space
	let x, y, z;
	// the z loop can be used for volumetric rendering
	//for (z = 0.0; z <= 1.0; z += inc) {
		let vr = [0,0,0];

		//let pz = 2.0 * z - 1.0; // normalize screen space

		//vr[2] = pz * scale;
		for (y = 0.0; y <= 1.0; y += inc) {
			let py = 2.0 * (y - 0.5) - 1.0;

			vr[1] = py * scale;
			let xinc = 0;
			for (x = 0.0; x <= 1.0; x += inc) {
				
				// displacement from heightmap
				let h = heightmap.pixels[(round(x * heightmap.width) + round(y * heightmap.height) * heightmap.width) * 4 + 0] / 255;
				z = 0.5 + h / 4;
				// any parametric surfaces can be built easily here :
				// z = abs(sin(x * PI)) * abs(cos(y * PI + PI / 2)) / 2 + 0.5;
				let pz = 2.0 * z - 1.0; // normalize screen space

				vr[2] = pz * scale;
				
				let px = (2.0 * x - 1.0);
				
				vr[0] = px * scale;

				// rotate/transform points
				let vrr = [
						rm[0] * vr[0] + rm[3] * vr[1] + rm[6] * vr[2],
						rm[1] * vr[0] + rm[4] * vr[1] + rm[7] * vr[2],
						rm[2] * vr[0] + rm[5] * vr[1] + rm[8] * vr[2]
				];
			
				// compute length & normalize
				let le = sqrt((vrr[0] * vrr[0]) + (vrr[1] * vrr[1]) + (vrr[2] * vrr[2]));
			  let vrn = [ vrr[0] / le, vrr[1] / le, vrr[2] / le ];

				// point shade based on normalized Z value
				let shadez = pow(vrn[2], 2);
			  let shade = [shadez * texture.pixels[(round(x * texture.width) + round(y * texture.height) * texture.width) * 4 + 0],
											 shadez * texture.pixels[(round(x * texture.width) + round(y * texture.height) * texture.width) * 4 + 1],
											 shadez * texture.pixels[(round(x * texture.width) + round(y * texture.height) * texture.width) * 4 + 2]];
				
				// since we were in normalized space we scale it to screen space and translate it at the center of the screen
				let posx = x2 - (int)(vrr[0] * cs);
				let posy = y2 - (int)(vrr[1] * cs);
				
				// micropolygons rendering
				if (points_x[xinc] && points_x[xinc - 1]) {
					let depth = vrn[2] * 255;
					
					fillTriangle(points_x[xinc - 1], points_x[xinc], last_point_x, depth, shade);
					fillTriangle([posx, posy], points_x[xinc], points_x[xinc - 1], depth, shade);
				}
				
/*
				// wireframe
				stroke(shadez * 255);
				strokeWeight(0.25);
				if (points_x[xinc]) {
					line(points_x[xinc][0], points_x[xinc][1], posx, posy);
				}
				if (points_x[xinc + 1]) {
					line(points_x[xinc + 1][0], points_x[xinc + 1][1], posx, posy);
				}
				if (points_x[xinc-1]) {
					line(points_x[xinc-1][0], points_x[xinc-1][1], posx, posy);
				}
*/
				
				if (y > 0) {
					last_point_x = points_x[xinc];
				}
				
				points_x[xinc] = [posx, posy, vrr[0], vrr[1], vrr[2]];
				
				xinc += 1;
			}
		}

	// display z buffer
	//image(depthbuffer, 0, 0);

	frame += 1;
}"
"1052830","REYES rendering","mySketch","/**
  * Similar to my first Reyes sketch except it is this time accurate, non realtime and show texturing, how to generate surfaces and displacement.
	*
	* https://en.wikipedia.org/wiki/Reyes_rendering
	*
	* One can play with the subdivision factor and wireframe to look at how the surface is diced (grid of micropolygons),
	* this allow to add any amount of details to a surface via displacement and great shading.
	*
	* With phong shading.
	*/

let texture = null;
let heightmap = null;
function preload() {
  texture = loadImage('G4XAva5.png');
	heightmap = loadImage('cgxJEfN.png');
}

let frame = 0;

let cs = 3800; // also scale :P
let inc = 0.001; // control surface subdivision, lower = higher quality (but too slow for realtime)
let csi = 1.0 / inc; // how much points our surface will have along a specific axis
let scale = 1.0 / 8.0;

let depthbuffer;

function setup() {
  createCanvas(1024, 768);

  background(0);
	
	noStroke();
	
	depthbuffer = createGraphics(width, height);
	depthbuffer.noStroke();
	
	noStroke();
	
	heightmap.loadPixels();
	texture.loadPixels();
	
	draw2();
}

// barycentric interpolation
function edgeInter(a, b, c) { 
  return (c[0] - a[0]) * (b[1] - a[1]) - (c[1] - a[1]) * (b[0] - a[0]); 
}

function fillTriangle(v1, v2, v3, depth, shade) {
	let x1 = v1[0]; let x2 = v2[0]; let x3 = v3[0];
	let y1 = v1[1]; let y2 = v2[1]; let y3 = v3[1];
	
	let maxX = max(x1, max(x2, x3));
	let minX = min(x1, min(x2, x3));
	let maxY = max(y1, max(y2, y3));
	let minY = min(y1, min(y2, y3));

	// compute normals
	let nx1 = v1[2]; let nx2 = v2[2]; let nx3 = v3[2];
	let ny1 = v1[3]; let ny2 = v2[3]; let ny3 = v3[3];
	let nz1 = v1[4]; let nz2 = v2[4]; let nz3 = v3[4];
	
	let ux = nx2 - nx1; let uy = ny2 - ny1; let uz = nz2 - nz1;
	let vx = nx3 - nx1; let vy = ny3 - ny1; let vz = nz3 - nz1;
	
	// normals
	let nx = (ux * vz) - (uz * vy);
	let ny = (uz * vx) - (ux * vz);
	let nz = (ux * vy) - (uy * vx);
	
	// normalize
	let nl = sqrt((nx * nx) + (ny * ny) + (nz * nz));
	nx /= nl; ny /= nl; nz /= nl;
	
	// light pos
	let lpx = 0; let lpy = 0.5; let lpz = -4.2;
	// https://en.wikipedia.org/wiki/Phong_shading
	let ln = sqrt(((lpx - nx1) * (lpy - nx1)) + ((lpy - ny1) * (lpy - ny1)) + ((lpz - nz1) * (lpz - nz1)));
	lpx /= ln; lpy /= ln; lpz /= ln;
	
	let lambert = max(0, nx * lpx + ny * lpy + nz * lpz);
	
	let specular = 0;
	if (lambert > 0) {
		let rx = lpx - 2 * (lpx * nx + lpy * ny + lpz * nz) * nx;
		let ry = lpy - 2 * (lpx * nx + lpy * ny + lpz * nz) * ny;
		let rz = lpz - 2 * (lpx * nx + lpy * ny + lpz * nz) * nz;
		
		let vnl = sqrt((nx1 * nx1) + (ny1 * ny1) + (nz1 * nz1));
		let nnx = nx1 / vnl; let nny = ny1 / vnl; let nnz = nz1 / vnl;
		let spec_angle = max(0, rx * nnx + ry * nny + rz * nnz);
		specular = pow(spec_angle, 80);
	}
	
	let ambient = 0.0;
	let lsv = ambient + lambert + specular * 0.1;
	
	fill(shade[0] * lsv, shade[1] * lsv, shade[2] * lsv);
	
	//fill(shade[0], shade[1], shade[2]);
	for (let x = minX; x <= maxX; x += 1) {
  	for (let y = minY; y <= maxY; y += 1) {
			let qx = x - x1;
			let qy = y - y1;

			// http://courses.cms.caltech.edu/cs171/assignments/hw2/hw2-notes/notes-hw2.html#NotesSection1.3
			let a = edgeInter(v2, v3, [x, y]);
			let b = edgeInter(v3, v1, [x, y]);
			let c = edgeInter(v1, v2, [x, y]);

			if (a >= 0 && b >= 0 && c >= 0) {
				// check against Z buffer!
				if (depth >= depthbuffer.get(x, y)[0]) {
					// depth value go into depth buffer
					depthbuffer.fill(depth, depth, depth);
					depthbuffer.rect(x, y, 1, 1);

					rect(x, y, 1, 1);
				}
			}
		}
	}
}

function draw2() {
	// clear z-buffer
	depthbuffer.background(0);

	noStroke();
	
  background(0);

	let rxa = 0.03 * frame-PI / 3;
	let rya = 0.04 * frame;

	// rotation values
	let crx = cos(rxa);
	let cry = cos(rya);
	let srx = sin(rxa);
	let sry = sin(rya);
	
	// rm = rotation matrix
	let rm = [0,0,0,0,0,0,0,0,0];

	rm[0] = cry;     /*rm[1] = 0.0f;*/ rm[2] = -sry;
	rm[3] = sry * srx; rm[4] = crx;    rm[5] = cry * srx;
	rm[6] = sry * crx; rm[7] = -srx;   rm[8] = cry * crx;
	
	let last_point_x = null;
	let points_x = [];
	
	let x2 = width / 2;
	let y2 = height / 2;
	
	// step surface in normalized space
	let x, y, z;
	// the z loop can be used for volumetric rendering
	//for (z = 0.0; z <= 1.0; z += inc) {
		let vr = [0,0,0];

		//let pz = 2.0 * z - 1.0; // normalize screen space

		//vr[2] = pz * scale;
		for (y = 0.0; y <= 1.0; y += inc) {
			let py = 2.0 * (y - 0.5) - 1.0;

			vr[1] = py * scale;
			let xinc = 0;
			for (x = 0.0; x <= 1.0; x += inc) {
				
				// displacement from heightmap
				let h = heightmap.pixels[(round(x * heightmap.width) + round(y * heightmap.height) * heightmap.width) * 4 + 0] / 255;
				z = 0.5 + h / 4;
				// any parametric surfaces can be built easily here :
				let nn = noise(x*8,y*8);
				 z = 0.5+nn/4;//abs(sin(x * PI+noise(x,y))) * abs(cos(y * PI + PI / 2+noise(x,y)*PI)) / 8 + 0.5;
				let pz = 2.0 * z - 1.0; // normalize screen space

				vr[2] = pz * scale;
				
				let px = (2.0 * x - 1.0);
				
				vr[0] = px * scale;

				// rotate/transform points
				let vrr = [
						rm[0] * vr[0] + rm[3] * vr[1] + rm[6] * vr[2],
						rm[1] * vr[0] + rm[4] * vr[1] + rm[7] * vr[2],
						rm[2] * vr[0] + rm[5] * vr[1] + rm[8] * vr[2]
				];
			
				// compute length & normalize
				let le = sqrt((vrr[0] * vrr[0]) + (vrr[1] * vrr[1]) + (vrr[2] * vrr[2]));
			  let vrn = [ vrr[0] / le, vrr[1] / le, vrr[2] / le ];

				// point shade based on normalized Z value
				let shadez = pow(vrn[2], 2);
			  let shade = [shadez * nn * 255/*texture.pixels[(round(x * texture.width) + round(y * texture.height) * texture.width) * 4 + 0]*/,
											 shadez * nn * 255/** texture.pixels[(round(x * texture.width) + round(y * texture.height) * texture.width) * 4 + 1]*/,
											 shadez * nn * 255/** texture.pixels[(round(x * texture.width) + round(y * texture.height) * texture.width) * 4 + 2]*/];
				
				// since we were in normalized space we scale it to screen space and translate it at the center of the screen
				let posx = x2 - (int)(vrr[0] * cs);
				let posy = y2 - (int)(vrr[1] * cs);
				
				// micropolygons rendering
				if (points_x[xinc] && points_x[xinc - 1]) {
					let depth = vrn[2] * 255;
					
					fillTriangle(points_x[xinc - 1], points_x[xinc], last_point_x, depth, shade);
					fillTriangle([posx, posy], points_x[xinc], points_x[xinc - 1], depth, shade);
				}
				
/*
				// wireframe
				stroke(shadez * 255);
				strokeWeight(0.25);
				if (points_x[xinc]) {
					line(points_x[xinc][0], points_x[xinc][1], posx, posy);
				}
				if (points_x[xinc + 1]) {
					line(points_x[xinc + 1][0], points_x[xinc + 1][1], posx, posy);
				}
				if (points_x[xinc-1]) {
					line(points_x[xinc-1][0], points_x[xinc-1][1], posx, posy);
				}
*/
				
				if (y > 0) {
					last_point_x = points_x[xinc];
				}
				
				points_x[xinc] = [posx, posy, px, py, pz];
				
				xinc += 1;
			}
		}

	// display z buffer
	//image(depthbuffer, 0, 0);

	frame += 1;
}"
"1052830","REYES rendering","mySketch","/**
  * Similar to my first Reyes sketch except it is this time accurate, non realtime and show texturing, how to generate surfaces and displacement.
	*
	* https://en.wikipedia.org/wiki/Reyes_rendering
	*
	* One can play with the subdivision factor and wireframe to look at how the surface is diced (grid of micropolygons),
	* this allow to add any amount of details to a surface via displacement and great shading.
	*
	* With phong shading.
	*/

let texture = null;
let heightmap = null;
function preload() {
  texture = loadImage('G4XAva5.png');
	heightmap = loadImage('cgxJEfN.png');
}

let frame = 0;

let inc = 0.001; // control surface subdivision, lower = higher quality (but too slow for realtime)
let csi = 1.0 / inc; // how much points our surface will have along a specific axis
let scale = 1.0 / 1.6;

let depthbuffer;

function setup() {
  createCanvas(1024, 768);

  background(0);
	
	noStroke();
	
	depthbuffer = createGraphics(width, height);
	depthbuffer.noStroke();
	
	noStroke();
	
	heightmap.loadPixels();
	texture.loadPixels();
	
	draw2();
}

// barycentric interpolation
function edgeInter(a, b, c) { 
  return (c[0] - a[0]) * (b[1] - a[1]) - (c[1] - a[1]) * (b[0] - a[0]); 
}

function fillTriangle(v1, v2, v3, depth, shade) {
	let x1 = v1[0]; let x2 = v2[0]; let x3 = v3[0];
	let y1 = v1[1]; let y2 = v2[1]; let y3 = v3[1];
	
	let maxX = max(x1, max(x2, x3));
	let minX = min(x1, min(x2, x3));
	let maxY = max(y1, max(y2, y3));
	let minY = min(y1, min(y2, y3));

	// compute normals
	let nx1 = v1[2]; let nx2 = v2[2]; let nx3 = v3[2];
	let ny1 = v1[3]; let ny2 = v2[3]; let ny3 = v3[3];
	let nz1 = v1[4]; let nz2 = v2[4]; let nz3 = v3[4];
	
	let ux = nx2 - nx1; let uy = ny2 - ny1; let uz = nz2 - nz1;
	let vx = nx3 - nx1; let vy = ny3 - ny1; let vz = nz3 - nz1;
	
	// normals
	let nx = (ux * vz) - (uz * vy);
	let ny = (uz * vx) - (ux * vz);
	let nz = (ux * vy) - (uy * vx);
	
	// normalize
	let nl = sqrt((nx * nx) + (ny * ny) + (nz * nz));
	nx /= nl; ny /= nl; nz /= nl;
	
	// light pos
	let lpx = 0; let lpy = 0.5; let lpz = -4.2;
	// https://en.wikipedia.org/wiki/Phong_shading
	let ln = sqrt(((lpx - nx1) * (lpy - nx1)) + ((lpy - ny1) * (lpy - ny1)) + ((lpz - nz1) * (lpz - nz1)));
	lpx /= ln; lpy /= ln; lpz /= ln;
	
	let lambert = max(0, nx * lpx + ny * lpy + nz * lpz);
	
	let specular = 0;
	if (lambert > 0) {
		let rx = lpx - 2 * (lpx * nx + lpy * ny + lpz * nz) * nx;
		let ry = lpy - 2 * (lpx * nx + lpy * ny + lpz * nz) * ny;
		let rz = lpz - 2 * (lpx * nx + lpy * ny + lpz * nz) * nz;
		
		let vnl = sqrt((nx1 * nx1) + (ny1 * ny1) + (nz1 * nz1));
		let nnx = nx1 / vnl; let nny = ny1 / vnl; let nnz = nz1 / vnl;
		let spec_angle = max(0, rx * nnx + ry * nny + rz * nnz);
		specular = pow(spec_angle, 80);
	}
	
	let ambient = 0.0;
	let lsv = ambient + lambert + specular * 0.1;
	
	fill(shade[0] * lsv, shade[1] * lsv, shade[2] * lsv);
	
	//fill(shade[0], shade[1], shade[2]);
	for (let x = minX; x <= maxX; x += 1) {
  	for (let y = minY; y <= maxY; y += 1) {
			let qx = x - x1;
			let qy = y - y1;

			// http://courses.cms.caltech.edu/cs171/assignments/hw2/hw2-notes/notes-hw2.html#NotesSection1.3
			let a = edgeInter(v2, v3, [x, y]);
			let b = edgeInter(v3, v1, [x, y]);
			let c = edgeInter(v1, v2, [x, y]);

			if (a >= 0 && b >= 0 && c >= 0) {
				// check against Z buffer!
				if (depth >= depthbuffer.get(x, y)[0]) {
					// depth value go into depth buffer
					depthbuffer.fill(depth, depth, depth);
					depthbuffer.rect(x, y, 1, 1);

					rect(x, y, 1, 1);
				}
			}
		}
	}
}

function draw2() {
	// clear z-buffer
	depthbuffer.background(0);

	noStroke();
	
  background(0);

	let rxa = 0.03 * frame-PI / 3;
	let rya = 0.04 * frame;

	// rotation values
	let crx = cos(rxa);
	let cry = cos(rya);
	let srx = sin(rxa);
	let sry = sin(rya);
	
	// rm = rotation matrix
	let rm = [0,0,0,0,0,0,0,0,0];

	rm[0] = cry;     /*rm[1] = 0.0f;*/ rm[2] = -sry;
	rm[3] = sry * srx; rm[4] = crx;    rm[5] = cry * srx;
	rm[6] = sry * crx; rm[7] = -srx;   rm[8] = cry * crx;
	
	let last_point_x = null;
	let points_x = [];
	
	let x2 = width / 2;
	let y2 = height / 2;
	
	// step surface in normalized space
	let x, y, z;
	// the z loop can be used for volumetric rendering
	//for (z = 0.0; z <= 1.0; z += inc) {
		let vr = [0,0,0];

		//let pz = 2.0 * z - 1.0; // normalize screen space

		//vr[2] = pz * scale;
		for (y = 0.0; y <= 1.0; y += inc) {
			let py = 2.0 * (y - 0.5) - 1.0;

			vr[1] = py * scale;
			let xinc = 0;
			for (x = 0.0; x <= 1.0; x += inc) {
				
				// displacement from heightmap
				let h = heightmap.pixels[(round(x * heightmap.width) + round(y * heightmap.height) * heightmap.width) * 4 + 0] / 255;
				z = 0.5 + h / 4;
				// any parametric surfaces can be built easily here :
				let nn = noise(x*8,y*8);
				 z = 0.5+nn/4;//abs(sin(x * PI+noise(x,y))) * abs(cos(y * PI + PI / 2+noise(x,y)*PI)) / 8 + 0.5;
				let pz = 2.0 * z - 1.0; // normalize screen space

				vr[2] = pz * scale;
				
				let px = (2.0 * x - 1.0);
				
				vr[0] = px * scale;

				// rotate/transform points
				let vrr = [
						rm[0] * vr[0] + rm[3] * vr[1] + rm[6] * vr[2],
						rm[1] * vr[0] + rm[4] * vr[1] + rm[7] * vr[2],
						rm[2] * vr[0] + rm[5] * vr[1] + rm[8] * vr[2]
				];
			
				// compute length & normalize
				let le = sqrt((vrr[0] * vrr[0]) + (vrr[1] * vrr[1]) + (vrr[2] * vrr[2]));
			  let vrn = [ vrr[0] / le, vrr[1] / le, vrr[2] / le ];

				// point shade based on normalized Z value
				let shadez = pow(vrn[2], 2);
			  let shade = [shadez * nn * 255/*texture.pixels[(round(x * texture.width) + round(y * texture.height) * texture.width) * 4 + 0]*/,
											 shadez * nn * 255/** texture.pixels[(round(x * texture.width) + round(y * texture.height) * texture.width) * 4 + 1]*/,
											 shadez * nn * 255/** texture.pixels[(round(x * texture.width) + round(y * texture.height) * texture.width) * 4 + 2]*/];
				
				// since we were in normalized space we scale it to screen space and translate it at the center of the screen
				let posx = x2 - (int)(vrr[0] * width);
				let posy = y2 - (int)(vrr[1] * height);
				
				// micropolygons rendering
				if (points_x[xinc] && points_x[xinc - 1]) {
					let depth = vrn[2] * 255;
					
					fillTriangle(points_x[xinc - 1], points_x[xinc], last_point_x, depth, shade);
					fillTriangle([posx, posy], points_x[xinc], points_x[xinc - 1], depth, shade);
				}
				
/*
				// wireframe
				stroke(shadez * 255);
				strokeWeight(0.25);
				if (points_x[xinc]) {
					line(points_x[xinc][0], points_x[xinc][1], posx, posy);
				}
				if (points_x[xinc + 1]) {
					line(points_x[xinc + 1][0], points_x[xinc + 1][1], posx, posy);
				}
				if (points_x[xinc-1]) {
					line(points_x[xinc-1][0], points_x[xinc-1][1], posx, posy);
				}
*/
				
				if (y > 0) {
					last_point_x = points_x[xinc];
				}
				
				points_x[xinc] = [posx, posy, px, py, pz];
				
				xinc += 1;
			}
		}

	// display z buffer
	//image(depthbuffer, 0, 0);

	frame += 1;
}"
"1052830","REYES rendering","mySketch","/**
  * Similar to my first Reyes sketch except it is this time accurate, non realtime and show texturing, how to generate surfaces and displacement.
	*
	* https://en.wikipedia.org/wiki/Reyes_rendering
	*
	* One can play with the subdivision factor and wireframe to look at how the surface is diced (grid of micropolygons),
	* this allow to add any amount of details to a surface via displacement and great shading.
	*
	* With phong shading.
	*/

let texture = null;
let heightmap = null;
function preload() {
  texture = loadImage('G4XAva5.png');
	heightmap = loadImage('cgxJEfN.png');
}

let frame = 0;

let inc = 0.01; // control surface subdivision, lower = higher quality (but too slow for realtime)
let csi = 1.0 / inc; // how much points our surface will have along a specific axis
let scale = 1.0 / 1.6;

let depthbuffer;

function setup() {
  createCanvas(1024, 768);

  background(0);
	
	noStroke();
	
	depthbuffer = createGraphics(width, height);
	depthbuffer.noStroke();
	
	noStroke();
	
	heightmap.loadPixels();
	texture.loadPixels();
	
	draw2();
}

// barycentric interpolation
function edgeInter(a, b, c) { 
  return (c[0] - a[0]) * (b[1] - a[1]) - (c[1] - a[1]) * (b[0] - a[0]); 
}

function fillTriangle(v1, v2, v3, depth, shade) {
	let x1 = v1[0]; let x2 = v2[0]; let x3 = v3[0];
	let y1 = v1[1]; let y2 = v2[1]; let y3 = v3[1];
	
	let maxX = max(x1, max(x2, x3));
	let minX = min(x1, min(x2, x3));
	let maxY = max(y1, max(y2, y3));
	let minY = min(y1, min(y2, y3));

	// compute normals
	let nx1 = v1[2]; let nx2 = v2[2]; let nx3 = v3[2];
	let ny1 = v1[3]; let ny2 = v2[3]; let ny3 = v3[3];
	let nz1 = v1[4]; let nz2 = v2[4]; let nz3 = v3[4];
	
	let ux = nx2 - nx1; let uy = ny2 - ny1; let uz = nz2 - nz1;
	let vx = nx3 - nx1; let vy = ny3 - ny1; let vz = nz3 - nz1;
	
	// normals
	let nx = (ux * vz) - (uz * vy);
	let ny = (uz * vx) - (ux * vz);
	let nz = (ux * vy) - (uy * vx);
	
	// normalize
	let nl = sqrt((nx * nx) + (ny * ny) + (nz * nz));
	nx /= nl; ny /= nl; nz /= nl;
	
	// light pos
	let lpx = 0; let lpy = 0.5; let lpz = -4.2;
	// https://en.wikipedia.org/wiki/Phong_shading
	let ln = sqrt(((lpx - nx1) * (lpy - nx1)) + ((lpy - ny1) * (lpy - ny1)) + ((lpz - nz1) * (lpz - nz1)));
	lpx /= ln; lpy /= ln; lpz /= ln;
	
	let lambert = max(0, nx * lpx + ny * lpy + nz * lpz);
	
	let specular = 0;
	if (lambert > 0) {
		let rx = lpx - 2 * (lpx * nx + lpy * ny + lpz * nz) * nx;
		let ry = lpy - 2 * (lpx * nx + lpy * ny + lpz * nz) * ny;
		let rz = lpz - 2 * (lpx * nx + lpy * ny + lpz * nz) * nz;
		
		let vnl = sqrt((nx1 * nx1) + (ny1 * ny1) + (nz1 * nz1));
		let nnx = nx1 / vnl; let nny = ny1 / vnl; let nnz = nz1 / vnl;
		let spec_angle = max(0, rx * nnx + ry * nny + rz * nnz);
		specular = pow(spec_angle, 80);
	}
	
	let ambient = 0.0;
	let lsv = ambient + lambert + specular * 0.1;
	
	fill(shade[0] * lsv, shade[1] * lsv, shade[2] * lsv);
	
	//fill(shade[0], shade[1], shade[2]);
	for (let x = minX; x <= maxX; x += 1) {
  	for (let y = minY; y <= maxY; y += 1) {
			let qx = x - x1;
			let qy = y - y1;

			// http://courses.cms.caltech.edu/cs171/assignments/hw2/hw2-notes/notes-hw2.html#NotesSection1.3
			let a = edgeInter(v2, v3, [x, y]);
			let b = edgeInter(v3, v1, [x, y]);
			let c = edgeInter(v1, v2, [x, y]);

			if (a >= 0 && b >= 0 && c >= 0) {
				// check against Z buffer!
				if (depth >= depthbuffer.get(x, y)[0]) {
					// depth value go into depth buffer
					depthbuffer.fill(depth, depth, depth);
					depthbuffer.rect(x, y, 1, 1);

					rect(x, y, 1, 1);
				}
			}
		}
	}
}

function draw2() {
	// clear z-buffer
	depthbuffer.background(0);

	noStroke();
	
  background(0);

	let rxa = 0.03 * frame-PI / 3;
	let rya = 0.04 * frame;

	// rotation values
	let crx = cos(rxa);
	let cry = cos(rya);
	let srx = sin(rxa);
	let sry = sin(rya);
	
	// rm = rotation matrix
	let rm = [0,0,0,0,0,0,0,0,0];

	rm[0] = cry;     /*rm[1] = 0.0f;*/ rm[2] = -sry;
	rm[3] = sry * srx; rm[4] = crx;    rm[5] = cry * srx;
	rm[6] = sry * crx; rm[7] = -srx;   rm[8] = cry * crx;
	
	let last_point_x = null;
	let points_x = [];
	
	let x2 = width / 2;
	let y2 = height / 2;
	
	// step surface in normalized space
	let x, y, z;
	// the z loop can be used for volumetric rendering
	//for (z = 0.0; z <= 1.0; z += inc) {
		let vr = [0,0,0];

		//let pz = 2.0 * z - 1.0; // normalize screen space

		//vr[2] = pz * scale;
		for (y = 0.0; y <= 1.0; y += inc) {
			let py = 2.0 * (y - 0.5) - 1.0;

			vr[1] = py * scale;
			let xinc = 0;
			for (x = 0.0; x <= 1.0; x += inc) {
				
				// displacement from heightmap
				let h = heightmap.pixels[(round(x * heightmap.width) + round(y * heightmap.height) * heightmap.width) * 4 + 0] / 255;
				z = 0.5 + h / 4;
				// any parametric surfaces can be built easily here :
				let nn = noise(x*8,y*8);
				 z = 0.5+nn/4;//abs(sin(x * PI+noise(x,y))) * abs(cos(y * PI + PI / 2+noise(x,y)*PI)) / 8 + 0.5;
				let pz = 2.0 * z - 1.0; // normalize screen space

				vr[2] = pz * scale;
				
				let px = (2.0 * x - 1.0);
				
				vr[0] = px * scale;

				// rotate/transform points
				let vrr = [
						rm[0] * vr[0] + rm[3] * vr[1] + rm[6] * vr[2],
						rm[1] * vr[0] + rm[4] * vr[1] + rm[7] * vr[2],
						rm[2] * vr[0] + rm[5] * vr[1] + rm[8] * vr[2]
				];
			
				// compute length & normalize
				let le = sqrt((vrr[0] * vrr[0]) + (vrr[1] * vrr[1]) + (vrr[2] * vrr[2]));
			  let vrn = [ vrr[0] / le, vrr[1] / le, vrr[2] / le ];

				// point shade based on normalized Z value
				let shadez = pow(vrn[2], 2);
			  let shade = [shadez * nn * 255/*texture.pixels[(round(x * texture.width) + round(y * texture.height) * texture.width) * 4 + 0]*/,
											 shadez * nn * 255/** texture.pixels[(round(x * texture.width) + round(y * texture.height) * texture.width) * 4 + 1]*/,
											 shadez * nn * 255/** texture.pixels[(round(x * texture.width) + round(y * texture.height) * texture.width) * 4 + 2]*/];
				
				// since we were in normalized space we scale it to screen space and translate it at the center of the screen
				let posx = x2 - (int)(vrr[0] * width);
				let posy = y2 - (int)(vrr[1] * height);
				
				// micropolygons rendering
				if (points_x[xinc] && points_x[xinc - 1]) {
					let depth = vrn[2] * 255;
					
					fillTriangle(points_x[xinc - 1], points_x[xinc], last_point_x, depth, shade);
					fillTriangle([posx, posy], points_x[xinc], points_x[xinc - 1], depth, shade);
				}
				
/*
				// wireframe
				stroke(shadez * 255);
				strokeWeight(0.25);
				if (points_x[xinc]) {
					line(points_x[xinc][0], points_x[xinc][1], posx, posy);
				}
				if (points_x[xinc + 1]) {
					line(points_x[xinc + 1][0], points_x[xinc + 1][1], posx, posy);
				}
				if (points_x[xinc-1]) {
					line(points_x[xinc-1][0], points_x[xinc-1][1], posx, posy);
				}
*/
				
				if (y > 0) {
					last_point_x = points_x[xinc];
				}
				
				points_x[xinc] = [posx, posy, px, py, pz];
				
				xinc += 1;
			}
		}

	// display z buffer
	//image(depthbuffer, 0, 0);

	frame += 1;
}"
"1052712","REYES rendering","mySketch","/**
  * Similar to my first Reyes sketch except it is this time accurate, non realtime and show texturing, how to generate surfaces and displacement.
	*
	* https://en.wikipedia.org/wiki/Reyes_rendering
	*
	* One can play with the subdivision factor and wireframe to look at how the surface is diced (grid of micropolygons),
	* this allow to add any amount of details to a surface via displacement and great shading.
	*/

let texture = null;
let heightmap = null;
function preload() {
  texture = loadImage('G4XAva5.png');
	heightmap = loadImage('cgxJEfN.png');
}

let frame = 0;

let inc = 0.01; // control surface subdivision, lower = higher quality (but too slow for realtime)
let csi = 1.0 / inc; // how much points our surface will have along a specific axis
let scale = 1.0 / 1.6;

let depthbuffer;

function setup() {
  createCanvas(1024, 768);

  background(0);
	
	noStroke();
	
	depthbuffer = createGraphics(width, height);
	depthbuffer.noStroke();
	
	noStroke();
	
	heightmap.loadPixels();
	texture.loadPixels();
	
	draw2();
}

function fillTriangle(x1, y1, x2, y2, x3, y3, depth) {
	let maxX = max(x1, max(x2, x3));
	let minX = min(x1, min(x2, x3));
	let maxY = max(y1, max(y2, y3));
	let minY = min(y1, min(y2, y3));
	
	let vs1x = x2 - x1;
	let vs1y = y2 - y1;
	let vs2x = x3 - x1;
	let vs2y = y3 - y1;

	for (let x = minX; x <= maxX; x += 1) {
  	for (let y = minY; y <= maxY; y += 1) {
			let qx = x - x1;
			let qy = y - y1;
			
			let s = (qx * vs2y - vs2x * qy) / (vs1x * vs2y - vs2x * vs1y);
			let t = (vs1x * qy - qx * vs1y) / (vs1x * vs2y - vs2x * vs1y);

			if ( (s >= 0) && (t >= 0) && (s + t <= 1)) {
				// check against Z buffer!
				if (depth >= depthbuffer.get(x, y)[0]) {
					// depth value go into depth buffer
					depthbuffer.fill(depth, depth, depth);
					depthbuffer.rect(x, y, 1, 1);

					rect(x, y, 1, 1);
				}
			}
		}
	}
}

function draw2() {
	// clear z-buffer
	depthbuffer.background(0);

	noStroke();
	
  background(0);

	let rxa = 0.03 * frame-PI / 3;
	let rya = 0.04 * frame;

	// rotation values
	let crx = cos(rxa);
	let cry = cos(rya);
	let srx = sin(rxa);
	let sry = sin(rya);
	
	// rm = rotation matrix
	let rm = [0,0,0,0,0,0,0,0,0];

	rm[0] = cry;     /*rm[1] = 0.0f;*/ rm[2] = -sry;
	rm[3] = sry * srx; rm[4] = crx;    rm[5] = cry * srx;
	rm[6] = sry * crx; rm[7] = -srx;   rm[8] = cry * crx;
	
	let last_point_x = null;
	let points_x = [];
	
	let x2 = width / 2;
	let y2 = height / 2;
	
	// step surface in normalized space
	let x, y, z;
	// the z loop can be used for volumetric rendering
	//for (z = 0.0; z <= 1.0; z += inc) {
		let vr = [0,0,0];

		//let pz = 2.0 * z - 1.0; // normalize screen space

		//vr[2] = pz * scale;
		for (y = 0.0; y <= 1.0; y += inc) {
			let py = 2.0 * (y - 0.5) - 1.0;

			vr[1] = py * scale;
			let xinc = 0;
			for (x = 0.0; x <= 1.0; x += inc) {
				
				// displacement from heightmap
				let h = heightmap.pixels[(round(x * heightmap.width) + round(y * heightmap.height) * heightmap.width) * 4 + 0] / 255;
				z = 0.5 + h / 4;
				// any parametric surfaces can be built easily here :
				// z = abs(sin(x * PI)) * abs(cos(y * PI + PI / 2)) / 2 + 0.5;
				let pz = 2.0 * z - 1.0; // normalize screen space

				vr[2] = pz * scale;
				
				let px = (2.0 * x - 1.0);
				
				vr[0] = px * scale;

				// rotate/transform points
				let vrr = [
						rm[0] * vr[0] + rm[3] * vr[1] + rm[6] * vr[2],
						rm[1] * vr[0] + rm[4] * vr[1] + rm[7] * vr[2],
						rm[2] * vr[0] + rm[5] * vr[1] + rm[8] * vr[2]
				];
			
				// compute length & normalize
				let le = sqrt((vrr[0] * vrr[0]) + (vrr[1] * vrr[1]) + (vrr[2] * vrr[2]));
			  let vrn = [ vrr[0] / le, vrr[1] / le, vrr[2] / le ];

				// point shade based on normalized Z value
				let shadez = pow(vrn[2], 2);
			  let shading = [shadez * texture.pixels[(round(x * texture.width) + round(y * texture.height) * texture.width) * 4 + 0],
											 shadez * texture.pixels[(round(x * texture.width) + round(y * texture.height) * texture.width) * 4 + 1],
											 shadez * texture.pixels[(round(x * texture.width) + round(y * texture.height) * texture.width) * 4 + 2]];
				
				// since we were in normalized space we scale it to screen space and translate it at the center of the screen
				let posx = x2 - (int)(vrr[0] * width);
				let posy = y2 - (int)(vrr[1] * height);
				
				// micropolygons rendering
				if (x > 0) {
					if (points_x[xinc] && points_x[xinc - 1]) {
						let depth = vrn[2] * 255;
						fill(shading[0], shading[1], shading[2]);
						fillTriangle(points_x[xinc - 1][0], points_x[xinc - 1][1], points_x[xinc][0], points_x[xinc][1], last_point_x[0], last_point_x[1], depth);
						fillTriangle(posx, posy, points_x[xinc][0], points_x[xinc][1], points_x[xinc - 1][0], points_x[xinc - 1][1], depth);
					}
				}
				
/*
				// wireframe
				stroke(shadez * 255);
				strokeWeight(0.25);
				if (points_x[xinc]) {
					line(points_x[xinc][0], points_x[xinc][1], posx, posy);
				}
				if (points_x[xinc + 1]) {
					line(points_x[xinc + 1][0], points_x[xinc + 1][1], posx, posy);
				}
				if (points_x[xinc-1]) {
					line(points_x[xinc-1][0], points_x[xinc-1][1], posx, posy);
				}
*/
				
				if (y > 0) {
					last_point_x = points_x[xinc];
				}
				
				points_x[xinc] = [posx, posy];
				
				xinc += 1;
			}
		}

	// display z buffer
	//image(depthbuffer, 0, 0);

	frame += 1;
}"
"1052145","Stacking patterns 3","mySketch","// same as parallax checkerboard with static render goal

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseDetail(6, 0.7);
	
	noStroke();
	
	rectMode(CENTER);
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	//background(0);
	noStroke();
	//fill(0, 0, 0, 0.05);
	//rect(0, 0, width, height);
	
	var context = drawingContext
	context.shadowOffsetX = sin(xmotion);
	context.shadowOffsetY = cos(xmotion);
	context.shadowBlur = frameCount % 4 == 0 ? 8 : 1; // more can be fun also
	context.shadowColor = frameCount % 4 == 0 ? color(0, 0, 0, 0.25) : color(0, 0, 255, 0.1);
	
	let planes = 4;

	let sw = 100;
	let sh = 100;
	
	let xp_offset = 0;
	let yp_offset = 0;
	
	let w = width;
	let h = height;
	
	for (let p = 1; p <= planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let ainp = abs(0.5 - np) * 2;
		
		let sf = pow(1, ainp) / 1.5;
		
		push();
		translate(width / 2, height / 2);
		scale(sf + xmotion/148, sf + xmotion/148);
		
		for (let y = 0; y <= h; y += sw) {
			for (let x = 0; x <= w; x += sh) {
				
				if ((x % (sw * 2)) ^ (y % (sh * 2))) { // checkerboard pattern
					let nx = abs(0.5 - x / w) * 2;
					let ny = abs(0.5 - y / h) * 2;
				
					//rotate(sf * 2 + nx * ny);
				
					let no = noise(nx * 0.5, ny * 0.5) * noise(ainp * 2);
					
					let ss = abs(sin((nx * ny) * PI * 2 + inp * PI * 2 + xmotion / 8)) * 3;
					
					stroke(0, 0, 0, sf / 4);
					strokeWeight(0.75);
					fill((50 + no * 360 * ainp) % 360, 255 * sf + ainp * 128, 224 * np, sf / 2.25);
					
					let vw = sw * ss - frameCount/2;
					let vh = sh * ss - frameCount/2;
					
					if (vw > 0 && vh > 0) {
						if (noise(nx * 2, ny * 2) > 0.5) {
							rect(-width / 2 + (x + (cos(xmotion / 16 + ainp)) * 1 * no/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y + (sin(ymotion / 16 + ainp)) * 1 * no /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						} else {
							ellipse(-width / 2 + (x + abs(cos(xmotion / 4 + ainp)) * 1 * no/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y + abs(sin(ymotion / 4 + ainp)) * 1 * no /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						}
					}
				}
			}
		}
		pop();
	}
	
	xmotion += 0.25;
	ymotion += 0.25;
}"
"1050994","Stacking patterns 2","mySketch","// same as parallax checkerboard with static render goal

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseDetail(6, 0.7);
	
	noStroke();
	
	rectMode(CENTER);
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	//background(0);
	noStroke();
	//fill(0, 0, 0, 0.05);
	//rect(0, 0, width, height);
	
	var context = drawingContext
	context.shadowOffsetX = sin(xmotion)/2;
	context.shadowOffsetY = cos(xmotion)/2;
	context.shadowBlur = 1; // more can be fun also
	context.shadowColor = ""black"";
	
	let planes = 3;

	let sw = 100;
	let sh = 100;
	
	let xp_offset = 0;
	let yp_offset = 0;
	
	let w = width;
	let h = height;
	
	for (let p = 1; p <= planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let ainp = abs(0.5 - np) * 2;
		
		let sf = pow(1, ainp) / 3;
		
		push();
		translate(width / 2, height / 2);
		scale(sf + xmotion/148, sf + xmotion/148);
		
		for (let y = 0; y <= h; y += sw) {
			for (let x = 0; x <= w; x += sh) {
				
				if (x <= 0 || x >= w || y <= 0 || y >= h) { // checkerboard pattern
					let nx = abs(0.5 - x / w) * 2;
					let ny = abs(0.5 - y / h) * 2;
				
					//rotate(sf * 2 + nx * ny);
				
					let no = noise(nx * 0.5, ny * 0.5) * noise(ainp * 2)*4;
					
					let ss = abs(sin((nx * ny) * PI * 2 + inp * PI * 2 + xmotion / 8)) * 2;
					
					stroke(0, 0, 0, sf / 2);
					strokeWeight(0.5);
					fill((140 + no * 360 * ainp) % 360, 255 * sf + ainp * 128, 192 * np, sf / 0.05);
					
					let vw = sw * ss - frameCount/2;
					let vh = sh * ss - frameCount/2;
					
					if (vw > 0 && vh > 0) {
						if (noise(nx * 2, ny * 2) > 0.5) {
							rect(-width / 2 + (x + abs(cos(xmotion / 4 + ainp)) * 1 * no/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y + abs(sin(ymotion / 4 + ainp)) * 1 * no /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						} else {
							ellipse(-width / 2 + (x + abs(cos(xmotion / 4 + ainp)) * 1 * no/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y + abs(sin(ymotion / 4 + ainp)) * 1 * no /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						}
					}
				}
			}
		}
		pop();
	}
	
	xmotion += 0.25;
	ymotion += 0.25;
}"
"1050989","Bumpy patterns 4","mySketch","// same as parallax checkerboard with static render goal

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseDetail(6, 0.7);
	
	noStroke();
	
	var context = drawingContext
	context.shadowOffsetX = random(-4, 4);
	context.shadowOffsetY = random(-4, 4);
	context.shadowBlur = 4; // more can be fun also
	context.shadowColor = ""black"";
	
	rectMode(CENTER);
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	//background(0);
	noStroke();
	//fill(0, 0, 0, 0.05);
	//rect(0, 0, width, height);
	
	let planes = 8;

	let sw = 100;
	let sh = 100;
	
	let xp_offset = 0;
	let yp_offset = 0;
	
	let w = width;
	let h = height;
	
	for (let p = 1; p <= planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let ainp = abs(0.5 - np) * 2;
		
		let sf = pow(4, ainp);
		
		push();
		translate(width / 2, height / 2);
		scale(sf - pow(xmotion/128, 4), sf - pow(xmotion/128, 4));
		// slow
		rotate(sf * 2);
		for (let y = 0; y <= h; y += sw) {
			for (let x = 0; x <= w; x += sh) {
				//if ((x % (sw * 2)) ^ (y % (sh * 2))) { // checkerboard pattern
					let nx = abs(0.5 - x / w) * 2;
					let ny = abs(0.5 - y / h) * 2;
					
					let no = noise(nx * 0.5, ny * 0.5) * noise(ainp * 2);
					
					let ss = abs(sin((nx * ny) * PI * 2 + inp * PI * 2 + xmotion / 64)) * 2;
					
					stroke((120 + (1 - np) * 180 * sf + no * 140) % 360, 128 * sf, 192 * np, sf / 0.75);
					strokeWeight(1);
					fill((120 + (1 - np) * 180 * sf + no * 140) % 360, 128 * sf, 192 * np, sf / 4.5);
					
					let vw = sw * ss - frameCount/1;
					let vh = sh * ss - frameCount/1;
					
					if (vw > 0 && vh > 0) {
						if (noise(nx * 2, ny * 2) > 0.5) {
							rect(-width / 2 + (x + noise(nx * 8) * width + abs(cos(ainp * PI * 20 + xmotion / 4 * nx + nx * PI * 2)) * 2 * no/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y + noise(ny * 8) * height+ abs(sin(ainp * PI * 20 + ymotion / 4 * ny + ny * PI * 2)) * 2 * no /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						} else {
							ellipse(-width / 2 + (x + noise(nx * 8) * width + abs(cos(ainp * PI * 20 + xmotion / 4 * nx + nx * PI * 2)) * 2 * no/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y + noise(ny * 8) * height + abs(sin(ainp * PI * 20 + ymotion / 4 * ny + ny * PI * 2)) * 2 * no /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						}
					//}
				}
			}
		}
		pop();
	}
	
	xmotion += 0.25;
	ymotion += 0.25;
}"
"1050987","Bumpy patterns 3","mySketch","// same as parallax checkerboard with static render goal

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseDetail(6, 0.7);
	
	noStroke();
	
	var context = drawingContext
	context.shadowOffsetX = random(-4, 4);
	context.shadowOffsetY = random(-4, 4);
	context.shadowBlur = 1; // more can be fun also
	context.shadowColor = ""black"";
	
	rectMode(CENTER);
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	//background(0);
	noStroke();
	//fill(0, 0, 0, 0.05);
	//rect(0, 0, width, height);
	
	let planes = 4;

	let sw = 100;
	let sh = 100;
	
	let xp_offset = 0;
	let yp_offset = 0;
	
	let w = width;
	let h = height;
	
	for (let p = 1; p <= planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let ainp = abs(0.5 - np) * 2;
		
		let sf = pow(4, ainp);
		
		push();
		translate(width / 2, height / 2);
		scale(sf - pow(xmotion/128, 4), sf - pow(xmotion/128, 4));
		// slow
		rotate(sf * 2);
		for (let y = 0; y <= h; y += sw) {
			for (let x = 0; x <= w; x += sh) {
				//if ((x % (sw * 2)) ^ (y % (sh * 2))) { // checkerboard pattern
					let nx = abs(0.5 - x / w) * 200;
					let ny = abs(0.5 - y / h) * 200;
					
					let no = noise(nx * 0.5, ny * 0.5) * noise(ainp * 2);
					
					let ss = abs(sin((nx * ny) * PI * 2 + inp * PI * 2 + xmotion / 64)) * 2;
					
					stroke((200 + (1 - np) * 180 * sf + no * 140) % 360, 128 * sf, 192 * np, sf / 8.75);
					strokeWeight(1);
					fill((200 + (1 - np) * 180 * sf + no * 140) % 360, 128 * sf, 192 * np, sf / 20.5);
					
					let vw = sw * ss - frameCount/1;
					let vh = sh * ss - frameCount/1;
					
					if (vw > 0 && vh > 0) {
						if (noise(nx * 2, ny * 2) > 0.5) {
							rect(-width / 2 + (x + noise(nx * 8) * 128 + abs(cos(ainp * PI * 2 + xmotion / 4 * nx + nx * PI * 2)) * 2 * no/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y + noise(ny * 8) * 128+ abs(sin(ainp * PI * 2 + ymotion / 4 * ny + ny * PI * 2)) * 2 * no /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						} else {
							ellipse(-width / 2 + (x + noise(nx * 8) * 128 + abs(cos(ainp * PI * 2 + xmotion / 4 * nx + nx * PI * 2)) * 2 * no/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y + noise(ny * 8) * 128 + abs(sin(ainp * PI * 2 + ymotion / 4 * ny + ny * PI * 2)) * 2 * no /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						}
					//}
				}
			}
		}
		pop();
	}
	
	xmotion += 0.25;
	ymotion += 0.25;
}"
"1050984","Bumpy patterns 2","mySketch","// same as parallax checkerboard with static render goal

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseDetail(6, 0.7);
	
	noStroke();
	
	var context = drawingContext
	context.shadowOffsetX = random(-1, 1);
	context.shadowOffsetY = random(-1, 1);
	context.shadowBlur = 1; // more can be fun also
	context.shadowColor = ""white"";
	
	rectMode(CENTER);
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	//background(0);
	noStroke();
	//fill(0, 0, 0, 0.05);
	//rect(0, 0, width, height);
	
	let planes = 4;

	let sw = 100;
	let sh = 100;
	
	let xp_offset = 0;
	let yp_offset = 0;
	
	let w = width;
	let h = height;
	
	noFill();
	
	for (let p = 1; p <= planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let ainp = abs(0.5 - np) * 2;
		
		let sf = pow(1, inp);
		
		push();
		translate(width / 2, height / 2);
		scale(1.5, 1.5);
		//scale(sf - pow(xmotion/128, 4), sf - pow(xmotion/128, 4));
		// slow
		rotate(sf * 200);
		for (let y = 0; y <= h; y += sw) {
			for (let x = 0; x <= w; x += sh) {
				if ((x % (sw * 2)) ^ (y % (sh * 2))) { // checkerboard pattern
					let nx = abs(0.5 - x / w) * 2;
					let ny = abs(0.5 - y / h) * 2;
					
					let no = noise(nx * 4, ny * 4);
					
					let ss = abs(sin((nx * ny) * PI * 8 + inp * PI * 8 + xmotion / 32 * sf)) * 2;
					
					stroke((140 + (1 - np) * 180 * sf + no * 140) % 360, 224 * sf, 128 * np, sf / 4 * ss);
					strokeWeight(1.0);
					//fill(0, 0, 0, sf);
					
					let vw = sw * ss;
					let vh = sh * ss;
					
					if (vw > 0 && vh > 0) {
						if (noise(nx * 8 + xmotion / 8, ny * 8) > 0.5) {
							rect(-width / 2 + (x/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y/* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						} else {
							ellipse(-width / 2 + (x/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						}
					}
				}
			}
		}
		pop();
	}
	
	xmotion += 0.25;
	ymotion += 0.25;
}"
"1050983","Bumpy patterns","mySketch","// same as parallax checkerboard with static render goal

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseDetail(6, 0.7);
	
	noStroke();
	
	var context = drawingContext
	context.shadowOffsetX = random(-4, 4);
	context.shadowOffsetY = random(-4, 4);
	context.shadowBlur = 1; // more can be fun also
	context.shadowColor = ""white"";
	
	rectMode(CENTER);
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	//background(0);
	noStroke();
	//fill(0, 0, 0, 0.05);
	//rect(0, 0, width, height);
	
	let planes = 4;

	let sw = 100;
	let sh = 100;
	
	let xp_offset = 0;
	let yp_offset = 0;
	
	let w = width;
	let h = height;
	
	for (let p = 1; p <= planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let ainp = abs(0.5 - np) * 2;
		
		let sf = pow(4, ainp);
		
		push();
		translate(width / 2, height / 2);
		scale(sf - pow(xmotion/128, 4), sf - pow(xmotion/128, 4));
		// slow
		rotate(sf * 20);
		for (let y = 0; y <= h; y += sw) {
			for (let x = 0; x <= w; x += sh) {
				if ((x % (sw * 2)) ^ (y % (sh * 2))) { // checkerboard pattern
					let nx = abs(0.5 - x / w) * 2;
					let ny = abs(0.5 - y / h) * 2;
					
					let no = noise(nx * 0.5, ny * 0.5) * noise(ainp * 2);
					
					let ss = abs(sin((nx * ny) * PI * 2 + inp * PI * 2 + xmotion / 1)) * 2;
					
					stroke((140 + (1 - np) * 180 * sf + no * 140) % 360, 128 * sf, 192 * np, sf / 0.75);
					strokeWeight(0.25);
					fill(0, 0, 0, sf / 2);
					
					let vw = sw * ss - frameCount/2;
					let vh = sh * ss - frameCount/2;
					
					if (vw > 0 && vh > 0) {
						if (noise(nx * 2, ny * 2) > 0.5) {
							rect(-width / 2 + (x + abs(cos(ainp * PI * 2 + xmotion / 4 * nx + nx * PI * 2)) * 2 * no/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y + abs(sin(ainp * PI * 2 + ymotion / 4 * ny + ny * PI * 2)) * 2 * no /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						} else {
							ellipse(-width / 2 + (x + abs(cos(ainp * PI * 2 + xmotion / 4 * nx + nx * PI * 2)) * 2 * no/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y + abs(sin(ainp * PI * 2 + ymotion / 4 * ny + ny * PI * 2)) * 2 * no /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						}
					}
				}
			}
		}
		pop();
	}
	
	xmotion += 0.25;
	ymotion += 0.25;
}"
"1050895","Stacking patterns","mySketch","// same as parallax checkerboard with static render goal

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseDetail(6, 0.7);
	
	noStroke();
	
	rectMode(CENTER);
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	//background(0);
	noStroke();
	//fill(0, 0, 0, 0.05);
	//rect(0, 0, width, height);
	
	var context = drawingContext
	context.shadowOffsetX = sin(xmotion);
	context.shadowOffsetY = cos(xmotion);
	context.shadowBlur = frameCount % 4 == 0 ? 4 : 1; // more can be fun also
	context.shadowColor = frameCount % 4 == 0 ? color(0, 0, 0, 0.05) : color(0, 0, 255, 0.175);
	
	let planes = 3;

	let sw = 100;
	let sh = 100;
	
	let xp_offset = 0;
	let yp_offset = 0;
	
	let w = width;
	let h = height;
	
	for (let p = 1; p <= planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let ainp = abs(0.5 - np) * 2;
		
		let sf = pow(1, ainp) / 1.5;
		
		push();
		translate(width / 2, height / 2);
		scale(sf + xmotion/148, sf + xmotion/148);
		
		for (let y = 0; y <= h; y += sw) {
			for (let x = 0; x <= w; x += sh) {
				
				if ((x % (sw * 2)) ^ (y % (sh * 2))) { // checkerboard pattern
					let nx = abs(0.5 - x / w) * 2;
					let ny = abs(0.5 - y / h) * 2;
				
					//rotate(sf * 2 + nx * ny);
				
					let no = noise(nx * 0.5, ny * 0.5) * noise(ainp * 2);
					
					let ss = abs(sin((nx * ny) * PI * 2 + inp * PI * 2 + xmotion / 8)) * 1;
					
					stroke(0, 0, 0, sf / 2);
					strokeWeight(0.75);
					fill((140 + no * 360 * ainp) % 360, 255 * sf + ainp * 128, 224 * np, sf / 2.25);
					
					let vw = sw * ss - frameCount/2;
					let vh = sh * ss - frameCount/2;
					
					if (vw > 0 && vh > 0) {
						if (noise(nx * 2, ny * 2) > 0.5) {
							rect(-width / 2 + (x + (cos(xmotion / 16 + ainp)) * 1 * no/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y + (sin(ymotion / 16 + ainp)) * 1 * no /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						} else {
							ellipse(-width / 2 + (x + abs(cos(xmotion / 4 + ainp)) * 1 * no/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y + abs(sin(ymotion / 4 + ainp)) * 1 * no /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						}
					}
				}
			}
		}
		pop();
	}
	
	xmotion += 0.25;
	ymotion += 0.25;
}"
"1050888","Stacking patterns","mySketch","// same as parallax checkerboard with static render goal

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseDetail(6, 0.7);
	
	noStroke();
	
	var context = drawingContext
	context.shadowOffsetX = random(-4, 4);
	context.shadowOffsetY = random(-4, 4);
	context.shadowBlur = 1; // more can be fun also
	context.shadowColor = ""white"";
	
	rectMode(CENTER);
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	//background(0);
	noStroke();
	//fill(0, 0, 0, 0.05);
	//rect(0, 0, width, height);
	
	let planes = 4;

	let sw = 200;
	let sh = 200;
	
	let xp_offset = 0;
	let yp_offset = 0;
	
	let w = width;
	let h = height;
	
	for (let p = 1; p <= planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let ainp = abs(0.5 - np) * 2;
		
		let sf = pow(1, ainp);
		
		push();
		translate(width / 2, height / 2);
		scale(sf - xmotion/128, sf - xmotion/128);
		// slow
		rotate(sf * 2);
		for (let y = 0; y <= h; y += sw) {
			for (let x = 0; x <= w; x += sh) {
				//if ((x % (sw * 2)) ^ (y % (sh * 2))) { // checkerboard pattern
					let nx = abs(0.5 - x / w) * 2;
					let ny = abs(0.5 - y / h) * 2;
					
					let no = noise(nx * 0.5, ny * 0.5) * noise(ainp * 2);
					
					let ss = abs(sin((nx * ny) * PI * 2 + inp * PI * 2 + xmotion / 8)) * 1;
					
					stroke((140 + (1 - np) * 180 * sf + no * 140) % 360, 128 * sf, 192 * np, sf / 0.75);
					strokeWeight(0.75);
					fill(0, 0, 0, sf / 2);
					
					let vw = sw * ss - frameCount/2;
					let vh = sh * ss - frameCount/2;
					
					if (vw > 0 && vh > 0) {
						if (noise(nx * 2, ny * 2) > 0.5) {
							rect(-width / 2 + (x + abs(cos(ainp * PI * 2 + xmotion / 4 * nx + nx * PI * 2)) * 2 * no/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y + abs(sin(ainp * PI * 2 + ymotion / 4 * ny + ny * PI * 2)) * 2 * no /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						} else {
							ellipse(-width / 2 + (x + abs(cos(ainp * PI * 2 + xmotion / 4 * nx + nx * PI * 2)) * 2 * no/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y + abs(sin(ainp * PI * 2 + ymotion / 4 * ny + ny * PI * 2)) * 2 * no /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						}
					}
				//}
			}
		}
		pop();
	}
	
	xmotion += 0.25;
	ymotion += 0.25;
}"
"1050882","Pattern","mySketch","// same as parallax checkerboard with static render goal

function setup() {
	createCanvas(800, 800);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseDetail(6, 0.7);
	
	noStroke();
	
	var context = drawingContext
	context.shadowOffsetX = random(-4, 4);
	context.shadowOffsetY = random(-4, 4);
	context.shadowBlur = 4; // more can be fun also
	context.shadowColor = ""white"";
	
	rectMode(CENTER);
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	//background(0);
	noStroke();
	//fill(0, 0, 0, 0.05);
	//rect(0, 0, width, height);
	
	let planes = 3;

	let sw = 80;
	let sh = 80;
	
	let xp_offset = 0;
	let yp_offset = 0;
	
	let w = width;
	let h = height;
	
	for (let p = 1; p <= planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let ainp = abs(0.5 - np) * 8;
		
		let sf = pow(1, inp) * 2 * ainp;
		
		push();
		translate(width / 2, height / 2);
		scale(sf, sf);
		// slow
		//rotate(sf * 2);
		for (let y = 0; y <= h; y += sw) {
			for (let x = 0; x <= w; x += sh) {
				//if ((x % (sw * 2)) ^ (y % (sh * 2))) { // checkerboard pattern
					let nx = abs(0.5 - x / w) * 2;
					let ny = abs(0.5 - y / h) * 2;
					
					let no = noise(nx * 0.5, ny * 0.5) * noise(ainp * 2);
					
					let ss = abs(sin((nx * ny) * PI * 2 + inp * PI * 2 + xmotion / 8)) * 2;
					
					stroke((140 + (1 - np) * 180 * sf + no * 140) % 360, 128 * sf, 192 * np, sf / 0.75);
					strokeWeight(0.75);
					fill(0, 0, 0, sf / 2);
					
					let vw = sw * ss - frameCount/2;
					let vh = sh * ss - frameCount/2;
					
					if (vw > 0 && vh > 0) {
						if (noise(nx * 8, ny * 8) > 0.6) {
							rect(-width / 2 + (x + abs(cos(ainp * PI * 2 + xmotion / 4 * nx + nx * PI * 2)) * 1 * no/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y + abs(sin(ainp * PI * 2 + ymotion / 4 * ny + ny * PI * 2)) * 1 * no /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						} else {
							ellipse(-width / 2 + (x + abs(cos(ainp * PI * 2 + xmotion / 4 * nx + nx * PI * 2)) * 1 * no/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
											-height / 2 + (y + abs(sin(ainp * PI * 2 + ymotion / 4 * ny + ny * PI * 2)) * 1 * no /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
											vw,
											vh);
						}
					}
				//}
			}
		}
		pop();
	}
	
	xmotion += 0.25;
	ymotion += 0.25;
}"
"1050829","My Sketch","mySketch","function setup() {
	createCanvas(windowWidth, windowHeight);
	background(100);
}

function draw() {
	ellipse(mouseX, mouseY, 20, 20);
}"
"1050829","My Sketch","mySketch","let img;
let snap;

function preload() {
  img = loadImage('512_texture.jpg');
}

function setup() {
  createCanvas(800, 800, WEBGL);
}

function draw() {
  background(220);
  
	const v1 = { x: -1, y: -1, z: -1 };
	const v2 = { x:  1, y: -1, z: 1 };
	const v3 = { x:  1, y:  1, z: 1 };
	const v4 = { x: -1, y:  1, z: -1 };
	
	let w2 = width/2;
	let h2 = height / 2;
  noStroke();
  texture(img);
  push();
  translate(-width/2,-height / 2,0);
  quad(w2+v1.x * w2, 
			 h2+v1.y * h2, 
			 w2+v2.x * w2, 
			 h2+v2.y * h2,
			 w2+v3.x * w2, 
			 h2+v3.y * h2,
			 w2+v4.x * w2, 
			 h2+v4.y * h2);
  pop();
}"
"1050731","Pipe divisions 6","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 6;

function setup() {
  createCanvas(800, 800);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (2.0 + abs(sin(x / width * PI * 0.25 + cos(y / height * PI * 0.025 + pow(x/ width, 1) * PI * 0.25)))), y: (width / (1) + x - y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.0 + x) / 1 + j * (20), y: (height / 4 - y * 2 / j + (x / (1.0 * (1 + y / height)))) / 1.0 + j * (80) };
}

function f3(x, y, j) {
	return { x: (width * 0.5 - x * j) / (16 * (j / 14) + x / (width / (10))), y: y / 6 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (3.25) - x + y / (1.95 * j * ((0.5 - y / width) * 10))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 10, y: (height / 2 - y * 1.15 / j + (x / 10.075)) / 1.75 + j * (50) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (4.0 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 5000) {
		for (let i = 0; i < 10000; i += 1) {
			for (let j = 5; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let ny1 = x[j] / width*2-1;
				let nx1 = y[j] / height;
				let inx1 =((0.05)+pow(abs(2.0-nx1)/8, 1));
				let nx11 = y[j] / width*2-1;//abs(0.5-y[j] / height)*2;
				let inx3 =((0.15)+pow((0.5-nx11)/2, 4));
				let nx2 = y2[j] / height;
				let inx2 = 0.45+pow(nx2, 0.5);
				
				let e = 0.75;

				if (iter > 20) {
					stroke((xmotion*64+iter*64)%360, 128, 255, 0.0125 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);
					//point(width - x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					//point(x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					
					//point(x2[j] * inx2+5, height / 1 - y2[j]/2.5);
					//point(width - x2[j] * inx2-5, height / 1 - y2[j]/2.5);
					//point(x[j] / 4.0 * inx3 - width / 4 * sin(nx1*PI*0.5), y[j]/2);
					//point(width - (width - x[j] / 4.0 * inx3 - width / 4 * sin(nx1*PI*0.5)), y[j]/2);
					//point(width / 1.95 - x[j] / 4.0 * inx3 - width / 4 * sin(nx1*PI*0.5), height - y[j]/2);
					//point(width - (width / 1.95 - x[j] / 4.0 * inx3 - width / 4 * sin(nx1*PI*0.5)), height - y[j]/2);

					point(width / 1.35 + x[j] / 2.5, y[j]/1.5);
					point(width - (width / 1.35 + x[j] / 2.5), y[j]/1.5);
					point(width / 2 + x[j] / 2.5, height / 2 + height - (height / 2 + y[j]/1.0));
					point(width - (width /2+ x[j] / 2.5), height / 2 + height - (height / 2 + y[j]/1.0));
					//point(width / 2.75 + x[j] / 4, y[j]/3);
					//point(width - (width / 2.75 + x[j] / 4), height - y[j]/3);
					//point(width / 2 + x[j] / 2.0 * inx1 + width / 12.0 * abs(cos(ny1*PI*1.5 * pow(sin(nx1 * PI *0.15), 4))), (height - y[j]/2));
					//point(width / 2 - (x[j] / 2.0 * inx1 + width / 12.0 * abs(cos(ny1*PI*1.5 * pow(sin(nx1 * PI *0.15), 4)))), (height - y[j]/2));
					point(width - (x[j] / 1.0 * inx1 + width / 8.0 * abs(cos(ny1*PI*0.5 * pow(sin(nx1 * PI *0.15), 4)))), (y[j]/3));
					point((x[j] / 1.0 * inx1 + width / 8.0 * abs(cos(ny1*PI*0.5 * pow(sin(nx1 * PI *0.15), 4)))), (y[j]/3));
					point(width - (x[j] / 1.0 * inx1 + width / 16.0 * abs(cos(ny1*PI*4.5 * pow(sin(nx1 * PI *0.15), 4)))), (height - y[j]/4));
					point((x[j] / 1.0 * inx1 + width / 16.0 * abs(cos(ny1*PI*4.5 * pow(sin(nx1 * PI *0.15), 4)))), (height - y[j]/4));
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	} else {
		iter = 0;
		xmotion += 0.01;
	}

	//xmotion += 1;
	ymotion += 0.25;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"1050729","Pipe divisions 5","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 6;

function setup() {
  createCanvas(800, 800);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (2.0 + abs(sin(x / width * PI * 0.25 + cos(y / height * PI * 0.025 + pow(x/ width, 1) * PI * 0.25)))), y: (width / (1) + x - y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.0 + x) / 1 + j * (20), y: (height / 4 - y * 2 / j + (x / (1.0 * (1 + y / height)))) / 1.0 + j * (80) };
}

function f3(x, y, j) {
	return { x: (width * 0.5 - x * j) / (16 * (j / 14) + x / (width / (10))), y: y / 6 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (3.25) - x + y / (1.95 * j * ((0.5 - y / width) * 10))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 10, y: (height / 2 - y * 1.15 / j + (x / 10.075)) / 1.75 + j * (50) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (4.0 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 5000) {
		for (let i = 0; i < 10000; i += 1) {
			for (let j = 5; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let ny1 = x[j] / width*2-1;
				let nx1 = y[j] / height;
				let inx1 =((0.05)+pow(abs(2.0-nx1)/8, 1));
				let nx11 = y[j] / width*2-1;//abs(0.5-y[j] / height)*2;
				let inx3 =((0.15)+pow((0.5-nx11)/2, 4));
				let nx2 = y2[j] / height;
				let inx2 = 0.45+pow(nx2, 0.5);
				
				let e = 0.75;

				if (iter > 20) {
					stroke((xmotion*64+iter*64)%360, 128, 255, 0.0125 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);
					//point(width - x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					//point(x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					
					//point(x2[j] * inx2+5, height / 1 - y2[j]/2.5);
					//point(width - x2[j] * inx2-5, height / 1 - y2[j]/2.5);
					//point(x[j] / 4.0 * inx3 - width / 4 * sin(nx1*PI*0.5), y[j]/2);
					//point(width - (width - x[j] / 4.0 * inx3 - width / 4 * sin(nx1*PI*0.5)), y[j]/2);
					//point(width / 1.95 - x[j] / 4.0 * inx3 - width / 4 * sin(nx1*PI*0.5), height - y[j]/2);
					//point(width - (width / 1.95 - x[j] / 4.0 * inx3 - width / 4 * sin(nx1*PI*0.5)), height - y[j]/2);

					point(width / 1.35 + x[j] / 2.5, y[j]/2.5);
					point(width - (width / 1.35 + x[j] / 2.5), y[j]/2.5);
					point(width / 2.75 + x[j] / 3, y[j]/1);
					point(width - (width / 2.75 + x[j] / 3), y[j]/1);
					//point(width / 2 + x[j] / 2.0 * inx1 + width / 12.0 * abs(cos(ny1*PI*1.5 * pow(sin(nx1 * PI *0.15), 4))), (height - y[j]/2));
					//point(width / 2 - (x[j] / 2.0 * inx1 + width / 12.0 * abs(cos(ny1*PI*1.5 * pow(sin(nx1 * PI *0.15), 4)))), (height - y[j]/2));
					point(width - (x[j] / 1.0 * inx1 + width / 8.0 * abs(cos(ny1*PI*0.5 * pow(sin(nx1 * PI *0.15), 4)))), (y[j]/3));
					point((x[j] / 1.0 * inx1 + width / 8.0 * abs(cos(ny1*PI*0.5 * pow(sin(nx1 * PI *0.15), 4)))), (y[j]/3));
					point(width - (x[j] / 1.0 * inx1 + width / 16.0 * abs(cos(ny1*PI*4.5 * pow(sin(nx1 * PI *0.15), 4)))), (height - y[j]/4));
					point((x[j] / 1.0 * inx1 + width / 16.0 * abs(cos(ny1*PI*4.5 * pow(sin(nx1 * PI *0.15), 4)))), (height - y[j]/4));
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	} else {
		iter = 0;
		xmotion += 0.01;
	}

	//xmotion += 1;
	ymotion += 0.25;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"1050722","Pipe divisions 4","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 6;

function setup() {
  createCanvas(800, 800);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (2.0 + abs(sin(x / width * PI * 0.25 + cos(y / height * PI * 0.25 + pow(x/ width, 1) * PI * 0.25)))), y: (width / (1.0) + x - y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.25 + x) / 1 + j * (20), y: (height / 4 - y * 2 / j + (x / 1.0)) / 1.0 + j * (80) };
}

function f3(x, y, j) {
	return { x: (width * 0.5 - x * j) / (16 * (j / 14) + x / (width / (10))), y: y / 6 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (3.25) - x + y / (1.95 * j * ((0.5 - y / width) * 10))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 10, y: (height / 2 - y * 1.15 / j + (x / 10.075)) / 1.75 + j * (50) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (4.0 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 5000) {
		for (let i = 0; i < 10000; i += 1) {
			for (let j = 5; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let ny1 = x[j] / width*2-1;
				let nx1 = y[j] / height;
				let inx1 =((0.05)+pow(abs(2.0-nx1)/8, 1));
				let nx11 = y[j] / width*2-1;//abs(0.5-y[j] / height)*2;
				let inx3 =((0.15)+pow((0.5-nx11)/2, 4));
				let nx2 = y2[j] / height;
				let inx2 = 0.45+pow(nx2, 0.5);
				
				let e = 0.75;

				if (iter > 20) {
					stroke((xmotion*64+iter*64)%360, 128, 255, 0.0125 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);
					//point(width - x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					//point(x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					
					//point(x2[j] * inx2+5, height / 1 - y2[j]/2.5);
					//point(width - x2[j] * inx2-5, height / 1 - y2[j]/2.5);
					//point(x[j] / 4.0 * inx3 - width / 4 * sin(nx1*PI*0.5), y[j]/2);
					//point(width - (width - x[j] / 4.0 * inx3 - width / 4 * sin(nx1*PI*0.5)), y[j]/2);
					//point(width / 1.95 - x[j] / 4.0 * inx3 - width / 4 * sin(nx1*PI*0.5), height - y[j]/2);
					//point(width - (width / 1.95 - x[j] / 4.0 * inx3 - width / 4 * sin(nx1*PI*0.5)), height - y[j]/2);

					point(width / 1.75 + x[j] / 3, y[j]/1.5);
					point(width - (width / 1.75 + x[j] / 3), y[j]/1.5);
					point(width / 2.05 + x[j] / 3, y[j]/4);
					point(width - (width / 2.05 + x[j] / 3), y[j]/4);
					//point(width / 2 + x[j] / 2.0 * inx1 + width / 12.0 * abs(cos(ny1*PI*1.5 * pow(sin(nx1 * PI *0.15), 4))), (height - y[j]/2));
					//point(width / 2 - (x[j] / 2.0 * inx1 + width / 12.0 * abs(cos(ny1*PI*1.5 * pow(sin(nx1 * PI *0.15), 4)))), (height - y[j]/2));
					point(width - (x[j] / 1.0 * inx1 + width / 12.0 * abs(cos(ny1*PI*2.5 * pow(sin(nx1 * PI *0.15), 4)))), (height - y[j]/4));
					point((x[j] / 1.0 * inx1 + width / 12.0 * abs(cos(ny1*PI*2.5 * pow(sin(nx1 * PI *0.15), 4)))), (height - y[j]/4));
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	} else {
		iter = 0;
		xmotion += 0.01;
	}

	//xmotion += 1;
	ymotion += 0.25;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"1050719","Pipe divisions 3","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 6;

function setup() {
  createCanvas(800, 800);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (2.0 + abs(sin(x / width * PI * 0.25 + cos(y / height * PI * 0.25 + pow(x/ width, 1) * PI * 0.25)))), y: (width / (1.0) + x - y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.25 + x) / 1 + j * (20), y: (height / 4 - y * 2 / j + (x / 1.0)) / 1.0 + j * (80) };
}

function f3(x, y, j) {
	return { x: (width * 0.5 - x * j) / (16 * (j / 14) + x / (width / (10))), y: y / 6 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (3.25) - x + y / (1.95 * j * ((0.5 - y / width) * 10))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 10, y: (height / 2 - y * 1.15 / j + (x / 10.075)) / 1.75 + j * (50) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (4.0 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 5000) {
		for (let i = 0; i < 10000; i += 1) {
			for (let j = 5; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let ny1 = x[j] / width*2-1;
				let nx1 = y[j] / height;
				let inx1 =((0.05)+pow(abs(2.0-nx1)/8, 1));
				let nx11 = y[j] / width*2-1;//abs(0.5-y[j] / height)*2;
				let inx3 =((0.15)+pow((0.5-nx11)/2, 4));
				let nx2 = y2[j] / height;
				let inx2 = 0.45+pow(nx2, 0.5);
				
				let e = 0.75;

				if (iter > 20) {
					stroke((xmotion*64+iter*64)%360, 128, 255, 0.0125 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);
					//point(width - x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					//point(x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					
					//point(x2[j] * inx2+5, height / 1 - y2[j]/2.5);
					//point(width - x2[j] * inx2-5, height / 1 - y2[j]/2.5);
					//point(x[j] / 4.0 * inx3 - width / 4 * sin(nx1*PI*0.5), y[j]/2);
					//point(width - (width - x[j] / 4.0 * inx3 - width / 4 * sin(nx1*PI*0.5)), y[j]/2);
					//point(width / 1.95 - x[j] / 4.0 * inx3 - width / 4 * sin(nx1*PI*0.5), height - y[j]/2);
					//point(width - (width / 1.95 - x[j] / 4.0 * inx3 - width / 4 * sin(nx1*PI*0.5)), height - y[j]/2);

					point(width / 1.5 + x[j] / 3, y[j]/1.5);
					point(width - (width / 1.5 + x[j] / 3), y[j]/1.5);
					point(width / 2.05 + x[j] / 2, y[j]/2);
					point(width - (width / 2.05 + x[j] / 2), y[j]/2);
					//point(width / 2 + x[j] / 2.0 * inx1 + width / 12.0 * abs(cos(ny1*PI*1.5 * pow(sin(nx1 * PI *0.15), 4))), (height - y[j]/2));
					//point(width / 2 - (x[j] / 2.0 * inx1 + width / 12.0 * abs(cos(ny1*PI*1.5 * pow(sin(nx1 * PI *0.15), 4)))), (height - y[j]/2));
					point(width - (x[j] / 1.0 * inx1 + width / 12.0 * abs(cos(ny1*PI*1.5 * pow(sin(nx1 * PI *0.15), 4)))), (height - y[j]/4));
					point((x[j] / 1.0 * inx1 + width / 12.0 * abs(cos(ny1*PI*1.5 * pow(sin(nx1 * PI *0.15), 4)))), (height - y[j]/4));
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	} else {
		iter = 0;
		xmotion += 0.01;
	}

	//xmotion += 1;
	ymotion += 0.25;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"1050714","Pipe divisions²","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 6;

function setup() {
  createCanvas(800, 800);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (1.5 + abs(sin(x / width * PI * 1.25 + cos(y / height * PI * 1.25 + pow(x/ width, 1) * PI * 0.25)))), y: (width / (1.0) + x - y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.25 + x) / 1 + j * (20), y: (height / 4 - y * 2 / j + (x / 4.0)) / 1.0 + j * (80) };
}

function f3(x, y, j) {
	return { x: (width * 0.5 - x * j) / (16 * (j / 14) + x / (width / (10))), y: y / 8 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (3.25) - x + y / (1.95 * j * ((0.5 - y / width) * 10))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 10, y: (height / 2 - y * 1.15 / j + (x / 10.075)) / 1.75 + j * (50) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (4.0 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 5000) {
		for (let i = 0; i < 10000; i += 1) {
			for (let j = 5; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let ny1 = x[j] / width*2-1;
				let nx1 = y[j] / height;
				let inx1 =((0.05)+pow(abs(2.0-nx1)/8, 1));
				let nx11 = y[j] / width*2-1;//abs(0.5-y[j] / height)*2;
				let inx3 =((0.15)+pow((0.5-nx11)/2, 4));
				let nx2 = y2[j] / height;
				let inx2 = 0.45+pow(nx2, 0.5);
				
				let e = 0.75;

				if (iter > 20) {
					stroke((xmotion*64+iter*64)%360, 128, 255, 0.0125 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);
					//point(width - x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					//point(x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					
					//point(x2[j] * inx2+5, height / 1 - y2[j]/2.5);
					//point(width - x2[j] * inx2-5, height / 1 - y2[j]/2.5);
					//point(x[j] / 4.0 * inx3 - width / 4 * sin(nx1*PI*0.5), y[j]/2);
					//point(width - (width - x[j] / 4.0 * inx3 - width / 4 * sin(nx1*PI*0.5)), y[j]/2);
					//point(width / 1.95 - x[j] / 4.0 * inx3 - width / 4 * sin(nx1*PI*0.5), height - y[j]/2);
					//point(width - (width / 1.95 - x[j] / 4.0 * inx3 - width / 4 * sin(nx1*PI*0.5)), height - y[j]/2);

					point(width / 2 - x[j] / 3, height - y[j]/1.5);
					point(width / 2 + x[j] / 3, height - y[j]/1.5);
					point(width / 2 + x[j] / 1.0 * inx1 + width / 12.0 * abs(cos(ny1*PI*1.5 * pow(sin(nx1 * PI *0.15), 4))), (height - y[j]/2));
					point(width / 2 - (x[j] / 1.0 * inx1 + width / 12.0 * abs(cos(ny1*PI*1.5 * pow(sin(nx1 * PI *0.15), 4)))), (height - y[j]/2));
					point(width - (x[j] / 1.0 * inx1 + width / 12.0 * abs(cos(ny1*PI*1.5 * pow(sin(nx1 * PI *0.15), 4)))), (height - y[j]/4));
					point((x[j] / 1.0 * inx1 + width / 12.0 * abs(cos(ny1*PI*1.5 * pow(sin(nx1 * PI *0.15), 4)))), (height - y[j]/4));
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	} else {
		iter = 0;
		xmotion += 0.01;
	}

	//xmotion += 1;
	ymotion += 0.25;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"1050712","Pipe divisions","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 6;

function setup() {
  createCanvas(800, 800);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (1.5 + abs(sin(x / width * PI * 0.25 + cos(y / height * PI * 0.25 + pow(x/ width, 1) * PI * 0.25)))), y: (width / (1.0) + x - y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.25 + x) / 1 + j * (20), y: (height / 4 - y * 2 / j + (x / 4.0)) / 1.0 + j * (80) };
}

function f3(x, y, j) {
	return { x: (width * 0.5 - x * j) / (16 * (j / 14) + x / (width / (10))), y: y / 8 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (3.25) - x + y / (1.95 * j * ((0.5 - y / width) * 10))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 10, y: (height / 2 - y * 1.15 / j + (x / 10.075)) / 1.75 + j * (50) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (4.0 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 5000) {
		for (let i = 0; i < 10000; i += 1) {
			for (let j = 5; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let ny1 = x[j] / width*2-1;
				let nx1 = y[j] / height;
				let inx1 =((0.05)+pow(abs(2.0-nx1)/8, 2));
				let nx11 = y[j] / width*2-1;//abs(0.5-y[j] / height)*2;
				let inx3 =((0.15)+pow((0.5-nx11)/2, 4));
				let nx2 = y2[j] / height;
				let inx2 = 0.45+pow(nx2, 0.5);
				
				let e = 0.75;

				if (iter > 20) {
					stroke((xmotion*64+iter*64)%360, 128, 255, 0.0125 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);
					//point(width - x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					//point(x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					
					//point(x2[j] * inx2+5, height / 1 - y2[j]/2.5);
					//point(width - x2[j] * inx2-5, height / 1 - y2[j]/2.5);
					//point(x[j] / 4.0 * inx3 - width / 4 * sin(nx1*PI*0.5), y[j]/2);
					//point(width - (width - x[j] / 4.0 * inx3 - width / 4 * sin(nx1*PI*0.5)), y[j]/2);
					//point(width / 1.95 - x[j] / 4.0 * inx3 - width / 4 * sin(nx1*PI*0.5), height - y[j]/2);
					//point(width - (width / 1.95 - x[j] / 4.0 * inx3 - width / 4 * sin(nx1*PI*0.5)), height - y[j]/2);

					point(width / 2 - x[j] / 3, height - y[j]/1.5);
					point(width / 2 + x[j] / 3, height - y[j]/1.5);
					point(width / 2 + x[j] / 1.0 * inx1 + width / 12.0 * abs(cos(ny1*PI*1.5 * pow(sin(nx1 * PI *0.15), 4))), (height - y[j]/2));
					point(width / 2 - (x[j] / 1.0 * inx1 + width / 12.0 * abs(cos(ny1*PI*1.5 * pow(sin(nx1 * PI *0.15), 4)))), (height - y[j]/2));
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	} else {
		iter = 0;
		xmotion += 0.01;
	}

	//xmotion += 1;
	ymotion += 0.25;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"1050712","Pipe divisions","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 6;

function setup() {
  createCanvas(800, 800);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (1.5 + abs(sin(x / width * PI * 0.25 + cos(y / height * PI * 0.25 + pow(x/ width, 1) * PI * 0.25)))), y: (width / (1.0) + x - y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.25 + x) / 1 + j * (20), y: (height / 4 - y * 2 / j + (x / 4.0)) / 1.0 + j * (80) };
}

function f3(x, y, j) {
	return { x: (width * 0.5 - x * j) / (16 * (j / 14) + x / (width / (10))), y: y / 8 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (3.25) - x + y / (1.95 * j * ((0.5 - y / width) * 10))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 10, y: (height / 2 - y * 1.15 / j + (x / 10.075)) / 1.75 + j * (50) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (4.0 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 5000) {
		for (let i = 0; i < 10000; i += 1) {
			for (let j = 5; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let ny1 = x[j] / width*2-1;
				let nx1 = y[j] / height;
				let inx1 =((0.05)+pow(abs(2.0-nx1)/8, 1));
				let nx11 = y[j] / width*2-1;//abs(0.5-y[j] / height)*2;
				let inx3 =((0.15)+pow((0.5-nx11)/2, 4));
				let nx2 = y2[j] / height;
				let inx2 = 0.45+pow(nx2, 0.5);
				
				let e = 0.75;

				if (iter > 20) {
					stroke((xmotion*64+iter*64)%360, 128, 255, 0.0125 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);
					//point(width - x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					//point(x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					
					//point(x2[j] * inx2+5, height / 1 - y2[j]/2.5);
					//point(width - x2[j] * inx2-5, height / 1 - y2[j]/2.5);
					//point(x[j] / 4.0 * inx3 - width / 4 * sin(nx1*PI*0.5), y[j]/2);
					//point(width - (width - x[j] / 4.0 * inx3 - width / 4 * sin(nx1*PI*0.5)), y[j]/2);
					//point(width / 1.95 - x[j] / 4.0 * inx3 - width / 4 * sin(nx1*PI*0.5), height - y[j]/2);
					//point(width - (width / 1.95 - x[j] / 4.0 * inx3 - width / 4 * sin(nx1*PI*0.5)), height - y[j]/2);

					point(width / 2 - x[j] / 3, height - y[j]/1.5);
					point(width / 2 + x[j] / 3, height - y[j]/1.5);
					point(width / 2 + x[j] / 1.0 * inx1 + width / 12.0 * abs(cos(ny1*PI*1.5 * pow(sin(nx1 * PI *0.15), 4))), (height - y[j]/2));
					point(width / 2 - (x[j] / 1.0 * inx1 + width / 12.0 * abs(cos(ny1*PI*1.5 * pow(sin(nx1 * PI *0.15), 4)))), (height - y[j]/2));
					point(width - (x[j] / 1.0 * inx1 + width / 12.0 * abs(cos(ny1*PI*1.5 * pow(sin(nx1 * PI *0.15), 4)))), (height - y[j]/4));
					point((x[j] / 1.0 * inx1 + width / 12.0 * abs(cos(ny1*PI*1.5 * pow(sin(nx1 * PI *0.15), 4)))), (height - y[j]/4));
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	} else {
		iter = 0;
		xmotion += 0.01;
	}

	//xmotion += 1;
	ymotion += 0.25;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"1050712","Pipe divisions","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 6;

function setup() {
  createCanvas(800, 800);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (1.5 + abs(sin(x / width * PI * 0.25 + cos(y / height * PI * 0.25 + pow(x/ width, 1) * PI * 0.25)))), y: (width / (1.0) + x - y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.25 + x) / 1 + j * (20), y: (height / 4 - y * 2 / j + (x / 4.0)) / 1.0 + j * (80) };
}

function f3(x, y, j) {
	return { x: (width * 0.5 - x * j) / (16 * (j / 14) + x / (width / (10))), y: y / 8 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (3.25) - x + y / (1.95 * j * ((0.5 - y / width) * 10))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 10, y: (height / 2 - y * 1.15 / j + (x / 10.075)) / 1.75 + j * (50) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (4.0 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 5000) {
		for (let i = 0; i < 10000; i += 1) {
			for (let j = 5; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let ny1 = x[j] / width*2-1;
				let nx1 = y[j] / height;
				let inx1 =((0.05)+pow(abs(2.0-nx1)/8, 1));
				let nx11 = y[j] / width*2-1;//abs(0.5-y[j] / height)*2;
				let inx3 =((0.15)+pow((0.5-nx11)/2, 4));
				let nx2 = y2[j] / height;
				let inx2 = 0.45+pow(nx2, 0.5);
				
				let e = 0.75;

				if (iter > 20) {
					stroke((xmotion*64+iter*64)%360, 128, 255, 0.0125 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);
					//point(width - x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					//point(x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					
					//point(x2[j] * inx2+5, height / 1 - y2[j]/2.5);
					//point(width - x2[j] * inx2-5, height / 1 - y2[j]/2.5);
					//point(x[j] / 4.0 * inx3 - width / 4 * sin(nx1*PI*0.5), y[j]/2);
					//point(width - (width - x[j] / 4.0 * inx3 - width / 4 * sin(nx1*PI*0.5)), y[j]/2);
					//point(width / 1.95 - x[j] / 4.0 * inx3 - width / 4 * sin(nx1*PI*0.5), height - y[j]/2);
					//point(width - (width / 1.95 - x[j] / 4.0 * inx3 - width / 4 * sin(nx1*PI*0.5)), height - y[j]/2);

					point(width / 2 - x[j] / 3, height - y[j]/1.5);
					point(width / 2 + x[j] / 3, height - y[j]/1.5);
					point(width / 2 + x[j] / 1.0 * inx1 + width / 12.0 * abs(cos(ny1*PI*1.5 * pow(sin(nx1 * PI *0.15), 4))), (height - y[j]/2));
					point(width / 2 - (x[j] / 1.0 * inx1 + width / 12.0 * abs(cos(ny1*PI*1.5 * pow(sin(nx1 * PI *0.15), 4)))), (height - y[j]/2));
					point(width - (x[j] / 1.0 * inx1 + width / 12.0 * abs(cos(ny1*PI*1.5 * pow(sin(nx1 * PI *0.15), 4)))), (height - y[j]/4));
					point((x[j] / 1.0 * inx1 + width / 12.0 * abs(cos(ny1*PI*1.5 * pow(sin(nx1 * PI *0.15), 4)))), (height - y[j]/4));
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	} else {
		iter = 0;
		xmotion += 0.01;
	}

	//xmotion += 1;
	ymotion += 0.25;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"1050568","Quads rasterizer","mySketch","function setup() {
	createCanvas(800, 800);
	background(0);
}

function draw() {
	ellipse(mouseX, mouseY, 20, 20);
}"
"1050568","Quads rasterizer","mySketch","let img;
function preload() {
  img = loadImage('test.jpg');
}

function setup() {
	createCanvas(600, 600);
	
	img.loadPixels();
}

function stretch(x1, y1, x2, y2, yr, yw) {
	let dx = abs(x2 - x1);
	let dy = abs(y2 - y1);
	let sx = Math.sign(x2 - x1);
	let sy = Math.sign(y2 - y1);
	let e = 2 * dy - dx;
	let dx2 = 2 * dx;
	let dy2 = 2 * dy;
	for (let i = 0; i <= dx; i += 1) {
		let cr = img.pixels[(y1 + yr * img.width) * 4 + 0];
		let cg = img.pixels[(y1 + yr * img.width) * 4 + 1];
		let cb = img.pixels[(y1 + yr * img.width) * 4 + 2];
		
		fill(cr, cg, cb);
		rect(x1, yw, 1, 1);
		while (e >= 0) {
			y1 += sy;
			e -= dx2;
		}
		x1 += sx;
		e += dy2;
	}
}

function draw() {
	background(0);
}"
"1050568","Quads rasterizer","mySketch","let img;
function preload() {
  img = loadImage('test.jpg');
}

function setup() {
	createCanvas(600, 600);
}

function stretch(x1, y1, x2, y2, yr, yw) {
	let dx = abs(x2 - x1);
	let dy = abs(y2 - y1);
	let sx = Math.sign(x2 - x1);
	let sy = Math.sign(y2 - y1);
	let e = 2 * dy - dx;
	let dx2 = 2 * dx;
	let dy2 = 2 * dy;
	for (let i = 0; i <= dx; i += 1) {
		let cr = img.pixels[(y1 + yr * img.width) * 4 + 0];
		let cg = img.pixels[(y1 + yr * img.width) * 4 + 1];
		let cb = img.pixels[(y1 + yr * img.width) * 4 + 2];
		
		fill(cr, cg, cb);
		rect(x1, yw, 1, 1);
		while (e >= 0) {
			y1 += sy;
			e -= dx2;
		}
		x1 += sx;
		e += dy2;
	}
}

function draw() {
	background(0);
	
	img.loadPixels();
	stretch(0, 0, 100, 100, 100, 100);
}"
"1050568","Quads rasterizer","mySketch","let img;
function preload() {
  img = loadImage('test.jpg');
}

function setup() {
	createCanvas(600, 600);
}

function stretch(x1, y1, x2, y2, yr, yw) {
	let dx = abs(x2 - x1);
	let dy = abs(y2 - y1);
	let sx = Math.sign(x2 - x1);
	let sy = Math.sign(y2 - y1);
	let e = 2 * dy - dx;
	let dx2 = 2 * dx;
	let dy2 = 2 * dy;
	for (let i = 0; i <= dx; i += 1) {
		let cr = img.pixels[(y1 + yr * img.width) * 4 + 0];
		let cg = img.pixels[(y1 + yr * img.width) * 4 + 1];
		let cb = img.pixels[(y1 + yr * img.width) * 4 + 2];
		
		fill(cr, cg, cb);
		rect(x1, yw, 1, 1);
		while (e >= 0) {
			y1 += sy;
			e -= dx2;
		}
		x1 += sx;
		e += dy2;
	}
}

function draw() {
	background(0);
	
	img.loadPixels();
	stretch(0, 0, 100, 100, 100, 100);
}"
"1050568","Quads rasterizer","mySketch","let img;
function preload() {
  img = loadImage('test.jpg');
}

function setup() {
	createCanvas(600, 600);
	
	noStroke();
}

function stretch(x1, y1, x2, y2, yr, yw) {
	let dx = abs(x2 - x1);
	let dy = abs(y2 - y1);
	let sx = Math.sign(x2 - x1);
	let sy = Math.sign(y2 - y1);
	let e = 2 * dy - dx;
	let dx2 = 2 * dx;
	let dy2 = 2 * dy;
	for (let i = 0; i <= dx; i += 1) {
		let cr = img.pixels[(y1 + yr * img.width) * 4 + 0];
		let cg = img.pixels[(y1 + yr * img.width) * 4 + 1];
		let cb = img.pixels[(y1 + yr * img.width) * 4 + 2];
		
		fill(cr, cg, cb);
		rect(x1, yw, 1, 1);
		while (e >= 0) {
			y1 += sy;
			e -= dx2;
		}
		x1 += sx;
		e += dy2;
	}
}

function draw() {
	background(0);
	
	img.loadPixels();
	stretch(100, 10, 200, 100, 10, 10);
}"
"1050568","Quads rasterizer","mySketch","let img;
function preload() {
  img = loadImage('test.jpg');
}

function setup() {
	createCanvas(600, 600);
	
	noStroke();
}

function stretch(x1, y1, x2, y2, yr, yw) {
	let dx = abs(x2 - x1);
	let dy = abs(y2 - y1);
	let sx = Math.sign(x2 - x1);
	let sy = Math.sign(y2 - y1);
	let e = 2 * dy - dx;
	let dx2 = 2 * dx;
	let dy2 = 2 * dy;
	
	if (dy == 0) return;
	
	for (let i = 0; i <= dx; i += 1) {
		let cr = img.pixels[(y1 + yr * img.width) * 4 + 0];
		let cg = img.pixels[(y1 + yr * img.width) * 4 + 1];
		let cb = img.pixels[(y1 + yr * img.width) * 4 + 2];
		
		fill(cr, cg, cb);
		rect(x1, yw, 1, 1);
		while (e >= 0) {
			y1 += sy;
			e -= dx2;
		}
		x1 += sx;
		e += dy2;
	}
}

function draw() {
	background(0);
	
	img.loadPixels();
	stretch(100, 10, 200, 100, 10, 10);
}"
"1050568","Quads rasterizer","mySketch","let img;
function preload() {
  img = loadImage('test.jpg');
}

function setup() {
	createCanvas(600, 600);
	
	noStroke();
}

function stretch(x1, y1, x2, y2, yr, yw) {
	let dx = abs(x2 - x1);
	let dy = abs(y2 - y1);
	let sx = Math.sign(x2 - x1);
	let sy = Math.sign(y2 - y1);
	let e = 2 * dy - dx;
	let dx2 = 2 * dx;
	let dy2 = 2 * dy;
	
	if (dx == 0 || dy == 0) return;
	
	for (let i = 0; i <= dx; i += 1) {
		let cr = img.pixels[(y1 + yr * img.width) * 4 + 0];
		let cg = img.pixels[(y1 + yr * img.width) * 4 + 1];
		let cb = img.pixels[(y1 + yr * img.width) * 4 + 2];
		
		//fill(cr, cg, cb);
		//rect(x1, yw, 1, 1);
		
		pixels[(x1 + yw * width) * 4 + 0] = cr;
		pixels[(x1 + yw * width) * 4 + 1] = cg;
		pixels[(x1 + yw * width) * 4 + 2] = cb;
		
		while (e >= 0) {
			y1 += sy;
			e -= dx2;
		}
		x1 += sx;
		e += dy2;
	}
}

function draw() {
	background(0);
	
	stroke(255, 255, 255);
	noFill();
	rect(0, 0, width, height);
	noStroke();
	
	img.loadPixels();
	loadPixels();
	
	for (let y = 0; y < 256; y += 1) {
		let ny = y / 256;
		stretch(width / 2 - (256 / 2 * ny), 0, width / 2 + (256 / 2 * ny), img.width, y, width /2 - (128 - y));
	}
	updatePixels();
}"
"1050568","Quads rasterizer","mySketch","let img;
function preload() {
  img = loadImage('test.jpg');
}

function setup() {
	createCanvas(600, 600);
	
	noStroke();
}

function stretch(x1, y1, x2, y2, yr, yw) {
	let dx = abs(x2 - x1);
	let dy = abs(y2 - y1);
	let sx = Math.sign(x2 - x1);
	let sy = Math.sign(y2 - y1);
	let e = 2 * dy - dx;
	let dx2 = 2 * dx;
	let dy2 = 2 * dy;
	
	if (dx == 0 || dy == 0) {
		return;
	}
	
	for (let i = 0; i <= dx; i += 1) {
		let cr = img.pixels[(y1 + yr * img.width) * 4 + 0];
		let cg = img.pixels[(y1 + yr * img.width) * 4 + 1];
		let cb = img.pixels[(y1 + yr * img.width) * 4 + 2];
		
		//fill(cr, cg, cb);
		//rect(x1, yw, 1, 1);
		
		pixels[(x1 + yw * width) * 4 + 0] = cr;
		pixels[(x1 + yw * width) * 4 + 1] = cg;
		pixels[(x1 + yw * width) * 4 + 2] = cb;
		
		while (e >= 0) {
			y1 += sy;
			e -= dx2;
		}
		x1 += sx;
		e += dy2;
	}
}

function draw() {
	background(0);
	
	stroke(255, 255, 255);
	noFill();
	rect(0, 0, width, height);
	noStroke();
	
	img.loadPixels();
	loadPixels();
	
	for (let y = 0; y < 256; y += 1) {
		let ny = y / 256;
		stretch(width / 2 - (256 / 2 * ny), 0, width / 2 + (256 / 2 * ny), img.width, y, width /2 - (128 - y));
	}
	updatePixels();
}"
"1050568","Quads rasterizer","mySketch","let img;
function preload() {
  img = loadImage('test.jpg');
}

function setup() {
	createCanvas(600, 600);
	
	noStroke();
}

function stretch(x1, y1, x2, y2, yr, yw) {
	let dx = abs(x2 - x1);
	let dy = abs(y2 - y1);
	let sx = Math.sign(x2 - x1);
	let sy = Math.sign(y2 - y1);
	let e = 2 * dy - dx;
	let dx2 = 2 * dx;
	let dy2 = 2 * dy;
	
	if (dx == 0 || dy == 0) {
		let cr = img.pixels[(y1 + yr * img.width) * 4 + 0];
		let cg = img.pixels[(y1 + yr * img.width) * 4 + 1];
		let cb = img.pixels[(y1 + yr * img.width) * 4 + 2];
		
		pixels[(x1 + yw * width) * 4 + 0] = cr;
		pixels[(x1 + yw * width) * 4 + 1] = cg;
		pixels[(x1 + yw * width) * 4 + 2] = cb;
		
		return;
	}
	
	for (let i = 0; i <= dx; i += 1) {
		let cr = img.pixels[(y1 + yr * img.width) * 4 + 0];
		let cg = img.pixels[(y1 + yr * img.width) * 4 + 1];
		let cb = img.pixels[(y1 + yr * img.width) * 4 + 2];
		
		//fill(cr, cg, cb);
		//rect(x1, yw, 1, 1);
		
		pixels[(x1 + yw * width) * 4 + 0] = cr;
		pixels[(x1 + yw * width) * 4 + 1] = cg;
		pixels[(x1 + yw * width) * 4 + 2] = cb;
		
		while (e >= 0) {
			y1 += sy;
			e -= dx2;
		}

		x1 += sx;
		e += dy2;
	}
}

function draw() {
	background(0);
	
	stroke(255, 255, 255);
	noFill();
	rect(0, 0, width, height);
	noStroke();
	
	img.loadPixels();
	loadPixels();
	
	for (let y = 0; y < 256; y += 1) {
		let ny = y / 256;
		stretch(width / 2 - (256 / 2 * ny), 0, width / 2 + (256 / 2 * ny), img.width, y, width /2 - (128 - y));
	}
	updatePixels();
}"
"1050568","Quads rasterizer","mySketch","let img;
function preload() {
  img = loadImage('test.jpg');
}

function setup() {
	createCanvas(600, 600);
	
	noStroke();
}

function stretch(x1, y1, x2, y2, yr, yw) {
	let dx = abs(x2 - x1);
	let dy = abs(y2 - y1);
	let sx = Math.sign(x2 - x1);
	let sy = Math.sign(y2 - y1);
	let e = 2 * dy - dx;
	let dx2 = 2 * dx;
	let dy2 = 2 * dy;
	
	if (dx == 0 || dy == 0) {
		let cr = img.pixels[(y1 + yr * img.width) * 4 + 0];
		let cg = img.pixels[(y1 + yr * img.width) * 4 + 1];
		let cb = img.pixels[(y1 + yr * img.width) * 4 + 2];
		
		pixels[(x1 + yw * width) * 4 + 0] = cr;
		pixels[(x1 + yw * width) * 4 + 1] = cg;
		pixels[(x1 + yw * width) * 4 + 2] = cb;
		
		return;
	}
	
	for (let i = 0; i <= dx; i += 1) {
		let cr = img.pixels[(y1 + yr * img.width) * 4 + 0];
		let cg = img.pixels[(y1 + yr * img.width) * 4 + 1];
		let cb = img.pixels[(y1 + yr * img.width) * 4 + 2];
		
		pixels[(x1 + yw * width) * 4 + 0] = cr;
		pixels[(x1 + yw * width) * 4 + 1] = cg;
		pixels[(x1 + yw * width) * 4 + 2] = cb;
		
		while (e >= 0) {
			y1 += sy;
			e -= dx2;
		}

		x1 += sx;
		e += dy2;
	}
}

function draw() {
	background(0);
	
	stroke(255, 255, 255);
	noFill();
	rect(0, 0, width, height);
	noStroke();
	
	img.loadPixels();
	loadPixels();
	
	for (let y = 0; y < 256; y += 1) {
		let ny = y / 256;
		stretch(width / 2 - (256 / 2 * ny), 0, width / 2 + (256 / 2 * ny), img.width, y, width /2 - (128 - y));
	}
	updatePixels();
}"
"1050568","Quads rasterizer","mySketch","let img;
function preload() {
  img = loadImage('test.jpg');
}

function setup() {
	createCanvas(600, 600);
	
	noStroke();
}

function stretch(x1, y1, x2, y2, yr, yw) {
	let dx = abs(x2 - x1);
	let dy = abs(y2 - y1);
	let sx = Math.sign(x2 - x1);
	let sy = Math.sign(y2 - y1);
	let e = 2 * dy - dx;
	let dx2 = 2 * dx;
	let dy2 = 2 * dy;
	
	if (dx == 0 || dy == 0) {
		let cr = img.pixels[(y1 + yr * img.width) * 4 + 0];
		let cg = img.pixels[(y1 + yr * img.width) * 4 + 1];
		let cb = img.pixels[(y1 + yr * img.width) * 4 + 2];
		
		pixels[(x1 + yw * width) * 4 + 0] = cr;
		pixels[(x1 + yw * width) * 4 + 1] = cg;
		pixels[(x1 + yw * width) * 4 + 2] = cb;
		
		return;
	}
	
	for (let i = 0; i <= dx; i += 1) {
		let cr = img.pixels[(y1 + yr * img.width) * 4 + 0];
		let cg = img.pixels[(y1 + yr * img.width) * 4 + 1];
		let cb = img.pixels[(y1 + yr * img.width) * 4 + 2];
		
		pixels[(x1 + yw * width) * 4 + 0] = cr;
		pixels[(x1 + yw * width) * 4 + 1] = cg;
		pixels[(x1 + yw * width) * 4 + 2] = cb;
		
		while (e >= 0) {
			y1 += sy;
			e -= dx2;
		}

		x1 += sx;
		e += dy2;
	}
}

function draw() {
	background(0);
	
	stroke(255, 255, 255);
	noFill();
	rect(0, 0, width, height);
	noStroke();
	
	img.loadPixels();
	loadPixels();
	
	for (let y = 0; y < 256; y += 1) {
		let ny = y / 256;
		stretch(width / 2 - (256 / 2 * ny), 0, width / 2 + (256 / 2 * ny), img.width, y, width /2 - (128 - y));
	}
	updatePixels();
}"
"1050568","Quads rasterizer","mySketch","let img;
function preload() {
  img = loadImage('test.jpg');
}

function setup() {
	createCanvas(600, 600);
	
	noStroke();
}

function stretch(x1, y1, x2, y2, yr, yw) {
	let dx = abs(x2 - x1);
	let dy = abs(y2 - y1);
	let sx = Math.sign(x2 - x1);
	let sy = Math.sign(y2 - y1);
	let e = 2 * dy - dx;
	let dx2 = 2 * dx;
	let dy2 = 2 * dy;
	
	if (dx == 0 || dy == 0) {
		let cr = img.pixels[(y1 + yr * img.width) * 4 + 0];
		let cg = img.pixels[(y1 + yr * img.width) * 4 + 1];
		let cb = img.pixels[(y1 + yr * img.width) * 4 + 2];
		
		pixels[(x1 + yw * width) * 4 + 0] = cr;
		pixels[(x1 + yw * width) * 4 + 1] = cg;
		pixels[(x1 + yw * width) * 4 + 2] = cb;
		
		return;
	}
	
	for (let i = 0; i <= dx; i += 1) {
		let cr = img.pixels[(y1 + yr * img.width) * 4 + 0];
		let cg = img.pixels[(y1 + yr * img.width) * 4 + 1];
		let cb = img.pixels[(y1 + yr * img.width) * 4 + 2];
		
		pixels[(x1 + yw * width) * 4 + 0] = cr;
		pixels[(x1 + yw * width) * 4 + 1] = cg;
		pixels[(x1 + yw * width) * 4 + 2] = cb;
		
		while (e >= 0) {
			y1 += sy;
			e -= dx2;
		}

		x1 += sx;
		e += dy2;
	}
}

function draw() {
	background(0);
	
	stroke(255, 255, 255);
	noFill();
	rect(0, 0, width, height);
	noStroke();
	
	img.loadPixels();
	loadPixels();
	
	for (let y = 0; y < 256; y += 1) {
		let ny = y / 256;
		stretch(width / 2 - round(256 / 2 * ny), 0, width / 2 + round(256 / 2 * ny), img.width, y, width /2 - (128 - y));
	}
	updatePixels();
}"
"1050568","Quads rasterizer","mySketch","let img;
function preload() {
  img = loadImage('test.jpg');
}

let offscreen_canvas;
function setup() {
	createCanvas(600, 600);
	offscreen_canvas = createGraphics(width * 2, height * 2);
	
	offscreen_canvas.stroke(255, 255, 255);
	offscreen_canvas.noFill();
}

function stretch(x1, y1, x2, y2, yr, yw) {
	let dx = abs(x2 - x1);
	let dy = abs(y2 - y1);
	let sx = Math.sign(x2 - x1);
	let sy = Math.sign(y2 - y1);
	let e = 2 * dy - dx;
	let dx2 = 2 * dx;
	let dy2 = 2 * dy;
	
	if (dx == 0 || dy == 0) {
		let cr = img.pixels[(y1 + yr * img.width) * 4 + 0];
		let cg = img.pixels[(y1 + yr * img.width) * 4 + 1];
		let cb = img.pixels[(y1 + yr * img.width) * 4 + 2];
		
		offscreen_canvas.pixels[(x1 + yw * offscreen_canvas.width) * 4 + 0] = cr;
		offscreen_canvas.pixels[(x1 + yw * offscreen_canvas.width) * 4 + 1] = cg;
		offscreen_canvas.pixels[(x1 + yw * offscreen_canvas.width) * 4 + 2] = cb;
		
		return;
	}
	
	for (let i = 0; i <= dx; i += 1) {
		let cr = img.pixels[(y1 + yr * img.width) * 4 + 0];
		let cg = img.pixels[(y1 + yr * img.width) * 4 + 1];
		let cb = img.pixels[(y1 + yr * img.width) * 4 + 2];
		
		offscreen_canvas.pixels[(x1 + yw * offscreen_canvas.width) * 4 + 0] = cr;
		offscreen_canvas.pixels[(x1 + yw * offscreen_canvas.width) * 4 + 1] = cg;
		offscreen_canvas.pixels[(x1 + yw * offscreen_canvas.width) * 4 + 2] = cb;
		
		while (e >= 0) {
			y1 += sy;
			e -= dx2;
		}

		x1 += sx;
		e += dy2;
	}
}

function draw() {
	offscreen_canvas.background(0);
	
	//offscreen_canvas.rect(0, 0, offscreen_canvas.width, offscreen_canvas.height);
	
	img.loadPixels();
	offscreen_canvas.loadPixels();
	
	for (let y = 0; y < img.height; y += 1) {
		let ny = y / img.height;
		stretch(offscreen_canvas.width / 2 - round(img.width * ny), 
						0,
						offscreen_canvas.width / 2 + round(img.width * ny),
						img.width,
						y,
						offscreen_canvas.height / 2 - (img.height / 2 - y));
	}
	offscreen_canvas.updatePixels();
	
	image(offscreen_canvas, 0, 0, width, height);
}"
"1050568","Quads rasterizer","mySketch","let img;
function preload() {
  img = loadImage('2048_texture.jpg');
}

let offscreen_canvas;
function setup() {
	createCanvas(600, 600);
	offscreen_canvas = createGraphics(width, height);
	
	offscreen_canvas.stroke(255, 255, 255);
	offscreen_canvas.noFill();
}

function stretch(x1, y1, x2, y2, yr, yw) {
	let dx = abs(x2 - x1);
	let dy = abs(y2 - y1);
	let sx = Math.sign(x2 - x1);
	let sy = Math.sign(y2 - y1);
	let e = 2 * dy - dx;
	let dx2 = 2 * dx;
	let dy2 = 2 * dy;
	
	if (dx == 0 || dy == 0) {
		let cr = img.pixels[(y1 + yr * img.width) * 4 + 0];
		let cg = img.pixels[(y1 + yr * img.width) * 4 + 1];
		let cb = img.pixels[(y1 + yr * img.width) * 4 + 2];
		
		offscreen_canvas.pixels[(x1 + yw * offscreen_canvas.width) * 4 + 0] = cr;
		offscreen_canvas.pixels[(x1 + yw * offscreen_canvas.width) * 4 + 1] = cg;
		offscreen_canvas.pixels[(x1 + yw * offscreen_canvas.width) * 4 + 2] = cb;
		
		return;
	}
	
	for (let i = 0; i <= dx; i += 1) {
		let cr = img.pixels[(y1 + yr * img.width) * 4 + 0];
		let cg = img.pixels[(y1 + yr * img.width) * 4 + 1];
		let cb = img.pixels[(y1 + yr * img.width) * 4 + 2];
		
		offscreen_canvas.pixels[(x1 + yw * offscreen_canvas.width) * 4 + 0] = cr;
		offscreen_canvas.pixels[(x1 + yw * offscreen_canvas.width) * 4 + 1] = cg;
		offscreen_canvas.pixels[(x1 + yw * offscreen_canvas.width) * 4 + 2] = cb;
		
		while (e >= 0) {
			y1 += sy;
			e -= dx2;
		}

		x1 += sx;
		e += dy2;
	}
}

// algebraically simplified linear interpolation
function lrp_simple(a, b, f) {
    return a + f * (b - a);
}

function draw() {
	offscreen_canvas.background(0);
	
	offscreen_canvas.rect(0, 0, offscreen_canvas.width, offscreen_canvas.height);
	
	img.loadPixels();
	offscreen_canvas.loadPixels();
	
	let v1 = { x: -0.5, y: -0.5 };
	let v2 = { x:  0.5, y: -0.5 };
	let v3 = { x:  0.0, y:  0.5 };
	let v4 = { x:  0.0, y:  0.5 };
	let h = offscreen_canvas.height / 2;
	for (let y = 0; y < h; y += 1) {
		let ny = y / h;
		stretch(round(offscreen_canvas.width / 2 + lrp_simple(v1.x, v4.x, ny) * offscreen_canvas.width / 2), 
						0,
						round(offscreen_canvas.width / 2 + lrp_simple(v2.x, v3.x, ny) * offscreen_canvas.width / 2),
						img.width,
						round(ny * img.height),
						y);
	}
	offscreen_canvas.updatePixels();
	
	image(offscreen_canvas, 0, 0, width, height);
}"
"1050568","Quads rasterizer","mySketch","let img;
function preload() {
  img = loadImage('2048_texture.jpg');
}

let offscreen_canvas;
function setup() {
	createCanvas(600, 600);
	offscreen_canvas = createGraphics(width * 2, height * 2);
	
	offscreen_canvas.stroke(255, 255, 255);
	offscreen_canvas.noFill();
}

function stretch(x1, y1, x2, y2, yr, yw) {
	let dx = abs(x2 - x1);
	let dy = abs(y2 - y1);
	let sx = Math.sign(x2 - x1);
	let sy = Math.sign(y2 - y1);
	let e = 2 * dy - dx;
	let dx2 = 2 * dx;
	let dy2 = 2 * dy;
	
	if (dx == 0 || dy == 0) {
		let cr = img.pixels[(y1 + yr * img.width) * 4 + 0];
		let cg = img.pixels[(y1 + yr * img.width) * 4 + 1];
		let cb = img.pixels[(y1 + yr * img.width) * 4 + 2];
		
		offscreen_canvas.pixels[(x1 + yw * offscreen_canvas.width) * 4 + 0] = cr;
		offscreen_canvas.pixels[(x1 + yw * offscreen_canvas.width) * 4 + 1] = cg;
		offscreen_canvas.pixels[(x1 + yw * offscreen_canvas.width) * 4 + 2] = cb;
		
		return;
	}
	
	for (let i = 0; i <= dx; i += 1) {
		let cr = img.pixels[(y1 + yr * img.width) * 4 + 0];
		let cg = img.pixels[(y1 + yr * img.width) * 4 + 1];
		let cb = img.pixels[(y1 + yr * img.width) * 4 + 2];
		
		offscreen_canvas.pixels[(x1 + yw * offscreen_canvas.width) * 4 + 0] = cr;
		offscreen_canvas.pixels[(x1 + yw * offscreen_canvas.width) * 4 + 1] = cg;
		offscreen_canvas.pixels[(x1 + yw * offscreen_canvas.width) * 4 + 2] = cb;
		
		while (e >= 0) {
			y1 += sy;
			e -= dx2;
		}

		x1 += sx;
		e += dy2;
	}
}

// algebraically simplified linear interpolation
function lrp_simple(a, b, f) {
    return a + f * (b - a);
}

function draw() {
	offscreen_canvas.background(0);
	
	//offscreen_canvas.rect(0, 0, offscreen_canvas.width, offscreen_canvas.height);
	
	img.loadPixels();
	offscreen_canvas.loadPixels();
	
	let v1 = { x: -0.5, y: -0.5 };
	let v2 = { x:  0.5 };
	let v3 = { x:  0.5 };
	let v4 = { x:  -0.5, y:  0.5 };
	let h = offscreen_canvas.height / 2;
	for (let y = 0; y < h; y += 1) {
		let ny = y / h;
		stretch(round(offscreen_canvas.width / 2 + lrp_simple(v1.x, v4.x, ny) * offscreen_canvas.width / 2), 
						0,
						round(offscreen_canvas.width / 2 + lrp_simple(v2.x, v3.x, ny) * offscreen_canvas.width / 2),
						img.width,
						round(ny * img.height),
						round(offscreen_canvas.height / 2 + lrp_simple(v1.y, v4.y, ny) * offscreen_canvas.height / 2));
	}
	offscreen_canvas.updatePixels();
	
	image(offscreen_canvas, 0, 0, width, height);
}"
"1050568","Quads rasterizer","mySketch","let img;
function preload() {
  img = loadImage('2048_texture.jpg');
}

let offscreen_canvas;
function setup() {
	createCanvas(600, 600);
	offscreen_canvas = createGraphics(width * 2, height * 2);
	
	offscreen_canvas.stroke(255, 255, 255);
	offscreen_canvas.noFill();
}

function stretch(x1, y1, x2, y2, yr, yw) {
	let dx = abs(x2 - x1);
	let dy = abs(y2 - y1);
	let sx = Math.sign(x2 - x1);
	let sy = Math.sign(y2 - y1);
	let e = 2 * dy - dx;
	let dx2 = 2 * dx;
	let dy2 = 2 * dy;
	
	if (dx == 0 || dy == 0) {
		let si = (y1 + yr * img.width) * 4;
		let cr = img.pixels[si + 0];
		let cg = img.pixels[si + 1];
		let cb = img.pixels[si + 2];
		
		let di = (x1 + yw * offscreen_canvas.width) * 4;
		offscreen_canvas.pixels[di + 0] = cr;
		offscreen_canvas.pixels[di + 1] = cg;
		offscreen_canvas.pixels[di + 2] = cb;
		
		return;
	}
	
	for (let i = 0; i <= dx; i += 1) {
		let si = (y1 + yr * img.width) * 4;
		let cr = img.pixels[si + 0];
		let cg = img.pixels[si + 1];
		let cb = img.pixels[si + 2];
		
		let di = (x1 + yw * offscreen_canvas.width) * 4;
		offscreen_canvas.pixels[di + 0] = cr;
		offscreen_canvas.pixels[di + 1] = cg;
		offscreen_canvas.pixels[di + 2] = cb;
		
		while (e >= 0) {
			y1 += sy;
			e -= dx2;
		}

		x1 += sx;
		e += dy2;
	}
}

// algebraically simplified linear interpolation
function lrp_simple(a, b, f) {
    return a + f * (b - a);
}

function draw() {
	offscreen_canvas.background(0);
	
	//offscreen_canvas.rect(0, 0, offscreen_canvas.width, offscreen_canvas.height);
	
	img.loadPixels();
	offscreen_canvas.loadPixels();
	
	let v1 = { x: -0.5, y: -0.5 };
	let v2 = { x:  0.5 };
	let v3 = { x:  0.5 };
	let v4 = { x:  -0.5, y:  0.5 };
	let h = offscreen_canvas.height / 2;
	for (let y = 0; y < h; y += 1) {
		let ny = y / h;
		stretch(round(offscreen_canvas.width / 2 + lrp_simple(v1.x, v4.x, ny) * offscreen_canvas.width / 2), 
						0,
						round(offscreen_canvas.width / 2 + lrp_simple(v2.x, v3.x, ny) * offscreen_canvas.width / 2),
						img.width,
						round(ny * img.height),
						round(offscreen_canvas.height / 2 + lrp_simple(v1.y, v4.y, ny) * offscreen_canvas.height / 2));
	}
	offscreen_canvas.updatePixels();
	
	image(offscreen_canvas, 0, 0, width, height);
}"
"1050568","Quads rasterizer","mySketch","let img;
function preload() {
  img = loadImage('2048_texture.jpg');
}

let offscreen_canvas;
function setup() {
	createCanvas(600, 600);
	offscreen_canvas = createGraphics(width * 2, height * 2);
	
	offscreen_canvas.stroke(255, 255, 255);
	offscreen_canvas.noFill();
}

function stretch(x1, y1, x2, y2, yr, yw) {
	let dx = abs(x2 - x1);
	let dy = abs(y2 - y1);
	let sx = Math.sign(x2 - x1);
	let sy = Math.sign(y2 - y1);
	let e = 2 * dy - dx;
	let dx2 = 2 * dx;
	let dy2 = 2 * dy;
	
	if (dx == 0 || dy == 0) {
		let si = (y1 + yr * img.width) * 4;
		let cr = img.pixels[si + 0];
		let cg = img.pixels[si + 1];
		let cb = img.pixels[si + 2];
		
		let di = (x1 + yw * offscreen_canvas.width) * 4;
		offscreen_canvas.pixels[di + 0] = cr;
		offscreen_canvas.pixels[di + 1] = cg;
		offscreen_canvas.pixels[di + 2] = cb;
		
		return;
	}
	
	for (let i = 0; i <= dx; i += 1) {
		let si = (y1 + yr * img.width) * 4;
		let cr = img.pixels[si + 0];
		let cg = img.pixels[si + 1];
		let cb = img.pixels[si + 2];
		
		let di = (x1 + yw * offscreen_canvas.width) * 4;
		offscreen_canvas.pixels[di + 0] = cr;
		offscreen_canvas.pixels[di + 1] = cg;
		offscreen_canvas.pixels[di + 2] = cb;
		
		while (e >= 0) {
			y1 += sy;
			e -= dx2;
		}

		x1 += sx;
		e += dy2;
	}
}

// algebraically simplified linear interpolation
function lrp_simple(a, b, f) {
    return a + f * (b - a);
}

function draw() {
	offscreen_canvas.background(0);
	
	//offscreen_canvas.rect(0, 0, offscreen_canvas.width, offscreen_canvas.height);
	
	img.loadPixels();
	offscreen_canvas.loadPixels();
	
	let v1 = { x: -0.5, y: -0.5 };
	let v2 = { x:  0.5, y: -0.5 };
	let v3 = { x:  0.5, y:  0.5 };
	let v4 = { x: -0.5, y:  0.5 };
	let h = offscreen_canvas.height / 2;
	for (let y = 0; y < h; y += 1) {
		let ny = y / h;
		stretch(round(offscreen_canvas.width / 2 + lrp_simple(v1.x, v4.x, ny) * offscreen_canvas.width / 2), 
						0,
						round(offscreen_canvas.width / 2 + lrp_simple(v2.x, v3.x, ny) * offscreen_canvas.width / 2),
						img.width,
						round(ny * img.height),
						round(offscreen_canvas.height / 2 + lrp_simple(v1.y, v4.y, ny) * offscreen_canvas.height / 2));
	}
	offscreen_canvas.updatePixels();
	
	image(offscreen_canvas, 0, 0, width, height);
}"
"1050568","Quads rasterizer","mySketch","let img;
function preload() {
  img = loadImage('2048_texture.jpg');
}

let offscreen_canvas;
function setup() {
	createCanvas(600, 600);
	offscreen_canvas = createGraphics(width * 2, height * 2);
	
	offscreen_canvas.stroke(255, 255, 255);
	offscreen_canvas.noFill();
}

function stretch(src, dst, x1, y1, x2, y2, yr, yw) {
	let dx = abs(x2 - x1);
	let dy = abs(y2 - y1);
	let sx = Math.sign(x2 - x1);
	let sy = Math.sign(y2 - y1);
	let e = 2 * dy - dx;
	let dx2 = 2 * dx;
	let dy2 = 2 * dy;
	
	if (dx == 0 || dy == 0) {
		let si = (y1 + yr * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (x1 + yw * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		return;
	}
	
	for (let i = 0; i <= dx; i += 1) {
		let si = (y1 + yr * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (x1 + yw * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		while (e >= 0) {
			y1 += sy;
			e -= dx2;
		}

		x1 += sx;
		e += dy2;
	}
}

// algebraically simplified linear interpolation
function lrp_simple(a, b, f) {
    return a + f * (b - a);
}

function draw() {
	offscreen_canvas.background(0);
	
	//offscreen_canvas.rect(0, 0, offscreen_canvas.width, offscreen_canvas.height);
	
	img.loadPixels();
	offscreen_canvas.loadPixels();
	
	let v1 = { x: -0.5, y: -0.5 };
	let v2 = { x:  0.5, y: -0.5 };
	let v3 = { x:  0.5, y:  0.5 };
	let v4 = { x: -0.5, y:  0.5 };
	let h = offscreen_canvas.height / 2;
	for (let y = 0; y < h; y += 1) {
		let ny = y / h;
		stretch(round(offscreen_canvas.width / 2 + lrp_simple(v1.x, v4.x, ny) * offscreen_canvas.width / 2), 
						0,
						round(offscreen_canvas.width / 2 + lrp_simple(v2.x, v3.x, ny) * offscreen_canvas.width / 2),
						img.width,
						round(ny * img.height),
						round(offscreen_canvas.height / 2 + lrp_simple(v1.y, v4.y, ny) * offscreen_canvas.height / 2));
	}
	offscreen_canvas.updatePixels();
	
	image(offscreen_canvas, 0, 0, width, height);
}"
"1050568","Quads rasterizer","mySketch","let img;
function preload() {
  img = loadImage('2048_texture.jpg');
}

let offscreen_canvas;
function setup() {
	createCanvas(600, 600);
	offscreen_canvas = createGraphics(width * 2, height * 2);
	
	offscreen_canvas.stroke(255, 255, 255);
	offscreen_canvas.noFill();
}

function stretch(src, dst, x1, y1, x2, y2, yr, yw) {
	let dx = abs(x2 - x1);
	let dy = abs(y2 - y1);
	let sx = Math.sign(x2 - x1);
	let sy = Math.sign(y2 - y1);
	let e = 2 * dy - dx;
	let dx2 = 2 * dx;
	let dy2 = 2 * dy;
	
	if (dx == 0 || dy == 0) {
		let si = (y1 + yr * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (x1 + yw * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		return;
	}
	
	for (let i = 0; i <= dx; i += 1) {
		let si = (y1 + yr * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (x1 + yw * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		while (e >= 0) {
			y1 += sy;
			e -= dx2;
		}

		x1 += sx;
		e += dy2;
	}
}

// algebraically simplified linear interpolation
function lrp_simple(a, b, f) {
    return a + f * (b - a);
}

function draw() {
	offscreen_canvas.background(0);
	
	//offscreen_canvas.rect(0, 0, offscreen_canvas.width, offscreen_canvas.height);
	
	img.loadPixels();
	offscreen_canvas.loadPixels();
	
	let v1 = { x: -0.5, y: -0.5 };
	let v2 = { x:  0.5, y: -0.5 };
	let v3 = { x:  0.5, y:  0.5 };
	let v4 = { x: -0.5, y:  0.5 };
	let h = offscreen_canvas.height / 2;
	for (let y = 0; y < h; y += 1) {
		let ny = y / h;
		stretch(img, offscreen_canvas,
						round(offscreen_canvas.width / 2 + lrp_simple(v1.x, v4.x, ny) * offscreen_canvas.width / 2), 
						0,
						round(offscreen_canvas.width / 2 + lrp_simple(v2.x, v3.x, ny) * offscreen_canvas.width / 2),
						img.width,
						round(ny * img.height),
						round(offscreen_canvas.height / 2 + lrp_simple(v1.y, v4.y, ny) * offscreen_canvas.height / 2));
	}
	offscreen_canvas.updatePixels();
	
	image(offscreen_canvas, 0, 0, width, height);
}"
"1050568","Quads rasterizer","mySketch","let img;
function preload() {
  img = loadImage('2048_texture.jpg');
}

let offscreen_canvas;
function setup() {
	createCanvas(600, 600);
	offscreen_canvas = createGraphics(width * 2, height * 2);
	
	offscreen_canvas.stroke(255, 255, 255);
	offscreen_canvas.noFill();
}

function stretch(src, dst, x1, y1, x2, y2, yr, yw) {
	let dx = abs(x2 - x1);
	let dy = abs(y2 - y1);
	let sx = Math.sign(x2 - x1);
	let sy = Math.sign(y2 - y1);
	let e = 2 * dy - dx;
	let dx2 = 2 * dx;
	let dy2 = 2 * dy;
	
	if (dx == 0 || dy == 0) {
		let si = (y1 + yr * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (x1 + yw * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		return;
	}
	
	for (let i = 0; i <= dx; i += 1) {
		let si = (y1 + yr * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (x1 + yw * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		while (e >= 0) {
			y1 += sy;
			e -= dx2;
		}

		x1 += sx;
		e += dy2;
	}
}

// algebraically simplified linear interpolation
function lrp_simple(a, b, f) {
    return a + f * (b - a);
}

function draw() {
	offscreen_canvas.background(0);
	
	//offscreen_canvas.rect(0, 0, offscreen_canvas.width, offscreen_canvas.height);
	
	img.loadPixels();
	offscreen_canvas.loadPixels();
	
	let v1 = { x: -0.5, y: -0.5 };
	let v2 = { x:  0.5, y: -0.5 };
	let v3 = { x:  0.0, y:  0.5 };
	let v4 = { x: -0.0, y:  0.5 };
	let h = offscreen_canvas.height / 2;
	for (let y = 0; y < h; y += 1) {
		let ny = y / h;
		stretch(img, offscreen_canvas,
						round(offscreen_canvas.width / 2 + lrp_simple(v1.x, v4.x, ny) * offscreen_canvas.width / 2), 
						0,
						round(offscreen_canvas.width / 2 + lrp_simple(v2.x, v3.x, ny) * offscreen_canvas.width / 2),
						img.width,
						round(ny * img.height),
						round(offscreen_canvas.height / 2 + lrp_simple(v1.y, v4.y, ny) * offscreen_canvas.height / 2));
	}
	offscreen_canvas.updatePixels();
	
	image(offscreen_canvas, 0, 0, width, height);
}"
"1050568","Quads rasterizer","mySketch","let img;
function preload() {
  img = loadImage('2048_texture.jpg');
}

let shape_canvas;
let offscreen_canvas;
function setup() {
	createCanvas(600, 600);
	shape_canvas = createGraphics(width * 2, height * 2);
	offscreen_canvas = createGraphics(width * 2, height * 2);
	offscreen_canvas.stroke(255, 255, 255);
	offscreen_canvas.noFill();
	shape_canvas.stroke(255, 255, 255);
	shape_canvas.noFill();
}

function stretch(src, dst, x1, y1, x2, y2, yr, yw) {
	let dx = abs(x2 - x1);
	let dy = abs(y2 - y1);
	let sx = Math.sign(x2 - x1);
	let sy = Math.sign(y2 - y1);
	let e = 2 * dy - dx;
	let dx2 = 2 * dx;
	let dy2 = 2 * dy;
	
	if (dx == 0 || dy == 0) {
		let si = (y1 + yr * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (x1 + yw * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		return;
	}
	
	for (let i = 0; i <= dx; i += 1) {
		let si = (y1 + yr * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (x1 + yw * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		while (e >= 0) {
			y1 += sy;
			e -= dx2;
		}

		x1 += sx;
		e += dy2;
	}
}

// algebraically simplified linear interpolation
function lrp_simple(a, b, f) {
    return a + f * (b - a);
}

function draw() {
	offscreen_canvas.background(0);
	shape_canvas.background(0);
	
	//offscreen_canvas.rect(0, 0, offscreen_canvas.width, offscreen_canvas.height);
	
	img.loadPixels();
	shape_canvas.loadPixels();
	
	let v1 = { x: -0.5, y: -0.5 };
	let v2 = { x:  0.5, y: -0.5 };
	let v3 = { x:  0.0, y:  0.5 };
	let v4 = { x: -0.0, y:  0.5 };
	let h = shape_canvas.height / 2;
	
	let bbx = min(floor(shape_canvas.width / 2 + v1.x * shape_canvas.width / 2), round(shape_canvas.width / 2 + v2.x * shape_canvas.width / 2));
	let bbw = abs(ceil(shape_canvas.width / 2 + v1.x * shape_canvas.width / 2) - round(shape_canvas.width / 2 + v2.x * shape_canvas.width / 2));
	let bby = min(floor(shape_canvas.height / 2 + v1.y * shape_canvas.height / 2), round(shape_canvas.height / 2 + v4.y * shape_canvas.height / 2));
	let bbh = abs(ceil(shape_canvas.height / 2 + v1.y * shape_canvas.height / 2) - round(shape_canvas.height / 2 + v4.y * shape_canvas.height / 2));

	for (let y = 0; y < h; y += 1) {
		let ny = y / h;
		stretch(img, shape_canvas,
						round(shape_canvas.width / 2 + lrp_simple(v1.x, v4.x, ny) * shape_canvas.width / 2), 
						0,
						round(shape_canvas.width / 2 + lrp_simple(v2.x, v3.x, ny) * shape_canvas.width / 2),
						img.width,
						round(ny * img.height),
						round(shape_canvas.height / 2 + lrp_simple(v1.y, v4.y, ny) * shape_canvas.height / 2));
	}
	shape_canvas.updatePixels();
	
	shape_canvas.rect(bbx, bby, bbw, bbh);
	
	image(shape_canvas, 0, 0, width, height);
}"
"1050568","Quads rasterizer","mySketch","let img;
function preload() {
  img = loadImage('2048_texture.jpg');
}

let shape_canvas;
let offscreen_canvas;
function setup() {
	createCanvas(600, 600);
	shape_canvas = createGraphics(width * 2, height * 2);
	offscreen_canvas = createGraphics(width * 2, height * 2);
	offscreen_canvas.stroke(255, 255, 255);
	offscreen_canvas.noFill();
	shape_canvas.stroke(255, 255, 255);
	shape_canvas.noFill();
}

function stretchX(src, dst, x1, y1, x2, y2, yr, yw) {
	let dx = abs(x2 - x1);
	let dy = abs(y2 - y1);
	let sx = Math.sign(x2 - x1);
	let sy = Math.sign(y2 - y1);
	let e = 2 * dy - dx;
	let dx2 = 2 * dx;
	let dy2 = 2 * dy;
	
	if (dx == 0 || dy == 0) {
		let si = (y1 + yr * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (x1 + yw * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		return;
	}
	
	for (let i = 0; i <= dx; i += 1) {
		let si = (y1 + yr * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (x1 + yw * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		while (e >= 0) {
			y1 += sy;
			e -= dx2;
		}

		x1 += sx;
		e += dy2;
	}
}

function stretchY(src, dst, x1, y1, x2, y2, yr, yw) {
	let dx = abs(x2 - x1);
	let dy = abs(y2 - y1);
	let sx = Math.sign(x2 - x1);
	let sy = Math.sign(y2 - y1);
	let e = 2 * dy - dx;
	let dx2 = 2 * dx;
	let dy2 = 2 * dy;
	
	if (dx == 0 || dy == 0) {
		let si = (yr + y1 * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (yw + x1 * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		return;
	}
	
	for (let i = 0; i <= dx; i += 1) {
		let si = (yr + y1 * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (yw + x1 * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		while (e >= 0) {
			y1 += sy;
			e -= dx2;
		}

		x1 += sx;
		e += dy2;
	}
}

// algebraically simplified linear interpolation
function lrp_simple(a, b, f) {
    return a + f * (b - a);
}

function draw() {
	offscreen_canvas.background(0);
	shape_canvas.background(0);
	
	//offscreen_canvas.rect(0, 0, offscreen_canvas.width, offscreen_canvas.height);
	
	img.loadPixels();
	shape_canvas.loadPixels();
	offscreen_canvas.loadPixels();
	
	let v1 = { x: -0.5, y: -0.5 };
	let v2 = { x:  0.5, y: -0.5 };
	let v3 = { x:  0.5, y:  0.5 };
	let v4 = { x: -0.5, y:  0.5 };
	
	let w2 = shape_canvas.width / 2;
	
	let bbmin = min(round(w2 + v1.x * w2), round(w2 + v2.x * w2), round(w2 + v3.x * w2), round(w2 + v4.x * w2));
	let bbmax = max(round(w2 + v1.x * w2), round(w2 + v2.x * w2), round(w2 + v3.x * w2), round(w2 + v4.x * w2));
	let bbw = abs(bbmin - bbmax);
	let bby = min(round(w2 + v1.y * w2), round(w2 + v4.y * w2));
	let bbh = abs(round((w2 + v1.y * w2) - (w2 + v4.y * w2)));

	let h2 = shape_canvas.height / 2;
	for (let y = 0; y < h2; y += 1) {
		let ny = y / h2;
		stretchX(img, shape_canvas,
						round(w2 + lrp_simple(v1.x, v4.x, ny) * w2), 
						0,
						round(w2 + lrp_simple(v2.x, v3.x, ny) * w2),
						img.width,
						round(ny * img.height),
						round(h2 + lrp_simple(v1.y, v4.y, ny) * h2));
	}
	shape_canvas.updatePixels();
	
	for (let x = 0; x < bbw; x += 1) {
		let nx = x / bbw;
		stretchY(shape_canvas, offscreen_canvas,
						round(h2 + lrp_simple(v1.y, v2.y, nx) * h2), 
						bby,
						round(h2 + lrp_simple(v4.y, v3.y, nx) * h2),
						bby + bbh,
						bbmin + x,
						round(w2 + lrp_simple(bbmin / shape_canvas.width * 2 - 1, bbmax / shape_canvas.width * 2 - 1, nx) * bbw));
	}
	offscreen_canvas.updatePixels();
	
	//offscreen_canvas.rect(bbmin, bby, bbw, bbh);
	
	image(offscreen_canvas, 0, 0, width, height);
}"
"1050568","Quads rasterizer","mySketch","let img;
function preload() {
  img = loadImage('2048_texture.jpg');
}

let shape_canvas;
let offscreen_canvas;
function setup() {
	createCanvas(600, 600);
	shape_canvas = createGraphics(width * 2, height * 2);
	offscreen_canvas = createGraphics(width * 2, height * 2);
	offscreen_canvas.stroke(255, 255, 255);
	offscreen_canvas.noFill();
	shape_canvas.stroke(255, 255, 255);
	shape_canvas.noFill();
}

function stretchX(src, dst, x1, y1, x2, y2, yr, yw) {
	let dx = abs(x2 - x1);
	let dy = abs(y2 - y1);
	let sx = Math.sign(x2 - x1);
	let sy = Math.sign(y2 - y1);
	let e = 2 * dy - dx;
	let dx2 = 2 * dx;
	let dy2 = 2 * dy;
	
	if (dx == 0 || dy == 0) {
		let si = (y1 + yr * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (x1 + yw * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		return;
	}
	
	for (let i = 0; i <= dx; i += 1) {
		let si = (y1 + yr * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (x1 + yw * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		while (e >= 0) {
			y1 += sy;
			e -= dx2;
		}

		x1 += sx;
		e += dy2;
	}
}

function stretchY(src, dst, x1, y1, x2, y2, yr, yw) {
	let dx = abs(x2 - x1);
	let dy = abs(y2 - y1);
	let sx = Math.sign(x2 - x1);
	let sy = Math.sign(y2 - y1);
	let e = 2 * dy - dx;
	let dx2 = 2 * dx;
	let dy2 = 2 * dy;
	
	if (dx == 0 || dy == 0) {
		let si = (yr + y1 * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (yw + x1 * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		return;
	}
	
	for (let i = 0; i <= dx; i += 1) {
		let si = (yr + y1 * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (yw + x1 * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		while (e >= 0) {
			y1 += sy;
			e -= dx2;
		}

		x1 += sx;
		e += dy2;
	}
}

// algebraically simplified linear interpolation
function lrp_simple(a, b, f) {
    return a + f * (b - a);
}

function draw() {
	offscreen_canvas.background(0);
	shape_canvas.background(0);
	
	//offscreen_canvas.rect(0, 0, offscreen_canvas.width, offscreen_canvas.height);
	
	img.loadPixels();
	shape_canvas.loadPixels();
	offscreen_canvas.loadPixels();
	
	let v1 = { x: -0.5, y: -0.5 };
	let v2 = { x:  0.5, y: -0.5 };
	let v3 = { x:  0.5, y:  0.5 };
	let v4 = { x: -0.5, y:  0.5 };
	
	let w2 = shape_canvas.width / 2;
	
	let bbmin = min(round(w2 + v1.x * w2), round(w2 + v2.x * w2), round(w2 + v3.x * w2), round(w2 + v4.x * w2));
	let bbmax = max(round(w2 + v1.x * w2), round(w2 + v2.x * w2), round(w2 + v3.x * w2), round(w2 + v4.x * w2));
	let bbw = abs(bbmin - bbmax);
	let bby = min(round(w2 + v1.y * w2), round(w2 + v4.y * w2));
	let bbh = abs(round((w2 + v1.y * w2) - (w2 + v4.y * w2)));

	let h2 = shape_canvas.height / 2;
	for (let y = 0; y < h2; y += 1) {
		let ny = y / h2;
		stretchX(img, shape_canvas,
						round(w2 + lrp_simple(v1.x, v4.x, ny) * w2), 
						0,
						round(w2 + lrp_simple(v2.x, v3.x, ny) * w2),
						img.width,
						round(ny * img.height),
						round(h2 + lrp_simple(v1.y, v4.y, ny) * h2));
	}
	shape_canvas.updatePixels();
	
	for (let x = 0; x < bbw; x += 1) {
		let nx = x / bbw;
		stretchY(shape_canvas, offscreen_canvas,
						round(h2 + lrp_simple(v1.y, v2.y, nx) * h2), 
						bby,
						round(h2 + lrp_simple(v4.y, v3.y, nx) * h2),
						bby + bbh,
						bbmin + x,
						round(w2 + lrp_simple(bbmin / shape_canvas.width * 2 - 1, bbmax / shape_canvas.width * 2 - 1, nx) * bbw));
	}
	offscreen_canvas.updatePixels();
	
	//offscreen_canvas.rect(bbmin, bby, bbw, bbh);
	
	image(offscreen_canvas, 0, 0, width, height);
}"
"1050568","Quads rasterizer","mySketch","let img;
function preload() {
  img = loadImage('2048_texture.jpg');
}

let shape_canvas;
let offscreen_canvas;
function setup() {
	createCanvas(600, 600);
	shape_canvas = createGraphics(width * 2, height * 2);
	offscreen_canvas = createGraphics(width * 2, height * 2);
	offscreen_canvas.stroke(255, 255, 255);
	offscreen_canvas.noFill();
	shape_canvas.stroke(255, 255, 255);
	shape_canvas.noFill();
}

function stretchX(src, dst, x1, y1, x2, y2, yr, yw) {
	let dx = abs(x2 - x1);
	let dy = abs(y2 - y1);
	let sx = Math.sign(x2 - x1);
	let sy = Math.sign(y2 - y1);
	let e = 2 * dy - dx;
	let dx2 = 2 * dx;
	let dy2 = 2 * dy;
	
	if (dx == 0 || dy == 0) {
		let si = (y1 + yr * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (x1 + yw * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		return;
	}
	
	for (let i = 0; i <= dx; i += 1) {
		let si = (y1 + yr * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (x1 + yw * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		while (e >= 0) {
			y1 += sy;
			e -= dx2;
		}

		x1 += sx;
		e += dy2;
	}
}

function stretchY(src, dst, x1, y1, x2, y2, yr, yw) {
	let dx = abs(x2 - x1);
	let dy = abs(y2 - y1);
	let sx = Math.sign(x2 - x1);
	let sy = Math.sign(y2 - y1);
	let e = 2 * dy - dx;
	let dx2 = 2 * dx;
	let dy2 = 2 * dy;
	
	if (dx == 0 || dy == 0) {
		let si = (yr + y1 * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (yw + x1 * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		return;
	}
	
	for (let i = 0; i <= dx; i += 1) {
		let si = (yr + y1 * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (yw + x1 * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		while (e >= 0) {
			y1 += sy;
			e -= dx2;
		}

		x1 += sx;
		e += dy2;
	}
}

// algebraically simplified linear interpolation
function lrp_simple(a, b, f) {
    return a + f * (b - a);
}

function draw() {
	offscreen_canvas.background(0);
	shape_canvas.background(0);
	
	//offscreen_canvas.rect(0, 0, offscreen_canvas.width, offscreen_canvas.height);
	
	img.loadPixels();
	shape_canvas.loadPixels();
	offscreen_canvas.loadPixels();
	
	let v1 = { x: -0.5, y: -0.5 };
	let v2 = { x:  0.5, y: -0.5 };
	let v3 = { x:  0.5, y:  0.5 };
	let v4 = { x: -0.5, y:  0.5 };
	
	let w2 = shape_canvas.width / 2;
	
	let bbmin = min(round(w2 + v1.x * w2), round(w2 + v2.x * w2), round(w2 + v3.x * w2), round(w2 + v4.x * w2));
	let bbmax = max(round(w2 + v1.x * w2), round(w2 + v2.x * w2), round(w2 + v3.x * w2), round(w2 + v4.x * w2));
	let bbw = abs(bbmin - bbmax);
	let bby = min(round(w2 + v1.y * w2), round(w2 + v4.y * w2));
	let bbh = abs(round((w2 + v1.y * w2) - (w2 + v4.y * w2)));

	let h2 = shape_canvas.height / 2;
	for (let y = 0; y < h2; y += 1) {
		let ny = y / h2;
		stretchX(img, shape_canvas,
						round(w2 + lrp_simple(v1.x, v4.x, ny) * w2), 
						0,
						round(w2 + lrp_simple(v2.x, v3.x, ny) * w2),
						img.width,
						round(ny * img.height),
						round(h2 + lrp_simple(v1.y, v4.y, ny) * h2));
	}
	shape_canvas.updatePixels();
	
	for (let x = 0; x < bbw; x += 1) {
		let nx = x / bbw;
		stretchY(shape_canvas, offscreen_canvas,
						round(h2 + lrp_simple(v1.y, v2.y, nx) * h2), 
						bby,
						round(h2 + lrp_simple(v4.y, v3.y, nx) * h2),
						bby + bbh,
						bbmin + x,
						round(w2 + lrp_simple(bbmin / shape_canvas.width * 2 - 1, bbmax / shape_canvas.width * 2 - 1, nx) * bbw));
	}
	offscreen_canvas.updatePixels();
	
	//offscreen_canvas.rect(bbmin, bby, bbw, bbh);
	
	image(offscreen_canvas, 0, 0, width, height);
}"
"1050568","Quads rasterizer","mySketch","let img;
function preload() {
  img = loadImage('2048_texture.jpg');
}

let shape_canvas;
let offscreen_canvas;
function setup() {
	createCanvas(600, 600);
	shape_canvas = createGraphics(width * 2, height * 2);
	offscreen_canvas = createGraphics(width * 2, height * 2);
	offscreen_canvas.stroke(255, 255, 255);
	offscreen_canvas.noFill();
	shape_canvas.stroke(255, 255, 255);
	shape_canvas.noFill();
}

function stretchX(src, dst, x1, y1, x2, y2, yr, yw) {
	let dx = abs(x2 - x1);
	let dy = abs(y2 - y1);
	let sx = Math.sign(x2 - x1);
	let sy = Math.sign(y2 - y1);
	let e = 2 * dy - dx;
	let dx2 = 2 * dx;
	let dy2 = 2 * dy;
	
	if (dx == 0 || dy == 0) {
		let si = (y1 + yr * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (x1 + yw * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		return;
	}
	
	for (let i = 0; i <= dx; i += 1) {
		let si = (y1 + yr * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (x1 + yw * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		while (e >= 0) {
			y1 += sy;
			e -= dx2;
		}

		x1 += sx;
		e += dy2;
	}
}

function stretchY(src, dst, x1, y1, x2, y2, yr, yw) {
	let dx = abs(x2 - x1);
	let dy = abs(y2 - y1);
	let sx = Math.sign(x2 - x1);
	let sy = Math.sign(y2 - y1);
	let e = 2 * dy - dx;
	let dx2 = 2 * dx;
	let dy2 = 2 * dy;
	
	if (dx == 0 || dy == 0) {
		let si = (yr + y1 * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (yw + x1 * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		return;
	}
	
	for (let i = 0; i <= dx; i += 1) {
		let si = (yr + y1 * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (yw + x1 * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		while (e >= 0) {
			y1 += sy;
			e -= dx2;
		}

		x1 += sx;
		e += dy2;
	}
}

// algebraically simplified linear interpolation
function lrp_simple(a, b, f) {
    return a + f * (b - a);
}

function draw() {
	offscreen_canvas.background(0);
	shape_canvas.background(0);
	
	//offscreen_canvas.rect(0, 0, offscreen_canvas.width, offscreen_canvas.height);
	
	img.loadPixels();
	shape_canvas.loadPixels();
	offscreen_canvas.loadPixels();
	
	let v1 = { x: -0.5, y: -0.5 };
	let v2 = { x:  0.5, y: -0.5 };
	let v3 = { x:  0.5, y:  0.5 };
	let v4 = { x: -0.5, y:  0.5 };
	
	let w2 = shape_canvas.width / 2;
	
	let bbmin = min(round(w2 + v1.x * w2), round(w2 + v2.x * w2), round(w2 + v3.x * w2), round(w2 + v4.x * w2));
	let bbmax = max(round(w2 + v1.x * w2), round(w2 + v2.x * w2), round(w2 + v3.x * w2), round(w2 + v4.x * w2));
	let bbw = abs(bbmin - bbmax);
	let bby = min(round(w2 + v1.y * w2), round(w2 + v4.y * w2));
	let bbh = abs(round((w2 + v1.y * w2) - (w2 + v4.y * w2)));

	let h2 = shape_canvas.height / 2;
	for (let y = 0; y < h2; y += 1) {
		let ny = y / h2;
		stretchX(img, shape_canvas,
						round(w2 + lrp_simple(v1.x, v4.x, ny) * w2), 
						0,
						round(w2 + lrp_simple(v2.x, v3.x, ny) * w2),
						img.width,
						round(ny * img.height),
						round(h2 + lrp_simple(v1.y, v4.y, ny) * h2));
	}
	shape_canvas.updatePixels();
	
	for (let x = 0; x < bbw; x += 1) {
		let nx = x / bbw;
		stretchY(shape_canvas, offscreen_canvas,
						round(h2 + lrp_simple(v1.y, v2.y, nx) * h2), 
						bby,
						round(h2 + lrp_simple(v4.y, v3.y, nx) * h2),
						bby + bbh,
						bbmin + x,
						round(w2 + lrp_simple(bbmin / shape_canvas.width * 2 - 1, bbmax / shape_canvas.width * 2 - 1, nx) * bbw));
	}
	offscreen_canvas.updatePixels();
	
	//offscreen_canvas.rect(bbmin, bby, bbw, bbh);
	
	image(offscreen_canvas, 0, 0, width, height);
}"
"1050568","Quads rasterizer","mySketch","let img;
function preload() {
  img = loadImage('2048_texture.jpg');
}

let aa = 2;

let shape_canvas;
let offscreen_canvas;
function setup() {
	createCanvas(600, 600);
	shape_canvas = createGraphics(width * aa, height * aa);
	offscreen_canvas = createGraphics(width * aa, height * aa);
	offscreen_canvas.stroke(255, 255, 255);
	offscreen_canvas.noFill();
	shape_canvas.stroke(255, 255, 255);
	shape_canvas.noFill();
}

function stretchX(src, dst, x1, y1, x2, y2, yr, yw) {
	let dx = abs(x2 - x1);
	let dy = abs(y2 - y1);
	let sx = Math.sign(x2 - x1);
	let sy = Math.sign(y2 - y1);
	let e = 2 * dy - dx;
	let dx2 = 2 * dx;
	let dy2 = 2 * dy;
	
	if (dx == 0 || dy == 0) {
		let si = (y1 + yr * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (x1 + yw * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		return;
	}
	
	for (let i = 0; i <= dx; i += 1) {
		let si = (y1 + yr * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (x1 + yw * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		while (e >= 0) {
			y1 += sy;
			e -= dx2;
		}

		x1 += sx;
		e += dy2;
	}
}

function stretchY(src, dst, x1, y1, x2, y2, yr, yw) {
	let dx = abs(x2 - x1);
	let dy = abs(y2 - y1);
	let sx = Math.sign(x2 - x1);
	let sy = Math.sign(y2 - y1);
	let e = 2 * dy - dx;
	let dx2 = 2 * dx;
	let dy2 = 2 * dy;
	
	if (dx == 0 || dy == 0) {
		let si = (yr + y1 * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (yw + x1 * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		return;
	}
	
	for (let i = 0; i <= dx; i += 1) {
		let si = (yr + y1 * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (yw + x1 * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		while (e >= 0) {
			y1 += sy;
			e -= dx2;
		}

		x1 += sx;
		e += dy2;
	}
}

// algebraically simplified linear interpolation
function lrp_simple(a, b, f) {
    return a + f * (b - a);
}

function draw() {
	offscreen_canvas.background(0);
	shape_canvas.background(0);
	
	//offscreen_canvas.rect(0, 0, offscreen_canvas.width, offscreen_canvas.height);
	
	img.loadPixels();
	shape_canvas.loadPixels();
	offscreen_canvas.loadPixels();
	
	const v1 = { x: -0.65, y: -0.5 };
	const v2 = { x:  0.5, y: -0.5 };
	const v3 = { x:  0.5, y:  0.5 };
	const v4 = { x: -0.5, y:  0.5 };
	
	const w2 = shape_canvas.width / 2;
	
	const bbmin = min(round(w2 + v1.x * w2), round(w2 + v2.x * w2), round(w2 + v3.x * w2), round(w2 + v4.x * w2));
	const bbmax = max(round(w2 + v1.x * w2), round(w2 + v2.x * w2), round(w2 + v3.x * w2), round(w2 + v4.x * w2));
	const bbw = abs(bbmin - bbmax);
	const bby = min(round(w2 + v1.y * w2), round(w2 + v4.y * w2));
	const bbh = abs(round((w2 + v1.y * w2) - (w2 + v4.y * w2)));

	let h2 = shape_canvas.height / 2;
	for (let y = 0; y < h2; y += 1) {
		let ny = y / h2;
		stretchX(img, shape_canvas,
						round(w2 + lrp_simple(v1.x, v4.x, ny) * w2), 
						0,
						round(w2 + lrp_simple(v2.x, v3.x, ny) * w2),
						img.width,
						round(ny * img.height),
						round(h2 + lrp_simple(v1.y, v4.y, ny) * h2));
	}
	shape_canvas.updatePixels();

	for (let x = 0; x < bbw; x += 1) {
		let nx = x / bbw;
		stretchY(shape_canvas, offscreen_canvas,
						round(h2 + lrp_simple(v1.y, v2.y, nx) * h2), 
						bby,
						round(h2 + lrp_simple(v4.y, v3.y, nx) * h2),
						bby + bbh,
						bbmin + x,
						round(w2 + lrp_simple(bbmin / shape_canvas.width * 2 - 1, bbmax / shape_canvas.width * 2 - 1, nx) * bbw));
	}
	offscreen_canvas.updatePixels();

	offscreen_canvas.rect(bbmin, bby, bbw, bbh);
	image(offscreen_canvas, 0, 0, width, height);
	
	//shape_canvas.rect(bbmin1, bby, bbw, bbh);
	//image(shape_canvas, 0, 0, width, height);
}"
"1050568","Quads rasterizer","mySketch","let img;
function preload() {
  img = loadImage('2048_texture.jpg');
}

let aa = 1;

let shape_canvas;
let offscreen_canvas;
function setup() {
	createCanvas(600, 600);
	
	shape_canvas = createGraphics(width * aa, height * aa);
	offscreen_canvas = createGraphics(width * aa, height * aa);
	
	stroke(255, 255, 255);
	noFill();
}

function stretchX(src, dst, x1, y1, x2, y2, yr, yw) {
	let dx = abs(x2 - x1);
	let dy = abs(y2 - y1);
	let sx = Math.sign(x2 - x1);
	let sy = Math.sign(y2 - y1);
	let e = 2 * dy - dx;
	let dx2 = 2 * dx;
	let dy2 = 2 * dy;
	
	if (dx == 0 || dy == 0) {
		let si = (y1 + yr * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (x1 + yw * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		return;
	}
	
	for (let i = 0; i <= dx; i += 1) {
		let si = (y1 + yr * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (x1 + yw * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		while (e >= 0) {
			y1 += sy;
			e -= dx2;
		}

		x1 += sx;
		e += dy2;
	}
}

function stretchY(src, dst, x1, y1, x2, y2, yr, yw) {
	let dx = abs(x2 - x1);
	let dy = abs(y2 - y1);
	let sx = Math.sign(x2 - x1);
	let sy = Math.sign(y2 - y1);
	let e = 2 * dy - dx;
	let dx2 = 2 * dx;
	let dy2 = 2 * dy;
	
	if (dx == 0 || dy == 0) {
		let si = (yr + y1 * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (yw + x1 * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		return;
	}
	
	for (let i = 0; i <= dx; i += 1) {
		let si = (yr + y1 * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (yw + x1 * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		while (e >= 0) {
			y1 += sy;
			e -= dx2;
		}

		x1 += sx;
		e += dy2;
	}
}

// algebraically simplified linear interpolation
function lrp_simple(a, b, f) {
    return a + f * (b - a);
}

function draw() {
	offscreen_canvas.background(0);
	shape_canvas.background(0);
	
	//offscreen_canvas.rect(0, 0, offscreen_canvas.width, offscreen_canvas.height);
	
	img.loadPixels();
	shape_canvas.loadPixels();
	offscreen_canvas.loadPixels();
	
	const v1 = { x: sin(frameCount / 40), y: -0.5 };
	const v2 = { x:  0.5, y: -0.5 };
	const v3 = { x:  0.5, y:  0.5 };
	const v4 = { x: -0.5, y:  0.5 };
	
	const w2 = shape_canvas.width / 2;
	
	const bbmin = min([round(w2 + v1.x * w2), round(w2 + v2.x * w2), round(w2 + v3.x * w2), round(w2 + v4.x * w2)]);
	const bbmax = max([round(w2 + v1.x * w2), round(w2 + v2.x * w2), round(w2 + v3.x * w2), round(w2 + v4.x * w2)]);
	const bbw = abs(bbmin - bbmax);
	const bby = min([round(w2 + v1.y * w2), round(w2 + v4.y * w2)]);
	const bbh = abs(round((w2 + v1.y * w2) - (w2 + v4.y * w2)));

	let h2 = shape_canvas.height / 2;
	for (let y = 0; y < h2; y += 1) {
		let ny = y / h2;
		stretchX(img, shape_canvas,
						round(w2 + lrp_simple(v1.x, v4.x, ny) * w2), 
						0,
						round(w2 + lrp_simple(v2.x, v3.x, ny) * w2),
						img.width,
						round(ny * img.height),
						round(h2 + lrp_simple(v1.y, v4.y, ny) * h2));
	}
	shape_canvas.updatePixels();

	for (let x = 0; x < bbw; x += 1) {
		let nx = x / bbw;
		stretchY(shape_canvas, offscreen_canvas,
						round(h2 + lrp_simple(v1.y, v2.y, nx) * h2), 
						bby,
						round(h2 + lrp_simple(v4.y, v3.y, nx) * h2),
						bby + bbh,
						bbmin + x,
						round(w2 + lrp_simple(bbmin / shape_canvas.width * 2 - 1, bbmax / shape_canvas.width * 2 - 1, nx) * bbw));
	}
	offscreen_canvas.updatePixels();

	//image(offscreen_canvas, 0, 0, width, height);
	image(shape_canvas, 0, 0, width, height);
	
	rect(bbmin, bby, bbw, bbh);
}"
"1050568","Quads rasterizer","mySketch","let img;
function preload() {
  img = loadImage('2048_texture.jpg');
}

let aa = 1;

let shape_canvas;
let offscreen_canvas;
function setup() {
	createCanvas(600, 600);
	
	shape_canvas = createGraphics(width * aa, height * aa);
	offscreen_canvas = createGraphics(width * aa, height * aa);
	
	stroke(255, 255, 255);
	noFill();
}

function stretchX(src, dst, x1, y1, x2, y2, yr, yw) {
	let dx = abs(x2 - x1);
	let dy = abs(y2 - y1);
	let sx = Math.sign(x2 - x1);
	let sy = Math.sign(y2 - y1);
	let e = 2 * dy - dx;
	let dx2 = 2 * dx;
	let dy2 = 2 * dy;
	
	if (dx == 0 || dy == 0) {
		let si = (y1 + yr * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (x1 + yw * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		return;
	}
	
	for (let i = 0; i <= dx; i += 1) {
		let si = (y1 + yr * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (x1 + yw * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		while (e >= 0) {
			y1 += sy;
			e -= dx2;
		}

		x1 += sx;
		e += dy2;
	}
}

function stretchY(src, dst, x1, y1, x2, y2, yr, yw) {
	let dx = abs(x2 - x1);
	let dy = abs(y2 - y1);
	let sx = Math.sign(x2 - x1);
	let sy = Math.sign(y2 - y1);
	let e = 2 * dy - dx;
	let dx2 = 2 * dx;
	let dy2 = 2 * dy;
	
	if (dx == 0 || dy == 0) {
		let si = (yr + y1 * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (yw + x1 * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		return;
	}
	
	for (let i = 0; i <= dx; i += 1) {
		let si = (yr + y1 * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (yw + x1 * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		while (e >= 0) {
			y1 += sy;
			e -= dx2;
		}

		x1 += sx;
		e += dy2;
	}
}

// algebraically simplified linear interpolation
function lrp_simple(a, b, f) {
    return a + f * (b - a);
}

function draw() {
	offscreen_canvas.background(0);
	shape_canvas.background(0);
	
	//offscreen_canvas.rect(0, 0, offscreen_canvas.width, offscreen_canvas.height);
	
	img.loadPixels();
	shape_canvas.loadPixels();
	offscreen_canvas.loadPixels();
	
	const v1 = { x: -1, y: -1 };
	const v2 = { x:  1, y: -1 };
	const v3 = { x:  1, y:  1 };
	const v4 = { x: -1, y:  1 };
	
	const w2 = shape_canvas.width / aa;
	
	const bbmin = min([round(w2 + v1.x * w2), round(w2 + v2.x * w2), round(w2 + v3.x * w2), round(w2 + v4.x * w2)]);
	const bbmax = max([round(w2 + v1.x * w2), round(w2 + v2.x * w2), round(w2 + v3.x * w2), round(w2 + v4.x * w2)]);
	const bbw = abs(bbmin - bbmax);
	const bby = min([round(w2 + v1.y * w2), round(w2 + v4.y * w2)]);
	const bbh = abs(round((w2 + v1.y * w2) - (w2 + v4.y * w2)));

	let h2 = shape_canvas.height / aa;
	for (let y = 0; y < h2; y += 1) {
		let ny = y / h2;
		stretchX(img, shape_canvas,
						round(w2 + lrp_simple(v1.x, v4.x, ny) * w2), 
						0,
						round(w2 + lrp_simple(v2.x, v3.x, ny) * w2),
						img.width,
						round(ny * img.height),
						y);//round(h2 + lrp_simple(v1.y, v4.y, ny) * h2));
	}
	shape_canvas.updatePixels();
/*
	for (let x = 0; x < bbw; x += 1) {
		let nx = x / bbw;
		stretchY(shape_canvas, offscreen_canvas,
						round(h2 + lrp_simple(v1.y, v2.y, nx) * h2), 
						bby,
						round(h2 + lrp_simple(v4.y, v3.y, nx) * h2),
						bby + bbh,
						bbmin + x,
						bbmin + x);//round(w2 + lrp_simple(bbmin / shape_canvas.width * 2 - 1, bbmax / shape_canvas.width * 2 - 1, nx) * bbw));
	}
	offscreen_canvas.updatePixels();
*/
	//image(offscreen_canvas, 0, 0, width, height);
	image(shape_canvas, 0, 0, width, height);
	
	rect(bbmin, bby, bbw, bbh);
}"
"1050568","Quads rasterizer","mySketch","let img;
function preload() {
  img = loadImage('2048_texture.jpg');
}

let aa = 1;

let shape_canvas;
let offscreen_canvas;
function setup() {
	createCanvas(600, 600);
	
	shape_canvas = createGraphics(width * aa, height * aa);
	offscreen_canvas = createGraphics(width * aa, height * aa);
	
	stroke(255, 255, 255);
	noFill();
}

function stretchX(src, dst, x1, y1, x2, y2, yr, yw) {
	let dx = abs(x2 - x1);
	let dy = abs(y2 - y1);
	let sx = Math.sign(x2 - x1);
	let sy = Math.sign(y2 - y1);
	let e = 2 * dy - dx;
	let dx2 = 2 * dx;
	let dy2 = 2 * dy;
	
	if (dx == 0 || dy == 0) {
		let si = (y1 + yr * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (x1 + yw * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		return;
	}
	
	for (let i = 0; i <= dx; i += 1) {
		let si = (y1 + yr * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (x1 + yw * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		while (e >= 0) {
			y1 += sy;
			e -= dx2;
		}

		x1 += sx;
		e += dy2;
	}
}

function stretchY(src, dst, x1, y1, x2, y2, yr, yw) {
	let dx = abs(x2 - x1);
	let dy = abs(y2 - y1);
	let sx = Math.sign(x2 - x1);
	let sy = Math.sign(y2 - y1);
	let e = 2 * dy - dx;
	let dx2 = 2 * dx;
	let dy2 = 2 * dy;
	
	if (dx == 0 || dy == 0) {
		let si = (yr + y1 * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (yw + x1 * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		return;
	}
	
	for (let i = 0; i <= dx; i += 1) {
		let si = (yr + y1 * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (yw + x1 * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		while (e >= 0) {
			y1 += sy;
			e -= dx2;
		}

		x1 += sx;
		e += dy2;
	}
}

// algebraically simplified linear interpolation
function lrp_simple(a, b, f) {
    return a + f * (b - a);
}

function draw() {
	offscreen_canvas.background(0);
	shape_canvas.background(0);
	
	//offscreen_canvas.rect(0, 0, offscreen_canvas.width, offscreen_canvas.height);
	
	img.loadPixels();
	shape_canvas.loadPixels();
	offscreen_canvas.loadPixels();
	
	const v1 = { x: -1, y: -1 };
	const v2 = { x:  1, y: -1 };
	const v3 = { x:  1, y:  1 };
	const v4 = { x: -1, y:  1 };
	
	const w2 = shape_canvas.width / aa;
	
	const bbmin = min([round(w2 + v1.x * w2), round(w2 + v2.x * w2), round(w2 + v3.x * w2), round(w2 + v4.x * w2)]);
	const bbmax = max([round(w2 + v1.x * w2), round(w2 + v2.x * w2), round(w2 + v3.x * w2), round(w2 + v4.x * w2)]);
	const bbw = abs(bbmin - bbmax);
	const bby = min([round(w2 + v1.y * w2), round(w2 + v4.y * w2)]);
	const bbh = abs(round((w2 + v1.y * w2) - (w2 + v4.y * w2)));

	let h2 = shape_canvas.height / aa;
	for (let y = 0; y < h2; y += 1) {
		let ny = y / h2;
		stretchX(img, shape_canvas,
						round(w2 + lrp_simple(v1.x, v4.x, ny) * w2), 
						0,
						round(w2 + lrp_simple(v2.x, v3.x, ny) * w2),
						img.width,
						round(ny * img.height),
						y);//round(h2 + lrp_simple(v1.y, v4.y, ny) * h2));
	}
	shape_canvas.updatePixels();
/*
	for (let x = 0; x < bbw; x += 1) {
		let nx = x / bbw;
		stretchY(shape_canvas, offscreen_canvas,
						round(h2 + lrp_simple(v1.y, v2.y, nx) * h2), 
						bby,
						round(h2 + lrp_simple(v4.y, v3.y, nx) * h2),
						bby + bbh,
						bbmin + x,
						bbmin + x);//round(w2 + lrp_simple(bbmin / shape_canvas.width * 2 - 1, bbmax / shape_canvas.width * 2 - 1, nx) * bbw));
	}
	offscreen_canvas.updatePixels();
*/
	//image(offscreen_canvas, 0, 0, width, height);
	image(shape_canvas, 0, 0, width, height);
	
	rect(bbmin, bby, bbw, bbh);
}"
"1050568","Quads rasterizer","mySketch","let img;
function preload() {
  img = loadImage('2048_texture.jpg');
}

let aa = 1;

let shape_canvas;
let offscreen_canvas;
function setup() {
	createCanvas(600, 600);
	
	shape_canvas = createGraphics(width * aa, height * aa);
	offscreen_canvas = createGraphics(width * aa, height * aa);
	
	stroke(255, 255, 255);
	noFill();
}

function stretchX(src, dst, x1, y1, x2, y2, yr, yw) {
	let dx = abs(x2 - x1);
	let dy = abs(y2 - y1);
	let sx = Math.sign(x2 - x1);
	let sy = Math.sign(y2 - y1);
	let e = 2 * dy - dx;
	let dx2 = 2 * dx;
	let dy2 = 2 * dy;
	
	if (dx == 0 || dy == 0) {
		let si = (y1 + yr * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (x1 + yw * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		return;
	}
	
	for (let i = 0; i <= dx; i += 1) {
		let si = (y1 + yr * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (x1 + yw * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		while (e >= 0) {
			y1 += sy;
			e -= dx2;
		}

		x1 += sx;
		e += dy2;
	}
}

function stretchY(src, dst, x1, y1, x2, y2, yr, yw) {
	let dx = abs(x2 - x1);
	let dy = abs(y2 - y1);
	let sx = Math.sign(x2 - x1);
	let sy = Math.sign(y2 - y1);
	let e = 2 * dy - dx;
	let dx2 = 2 * dx;
	let dy2 = 2 * dy;
	
	if (dx == 0 || dy == 0) {
		let si = (yr + y1 * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (yw + x1 * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		return;
	}
	
	for (let i = 0; i <= dx; i += 1) {
		let si = (yr + y1 * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (yw + x1 * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		while (e >= 0) {
			y1 += sy;
			e -= dx2;
		}

		x1 += sx;
		e += dy2;
	}
}

// algebraically simplified linear interpolation
function lrp_simple(a, b, f) {
    return a + f * (b - a);
}

function draw() {
	offscreen_canvas.background(0);
	shape_canvas.background(0);
	
	//offscreen_canvas.rect(0, 0, offscreen_canvas.width, offscreen_canvas.height);
	
	img.loadPixels();
	shape_canvas.loadPixels();
	offscreen_canvas.loadPixels();
	
	const v1 = { x: -1, y: -1 };
	const v2 = { x:  1, y: -1 };
	const v3 = { x:  1, y:  1 };
	const v4 = { x: -1, y:  1 };
	
	const w2 = shape_canvas.width;
	
	const bbmin = min([round(w2 + v1.x * w2), round(w2 + v2.x * w2), round(w2 + v3.x * w2), round(w2 + v4.x * w2)]);
	const bbmax = max([round(w2 + v1.x * w2), round(w2 + v2.x * w2), round(w2 + v3.x * w2), round(w2 + v4.x * w2)]);
	const bbw = abs(bbmin - bbmax);
	const bby = min([round(w2 + v1.y * w2), round(w2 + v4.y * w2)]);
	const bbh = abs(round((w2 + v1.y * w2) - (w2 + v4.y * w2)));

	let h2 = shape_canvas.height;
	for (let y = 0; y < h2; y += 1) {
		let ny = y / h2;
		stretchX(img, shape_canvas,
						round(w2 + lrp_simple(v1.x, v4.x, ny) * w2), 
						0,
						round(w2 + lrp_simple(v2.x, v3.x, ny) * w2),
						img.width,
						round(ny * img.height),
						y);//round(h2 + lrp_simple(v1.y, v4.y, ny) * h2));
	}
	shape_canvas.updatePixels();
/*
	for (let x = 0; x < bbw; x += 1) {
		let nx = x / bbw;
		stretchY(shape_canvas, offscreen_canvas,
						round(h2 + lrp_simple(v1.y, v2.y, nx) * h2), 
						bby,
						round(h2 + lrp_simple(v4.y, v3.y, nx) * h2),
						bby + bbh,
						bbmin + x,
						bbmin + x);//round(w2 + lrp_simple(bbmin / shape_canvas.width * 2 - 1, bbmax / shape_canvas.width * 2 - 1, nx) * bbw));
	}
	offscreen_canvas.updatePixels();
*/
	//image(offscreen_canvas, 0, 0, width, height);
	image(shape_canvas, 0, 0, width, height);
	
	rect(bbmin, bby, bbw, bbh);
}"
"1050568","Quads rasterizer","mySketch","let img;
function preload() {
  img = loadImage('2048_texture.jpg');
}

let aa = 1;

let shape_canvas;
let offscreen_canvas;
function setup() {
	createCanvas(600, 600);
	
	shape_canvas = createGraphics(width * aa, height * aa);
	offscreen_canvas = createGraphics(width * aa, height * aa);
	
	stroke(255, 255, 255);
	noFill();
}

function stretchX(src, dst, x1, y1, x2, y2, yr, yw) {
	let dx = abs(x2 - x1);
	let dy = abs(y2 - y1);
	let sx = Math.sign(x2 - x1);
	let sy = Math.sign(y2 - y1);
	let e = 2 * dy - dx;
	let dx2 = 2 * dx;
	let dy2 = 2 * dy;
	
	if (dx == 0 || dy == 0) {
		let si = (y1 + yr * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (x1 + yw * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		return;
	}
	
	for (let i = 0; i <= dx; i += 1) {
		let si = (y1 + yr * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (x1 + yw * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		while (e >= 0) {
			y1 += sy;
			e -= dx2;
		}

		x1 += sx;
		e += dy2;
	}
}

function stretchY(src, dst, x1, y1, x2, y2, yr, yw) {
	let dx = abs(x2 - x1);
	let dy = abs(y2 - y1);
	let sx = Math.sign(x2 - x1);
	let sy = Math.sign(y2 - y1);
	let e = 2 * dy - dx;
	let dx2 = 2 * dx;
	let dy2 = 2 * dy;
	
	if (dx == 0 || dy == 0) {
		let si = (yr + y1 * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (yw + x1 * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		return;
	}
	
	for (let i = 0; i <= dx; i += 1) {
		let si = (yr + y1 * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (yw + x1 * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		while (e >= 0) {
			y1 += sy;
			e -= dx2;
		}

		x1 += sx;
		e += dy2;
	}
}

// algebraically simplified linear interpolation
function lrp_simple(a, b, f) {
    return a + f * (b - a);
}

function draw() {
	offscreen_canvas.background(0);
	shape_canvas.background(0);
	
	//offscreen_canvas.rect(0, 0, offscreen_canvas.width, offscreen_canvas.height);
	
	img.loadPixels();
	shape_canvas.loadPixels();
	offscreen_canvas.loadPixels();
	
	const v1 = { x: -1, y: -1 };
	const v2 = { x:  1, y: -1 };
	const v3 = { x:  1, y:  1 };
	const v4 = { x: -1, y:  1 };
	
	const w2 = shape_canvas.width / 2;
	
	const bbmin = min([round(w2 + v1.x * w2), round(w2 + v2.x * w2), round(w2 + v3.x * w2), round(w2 + v4.x * w2)]);
	const bbmax = max([round(w2 + v1.x * w2), round(w2 + v2.x * w2), round(w2 + v3.x * w2), round(w2 + v4.x * w2)]);
	const bbw = abs(bbmin - bbmax);
	const bby = min([round(w2 + v1.y * w2), round(w2 + v4.y * w2)]);
	const bbh = abs(round((w2 + v1.y * w2) - (w2 + v4.y * w2)));

	let h2 = shape_canvas.height;
	for (let y = 0; y < h2; y += 1) {
		let ny = y / h2;
		stretchX(img, shape_canvas,
						round(w2 + lrp_simple(v1.x, v4.x, ny) * w2), 
						0,
						round(w2 + lrp_simple(v2.x, v3.x, ny) * w2),
						img.width,
						round(ny * img.height),
						y);//round(h2 + lrp_simple(v1.y, v4.y, ny) * h2));
	}
	shape_canvas.updatePixels();
/*
	for (let x = 0; x < bbw; x += 1) {
		let nx = x / bbw;
		stretchY(shape_canvas, offscreen_canvas,
						round(h2 + lrp_simple(v1.y, v2.y, nx) * h2), 
						bby,
						round(h2 + lrp_simple(v4.y, v3.y, nx) * h2),
						bby + bbh,
						bbmin + x,
						bbmin + x);//round(w2 + lrp_simple(bbmin / shape_canvas.width * 2 - 1, bbmax / shape_canvas.width * 2 - 1, nx) * bbw));
	}
	offscreen_canvas.updatePixels();
*/
	//image(offscreen_canvas, 0, 0, width, height);
	image(shape_canvas, 0, 0, width, height);
	
	rect(bbmin, bby, bbw, bbh);
}"
"1050568","Quads rasterizer","mySketch","let img;
function preload() {
  img = loadImage('2048_texture.jpg');
}

let aa = 1;

let shape_canvas;
let offscreen_canvas;
function setup() {
	createCanvas(600, 600);
	
	shape_canvas = createGraphics(width * aa, height * aa);
	offscreen_canvas = createGraphics(width * aa, height * aa);
	
	stroke(255, 255, 255);
	noFill();
}

function stretchX(src, dst, x1, y1, x2, y2, yr, yw) {
	let dx = abs(x2 - x1);
	let dy = abs(y2 - y1);
	let sx = Math.sign(x2 - x1);
	let sy = Math.sign(y2 - y1);
	let e = 2 * dy - dx;
	let dx2 = 2 * dx;
	let dy2 = 2 * dy;
	
	if (dx == 0 || dy == 0) {
		let si = (y1 + yr * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (x1 + yw * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		return;
	}
	
	for (let i = 0; i <= dx; i += 1) {
		let si = (y1 + yr * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (x1 + yw * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		while (e >= 0) {
			y1 += sy;
			e -= dx2;
		}

		x1 += sx;
		e += dy2;
	}
}

function stretchY(src, dst, x1, y1, x2, y2, yr, yw) {
	let dx = abs(x2 - x1);
	let dy = abs(y2 - y1);
	let sx = Math.sign(x2 - x1);
	let sy = Math.sign(y2 - y1);
	let e = 2 * dy - dx;
	let dx2 = 2 * dx;
	let dy2 = 2 * dy;
	
	if (dx == 0 || dy == 0) {
		let si = (yr + y1 * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (yw + x1 * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		return;
	}
	
	for (let i = 0; i <= dx; i += 1) {
		let si = (yr + y1 * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (yw + x1 * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		while (e >= 0) {
			y1 += sy;
			e -= dx2;
		}

		x1 += sx;
		e += dy2;
	}
}

// algebraically simplified linear interpolation
function lrp_simple(a, b, f) {
    return a + f * (b - a);
}

function draw() {
	offscreen_canvas.background(0);
	shape_canvas.background(0);
	
	//offscreen_canvas.rect(0, 0, offscreen_canvas.width, offscreen_canvas.height);
	
	img.loadPixels();
	shape_canvas.loadPixels();
	offscreen_canvas.loadPixels();
	
	const v1 = { x: -1, y: -1 };
	const v2 = { x:  1, y: -1 };
	const v3 = { x:  1, y:  1 };
	const v4 = { x: -1, y:  1 };
	
	const w2 = shape_canvas.width / 2;
	
	const bbmin = min([round(w2 + v1.x * w2), round(w2 + v2.x * w2), round(w2 + v3.x * w2), round(w2 + v4.x * w2)]);
	const bbmax = max([round(w2 + v1.x * w2), round(w2 + v2.x * w2), round(w2 + v3.x * w2), round(w2 + v4.x * w2)]);
	const bbw = abs(bbmin - bbmax);
	const bby = min([round(w2 + v1.y * w2), round(w2 + v4.y * w2)]);
	const bbh = abs(round((w2 + v1.y * w2) - (w2 + v4.y * w2)));

	for (let y = 0; y < shape_canvas.height; y += 1) {
		let ny = y / shape_canvas.height;
		stretchX(img, shape_canvas,
						round(w2 + lrp_simple(v1.x, v4.x, ny) * w2), 
						0,
						round(w2 + lrp_simple(v2.x, v3.x, ny) * w2),
						img.width,
						round(ny * img.height),
						y);//round(h2 + lrp_simple(v1.y, v4.y, ny) * h2));
	}
	shape_canvas.updatePixels();

	let h2 = shape_canvas.height / 2;
	for (let x = 0; x < bbw; x += 1) {
		let nx = x / bbw;
		stretchY(shape_canvas, offscreen_canvas,
						round(h2 + lrp_simple(v1.y, v2.y, nx) * h2), 
						bby,
						round(h2 + lrp_simple(v4.y, v3.y, nx) * h2),
						bby + bbh,
						bbmin + x,
						bbmin + x);//round(w2 + lrp_simple(bbmin / shape_canvas.width * 2 - 1, bbmax / shape_canvas.width * 2 - 1, nx) * bbw));
	}
	offscreen_canvas.updatePixels();

	image(offscreen_canvas, 0, 0, width, height);
	//image(shape_canvas, 0, 0, width, height);
	
	rect(bbmin, bby, bbw, bbh);
}"
"1050568","Quads rasterizer","mySketch","let img;
function preload() {
  img = loadImage('2048_texture.jpg');
}

let aa = 1;

let shape_canvas;
let offscreen_canvas;
function setup() {
	createCanvas(600, 600);
	
	shape_canvas = createGraphics(width * aa, height * aa);
	offscreen_canvas = createGraphics(width * aa, height * aa);
	
	stroke(255, 255, 255);
	noFill();
}

function stretchX(src, dst, x1, y1, x2, y2, yr, yw) {
	let dx = abs(x2 - x1);
	let dy = abs(y2 - y1);
	let sx = Math.sign(x2 - x1);
	let sy = Math.sign(y2 - y1);
	let e = 2 * dy - dx;
	let dx2 = 2 * dx;
	let dy2 = 2 * dy;
	
	if (dx == 0 || dy == 0) {
		let si = (y1 + yr * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (x1 + yw * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		return;
	}
	
	for (let i = 0; i <= dx; i += 1) {
		let si = (y1 + yr * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (x1 + yw * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		while (e >= 0) {
			y1 += sy;
			e -= dx2;
		}

		x1 += sx;
		e += dy2;
	}
}

function stretchY(src, dst, x1, y1, x2, y2, yr, yw) {
	let dx = abs(x2 - x1);
	let dy = abs(y2 - y1);
	let sx = Math.sign(x2 - x1);
	let sy = Math.sign(y2 - y1);
	let e = 2 * dy - dx;
	let dx2 = 2 * dx;
	let dy2 = 2 * dy;
	
	if (dx == 0 || dy == 0) {
		let si = (yr + y1 * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (yw + x1 * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		return;
	}
	
	for (let i = 0; i <= dx; i += 1) {
		let si = (yr + y1 * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (yw + x1 * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		while (e >= 0) {
			y1 += sy;
			e -= dx2;
		}

		x1 += sx;
		e += dy2;
	}
}

// algebraically simplified linear interpolation
function lrp_simple(a, b, f) {
    return a + f * (b - a);
}

function draw() {
	offscreen_canvas.background(0);
	shape_canvas.background(0);
	
	//offscreen_canvas.rect(0, 0, offscreen_canvas.width, offscreen_canvas.height);
	
	img.loadPixels();
	shape_canvas.loadPixels();
	offscreen_canvas.loadPixels();
	
	const v1 = { x: 0, y: -1 };
	const v2 = { x:  1, y: -1 };
	const v3 = { x:  1, y:  0 };
	const v4 = { x: -1, y:  1 };
	
	const w2 = shape_canvas.width / 2;
	
	const bbmin = min([round(w2 + v1.x * w2), round(w2 + v2.x * w2), round(w2 + v3.x * w2), round(w2 + v4.x * w2)]);
	const bbmax = max([round(w2 + v1.x * w2), round(w2 + v2.x * w2), round(w2 + v3.x * w2), round(w2 + v4.x * w2)]);
	const bbw = abs(bbmin - bbmax);
	const bby = 0;//min([round(w2 + v1.y * w2), round(w2 + v4.y * w2)]);
	const bbh = shape_canvas.height;//abs(round((w2 + v1.y * w2) - (w2 + v4.y * w2)));

	for (let y = 0; y < shape_canvas.height; y += 1) {
		let ny = y / shape_canvas.height;
		stretchX(img, shape_canvas,
						round(w2 + lrp_simple(v1.x, v4.x, ny) * w2), 
						0,
						round(w2 + lrp_simple(v2.x, v3.x, ny) * w2),
						img.width,
						round(ny * img.height),
						y);//round(h2 + lrp_simple(v1.y, v4.y, ny) * h2));
	}
	shape_canvas.updatePixels();

	let h2 = offscreen_canvas.height / 2;
	for (let x = 0; x < bbw; x += 1) {
		let nx = x / bbw;
		stretchY(shape_canvas, offscreen_canvas,
						round(h2 + lrp_simple(v1.y, v2.y, nx) * h2), 
						bby,
						round(h2 + lrp_simple(v4.y, v3.y, nx) * h2),
						bby + bbh,
						bbmin + x,
						bbmin + x);//round(w2 + lrp_simple(bbmin / shape_canvas.width * 2 - 1, bbmax / shape_canvas.width * 2 - 1, nx) * bbw));
	}
	offscreen_canvas.updatePixels();

	image(offscreen_canvas, 0, 0, width, height);
	//image(shape_canvas, 0, 0, width, height);
	
	rect(bbmin, bby, bbw, bbh);
}"
"1050568","Quads rasterizer","mySketch","let img;
function preload() {
  img = loadImage('2048_texture.jpg');
}

let aa = 1;

let shape_canvas;
let offscreen_canvas;
function setup() {
	createCanvas(600, 600);
	
	shape_canvas = createGraphics(width * aa, height * aa);
	offscreen_canvas = createGraphics(width * aa, height * aa);
	
	stroke(255, 255, 255);
	noFill();
}

function stretchX(src, dst, x1, y1, x2, y2, yr, yw) {
	let dx = abs(x2 - x1);
	let dy = abs(y2 - y1);
	let sx = Math.sign(x2 - x1);
	let sy = Math.sign(y2 - y1);
	let e = 2 * dy - dx;
	let dx2 = 2 * dx;
	let dy2 = 2 * dy;
	
	if (dx == 0 || dy == 0) {
		let si = (y1 + yr * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (x1 + yw * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		return;
	}
	
	for (let i = 0; i <= dx; i += 1) {
		let si = (y1 + yr * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (x1 + yw * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		while (e >= 0) {
			y1 += sy;
			e -= dx2;
		}

		x1 += sx;
		e += dy2;
	}
}

function stretchY(src, dst, x1, y1, x2, y2, yr, yw) {
	let dx = abs(x2 - x1);
	let dy = abs(y2 - y1);
	let sx = Math.sign(x2 - x1);
	let sy = Math.sign(y2 - y1);
	let e = 2 * dy - dx;
	let dx2 = 2 * dx;
	let dy2 = 2 * dy;
	
	if (dx == 0 || dy == 0) {
		let si = (yr + y1 * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (yw + x1 * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		return;
	}
	
	for (let i = 0; i <= dx; i += 1) {
		let si = (yr + y1 * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (yw + x1 * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		while (e >= 0) {
			y1 += sy;
			e -= dx2;
		}

		x1 += sx;
		e += dy2;
	}
}

// algebraically simplified linear interpolation
function lrp_simple(a, b, f) {
    return a + f * (b - a);
}

function draw() {
	offscreen_canvas.background(0);
	shape_canvas.background(0);
	
	//offscreen_canvas.rect(0, 0, offscreen_canvas.width, offscreen_canvas.height);
	
	img.loadPixels();
	shape_canvas.loadPixels();
	offscreen_canvas.loadPixels();
	
	const v1 = { x: -1, y: -1 };
	const v2 = { x:  1, y: -1 };
	const v3 = { x:  1, y:  1 };
	const v4 = { x: -1, y:  1 };
	
	const w2 = shape_canvas.width / 2;
	
	const bbmin = min([round(w2 + v1.x * w2), round(w2 + v2.x * w2), round(w2 + v3.x * w2), round(w2 + v4.x * w2)]);
	const bbmax = max([round(w2 + v1.x * w2), round(w2 + v2.x * w2), round(w2 + v3.x * w2), round(w2 + v4.x * w2)]);
	const bbw = abs(bbmin - bbmax);
	const bby = 0;//min([round(w2 + v1.y * w2), round(w2 + v4.y * w2)]);
	const bbh = shape_canvas.height;//abs(round((w2 + v1.y * w2) - (w2 + v4.y * w2)));

	for (let y = 0; y < shape_canvas.height; y += 1) {
		let ny = y / shape_canvas.height;
		stretchX(img, shape_canvas,
						round(w2 + lrp_simple(v1.x, v4.x, ny) * w2), 
						0,
						round(w2 + lrp_simple(v2.x, v3.x, ny) * w2),
						img.width,
						round(ny * img.height),
						y);//round(h2 + lrp_simple(v1.y, v4.y, ny) * h2));
	}
	shape_canvas.updatePixels();

	let h2 = offscreen_canvas.height / 2;
	for (let x = 0; x < bbw; x += 1) {
		let nx = x / bbw;
		stretchY(shape_canvas, offscreen_canvas,
						round(h2 + lrp_simple(v1.y, v2.y, nx) * h2), 
						bby,
						round(h2 + lrp_simple(v4.y, v3.y, nx) * h2),
						bby + bbh,
						bbmin + x,
						bbmin + x);//round(w2 + lrp_simple(bbmin / shape_canvas.width * 2 - 1, bbmax / shape_canvas.width * 2 - 1, nx) * bbw));
	}
	offscreen_canvas.updatePixels();

	image(offscreen_canvas, 0, 0, width, height);
	//image(shape_canvas, 0, 0, width, height);
	
	rect(bbmin, bby, bbw, bbh);
}"
"1050568","Quads rasterizer","mySketch","let img;
function preload() {
  img = loadImage('2048_texture.jpg');
}

let aa = 1;

let shape_canvas;
let offscreen_canvas;
function setup() {
	createCanvas(600, 600);
	
	shape_canvas = createGraphics(width * aa, height * aa);
	offscreen_canvas = createGraphics(width * aa, height * aa);
	
	stroke(255, 255, 255);
	noFill();
}

function stretchX(src, dst, x1, y1, x2, y2, yr, yw) {
	let dx = abs(x2 - x1);
	let dy = abs(y2 - y1);
	let sx = Math.sign(x2 - x1);
	let sy = Math.sign(y2 - y1);
	let e = 2 * dy - dx;
	let dx2 = 2 * dx;
	let dy2 = 2 * dy;
	
	if (dx == 0 || dy == 0) {
		let si = (y1 + yr * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (x1 + yw * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		return;
	}
	
	for (let i = 0; i <= dx; i += 1) {
		let si = (y1 + yr * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (x1 + yw * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		while (e >= 0) {
			y1 += sy;
			e -= dx2;
		}

		x1 += sx;
		e += dy2;
	}
}

function vrotateX(v, r) {
	let a =  cos(r) * v.y + sin(r) * v.z;
	let b = -sin(r) * v.y + cos(r) * v.z;
	
	v.y = a;
	v.z = b;
}

function vrotateY(v, r) {
	let a =  cos(r) * v.x + sin(r) * v.z;
	let b = -sin(r) * v.x + cos(r) * v.z;
	
	v.x = a;
	v.z = b;
}

function stretchY(src, dst, x1, y1, x2, y2, yr, yw) {
	let dx = abs(x2 - x1);
	let dy = abs(y2 - y1);
	let sx = Math.sign(x2 - x1);
	let sy = Math.sign(y2 - y1);
	let e = 2 * dy - dx;
	let dx2 = 2 * dx;
	let dy2 = 2 * dy;
	
	if (dx == 0 || dy == 0) {
		let si = (yr + y1 * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (yw + x1 * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		return;
	}
	
	for (let i = 0; i <= dx; i += 1) {
		let si = (yr + y1 * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (yw + x1 * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		while (e >= 0) {
			y1 += sy;
			e -= dx2;
		}

		x1 += sx;
		e += dy2;
	}
}

// algebraically simplified linear interpolation
function lrp_simple(a, b, f) {
    return a + f * (b - a);
}

function draw() {
	offscreen_canvas.background(0);
	shape_canvas.background(0);
	
	//offscreen_canvas.rect(0, 0, offscreen_canvas.width, offscreen_canvas.height);
	
	img.loadPixels();
	shape_canvas.loadPixels();
	offscreen_canvas.loadPixels();
	
	const v1 = { x: -1, y: -1, z: 0 };
	const v2 = { x:  1, y: -1, z: 0 };
	const v3 = { x:  1, y:  1, z: 0 };
	const v4 = { x: -1, y:  1, z: 0 };
	
	vrotateX(v1, frameCount / 40);
	vrotateX(v2, frameCount / 40);
	vrotateX(v3, frameCount / 40);
	vrotateX(v4, frameCount / 40);
	
	vrotateY(v1, frameCount / 40);
	vrotateY(v2, frameCount / 40);
	vrotateY(v3, frameCount / 40);
	vrotateY(v4, frameCount / 40);
	
	const w2 = shape_canvas.width / 2;
	
	const bbmin = min([round(w2 + v1.x * w2), round(w2 + v2.x * w2), round(w2 + v3.x * w2), round(w2 + v4.x * w2)]);
	const bbmax = max([round(w2 + v1.x * w2), round(w2 + v2.x * w2), round(w2 + v3.x * w2), round(w2 + v4.x * w2)]);
	const bbw = abs(bbmin - bbmax);
	const bby = 0;//min([round(w2 + v1.y * w2), round(w2 + v4.y * w2)]);
	const bbh = shape_canvas.height;//abs(round((w2 + v1.y * w2) - (w2 + v4.y * w2)));

	for (let y = 0; y < shape_canvas.height; y += 1) {
		let ny = y / shape_canvas.height;
		stretchX(img, shape_canvas,
						round(w2 + lrp_simple(v1.x, v4.x, ny) * w2), 
						0,
						round(w2 + lrp_simple(v2.x, v3.x, ny) * w2),
						img.width,
						round(ny * img.height),
						y);//round(h2 + lrp_simple(v1.y, v4.y, ny) * h2));
	}
	shape_canvas.updatePixels();

	let h2 = offscreen_canvas.height / 2;
	for (let x = 0; x < bbw; x += 1) {
		let nx = x / bbw;
		stretchY(shape_canvas, offscreen_canvas,
						round(h2 + lrp_simple(v1.y, v2.y, nx) * h2), 
						bby,
						round(h2 + lrp_simple(v4.y, v3.y, nx) * h2),
						bby + bbh,
						bbmin + x,
						bbmin + x);//round(w2 + lrp_simple(bbmin / shape_canvas.width * 2 - 1, bbmax / shape_canvas.width * 2 - 1, nx) * bbw));
	}
	offscreen_canvas.updatePixels();

	image(offscreen_canvas, 0, 0, width, height);
	//image(shape_canvas, 0, 0, width, height);
	
	// debug first shear bbox
	//rect(bbmin, bby, bbw, bbh);
}"
"1050568","Quads rasterizer","mySketch","let img;
function preload() {
  img = loadImage('2048_texture.jpg');
}

let aa = 1;

let shape_canvas;
let offscreen_canvas;
function setup() {
	createCanvas(600, 600);
	
	shape_canvas = createGraphics(width * aa, height * aa);
	offscreen_canvas = createGraphics(width * aa, height * aa);
	
	stroke(255, 255, 255);
	noFill();
}

function stretchX(src, dst, x1, y1, x2, y2, yr, yw) {
	let dx = abs(x2 - x1);
	let dy = abs(y2 - y1);
	let sx = Math.sign(x2 - x1);
	let sy = Math.sign(y2 - y1);
	let e = 2 * dy - dx;
	let dx2 = 2 * dx;
	let dy2 = 2 * dy;
	
	if (dx == 0 || dy == 0) {
		let si = (y1 + yr * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (x1 + yw * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		return;
	}
	
	for (let i = 0; i <= dx; i += 1) {
		let si = (y1 + yr * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (x1 + yw * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		while (e >= 0) {
			y1 += sy;
			e -= dx2;
		}

		x1 += sx;
		e += dy2;
	}
}

function vrotateX(v, r) {
	let a =  cos(r) * v.y + sin(r) * v.z;
	let b = -sin(r) * v.y + cos(r) * v.z;
	
	v.y = a;
	v.z = b;
}

function vrotateY(v, r) {
	let a =  cos(r) * v.x + sin(r) * v.z;
	let b = -sin(r) * v.x + cos(r) * v.z;
	
	v.x = a;
	v.z = b;
}

function vrotateZ(v, r) {
	let a =  cos(r) * v.x + sin(r) * v.y;
	let b = -sin(r) * v.x + cos(r) * v.y;
	
	v.x = a;
	v.y = b;
}

function uscale(v, s) {
	v.x *= s;
	v.y *= s;
	v.z *= s;
}

function project(v) {
	v.x /= (v.z + 100) * 0.01;
	v.y /= (v.z + 100) * 0.01;
}

function stretchY(src, dst, x1, y1, x2, y2, yr, yw) {
	let dx = abs(x2 - x1);
	let dy = abs(y2 - y1);
	let sx = Math.sign(x2 - x1);
	let sy = Math.sign(y2 - y1);
	let e = 2 * dy - dx;
	let dx2 = 2 * dx;
	let dy2 = 2 * dy;
	
	if (dx == 0 || dy == 0) {
		let si = (yr + y1 * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (yw + x1 * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		return;
	}
	
	for (let i = 0; i <= dx; i += 1) {
		let si = (yr + y1 * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (yw + x1 * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		while (e >= 0) {
			y1 += sy;
			e -= dx2;
		}

		x1 += sx;
		e += dy2;
	}
}

// algebraically simplified linear interpolation
function lrp_simple(a, b, f) {
    return a + f * (b - a);
}

function draw() {
	offscreen_canvas.background(0);
	shape_canvas.background(0);
	
	//offscreen_canvas.rect(0, 0, offscreen_canvas.width, offscreen_canvas.height);
	
	img.loadPixels();
	shape_canvas.loadPixels();
	offscreen_canvas.loadPixels();
	
	const v1 = { x: -1, y: -1, z: -1 };
	const v2 = { x:  1, y: -1, z: 0 };
	const v3 = { x:  1, y:  1, z: 0 };
	const v4 = { x: -1, y:  1, z: 0 };
	
	uscale(v1, 0.75);
	uscale(v2, 0.75);
	uscale(v3, 0.75);
	uscale(v4, 0.75);
	
	vrotateX(v1, frameCount / 60);
	vrotateX(v2, frameCount / 60);
	vrotateX(v3, frameCount / 60);
	vrotateX(v4, frameCount / 60);
	
	vrotateY(v1, frameCount / 80+1);
	vrotateY(v2, frameCount / 80+1);
	vrotateY(v3, frameCount / 80+1);
	vrotateY(v4, frameCount / 80+1);
	
	vrotateZ(v1, frameCount / 50);
	vrotateZ(v2, frameCount / 50);
	vrotateZ(v3, frameCount / 50);
	vrotateZ(v4, frameCount / 50);
	
	project(v1);
	project(v2);
	project(v3);
	project(v4);
	
	const w2 = shape_canvas.width / 2;
	
	const bbmin = min([round(w2 + v1.x * w2), round(w2 + v2.x * w2), round(w2 + v3.x * w2), round(w2 + v4.x * w2)]);
	const bbmax = max([round(w2 + v1.x * w2), round(w2 + v2.x * w2), round(w2 + v3.x * w2), round(w2 + v4.x * w2)]);
	const bbw = abs(bbmin - bbmax);
	const bby = 0;//min([round(w2 + v1.y * w2), round(w2 + v4.y * w2)]);
	const bbh = shape_canvas.height;//abs(round((w2 + v1.y * w2) - (w2 + v4.y * w2)));

	for (let y = 0; y < shape_canvas.height; y += 1) {
		let ny = y / shape_canvas.height;
		stretchX(img, shape_canvas,
						round(w2 + lrp_simple(v1.x, v4.x, ny) * w2), 
						0,
						round(w2 + lrp_simple(v2.x, v3.x, ny) * w2),
						img.width,
						round(ny * img.height),
						y);//round(h2 + lrp_simple(v1.y, v4.y, ny) * h2));
	}
	shape_canvas.updatePixels();

	let h2 = offscreen_canvas.height / 2;
	for (let x = 0; x < bbw; x += 1) {
		let nx = x / bbw;
		stretchY(shape_canvas, offscreen_canvas,
						round(h2 + lrp_simple(v1.y, v2.y, nx) * h2), 
						bby,
						round(h2 + lrp_simple(v4.y, v3.y, nx) * h2),
						bby + bbh,
						bbmin + x,
						bbmin + x);//round(w2 + lrp_simple(bbmin / shape_canvas.width * 2 - 1, bbmax / shape_canvas.width * 2 - 1, nx) * bbw));
	}
	offscreen_canvas.updatePixels();

	image(offscreen_canvas, 0, 0, width, height);
	//image(shape_canvas, 0, 0, width, height);
	
	// debug first shear bbox
	//rect(bbmin, bby, bbw, bbh);
}"
"1050568","Quads rasterizer","mySketch","/*
  this is a 3d quad software rasterizer experiment
  started from several ideas, inspired first by how the Sega Saturn rendered quads (no triangles there!) then stumbled upon a fast stretcher algorithm in graphics gem 3 book
  the idea is very simple and is basically to stretch a bitmap horizontally then vertically (two pass) to make it act like a polygon, of course it come with artefacts but it somehow look close
  i think this was used in several software rendered demos in the 80s / 90s on low end hardware because then you could shear anything on screen with a combination
  of vblank and hblank (scanline offset) which was almost free since it was provided by the hardware...
	
*/

let img;
function preload() {
  img = loadImage('2048_texture.jpg');
}

// anti-aliasing (supersampling)
let aa = 1;

let shape_canvas;
let offscreen_canvas;
function setup() {
	createCanvas(800, 800);
	
	shape_canvas = createGraphics(width * aa, height * aa);
	offscreen_canvas = createGraphics(width * aa, height * aa);
	
	stroke(255, 255, 255);
	noFill();
}

// integer algorithm for stretching a bitmap (very fast)
// source : Fast bitmap stretching by Tomas Möller - Graphics Gems 3
function stretchX(src, dst, x1, y1, x2, y2, yr, yw) {
	let dx = abs(x2 - x1);
	let dy = abs(y2 - y1);
	let sx = Math.sign(x2 - x1);
	let sy = Math.sign(y2 - y1);
	let e = 2 * dy - dx;
	let dx2 = 2 * dx;
	let dy2 = 2 * dy;
	
	if (dx == 0 || dy == 0) {
		let si = (y1 + yr * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (x1 + yw * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		return;
	}
	
	for (let i = 0; i <= dx; i += 1) {
		let si = (y1 + yr * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (x1 + yw * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		while (e >= 0) {
			y1 += sy;
			e -= dx2;
		}

		x1 += sx;
		e += dy2;
	}
}

function stretchY(src, dst, x1, y1, x2, y2, yr, yw) {
	let dx = abs(x2 - x1);
	let dy = abs(y2 - y1);
	let sx = Math.sign(x2 - x1);
	let sy = Math.sign(y2 - y1);
	let e = 2 * dy - dx;
	let dx2 = 2 * dx;
	let dy2 = 2 * dy;
	
	if (dx == 0 || dy == 0) {
		let si = (yr + y1 * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (yw + x1 * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		return;
	}
	
	for (let i = 0; i <= dx; i += 1) {
		let si = (yr + y1 * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (yw + x1 * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		while (e >= 0) {
			y1 += sy;
			e -= dx2;
		}

		x1 += sx;
		e += dy2;
	}
}

// some 3d stuff
function vrotateX(v, r) {
	let a =  cos(r) * v.y + sin(r) * v.z;
	let b = -sin(r) * v.y + cos(r) * v.z;
	
	v.y = a;
	v.z = b;
}

function vrotateY(v, r) {
	let a =  cos(r) * v.x + sin(r) * v.z;
	let b = -sin(r) * v.x + cos(r) * v.z;
	
	v.x = a;
	v.z = b;
}

function vrotateZ(v, r) {
	let a =  cos(r) * v.x + sin(r) * v.y;
	let b = -sin(r) * v.x + cos(r) * v.y;
	
	v.x = a;
	v.y = b;
}

function uscale(v, s) {
	v.x *= s;
	v.y *= s;
	v.z *= s;
}

function project(v) {
	v.x /= (v.z + 200) * 0.01;
	v.y /= (v.z + 200) * 0.01;
}

// algebraically simplified linear interpolation
function lrp_simple(a, b, f) {
    return a + f * (b - a);
}

function draw() {
	offscreen_canvas.background(0);
	shape_canvas.background(0);
	
	//offscreen_canvas.rect(0, 0, offscreen_canvas.width, offscreen_canvas.height);
	
	img.loadPixels();
	shape_canvas.loadPixels();
	offscreen_canvas.loadPixels();
	
	// a quad
	const v1 = { x: -1, y: -1, z: -1 };
	const v2 = { x:  1, y: -1, z: 0 };
	const v3 = { x:  1, y:  1, z: 0 };
	const v4 = { x: -1, y:  1, z: 0 };
	
	// apply transforms (scale, rotate, project)
	let scale = 1;
	
	uscale(v1, scale);
	uscale(v2, scale);
	uscale(v3, scale);
	uscale(v4, scale);
	
	vrotateX(v1, frameCount / 60);
	vrotateX(v2, frameCount / 60);
	vrotateX(v3, frameCount / 60);
	vrotateX(v4, frameCount / 60);
	
	vrotateY(v1, frameCount / 80+1);
	vrotateY(v2, frameCount / 80+1);
	vrotateY(v3, frameCount / 80+1);
	vrotateY(v4, frameCount / 80+1);
	/*
	vrotateZ(v1, frameCount / 50);
	vrotateZ(v2, frameCount / 50);
	vrotateZ(v3, frameCount / 50);
	vrotateZ(v4, frameCount / 50);
	*/
	project(v1);
	project(v2);
	project(v3);
	project(v4);
	
	const w2 = shape_canvas.width / 2;
	
	// compute the bouding box of the first shear (horizontal stretch)
	const bbmin = min([round(w2 + v1.x * w2), round(w2 + v2.x * w2), round(w2 + v3.x * w2), round(w2 + v4.x * w2)]);
	const bbmax = max([round(w2 + v1.x * w2), round(w2 + v2.x * w2), round(w2 + v3.x * w2), round(w2 + v4.x * w2)]);
	const bbw = abs(bbmin - bbmax);
	const bby = 0;//min([round(w2 + v1.y * w2), round(w2 + v4.y * w2)]);
	const bbh = shape_canvas.height;//abs(round((w2 + v1.y * w2) - (w2 + v4.y * w2)));

	for (let y = 0; y < shape_canvas.height; y += 1) {
		let ny = y / shape_canvas.height;
		stretchX(img, shape_canvas,
						round(w2 + lrp_simple(v1.x, v4.x, ny) * w2), 
						0, // uv u start
						round(w2 + lrp_simple(v2.x, v3.x, ny) * w2),
						img.width, // uv u end
						round(ny * img.height), // uv v
						y);//round(h2 + lrp_simple(v1.y, v4.y, ny) * h2));
	}
	shape_canvas.updatePixels();

	// compute vertical shear from the horizontal shear
	let h2 = offscreen_canvas.height / 2;
	for (let x = 0; x < bbw; x += 1) {
		let nx = x / bbw;
		stretchY(shape_canvas, offscreen_canvas,
						round(h2 + lrp_simple(v1.y, v2.y, nx) * h2), 
						bby,
						round(h2 + lrp_simple(v4.y, v3.y, nx) * h2),
						bby + bbh,
						bbmin + x,
						bbmin + x);//round(w2 + lrp_simple(bbmin / shape_canvas.width * 2 - 1, bbmax / shape_canvas.width * 2 - 1, nx) * bbw));
	}
	offscreen_canvas.updatePixels();

	image(offscreen_canvas, 0, 0, width, height);
	//image(shape_canvas, 0, 0, width, height);
	
	// debug first shear bbox
	//rect(bbmin, bby, bbw, bbh);
}"
"1050568","Quads rasterizer","mySketch","/*
  this is a 3d quad software rasterizer experiment
  started from several ideas, inspired first by how the Sega Saturn rendered quads (no triangles there!) then stumbled upon a fast stretcher algorithm in graphics gem 3 book
  the idea is very simple and is basically to stretch a bitmap horizontally then vertically (two pass) to make it act like a polygon, of course it come with artefacts but it somehow look close
	
  i think this was used in several software rendered demos in the 80s / 90s on low end hardware because then you could shear anything on screen with a combination
  of vblank and hblank (scanline offset) which was almost free since it was provided by the hardware...
	
	this renderer could probably be used without issues for any Parallel projection stuff (isometric etc.) since it act best when edges are parallel to each others
	this demo try to do 'perspective projection', it is rather nice but it have issues since the second pass stretch / bend everything on its way thus it may look distorted on certain vertex configurations
*/

let img;
function preload() {
  img = loadImage('2048_texture.jpg');
}

// anti-aliasing (supersampling)
let aa = 1;

let shape_canvas;
let offscreen_canvas;
function setup() {
	createCanvas(800, 800);
	
	shape_canvas = createGraphics(width * aa, height * aa);
	offscreen_canvas = createGraphics(width * aa, height * aa);
	
	stroke(255, 255, 255);
	noFill();
}

// integer algorithm for stretching a bitmap (very fast)
// source : Fast bitmap stretching by Tomas Möller - Graphics Gems 3
function stretchX(src, dst, x1, y1, x2, y2, yr, yw) {
	let dx = abs(x2 - x1);
	let dy = abs(y2 - y1);
	let sx = Math.sign(x2 - x1);
	let sy = Math.sign(y2 - y1);
	let e = 2 * dy - dx;
	let dx2 = 2 * dx;
	let dy2 = 2 * dy;
	
	if (dx == 0 || dy == 0) {
		let si = (y1 + yr * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (x1 + yw * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		return;
	}
	
	for (let i = 0; i <= dx; i += 1) {
		let si = (y1 + yr * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (x1 + yw * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		while (e >= 0) {
			y1 += sy;
			e -= dx2;
		}

		x1 += sx;
		e += dy2;
	}
}

function stretchY(src, dst, x1, y1, x2, y2, yr, yw) {
	let dx = abs(x2 - x1);
	let dy = abs(y2 - y1);
	let sx = Math.sign(x2 - x1);
	let sy = Math.sign(y2 - y1);
	let e = 2 * dy - dx;
	let dx2 = 2 * dx;
	let dy2 = 2 * dy;
	
	if (dx == 0 || dy == 0) {
		let si = (yr + y1 * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (yw + x1 * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		return;
	}
	
	for (let i = 0; i <= dx; i += 1) {
		let si = (yr + y1 * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (yw + x1 * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		while (e >= 0) {
			y1 += sy;
			e -= dx2;
		}

		x1 += sx;
		e += dy2;
	}
}

// some 3d stuff
function vrotateX(v, r) {
	let a =  cos(r) * v.y + sin(r) * v.z;
	let b = -sin(r) * v.y + cos(r) * v.z;
	
	v.y = a;
	v.z = b;
}

function vrotateY(v, r) {
	let a =  cos(r) * v.x + sin(r) * v.z;
	let b = -sin(r) * v.x + cos(r) * v.z;
	
	v.x = a;
	v.z = b;
}

function vrotateZ(v, r) {
	let a =  cos(r) * v.x + sin(r) * v.y;
	let b = -sin(r) * v.x + cos(r) * v.y;
	
	v.x = a;
	v.y = b;
}

function uscale(v, s) {
	v.x *= s;
	v.y *= s;
	v.z *= s;
}

function project(v) {
	v.x /= (v.z + 200) * 0.01;
	v.y /= (v.z + 200) * 0.01;
}

// algebraically simplified linear interpolation
function lrp_simple(a, b, f) {
    return a + f * (b - a);
}

function draw() {
	offscreen_canvas.background(0);
	shape_canvas.background(0);
	
	//offscreen_canvas.rect(0, 0, offscreen_canvas.width, offscreen_canvas.height);
	
	img.loadPixels();
	shape_canvas.loadPixels();
	offscreen_canvas.loadPixels();
	
	// a quad
	const v1 = { x: -1, y: -1, z: -1 };
	const v2 = { x:  1, y: -1, z: 0 };
	const v3 = { x:  1, y:  1, z: 0 };
	const v4 = { x: -1, y:  1, z: 0 };
	
	// apply transforms (scale, rotate, project)
	let scale = 1;
	
	uscale(v1, scale);
	uscale(v2, scale);
	uscale(v3, scale);
	uscale(v4, scale);
	
	vrotateX(v1, frameCount / 60);
	vrotateX(v2, frameCount / 60);
	vrotateX(v3, frameCount / 60);
	vrotateX(v4, frameCount / 60);
	
	vrotateY(v1, frameCount / 80+1);
	vrotateY(v2, frameCount / 80+1);
	vrotateY(v3, frameCount / 80+1);
	vrotateY(v4, frameCount / 80+1);
	/*
	vrotateZ(v1, frameCount / 50);
	vrotateZ(v2, frameCount / 50);
	vrotateZ(v3, frameCount / 50);
	vrotateZ(v4, frameCount / 50);
	*/
	project(v1);
	project(v2);
	project(v3);
	project(v4);
	
	const w2 = shape_canvas.width / 2;
	
	// compute the bouding box of the first shear (horizontal stretch)
	const bbmin = min([round(w2 + v1.x * w2), round(w2 + v2.x * w2), round(w2 + v3.x * w2), round(w2 + v4.x * w2)]);
	const bbmax = max([round(w2 + v1.x * w2), round(w2 + v2.x * w2), round(w2 + v3.x * w2), round(w2 + v4.x * w2)]);
	const bbw = abs(bbmin - bbmax);
	const bby = 0;//min([round(w2 + v1.y * w2), round(w2 + v4.y * w2)]);
	const bbh = shape_canvas.height;//abs(round((w2 + v1.y * w2) - (w2 + v4.y * w2)));

	for (let y = 0; y < shape_canvas.height; y += 1) {
		let ny = y / shape_canvas.height;
		stretchX(img, shape_canvas,
						round(w2 + lrp_simple(v1.x, v4.x, ny) * w2), 
						0, // uv u start
						round(w2 + lrp_simple(v2.x, v3.x, ny) * w2),
						img.width, // uv u end
						round(ny * img.height), // uv v
						y);//round(h2 + lrp_simple(v1.y, v4.y, ny) * h2));
	}
	shape_canvas.updatePixels();

	// compute vertical shear from the horizontal shear
	let h2 = offscreen_canvas.height / 2;
	for (let x = 0; x < bbw; x += 1) {
		let nx = x / bbw;
		stretchY(shape_canvas, offscreen_canvas,
						round(h2 + lrp_simple(v1.y, v2.y, nx) * h2), 
						bby,
						round(h2 + lrp_simple(v4.y, v3.y, nx) * h2),
						bby + bbh,
						bbmin + x,
						bbmin + x);//round(w2 + lrp_simple(bbmin / shape_canvas.width * 2 - 1, bbmax / shape_canvas.width * 2 - 1, nx) * bbw));
	}
	offscreen_canvas.updatePixels();

	image(offscreen_canvas, 0, 0, width, height);
	//image(shape_canvas, 0, 0, width, height);
	
	// debug first shear bbox
	//rect(bbmin, bby, bbw, bbh);
}"
"1050568","Quads rasterizer","mySketch","/*
  this is a 3d quad software rasterizer experiment
  started from several ideas, inspired first by how the Sega Saturn rendered quads (no triangles there!) then stumbled upon a fast stretcher algorithm in graphics gem 3 book
  the idea is very simple and is basically to stretch a bitmap horizontally then vertically (two pass) to make it act like a polygon, of course it come with artefacts but it somehow look close
	
  i think this was used in several software rendered demos in the 80s / 90s on low end hardware because then you could shear anything on screen with a combination
  of vblank and hblank (scanline offset) which was almost free since it was provided by the hardware...
	
	this renderer could probably be used without issues for any Parallel projection stuff (isometric etc.) since it act best when edges are parallel to each others
	this demo try to do 'perspective projection', it is rather nice but it have issues since the second pass stretch / bend everything on its way thus it may look distorted on certain vertex configurations
*/

let img;
function preload() {
  img = loadImage('2048_texture.jpg');
}

// anti-aliasing (supersampling)
let aa = 1;

let shape_canvas;
let offscreen_canvas;
function setup() {
	createCanvas(800, 800);
	
	shape_canvas = createGraphics(width * aa, height * aa);
	offscreen_canvas = createGraphics(width * aa, height * aa);
	
	stroke(255, 255, 255);
	noFill();
}

// integer algorithm for stretching a bitmap (very fast)
// source : Fast bitmap stretching by Tomas Möller - Graphics Gems 3
function stretchX(src, dst, x1, y1, x2, y2, yr, yw) {
	let dx = abs(x2 - x1);
	let dy = abs(y2 - y1);
	let sx = Math.sign(x2 - x1);
	let sy = Math.sign(y2 - y1);
	let e = 2 * dy - dx;
	let dx2 = 2 * dx;
	let dy2 = 2 * dy;
	
	if (dx == 0 || dy == 0) {
		let si = (y1 + yr * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (x1 + yw * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		return;
	}
	
	for (let i = 0; i <= dx; i += 1) {
		let si = (y1 + yr * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (x1 + yw * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		while (e >= 0) {
			y1 += sy;
			e -= dx2;
		}

		x1 += sx;
		e += dy2;
	}
}

function stretchY(src, dst, x1, y1, x2, y2, yr, yw) {
	let dx = abs(x2 - x1);
	let dy = abs(y2 - y1);
	let sx = Math.sign(x2 - x1);
	let sy = Math.sign(y2 - y1);
	let e = 2 * dy - dx;
	let dx2 = 2 * dx;
	let dy2 = 2 * dy;
	
	if (dx == 0 || dy == 0) {
		let si = (yr + y1 * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (yw + x1 * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		return;
	}
	
	for (let i = 0; i <= dx; i += 1) {
		let si = (yr + y1 * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (yw + x1 * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		while (e >= 0) {
			y1 += sy;
			e -= dx2;
		}

		x1 += sx;
		e += dy2;
	}
}

// some 3d stuff
function vrotateX(v, r) {
	let a =  cos(r) * v.y + sin(r) * v.z;
	let b = -sin(r) * v.y + cos(r) * v.z;
	
	v.y = a;
	v.z = b;
}

function vrotateY(v, r) {
	let a =  cos(r) * v.x + sin(r) * v.z;
	let b = -sin(r) * v.x + cos(r) * v.z;
	
	v.x = a;
	v.z = b;
}

function vrotateZ(v, r) {
	let a =  cos(r) * v.x + sin(r) * v.y;
	let b = -sin(r) * v.x + cos(r) * v.y;
	
	v.x = a;
	v.y = b;
}

function uscale(v, s) {
	v.x *= s;
	v.y *= s;
	v.z *= s;
}

function project(v) {
	v.x /= (v.z + 200) * 0.01;
	v.y /= (v.z + 200) * 0.01;
}

// algebraically simplified linear interpolation
function lrp_simple(a, b, f) {
    return a + f * (b - a);
}

function draw() {
	offscreen_canvas.background(0);
	//shape_canvas.background(0);
	
	//offscreen_canvas.rect(0, 0, offscreen_canvas.width, offscreen_canvas.height);
	
	img.loadPixels();
	shape_canvas.loadPixels();
	offscreen_canvas.loadPixels();
	
	// a quad
	const v1 = { x: -1, y: -1, z: -1 };
	const v2 = { x:  1, y: -1, z: 0 };
	const v3 = { x:  1, y:  1, z: 0 };
	const v4 = { x: -1, y:  1, z: 0 };
	
	// apply transforms (scale, rotate, project)
	let scale = 1;
	
	uscale(v1, scale);
	uscale(v2, scale);
	uscale(v3, scale);
	uscale(v4, scale);
	
	vrotateX(v1, frameCount / 60);
	vrotateX(v2, frameCount / 60);
	vrotateX(v3, frameCount / 60);
	vrotateX(v4, frameCount / 60);
	
	vrotateY(v1, frameCount / 80+1);
	vrotateY(v2, frameCount / 80+1);
	vrotateY(v3, frameCount / 80+1);
	vrotateY(v4, frameCount / 80+1);
	/*
	vrotateZ(v1, frameCount / 50);
	vrotateZ(v2, frameCount / 50);
	vrotateZ(v3, frameCount / 50);
	vrotateZ(v4, frameCount / 50);
	*/
	project(v1);
	project(v2);
	project(v3);
	project(v4);
	
	const w2 = shape_canvas.width / 2;
	
	// compute the bouding box of the first shear (horizontal stretch)
	const bbmin = min([round(w2 + v1.x * w2), round(w2 + v2.x * w2), round(w2 + v3.x * w2), round(w2 + v4.x * w2)]);
	const bbmax = max([round(w2 + v1.x * w2), round(w2 + v2.x * w2), round(w2 + v3.x * w2), round(w2 + v4.x * w2)]);
	const bbw = abs(bbmin - bbmax);
	const bby = 0;//min([round(w2 + v1.y * w2), round(w2 + v4.y * w2)]);
	const bbh = shape_canvas.height;//abs(round((w2 + v1.y * w2) - (w2 + v4.y * w2)));

	for (let y = 0; y < shape_canvas.height; y += 1) {
		let ny = y / shape_canvas.height;
		stretchX(img, shape_canvas,
						round(w2 + lrp_simple(v1.x, v4.x, ny) * w2), 
						0, // uv u start
						round(w2 + lrp_simple(v2.x, v3.x, ny) * w2),
						img.width, // uv u end
						round(ny * img.height), // uv v
						y);//round(h2 + lrp_simple(v1.y, v4.y, ny) * h2));
	}
	//shape_canvas.updatePixels();

	// compute vertical shear from the horizontal shear
	let h2 = offscreen_canvas.height / 2;
	for (let x = 0; x < bbw; x += 1) {
		let nx = x / bbw;
		stretchY(shape_canvas, offscreen_canvas,
						round(h2 + lrp_simple(v1.y, v2.y, nx) * h2), 
						bby,
						round(h2 + lrp_simple(v4.y, v3.y, nx) * h2),
						bby + bbh,
						bbmin + x,
						bbmin + x);//round(w2 + lrp_simple(bbmin / shape_canvas.width * 2 - 1, bbmax / shape_canvas.width * 2 - 1, nx) * bbw));
	}
	offscreen_canvas.updatePixels();

	image(offscreen_canvas, 0, 0, width, height);
	//image(shape_canvas, 0, 0, width, height);
	
	// debug first shear bbox
	//rect(bbmin, bby, bbw, bbh);
}"
"1050568","Quads rasterizer","mySketch","/*
  this is a 3d quad software rasterizer experiment
  started from several ideas, inspired first by how the Sega Saturn rendered quads (no triangles there!) then stumbled upon a fast stretcher algorithm in graphics gem 3 book
  the idea is very simple and is basically to stretch a bitmap horizontally then vertically (two pass) to make it act like a polygon, of course it come with artefacts but it somehow look close
	
  i think this was used in several software rendered demos in the 80s / 90s on low end hardware because then you could shear anything on screen with a combination
  of vblank and hblank (scanline offset) which was almost free since it was provided by the hardware...
	
	this renderer could probably be used without issues for any Parallel projection stuff (isometric etc.) since it act best when edges are parallel to each others
	this demo try to do 'perspective projection', it have issues since the second pass stretch / bend everything on its way thus it may look distorted on certain vertex configurations
*/

let img;
function preload() {
  img = loadImage('2048_texture.jpg');
}

// anti-aliasing (supersampling)
let aa = 1;

let shape_canvas;
let offscreen_canvas;
function setup() {
	createCanvas(800, 800);
	
	shape_canvas = createGraphics(width * aa, height * aa);
	offscreen_canvas = createGraphics(width * aa, height * aa);
	
	stroke(255, 255, 255);
	noFill();
}

// integer algorithm for stretching a bitmap (very fast)
// source : Fast bitmap stretching by Tomas Möller - Graphics Gems 3
function stretchX(src, dst, x1, y1, x2, y2, yr, yw) {
	let dx = abs(x2 - x1);
	let dy = abs(y2 - y1);
	let sx = Math.sign(x2 - x1);
	let sy = Math.sign(y2 - y1);
	let e = 2 * dy - dx;
	let dx2 = 2 * dx;
	let dy2 = 2 * dy;
	
	if (dx == 0 || dy == 0) {
		let si = (y1 + yr * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (x1 + yw * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		return;
	}
	
	for (let i = 0; i <= dx; i += 1) {
		let si = (y1 + yr * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (x1 + yw * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		while (e >= 0) {
			y1 += sy;
			e -= dx2;
		}

		x1 += sx;
		e += dy2;
	}
}

function stretchY(src, dst, x1, y1, x2, y2, yr, yw) {
	let dx = abs(x2 - x1);
	let dy = abs(y2 - y1);
	let sx = Math.sign(x2 - x1);
	let sy = Math.sign(y2 - y1);
	let e = 2 * dy - dx;
	let dx2 = 2 * dx;
	let dy2 = 2 * dy;
	
	if (dx == 0 || dy == 0) {
		let si = (yr + y1 * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (yw + x1 * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		return;
	}
	
	for (let i = 0; i <= dx; i += 1) {
		let si = (yr + y1 * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (yw + x1 * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		while (e >= 0) {
			y1 += sy;
			e -= dx2;
		}

		x1 += sx;
		e += dy2;
	}
}

// some 3d stuff
function vrotateX(v, r) {
	let a =  cos(r) * v.y + sin(r) * v.z;
	let b = -sin(r) * v.y + cos(r) * v.z;
	
	v.y = a;
	v.z = b;
}

function vrotateY(v, r) {
	let a =  cos(r) * v.x + sin(r) * v.z;
	let b = -sin(r) * v.x + cos(r) * v.z;
	
	v.x = a;
	v.z = b;
}

function vrotateZ(v, r) {
	let a =  cos(r) * v.x + sin(r) * v.y;
	let b = -sin(r) * v.x + cos(r) * v.y;
	
	v.x = a;
	v.y = b;
}

function uscale(v, s) {
	v.x *= s;
	v.y *= s;
	v.z *= s;
}

function project(v) {
	v.x /= (v.z + 200) * 0.01;
	v.y /= (v.z + 200) * 0.01;
}

// algebraically simplified linear interpolation
function lrp_simple(a, b, f) {
    return a + f * (b - a);
}

function draw() {
	offscreen_canvas.background(0);
	//shape_canvas.background(0);
	
	//offscreen_canvas.rect(0, 0, offscreen_canvas.width, offscreen_canvas.height);
	
	img.loadPixels();
	shape_canvas.loadPixels();
	offscreen_canvas.loadPixels();
	
	// a quad
	const v1 = { x: -1, y: -1, z: -1 };
	const v2 = { x:  1, y: -1, z: 0 };
	const v3 = { x:  1, y:  1, z: 0 };
	const v4 = { x: -1, y:  1, z: 0 };
	
	// apply transforms (scale, rotate, project)
	let scale = 1;
	
	uscale(v1, scale);
	uscale(v2, scale);
	uscale(v3, scale);
	uscale(v4, scale);
	
	vrotateX(v1, frameCount / 60);
	vrotateX(v2, frameCount / 60);
	vrotateX(v3, frameCount / 60);
	vrotateX(v4, frameCount / 60);
	
	vrotateY(v1, frameCount / 80+1);
	vrotateY(v2, frameCount / 80+1);
	vrotateY(v3, frameCount / 80+1);
	vrotateY(v4, frameCount / 80+1);
	/*
	vrotateZ(v1, frameCount / 50);
	vrotateZ(v2, frameCount / 50);
	vrotateZ(v3, frameCount / 50);
	vrotateZ(v4, frameCount / 50);
	*/
	project(v1);
	project(v2);
	project(v3);
	project(v4);
	
	const w2 = shape_canvas.width / 2;
	
	// compute the bouding box of the first shear (horizontal stretch)
	const bbmin = min([round(w2 + v1.x * w2), round(w2 + v2.x * w2), round(w2 + v3.x * w2), round(w2 + v4.x * w2)]);
	const bbmax = max([round(w2 + v1.x * w2), round(w2 + v2.x * w2), round(w2 + v3.x * w2), round(w2 + v4.x * w2)]);
	const bbw = abs(bbmin - bbmax);
	const bby = 0;//min([round(w2 + v1.y * w2), round(w2 + v4.y * w2)]);
	const bbh = shape_canvas.height;//abs(round((w2 + v1.y * w2) - (w2 + v4.y * w2)));

	for (let y = 0; y < shape_canvas.height; y += 1) {
		let ny = y / shape_canvas.height;
		stretchX(img, shape_canvas,
						round(w2 + lrp_simple(v1.x, v4.x, ny) * w2), 
						0, // uv u start
						round(w2 + lrp_simple(v2.x, v3.x, ny) * w2),
						img.width, // uv u end
						round(ny * img.height), // uv v
						y);//round(h2 + lrp_simple(v1.y, v4.y, ny) * h2));
	}
	//shape_canvas.updatePixels();

	// compute vertical shear from the horizontal shear
	let h2 = offscreen_canvas.height / 2;
	for (let x = 0; x < bbw; x += 1) {
		let nx = x / bbw;
		stretchY(shape_canvas, offscreen_canvas,
						round(h2 + lrp_simple(v1.y, v2.y, nx) * h2), 
						bby,
						round(h2 + lrp_simple(v4.y, v3.y, nx) * h2),
						bby + bbh,
						bbmin + x,
						bbmin + x);//round(w2 + lrp_simple(bbmin / shape_canvas.width * 2 - 1, bbmax / shape_canvas.width * 2 - 1, nx) * bbw));
	}
	offscreen_canvas.updatePixels();

	image(offscreen_canvas, 0, 0, width, height);
	//image(shape_canvas, 0, 0, width, height);
	
	// debug first shear bbox
	//rect(bbmin, bby, bbw, bbh);
}"
"1050568","Quads rasterizer","mySketch","/*
  this is a 3d quad software rasterizer experiment
  started from several ideas, inspired first by how the Sega Saturn rendered quads (no triangles there!) then stumbled upon a fast stretcher algorithm in graphics gem 3 book
  the idea is very simple and is basically to stretch a bitmap horizontally then vertically (two pass) to make it act like a polygon, of course it come with artefacts but it somehow look close
	
  i think this was used in several software rendered demos in the 80s / 90s on low end hardware because then you could shear anything on screen with a combination
  of vblank and hblank (scanline offset) which was almost free since it was provided by the hardware...
	
	this renderer could probably be used without issues for any Parallel projection stuff (isometric etc.) since it act best when edges are parallel to each others
	this demo try to do 'perspective projection', it have issues since the second pass stretch / bend everything on its way thus it may look distorted on certain vertex configurations
*/

let img;
function preload() {
  img = loadImage('2048_texture.jpg');
}

// anti-aliasing (supersampling)
let aa = 1;

let shape_canvas;
let offscreen_canvas;
function setup() {
	createCanvas(800, 800);
	
	shape_canvas = createGraphics(width * aa, height * aa);
	offscreen_canvas = createGraphics(width * aa, height * aa);
	
	stroke(255, 255, 255);
	noFill();
}

// integer algorithm for stretching a bitmap (very fast)
// source : Fast bitmap stretching by Tomas Möller - Graphics Gems 3
function stretchX(src, dst, x1, y1, x2, y2, yr, yw) {
	let dx = abs(x2 - x1);
	let dy = abs(y2 - y1);
	let sx = Math.sign(x2 - x1);
	let sy = Math.sign(y2 - y1);
	let e = 2 * dy - dx;
	let dx2 = 2 * dx;
	let dy2 = 2 * dy;
	
	if (dx == 0 || dy == 0) {
		let si = (y1 + yr * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (x1 + yw * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		return;
	}
	
	for (let i = 0; i <= dx; i += 1) {
		let si = (y1 + yr * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (x1 + yw * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		while (e >= 0) {
			y1 += sy;
			e -= dx2;
		}

		x1 += sx;
		e += dy2;
	}
}

function stretchY(src, dst, x1, y1, x2, y2, yr, yw) {
	let dx = abs(x2 - x1);
	let dy = abs(y2 - y1);
	let sx = Math.sign(x2 - x1);
	let sy = Math.sign(y2 - y1);
	let e = 2 * dy - dx;
	let dx2 = 2 * dx;
	let dy2 = 2 * dy;
	
	if (dx == 0 || dy == 0) {
		let si = (yr + y1 * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (yw + x1 * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		return;
	}
	
	for (let i = 0; i <= dx; i += 1) {
		let si = (yr + y1 * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (yw + x1 * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		while (e >= 0) {
			y1 += sy;
			e -= dx2;
		}

		x1 += sx;
		e += dy2;
	}
}

// some 3d stuff
function vrotateX(v, r) {
	let a =  cos(r) * v.y + sin(r) * v.z;
	let b = -sin(r) * v.y + cos(r) * v.z;
	
	v.y = a;
	v.z = b;
}

function vrotateY(v, r) {
	let a =  cos(r) * v.x + sin(r) * v.z;
	let b = -sin(r) * v.x + cos(r) * v.z;
	
	v.x = a;
	v.z = b;
}

function vrotateZ(v, r) {
	let a =  cos(r) * v.x + sin(r) * v.y;
	let b = -sin(r) * v.x + cos(r) * v.y;
	
	v.x = a;
	v.y = b;
}

function uscale(v, s) {
	v.x *= s;
	v.y *= s;
	v.z *= s;
}

function project(v) {
	v.x /= (v.z + 200) * 0.01;
	v.y /= (v.z + 200) * 0.01;
}

// algebraically simplified linear interpolation
function lrp_simple(a, b, f) {
    return a + f * (b - a);
}

function draw() {
	offscreen_canvas.background(0);
	//shape_canvas.background(0);
	
	//offscreen_canvas.rect(0, 0, offscreen_canvas.width, offscreen_canvas.height);
	
	img.loadPixels();
	shape_canvas.loadPixels();
	offscreen_canvas.loadPixels();
	
	// a quad
	const v1 = { x: -1, y: -1, z: -1 };
	const v2 = { x:  1, y: -1, z: -1 };
	const v3 = { x:  1, y:  1, z: -1 };
	const v4 = { x: -1, y:  1, z: -1 };
	
	// apply transforms (scale, rotate, project)
	let scale = 1;
	
	uscale(v1, scale);
	uscale(v2, scale);
	uscale(v3, scale);
	uscale(v4, scale);
	
	vrotateX(v1, frameCount / 60);
	vrotateX(v2, frameCount / 60);
	vrotateX(v3, frameCount / 60);
	vrotateX(v4, frameCount / 60);
	/*
	vrotateY(v1, frameCount / 80+1);
	vrotateY(v2, frameCount / 80+1);
	vrotateY(v3, frameCount / 80+1);
	vrotateY(v4, frameCount / 80+1);
	*/
	vrotateZ(v1, frameCount / 50);
	vrotateZ(v2, frameCount / 50);
	vrotateZ(v3, frameCount / 50);
	vrotateZ(v4, frameCount / 50);
	
	project(v1);
	project(v2);
	project(v3);
	project(v4);
	
	const w2 = shape_canvas.width / 2;
	
	// compute the bouding box of the first shear (horizontal stretch)
	const bbmin = min([round(w2 + v1.x * w2), round(w2 + v2.x * w2), round(w2 + v3.x * w2), round(w2 + v4.x * w2)]);
	const bbmax = max([round(w2 + v1.x * w2), round(w2 + v2.x * w2), round(w2 + v3.x * w2), round(w2 + v4.x * w2)]);
	const bbw = abs(bbmin - bbmax);
	const bby = 0;//min([round(w2 + v1.y * w2), round(w2 + v4.y * w2)]);
	const bbh = shape_canvas.height;//abs(round((w2 + v1.y * w2) - (w2 + v4.y * w2)));

	for (let y = 0; y < shape_canvas.height; y += 1) {
		let ny = y / shape_canvas.height;
		stretchX(img, shape_canvas,
						round(w2 + lrp_simple(v1.x, v4.x, ny) * w2), 
						0, // uv u start
						round(w2 + lrp_simple(v2.x, v3.x, ny) * w2),
						img.width, // uv u end
						round(ny * img.height), // uv v
						y);//round(h2 + lrp_simple(v1.y, v4.y, ny) * h2));
	}
	//shape_canvas.updatePixels();

	// compute vertical shear from the horizontal shear
	let h2 = offscreen_canvas.height / 2;
	for (let x = 0; x < bbw; x += 1) {
		let nx = x / bbw;
		stretchY(shape_canvas, offscreen_canvas,
						round(h2 + lrp_simple(v1.y, v2.y, nx) * h2), 
						bby,
						round(h2 + lrp_simple(v4.y, v3.y, nx) * h2),
						bby + bbh,
						bbmin + x,
						bbmin + x);//round(w2 + lrp_simple(bbmin / shape_canvas.width * 2 - 1, bbmax / shape_canvas.width * 2 - 1, nx) * bbw));
	}
	offscreen_canvas.updatePixels();

	image(offscreen_canvas, 0, 0, width, height);
	//image(shape_canvas, 0, 0, width, height);
	
	// debug first shear bbox
	//rect(bbmin, bby, bbw, bbh);
}"
"1050568","Quads rasterizer","mySketch","/*
  this is a 3d quad software rasterizer experiment
  started from several ideas, inspired first by how the Sega Saturn rendered quads (no triangles there!) then stumbled upon a fast stretcher algorithm in graphics gem 3 book
  the idea is very simple and is basically to stretch a bitmap horizontally then vertically (two pass) to make it act like a polygon, of course it come with artefacts but it somehow look close
	
  i think this was used in several software rendered demos in the 80s / 90s on low end hardware because then you could shear anything on screen with a combination
  of vblank and hblank (scanline offset) which was almost free since it was provided by the hardware...
	
	this renderer could probably be used without issues for any Parallel projection stuff (isometric etc.) since it act best when edges are parallel to each others
	this demo try to do 'perspective projection', it have issues since the second pass stretch / bend everything on its way thus it may look distorted on certain vertex configurations
*/

let img;
function preload() {
  img = loadImage('2048_texture.jpg');
}

// anti-aliasing (supersampling)
let aa = 1;

let shape_canvas;
let offscreen_canvas;
function setup() {
	createCanvas(800, 800);
	
	shape_canvas = createGraphics(width * aa, height * aa);
	offscreen_canvas = createGraphics(width * aa, height * aa);
	
	stroke(255, 255, 255);
	noFill();
}

// integer algorithm for stretching a bitmap (very fast)
// source : Fast bitmap stretching by Tomas Möller - Graphics Gems 3
function stretchX(src, dst, x1, y1, x2, y2, yr, yw) {
	let dx = abs(x2 - x1);
	let dy = abs(y2 - y1);
	let sx = Math.sign(x2 - x1);
	let sy = Math.sign(y2 - y1);
	let e = 2 * dy - dx;
	let dx2 = 2 * dx;
	let dy2 = 2 * dy;
	
	if (dx == 0 || dy == 0) {
		let si = (y1 + yr * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (x1 + yw * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		return;
	}
	
	for (let i = 0; i <= dx; i += 1) {
		let si = (y1 + yr * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (x1 + yw * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		while (e >= 0) {
			y1 += sy;
			e -= dx2;
		}

		x1 += sx;
		e += dy2;
	}
}

function stretchY(src, dst, x1, y1, x2, y2, yr, yw) {
	let dx = abs(x2 - x1);
	let dy = abs(y2 - y1);
	let sx = Math.sign(x2 - x1);
	let sy = Math.sign(y2 - y1);
	let e = 2 * dy - dx;
	let dx2 = 2 * dx;
	let dy2 = 2 * dy;
	
	if (dx == 0 || dy == 0) {
		let si = (yr + y1 * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (yw + x1 * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		return;
	}
	
	for (let i = 0; i <= dx; i += 1) {
		let si = (yr + y1 * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (yw + x1 * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		while (e >= 0) {
			y1 += sy;
			e -= dx2;
		}

		x1 += sx;
		e += dy2;
	}
}

// some 3d stuff
function vrotateX(v, r) {
	let a =  cos(r) * v.y + sin(r) * v.z;
	let b = -sin(r) * v.y + cos(r) * v.z;
	
	v.y = a;
	v.z = b;
}

function vrotateY(v, r) {
	let a =  cos(r) * v.x + sin(r) * v.z;
	let b = -sin(r) * v.x + cos(r) * v.z;
	
	v.x = a;
	v.z = b;
}

function vrotateZ(v, r) {
	let a =  cos(r) * v.x + sin(r) * v.y;
	let b = -sin(r) * v.x + cos(r) * v.y;
	
	v.x = a;
	v.y = b;
}

function uscale(v, s) {
	v.x *= s;
	v.y *= s;
	v.z *= s;
}

function project(v) {
	v.x /= (v.z + 200) * 0.01;
	v.y /= (v.z + 200) * 0.01;
}

// algebraically simplified linear interpolation
function lrp_simple(a, b, f) {
    return a + f * (b - a);
}

function draw() {
	offscreen_canvas.background(0);
	//shape_canvas.background(0);
	
	//offscreen_canvas.rect(0, 0, offscreen_canvas.width, offscreen_canvas.height);
	
	img.loadPixels();
	shape_canvas.loadPixels();
	offscreen_canvas.loadPixels();
	
	// a quad
	const v1 = { x: -1, y: -1, z: -1 };
	const v2 = { x:  1, y: -1, z: 1 };
	const v3 = { x:  1, y:  1, z: 1 };
	const v4 = { x: -1, y:  1, z: -1 };
	
	// apply transforms (scale, rotate, project)
	let scale = 1;
	
	uscale(v1, scale);
	uscale(v2, scale);
	uscale(v3, scale);
	uscale(v4, scale);
	
	vrotateX(v1, frameCount / 60);
	vrotateX(v2, frameCount / 60);
	vrotateX(v3, frameCount / 60);
	vrotateX(v4, frameCount / 60);
	
	vrotateY(v1, frameCount / 80+1);
	vrotateY(v2, frameCount / 80+1);
	vrotateY(v3, frameCount / 80+1);
	vrotateY(v4, frameCount / 80+1);
	
	vrotateZ(v1, frameCount / 50);
	vrotateZ(v2, frameCount / 50);
	vrotateZ(v3, frameCount / 50);
	vrotateZ(v4, frameCount / 50);
	
	project(v1);
	project(v2);
	project(v3);
	project(v4);
	
	const w2 = shape_canvas.width / 2;
	
	// compute the bouding box of the first shear (horizontal stretch)
	const bbmin = min([round(w2 + v1.x * w2), round(w2 + v2.x * w2), round(w2 + v3.x * w2), round(w2 + v4.x * w2)]);
	const bbmax = max([round(w2 + v1.x * w2), round(w2 + v2.x * w2), round(w2 + v3.x * w2), round(w2 + v4.x * w2)]);
	const bbw = abs(bbmin - bbmax);
	const bby = 0;//min([round(w2 + v1.y * w2), round(w2 + v4.y * w2)]);
	const bbh = shape_canvas.height;//abs(round((w2 + v1.y * w2) - (w2 + v4.y * w2)));

	for (let y = 0; y < shape_canvas.height; y += 1) {
		let ny = y / shape_canvas.height;
		stretchX(img, shape_canvas,
						round(w2 + lrp_simple(v1.x, v4.x, ny) * w2), 
						0, // uv u start
						round(w2 + lrp_simple(v2.x, v3.x, ny) * w2),
						img.width, // uv u end
						round(ny * img.height), // uv v
						y);//round(h2 + lrp_simple(v1.y, v4.y, ny) * h2));
	}
	//shape_canvas.updatePixels();

	// compute vertical shear from the horizontal shear
	let h2 = offscreen_canvas.height / 2;
	for (let x = 0; x < bbw; x += 1) {
		let nx = x / bbw;
		stretchY(shape_canvas, offscreen_canvas,
						round(h2 + lrp_simple(v1.y, v2.y, nx) * h2), 
						bby,
						round(h2 + lrp_simple(v4.y, v3.y, nx) * h2),
						bby + bbh,
						bbmin + x,
						bbmin + x);//round(w2 + lrp_simple(bbmin / shape_canvas.width * 2 - 1, bbmax / shape_canvas.width * 2 - 1, nx) * bbw));
	}
	offscreen_canvas.updatePixels();

	image(offscreen_canvas, 0, 0, width, height);
	//image(shape_canvas, 0, 0, width, height);
	
	// debug first shear bbox
	//rect(bbmin, bby, bbw, bbh);
}"
"1050568","Quads rasterizer","mySketch","/*
  this is a 3d quad software rasterizer experiment
  started from several ideas, inspired first by how the Sega Saturn rendered quads (no triangles there!) then stumbled upon a fast stretcher algorithm in graphics gem 3 book
  the idea is very simple and is basically to stretch a bitmap horizontally then vertically (two pass) to make it act like a polygon, of course it come with artefacts but it somehow look close
	
  i think this was used in several software rendered demos in the 80s / 90s on low end hardware because then you could shear anything on screen with a combination
  of vblank and hblank (scanline offset) which was almost free since it was provided by the hardware...
	
	this renderer could probably be used without issues for any Parallel projection stuff (isometric etc.) since it act best when edges are parallel to each others
	this demo try to do 'perspective projection', it have issues since the second pass stretch / bend everything on its way thus it may look distorted on certain vertex configurations
*/

let img;
function preload() {
  img = loadImage('512_texture.jpg');
}

// anti-aliasing (supersampling)
let aa = 1;

let shape_canvas;
let offscreen_canvas;
function setup() {
	createCanvas(800, 800);
	
	shape_canvas = createGraphics(width * aa, height * aa);
	offscreen_canvas = createGraphics(width * aa, height * aa);
	
	stroke(255, 255, 255);
	noFill();
}

// integer algorithm for stretching a bitmap (very fast)
// source : Fast bitmap stretching by Tomas Möller - Graphics Gems 3
function stretchX(src, dst, x1, y1, x2, y2, yr, yw) {
	let dx = abs(x2 - x1);
	let dy = abs(y2 - y1);
	let sx = Math.sign(x2 - x1);
	let sy = Math.sign(y2 - y1);
	let e = 2 * dy - dx;
	let dx2 = 2 * dx;
	let dy2 = 2 * dy;
	
	if (dx == 0 || dy == 0) {
		let si = (y1 + yr * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (x1 + yw * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		return;
	}
	
	for (let i = 0; i <= dx; i += 1) {
		let si = (y1 + yr * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (x1 + yw * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		while (e >= 0) {
			y1 += sy;
			e -= dx2;
		}

		x1 += sx;
		e += dy2;
	}
}

function stretchY(src, dst, x1, y1, x2, y2, yr, yw) {
	let dx = abs(x2 - x1);
	let dy = abs(y2 - y1);
	let sx = Math.sign(x2 - x1);
	let sy = Math.sign(y2 - y1);
	let e = 2 * dy - dx;
	let dx2 = 2 * dx;
	let dy2 = 2 * dy;
	
	if (dx == 0 || dy == 0) {
		let si = (yr + y1 * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (yw + x1 * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		return;
	}
	
	for (let i = 0; i <= dx; i += 1) {
		let si = (yr + y1 * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (yw + x1 * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		while (e >= 0) {
			y1 += sy;
			e -= dx2;
		}

		x1 += sx;
		e += dy2;
	}
}

// some 3d stuff
function vrotateX(v, r) {
	let a =  cos(r) * v.y + sin(r) * v.z;
	let b = -sin(r) * v.y + cos(r) * v.z;
	
	v.y = a;
	v.z = b;
}

function vrotateY(v, r) {
	let a =  cos(r) * v.x + sin(r) * v.z;
	let b = -sin(r) * v.x + cos(r) * v.z;
	
	v.x = a;
	v.z = b;
}

function vrotateZ(v, r) {
	let a =  cos(r) * v.x + sin(r) * v.y;
	let b = -sin(r) * v.x + cos(r) * v.y;
	
	v.x = a;
	v.y = b;
}

function uscale(v, s) {
	v.x *= s;
	v.y *= s;
	v.z *= s;
}

function project(v) {
	v.x /= (v.z + 200) * 0.01;
	v.y /= (v.z + 200) * 0.01;
}

// algebraically simplified linear interpolation
function lrp_simple(a, b, f) {
    return a + f * (b - a);
}

function draw() {
	offscreen_canvas.background(0);
	//shape_canvas.background(0);
	
	//offscreen_canvas.rect(0, 0, offscreen_canvas.width, offscreen_canvas.height);
	
	img.loadPixels();
	shape_canvas.loadPixels();
	offscreen_canvas.loadPixels();
	
	// a quad
	const v1 = { x: -1, y: -1, z: -1 };
	const v2 = { x:  1, y: -1, z: 1 };
	const v3 = { x:  1, y:  1, z: 1 };
	const v4 = { x: -1, y:  1, z: -1 };
	
	// apply transforms (scale, rotate, project)
	let scale = 1;
	
	uscale(v1, scale);
	uscale(v2, scale);
	uscale(v3, scale);
	uscale(v4, scale);
	
	vrotateX(v1, frameCount / 60);
	vrotateX(v2, frameCount / 60);
	vrotateX(v3, frameCount / 60);
	vrotateX(v4, frameCount / 60);
	
	vrotateY(v1, frameCount / 80+1);
	vrotateY(v2, frameCount / 80+1);
	vrotateY(v3, frameCount / 80+1);
	vrotateY(v4, frameCount / 80+1);
	
	vrotateZ(v1, frameCount / 50);
	vrotateZ(v2, frameCount / 50);
	vrotateZ(v3, frameCount / 50);
	vrotateZ(v4, frameCount / 50);
	
	project(v1);
	project(v2);
	project(v3);
	project(v4);
	
	const w2 = shape_canvas.width / 2;
	
	// compute the bouding box of the first shear (horizontal stretch)
	const bbmin = min([round(w2 + v1.x * w2), round(w2 + v2.x * w2), round(w2 + v3.x * w2), round(w2 + v4.x * w2)]);
	const bbmax = max([round(w2 + v1.x * w2), round(w2 + v2.x * w2), round(w2 + v3.x * w2), round(w2 + v4.x * w2)]);
	const bbw = abs(bbmin - bbmax);
	const bby = 0;//min([round(w2 + v1.y * w2), round(w2 + v4.y * w2)]);
	const bbh = shape_canvas.height;//abs(round((w2 + v1.y * w2) - (w2 + v4.y * w2)));

	for (let y = 0; y < shape_canvas.height; y += 1) {
		let ny = y / shape_canvas.height;
		stretchX(img, shape_canvas,
						round(w2 + lrp_simple(v1.x, v4.x, ny) * w2), 
						0, // uv u start
						round(w2 + lrp_simple(v2.x, v3.x, ny) * w2),
						img.width, // uv u end
						round(ny * img.height), // uv v
						y);//round(h2 + lrp_simple(v1.y, v4.y, ny) * h2));
	}
	//shape_canvas.updatePixels();

	// compute vertical shear from the horizontal shear
	let h2 = offscreen_canvas.height / 2;
	for (let x = 0; x < bbw; x += 1) {
		let nx = x / bbw;
		stretchY(shape_canvas, offscreen_canvas,
						round(h2 + lrp_simple(v1.y, v2.y, nx) * h2), 
						bby,
						round(h2 + lrp_simple(v4.y, v3.y, nx) * h2),
						bby + bbh,
						bbmin + x,
						bbmin + x);//round(w2 + lrp_simple(bbmin / shape_canvas.width * 2 - 1, bbmax / shape_canvas.width * 2 - 1, nx) * bbw));
	}
	offscreen_canvas.updatePixels();

	image(offscreen_canvas, 0, 0, width, height);
	//image(shape_canvas, 0, 0, width, height);
	
	// debug first shear bbox
	//rect(bbmin, bby, bbw, bbh);
}"
"1050568","Quads rasterizer","mySketch","/*
  this is a 3d quad software rasterizer experiment
  started from several ideas, inspired first by how the Sega Saturn rendered quads (no triangles there!) then stumbled upon a fast stretcher algorithm in graphics gem 3 book
  the idea is very simple and is basically to stretch a bitmap horizontally then vertically (two pass) to make it act like a polygon, of course it come with artefacts but it somehow look close
	
  i think this was used in several software rendered demos in the 80s / 90s on low end hardware because then you could shear anything on screen with a combination
  of vblank and hblank (scanline offset) which was almost free since it was provided by the hardware...
	
	this renderer could probably be used without issues for any Parallel projection stuff (isometric etc.) since it act best when edges are parallel to each others
	this demo try to do 'perspective projection', it have issues since the second pass stretch / bend everything on its way thus it may look distorted on certain vertex configurations
	
	additionally this can be used on any retro hardware to build high quality rotozoomer by adding a negative horizontal pass (basically do shear x, shear y then shear -x), 
	providing almost free rotation + scaling on any old platforms!
*/

let img;
function preload() {
  img = loadImage('512_texture.jpg');
}

// anti-aliasing (supersampling)
let aa = 1;

let shape_canvas;
let offscreen_canvas;
function setup() {
	createCanvas(800, 800);
	
	shape_canvas = createGraphics(width * aa, height * aa);
	offscreen_canvas = createGraphics(width * aa, height * aa);
	
	stroke(255, 255, 255);
	noFill();
}

// integer algorithm for stretching a bitmap (very fast)
// source : Fast bitmap stretching by Tomas Möller - Graphics Gems 3
function stretchX(src, dst, x1, y1, x2, y2, yr, yw) {
	let dx = abs(x2 - x1);
	let dy = abs(y2 - y1);
	let sx = Math.sign(x2 - x1);
	let sy = Math.sign(y2 - y1);
	let e = 2 * dy - dx;
	let dx2 = 2 * dx;
	let dy2 = 2 * dy;
	
	if (dx == 0 || dy == 0) {
		let si = (y1 + yr * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (x1 + yw * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		return;
	}
	
	for (let i = 0; i <= dx; i += 1) {
		let si = (y1 + yr * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (x1 + yw * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		while (e >= 0) {
			y1 += sy;
			e -= dx2;
		}

		x1 += sx;
		e += dy2;
	}
}

function stretchY(src, dst, x1, y1, x2, y2, yr, yw) {
	let dx = abs(x2 - x1);
	let dy = abs(y2 - y1);
	let sx = Math.sign(x2 - x1);
	let sy = Math.sign(y2 - y1);
	let e = 2 * dy - dx;
	let dx2 = 2 * dx;
	let dy2 = 2 * dy;
	
	if (dx == 0 || dy == 0) {
		let si = (yr + y1 * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (yw + x1 * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		return;
	}
	
	for (let i = 0; i <= dx; i += 1) {
		let si = (yr + y1 * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (yw + x1 * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		while (e >= 0) {
			y1 += sy;
			e -= dx2;
		}

		x1 += sx;
		e += dy2;
	}
}

// some 3d stuff
function vrotateX(v, r) {
	let a =  cos(r) * v.y + sin(r) * v.z;
	let b = -sin(r) * v.y + cos(r) * v.z;
	
	v.y = a;
	v.z = b;
}

function vrotateY(v, r) {
	let a =  cos(r) * v.x + sin(r) * v.z;
	let b = -sin(r) * v.x + cos(r) * v.z;
	
	v.x = a;
	v.z = b;
}

function vrotateZ(v, r) {
	let a =  cos(r) * v.x + sin(r) * v.y;
	let b = -sin(r) * v.x + cos(r) * v.y;
	
	v.x = a;
	v.y = b;
}

function uscale(v, s) {
	v.x *= s;
	v.y *= s;
	v.z *= s;
}

function project(v) {
	v.x /= (v.z + 200) * 0.01;
	v.y /= (v.z + 200) * 0.01;
}

// algebraically simplified linear interpolation
function lrp_simple(a, b, f) {
    return a + f * (b - a);
}

function draw() {
	offscreen_canvas.background(0);
	//shape_canvas.background(0);
	
	//offscreen_canvas.rect(0, 0, offscreen_canvas.width, offscreen_canvas.height);
	
	img.loadPixels();
	shape_canvas.loadPixels();
	offscreen_canvas.loadPixels();
	
	// a quad
	const v1 = { x: -1, y: -1, z: -1 };
	const v2 = { x:  1, y: -1, z: 1 };
	const v3 = { x:  1, y:  1, z: 1 };
	const v4 = { x: -1, y:  1, z: -1 };
	
	// apply transforms (scale, rotate, project)
	let scale = 1;
	
	uscale(v1, scale);
	uscale(v2, scale);
	uscale(v3, scale);
	uscale(v4, scale);
	
	vrotateX(v1, frameCount / 60);
	vrotateX(v2, frameCount / 60);
	vrotateX(v3, frameCount / 60);
	vrotateX(v4, frameCount / 60);
	
	vrotateY(v1, frameCount / 80+1);
	vrotateY(v2, frameCount / 80+1);
	vrotateY(v3, frameCount / 80+1);
	vrotateY(v4, frameCount / 80+1);
	
	vrotateZ(v1, frameCount / 50);
	vrotateZ(v2, frameCount / 50);
	vrotateZ(v3, frameCount / 50);
	vrotateZ(v4, frameCount / 50);
	
	project(v1);
	project(v2);
	project(v3);
	project(v4);
	
	const w2 = shape_canvas.width / 2;
	
	// compute the bouding box of the first shear (horizontal stretch)
	const bbmin = min([round(w2 + v1.x * w2), round(w2 + v2.x * w2), round(w2 + v3.x * w2), round(w2 + v4.x * w2)]);
	const bbmax = max([round(w2 + v1.x * w2), round(w2 + v2.x * w2), round(w2 + v3.x * w2), round(w2 + v4.x * w2)]);
	const bbw = abs(bbmin - bbmax);
	const bby = 0;//min([round(w2 + v1.y * w2), round(w2 + v4.y * w2)]);
	const bbh = shape_canvas.height;//abs(round((w2 + v1.y * w2) - (w2 + v4.y * w2)));

	for (let y = 0; y < shape_canvas.height; y += 1) {
		let ny = y / shape_canvas.height;
		stretchX(img, shape_canvas,
						round(w2 + lrp_simple(v1.x, v4.x, ny) * w2), 
						0, // uv u start
						round(w2 + lrp_simple(v2.x, v3.x, ny) * w2),
						img.width, // uv u end
						round(ny * img.height), // uv v
						y);//round(h2 + lrp_simple(v1.y, v4.y, ny) * h2));
	}
	//shape_canvas.updatePixels();

	// compute vertical shear from the horizontal shear
	let h2 = offscreen_canvas.height / 2;
	for (let x = 0; x < bbw; x += 1) {
		let nx = x / bbw;
		stretchY(shape_canvas, offscreen_canvas,
						round(h2 + lrp_simple(v1.y, v2.y, nx) * h2), 
						bby,
						round(h2 + lrp_simple(v4.y, v3.y, nx) * h2),
						bby + bbh,
						bbmin + x,
						bbmin + x);//round(w2 + lrp_simple(bbmin / shape_canvas.width * 2 - 1, bbmax / shape_canvas.width * 2 - 1, nx) * bbw));
	}
	offscreen_canvas.updatePixels();

	image(offscreen_canvas, 0, 0, width, height);
	//image(shape_canvas, 0, 0, width, height);
	
	// debug first shear bbox
	//rect(bbmin, bby, bbw, bbh);
}"
"1050568","Quads rasterizer","mySketch","/*
  this is a 3d quad software rasterizer experiment
  started from several ideas, inspired first by how the Sega Saturn rendered quads (no triangles there!) then stumbled upon a fast stretcher algorithm in graphics gem 3 book
  the idea is very simple and is basically to stretch a bitmap horizontally then vertically (two pass) to make it act like a polygon, of course it come with artefacts but it somehow look close
	
  i think this was used in several software rendered demos in the 80s / 90s on low end hardware because then you could shear anything on screen with a combination
  of vblank and hblank (scanline offset) which was almost free since it was provided by the hardware...
	
	this renderer could probably be used without issues for any Parallel projection stuff (isometric etc.) since it act best when edges are parallel to each others
	this demo try to do 'perspective projection', it have issues since the second pass stretch / bend everything on its way thus it may look distorted on certain vertex configurations
	
	additionally this can be used on any retro hardware to build high quality rotozoomer by adding a negative horizontal pass (basically do shear x, shear y then shear -x), 
	providing almost free rotation + scaling on any old platforms!
*/

let img;
function preload() {
  img = loadImage('512_texture.jpg');
}

// anti-aliasing (supersampling)
let aa = 1;

let shape_canvas;
let offscreen_canvas;
function setup() {
	createCanvas(800, 800);
	
	shape_canvas = createGraphics(width * aa, height * aa);
	offscreen_canvas = createGraphics(width * aa, height * aa);
	
	stroke(255, 255, 255);
	noFill();
}

// integer algorithm for stretching a bitmap (very fast)
// source : Fast bitmap stretching by Tomas Möller - Graphics Gems 3
function stretchX(src, dst, x1, y1, x2, y2, yr, yw) {
	let dx = abs(x2 - x1);
	let dy = abs(y2 - y1);
	let sx = Math.sign(x2 - x1);
	let sy = Math.sign(y2 - y1);
	let e = 2 * dy - dx;
	let dx2 = 2 * dx;
	let dy2 = 2 * dy;
	
	if (dx == 0 || dy == 0) {
		let si = (y1 + yr * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (x1 + yw * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		return;
	}
	
	for (let i = 0; i <= dx; i += 1) {
		let si = (y1 + yr * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (x1 + yw * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		while (e >= 0) {
			y1 += sy;
			e -= dx2;
		}

		x1 += sx;
		e += dy2;
	}
}

function stretchY(src, dst, x1, y1, x2, y2, yr, yw) {
	let dx = abs(x2 - x1);
	let dy = abs(y2 - y1);
	let sx = Math.sign(x2 - x1);
	let sy = Math.sign(y2 - y1);
	let e = 2 * dy - dx;
	let dx2 = 2 * dx;
	let dy2 = 2 * dy;
	
	if (dx == 0 || dy == 0) {
		let si = (yr + y1 * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (yw + x1 * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		return;
	}
	
	for (let i = 0; i <= dx; i += 1) {
		let si = (yr + y1 * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (yw + x1 * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		while (e >= 0) {
			y1 += sy;
			e -= dx2;
		}

		x1 += sx;
		e += dy2;
	}
}

// some 3d stuff
function vrotateX(v, r) {
	let a =  cos(r) * v.y + sin(r) * v.z;
	let b = -sin(r) * v.y + cos(r) * v.z;
	
	v.y = a;
	v.z = b;
}

function vrotateY(v, r) {
	let a =  cos(r) * v.x + sin(r) * v.z;
	let b = -sin(r) * v.x + cos(r) * v.z;
	
	v.x = a;
	v.z = b;
}

function vrotateZ(v, r) {
	let a =  cos(r) * v.x + sin(r) * v.y;
	let b = -sin(r) * v.x + cos(r) * v.y;
	
	v.x = a;
	v.y = b;
}

function uscale(v, s) {
	v.x *= s;
	v.y *= s;
	v.z *= s;
}

function project(v) {
	v.x /= (v.z + 200) * 0.01;
	v.y /= (v.z + 200) * 0.01;
}

// algebraically simplified linear interpolation
function lrp_simple(a, b, f) {
    return a + f * (b - a);
}

function draw() {
	offscreen_canvas.background(0);
	shape_canvas.background(0);
	
	//offscreen_canvas.rect(0, 0, offscreen_canvas.width, offscreen_canvas.height);
	
	img.loadPixels();
	shape_canvas.loadPixels();
	offscreen_canvas.loadPixels();
	
	// a quad
	const v1 = { x: -0, y: -1, z: -1 };
	const v2 = { x:  1, y: -0, z: 1 };
	const v3 = { x:  1, y:  1, z: 1 };
	const v4 = { x: -1, y:  1, z: -1 };
	
	// apply transforms (scale, rotate, project)
	let scale = 1;
	/*
	uscale(v1, scale);
	uscale(v2, scale);
	uscale(v3, scale);
	uscale(v4, scale);
	
	vrotateX(v1, frameCount / 60);
	vrotateX(v2, frameCount / 60);
	vrotateX(v3, frameCount / 60);
	vrotateX(v4, frameCount / 60);
	
	vrotateY(v1, frameCount / 80+1);
	vrotateY(v2, frameCount / 80+1);
	vrotateY(v3, frameCount / 80+1);
	vrotateY(v4, frameCount / 80+1);
	
	vrotateZ(v1, frameCount / 50);
	vrotateZ(v2, frameCount / 50);
	vrotateZ(v3, frameCount / 50);
	vrotateZ(v4, frameCount / 50);
	
	project(v1);
	project(v2);
	project(v3);
	project(v4);
	*/
	const w2 = shape_canvas.width / 2;
	
	// compute the bouding box of the first shear (horizontal stretch)
	const bbmin = min([round(w2 + v1.x * w2), round(w2 + v2.x * w2), round(w2 + v3.x * w2), round(w2 + v4.x * w2)]);
	const bbmax = max([round(w2 + v1.x * w2), round(w2 + v2.x * w2), round(w2 + v3.x * w2), round(w2 + v4.x * w2)]);
	const bbw = abs(bbmin - bbmax);
	const bby = 0;//min([round(w2 + v1.y * w2), round(w2 + v4.y * w2)]);
	const bbh = shape_canvas.height;//abs(round((w2 + v1.y * w2) - (w2 + v4.y * w2)));

	for (let y = 0; y < shape_canvas.height; y += 1) {
		let ny = y / shape_canvas.height;
		stretchX(img, shape_canvas,
						round(w2 + lrp_simple(v1.x, v4.x, ny) * w2), 
						0, // uv u start
						round(w2 + lrp_simple(v2.x, v3.x, ny) * w2),
						img.width, // uv u end
						round(ny * img.height), // uv v
						y);//round(h2 + lrp_simple(v1.y, v4.y, ny) * h2));
	}
	shape_canvas.updatePixels();

	// compute vertical shear from the horizontal shear
	let h2 = offscreen_canvas.height / 2;
	for (let x = 0; x < bbw; x += 1) {
		let nx = x / bbw;
		stretchY(shape_canvas, offscreen_canvas,
						round(h2 + lrp_simple(v1.y, v2.y, nx) * h2), 
						bby,
						round(h2 + lrp_simple(v4.y, v3.y, nx) * h2),
						bby + bbh,
						bbmin + x,
						bbmin + x);//round(w2 + lrp_simple(bbmin / shape_canvas.width * 2 - 1, bbmax / shape_canvas.width * 2 - 1, nx) * bbw));
	}
	offscreen_canvas.updatePixels();

	//image(offscreen_canvas, 0, 0, width, height);
	image(shape_canvas, 0, 0, width, height);
	
	// debug first shear bbox
	//rect(bbmin, bby, bbw, bbh);
}"
"1050568","Quads rasterizer","mySketch","/*
  this is a 3d quad software rasterizer experiment
  started from several ideas, inspired first by how the Sega Saturn rendered quads (no triangles there!) then stumbled upon a fast stretcher algorithm in graphics gem 3 book
  the idea is very simple and is basically to stretch a bitmap horizontally then vertically (two pass) to make it act like a polygon, of course it come with artefacts but it somehow look close
	
  i think this was used in several software rendered demos in the 80s / 90s on low end hardware because then you could shear anything on screen with a combination
  of vblank and hblank (scanline offset) which was almost free since it was provided by the hardware...
	
	this renderer could probably be used without issues for any Parallel projection stuff (isometric etc.) since it act best when edges are parallel to each others
	this demo try to do 'perspective projection', it have issues since the second pass stretch / bend everything on its way thus it may look distorted on certain vertex configurations
	
	additionally this can be used on any retro hardware to build high quality rotozoomer by adding a negative horizontal pass (basically do shear x, shear y then shear -x), 
	providing almost free rotation + scaling on any old platforms!
*/

let img;
function preload() {
  img = loadImage('512_texture.jpg');
}

// anti-aliasing (supersampling)
let aa = 1;

let shape_canvas;
let offscreen_canvas;
function setup() {
	createCanvas(800, 800);
	
	shape_canvas = createGraphics(width * aa, height * aa);
	offscreen_canvas = createGraphics(width * aa, height * aa);
	
	stroke(255, 255, 255);
	noFill();
}

// integer algorithm for stretching a bitmap (very fast)
// source : Fast bitmap stretching by Tomas Möller - Graphics Gems 3
function stretchX(src, dst, x1, y1, x2, y2, yr, yw) {
	let dx = abs(x2 - x1);
	let dy = abs(y2 - y1);
	let sx = Math.sign(x2 - x1);
	let sy = Math.sign(y2 - y1);
	let e = 2 * dy - dx;
	let dx2 = 2 * dx;
	let dy2 = 2 * dy;
	
	if (dx == 0 || dy == 0) {
		let si = (y1 + yr * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (x1 + yw * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		return;
	}
	
	for (let i = 0; i <= dx; i += 1) {
		let si = (y1 + yr * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (x1 + yw * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		while (e >= 0) {
			y1 += sy;
			e -= dx2;
		}

		x1 += sx;
		e += dy2;
	}
}

function stretchY(src, dst, x1, y1, x2, y2, yr, yw) {
	let dx = abs(x2 - x1);
	let dy = abs(y2 - y1);
	let sx = Math.sign(x2 - x1);
	let sy = Math.sign(y2 - y1);
	let e = 2 * dy - dx;
	let dx2 = 2 * dx;
	let dy2 = 2 * dy;
	
	if (dx == 0 || dy == 0) {
		let si = (yr + y1 * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (yw + x1 * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		return;
	}
	
	for (let i = 0; i <= dx; i += 1) {
		let si = (yr + y1 * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (yw + x1 * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		while (e >= 0) {
			y1 += sy;
			e -= dx2;
		}

		x1 += sx;
		e += dy2;
	}
}

// some 3d stuff
function vrotateX(v, r) {
	let a =  cos(r) * v.y + sin(r) * v.z;
	let b = -sin(r) * v.y + cos(r) * v.z;
	
	v.y = a;
	v.z = b;
}

function vrotateY(v, r) {
	let a =  cos(r) * v.x + sin(r) * v.z;
	let b = -sin(r) * v.x + cos(r) * v.z;
	
	v.x = a;
	v.z = b;
}

function vrotateZ(v, r) {
	let a =  cos(r) * v.x + sin(r) * v.y;
	let b = -sin(r) * v.x + cos(r) * v.y;
	
	v.x = a;
	v.y = b;
}

function uscale(v, s) {
	v.x *= s;
	v.y *= s;
	v.z *= s;
}

function project(v) {
	v.x /= (v.z + 200) * 0.01;
	v.y /= (v.z + 200) * 0.01;
}

// algebraically simplified linear interpolation
function lrp_simple(a, b, f) {
    return a + f * (b - a);
}

function draw() {
	offscreen_canvas.background(0);
	shape_canvas.background(0);
	
	//offscreen_canvas.rect(0, 0, offscreen_canvas.width, offscreen_canvas.height);
	
	img.loadPixels();
	shape_canvas.loadPixels();
	offscreen_canvas.loadPixels();
	
	// a quad
	const v1 = { x: -1, y: -1, z: -1 };
	const v2 = { x:  1, y: -1, z: 1 };
	const v3 = { x:  1, y:  1, z: 1 };
	const v4 = { x: -1, y:  1, z: -1 };
	
	// apply transforms (scale, rotate, project)
	let scale = 1;
	
	uscale(v1, scale);
	uscale(v2, scale);
	uscale(v3, scale);
	uscale(v4, scale);
	
	vrotateX(v1, frameCount / 60);
	vrotateX(v2, frameCount / 60);
	vrotateX(v3, frameCount / 60);
	vrotateX(v4, frameCount / 60);
	
	vrotateY(v1, frameCount / 80+1);
	vrotateY(v2, frameCount / 80+1);
	vrotateY(v3, frameCount / 80+1);
	vrotateY(v4, frameCount / 80+1);
	
	vrotateZ(v1, frameCount / 50);
	vrotateZ(v2, frameCount / 50);
	vrotateZ(v3, frameCount / 50);
	vrotateZ(v4, frameCount / 50);
	
	project(v1);
	project(v2);
	project(v3);
	project(v4);
	
	const w2 = shape_canvas.width / 2;
	
	// compute the bouding box of the first shear (horizontal stretch)
	const bbmin = min([round(w2 + v1.x * w2), round(w2 + v2.x * w2), round(w2 + v3.x * w2), round(w2 + v4.x * w2)]);
	const bbmax = max([round(w2 + v1.x * w2), round(w2 + v2.x * w2), round(w2 + v3.x * w2), round(w2 + v4.x * w2)]);
	const bbw = abs(bbmin - bbmax);
	const bby = 0;//min([round(w2 + v1.y * w2), round(w2 + v4.y * w2)]);
	const bbh = shape_canvas.height;//abs(round((w2 + v1.y * w2) - (w2 + v4.y * w2)));

	for (let y = 0; y < shape_canvas.height; y += 1) {
		let ny = y / shape_canvas.height;
		stretchX(img, shape_canvas,
						round(w2 + lrp_simple(v1.x, v4.x, ny) * w2), 
						0, // uv u start
						round(w2 + lrp_simple(v2.x, v3.x, ny) * w2),
						img.width, // uv u end
						round(ny * img.height), // uv v
						y);//round(h2 + lrp_simple(v1.y, v4.y, ny) * h2));
	}
	shape_canvas.updatePixels();

	// compute vertical shear from the horizontal shear
	let h2 = offscreen_canvas.height / 2;
	for (let x = 0; x < bbw; x += 1) {
		let nx = x / bbw;
		stretchY(shape_canvas, offscreen_canvas,
						round(h2 + lrp_simple(v1.y, v2.y, nx) * h2), 
						bby,
						round(h2 + lrp_simple(v4.y, v3.y, nx) * h2),
						bby + bbh,
						bbmin + x,
						bbmin + x);//round(w2 + lrp_simple(bbmin / shape_canvas.width * 2 - 1, bbmax / shape_canvas.width * 2 - 1, nx) * bbw));
	}
	offscreen_canvas.updatePixels();

	image(offscreen_canvas, 0, 0, width, height);
	//image(shape_canvas, 0, 0, width, height);
	
	// debug first shear bbox
	//rect(bbmin, bby, bbw, bbh);
}"
"1050568","Quads rasterizer","mySketch","/*
  this is a 3d quad software rasterizer experiment
  started from several ideas, inspired first by how the Sega Saturn rendered quads (no triangles there!) then stumbled upon a fast stretcher algorithm in graphics gem 3 book
  the idea is very simple and is basically to stretch a bitmap horizontally then vertically (two pass) to make it act like a polygon, of course it come with artefacts but it somehow look close
	
  i think this was used in several software rendered demos in the 80s / 90s on low end hardware because then you could shear anything on screen with a combination
  of vblank and hblank (scanline offset) which was almost free since it was provided by the hardware...
	
	this renderer could probably be used without issues for any Parallel projection stuff (isometric etc.) since it act best when edges are parallel to each others
	this demo try to do some 3d by rotating the quad, it have issues since the second pass stretch / bend everything on its way thus it may look distorted on certain vertex configurations
	
	additionally this can be used on any retro hardware to build high quality rotozoomer by adding a negative horizontal pass (basically do shear x, shear y then shear -x), 
	providing almost free rotation + scaling on any old platforms!
*/

let img;
function preload() {
  img = loadImage('512_texture.jpg');
}

// anti-aliasing (supersampling)
let aa = 1;

let shape_canvas;
let offscreen_canvas;
function setup() {
	createCanvas(800, 800);
	
	shape_canvas = createGraphics(width * aa, height * aa);
	offscreen_canvas = createGraphics(width * aa, height * aa);
	
	stroke(255, 255, 255);
	noFill();
}

// integer algorithm for stretching a bitmap (very fast)
// source : Fast bitmap stretching by Tomas Möller - Graphics Gems 3
function stretchX(src, dst, x1, y1, x2, y2, yr, yw) {
	let dx = abs(x2 - x1);
	let dy = abs(y2 - y1);
	let sx = Math.sign(x2 - x1);
	let sy = Math.sign(y2 - y1);
	let e = 2 * dy - dx;
	let dx2 = 2 * dx;
	let dy2 = 2 * dy;
	
	if (dx == 0 || dy == 0) {
		let si = (y1 + yr * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (x1 + yw * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		return;
	}
	
	for (let i = 0; i <= dx; i += 1) {
		let si = (y1 + yr * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (x1 + yw * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		while (e >= 0) {
			y1 += sy;
			e -= dx2;
		}

		x1 += sx;
		e += dy2;
	}
}

function stretchY(src, dst, x1, y1, x2, y2, yr, yw) {
	let dx = abs(x2 - x1);
	let dy = abs(y2 - y1);
	let sx = Math.sign(x2 - x1);
	let sy = Math.sign(y2 - y1);
	let e = 2 * dy - dx;
	let dx2 = 2 * dx;
	let dy2 = 2 * dy;
	
	if (dx == 0 || dy == 0) {
		let si = (yr + y1 * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (yw + x1 * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		return;
	}
	
	for (let i = 0; i <= dx; i += 1) {
		let si = (yr + y1 * src.width) * 4;
		let cr = src.pixels[si + 0];
		let cg = src.pixels[si + 1];
		let cb = src.pixels[si + 2];
		
		let di = (yw + x1 * dst.width) * 4;
		dst.pixels[di + 0] = cr;
		dst.pixels[di + 1] = cg;
		dst.pixels[di + 2] = cb;
		
		while (e >= 0) {
			y1 += sy;
			e -= dx2;
		}

		x1 += sx;
		e += dy2;
	}
}

// some 3d stuff
function vrotateX(v, r) {
	let a =  cos(r) * v.y + sin(r) * v.z;
	let b = -sin(r) * v.y + cos(r) * v.z;
	
	v.y = a;
	v.z = b;
}

function vrotateY(v, r) {
	let a =  cos(r) * v.x + sin(r) * v.z;
	let b = -sin(r) * v.x + cos(r) * v.z;
	
	v.x = a;
	v.z = b;
}

function vrotateZ(v, r) {
	let a =  cos(r) * v.x + sin(r) * v.y;
	let b = -sin(r) * v.x + cos(r) * v.y;
	
	v.x = a;
	v.y = b;
}

function uscale(v, s) {
	v.x *= s;
	v.y *= s;
	v.z *= s;
}

function project(v) {
	v.x /= (v.z + 200) * 0.01;
	v.y /= (v.z + 200) * 0.01;
}

// algebraically simplified linear interpolation
function lrp_simple(a, b, f) {
    return a + f * (b - a);
}

function draw() {
	offscreen_canvas.background(0);
	shape_canvas.background(0);
	
	//offscreen_canvas.rect(0, 0, offscreen_canvas.width, offscreen_canvas.height);
	
	img.loadPixels();
	shape_canvas.loadPixels();
	offscreen_canvas.loadPixels();
	
	// a quad
	const v1 = { x: -1, y: -1, z: -1 };
	const v2 = { x:  1, y: -1, z: 1 };
	const v3 = { x:  1, y:  1, z: 1 };
	const v4 = { x: -1, y:  1, z: -1 };
	
	// apply transforms (scale, rotate, project)
	let scale = 1;
	
	uscale(v1, scale);
	uscale(v2, scale);
	uscale(v3, scale);
	uscale(v4, scale);
	
	vrotateX(v1, frameCount / 60);
	vrotateX(v2, frameCount / 60);
	vrotateX(v3, frameCount / 60);
	vrotateX(v4, frameCount / 60);
	
	vrotateY(v1, frameCount / 80+1);
	vrotateY(v2, frameCount / 80+1);
	vrotateY(v3, frameCount / 80+1);
	vrotateY(v4, frameCount / 80+1);
	
	vrotateZ(v1, frameCount / 50);
	vrotateZ(v2, frameCount / 50);
	vrotateZ(v3, frameCount / 50);
	vrotateZ(v4, frameCount / 50);
	
	project(v1);
	project(v2);
	project(v3);
	project(v4);
	
	const w2 = shape_canvas.width / 2;
	
	// compute the bouding box of the first shear (horizontal stretch)
	const bbmin = min([round(w2 + v1.x * w2), round(w2 + v2.x * w2), round(w2 + v3.x * w2), round(w2 + v4.x * w2)]);
	const bbmax = max([round(w2 + v1.x * w2), round(w2 + v2.x * w2), round(w2 + v3.x * w2), round(w2 + v4.x * w2)]);
	const bbw = abs(bbmin - bbmax);
	const bby = 0;//min([round(w2 + v1.y * w2), round(w2 + v4.y * w2)]);
	const bbh = shape_canvas.height;//abs(round((w2 + v1.y * w2) - (w2 + v4.y * w2)));

	for (let y = 0; y < shape_canvas.height; y += 1) {
		let ny = y / shape_canvas.height;
		stretchX(img, shape_canvas,
						round(w2 + lrp_simple(v1.x, v4.x, ny) * w2), 
						0, // uv u start
						round(w2 + lrp_simple(v2.x, v3.x, ny) * w2),
						img.width, // uv u end
						round(ny * img.height), // uv v
						y);//round(h2 + lrp_simple(v1.y, v4.y, ny) * h2));
	}
	shape_canvas.updatePixels();

	// compute vertical shear from the horizontal shear
	let h2 = offscreen_canvas.height / 2;
	for (let x = 0; x < bbw; x += 1) {
		let nx = x / bbw;
		stretchY(shape_canvas, offscreen_canvas,
						round(h2 + lrp_simple(v1.y, v2.y, nx) * h2), 
						bby,
						round(h2 + lrp_simple(v4.y, v3.y, nx) * h2),
						bby + bbh,
						bbmin + x,
						bbmin + x);//round(w2 + lrp_simple(bbmin / shape_canvas.width * 2 - 1, bbmax / shape_canvas.width * 2 - 1, nx) * bbw));
	}
	offscreen_canvas.updatePixels();

	image(offscreen_canvas, 0, 0, width, height);
	//image(shape_canvas, 0, 0, width, height);
	
	// debug first shear bbox
	//rect(bbmin, bby, bbw, bbh);
}"
"1050212","My Sketch","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 6;

function setup() {
  createCanvas(800, 800);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (1.5 + abs(sin(x / width * PI * 0.25 + cos(y / height * PI * 0.25 + pow(x/ width, 1) * PI * 0.25)))), y: (width / (1.0) + x - y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.25 + x) / 1 + j * (20), y: (height / 4 - y * 2 / j + (x / 4.0)) / 1.0 + j * (80) };
}

function f3(x, y, j) {
	return { x: (width * 0.5 - x * j) / (16 * (j / 14) + x / (width / (10))), y: y / 8 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (3.25) - x + y / (1.95 * j * ((0.5 - y / width) * 10))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 10, y: (height / 2 - y * 1.15 / j + (x / 10.075)) / 1.75 + j * (50) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (4.0 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 5000) {
		for (let i = 0; i < 10000; i += 1) {
			for (let j = 5; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let ny1 = x[j] / width*2-1;
				let nx1 = y[j] / height;
				let inx1 =((0.05)+pow(abs(2.0-nx1), 2));
				let nx11 = y[j] / width*2-1;//abs(0.5-y[j] / height)*2;
				let inx3 =((0.15)+pow((0.5-nx11)/2, 4));
				let nx2 = y2[j] / height;
				let inx2 = 0.45+pow(nx2, 0.5);
				
				let e = 0.75;

				if (iter > 20) {
					stroke((xmotion*64+iter*64)%360, 128, 255, 0.0125 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);
					//point(width - x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					//point(x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					
					//point(x2[j] * inx2+5, height / 1 - y2[j]/2.5);
					//point(width - x2[j] * inx2-5, height / 1 - y2[j]/2.5);
					//point(x[j] / 4.0 * inx3 - width / 4 * sin(nx1*PI*0.5), y[j]/2);
					//point(width - (width - x[j] / 4.0 * inx3 - width / 4 * sin(nx1*PI*0.5)), y[j]/2);
					//point(width / 1.95 - x[j] / 4.0 * inx3 - width / 4 * sin(nx1*PI*0.5), height - y[j]/2);
					//point(width - (width / 1.95 - x[j] / 4.0 * inx3 - width / 4 * sin(nx1*PI*0.5)), height - y[j]/2);

					//point(width / 2 - x[j] / 4, height - y[j]/2);
					//point(width / 2 + x[j] / 4, height - y[j]/2);
					point(width / 2 + x[j] / 1.0 * inx1 + width / 12.0 * abs(cos(ny1*PI*1.5 * pow(sin(nx1 * PI *0.15), 4))), (height - y[j]/4));
					point(width / 2 - (x[j] / 1.0 * inx1 + width / 12.0 * abs(cos(ny1*PI*1.5 * pow(sin(nx1 * PI *0.15), 4)))), (height - y[j]/4));
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	} else {
		iter = 0;
		xmotion += 0.01;
	}

	//xmotion += 1;
	ymotion += 0.25;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"1050212","My Sketch","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 6;

function setup() {
  createCanvas(800, 800);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (1.5 + abs(sin(x / width * PI * 0.25 + cos(y / height * PI * 0.25 + pow(x/ width, 1) * PI * 0.25)))), y: (width / (1.0) + x - y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.25 + x) / 1 + j * (20), y: (height / 4 - y * 2 / j + (x / 4.0)) / 1.0 + j * (80) };
}

function f3(x, y, j) {
	return { x: (width * 0.5 - x * j) / (16 * (j / 14) + x / (width / (10))), y: y / 8 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (3.25) - x + y / (1.95 * j * ((0.5 - y / width) * 10))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 10, y: (height / 2 - y * 1.15 / j + (x / 10.075)) / 1.75 + j * (50) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (4.0 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 5000) {
		for (let i = 0; i < 10000; i += 1) {
			for (let j = 5; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let ny1 = x[j] / width*2-1;
				let nx1 = y[j] / height;
				let inx1 =((0.05)+pow(abs(2.0-nx1), 2));
				let nx11 = y[j] / width*2-1;//abs(0.5-y[j] / height)*2;
				let inx3 =((0.15)+pow((0.5-nx11)/2, 4));
				let nx2 = y2[j] / height;
				let inx2 = 0.45+pow(nx2, 0.5);
				
				let e = 0.75;

				if (iter > 20) {
					stroke((xmotion*64+iter*64)%360, 128, 255, 0.0125 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);
					//point(width - x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					//point(x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					
					//point(x2[j] * inx2+5, height / 1 - y2[j]/2.5);
					//point(width - x2[j] * inx2-5, height / 1 - y2[j]/2.5);
					//point(x[j] / 4.0 * inx3 - width / 4 * sin(nx1*PI*0.5), y[j]/2);
					//point(width - (width - x[j] / 4.0 * inx3 - width / 4 * sin(nx1*PI*0.5)), y[j]/2);
					//point(width / 1.95 - x[j] / 4.0 * inx3 - width / 4 * sin(nx1*PI*0.5), height - y[j]/2);
					//point(width - (width / 1.95 - x[j] / 4.0 * inx3 - width / 4 * sin(nx1*PI*0.5)), height - y[j]/2);

					point(width / 2 - x[j] / 3, height - y[j]/1.5);
					point(width / 2 + x[j] / 3, height - y[j]/1.5);
					point(width / 2 + x[j] / 1.0 * inx1 + width / 12.0 * abs(cos(ny1*PI*1.5 * pow(sin(nx1 * PI *0.15), 4))), (height - y[j]/2));
					point(width / 2 - (x[j] / 1.0 * inx1 + width / 12.0 * abs(cos(ny1*PI*1.5 * pow(sin(nx1 * PI *0.15), 4)))), (height - y[j]/2));
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	} else {
		iter = 0;
		xmotion += 0.01;
	}

	//xmotion += 1;
	ymotion += 0.25;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"1048257","L-systems mistake 4","mySketch","// some more improvements / polish over the dynamic L-systems idea (colors with shadow outline, refined parameters)
// endless automatic drawing patterns fun by tweaking the rules, initial angle, step, colors, compositing... !

// glitchy version due wrap-around mistake

// an excellent source of documented rules : http://paulbourke.net/fractals/lsys/

function pal(t, a, b, c, d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

function weightedRandom(prob) {
  let i, sum=0, r=Math.random();
  for (i in prob) {
    sum += prob[i];
    if (r <= sum) return i;
  }
}

function variance(data) {
		let s1 = 0;
		let s2 = 0;
		let n = data.length;

    for (let x = 0; x < data.length; x += 1) {
    		s1 += x;
		}

    let mean = s1 / n;

    for (let x = 0; x < data.length; x += 1) {
        s2 += (x - mean) * (x - mean);
		}

    return s2 / (n - 1);
}

class lm {
	constructor(axiom, rules, angle, step, sx, sy, iter) {
		this.ax = sx;
		this.ay = sy;
		this.px = this.ax;
		this.py = this.ay;
		this.ta = angle;
		this.ca = PI;
		this.fs = step;
		
		this.stack = [];
		
		this.axiom = axiom;
		this.rules = rules;
		this.itera = iter;
		
		this.rule = 0;
		
		this.cycles = 0;
		
		this.b = false;
		
		this.where = 1;
		
		this.initialize();
	}
	
	initialize() {
		let rule = this.axiom;
		for (let i = 0; i < this.itera; i++) {
			rule = this.lindenmayer(rule);
		}
		
		this.rule = rule;
	}
	
	lindenmayer(s) {
		let outputstring = '';

		for (let i = 0; i < s.length; i++) {
			let ismatch = 0;
			for (let j = 0; j < this.rules.length; j++) {
				if (s[i] == this.rules[j][0])  {
					let rule_index = 1;
					if (this.rules[j].length > 2) { // stochastic
						let probs = {};
						for (let k = 1; k < this.rules[j].length; k+=2) {
							probs[k+1] = this.rules[j][k];
						}
						rule_index = weightedRandom(probs);
					}
					outputstring += this.rules[j][rule_index];
					ismatch = 1;
					break;
				}
			}

			if (ismatch == 0) outputstring+= s[i];
		}
		
		return outputstring;
	}
	
	computeParameters(w) {
		
	}
	
	compute(cb_trigger) {
		let k = this.rule[this.where];
		if (k == 'F' || k == 'f') {
			var polx = this.fs * sin(this.ca);
			var poly = this.fs * cos(this.ca);
			let x1 = this.b ? this.px - polx : this.px + polx;
			let y1 = this.b ? this.py - poly : this.py + poly;

			if (x1 < 0 || y1 < 0 || x1 > width || y1 > height) {
				this.b = !this.b;
				this.ta = -this.ta;//random() * PI * 2;
				
				if (x1 < 0) { x1 = width; }
				if (y1 < 0) { y1 = height; }
				if (x1 > width) { x1 = 0; }
				if (y1 > height) { y1 = 0; }
			}

			this.ax = this.px;
			this.ay = this.py;
			this.px = x1;
			this.py = y1;
		} else if (k == '[') {
			this.stack.push(this.px);
			this.stack.push(this.py);
			this.stack.push(this.ca);
		} else if (k == ']') {
			this.ca = this.stack.pop();
			this.py = this.stack.pop();
			this.px = this.stack.pop();
		} else if (k == '+') {
			this.ca += this.ta;
		} else if (k == '-') {
			this.ca -= this.ta;
		}
		
		this.where++;
  	if (this.where > (this.rule.length-1)/8) {
			this.where = 0;
			this.cycles += 1;
			
			cb_trigger(this);
		}
		
		if (k == 'F') {
			return true;
		} else {
			return false;
		}
	}
}

var xmotion = 0;
var ymotion = 0;

let lms = [];

function setup() {
  createCanvas(800, 800);
  background(0);
	
	noiseDetail(7, 0.7);
	//colorMode(HSB, 360, 100, 100, 255);
	
	//blendMode(LIGHTEST);
	
	stroke(0, 0, 100, 255);
 // lms[0] = new lm('X', [['X', 0.5, 'XFFFF-[F-X+]FX+', 0.5, 'FFFFF[f+F]------------F'], ['F', '+F--F+']], radians(45), 1);
	let amount = 8;
	for (let i = 0; i < amount; i += 1) {
		let r = radians(10 + 180* ((((1+i) / amount)*2)-1));
		let s = 2;
		let sx = random(1, width-1);
		let sy = random(1, height-1);
		if (i % 2 == 0)
			//lms[i] = new lm('F+F+F+F', [['F', 'FF+[+F-F-F]-[-F+F+F]']], r, 2, sx, sy, 6);
			lms[i] = new lm('F+F+F+F', [['F', 'FF+[+FF]-[-FF]']], r, 2, sx, sy, 4);
	  else if (i % 2 == 1)
			//lms[i] = new lm('F+XF+F+XF', [['X', 'XF-F+F-XF+F+XF-F+F-X']], r, 2, sx, sy, 6);
	  //else if (i % 4 == 2)
			//lms[i] = new lm('XF', [['X', 'X+YF++YF-FX--FXFX-YF+'], ['Y', '-FX+YFYF++YF+FX--FX-Y']], r, 2, sx, sy, 6);
		//else
			lms[i] = new lm('F+XF+F+XF', [['X', 'XF-F+F-XF+F+XF-F+F-X']], r, s, sx, sy, 4);
	}
	//lms[1] = new lm('X', [['X', 'F-[[X]+X]+F[+FX]-X'], ['F', 'FF']], radians(90), 1);
}

function change(lm) {
	let max_cycles = 1;
	noStroke();
	if (lm.cycles % max_cycles == 0) {
		
		lm.ta += 0.01;
		lm.fs = random(1, 8);
		
		//fill(0, 0, 0, 64);
		//rect(0, 0, width, height);
	}
	
	// handle stuck case when it oscillate on corners (could be improved ?)
	if (lm.cycles % 128 == 0) {
		lm.px = random(0, width);
		lm.py = random(0, height);
		lm.ax = lm.px;
		lm.ay = lm.py;
	}
	
	/*
	if (lm.cycles % 512 == 0) {
		fill(0, 0, 0, 64);
		rect(0, 0, width, height);
	}
	*/
	
	//let nc = (lm.cycles % 8) / 8;
	//stroke(0, 0, 100, random(0, 10));
	/*
	if (random() > 0.5) {
		lm.iter = 5;
		lm.initialize();
	} else {
		lm.iter = 6;
		lm.initialize();
	}*/
}

function draw() {
	for (let k = 0; k < 128; k += 1) {
		for (let i = 0; i < lms.length; i += 1) {
			let lm = lms[i];
			
			let result = lm.compute(change);
			
			if (result) {
				//stroke(k / 3 + abs(sin(xmotion/24))*180, 30, 255, 255);
			var pa1 = 1, pa2 = 1, pa3 = 1;
			var pb1 = 0.25, pb2 = 0.75, pb3 = 1;
			var pc1 = 1, pc2 = 1, pc3 = 1;

			var pdr = 1;
			var pdg = 1;
			var pdb = 0.0;

				var pt = abs(sin(xmotion *8+ i/8));

				var rf = pal(pt, pa1, pb1, pc1, pdr) * 255*1.15;
				var gf = pal(pt, pa2, pb2, pc2, pdg) * 255*1.15;
				var bf = pal(pt, pa3, pb3, pc3, pdb) * 255*1.15;

				if (random() > 0.25) {
					stroke(rf, gf, bf, random() > 0.25 ? 255 : 92);
				} else {
					stroke(255-rf, 255-gf, 255-bf, 192);
				}
				strokeWeight(1+8 * abs(sin(xmotion/2+i) * (i / lms.length))/* + abs(sin(xmotion/16+i))*8*/);
				var context = drawingContext
        context.shadowOffsetX = random(-1, 1);
        context.shadowOffsetY = random(-1, 1);
        context.shadowBlur = 1; // more can be fun also
        context.shadowColor = ""black"";
				

				line(lm.px, lm.py, lm.ax, lm.ay);
			}
		}
	}
	
	xmotion += 0.5;
	ymotion += 0.25;
}"
"1045823","Sea3","mySketch","// same as parallax checkerboard but everything depart from center with variable shape size based on distance
// white stroke is used to give some sort of shading
// with many shapes this give a 3d look (but slower)
// more distorsion and noise !

function setup() {
	createCanvas(900, 900);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseDetail(6, 0.7);
	
	noStroke();
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	//background(0);
	noStroke();
	fill(0, 0, 0, 0.2);
	rect(0, 0, width, height);
	
	let planes = 92;
	
	let sw = 100;
	let sh = 100;
	
	let xp_offset = 0;
	let yp_offset = 0;
	
	let w = width;
	let h = height;
	
	for (let p = 1; p <= planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let ainp = abs(0.5 - np) * 2;
		
		let sf = pow(0.15, inp) * 1.25;
		
		push();
		translate(width / 2, height / 2);
		scale(sf, sf);
		// slow
		//rotate(sf * 3 * inp + xmotion / 64);
		for (let y = 0; y <= h; y += sw) {
			for (let x = 0; x <= w; x += sh) {
				if ((x % (sw * 2)) ^ (y % (sh * 2))) { // checkerboard pattern
					let nx = 1-abs(0.5 - x / w) * 2;
					let ny = 1-abs(0.5 - y / h) * 2;
					
					let no = noise(nx * 1, ny * 1) * noise(ainp * 20 + xmotion / 32);
					
					let ss = sin(nx * ny * PI * 1 + inp * PI * 0.5 + xmotion / 32) + no * 1.25;
					
					stroke(0, 0, 255, 1);
					strokeWeight(0.125);
					fill((240 + (1 - np) * 260 * sf + noise(np * 8 + xmotion / 2) * 48 + xmotion) % 360, 255 * np, 255 * np, sf /4);
					ellipse(-width / 2 + (x + cos(sf + xmotion / 28) * 2/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
							 	  -height / 2 + (y + sin(sf + ymotion / 28) * 2 /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
									sw * ss * inp,
									sh * ss * inp);
				}
			}
		}
		pop();
	}
	
	xmotion += 1;
	ymotion += 1;
}"
"1045823","Sea3","mySketch","// same as parallax checkerboard but everything depart from center with variable shape size based on distance
// white stroke is used to give some sort of shading
// with many shapes this give a 3d look (but slower)
// more distorsion and noise !

function setup() {
	createCanvas(600, 600);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseDetail(6, 0.7);
	
	noStroke();
	
	//blendMode(BURN     );
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	//background(0);
	noStroke();
	fill(0, 0, 0, 0.5);
	rect(0, 0, width, height);
	
	let planes = 92;
	
	let sw = 100;
	let sh = 100;
	
	let xp_offset = 0;
	let yp_offset = 0;
	
	let w = width;
	let h = height;
	
	for (let p = 1; p <= planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let ainp = abs(0.5 - np) * 2;
		
		let sf = pow(0.15, inp) * 1.25;
		
		push();
		translate(width / 2, height / 2);
		scale(sf, sf);
		// slow
		
		for (let y = 0; y <= h; y += sw) {
			for (let x = 0; x <= w; x += sh) {
				if ((x % (sw * 2)) ^ (y % (sh * 2))) { // checkerboard pattern
					let nx = 1-abs(0.5 - x / w) * 2;
					let ny = 1-abs(0.5 - y / h) * 2;
					rotate(x / width * y / height * xmotion/1000);
					let no = noise(nx * 1, ny * 1) * noise(ainp * 2 + xmotion / 32);
					
					let ss = sin(nx * ny * PI * 1 + inp * PI * 0.5 + xmotion / 32) + no * 0.5;
					
					stroke(0, 0, 255, 1);
					strokeWeight(0.125);
					fill((240 + (1 - np) * 260 * sf + noise(np * 8 + xmotion / 2 + x) * 48 + xmotion) % 360, 255 * np, 255 * np, sf /4);
					ellipse(-width / 2 + (x + cos(sf+x + xmotion / 20) * 0/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
							 	  -height / 2 + (y + sin(sf+y + ymotion / 20) * 0 /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
									sw * ss * inp,
									sh * ss * inp);
				}
			}
		}
		pop();
	}
	
	xmotion += 1;
	ymotion += 1;
}"
"1044926","Wild winter","mySketch","// finally with some clouds :) needed to be tuned a bit!
// different shading on the sea
// change the seeds; shading of both sea & sky vary greatly

function setup() {
	createCanvas(600, 600);
	
	noStroke();
	
	background(0);
	
	colorMode(HSL, 360, 255, 255, 1);
	
	noiseSeed(247);
	noiseDetail(8, 0.75);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	generate();
}

function draw() {
	
}

function generate() {
	noStroke();
				/*		var context = drawingContext
        context.shadowOffsetX = random(-1, 1);
        context.shadowOffsetY = random(-1, 1);
        context.shadowBlur = 1;
        context.shadowColor = ""white"";
	background(0, 0, 255, 1);
	*/
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 2) {
		let ny = y / height;
		for (x = 0; x < width+8; x += 1) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx, ny);
			
			let yy = height / 3.1 + y - n * height;
			fill(200 + 25 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.5 + ny * PI * 2 + 0.25))), 118, 128 + pow(ny, 1) * 128, 1);
			rect(x, yy, 4, 5);
		}
	}
	
	for (y = height/2; y > 0; y -= ystep) {
		let ny = y / (height/2);
		for (x = 0; x < width; x += 3) {
			let nx = x / width;
			let n = noise(nx/2, ny/2);
			let n2 = noise(nx *3, ny *8);
			
			let yy = height + y - n * (height / 12);
			noStroke();
			fill(200 + n2 * 32, 128, 32 + 128 * n2 + 128 - 32 * (pow((1 - ny), 3.25)), 0.25);
			rect(x, yy-height /2, 3, 3);
		}
	}
						var context = drawingContext
        context.shadowOffsetX = random(-1, 1);
        context.shadowOffsetY = random(-1, 1);
        context.shadowBlur = 1;
        context.shadowColor = ""white"";
	for (y = height/1.85; y > 0; y -= 1) {
		let ny = y / height/1.85;
		for (x = 0; x < width; x += 1) {
			if (random() > 0.75) {
				stroke(0, 0, 0, random(0, 0.05));
				let xx = x + random(-4, 4);
				line(xx, y, xx + random(-6, 6)*ny, y + random(-6, 6)*ny);
			}
		}
	}

	for (y = 0; y < height / 2; y += 1) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 8) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.05);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-100, 100), y + random(-100, 100));
			}
		}
	}
	
	for (y = 0; y < height / 2; y += 1) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 1) {
			let n = noise(x / width, y / height*4);
			if (random() > 0.25 + n) {
				stroke(0, 0, 255, random() * 0.0075*n);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-100, 100), y + random(-20, 20));
			}
		}
	}
	
	let wl = 255 * (height / 976);
	let m = 0; // get max y
	for (y = 0; y < (height - m); y += 1) {
		let ny = y / height;
		let noy = noise(ny);
		
		for (x = -32; x < width+32; x += 1) {
			let yy = (height / 2 + noise(x / width) * 24) + y + m;
			
			let nx = x / width;
			let nox = noise(nx * 16, ny * 16)
			let nox2 = (noise(nx*16, ny*16));
			let nox3 = noise(nx * 16, ny * 16);
			let n = (sin(nx * PI * 2.25 + ny * PI * 1 + nox * PI * 1.75)) * 1 * nox2;
			
			if (random() > 0.15) {
				stroke(190 + nox2 * 24, 100 * nox3, 248*nox3-random(248) * n, random() * 0.5 * pow(ny, 0.3));
				let xx = x + random(-2, 2);
				line(xx, yy, xx + random(-80, 80) * n * noy * ny + nox3*20*ny, yy + random(-140, 140) * n * ny);
			}
			if (random() > 0.05) {
			n = (sin(nx * PI * 1.5 + ny * PI * 8 + nox * PI * 4.15)) / 2 * nox2;
				stroke(190 + nox2 * 24, 100 * nox3, 200*nox3-random(200) * n, random() * 0.75 * pow(ny, 0.3));
				xx = x + random(-20, 20);
				line(xx, yy, xx + random(-8, 8) * n * noy * ny + nox3*100*ny, yy + random(-140, 140) * n * ny);
		}
			if (random() > 0.05) {
			n = (sin(nx * PI * 1.5 + ny * PI * 4 + nox * PI *3.15)) / 2 * nox2;
				stroke(190 + nox2 * 24, 100 * nox3, 200*nox3-random(248) * n, random() * 0.75 * pow(ny, 0.3));
				xx = x + random(-4, 4);
				line(xx, yy, xx + random(-40, 40) * n * noy * ny + nox3*80*ny, yy + random(-200, 200) * n * ny);
		}
			if (random() > 0.15) {
			n = (sin(nx * PI * 2.5 + ny * PI * 1 + nox * PI * 2.15)) / 2 * nox2;
				stroke(190 + nox2 * 24, 100 * nox3, 180*nox3-random(100) * n, random() * 0.75 * pow(ny, 0.3));
				xx = x + random(-20, 20);
				line(xx, yy, xx + random(-80, 80) * n * noy * ny + nox3*70*ny, yy + random(-140, 140) * n * ny);
		}
		}
		/*
		if (y == height / 5) {
			stroke(0, 0, 0, 1);
			strokeWeight(0.5);
			line(width / 5, height / 2 + y, width / 5, height / 2 + y - height / 12);
			line(width / 5, height / 2 + y, width / 4.25, height / 2 + y - height / 64);
			strokeWeight(1);
		}*/
	}
	/*
	for (y = 0; y < (height - m); y += 1) {
		let ny = y / height;
		let noy = noise(ny);
		
		for (x = -32; x < width+32; x += 1) {
			let yy = (height / 2 + noise(x / width) * 4) + y + m;
			
			let nx = x / width;
			let nox = noise(nx * 4, ny * 4)
			let nox2 = (noise(nx/2, ny/2));
			let nox3 = noise(nx * 1, ny * 3);
			let ss = exp(-pow(nx - 0.5 + cos(PI * 0.5 + (ny) * PI * 1)/2, 2)*2 + 0.15);
			let n = (sin(nx * PI * 0.5 + ny * PI * 1 + nox * PI * 1.15)) / 0.5 * nox2;
			
			if (random() > 0.0) {
				stroke(10 + (nox2) * 40, 140 * nox3 + 20 * (1-ss), (248*nox3-random(248) * n)+200*(1-ss), random() * 0.5 * pow(ny, 0.3));
				let xx = x + random(-2, 2);
				line(xx, yy, xx + random(-8, 8) * ny + nox3*10*ny * (ss), yy + random(-4, 4) * n * ny);
			}
		}
	}*/

	for (y = 0; y < height / 2; y += 16) {
		let ny = y / height;
		let noy = noise(ny);
		for (x = 0; x < width; x += 3) {
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = noise(nx, ny);
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2 * nox2;

			let yy = y;

			if (random() > 0.9991) {
				stroke(0, 0, 0, 1);
				strokeWeight(0.5);
				let tx = x + random(1, 6);
				let ty = yy + random(1, 6);
				line(x, yy, tx, ty);
				line(tx, ty, tx + random(1, 4) * (1-ny), ty - random(1, 1) * (1-ny));
			}
		}
	}
	
	for (y = height / 1.85; y < height; y += 1) {
		let ny = y / height;
		let noy = noise(ny);
		for (x = 0; x < width; x += 1) {
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = noise(nx, ny);
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2 * nox2;

			let yy = y;

			if (random() > 0.41 && nox2 < 0.75) {
				noStroke();
				fill(random(0, 64), random(64, 128), 128, random(0, 0.05));
				strokeWeight(1);
				let tx = x + random(1, 6);
				let ty = yy + random(1, 6);
				ellipse(x, yy, 1+2 * ny, 1+1 * ny);
				//line(x, yy, tx, ty);
				//line(tx, ty, tx + random(1, 4) * (1-ny), ty - random(1, 1) * (1-ny));
			}
		}
	}
}"
"1044084","Wilderness with pole darker","mySketch","// finally with some clouds :) needed to be tuned a bit!
// different shading on the sea
// change the seeds; shading of both sea & sky vary greatly

function setup() {
	createCanvas(800, 800);
	
	noStroke();
	
	background(0);
	
	colorMode(HSL, 360, 255, 255, 1);
	
	noiseSeed(23);
	noiseDetail(8, 0.75);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	generate();
}

function draw() {
	
}

function generate() {
	noStroke();
				/*		var context = drawingContext
        context.shadowOffsetX = random(-1, 1);
        context.shadowOffsetY = random(-1, 1);
        context.shadowBlur = 1;
        context.shadowColor = ""white"";
	background(0, 0, 255, 1);
	*/
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 2) {
		let ny = y / height;
		for (x = 0; x < width+8; x += 1) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx, ny);
			
			let yy = height / 3.1 + y - n * height;
			fill(200 + 25 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.5 + ny * PI * 2 + 0.25))), 118, 128 + pow(ny, 1) * 128, 1);
			rect(x, yy, 4, 5);
		}
	}
	
	for (y = height/2; y > 0; y -= ystep) {
		let ny = y / (height/2);
		for (x = 0; x < width; x += 3) {
			let nx = x / width;
			let n = noise(nx/2, ny/2);
			let n2 = noise(nx *3, ny *8);
			
			let yy = height + y - n * (height / 12);
			noStroke();
			fill(200 + n2 * 32, 128, 32 + 128 * n2 + 128 - 32 * (pow((1 - ny), 3.25)), 0.25);
			rect(x, yy-height /2, 3, 3);
		}
	}

	for (y = height/1.85; y > 0; y -= 1) {
		let ny = y / height/1.85;
		for (x = 0; x < width; x += 1) {
			if (random() > 0.75) {
				stroke(0, 0, 0, random(0, 0.05));
				let xx = x + random(-4, 4);
				line(xx, y, xx + random(-6, 6)*ny, y + random(-6, 6)*ny);
			}
		}
	}

	for (y = 0; y < height / 2; y += 1) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 8) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.05);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-100, 100), y + random(-100, 100));
			}
		}
	}
							var context = drawingContext
        context.shadowOffsetX = random(-1, 1);
        context.shadowOffsetY = random(-1, 1);
        context.shadowBlur = 1;
        context.shadowColor = ""black"";
	for (y = 0; y < height / 2; y += 1) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 1) {
			let n = noise(x / width, y / height*4);
			if (random() > 0.25 + n) {
				stroke(0, 0, 255, random() * 0.0075*n);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-100, 100), y + random(-20, 20));
			}
		}
	}
	
	let wl = 255 * (height / 976);
	let m = 0; // get max y
	for (y = 0; y < (height - m); y += 1) {
		let ny = y / height;
		let noy = noise(ny);
		
		for (x = -32; x < width+32; x += 1) {
			let yy = (height / 2 + noise(x / width) * 24) + y + m;
			
			let nx = x / width;
			let nox = noise(nx * 1, ny * 1)
			let nox2 = (noise(nx*2, ny*2));
			let nox3 = noise(nx * 2, ny * 3);
			let n = (sin(nx * PI * 2.5 + ny * PI * 10 + nox * PI * 3.15)) / 1.5 * nox2;
			
			if (random() > 0.15) {
				stroke(10 + (nox2) * 40, 140 * nox3, 248*nox3-random(248) * n, random() * 0.5 * pow(ny, 0.3));
				let xx = x + random(-2, 2);
				line(xx, yy, xx + random(-80, 80) * n * noy * ny + nox3*20*ny, yy + random(-140, 140) * n * ny);
			}
			if (random() > 0.05) {
			n = (sin(nx * PI * 1.5 + ny * PI * 8 + nox * PI * 4.15)) / 2 * nox2;
				stroke(10 + (nox2) * 40, 140 * nox3, 200*nox3-random(200) * n, random() * 0.75 * pow(ny, 0.3));
				xx = x + random(-20, 20);
				line(xx, yy, xx + random(-8, 8) * n * noy * ny + nox3*100*ny, yy + random(-140, 140) * n * ny);
		}
			if (random() > 0.05) {
			n = (sin(nx * PI * 1.5 + ny * PI * 4 + nox * PI *3.15)) / 2 * nox2;
				stroke(10 + (nox2) * 30, 140 * nox3, 200*nox3-random(248) * n, random() * 0.75 * pow(ny, 0.3));
				xx = x + random(-4, 4);
				line(xx, yy, xx + random(-40, 40) * n * noy * ny + nox3*80*ny, yy + random(-200, 200) * n * ny);
		}
			if (random() > 0.15) {
			n = (sin(nx * PI * 2.5 + ny * PI * 1 + nox * PI * 2.15)) / 2 * nox2;
				stroke(20 + (nox2) * 30, 140 * nox3, 180*nox3-random(100) * n, random() * 0.75 * pow(ny, 0.3));
				xx = x + random(-20, 20);
				line(xx, yy, xx + random(-80, 80) * n * noy * ny + nox3*70*ny, yy + random(-140, 140) * n * ny);
		}
		}
		
		if (y == height / 5) {
			stroke(0, 0, 0, 1);
			strokeWeight(0.5);
			line(width / 5, height / 2 + y, width / 5, height / 2 + y - height / 12);
			line(width / 5, height / 2 + y, width / 4.25, height / 2 + y - height / 64);
			strokeWeight(1);
		}
	}
	/*
	for (y = 0; y < (height - m); y += 1) {
		let ny = y / height;
		let noy = noise(ny);
		
		for (x = -32; x < width+32; x += 1) {
			let yy = (height / 2 + noise(x / width) * 4) + y + m;
			
			let nx = x / width;
			let nox = noise(nx * 4, ny * 4)
			let nox2 = (noise(nx/2, ny/2));
			let nox3 = noise(nx * 1, ny * 3);
			let ss = exp(-pow(nx - 0.5 + cos(PI * 0.5 + (ny) * PI * 1)/2, 2)*2 + 0.15);
			let n = (sin(nx * PI * 0.5 + ny * PI * 1 + nox * PI * 1.15)) / 0.5 * nox2;
			
			if (random() > 0.0) {
				stroke(10 + (nox2) * 40, 140 * nox3 + 20 * (1-ss), (248*nox3-random(248) * n)+200*(1-ss), random() * 0.5 * pow(ny, 0.3));
				let xx = x + random(-2, 2);
				line(xx, yy, xx + random(-8, 8) * ny + nox3*10*ny * (ss), yy + random(-4, 4) * n * ny);
			}
		}
	}*/

	for (y = 0; y < height / 2; y += 16) {
		let ny = y / height;
		let noy = noise(ny);
		for (x = 0; x < width; x += 3) {
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = noise(nx, ny);
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2 * nox2;

			let yy = y;

			if (random() > 0.9991) {
				stroke(0, 0, 0, 1);
				strokeWeight(0.5);
				let tx = x + random(1, 6);
				let ty = yy + random(1, 6);
				line(x, yy, tx, ty);
				line(tx, ty, tx + random(1, 4) * (1-ny), ty - random(1, 1) * (1-ny));
			}
		}
	}
	
	for (y = height / 1.85; y < height; y += 1) {
		let ny = y / height;
		let noy = noise(ny);
		for (x = 0; x < width; x += 1) {
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = noise(nx, ny);
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2 * nox2;

			let yy = y;

			if (random() > 0.41 && nox2 < 0.75) {
				noStroke();
				fill(random(0, 64), random(64, 128), 128, random(0, 0.05));
				strokeWeight(1);
				let tx = x + random(1, 6);
				let ty = yy + random(1, 6);
				ellipse(x, yy, 1+2 * ny, 1+1 * ny);
				//line(x, yy, tx, ty);
				//line(tx, ty, tx + random(1, 4) * (1-ny), ty - random(1, 1) * (1-ny));
			}
		}
	}
}"
"1043568","Wild tsunami with pole","mySketch","// finally with some clouds :) needed to be tuned a bit!
// different shading on the sea
// change the seeds; shading of both sea & sky vary greatly

function setup() {
	createCanvas(600, 600);
	
	noStroke();
	
	background(0);
	
	colorMode(HSL, 360, 255, 255, 1);
	
	noiseSeed(23);
	noiseDetail(8, 0.75);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	generate();
}

function draw() {
	
}

function generate() {
	noStroke();
				/*		var context = drawingContext
        context.shadowOffsetX = random(-1, 1);
        context.shadowOffsetY = random(-1, 1);
        context.shadowBlur = 1;
        context.shadowColor = ""white"";
	background(0, 0, 255, 1);
	*/
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 2) {
		let ny = y / height;
		for (x = 0; x < width+8; x += 1) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx, ny);
			
			let yy = height / 3.1 + y - n * height;
			fill(200 + 25 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.5 + ny * PI * 2 + 0.25))), 118, 128 + pow(ny, 1) * 128, 1);
			rect(x, yy, 4, 5);
		}
	}
	
	for (y = height/2; y > 0; y -= ystep) {
		let ny = y / (height/2);
		for (x = 0; x < width; x += 3) {
			let nx = x / width;
			let n = noise(nx/2, ny/2);
			let n2 = noise(nx *3, ny *8);
			
			let yy = height + y - n * (height / 12);
			noStroke();
			fill(200 + n2 * 32, 128, 32 + 128 * n2 + 128 - 32 * (pow((1 - ny), 3.25)), 0.25);
			rect(x, yy-height /2, 3, 3);
		}
	}
						var context = drawingContext
        context.shadowOffsetX = random(-1, 1);
        context.shadowOffsetY = random(-1, 1);
        context.shadowBlur = 1;
        context.shadowColor = ""white"";
	for (y = height/1.85; y > 0; y -= 1) {
		let ny = y / height/1.85;
		for (x = 0; x < width; x += 1) {
			if (random() > 0.75) {
				stroke(0, 0, 0, random(0, 0.05));
				let xx = x + random(-4, 4);
				line(xx, y, xx + random(-6, 6)*ny, y + random(-6, 6)*ny);
			}
		}
	}

	for (y = 0; y < height / 2; y += 1) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 8) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.05);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-100, 100), y + random(-100, 100));
			}
		}
	}
	
	for (y = 0; y < height / 2; y += 1) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 1) {
			let n = noise(x / width, y / height*4);
			if (random() > 0.25 + n) {
				stroke(0, 0, 255, random() * 0.0075*n);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-100, 100), y + random(-20, 20));
			}
		}
	}
	
	let wl = 255 * (height / 976);
	let m = 0; // get max y
	for (y = 0; y < (height - m); y += 1) {
		let ny = y / height;
		let noy = noise(ny);
		
		for (x = -32; x < width+32; x += 1) {
			let yy = (height / 2 + noise(x / width) * 24) + y + m;
			
			let nx = x / width;
			let nox = noise(nx * 1, ny * 1)
			let nox2 = (noise(nx*2, ny*2));
			let nox3 = noise(nx * 2, ny * 3);
			let n = (sin(nx * PI * 2.5 + ny * PI * 10 + nox * PI * 3.15)) / 1.5 * nox2;
			
			if (random() > 0.15) {
				stroke(10 + (nox2) * 40, 140 * nox3, 248*nox3-random(248) * n, random() * 0.5 * pow(ny, 0.3));
				let xx = x + random(-2, 2);
				line(xx, yy, xx + random(-80, 80) * n * noy * ny + nox3*20*ny, yy + random(-140, 140) * n * ny);
			}
			if (random() > 0.05) {
			n = (sin(nx * PI * 1.5 + ny * PI * 8 + nox * PI * 4.15)) / 2 * nox2;
				stroke(10 + (nox2) * 40, 140 * nox3, 200*nox3-random(200) * n, random() * 0.75 * pow(ny, 0.3));
				xx = x + random(-20, 20);
				line(xx, yy, xx + random(-8, 8) * n * noy * ny + nox3*100*ny, yy + random(-140, 140) * n * ny);
		}
			if (random() > 0.05) {
			n = (sin(nx * PI * 1.5 + ny * PI * 4 + nox * PI *3.15)) / 2 * nox2;
				stroke(10 + (nox2) * 30, 140 * nox3, 200*nox3-random(248) * n, random() * 0.75 * pow(ny, 0.3));
				xx = x + random(-4, 4);
				line(xx, yy, xx + random(-40, 40) * n * noy * ny + nox3*80*ny, yy + random(-200, 200) * n * ny);
		}
			if (random() > 0.15) {
			n = (sin(nx * PI * 2.5 + ny * PI * 1 + nox * PI * 2.15)) / 2 * nox2;
				stroke(20 + (nox2) * 30, 140 * nox3, 180*nox3-random(100) * n, random() * 0.75 * pow(ny, 0.3));
				xx = x + random(-20, 20);
				line(xx, yy, xx + random(-80, 80) * n * noy * ny + nox3*70*ny, yy + random(-140, 140) * n * ny);
		}
		}
		
		if (y == height / 5) {
			stroke(0, 0, 0, 1);
			strokeWeight(0.5);
			line(width / 5, height / 2 + y, width / 5, height / 2 + y - height / 12);
			line(width / 5, height / 2 + y, width / 4.25, height / 2 + y - height / 64);
			strokeWeight(1);
		}
	}
	/*
	for (y = 0; y < (height - m); y += 1) {
		let ny = y / height;
		let noy = noise(ny);
		
		for (x = -32; x < width+32; x += 1) {
			let yy = (height / 2 + noise(x / width) * 4) + y + m;
			
			let nx = x / width;
			let nox = noise(nx * 4, ny * 4)
			let nox2 = (noise(nx/2, ny/2));
			let nox3 = noise(nx * 1, ny * 3);
			let ss = exp(-pow(nx - 0.5 + cos(PI * 0.5 + (ny) * PI * 1)/2, 2)*2 + 0.15);
			let n = (sin(nx * PI * 0.5 + ny * PI * 1 + nox * PI * 1.15)) / 0.5 * nox2;
			
			if (random() > 0.0) {
				stroke(10 + (nox2) * 40, 140 * nox3 + 20 * (1-ss), (248*nox3-random(248) * n)+200*(1-ss), random() * 0.5 * pow(ny, 0.3));
				let xx = x + random(-2, 2);
				line(xx, yy, xx + random(-8, 8) * ny + nox3*10*ny * (ss), yy + random(-4, 4) * n * ny);
			}
		}
	}*/

	for (y = 0; y < height / 2; y += 16) {
		let ny = y / height;
		let noy = noise(ny);
		for (x = 0; x < width; x += 3) {
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = noise(nx, ny);
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2 * nox2;

			let yy = y;

			if (random() > 0.9991) {
				stroke(0, 0, 0, 1);
				strokeWeight(0.5);
				let tx = x + random(1, 6);
				let ty = yy + random(1, 6);
				line(x, yy, tx, ty);
				line(tx, ty, tx + random(1, 4) * (1-ny), ty - random(1, 1) * (1-ny));
			}
		}
	}
	
	for (y = height / 1.85; y < height; y += 1) {
		let ny = y / height;
		let noy = noise(ny);
		for (x = 0; x < width; x += 1) {
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = noise(nx, ny);
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2 * nox2;

			let yy = y;

			if (random() > 0.41 && nox2 < 0.75) {
				noStroke();
				fill(random(0, 64), random(64, 128), 128, random(0, 0.05));
				strokeWeight(1);
				let tx = x + random(1, 6);
				let ty = yy + random(1, 6);
				ellipse(x, yy, 1+2 * ny, 1+1 * ny);
				//line(x, yy, tx, ty);
				//line(tx, ty, tx + random(1, 4) * (1-ny), ty - random(1, 1) * (1-ny));
			}
		}
	}
}"
"1043504","The tree","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 6;

function setup() {
  createCanvas(800, 800);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (1.0 + abs(sin(x / width * PI * 1.25 + cos(y / height * PI * 0.25 + pow(x/ width, 1) * PI * 0.05)))), y: (width / (1) + x - y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.25 * x) / 1 + j * (70), y: (height / 8 - y * 2 / j + (x / 4.0)) / 1.0 + j * (70) };
}

function f3(x, y, j) {
	return { x: (width * 0.5 - x * j) / (24 * (j / 16) + x / (width / (10))), y: y / 3 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (3.25) - x + y / (1.95 * j * ((0.5 - y / width) * 10))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 10, y: (height / 2 - y * 1.15 / j + (x / 10.075)) / 1.75 + j * (50) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (4.0 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 5000) {
		for (let i = 0; i < 10000; i += 1) {
			for (let j = 5; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let ny1 = x[j] / width;
				let nx1 = y[j] / height;
				let inx1 =((1.5)+pow((0.5-nx1), 8));
				let nx2 = y2[j] / height;
				let inx2 = 0.95+pow((0.5-nx1), 16);
				
				let e = 0.75;

				if (iter > 20) {
					stroke((xmotion*64+iter*64)%360, 128, 255, 0.0125 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);
					//point(width - x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					//point(x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					
					//point(x2[j] * inx2+5, height / 1 - y2[j]/2.5);
					//point(width - x2[j] * inx2-5, height / 1 - y2[j]/2.5);
					//point(width / 2 - x[j] / 3.0 * inx1 - width / 4 * sin(nx1*PI*0.5), y[j]/4);
					//point(width - (width / 2 - x[j] / 3.0 * inx1 - width / 4 * sin(nx1*PI*0.5)), y[j]/4);
					//point(x[j] / 8, y[j]/4);
					//point(y[j] / 4, x[j]/8);
					point(width /1.65- y[j] / 2 * inx2, x[j]/6);
					point(width-(width /1.65- y[j] / 2 * inx2), x[j]/6);
					//point(width / 1.9 + x[j] / 8.0 * inx1 + width / 2 * abs(cos(ny1*PI*0.5 * pow(sin(nx1 * PI *0.25), 4))), height - (y[j]/2.5) - height / 2);
					//point(width - (width / 1.9 + x[j] / 8.0 * inx1 + width / 2 * abs(cos(ny1*PI*0.5 * pow(sin(nx1 * PI *0.25), 4)))), height - (y[j]/2.5) - height / 2);
					point(width / 12 + x[j] / 8.5 * inx1 + width / 2 * abs(cos(ny1*PI*0.25 * pow(sin(nx1 * PI *0.25), 4))), height / 8 + y[j]/2.1);
					point(width - (width / 12 + x[j] / 8.5 * inx1 + width / 2 * abs(cos(ny1*PI*0.25 * pow(sin(nx1 * PI *0.25), 4)))), height / 8 + y[j]/2.1);
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	} else {
		iter = 0;
		xmotion += 0.01;
	}

	//xmotion += 1;
	ymotion += 0.25;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"1042199","Wild","mySketch","// finally with some clouds :) needed to be tuned a bit!
// different shading on the sea
// change the seeds; shading of both sea & sky vary greatly

function setup() {
	createCanvas(600, 600);
	
	noStroke();
	
	background(0);
	
	colorMode(HSL, 360, 255, 255, 1);
	
	noiseSeed(23);
	noiseDetail(8, 0.75);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	generate();
}

function draw() {
	
}

function generate() {
	noStroke();
						var context = drawingContext
        context.shadowOffsetX = random(-1, 1);
        context.shadowOffsetY = random(-1, 1);
        context.shadowBlur = 1;
        context.shadowColor = ""white"";
	background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 2) {
		let ny = y / height;
		for (x = 0; x < width+8; x += 1) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx, ny);
			
			let yy = height / 3.1 + y - n * height;
			fill(200 + 25 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.5 + ny * PI * 2 + 0.25))), 118, 128 + pow(ny, 1) * 128, 1);
			rect(x, yy, 4, 5);
		}
	}
	
	for (y = height/1.85; y > 0; y -= 1) {
		let ny = y / height/1.85;
		for (x = 0; x < width; x += 1) {
			if (random() > 0.75) {
				stroke(0, 0, 0, random(0, 0.05));
				let xx = x + random(-4, 4);
				line(xx, y, xx + random(-6, 6)*ny, y + random(-6, 6)*ny);
			}
		}
	}

	for (y = 0; y < height / 2; y += 1) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 8) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.05);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-100, 100), y + random(-100, 100));
			}
		}
	}
	
	for (y = 0; y < height / 2; y += 1) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 1) {
			let n = noise(x / width, y / height*4);
			if (random() > 0.25 + n) {
				stroke(0, 0, 255, random() * 0.0075*n);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-100, 100), y + random(-20, 20));
			}
		}
	}
	
	let wl = 255 * (height / 976);
	let m = 0; // get max y
	for (y = 0; y < (height - m); y += 1) {
		let ny = y / height;
		let noy = noise(ny);
		
		for (x = -32; x < width+32; x += 1) {
			let yy = (height / 2 + noise(x / width) * 24) + y + m;
			
			let nx = x / width;
			let nox = noise(nx * 1, ny * 1)
			let nox2 = (noise(nx*2, ny*2));
			let nox3 = noise(nx * 2, ny * 3);
			let n = (sin(nx * PI * 2.5 + ny * PI * 10 + nox * PI * 3.15)) / 1.5 * nox2;
			
			if (random() > 0.15) {
				stroke(10 + (nox2) * 40, 140 * nox3, 248*nox3-random(248) * n, random() * 0.5 * pow(ny, 0.3));
				let xx = x + random(-2, 2);
				line(xx, yy, xx + random(-80, 80) * n * noy * ny + nox3*20*ny, yy + random(-140, 140) * n * ny);
			}
			if (random() > 0.05) {
			n = (sin(nx * PI * 1.5 + ny * PI * 8 + nox * PI * 4.15)) / 2 * nox2;
				stroke(10 + (nox2) * 40, 140 * nox3, 200*nox3-random(200) * n, random() * 0.75 * pow(ny, 0.3));
				xx = x + random(-20, 20);
				line(xx, yy, xx + random(-8, 8) * n * noy * ny + nox3*100*ny, yy + random(-140, 140) * n * ny);
		}
			if (random() > 0.05) {
			n = (sin(nx * PI * 1.5 + ny * PI * 4 + nox * PI *3.15)) / 2 * nox2;
				stroke(10 + (nox2) * 30, 140 * nox3, 200*nox3-random(248) * n, random() * 0.75 * pow(ny, 0.3));
				xx = x + random(-4, 4);
				line(xx, yy, xx + random(-40, 40) * n * noy * ny + nox3*80*ny, yy + random(-200, 200) * n * ny);
		}
			if (random() > 0.15) {
			n = (sin(nx * PI * 2.5 + ny * PI * 1 + nox * PI * 2.15)) / 2 * nox2;
				stroke(20 + (nox2) * 30, 140 * nox3, 180*nox3-random(100) * n, random() * 0.75 * pow(ny, 0.3));
				xx = x + random(-20, 20);
				line(xx, yy, xx + random(-80, 80) * n * noy * ny + nox3*70*ny, yy + random(-140, 140) * n * ny);
		}
		}
	}
	/*
	for (y = 0; y < (height - m); y += 1) {
		let ny = y / height;
		let noy = noise(ny);
		
		for (x = -32; x < width+32; x += 1) {
			let yy = (height / 2 + noise(x / width) * 4) + y + m;
			
			let nx = x / width;
			let nox = noise(nx * 4, ny * 4)
			let nox2 = (noise(nx/2, ny/2));
			let nox3 = noise(nx * 1, ny * 3);
			let ss = exp(-pow(nx - 0.5 + cos(PI * 0.5 + (ny) * PI * 1)/2, 2)*2 + 0.15);
			let n = (sin(nx * PI * 0.5 + ny * PI * 1 + nox * PI * 1.15)) / 0.5 * nox2;
			
			if (random() > 0.0) {
				stroke(10 + (nox2) * 40, 140 * nox3 + 20 * (1-ss), (248*nox3-random(248) * n)+200*(1-ss), random() * 0.5 * pow(ny, 0.3));
				let xx = x + random(-2, 2);
				line(xx, yy, xx + random(-8, 8) * ny + nox3*10*ny * (ss), yy + random(-4, 4) * n * ny);
			}
		}
	}*/

	for (y = 0; y < height / 2; y += 16) {
		let ny = y / height;
		let noy = noise(ny);
		for (x = 0; x < width; x += 3) {
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = noise(nx, ny);
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2 * nox2;

			let yy = y;

			if (random() > 0.9991) {
				stroke(0, 0, 0, 1);
				strokeWeight(0.5);
				let tx = x + random(1, 6);
				let ty = yy + random(1, 6);
				line(x, yy, tx, ty);
				line(tx, ty, tx + random(1, 4) * (1-ny), ty - random(1, 1) * (1-ny));
			}
		}
	}
	
	for (y = height / 1.85; y < height; y += 1) {
		let ny = y / height;
		let noy = noise(ny);
		for (x = 0; x < width; x += 1) {
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = noise(nx, ny);
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2 * nox2;

			let yy = y;

			if (random() > 0.71 && nox2 < 0.65) {
				noStroke();
				fill(random(0, 32), random(64, 128), 128, random(0, 0.15));
				strokeWeight(1);
				let tx = x + random(1, 6);
				let ty = yy + random(1, 6);
				ellipse(x, yy, 1+2 * ny, 1+2 * ny);
				//line(x, yy, tx, ty);
				//line(tx, ty, tx + random(1, 4) * (1-ny), ty - random(1, 1) * (1-ny));
			}
		}
	}
}"
"1041918","Tun","mySketch","function setup() {
	createCanvas(1080, 566);
	
	noStroke();
	
	background(0);
	
	colorMode(HSL, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	generate();
}

function draw() {
	
}

function generate() {
	noStroke();
	
	background(0, 0, 255, 1);
	
	let x = 0, y = 0;
					var context = drawingContext
        context.shadowOffsetX = random(-1, 1);
        context.shadowOffsetY = random(-1, 1);
        context.shadowBlur = 1;
        context.shadowColor = ""white"";
	for (y = -128; y < height + height; y += 1) {
		let ny = y / height;
		let noy = noise(ny*2);
		
		for (x = 0; x < width / 2; x += 2) {			
			if (random() > 0.3) {
				let yy = y * 0.8;

				let nox0 = x / width;
				let nx = (sin((0.5 - nox0) * 2 * PI * 1.05 + ny * PI * 0.25));
				let nox = noise(nx * 2, ny * 2);
				let nox2 = (0.5 - noise(nx/2, ny/2)) * 2;
				let nox3 = noise(nx * 2, ny * 2);
				let n = (sin(nx * PI * 0.005 + ny * PI * 0.1 + nox * PI * 1));
				
				let xx = x + nox * 32 + width / 2;
				let yh2 = (width / 48) * nox2 * pow(ny, 0.7);
				noStroke();
				
				let off = width / 32;

				stroke(200 + abs(nox2) * 8, 64 + 64 * abs(nox2), 160 - 70 * nx + 60 * abs(n), 0.088 * abs(n) * pow(ny / 2, 0.8) + 0.25 * pow(nx / 2.2, 4));
				line(xx+off, height - yy, xx+off + nox2 * (width / 16) * pow(1 - ny, 3) * 3, height - yy - yh2);
				line(width - (xx + off), height - yy, width - (xx+off + nox2 * (width / 16) * pow(1 - ny, 3) * 3), height - (yy + yh2));
			}
		}
	}
	
	let cx = width / 2;
	let cy = height / 2.5;
	let rr = height * 8;
	
	strokeWeight(1);
	for (y = 0; y < 10000; y += 1) {
		let cyy = y / 10000;
		let cccx = cx + sin(cyy * PI * 2) * (rr / 2.05);
		stroke(random(50, 60), random(128, 200), 255, 0.05);
		line(cccx + random(-cx, cx) / 16, cy + random(-cx, cx) / 16 - rr / 2.5 + cos(cyy * PI * 2) * (rr / 1.85), cx, cy / 2);
	}
	/*
	rr = height / 64;
	for (y = 0; y < 100; y += 1) {
		let cyy = y / 100;
		let cccx = cx + sin(cyy * PI * 2) * (rr / 2.05);
		stroke(random(50, 60), random(128, 200), random(230, 255), 0.5);
		line(cccx + random(-cx, cx), cy + random(-cx, cx) - rr / 2.5 + cos(cyy * PI * 2) * (rr / 1.85), cx, cy / 2);
	}
	*/
	//noStroke();
	//fill(random(50, 60), 128, 255, 1);
	//ellipse(cx, cy - rr / 2.5, width / 48, height / 24);
}"
"1041857","Distant beacon","mySketch","function setup() {
	createCanvas(1080, 566);
	
	noStroke();
	
	background(0);
	
	colorMode(HSL, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	generate();
}

function draw() {
	
}

function generate() {
	noStroke();
	
	background(0, 0, 255, 1);
	
	let x = 0, y = 0;
					var context = drawingContext
        context.shadowOffsetX = random(-1, 1);
        context.shadowOffsetY = random(-1, 1);
        context.shadowBlur = 1;
        context.shadowColor = ""white"";
	for (y = -128; y < height + height; y += 1) {
		let ny = y / height;
		let noy = noise(ny);
		
		for (x = 0; x < width / 2; x += 2) {			
			if (random() > 0.3) {
				let yy = y * 0.8;

				let nox0 = x / width;
				let nx = abs(0.5 - nox0) * 2;
				let nox = noise(nx * 8, ny * 8);
				let nox2 = (0.5 - noise(nx, ny)) * 2;
				let nox3 = noise(nx * 2, ny * 2);
				let n = (sin(nx * PI * 0.5 + ny * PI * 2 + nox * PI * 10));
				
				let xx = x + random(-2, 2) + width / 2;
				let yh2 = (width / 48) * nox2 * pow(ny, 0.7);
				noStroke();

				stroke(210 + abs(nox2) * 8, 32 + 64 * abs(nox2), 160 - 110 * nx + 90 * abs(n), 0.068 * abs(n) * pow(ny / 2, 0.8) + 0.5 * pow(nx / 2.1, 4));
				line(xx, height - yy, xx + nox2 * (width / 32) * (1 - ny) * 5, height - yy - yh2);
				line(width - xx, height - yy, width - (xx + nox2 * (width / 32) * (1 - ny) * 5), height - (yy + yh2));
			}
		}
	}
	
	let cx = width / 2;
	let cy = height / 2.5;
	let rr = height * 8;
	
	strokeWeight(1);
	for (y = 0; y < 4000; y += 1) {
		let cyy = y / 4000;
		let cccx = cx + sin(cyy * PI * 2) * (rr / 2.05);
		stroke(random(50, 60), random(128, 200), 255, 0.05);
		line(cccx + random(-cx, cx) / 16, cy + random(-cx, cx) / 16 - rr / 2.5 + cos(cyy * PI * 2) * (rr / 1.85), cx, cy / 2);
	}
	/*
	rr = height / 64;
	for (y = 0; y < 100; y += 1) {
		let cyy = y / 100;
		let cccx = cx + sin(cyy * PI * 2) * (rr / 2.05);
		stroke(random(50, 60), random(128, 200), random(230, 255), 0.5);
		line(cccx + random(-cx, cx), cy + random(-cx, cx) - rr / 2.5 + cos(cyy * PI * 2) * (rr / 1.85), cx, cy / 2);
	}
	*/
	//noStroke();
	//fill(random(50, 60), 128, 255, 1);
	//ellipse(cx, cy - rr / 2.5, width / 48, height / 24);
}"
"1041855","Distant beacon 2","mySketch","function setup() {
	createCanvas(1280, 800);
	
	noStroke();
	
	background(0);
	
	colorMode(HSL, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	generate();
}

function draw() {
	
}

function generate() {
	noStroke();
	
	background(0, 0, 255, 1);
	
	let x = 0, y = 0;
					var context = drawingContext
        context.shadowOffsetX = random(-1, 1);
        context.shadowOffsetY = random(-1, 1);
        context.shadowBlur = 1;
        context.shadowColor = ""white"";
	for (y = -128; y < height + height; y += 1) {
		let ny = y / height;
		let noy = noise(ny*8);
		
		for (x = 0; x < width / 2; x += 2) {			
			if (random() > 0.4) {
				let yy = y * 0.8;

				let nox0 = x / width;
				let nx = abs(0.5 - nox0) * 2;
				let nox = noise(nx * 2, ny * 2);
				let nox2 = (0.5 - noise(nx*8, ny/1)) * 2;
				let nox3 = noise(nx * 2, ny * 2);
				let n = (sin(nx * PI * 0.005 + ny * PI * 0.1 + nox * PI * 1));
				
				let xx = x + random(-2, 2) + width / 2;
				let yh2 = (width / 48) * nox2 * pow(ny, 0.7);
				noStroke();

				stroke(200 + abs(nox2) * 8, 32 + 64 * abs(nox2), 160 - 70 * nx + 60 * abs(n), 0.078 * abs(n) * pow(ny / 2, 0.8) + 0.5 * pow(nx / 1.1, 4));
				line(xx, height - yy, xx + nox2 * (width / 24) * (1 - ny) * 3, height - yy - yh2);
				line(width - xx, height - yy, width - (xx + nox2 * (width / 24) * (1 - ny) * 5), height - (yy + yh2));
			}
		}
	}
	
	let cx = width / 2;
	let cy = height / 2.5;
	let rr = height * 8;
	
	strokeWeight(1);
	for (y = 0; y < 10000; y += 1) {
		let cyy = y / 10000;
		let cccx = cx + sin(cyy * PI * 2) * (rr / 2.05);
		stroke(random(50, 60), random(128, 200), 255, 0.05);
		line(cccx + random(-cx, cx) / 16, cy + random(-cx, cx) / 16 - rr / 2.5 + cos(cyy * PI * 2) * (rr / 1.85), cx, cy / 2);
	}
	/*
	rr = height / 64;
	for (y = 0; y < 100; y += 1) {
		let cyy = y / 100;
		let cccx = cx + sin(cyy * PI * 2) * (rr / 2.05);
		stroke(random(50, 60), random(128, 200), random(230, 255), 0.5);
		line(cccx + random(-cx, cx), cy + random(-cx, cx) - rr / 2.5 + cos(cyy * PI * 2) * (rr / 1.85), cx, cy / 2);
	}
	*/
	//noStroke();
	//fill(random(50, 60), 128, 255, 1);
	//ellipse(cx, cy - rr / 2.5, width / 48, height / 24);
}"
"1039860","L-systems patterns 2","mySketch","// some more improvements / polish over the dynamic L-systems idea (colors with shadow outline, refined parameters)
// endless automatic drawing patterns fun by tweaking the rules, initial angle, step, colors, compositing... !
// with different starting position, wrap around borders instead of bounce

// an excellent source of documented rules : http://paulbourke.net/fractals/lsys/

function pal(t, a, b, c, d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

function weightedRandom(prob) {
  let i, sum=0, r=Math.random();
  for (i in prob) {
    sum += prob[i];
    if (r <= sum) return i;
  }
}

class lm {
	constructor(axiom, rules, angle, step, sx, sy, iter) {
		this.ax = sx;
		this.ay = sy;
		this.px = this.ax;
		this.py = this.ay;
		this.ta = angle;
		this.ca = PI;
		this.fs = step;
		
		this.stack = [];
		
		this.axiom = axiom;
		this.rules = rules;
		this.itera = iter;
		
		this.rule = 0;
		
		this.cycles = 0;
		
		this.b = false;
		
		this.where = 1;
		
		this.initialize();
	}
	
	initialize() {
		let rule = this.axiom;
		for (let i = 0; i < this.itera; i++) {
			rule = this.lindenmayer(rule);
		}
		
		this.rule = rule;
	}
	
	lindenmayer(s) {
		let outputstring = '';

		for (let i = 0; i < s.length; i++) {
			let ismatch = 0;
			for (let j = 0; j < this.rules.length; j++) {
				if (s[i] == this.rules[j][0])  {
					let rule_index = 1;
					if (this.rules[j].length > 2) { // stochastic
						let probs = {};
						for (let k = 1; k < this.rules[j].length; k+=2) {
							probs[k+1] = this.rules[j][k];
						}
						rule_index = weightedRandom(probs);
					}
					outputstring += this.rules[j][rule_index];
					ismatch = 1;
					break;
				}
			}

			if (ismatch == 0) outputstring+= s[i];
		}
		
		return outputstring;
	}
	
	computeParameters(w) {
		
	}
	
	compute(cb_trigger) {
		let k = this.rule[this.where];
		if (k == 'F' || k == 'f') {
			var polx = this.fs * sin(this.ca);
			var poly = this.fs * cos(this.ca);
			let x1 = this.b ? this.px - polx : this.px + polx;
			let y1 = this.b ? this.py - poly : this.py + poly;

			if (x1 < 0 || y1 < 0 || x1 > width || y1 > height) {
				this.b = !this.b;
				this.ta = -this.ta;//random() * PI * 2;
				
				if (x1 < 0) { x1 = width; this.px = width; if (random() > 0.99995) { y1 += 1; if (y1 >= height) { y1 -= height; this.py = y1; } } }
				if (y1 < 0) { y1 = height; this.py = height; if (random() > 0.99995) { x1 += 1; if (x1 >= width) { x1 %= width; this.px = x1; } } }
				if (x1 > width) { x1 = 0; this.px = 0; }
				if (y1 > height) { y1 = 0; this.py = 0; }
			}

			this.ax = this.px;
			this.ay = this.py;
			this.px = x1;
			this.py = y1;
		} else if (k == '[') {
			this.stack.push(this.px);
			this.stack.push(this.py);
			this.stack.push(this.ca);
		} else if (k == ']') {
			this.ca = this.stack.pop();
			this.py = this.stack.pop();
			this.px = this.stack.pop();
		} else if (k == '+') {
			this.ca += this.ta;
		} else if (k == '-') {
			this.ca -= this.ta;
		}
		
		this.where++;
  	if (this.where > this.rule.length-1) {
			this.where = 0;
			this.cycles += 1;
			
			cb_trigger(this);
		}
		
		if (k == 'F') {
			return true;
		} else {
			return false;
		}
	}
}

var xmotion = 0;
var ymotion = 0;

let lms = [];

function setup() {
  createCanvas(800, 800);
  background(0);
	
	noiseDetail(7, 0.7);
	//colorMode(HSB, 360, 100, 100, 255);
	
	//blendMode(LIGHTEST);
	
	stroke(0, 0, 100, 255);
 // lms[0] = new lm('X', [['X', 0.5, 'XFFFF-[F-X+]FX+', 0.5, 'FFFFF[f+F]------------F'], ['F', '+F--F+']], radians(45), 1);
	let amount = 8;
	for (let i = 0; i < amount; i += 1) {
		let r = radians(10 + 180* ((((1+i) / amount)*2)-1));
		let s = 2;
		let sx = random(1, width-1);
		let sy = random(1, height-1);
		if (i % 2 == 0)
			lms[i] = new lm('F+F+F+F', [['F', 'FF+[+F-F-F]-[-F+F+F]']], r, 1, sx, sy, 2);
	  //else if (i % 4 == 1)
		else
			lms[i] = new lm('F+F+F+F', [['F', 'FF+F+F+F+FF']], r, s, sx, sy, 3);
	  //else if (i % 4 == 2)
		//	lms[i] = new lm('XF', [['X', 'X+YF++YF-FX--FXFX-YF+'], ['Y', '-FX+YFYF++YF+FX--FX-Y']], radians(90), s, sx, sy, 5);
		//else
		//	lms[i] = new lm('X', [['X', '-YF+XFX+FY-'], ['Y', '+XF-YFY-FX+']], radians(90), s, sx, sy, 5);
	}
	//lms[1] = new lm('X', [['X', 'F-[[X]+X]+F[+FX]-X'], ['F', 'FF']], radians(90), 1);
}

function change(lm) {
	let max_cycles = 1;
	noStroke();
	if (lm.cycles % max_cycles == 0) {
		
		lm.ta += 0.001;//= random(0, PI*2);
		lm.fs = random(2, 6);
		
		//fill(0, 0, 0, 92);
		//rect(0, 0, width, height);
	}
	
	/*
	if (lm.cycles % 16 == 0) {
		fill(0, 0, 0, 48);
		rect(0, 0, width, height);
	}
	*/
	
	let nc = (lm.cycles % 8) / 8;
	stroke(0, 0, 100, random(0, 10));
	
	//if (random() > 0.25) {
		lm.iter = 1;
		lm.initialize();
	/*} else {
		lm.iter = 2;
		lm.initialize();
	}*/
}

function draw() {
	for (let k = 0; k < 240; k += 1) {
		for (let i = 0; i < lms.length; i += 1) {
			let lm = lms[i];
			
			let result = lm.compute(change);
			
			if (result) {
				//stroke(k / 3 + abs(sin(xmotion/24))*180, 30, 255, 255);
			var pa1 = 0.75, pa2 = 0.95, pa3 = 0.95;
			var pb1 = 1/i, pb2 = 0.5/i, pb3 = 0.5/i;
			var pc1 = 1, pc2 = 1, pc3 = 1;

			var pdr = 1/i;
			var pdg = 1/i;
			var pdb = 1/i;

				var pt = abs(sin(xmotion + i));

				var rf = pal(pt, pa1, pb1, pc1, pdr) * 255;
				var gf = pal(pt, pa2, pb2, pc2, pdg) * 255;
				var bf = pal(pt, pa3, pb3, pc3, pdb) * 255;

				stroke(rf, gf, bf, 255);
				
				strokeWeight(1/* + abs(sin(xmotion/16+i))*8*/);
				var context = drawingContext
        context.shadowOffsetX = random(-1, 1);
        context.shadowOffsetY = random(-1, 1);
        context.shadowBlur = 4;
        context.shadowColor = ""black"";
				line(lm.px, lm.py, lm.ax, lm.ay);
			}
		}
	}
	
	xmotion += 0.5;
	ymotion += 0.25;
}"
"1039855","L-systems patterns","mySketch","// some more improvements / polish over the dynamic L-systems idea (colors with shadow outline, refined parameters)
// endless automatic drawing patterns fun by tweaking the rules, initial angle, step, colors, compositing... !
// with different starting position, wrap around borders instead of bounce

// an excellent source of documented rules : http://paulbourke.net/fractals/lsys/

function pal(t, a, b, c, d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

function weightedRandom(prob) {
  let i, sum=0, r=Math.random();
  for (i in prob) {
    sum += prob[i];
    if (r <= sum) return i;
  }
}

class lm {
	constructor(axiom, rules, angle, step, sx, sy, iter) {
		this.ax = sx;
		this.ay = sy;
		this.px = this.ax;
		this.py = this.ay;
		this.ta = angle;
		this.ca = PI;
		this.fs = step;
		
		this.stack = [];
		
		this.axiom = axiom;
		this.rules = rules;
		this.itera = iter;
		
		this.rule = 0;
		
		this.cycles = 0;
		
		this.b = false;
		
		this.where = 1;
		
		this.initialize();
	}
	
	initialize() {
		let rule = this.axiom;
		for (let i = 0; i < this.itera; i++) {
			rule = this.lindenmayer(rule);
		}
		
		this.rule = rule;
	}
	
	lindenmayer(s) {
		let outputstring = '';

		for (let i = 0; i < s.length; i++) {
			let ismatch = 0;
			for (let j = 0; j < this.rules.length; j++) {
				if (s[i] == this.rules[j][0])  {
					let rule_index = 1;
					if (this.rules[j].length > 2) { // stochastic
						let probs = {};
						for (let k = 1; k < this.rules[j].length; k+=2) {
							probs[k+1] = this.rules[j][k];
						}
						rule_index = weightedRandom(probs);
					}
					outputstring += this.rules[j][rule_index];
					ismatch = 1;
					break;
				}
			}

			if (ismatch == 0) outputstring+= s[i];
		}
		
		return outputstring;
	}
	
	computeParameters(w) {
		
	}
	
	compute(cb_trigger) {
		let k = this.rule[this.where];
		if (k == 'F' || k == 'f') {
			var polx = this.fs * sin(this.ca);
			var poly = this.fs * cos(this.ca);
			let x1 = this.b ? this.px - polx : this.px + polx;
			let y1 = this.b ? this.py - poly : this.py + poly;

			if (x1 < 0 || y1 < 0 || x1 > width || y1 > height) {
				this.b = !this.b;
				this.ta = -this.ta;//random() * PI * 2;
				
				if (x1 < 0) { x1 = width; this.px = width; if (random() > 0.99995) { y1 += 1; if (y1 >= height) { y1 -= height; this.py = y1; } } }
				if (y1 < 0) { y1 = height; this.py = height; if (random() > 0.99995) { x1 += 1; if (x1 >= width) { x1 %= width; this.px = x1; } } }
				if (x1 > width) { x1 = 0; this.px = 0; }
				if (y1 > height) { y1 = 0; this.py = 0; }
			}

			this.ax = this.px;
			this.ay = this.py;
			this.px = x1;
			this.py = y1;
		} else if (k == '[') {
			this.stack.push(this.px);
			this.stack.push(this.py);
			this.stack.push(this.ca);
		} else if (k == ']') {
			this.ca = this.stack.pop();
			this.py = this.stack.pop();
			this.px = this.stack.pop();
		} else if (k == '+') {
			this.ca += this.ta;
		} else if (k == '-') {
			this.ca -= this.ta;
		}
		
		this.where++;
  	if (this.where > this.rule.length-1) {
			this.where = 0;
			this.cycles += 1;
			
			cb_trigger(this);
		}
		
		if (k == 'F') {
			return true;
		} else {
			return false;
		}
	}
}

var xmotion = 0;
var ymotion = 0;

let lms = [];

function setup() {
  createCanvas(840, 840);
  background(0);
	
	noiseDetail(7, 0.7);
	//colorMode(HSB, 360, 100, 100, 255);
	
	//blendMode(LIGHTEST);
	
	stroke(0, 0, 100, 255);
 // lms[0] = new lm('X', [['X', 0.5, 'XFFFF-[F-X+]FX+', 0.5, 'FFFFF[f+F]------------F'], ['F', '+F--F+']], radians(45), 1);
	let amount = 8;
	for (let i = 0; i < amount; i += 1) {
		let r = radians(10 + 180* ((((1+i) / amount)*2)-1));
		let s = 2;
		let sx = random(1, width-1);
		let sy = random(1, height-1);
		if (i % 2 == 0)
			lms[i] = new lm('F+F+F+F', [['F', 'FF+[+F-F-F]-[-F+F+F]']], r, 1, sx, sy, 2);
	  //else if (i % 4 == 1)
		else
			lms[i] = new lm('F+F+F+F', [['F', 'FF+F+F+F+FF']], r, s, sx, sy, 3);
	  //else if (i % 4 == 2)
		//	lms[i] = new lm('XF', [['X', 'X+YF++YF-FX--FXFX-YF+'], ['Y', '-FX+YFYF++YF+FX--FX-Y']], radians(90), s, sx, sy, 5);
		//else
		//	lms[i] = new lm('X', [['X', '-YF+XFX+FY-'], ['Y', '+XF-YFY-FX+']], radians(90), s, sx, sy, 5);
	}
	//lms[1] = new lm('X', [['X', 'F-[[X]+X]+F[+FX]-X'], ['F', 'FF']], radians(90), 1);
}

function change(lm) {
	let max_cycles = 1;
	noStroke();
	if (lm.cycles % max_cycles == 0) {
		
		lm.ta += 0.001;//= random(0, PI*2);
		lm.fs = random(2, 6);
		
		//fill(0, 0, 0, 92);
		//rect(0, 0, width, height);
	}
	
	/*
	if (lm.cycles % 16 == 0) {
		fill(0, 0, 0, 48);
		rect(0, 0, width, height);
	}
	*/
	
	let nc = (lm.cycles % 8) / 8;
	stroke(0, 0, 100, random(0, 10));
	
	//if (random() > 0.25) {
		lm.iter = 1;
		lm.initialize();
	/*} else {
		lm.iter = 2;
		lm.initialize();
	}*/
}

function draw() {
	for (let k = 0; k < 240; k += 1) {
		for (let i = 0; i < lms.length; i += 1) {
			let lm = lms[i];
			
			let result = lm.compute(change);
			
			if (result) {
				//stroke(k / 3 + abs(sin(xmotion/24))*180, 30, 255, 255);
			var pa1 = 0.75, pa2 = 0.95, pa3 = 0.95;
			var pb1 = 1, pb2 = 0.5, pb3 = 0.5;
			var pc1 = 1, pc2 = 1, pc3 = 1;

			var pdr = 0.29;
			var pdg = 1;
			var pdb = 0.95;

				var pt = abs(sin(xmotion + i));

				var rf = pal(pt, pa1, pb1, pc1, pdr) * 255*1.15;
				var gf = pal(pt, pa2, pb2, pc2, pdg) * 255*1.15;
				var bf = pal(pt, pa3, pb3, pc3, pdb) * 255*1.15;

				stroke(rf, gf, bf, 255);
				
				strokeWeight(1/* + abs(sin(xmotion/16+i))*8*/);
				var context = drawingContext
        context.shadowOffsetX = random(-1, 1);
        context.shadowOffsetY = random(-1, 1);
        context.shadowBlur = 4;
        context.shadowColor = ""black"";
				line(lm.px, lm.py, lm.ax, lm.ay);
			}
		}
	}
	
	xmotion += 0.5;
	ymotion += 0.25;
}"
"1039563","L-systems mistake 3","mySketch","// some more improvements / polish over the dynamic L-systems idea (colors with shadow outline, refined parameters)
// endless automatic drawing patterns fun by tweaking the rules, initial angle, step, colors, compositing... !

// glitchy version due wrap-around mistake

// an excellent source of documented rules : http://paulbourke.net/fractals/lsys/

function pal(t, a, b, c, d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

function weightedRandom(prob) {
  let i, sum=0, r=Math.random();
  for (i in prob) {
    sum += prob[i];
    if (r <= sum) return i;
  }
}

function variance(data) {
		let s1 = 0;
		let s2 = 0;
		let n = data.length;

    for (let x = 0; x < data.length; x += 1) {
    		s1 += x;
		}

    let mean = s1 / n;

    for (let x = 0; x < data.length; x += 1) {
        s2 += (x - mean) * (x - mean);
		}

    return s2 / (n - 1);
}

class lm {
	constructor(axiom, rules, angle, step, sx, sy, iter) {
		this.ax = sx;
		this.ay = sy;
		this.px = this.ax;
		this.py = this.ay;
		this.ta = angle;
		this.ca = PI;
		this.fs = step;
		
		this.stack = [];
		
		this.axiom = axiom;
		this.rules = rules;
		this.itera = iter;
		
		this.rule = 0;
		
		this.cycles = 0;
		
		this.b = false;
		
		this.where = 1;
		
		this.initialize();
	}
	
	initialize() {
		let rule = this.axiom;
		for (let i = 0; i < this.itera; i++) {
			rule = this.lindenmayer(rule);
		}
		
		this.rule = rule;
	}
	
	lindenmayer(s) {
		let outputstring = '';

		for (let i = 0; i < s.length; i++) {
			let ismatch = 0;
			for (let j = 0; j < this.rules.length; j++) {
				if (s[i] == this.rules[j][0])  {
					let rule_index = 1;
					if (this.rules[j].length > 2) { // stochastic
						let probs = {};
						for (let k = 1; k < this.rules[j].length; k+=2) {
							probs[k+1] = this.rules[j][k];
						}
						rule_index = weightedRandom(probs);
					}
					outputstring += this.rules[j][rule_index];
					ismatch = 1;
					break;
				}
			}

			if (ismatch == 0) outputstring+= s[i];
		}
		
		return outputstring;
	}
	
	computeParameters(w) {
		
	}
	
	compute(cb_trigger) {
		let k = this.rule[this.where];
		if (k == 'F' || k == 'f') {
			var polx = this.fs * sin(this.ca);
			var poly = this.fs * cos(this.ca);
			let x1 = this.b ? this.px - polx : this.px + polx;
			let y1 = this.b ? this.py - poly : this.py + poly;

			if (x1 < 0 || y1 < 0 || x1 > width || y1 > height) {
				this.b = !this.b;
				this.ta = -this.ta;//random() * PI * 2;
				
				if (x1 < 0) { x1 = width; }
				if (y1 < 0) { y1 = height; }
				if (x1 > width) { x1 = 0; }
				if (y1 > height) { y1 = 0; }
			}

			this.ax = this.px;
			this.ay = this.py;
			this.px = x1;
			this.py = y1;
		} else if (k == '[') {
			this.stack.push(this.px);
			this.stack.push(this.py);
			this.stack.push(this.ca);
		} else if (k == ']') {
			this.ca = this.stack.pop();
			this.py = this.stack.pop();
			this.px = this.stack.pop();
		} else if (k == '+') {
			this.ca += this.ta;
		} else if (k == '-') {
			this.ca -= this.ta;
		}
		
		this.where++;
  	if (this.where > (this.rule.length-1)/8) {
			this.where = 0;
			this.cycles += 1;
			
			cb_trigger(this);
		}
		
		if (k == 'F') {
			return true;
		} else {
			return false;
		}
	}
}

var xmotion = 0;
var ymotion = 0;

let lms = [];

function setup() {
  createCanvas(840, 840);
  background(0);
	
	noiseDetail(7, 0.7);
	//colorMode(HSB, 360, 100, 100, 255);
	
	//blendMode(LIGHTEST);
	
	stroke(0, 0, 100, 255);
 // lms[0] = new lm('X', [['X', 0.5, 'XFFFF-[F-X+]FX+', 0.5, 'FFFFF[f+F]------------F'], ['F', '+F--F+']], radians(45), 1);
	let amount = 8;
	for (let i = 0; i < amount; i += 1) {
		let r = radians(10 + 180* ((((1+i) / amount)*2)-1));
		let s = 2;
		let sx = random(1, width-1);
		let sy = random(1, height-1);
		if (i % 2 == 0)
			//lms[i] = new lm('F+F+F+F', [['F', 'FF+[+F-F-F]-[-F+F+F]']], r, 2, sx, sy, 6);
			lms[i] = new lm('XF', [['X', 'X+YF++YF-FX--FXFX-YF+'], ['Y', '-FX+YFYF++YF+FX--FX-Y']], r, 2, sx, sy, 6);
	  else if (i % 2 == 1)
			//lms[i] = new lm('F+XF+F+XF', [['X', 'XF-F+F-XF+F+XF-F+F-X']], r, 2, sx, sy, 6);
	  //else if (i % 4 == 2)
			//lms[i] = new lm('XF', [['X', 'X+YF++YF-FX--FXFX-YF+'], ['Y', '-FX+YFYF++YF+FX--FX-Y']], r, 2, sx, sy, 6);
		//else
			lms[i] = new lm('FX', [['X', '[-FX]+FX']], r, s, sx, sy, 4);
	}
	//lms[1] = new lm('X', [['X', 'F-[[X]+X]+F[+FX]-X'], ['F', 'FF']], radians(90), 1);
}

function change(lm) {
	let max_cycles = 1;
	noStroke();
	if (lm.cycles % max_cycles == 0) {
		
		lm.ta += 0.01;
		lm.fs = random(1, 4);
		
		//fill(0, 0, 0, 64);
		//rect(0, 0, width, height);
	}
	
	// handle stuck case when it oscillate on corners (could be improved ?)
	if (lm.cycles % 128 == 0) {
		lm.px = random(0, width);
		lm.py = random(0, height);
		lm.ax = lm.px;
		lm.ay = lm.py;
	}
	
	/*
	if (lm.cycles % 512 == 0) {
		fill(0, 0, 0, 64);
		rect(0, 0, width, height);
	}
	*/
	
	//let nc = (lm.cycles % 8) / 8;
	//stroke(0, 0, 100, random(0, 10));
	/*
	if (random() > 0.5) {
		lm.iter = 5;
		lm.initialize();
	} else {
		lm.iter = 6;
		lm.initialize();
	}*/
}

function draw() {
	for (let k = 0; k < 128; k += 1) {
		for (let i = 0; i < lms.length; i += 1) {
			let lm = lms[i];
			
			let result = lm.compute(change);
			
			if (result) {
				//stroke(k / 3 + abs(sin(xmotion/24))*180, 30, 255, 255);
			var pa1 = 0.75, pa2 = 0.95, pa3 = 0.95;
			var pb1 = 1, pb2 = 0.75, pb3 = 0.25;
			var pc1 = 1, pc2 = 1, pc3 = 0;

			var pdr = abs(sin(xmotion/2+i));
			var pdg = abs(sin(xmotion/2+i));
			var pdb = abs(sin(xmotion/2+i));

				var pt = abs(sin(xmotion + i));

				var rf = pal(pt, pa1, pb1, pc1, pdr) * 255*1.15;
				var gf = pal(pt, pa2, pb2, pc2, pdg) * 255*1.15;
				var bf = pal(pt, pa3, pb3, pc3, pdb) * 255*1.15;

				if (random() > 0.25) {
					stroke(rf, gf, bf, random() > 0.25 ? 255 : 92);
				} else {
					stroke(255-rf, 255-gf, 255-bf, 192);
				}
				strokeWeight(1+32 * abs(sin(xmotion/2+i) * (i / lms.length))/* + abs(sin(xmotion/16+i))*8*/);
				var context = drawingContext
        context.shadowOffsetX = random(-1, 1);
        context.shadowOffsetY = random(-1, 1);
        context.shadowBlur = 1; // more can be fun also
        context.shadowColor = ""black"";
				

				line(lm.px, lm.py, lm.ax, lm.ay);
			}
		}
	}
	
	xmotion += 0.5;
	ymotion += 0.25;
}"
"1039528","L-systems mistake 2","mySketch","// some more improvements / polish over the dynamic L-systems idea (colors with shadow outline, refined parameters)
// endless automatic drawing patterns fun by tweaking the rules, initial angle, step, colors, compositing... !

// glitchy version due wrap-around mistake

// an excellent source of documented rules : http://paulbourke.net/fractals/lsys/

function pal(t, a, b, c, d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

function weightedRandom(prob) {
  let i, sum=0, r=Math.random();
  for (i in prob) {
    sum += prob[i];
    if (r <= sum) return i;
  }
}

function variance(data) {
		let s1 = 0;
		let s2 = 0;
		let n = data.length;

    for (let x = 0; x < data.length; x += 1) {
    		s1 += x;
		}

    let mean = s1 / n;

    for (let x = 0; x < data.length; x += 1) {
        s2 += (x - mean) * (x - mean);
		}

    return s2 / (n - 1);
}

class lm {
	constructor(axiom, rules, angle, step, sx, sy, iter) {
		this.ax = sx;
		this.ay = sy;
		this.px = this.ax;
		this.py = this.ay;
		this.ta = angle;
		this.ca = PI;
		this.fs = step;
		
		this.stack = [];
		
		this.axiom = axiom;
		this.rules = rules;
		this.itera = iter;
		
		this.rule = 0;
		
		this.cycles = 0;
		
		this.b = false;
		
		this.where = 1;
		
		this.initialize();
	}
	
	initialize() {
		let rule = this.axiom;
		for (let i = 0; i < this.itera; i++) {
			rule = this.lindenmayer(rule);
		}
		
		this.rule = rule;
	}
	
	lindenmayer(s) {
		let outputstring = '';

		for (let i = 0; i < s.length; i++) {
			let ismatch = 0;
			for (let j = 0; j < this.rules.length; j++) {
				if (s[i] == this.rules[j][0])  {
					let rule_index = 1;
					if (this.rules[j].length > 2) { // stochastic
						let probs = {};
						for (let k = 1; k < this.rules[j].length; k+=2) {
							probs[k+1] = this.rules[j][k];
						}
						rule_index = weightedRandom(probs);
					}
					outputstring += this.rules[j][rule_index];
					ismatch = 1;
					break;
				}
			}

			if (ismatch == 0) outputstring+= s[i];
		}
		
		return outputstring;
	}
	
	computeParameters(w) {
		
	}
	
	compute(cb_trigger) {
		let k = this.rule[this.where];
		if (k == 'F' || k == 'f') {
			var polx = this.fs * sin(this.ca);
			var poly = this.fs * cos(this.ca);
			let x1 = this.b ? this.px - polx : this.px + polx;
			let y1 = this.b ? this.py - poly : this.py + poly;

			if (x1 < 0 || y1 < 0 || x1 > width || y1 > height) {
				this.b = !this.b;
				this.ta = -this.ta;//random() * PI * 2;
				
				if (x1 < 0) { x1 = width; }
				if (y1 < 0) { y1 = height; }
				if (x1 > width) { x1 = 0; }
				if (y1 > height) { y1 = 0; }
			}

			this.ax = this.px;
			this.ay = this.py;
			this.px = x1;
			this.py = y1;
		} else if (k == '[') {
			this.stack.push(this.px);
			this.stack.push(this.py);
			this.stack.push(this.ca);
		} else if (k == ']') {
			this.ca = this.stack.pop();
			this.py = this.stack.pop();
			this.px = this.stack.pop();
		} else if (k == '+') {
			this.ca += this.ta;
		} else if (k == '-') {
			this.ca -= this.ta;
		}
		
		this.where++;
  	if (this.where > this.rule.length-1) {
			this.where = 0;
			this.cycles += 1;
			
			cb_trigger(this);
		}
		
		if (k == 'F') {
			return true;
		} else {
			return false;
		}
	}
}

var xmotion = 0;
var ymotion = 0;

let lms = [];

function setup() {
  createCanvas(840, 840);
  background(0);
	
	noiseDetail(7, 0.7);
	//colorMode(HSB, 360, 100, 100, 255);
	
	//blendMode(LIGHTEST);
	
	stroke(0, 0, 100, 255);
 // lms[0] = new lm('X', [['X', 0.5, 'XFFFF-[F-X+]FX+', 0.5, 'FFFFF[f+F]------------F'], ['F', '+F--F+']], radians(45), 1);
	let amount = 8;
	for (let i = 0; i < amount; i += 1) {
		let r = radians(10 + 180* ((((1+i) / amount)*2)-1));
		let s = 2;
		let sx = random(1, width-1);
		let sy = random(1, height-1);
		if (i % 4 == 0)
			lms[i] = new lm('F+F+F+F', [['F', 'FF+[+F-F-F]-[-F+F+F]']], r, 2, sx, sy, 2);
	  else if (i % 4 == 1)
			lms[i] = new lm('F+XF+F+XF', [['X', 'XF-F+F-XF+F+XF-F+F-X']], r, 2, sx, sy, 5);
	  else if (i % 4 == 2)
			lms[i] = new lm('XF', [['X', 'X+YF++YF-FX--FXFX-YF+'], ['Y', '-FX+YFYF++YF+FX--FX-Y']], r, 2, sx, sy, 5);
		else
			lms[i] = new lm('X', [['X', '-YF+XFX+FY-'], ['Y', '+XF-YFY-FX+']], r, s, sx, sy, 5);
	}
	//lms[1] = new lm('X', [['X', 'F-[[X]+X]+F[+FX]-X'], ['F', 'FF']], radians(90), 1);
}

function change(lm) {
	let max_cycles = 8;
	noStroke();
	if (lm.cycles % max_cycles == 0) {
		
		lm.ta = random(0, PI*2);
		lm.fs = abs(sin(xmotion/8))*16;//random(1, 4);
		
		//fill(0, 0, 0, 64);
		//rect(0, 0, width, height);
	}
	
	// handle stuck case when it oscillate on corners (could be improved ?)
	if (lm.cycles % 16 == 0) {
		lm.px = random(0, width);
		lm.py = random(0, height);
		lm.ax = lm.px;
		lm.ay = lm.py;
	}
	
	/*
	if (lm.cycles % 16 == 0) {
		fill(0, 0, 0, 64);
		rect(0, 0, width, height);
	}
	*/
	
	//let nc = (lm.cycles % 8) / 8;
	//stroke(0, 0, 100, random(0, 10));
	
	if (random() > 0.5) {
		lm.iter = 5;
		lm.initialize();
	} else {
		lm.iter = 6;
		lm.initialize();
	}
}

function draw() {
	for (let k = 0; k < 128; k += 1) {
		for (let i = 0; i < lms.length; i += 1) {
			let lm = lms[i];
			
			let result = lm.compute(change);
			
			if (result) {
				//stroke(k / 3 + abs(sin(xmotion/24))*180, 30, 255, 255);
			var pa1 = 0.75, pa2 = 0.95, pa3 = 0.95;
			var pb1 = 0.75, pb2 = 0.75, pb3 = 0.75;
			var pc1 = 1, pc2 = 1, pc3 = 1;

			var pdr = 0.29;
			var pdg = 1;
			var pdb = 0.95;

				var pt = abs(sin(xmotion + i));

				var rf = pal(pt, pa1, pb1, pc1, pdr) * 255*1.15;
				var gf = pal(pt, pa2, pb2, pc2, pdg) * 255*1.15;
				var bf = pal(pt, pa3, pb3, pc3, pdb) * 255*1.15;

					stroke(rf, gf, bf, 255);
				strokeWeight(1+32 * abs(sin(xmotion/2+i))/* + abs(sin(xmotion/16+i))*8*/);
				var context = drawingContext
        context.shadowOffsetX = random(-1, 1);
        context.shadowOffsetY = random(-1, 1);
        context.shadowBlur = 1; // more can be fun also
        context.shadowColor = ""black"";
				

				line(lm.px, lm.py, lm.ax, lm.ay);
			}
		}
	}
	
	xmotion += 0.5;
	ymotion += 0.25;
}"
"1039515","L-systems mistake","mySketch","// some more improvements / polish over the dynamic L-systems idea (colors with shadow outline, refined parameters)
// endless automatic drawing patterns fun by tweaking the rules, initial angle, step, colors, compositing... !

// glitchy version due wrap-around mistake

// an excellent source of documented rules : http://paulbourke.net/fractals/lsys/

function pal(t, a, b, c, d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

function weightedRandom(prob) {
  let i, sum=0, r=Math.random();
  for (i in prob) {
    sum += prob[i];
    if (r <= sum) return i;
  }
}

function variance(data) {
		let s1 = 0;
		let s2 = 0;
		let n = data.length;

    for (let x = 0; x < data.length; x += 1) {
    		s1 += x;
		}

    let mean = s1 / n;

    for (let x = 0; x < data.length; x += 1) {
        s2 += (x - mean) * (x - mean);
		}

    return s2 / (n - 1);
}

class lm {
	constructor(axiom, rules, angle, step, sx, sy, iter) {
		this.ax = sx;
		this.ay = sy;
		this.px = this.ax;
		this.py = this.ay;
		this.ta = angle;
		this.ca = PI;
		this.fs = step;
		
		this.stack = [];
		
		this.axiom = axiom;
		this.rules = rules;
		this.itera = iter;
		
		this.rule = 0;
		
		this.cycles = 0;
		
		this.b = false;
		
		this.where = 1;
		
		this.initialize();
	}
	
	initialize() {
		let rule = this.axiom;
		for (let i = 0; i < this.itera; i++) {
			rule = this.lindenmayer(rule);
		}
		
		this.rule = rule;
	}
	
	lindenmayer(s) {
		let outputstring = '';

		for (let i = 0; i < s.length; i++) {
			let ismatch = 0;
			for (let j = 0; j < this.rules.length; j++) {
				if (s[i] == this.rules[j][0])  {
					let rule_index = 1;
					if (this.rules[j].length > 2) { // stochastic
						let probs = {};
						for (let k = 1; k < this.rules[j].length; k+=2) {
							probs[k+1] = this.rules[j][k];
						}
						rule_index = weightedRandom(probs);
					}
					outputstring += this.rules[j][rule_index];
					ismatch = 1;
					break;
				}
			}

			if (ismatch == 0) outputstring+= s[i];
		}
		
		return outputstring;
	}
	
	computeParameters(w) {
		
	}
	
	compute(cb_trigger) {
		let k = this.rule[this.where];
		if (k == 'F' || k == 'f') {
			var polx = this.fs * sin(this.ca);
			var poly = this.fs * cos(this.ca);
			let x1 = this.b ? this.px - polx : this.px + polx;
			let y1 = this.b ? this.py - poly : this.py + poly;

			if (x1 < 0 || y1 < 0 || x1 > width || y1 > height) {
				this.b = !this.b;
				this.ta = -this.ta;//random() * PI * 2;
				
				if (x1 < 0) { x1 = width; }
				if (y1 < 0) { y1 = height; }
				if (x1 > width) { x1 = 0; }
				if (y1 > height) { y1 = 0; }
			}

			this.ax = this.px;
			this.ay = this.py;
			this.px = x1;
			this.py = y1;
		} else if (k == '[') {
			this.stack.push(this.px);
			this.stack.push(this.py);
			this.stack.push(this.ca);
		} else if (k == ']') {
			this.ca = this.stack.pop();
			this.py = this.stack.pop();
			this.px = this.stack.pop();
		} else if (k == '+') {
			this.ca += this.ta;
		} else if (k == '-') {
			this.ca -= this.ta;
		}
		
		this.where++;
  	if (this.where > this.rule.length-1) {
			this.where = 0;
			this.cycles += 1;
			
			cb_trigger(this);
		}
		
		if (k == 'F') {
			return true;
		} else {
			return false;
		}
	}
}

var xmotion = 0;
var ymotion = 0;

let lms = [];

function setup() {
  createCanvas(840, 840);
  background(0);
	
	noiseDetail(7, 0.7);
	//colorMode(HSB, 360, 100, 100, 255);
	
	//blendMode(LIGHTEST);
	
	stroke(0, 0, 100, 255);
 // lms[0] = new lm('X', [['X', 0.5, 'XFFFF-[F-X+]FX+', 0.5, 'FFFFF[f+F]------------F'], ['F', '+F--F+']], radians(45), 1);
	let amount = 12;
	for (let i = 0; i < amount; i += 1) {
		let r = radians(10 + 180* ((((1+i) / amount)*2)-1));
		let s = 2;
		let sx = random(1, width-1);
		let sy = random(1, height-1);
		//if (i % 2 == 0)
			//lms[i] = new lm('F+F+F+F', [['F', 'FF+[+F-F-F]-[-F+F+F]']], radians(90), 8, sx, sy, 2);
	  //else if (i % 4 == 1)
		//else
			lms[i] = new lm('F+F+F', [['F', 'F-F+F']], r, 8, sx, sy, 2);
	  //else if (i % 4 == 2)
		//	lms[i] = new lm('XF', [['X', 'X+YF++YF-FX--FXFX-YF+'], ['Y', '-FX+YFYF++YF+FX--FX-Y']], radians(90), s, sx, sy, 5);
		//else
		//	lms[i] = new lm('X', [['X', '-YF+XFX+FY-'], ['Y', '+XF-YFY-FX+']], radians(90), s, sx, sy, 5);
	}
	//lms[1] = new lm('X', [['X', 'F-[[X]+X]+F[+FX]-X'], ['F', 'FF']], radians(90), 1);
}

function change(lm) {
	let max_cycles = 1;
	noStroke();
	if (lm.cycles % max_cycles == 0) {
		
		lm.ta += 0.01;//random(0, PI*2);
		//lm.fs = abs(sin(xmotion/8))*16;//random(1, 4);
		
		//fill(0, 0, 0, 64);
		//rect(0, 0, width, height);
	}
	
	// handle stuck case when it oscillate on corners (could be improved ?)
	if (lm.cycles % 2048 == 0) {
		lm.px = random(0, width);
		lm.py = random(0, height);
		lm.ax = lm.px;
		lm.ay = lm.py;
		
		console.log(""trigger"");
	}
	
	/*
	if (lm.cycles % 16 == 0) {
		fill(0, 0, 0, 48);
		rect(0, 0, width, height);
	}
	*/
	
	//let nc = (lm.cycles % 8) / 8;
	//stroke(0, 0, 100, random(0, 10));
	
	if (random() > 0.25) {
		lm.iter = 5;
		lm.initialize();
	} else {
		lm.iter = 6;
		lm.initialize();
	}
}

function draw() {
	for (let k = 0; k < 240; k += 1) {
		for (let i = 0; i < lms.length; i += 1) {
			let lm = lms[i];
			
			let result = lm.compute(change);
			
			if (result) {
				//stroke(k / 3 + abs(sin(xmotion/24))*180, 30, 255, 255);
			var pa1 = 0.75, pa2 = 0.95, pa3 = 0.95;
			var pb1 = 0.5, pb2 = 0.5, pb3 = 0.5;
			var pc1 = 1, pc2 = 1, pc3 = 1;

			var pdr = 0.29;
			var pdg = 1;
			var pdb = 0.95;

				var pt = abs(sin(xmotion + i));

				var rf = pal(pt, pa1, pb1, pc1, pdr) * 255*1.15;
				var gf = pal(pt, pa2, pb2, pc2, pdg) * 255*1.15;
				var bf = pal(pt, pa3, pb3, pc3, pdb) * 255*1.15;

					stroke(rf, gf, bf, 255);
				strokeWeight(2/* + abs(sin(xmotion/16+i))*8*/);
				var context = drawingContext
        context.shadowOffsetX = random(-1, 1);
        context.shadowOffsetY = random(-1, 1);
        context.shadowBlur = 4;
        context.shadowColor = ""black"";
				

				line(lm.px, lm.py, lm.ax, lm.ay);
			}
		}
	}
	
	xmotion += 0.5;
	ymotion += 0.25;
}"
"1038278","L-systems wrap","mySketch","// some more improvements / polish over the dynamic L-systems idea (colors with shadow outline, refined parameters)
// endless automatic drawing patterns fun by tweaking the rules, initial angle, step, colors, compositing... !
// with different starting position, wrap around borders instead of bounce

// an excellent source of documented rules : http://paulbourke.net/fractals/lsys/

function pal(t, a, b, c, d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

function weightedRandom(prob) {
  let i, sum=0, r=Math.random();
  for (i in prob) {
    sum += prob[i];
    if (r <= sum) return i;
  }
}

class lm {
	constructor(axiom, rules, angle, step, sx, sy, iter) {
		this.ax = sx;
		this.ay = sy;
		this.px = this.ax;
		this.py = this.ay;
		this.ta = angle;
		this.ca = PI;
		this.fs = step;
		
		this.stack = [];
		
		this.axiom = axiom;
		this.rules = rules;
		this.itera = iter;
		
		this.rule = 0;
		
		this.cycles = 0;
		
		this.b = false;
		
		this.where = 1;
		
		this.initialize();
	}
	
	initialize() {
		let rule = this.axiom;
		for (let i = 0; i < this.itera; i++) {
			rule = this.lindenmayer(rule);
		}
		
		this.rule = rule;
	}
	
	lindenmayer(s) {
		let outputstring = '';

		for (let i = 0; i < s.length; i++) {
			let ismatch = 0;
			for (let j = 0; j < this.rules.length; j++) {
				if (s[i] == this.rules[j][0])  {
					let rule_index = 1;
					if (this.rules[j].length > 2) { // stochastic
						let probs = {};
						for (let k = 1; k < this.rules[j].length; k+=2) {
							probs[k+1] = this.rules[j][k];
						}
						rule_index = weightedRandom(probs);
					}
					outputstring += this.rules[j][rule_index];
					ismatch = 1;
					break;
				}
			}

			if (ismatch == 0) outputstring+= s[i];
		}
		
		return outputstring;
	}
	
	computeParameters(w) {
		
	}
	
	compute(cb_trigger) {
		let k = this.rule[this.where];
		if (k == 'F' || k == 'f') {
			var polx = this.fs * sin(this.ca);
			var poly = this.fs * cos(this.ca);
			let x1 = this.b ? this.px - polx : this.px + polx;
			let y1 = this.b ? this.py - poly : this.py + poly;

			if (x1 < 0 || y1 < 0 || x1 > width || y1 > height) {
				this.b = !this.b;
				this.ta = -this.ta;//random() * PI * 2;
				
				if (x1 < 0) { x1 = width; this.px = width; if (random() > 0.99995) { y1 += 1; if (y1 >= height) { y1 -= height; this.py = y1; } } }
				if (y1 < 0) { y1 = height; this.py = height; if (random() > 0.99995) { x1 += 1; if (x1 >= width) { x1 %= width; this.px = x1; } } }
				if (x1 > width) { x1 = 0; this.px = 0; }
				if (y1 > height) { y1 = 0; this.py = 0; }
			}

			this.ax = this.px;
			this.ay = this.py;
			this.px = x1;
			this.py = y1;
		} else if (k == '[') {
			this.stack.push(this.px);
			this.stack.push(this.py);
			this.stack.push(this.ca);
		} else if (k == ']') {
			this.ca = this.stack.pop();
			this.py = this.stack.pop();
			this.px = this.stack.pop();
		} else if (k == '+') {
			this.ca += this.ta;
		} else if (k == '-') {
			this.ca -= this.ta;
		}
		
		this.where++;
  	if (this.where > this.rule.length-1) {
			this.where = 0;
			this.cycles += 1;
			
			cb_trigger(this);
		}
		
		if (k == 'F') {
			return true;
		} else {
			return false;
		}
	}
}

var xmotion = 0;
var ymotion = 0;

let lms = [];

function setup() {
  createCanvas(840, 840);
  background(0);
	
	noiseDetail(7, 0.7);
	//colorMode(HSB, 360, 100, 100, 255);
	
	//blendMode(LIGHTEST);
	
	stroke(0, 0, 100, 255);
 // lms[0] = new lm('X', [['X', 0.5, 'XFFFF-[F-X+]FX+', 0.5, 'FFFFF[f+F]------------F'], ['F', '+F--F+']], radians(45), 1);
	let amount = 8;
	for (let i = 0; i < amount; i += 1) {
		let r = radians(10 + 180* ((((1+i) / amount)*2)-1));
		let s = 2;
		let sx = random(1, width-1);
		let sy = random(1, height-1);
		if (i % 2 == 0)
			lms[i] = new lm('F+F+F+F', [['F', 'FF+[+F-F-F]-[-F+F+F]']], r, 1, sx, sy, 2);
	  //else if (i % 4 == 1)
		else
			lms[i] = new lm('F+F+F+F', [['F', 'FF+F+F+F+FF']], r, s, sx, sy, 3);
	  //else if (i % 4 == 2)
		//	lms[i] = new lm('XF', [['X', 'X+YF++YF-FX--FXFX-YF+'], ['Y', '-FX+YFYF++YF+FX--FX-Y']], radians(90), s, sx, sy, 5);
		//else
		//	lms[i] = new lm('X', [['X', '-YF+XFX+FY-'], ['Y', '+XF-YFY-FX+']], radians(90), s, sx, sy, 5);
	}
	//lms[1] = new lm('X', [['X', 'F-[[X]+X]+F[+FX]-X'], ['F', 'FF']], radians(90), 1);
}

function change(lm) {
	let max_cycles = 1;
	noStroke();
	if (lm.cycles % max_cycles == 0) {
		
		lm.ta = random(0, PI*2);
		lm.fs = random(1, 4);
		
		//fill(0, 0, 0, 92);
		//rect(0, 0, width, height);
	}
	
	/*
	if (lm.cycles % 16 == 0) {
		fill(0, 0, 0, 48);
		rect(0, 0, width, height);
	}
	*/
	
	let nc = (lm.cycles % 8) / 8;
	stroke(0, 0, 100, random(0, 10));
	
	//if (random() > 0.25) {
		lm.iter = 1;
		lm.initialize();
	/*} else {
		lm.iter = 2;
		lm.initialize();
	}*/
}

function draw() {
	for (let k = 0; k < 240; k += 1) {
		for (let i = 0; i < lms.length; i += 1) {
			let lm = lms[i];
			
			let result = lm.compute(change);
			
			if (result) {
				//stroke(k / 3 + abs(sin(xmotion/24))*180, 30, 255, 255);
			var pa1 = 0.75, pa2 = 0.95, pa3 = 0.95;
			var pb1 = 0.5, pb2 = 0.5, pb3 = 0.5;
			var pc1 = 1, pc2 = 1, pc3 = 1;

			var pdr = 0.29;
			var pdg = 1;
			var pdb = 0.95;

				var pt = abs(sin(xmotion + i));

				var rf = pal(pt, pa1, pb1, pc1, pdr) * 255*1.15;
				var gf = pal(pt, pa2, pb2, pc2, pdg) * 255*1.15;
				var bf = pal(pt, pa3, pb3, pc3, pdb) * 255*1.15;

				stroke(rf, gf, bf, 255);
				
				strokeWeight(1/* + abs(sin(xmotion/16+i))*8*/);
				var context = drawingContext
        context.shadowOffsetX = random(-1, 1);
        context.shadowOffsetY = random(-1, 1);
        context.shadowBlur = 4;
        context.shadowColor = ""black"";
				line(lm.px, lm.py, lm.ax, lm.ay);
			}
		}
	}
	
	xmotion += 0.5;
	ymotion += 0.25;
}"
"1037803","L-systems draw","mySketch","// some more improvements / polish over the dynamic L-systems idea (colors with shadow outline, refined parameters)
// endless automatic drawing patterns fun by tweaking the rules, initial angle, step, colors, compositing... !

function pal(t, a, b, c, d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

function weightedRandom(prob) {
  let i, sum=0, r=Math.random();
  for (i in prob) {
    sum += prob[i];
    if (r <= sum) return i;
  }
}

class lm {
	constructor(axiom, rules, angle, step) {
		this.ax = width / 2;
		this.ay = height / 2;
		this.px = this.ax;
		this.py = this.ay;
		this.ta = angle;
		this.ca = PI;
		this.fs = step;
		
		this.stack = [];
		
		this.axiom = axiom;
		this.rules = rules;
		this.itera = 5;
		
		this.rule = 0;
		
		this.cycles = 0;
		
		this.b = false;
		
		this.where = 1;
		
		this.initialize();
	}
	
	initialize() {
		let rule = this.axiom;
		for (let i = 0; i < this.itera; i++) {
			rule = this.lindenmayer(rule);
		}
		
		this.rule = rule;
	}
	
	lindenmayer(s) {
		let outputstring = '';

		for (let i = 0; i < s.length; i++) {
			let ismatch = 0;
			for (let j = 0; j < this.rules.length; j++) {
				if (s[i] == this.rules[j][0])  {
					let rule_index = 1;
					if (this.rules[j].length > 2) { // stochastic
						let probs = {};
						for (let k = 1; k < this.rules[j].length; k+=2) {
							probs[k+1] = this.rules[j][k];
						}
						rule_index = weightedRandom(probs);
					}
					outputstring += this.rules[j][rule_index];
					ismatch = 1;
					break;
				}
			}

			if (ismatch == 0) outputstring+= s[i];
		}
		
		return outputstring;
	}
	
	computeParameters(w) {
		
	}
	
	compute(cb_trigger) {
		let k = this.rule[this.where];
		if (k == 'F' || k == 'f') {
			var polx = this.fs * sin(this.ca);
			var poly = this.fs * cos(this.ca);
			let x1 = this.b ? this.px - polx : this.px + polx;
			let y1 = this.b ? this.py - poly : this.py + poly;

			if (x1 < 0 || y1 < 0 || x1 > width || y1 > height) {
				this.b = !this.b;
				this.ta = random() * PI * 2;
				
				if (x1 < 0) x1 = 0;
				if (y1 < 0) y1 = 0;
				if (x1 > width) x1 = width;
				if (y1 > height) y1 = height;
			}

			this.ax = this.px;
			this.ay = this.py;
			this.px = x1;
			this.py = y1;
		} else if (k == '[') {
			this.stack.push(this.px);
			this.stack.push(this.py);
			this.stack.push(this.ca);
		} else if (k == ']') {
			this.ca = this.stack.pop();
			this.py = this.stack.pop();
			this.px = this.stack.pop();
		} else if (k == '+') {
			this.ca += this.ta;
		} else if (k == '-') {
			this.ca -= this.ta;
		}
		
		this.where++;
  	if (this.where > this.rule.length-1) {
			this.where = 0;
			this.cycles += 1;
			
			cb_trigger(this);
		}
		
		if (k == 'F') {
			return true;
		} else {
			return false;
		}
	}
}

var xmotion = 0;
var ymotion = 0;

let lms = [];

function setup() {
  createCanvas(800, 800);
  background(0);
	
	noiseDetail(7, 0.7);
	//colorMode(HSB, 360, 100, 100, 255);
	
	//blendMode(LIGHTEST);
	
	stroke(0, 0, 100, 255);
 // lms[0] = new lm('X', [['X', 0.5, 'XFFFF-[F-X+]FX+', 0.5, 'FFFFF[f+F]------------F'], ['F', '+F--F+']], radians(45), 1);
	let amount = 8;
	for (let i = 0; i < amount; i += 1) {
		lms[i] = new lm('X', [['X', 'XXXXXXXFF+F+'], ['F', 'FF']], radians(10+180 * (((1+i) / amount)*2)-1), 1);
	}
	//lms[1] = new lm('X', [['X', 'F-[[X]+X]+F[+FX]-X'], ['F', 'FF']], radians(90), 1);
}

function change(lm) {
	let max_cycles = 1;
	noStroke();
	if (lm.cycles % max_cycles == 0) {
		lm.ta = random(0, PI);
		lm.fs = random(1, 2);
		
		//fill(0, 0, 0, 92);
		//rect(0, 0, width, height);
	}
	
	/*
	if (lm.cycles % 16 == 0) {
		fill(0, 0, 0, 48);
		rect(0, 0, width, height);
	}
	*/
	
	let nc = (lm.cycles % 8) / 8;
	stroke(0, 0, 100, random(0, 10));
	
	//if (random() > 0.25) {
		lm.iter = 1;
		lm.initialize();
	/*} else {
		lm.iter = 2;
		lm.initialize();
	}*/
}

function draw() {
	for (let k = 0; k < 240; k += 1) {
		for (let i = 0; i < lms.length; i += 1) {
			let lm = lms[i];
			
			let result = lm.compute(change);
			
			if (result) {
				//stroke(k / 3 + abs(sin(xmotion/24))*180, 30, 255, 255);
			var pa1 = 1, pa2 = 1, pa3 = 1;
			var pb1 = 0.75, pb2 = 0.5, pb3 = 0.75;
			var pc1 = 1, pc2 = 0.75, pc3 = 0.5;

			var pdr = 0.9;
			var pdg = 0.25;
			var pdb = 0.67;

				var pt = abs(sin(xmotion/k/1 + i));

				var rf = pal(pt, pa1, pb1, pc1, pdr) * 255/4;
				var gf = pal(pt, pa2, pb2, pc2, pdg) * 255/4;
				var bf = pal(pt, pa3, pb3, pc3, pdb) * 255/4;

				stroke(rf, gf, bf, 255);
				
				strokeWeight(1);
				var context = drawingContext
        context.shadowOffsetX = random(-16, 16)
        context.shadowOffsetY = random(-16, 16);
        context.shadowBlur = 1;
        context.shadowColor = ""rgba(255, 255, 255, ""+ random() + "")"";
				line(lm.px, lm.py, lm.ax, lm.ay);
			}
		}
	}
	
	xmotion += 0.5;
	ymotion += 0.25;
}"
"1037803","L-systems draw","mySketch","// some more improvements / polish over the dynamic L-systems idea (colors with shadow outline, refined parameters)
// endless automatic drawing patterns fun by tweaking the rules, initial angle, step, colors, compositing... !

function pal(t, a, b, c, d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

function weightedRandom(prob) {
  let i, sum=0, r=Math.random();
  for (i in prob) {
    sum += prob[i];
    if (r <= sum) return i;
  }
}

class lm {
	constructor(axiom, rules, angle, step) {
		this.ax = width / 2;
		this.ay = height / 2;
		this.px = this.ax;
		this.py = this.ay;
		this.ta = angle;
		this.ca = PI;
		this.fs = step;
		
		this.stack = [];
		
		this.axiom = axiom;
		this.rules = rules;
		this.itera = 5;
		
		this.rule = 0;
		
		this.cycles = 0;
		
		this.b = false;
		
		this.where = 1;
		
		this.initialize();
	}
	
	initialize() {
		let rule = this.axiom;
		for (let i = 0; i < this.itera; i++) {
			rule = this.lindenmayer(rule);
		}
		
		this.rule = rule;
	}
	
	lindenmayer(s) {
		let outputstring = '';

		for (let i = 0; i < s.length; i++) {
			let ismatch = 0;
			for (let j = 0; j < this.rules.length; j++) {
				if (s[i] == this.rules[j][0])  {
					let rule_index = 1;
					if (this.rules[j].length > 2) { // stochastic
						let probs = {};
						for (let k = 1; k < this.rules[j].length; k+=2) {
							probs[k+1] = this.rules[j][k];
						}
						rule_index = weightedRandom(probs);
					}
					outputstring += this.rules[j][rule_index];
					ismatch = 1;
					break;
				}
			}

			if (ismatch == 0) outputstring+= s[i];
		}
		
		return outputstring;
	}
	
	computeParameters(w) {
		
	}
	
	compute(cb_trigger) {
		let k = this.rule[this.where];
		if (k == 'F' || k == 'f') {
			var polx = this.fs * sin(this.ca);
			var poly = this.fs * cos(this.ca);
			let x1 = this.b ? this.px - polx : this.px + polx;
			let y1 = this.b ? this.py - poly : this.py + poly;

			if (x1 < 0 || y1 < 0 || x1 > width || y1 > height) {
				this.b = !this.b;
				this.ta = random() * PI * 2;
				
				if (x1 < 0) x1 = 0;
				if (y1 < 0) y1 = 0;
				if (x1 > width) x1 = width;
				if (y1 > height) y1 = height;
			}

			this.ax = this.px;
			this.ay = this.py;
			this.px = x1;
			this.py = y1;
		} else if (k == '[') {
			this.stack.push(this.px);
			this.stack.push(this.py);
			this.stack.push(this.ca);
		} else if (k == ']') {
			this.ca = this.stack.pop();
			this.py = this.stack.pop();
			this.px = this.stack.pop();
		} else if (k == '+') {
			this.ca += this.ta;
		} else if (k == '-') {
			this.ca -= this.ta;
		}
		
		this.where++;
  	if (this.where > this.rule.length-1) {
			this.where = 0;
			this.cycles += 1;
			
			cb_trigger(this);
		}
		
		if (k == 'F') {
			return true;
		} else {
			return false;
		}
	}
}

var xmotion = 0;
var ymotion = 0;

let lms = [];

function setup() {
  createCanvas(800, 800);
  background(0);
	
	noiseDetail(7, 0.7);
	//colorMode(HSB, 360, 100, 100, 255);
	
	//blendMode(LIGHTEST);
	
	stroke(0, 0, 100, 255);
 // lms[0] = new lm('X', [['X', 0.5, 'XFFFF-[F-X+]FX+', 0.5, 'FFFFF[f+F]------------F'], ['F', '+F--F+']], radians(45), 1);
	let amount = 8;
	for (let i = 0; i < amount; i += 1) {
		lms[i] = new lm('X', [['X', 'XXXFF+F+'], ['F', 'FF+']], radians(10+180 * (((1+i) / amount)*2)-1), 1);
	}
	//lms[1] = new lm('X', [['X', 'F-[[X]+X]+F[+FX]-X'], ['F', 'FF']], radians(90), 1);
}

function change(lm) {
	let max_cycles = 1;
	noStroke();
	if (lm.cycles % max_cycles == 0) {
		lm.ta = random(0, PI);
		lm.fs = random(1, 2);
		
		//fill(0, 0, 0, 92);
		//rect(0, 0, width, height);
	}
	
	/*
	if (lm.cycles % 16 == 0) {
		fill(0, 0, 0, 48);
		rect(0, 0, width, height);
	}
	*/
	
	let nc = (lm.cycles % 8) / 8;
	stroke(0, 0, 100, random(0, 10));
	
	//if (random() > 0.25) {
		lm.iter = 1;
		lm.initialize();
	/*} else {
		lm.iter = 2;
		lm.initialize();
	}*/
}

function draw() {
	for (let k = 0; k < 240; k += 1) {
		for (let i = 0; i < lms.length; i += 1) {
			let lm = lms[i];
			
			let result = lm.compute(change);
			
			if (result) {
				//stroke(k / 3 + abs(sin(xmotion/24))*180, 30, 255, 255);
			var pa1 = 1, pa2 = 1, pa3 = 1;
			var pb1 = 0.75, pb2 = 0.5, pb3 = 0.75;
			var pc1 = 1, pc2 = 0.75, pc3 = 0.5;

			var pdr = 0.9;
			var pdg = 0.25;
			var pdb = 0.67;

				var pt = abs(sin(xmotion/k/1 + i));

				var rf = pal(pt, pa1, pb1, pc1, pdr) * 255;
				var gf = pal(pt, pa2, pb2, pc2, pdg) * 255;
				var bf = pal(pt, pa3, pb3, pc3, pdb) * 255;

				stroke(rf, gf, bf, 255);
				
				strokeWeight(4);
				var context = drawingContext
        context.shadowOffsetX = random(-4, 4)
        context.shadowOffsetY = random(-4, 4);
        context.shadowBlur = 1;
        context.shadowColor = ""rgba(0, 0, 0, ""+ random() + "")"";
				line(lm.px, lm.py, lm.ax, lm.ay);
			}
		}
	}
	
	xmotion += 0.5;
	ymotion += 0.25;
}"
"1037803","L-systems draw","mySketch","// some more improvements / polish over the dynamic L-systems idea (colors with shadow outline, refined parameters)
// endless automatic drawing patterns fun by tweaking the rules, initial angle, step, colors, compositing... !

function pal(t, a, b, c, d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

function weightedRandom(prob) {
  let i, sum=0, r=Math.random();
  for (i in prob) {
    sum += prob[i];
    if (r <= sum) return i;
  }
}

class lm {
	constructor(axiom, rules, angle, step) {
		this.ax = width / 2;
		this.ay = height / 2;
		this.px = this.ax;
		this.py = this.ay;
		this.ta = angle;
		this.ca = PI;
		this.fs = step;
		
		this.stack = [];
		
		this.axiom = axiom;
		this.rules = rules;
		this.itera = 5;
		
		this.rule = 0;
		
		this.cycles = 0;
		
		this.b = false;
		
		this.where = 1;
		
		this.initialize();
	}
	
	initialize() {
		let rule = this.axiom;
		for (let i = 0; i < this.itera; i++) {
			rule = this.lindenmayer(rule);
		}
		
		this.rule = rule;
	}
	
	lindenmayer(s) {
		let outputstring = '';

		for (let i = 0; i < s.length; i++) {
			let ismatch = 0;
			for (let j = 0; j < this.rules.length; j++) {
				if (s[i] == this.rules[j][0])  {
					let rule_index = 1;
					if (this.rules[j].length > 2) { // stochastic
						let probs = {};
						for (let k = 1; k < this.rules[j].length; k+=2) {
							probs[k+1] = this.rules[j][k];
						}
						rule_index = weightedRandom(probs);
					}
					outputstring += this.rules[j][rule_index];
					ismatch = 1;
					break;
				}
			}

			if (ismatch == 0) outputstring+= s[i];
		}
		
		return outputstring;
	}
	
	computeParameters(w) {
		
	}
	
	compute(cb_trigger) {
		let k = this.rule[this.where];
		if (k == 'F' || k == 'f') {
			var polx = this.fs * sin(this.ca);
			var poly = this.fs * cos(this.ca);
			let x1 = this.b ? this.px - polx : this.px + polx;
			let y1 = this.b ? this.py - poly : this.py + poly;

			if (x1 < 0 || y1 < 0 || x1 > width || y1 > height) {
				this.b = !this.b;
				this.ta = random() * PI * 2;
				
				if (x1 < 0) x1 = 0;
				if (y1 < 0) y1 = 0;
				if (x1 > width) x1 = width;
				if (y1 > height) y1 = height;
			}

			this.ax = this.px;
			this.ay = this.py;
			this.px = x1;
			this.py = y1;
		} else if (k == '[') {
			this.stack.push(this.px);
			this.stack.push(this.py);
			this.stack.push(this.ca);
		} else if (k == ']') {
			this.ca = this.stack.pop();
			this.py = this.stack.pop();
			this.px = this.stack.pop();
		} else if (k == '+') {
			this.ca += this.ta;
		} else if (k == '-') {
			this.ca -= this.ta;
		}
		
		this.where++;
  	if (this.where > this.rule.length-1) {
			this.where = 0;
			this.cycles += 1;
			
			cb_trigger(this);
		}
		
		if (k == 'F') {
			return true;
		} else {
			return false;
		}
	}
}

var xmotion = 0;
var ymotion = 0;

let lms = [];

function setup() {
  createCanvas(800, 800);
  background(0);
	
	noiseDetail(7, 0.7);
	//colorMode(HSB, 360, 100, 100, 255);
	
	//blendMode(LIGHTEST);
	
	stroke(0, 0, 100, 255);
 // lms[0] = new lm('X', [['X', 0.5, 'XFFFF-[F-X+]FX+', 0.5, 'FFFFF[f+F]------------F'], ['F', '+F--F+']], radians(45), 1);
	let amount = 8;
	for (let i = 0; i < amount; i += 1) {
		lms[i] = new lm('X', [['X', 'XXXFF+F+'], ['F', 'FF+']], radians(10+180 * (((1+i) / amount)*2)-1), 1);
	}
	//lms[1] = new lm('X', [['X', 'F-[[X]+X]+F[+FX]-X'], ['F', 'FF']], radians(90), 1);
}

function change(lm) {
	let max_cycles = 1;
	noStroke();
	if (lm.cycles % max_cycles == 0) {
		lm.ta += random(0, PI)/80;
		lm.fs = random(1, 2);
		
		//fill(0, 0, 0, 92);
		//rect(0, 0, width, height);
	}
	
	/*
	if (lm.cycles % 16 == 0) {
		fill(0, 0, 0, 48);
		rect(0, 0, width, height);
	}
	*/
	
	let nc = (lm.cycles % 8) / 8;
	stroke(0, 0, 100, random(0, 10));
	
	//if (random() > 0.25) {
		lm.iter = 1;
		lm.initialize();
	/*} else {
		lm.iter = 2;
		lm.initialize();
	}*/
}

function draw() {
	for (let k = 0; k < 300; k += 1) {
		for (let i = 0; i < lms.length; i += 1) {
			let lm = lms[i];
			
			let result = lm.compute(change);
			
			if (result) {
				//stroke(k / 3 + abs(sin(xmotion/24))*180, 30, 255, 255);
			var pa1 = 1, pa2 = 1, pa3 = 1;
			var pb1 = 0.75, pb2 = 0.5, pb3 = 0.75;
			var pc1 = 1, pc2 = 0.75, pc3 = 0.5;

			var pdr = 0.9;
			var pdg = 0.25;
			var pdb = 0.67;

				var pt = abs(sin(xmotion/k/1 + i));

				var rf = pal(pt, pa1, pb1, pc1, pdr) * 255;
				var gf = pal(pt, pa2, pb2, pc2, pdg) * 255;
				var bf = pal(pt, pa3, pb3, pc3, pdb) * 255;

				stroke(rf, gf, bf, 255 * random() / 4);
				
				strokeWeight(4);
				var context = drawingContext
        context.shadowOffsetX = random(-4, 4)
        context.shadowOffsetY = random(-4, 4);
        context.shadowBlur = 16;
        context.shadowColor = ""rgba(0, 0, 0, ""+ random() / 2 + "")"";
				line(lm.px, lm.py, lm.ax, lm.ay);
			}
		}
	}
	
	xmotion += 0.5;
	ymotion += 0.25;
}"
"1037803","L-systems draw","mySketch","// some more improvements / polish over the dynamic L-systems idea (colors with shadow outline, refined parameters)
// endless automatic drawing patterns fun by tweaking the rules, initial angle, step, colors, compositing... !

function pal(t, a, b, c, d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

function weightedRandom(prob) {
  let i, sum=0, r=Math.random();
  for (i in prob) {
    sum += prob[i];
    if (r <= sum) return i;
  }
}

class lm {
	constructor(axiom, rules, angle, step) {
		this.ax = width / 2;
		this.ay = height / 2;
		this.px = this.ax;
		this.py = this.ay;
		this.ta = angle;
		this.ca = PI;
		this.fs = step;
		
		this.stack = [];
		
		this.axiom = axiom;
		this.rules = rules;
		this.itera = 5;
		
		this.rule = 0;
		
		this.cycles = 0;
		
		this.b = false;
		
		this.where = 1;
		
		this.initialize();
	}
	
	initialize() {
		let rule = this.axiom;
		for (let i = 0; i < this.itera; i++) {
			rule = this.lindenmayer(rule);
		}
		
		this.rule = rule;
	}
	
	lindenmayer(s) {
		let outputstring = '';

		for (let i = 0; i < s.length; i++) {
			let ismatch = 0;
			for (let j = 0; j < this.rules.length; j++) {
				if (s[i] == this.rules[j][0])  {
					let rule_index = 1;
					if (this.rules[j].length > 2) { // stochastic
						let probs = {};
						for (let k = 1; k < this.rules[j].length; k+=2) {
							probs[k+1] = this.rules[j][k];
						}
						rule_index = weightedRandom(probs);
					}
					outputstring += this.rules[j][rule_index];
					ismatch = 1;
					break;
				}
			}

			if (ismatch == 0) outputstring+= s[i];
		}
		
		return outputstring;
	}
	
	computeParameters(w) {
		
	}
	
	compute(cb_trigger) {
		let k = this.rule[this.where];
		if (k == 'F' || k == 'f') {
			var polx = this.fs * sin(this.ca);
			var poly = this.fs * cos(this.ca);
			let x1 = this.b ? this.px - polx : this.px + polx;
			let y1 = this.b ? this.py - poly : this.py + poly;

			if (x1 < 0 || y1 < 0 || x1 > width || y1 > height) {
				this.b = !this.b;
				this.ta = random() * PI * 2;
				
				if (x1 < 0) x1 = 0;
				if (y1 < 0) y1 = 0;
				if (x1 > width) x1 = width;
				if (y1 > height) y1 = height;
			}

			this.ax = this.px;
			this.ay = this.py;
			this.px = x1;
			this.py = y1;
		} else if (k == '[') {
			this.stack.push(this.px);
			this.stack.push(this.py);
			this.stack.push(this.ca);
		} else if (k == ']') {
			this.ca = this.stack.pop();
			this.py = this.stack.pop();
			this.px = this.stack.pop();
		} else if (k == '+') {
			this.ca += this.ta;
		} else if (k == '-') {
			this.ca -= this.ta;
		}
		
		this.where++;
  	if (this.where > this.rule.length-1) {
			this.where = 0;
			this.cycles += 1;
			
			cb_trigger(this);
		}
		
		if (k == 'F') {
			return true;
		} else {
			return false;
		}
	}
}

var xmotion = 0;
var ymotion = 0;

let lms = [];

function setup() {
  createCanvas(800, 800);
  background(0);
	
	noiseDetail(7, 0.7);
	//colorMode(HSB, 360, 100, 100, 255);
	
	//blendMode(LIGHTEST);
	
	stroke(0, 0, 100, 255);
 // lms[0] = new lm('X', [['X', 0.5, 'XFFFF-[F-X+]FX+', 0.5, 'FFFFF[f+F]------------F'], ['F', '+F--F+']], radians(45), 1);
	let amount = 8;
	for (let i = 0; i < amount; i += 1) {
		lms[i] = new lm('X', [['X', 'XXXFF+F+'], ['F', 'FF+']], radians(10+180 * (((1+i) / amount)*2)-1), 1);
	}
	//lms[1] = new lm('X', [['X', 'F-[[X]+X]+F[+FX]-X'], ['F', 'FF']], radians(90), 1);
}

function change(lm) {
	let max_cycles = 1;
	noStroke();
	if (lm.cycles % max_cycles == 0) {
		lm.ta += random(0, PI)/80;
		lm.fs = random(1, 2);
		
		//fill(0, 0, 0, 92);
		//rect(0, 0, width, height);
	}
	
	/*
	if (lm.cycles % 16 == 0) {
		fill(0, 0, 0, 48);
		rect(0, 0, width, height);
	}
	*/
	
	let nc = (lm.cycles % 8) / 8;
	stroke(0, 0, 100, random(0, 10));
	
	//if (random() > 0.25) {
		lm.iter = 1;
		lm.initialize();
	/*} else {
		lm.iter = 2;
		lm.initialize();
	}*/
}

function draw() {
	for (let k = 0; k < 300; k += 1) {
		for (let i = 0; i < lms.length; i += 1) {
			let lm = lms[i];
			
			let result = lm.compute(change);
			
			if (result) {
				//stroke(k / 3 + abs(sin(xmotion/24))*180, 30, 255, 255);
			var pa1 = 1, pa2 = 1, pa3 = 1;
			var pb1 = 0.75, pb2 = 0.5, pb3 = 0.75;
			var pc1 = 1, pc2 = 0.75, pc3 = 0.5;

			var pdr = 0.9;
			var pdg = 0.25;
			var pdb = 0.67;

				var pt = abs(sin(xmotion/k/1 + i));

				var rf = pal(pt, pa1, pb1, pc1, pdr) * 255;
				var gf = pal(pt, pa2, pb2, pc2, pdg) * 255;
				var bf = pal(pt, pa3, pb3, pc3, pdb) * 255;

				stroke(rf, gf, bf, 255 * random() / 4);
				
				strokeWeight(4);
				var context = drawingContext
        context.shadowOffsetX = random(-4, 4)
        context.shadowOffsetY = random(-4, 4);
        context.shadowBlur = 16;
        context.shadowColor = ""rgba(0, 0, 0, ""+ random() / 2 + "")"";
				line(lm.px, lm.py, lm.ax, lm.ay);
			}
		}
	}
	
	xmotion += 0.5;
	ymotion += 0.25;
}"
"1037792","L-systems bouquet","mySketch","// some more improvements / polish over the dynamic L-systems idea (colors with shadow outline, refined parameters)
// endless automatic drawing patterns fun by tweaking the rules, initial angle, step, colors, compositing... !

function pal(t, a, b, c, d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

function weightedRandom(prob) {
  let i, sum=0, r=Math.random();
  for (i in prob) {
    sum += prob[i];
    if (r <= sum) return i;
  }
}

class lm {
	constructor(axiom, rules, angle, step) {
		this.ax = width / 2;
		this.ay = height / 2;
		this.px = this.ax;
		this.py = this.ay;
		this.ta = angle;
		this.ca = PI;
		this.fs = step;
		
		this.stack = [];
		
		this.axiom = axiom;
		this.rules = rules;
		this.itera = 5;
		
		this.rule = 0;
		
		this.cycles = 0;
		
		this.b = false;
		
		this.where = 1;
		
		this.initialize();
	}
	
	initialize() {
		let rule = this.axiom;
		for (let i = 0; i < this.itera; i++) {
			rule = this.lindenmayer(rule);
		}
		
		this.rule = rule;
	}
	
	lindenmayer(s) {
		let outputstring = '';

		for (let i = 0; i < s.length; i++) {
			let ismatch = 0;
			for (let j = 0; j < this.rules.length; j++) {
				if (s[i] == this.rules[j][0])  {
					let rule_index = 1;
					if (this.rules[j].length > 2) { // stochastic
						let probs = {};
						for (let k = 1; k < this.rules[j].length; k+=2) {
							probs[k+1] = this.rules[j][k];
						}
						rule_index = weightedRandom(probs);
					}
					outputstring += this.rules[j][rule_index];
					ismatch = 1;
					break;
				}
			}

			if (ismatch == 0) outputstring+= s[i];
		}
		
		return outputstring;
	}
	
	computeParameters(w) {
		
	}
	
	compute(cb_trigger) {
		let k = this.rule[this.where];
		if (k == 'F' || k == 'f') {
			var polx = this.fs * sin(this.ca);
			var poly = this.fs * cos(this.ca);
			let x1 = this.b ? this.px - polx : this.px + polx;
			let y1 = this.b ? this.py - poly : this.py + poly;

			if (x1 < 0 || y1 < 0 || x1 > width || y1 > height) {
				this.b = !this.b;
				this.ta = random() * PI * 2;
				
				if (x1 < 0) x1 = 0;
				if (y1 < 0) y1 = 0;
				if (x1 > width) x1 = width;
				if (y1 > height) y1 = height;
			}

			this.ax = this.px;
			this.ay = this.py;
			this.px = x1;
			this.py = y1;
		} else if (k == '[') {
			this.stack.push(this.px);
			this.stack.push(this.py);
			this.stack.push(this.ca);
		} else if (k == ']') {
			this.ca = this.stack.pop();
			this.py = this.stack.pop();
			this.px = this.stack.pop();
		} else if (k == '+') {
			this.ca += this.ta;
		} else if (k == '-') {
			this.ca -= this.ta;
		}
		
		this.where++;
  	if (this.where > this.rule.length-1) {
			this.where = 0;
			this.cycles += 1;
			
			cb_trigger(this);
		}
		
		if (k == 'F') {
			return true;
		} else {
			return false;
		}
	}
}

var xmotion = 0;
var ymotion = 0;

let lms = [];

function setup() {
  createCanvas(800, 800);
  background(0);
	
	noiseDetail(7, 0.7);
	//colorMode(HSB, 360, 100, 100, 255);
	
	//blendMode(LIGHTEST);
	
	stroke(0, 0, 100, 255);
 // lms[0] = new lm('X', [['X', 0.5, 'XFFFF-[F-X+]FX+', 0.5, 'FFFFF[f+F]------------F'], ['F', '+F--F+']], radians(45), 1);
	let amount = 8;
	for (let i = 0; i < amount; i += 1) {
		lms[i] = new lm('X', [['X', 'F-[[X]-X]+F[-F-X]+)'], ['F', 'FF']], radians(8+180 * (((1+i) / amount)*2)-1), 2);
	}
	//lms[1] = new lm('X', [['X', 'F-[[X]+X]+F[+FX]-X'], ['F', 'FF']], radians(90), 1);
}

function change(lm) {
	let max_cycles = 2;
	noStroke();
	if (lm.cycles % max_cycles == 0) {
		lm.ta = random(0, PI / 2);
		lm.fs = random(1, 2);
	}
	
	/*
	if (lm.cycles % 16 == 0) {
		fill(0, 0, 0, 48);
		rect(0, 0, width, height);
	}
	*/
	
	let nc = (lm.cycles % 8) / 8;
	stroke(0, 0, 100, random(0, 10));
	
	//if (random() > 0.25) {
		lm.iter = 1;
		lm.initialize();
	/*} else {
		lm.iter = 2;
		lm.initialize();
	}*/
}

function draw() {
	noStroke();
	if (frameCount % 60 == 0) {
		fill(0, 0, 0, 64);
		rect(0, 0, width, height);
	}
	
	for (let k = 0; k < 240; k += 1) {
		for (let i = 0; i < lms.length; i += 1) {
			let lm = lms[i];
			
			let result = lm.compute(change);
			
			if (result) {
				//stroke(k / 3 + abs(sin(xmotion/24))*180, 30, 255, 255);
			var pa1 = 0.95, pa2 = 1, pa3 = 1;
			var pb1 = 0.65, pb2 = 0.65, pb3 =0.65;
			var pc1 = 1, pc2 = 1, pc3 = 0.7;

			var pdr = 0.69;
			var pdg = 0.5;
			var pdb = 0.9;

				var pt = abs(sin(xmotion/k/2 + i));

				var rf = pal(pt, pa1, pb1, pc1, pdr) * 255*1.75;
				var gf = pal(pt, pa2, pb2, pc2, pdg) * 255*1.75;
				var bf = pal(pt, pa3, pb3, pc3, pdb) * 255*1.75;

				stroke(rf, gf, bf, 255);
				
				strokeWeight(1 + abs(sin(xmotion/16+i))*1);
				var context = drawingContext
        context.shadowOffsetX = random(-1, 1);
        context.shadowOffsetY = random(-1, 1);
        context.shadowBlur = 4;
        context.shadowColor = ""black"";
				line(lm.px, lm.py, lm.ax, lm.ay);
			}
		}
	}
	
	xmotion += 0.5;
	ymotion += 0.25;
}"
"1037789","L-systems 3","mySketch","// some more improvements / polish over the dynamic L-systems idea (colors with shadow outline, refined parameters)
// endless automatic drawing patterns fun by tweaking the rules, initial angle, step, colors, compositing... !

function pal(t, a, b, c, d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

function weightedRandom(prob) {
  let i, sum=0, r=Math.random();
  for (i in prob) {
    sum += prob[i];
    if (r <= sum) return i;
  }
}

class lm {
	constructor(axiom, rules, angle, step) {
		this.ax = width / 2;
		this.ay = height / 2;
		this.px = this.ax;
		this.py = this.ay;
		this.ta = angle;
		this.ca = PI;
		this.fs = step;
		
		this.stack = [];
		
		this.axiom = axiom;
		this.rules = rules;
		this.itera = 5;
		
		this.rule = 0;
		
		this.cycles = 0;
		
		this.b = false;
		
		this.where = 1;
		
		this.initialize();
	}
	
	initialize() {
		let rule = this.axiom;
		for (let i = 0; i < this.itera; i++) {
			rule = this.lindenmayer(rule);
		}
		
		this.rule = rule;
	}
	
	lindenmayer(s) {
		let outputstring = '';

		for (let i = 0; i < s.length; i++) {
			let ismatch = 0;
			for (let j = 0; j < this.rules.length; j++) {
				if (s[i] == this.rules[j][0])  {
					let rule_index = 1;
					if (this.rules[j].length > 2) { // stochastic
						let probs = {};
						for (let k = 1; k < this.rules[j].length; k+=2) {
							probs[k+1] = this.rules[j][k];
						}
						rule_index = weightedRandom(probs);
					}
					outputstring += this.rules[j][rule_index];
					ismatch = 1;
					break;
				}
			}

			if (ismatch == 0) outputstring+= s[i];
		}
		
		return outputstring;
	}
	
	computeParameters(w) {
		
	}
	
	compute(cb_trigger) {
		let k = this.rule[this.where];
		if (k == 'F' || k == 'f') {
			var polx = this.fs * sin(this.ca);
			var poly = this.fs * cos(this.ca);
			let x1 = this.b ? this.px - polx : this.px + polx;
			let y1 = this.b ? this.py - poly : this.py + poly;

			if (x1 < 0 || y1 < 0 || x1 > width || y1 > height) {
				this.b = !this.b;
				this.ta = random() * PI * 2;
				
				if (x1 < 0) x1 = 0;
				if (y1 < 0) y1 = 0;
				if (x1 > width) x1 = width;
				if (y1 > height) y1 = height;
			}

			this.ax = this.px;
			this.ay = this.py;
			this.px = x1;
			this.py = y1;
		} else if (k == '[') {
			this.stack.push(this.px);
			this.stack.push(this.py);
			this.stack.push(this.ca);
		} else if (k == ']') {
			this.ca = this.stack.pop();
			this.py = this.stack.pop();
			this.px = this.stack.pop();
		} else if (k == '+') {
			this.ca += this.ta;
		} else if (k == '-') {
			this.ca -= this.ta;
		}
		
		this.where++;
  	if (this.where > this.rule.length-1) {
			this.where = 0;
			this.cycles += 1;
			
			cb_trigger(this);
		}
		
		if (k == 'F') {
			return true;
		} else {
			return false;
		}
	}
}

var xmotion = 0;
var ymotion = 0;

let lms = [];

function setup() {
  createCanvas(800, 800);
  background(0);
	
	noiseDetail(7, 0.7);
	//colorMode(HSB, 360, 100, 100, 255);
	
	//blendMode(LIGHTEST);
	
	stroke(0, 0, 100, 255);
 // lms[0] = new lm('X', [['X', 0.5, 'XFFFF-[F-X+]FX+', 0.5, 'FFFFF[f+F]------------F'], ['F', '+F--F+']], radians(45), 1);
	let amount = 8;
	for (let i = 0; i < 8; i += 1) {
		lms[i] = new lm('X', [['X', 'F+[[X]-X]-F[-F-X]+X)'], ['F', 'FF']], radians(8+64 * (((1+i) / amount)*2)-1), 2);
	}
	//lms[1] = new lm('X', [['X', 'F-[[X]+X]+F[+FX]-X'], ['F', 'FF']], radians(90), 1);
}

function change(lm) {
	let max_cycles = 6;
	noStroke();
	if (lm.cycles % max_cycles == 0) {
		lm.ta = random(0, PI / 2);
		lm.fs = random(1, 2);
		
		//fill(0, 0, 0, 92);
		//rect(0, 0, width, height);
	}
	
	/*
	if (lm.cycles % 16 == 0) {
		fill(0, 0, 0, 48);
		rect(0, 0, width, height);
	}
	*/
	
	let nc = (lm.cycles % 8) / 8;
	stroke(0, 0, 100, random(0, 10));
	
	//if (random() > 0.25) {
		lm.iter = 1;
		lm.initialize();
	/*} else {
		lm.iter = 2;
		lm.initialize();
	}*/
}

function draw() {
	for (let k = 0; k < 240; k += 1) {
		for (let i = 0; i < lms.length; i += 1) {
			let lm = lms[i];
			
			let result = lm.compute(change);
			
			if (result) {
				//stroke(k / 3 + abs(sin(xmotion/24))*180, 30, 255, 255);
			var pa1 = 0.95, pa2 = 1, pa3 = 1;
			var pb1 = 0.65, pb2 = 0.65, pb3 =0.65;
			var pc1 = 1, pc2 = 1, pc3 = 0.7;

			var pdr = 0.69;
			var pdg = 0.44;
			var pdb = 0.45;

				var pt = abs(sin(xmotion/k/8 + i));

				var rf = pal(pt, pa1, pb1, pc1, pdr) * 255*1.25;
				var gf = pal(pt, pa2, pb2, pc2, pdg) * 255*1.25;
				var bf = pal(pt, pa3, pb3, pc3, pdb) * 255*1.25;

				stroke(rf, gf, bf, 255);
				
				strokeWeight(1/* + abs(sin(xmotion/16+i))*8*/);
				var context = drawingContext
        context.shadowOffsetX = random(-4, 4);
        context.shadowOffsetY = random(-4, 4);
        context.shadowBlur = 8;
        context.shadowColor = ""black"";
				line(lm.px, lm.py, lm.ax, lm.ay);
			}
		}
	}
	
	xmotion += 0.5;
	ymotion += 0.25;
}"
"1037789","L-systems 3","mySketch","// some more improvements / polish over the dynamic L-systems idea (colors with shadow outline, refined parameters)
// endless automatic drawing patterns fun by tweaking the rules, initial angle, step, colors, compositing... !

function pal(t, a, b, c, d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

function weightedRandom(prob) {
  let i, sum=0, r=Math.random();
  for (i in prob) {
    sum += prob[i];
    if (r <= sum) return i;
  }
}

class lm {
	constructor(axiom, rules, angle, step) {
		this.ax = width / 2;
		this.ay = height / 2;
		this.px = this.ax;
		this.py = this.ay;
		this.ta = angle;
		this.ca = PI;
		this.fs = step;
		
		this.stack = [];
		
		this.axiom = axiom;
		this.rules = rules;
		this.itera = 5;
		
		this.rule = 0;
		
		this.cycles = 0;
		
		this.b = false;
		
		this.where = 1;
		
		this.initialize();
	}
	
	initialize() {
		let rule = this.axiom;
		for (let i = 0; i < this.itera; i++) {
			rule = this.lindenmayer(rule);
		}
		
		this.rule = rule;
	}
	
	lindenmayer(s) {
		let outputstring = '';

		for (let i = 0; i < s.length; i++) {
			let ismatch = 0;
			for (let j = 0; j < this.rules.length; j++) {
				if (s[i] == this.rules[j][0])  {
					let rule_index = 1;
					if (this.rules[j].length > 2) { // stochastic
						let probs = {};
						for (let k = 1; k < this.rules[j].length; k+=2) {
							probs[k+1] = this.rules[j][k];
						}
						rule_index = weightedRandom(probs);
					}
					outputstring += this.rules[j][rule_index];
					ismatch = 1;
					break;
				}
			}

			if (ismatch == 0) outputstring+= s[i];
		}
		
		return outputstring;
	}
	
	computeParameters(w) {
		
	}
	
	compute(cb_trigger) {
		let k = this.rule[this.where];
		if (k == 'F' || k == 'f') {
			var polx = this.fs * sin(this.ca);
			var poly = this.fs * cos(this.ca);
			let x1 = this.b ? this.px - polx : this.px + polx;
			let y1 = this.b ? this.py - poly : this.py + poly;

			if (x1 < 0 || y1 < 0 || x1 > width || y1 > height) {
				this.b = !this.b;
				this.ta = random() * PI * 2;
				
				if (x1 < 0) x1 = 0;
				if (y1 < 0) y1 = 0;
				if (x1 > width) x1 = width;
				if (y1 > height) y1 = height;
			}

			this.ax = this.px;
			this.ay = this.py;
			this.px = x1;
			this.py = y1;
		} else if (k == '[') {
			this.stack.push(this.px);
			this.stack.push(this.py);
			this.stack.push(this.ca);
		} else if (k == ']') {
			this.ca = this.stack.pop();
			this.py = this.stack.pop();
			this.px = this.stack.pop();
		} else if (k == '+') {
			this.ca += this.ta;
		} else if (k == '-') {
			this.ca -= this.ta;
		}
		
		this.where++;
  	if (this.where > this.rule.length-1) {
			this.where = 0;
			this.cycles += 1;
			
			cb_trigger(this);
		}
		
		if (k == 'F') {
			return true;
		} else {
			return false;
		}
	}
}

var xmotion = 0;
var ymotion = 0;

let lms = [];

function setup() {
  createCanvas(800, 800);
  background(0);
	
	noiseDetail(7, 0.7);
	//colorMode(HSB, 360, 100, 100, 255);
	
	//blendMode(LIGHTEST);
	
	stroke(0, 0, 100, 255);
 // lms[0] = new lm('X', [['X', 0.5, 'XFFFF-[F-X+]FX+', 0.5, 'FFFFF[f+F]------------F'], ['F', '+F--F+']], radians(45), 1);
	let amount = 8;
	for (let i = 0; i < 8; i += 1) {
		lms[i] = new lm('X', [['X', 'F+[[X]-X]-F[-F-X]+X)'], ['F', 'FF']], radians(8+64 * (((1+i) / amount)*2)-1), 2);
	}
	//lms[1] = new lm('X', [['X', 'F-[[X]+X]+F[+FX]-X'], ['F', 'FF']], radians(90), 1);
}

function change(lm) {
	let max_cycles = 6;
	noStroke();
	if (lm.cycles % max_cycles == 0) {
		lm.ta = random(0, PI / 2);
		lm.fs = random(1, 2);
		
		//fill(0, 0, 0, 92);
		//rect(0, 0, width, height);
	}
	
	/*
	if (lm.cycles % 16 == 0) {
		fill(0, 0, 0, 48);
		rect(0, 0, width, height);
	}
	*/
	
	let nc = (lm.cycles % 8) / 8;
	stroke(0, 0, 100, random(0, 10));
	
	//if (random() > 0.25) {
		lm.iter = 1;
		lm.initialize();
	/*} else {
		lm.iter = 2;
		lm.initialize();
	}*/
}

function draw() {
	for (let k = 0; k < 240; k += 1) {
		for (let i = 0; i < lms.length; i += 1) {
			let lm = lms[i];
			
			let result = lm.compute(change);
			
			if (result) {
				//stroke(k / 3 + abs(sin(xmotion/24))*180, 30, 255, 255);
			var pa1 = 0.95, pa2 = 1, pa3 = 1;
			var pb1 = 0.65, pb2 = 0.65, pb3 =0.65;
			var pc1 = 1, pc2 = 1, pc3 = 0.7;

			var pdr = 0.69;
			var pdg = 0.44;
			var pdb = 0.45;

				var pt = abs(sin(xmotion/k/2 + i));

				var rf = pal(pt, pa1, pb1, pc1, pdr) * 255*1.25;
				var gf = pal(pt, pa2, pb2, pc2, pdg) * 255*1.25;
				var bf = pal(pt, pa3, pb3, pc3, pdb) * 255*1.25;

				stroke(rf, gf, bf, 255);
				
				strokeWeight(1/* + abs(sin(xmotion/16+i))*8*/);
				var context = drawingContext
        context.shadowOffsetX = random(-4, 4);
        context.shadowOffsetY = random(-4, 4);
        context.shadowBlur = 4;
        context.shadowColor = ""black"";
				line(lm.px, lm.py, lm.ax, lm.ay);
			}
		}
	}
	
	xmotion += 0.5;
	ymotion += 0.25;
}"
"1037780","L-systems geometrics","mySketch","// some more improvements / polish over the dynamic L-systems idea (colors with shadow outline, refined parameters)
// endless automatic drawing patterns fun by tweaking the rules, initial angle, step, colors, compositing... !

function pal(t, a, b, c, d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

function weightedRandom(prob) {
  let i, sum=0, r=Math.random();
  for (i in prob) {
    sum += prob[i];
    if (r <= sum) return i;
  }
}

class lm {
	constructor(axiom, rules, angle, step) {
		this.ax = width / 2;
		this.ay = height / 2;
		this.px = this.ax;
		this.py = this.ay;
		this.ta = angle;
		this.ca = PI;
		this.fs = step;
		
		this.stack = [];
		
		this.axiom = axiom;
		this.rules = rules;
		this.itera = 5;
		
		this.rule = 0;
		
		this.cycles = 0;
		
		this.b = false;
		
		this.where = 1;
		
		this.initialize();
	}
	
	initialize() {
		let rule = this.axiom;
		for (let i = 0; i < this.itera; i++) {
			rule = this.lindenmayer(rule);
		}
		
		this.rule = rule;
	}
	
	lindenmayer(s) {
		let outputstring = '';

		for (let i = 0; i < s.length; i++) {
			let ismatch = 0;
			for (let j = 0; j < this.rules.length; j++) {
				if (s[i] == this.rules[j][0])  {
					let rule_index = 1;
					if (this.rules[j].length > 2) { // stochastic
						let probs = {};
						for (let k = 1; k < this.rules[j].length; k+=2) {
							probs[k+1] = this.rules[j][k];
						}
						rule_index = weightedRandom(probs);
					}
					outputstring += this.rules[j][rule_index];
					ismatch = 1;
					break;
				}
			}

			if (ismatch == 0) outputstring+= s[i];
		}
		
		return outputstring;
	}
	
	computeParameters(w) {
		
	}
	
	compute(cb_trigger) {
		let k = this.rule[this.where];
		if (k == 'F' || k == 'f') {
			var polx = this.fs * sin(this.ca);
			var poly = this.fs * cos(this.ca);
			let x1 = this.b ? this.px - polx : this.px + polx;
			let y1 = this.b ? this.py - poly : this.py + poly;

			if (x1 < 0 || y1 < 0 || x1 > width || y1 > height) {
				this.b = !this.b;
				this.ta = random() * PI * 2;
				
				if (x1 < 0) x1 = 0;
				if (y1 < 0) y1 = 0;
				if (x1 > width) x1 = width;
				if (y1 > height) y1 = height;
			}

			this.ax = this.px;
			this.ay = this.py;
			this.px = x1;
			this.py = y1;
		} else if (k == '[') {
			this.stack.push(this.px);
			this.stack.push(this.py);
			this.stack.push(this.ca);
		} else if (k == ']') {
			this.ca = this.stack.pop();
			this.py = this.stack.pop();
			this.px = this.stack.pop();
		} else if (k == '+') {
			this.ca += this.ta;
		} else if (k == '-') {
			this.ca -= this.ta;
		}
		
		this.where++;
  	if (this.where > this.rule.length-1) {
			this.where = 0;
			this.cycles += 1;
			
			cb_trigger(this);
		}
		
		if (k == 'F') {
			return true;
		} else {
			return false;
		}
	}
}

var xmotion = 0;
var ymotion = 0;

let lms = [];

function setup() {
  createCanvas(840, 840);
  background(0);
	
	noiseDetail(7, 0.7);
	//colorMode(HSB, 360, 100, 100, 255);
	
	//blendMode(LIGHTEST);
	
	stroke(0, 0, 100, 255);
 // lms[0] = new lm('X', [['X', 0.5, 'XFFFF-[F-X+]FX+', 0.5, 'FFFFF[f+F]------------F'], ['F', '+F--F+']], radians(45), 1);
	let amount = 8;
	for (let i = 0; i < 4; i += 1) {
		lms[i] = new lm('X', [['X', 'XXXXFF+F+'], ['F', 'FF']], radians(10+180 * (((1+i) / amount)*2)-1), 1);
	}
	//lms[1] = new lm('X', [['X', 'F-[[X]+X]+F[+FX]-X'], ['F', 'FF']], radians(90), 1);
}

function change(lm) {
	let max_cycles = 1;
	noStroke();
	if (lm.cycles % max_cycles == 0) {
		lm.ta = random(0, PI);
		lm.fs = random(1, 2);
		
		//fill(0, 0, 0, 92);
		//rect(0, 0, width, height);
	}
	
	/*
	if (lm.cycles % 16 == 0) {
		fill(0, 0, 0, 48);
		rect(0, 0, width, height);
	}
	*/
	
	let nc = (lm.cycles % 8) / 8;
	stroke(0, 0, 100, random(0, 10));
	
	//if (random() > 0.25) {
		lm.iter = 1;
		lm.initialize();
	/*} else {
		lm.iter = 2;
		lm.initialize();
	}*/
}

function draw() {
	for (let k = 0; k < 240; k += 1) {
		for (let i = 0; i < lms.length; i += 1) {
			let lm = lms[i];
			
			let result = lm.compute(change);
			
			if (result) {
				//stroke(k / 3 + abs(sin(xmotion/24))*180, 30, 255, 255);
			var pa1 = 1, pa2 = 1, pa3 = 1;
			var pb1 = 0.75, pb2 = 0.5, pb3 = 0.75;
			var pc1 = 1, pc2 = 0.75, pc3 = 0.5;

			var pdr = 0.9;
			var pdg = 0.25;
			var pdb = 0.67;

				var pt = abs(sin(xmotion/k/1 + i));

				var rf = pal(pt, pa1, pb1, pc1, pdr) * 255;
				var gf = pal(pt, pa2, pb2, pc2, pdg) * 255;
				var bf = pal(pt, pa3, pb3, pc3, pdb) * 255;

				stroke(rf, gf, bf, 255);
				
				strokeWeight(1);
				var context = drawingContext
        context.shadowOffsetX = random(-4, 4);
        context.shadowOffsetY = random(-4, 4);
        context.shadowBlur = 4;
        context.shadowColor = ""black"";
				line(lm.px, lm.py, lm.ax, lm.ay);
			}
		}
	}
	
	xmotion += 0.5;
	ymotion += 0.25;
}"
"1037774","L-systems garlands","mySketch","// some more improvements / polish over the dynamic L-systems idea (colors with shadow outline, refined parameters)
// endless automatic drawing patterns fun by tweaking the rules, initial angle, step, colors, compositing... !

function pal(t, a, b, c, d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

function weightedRandom(prob) {
  let i, sum=0, r=Math.random();
  for (i in prob) {
    sum += prob[i];
    if (r <= sum) return i;
  }
}

class lm {
	constructor(axiom, rules, angle, step) {
		this.ax = width / 2;
		this.ay = height / 2;
		this.px = this.ax;
		this.py = this.ay;
		this.ta = angle;
		this.ca = PI;
		this.fs = step;
		
		this.stack = [];
		
		this.axiom = axiom;
		this.rules = rules;
		this.itera = 5;
		
		this.rule = 0;
		
		this.cycles = 0;
		
		this.b = false;
		
		this.where = 1;
		
		this.initialize();
	}
	
	initialize() {
		let rule = this.axiom;
		for (let i = 0; i < this.itera; i++) {
			rule = this.lindenmayer(rule);
		}
		
		this.rule = rule;
	}
	
	lindenmayer(s) {
		let outputstring = '';

		for (let i = 0; i < s.length; i++) {
			let ismatch = 0;
			for (let j = 0; j < this.rules.length; j++) {
				if (s[i] == this.rules[j][0])  {
					let rule_index = 1;
					if (this.rules[j].length > 2) { // stochastic
						let probs = {};
						for (let k = 1; k < this.rules[j].length; k+=2) {
							probs[k+1] = this.rules[j][k];
						}
						rule_index = weightedRandom(probs);
					}
					outputstring += this.rules[j][rule_index];
					ismatch = 1;
					break;
				}
			}

			if (ismatch == 0) outputstring+= s[i];
		}
		
		return outputstring;
	}
	
	computeParameters(w) {
		
	}
	
	compute(cb_trigger) {
		let k = this.rule[this.where];
		if (k == 'F' || k == 'f') {
			var polx = this.fs * sin(this.ca);
			var poly = this.fs * cos(this.ca);
			let x1 = this.b ? this.px - polx : this.px + polx;
			let y1 = this.b ? this.py - poly : this.py + poly;

			if (x1 < 0 || y1 < 0 || x1 > width || y1 > height) {
				this.b = !this.b;
				this.ta = random() * PI * 2;
				
				if (x1 < 0) x1 = 0;
				if (y1 < 0) y1 = 0;
				if (x1 > width) x1 = width;
				if (y1 > height) y1 = height;
			}

			this.ax = this.px;
			this.ay = this.py;
			this.px = x1;
			this.py = y1;
		} else if (k == '[') {
			this.stack.push(this.px);
			this.stack.push(this.py);
			this.stack.push(this.ca);
		} else if (k == ']') {
			this.ca = this.stack.pop();
			this.py = this.stack.pop();
			this.px = this.stack.pop();
		} else if (k == '+') {
			this.ca += this.ta;
		} else if (k == '-') {
			this.ca -= this.ta;
		}
		
		this.where++;
  	if (this.where > this.rule.length-1) {
			this.where = 0;
			this.cycles += 1;
			
			cb_trigger(this);
		}
		
		if (k == 'F') {
			return true;
		} else {
			return false;
		}
	}
}

var xmotion = 0;
var ymotion = 0;

let lms = [];

function setup() {
  createCanvas(840, 840);
  background(0);
	
	noiseDetail(7, 0.7);
	//colorMode(HSB, 360, 100, 100, 255);
	
	//blendMode(LIGHTEST);
	
	stroke(0, 0, 100, 255);
 // lms[0] = new lm('X', [['X', 0.5, 'XFFFF-[F-X+]FX+', 0.5, 'FFFFF[f+F]------------F'], ['F', '+F--F+']], radians(45), 1);
	let amount = 8;
	for (let i = 0; i < 8; i += 1) {
		lms[i] = new lm('X', [['X', 'F-[[X+F--]X-]+FX-X[F]-XX-X+F'], ['F', 'FF']], radians(10+360 * (((1+i) / amount)*2)-1), 2);
	}
	//lms[1] = new lm('X', [['X', 'F-[[X]+X]+F[+FX]-X'], ['F', 'FF']], radians(90), 1);
}

function change(lm) {
	let max_cycles = 6;
	noStroke();
	if (lm.cycles % max_cycles == 0) {
		lm.ta = random(0, PI / 2);
		lm.fs = random(1, 2);
		
		//fill(0, 0, 0, 92);
		//rect(0, 0, width, height);
	}
	
	/*
	if (lm.cycles % 16 == 0) {
		fill(0, 0, 0, 48);
		rect(0, 0, width, height);
	}
	*/
	
	let nc = (lm.cycles % 8) / 8;
	stroke(0, 0, 100, random(0, 10));
	
	//if (random() > 0.25) {
		lm.iter = 1;
		lm.initialize();
	/*} else {
		lm.iter = 2;
		lm.initialize();
	}*/
}

function draw() {
	for (let k = 0; k < 240; k += 1) {
		for (let i = 0; i < lms.length; i += 1) {
			let lm = lms[i];
			
			let result = lm.compute(change);
			
			if (result) {
				//stroke(k / 3 + abs(sin(xmotion/24))*180, 30, 255, 255);
			var pa1 = 0.75, pa2 = 1, pa3 = 1;
			var pb1 = 1, pb2 = 0.75, pb3 =1;
			var pc1 = 1, pc2 = 1, pc3 = 0.7;

			var pdr = 0.9;
			var pdg = 0.74;
			var pdb = 0.95;

				var pt = abs(sin(xmotion/k/2 + i));

				var rf = pal(pt, pa1, pb1, pc1, pdr) * 255;
				var gf = pal(pt, pa2, pb2, pc2, pdg) * 255;
				var bf = pal(pt, pa3, pb3, pc3, pdb) * 255;

				stroke(rf, gf, bf, 255);
				
				strokeWeight(1/* + abs(sin(xmotion/16+i))*8*/);
				var context = drawingContext
        context.shadowOffsetX = random(-4, 4);
        context.shadowOffsetY = random(-4, 4);
        context.shadowBlur = 4;
        context.shadowColor = ""black"";
				line(lm.px, lm.py, lm.ax, lm.ay);
			}
		}
	}
	
	xmotion += 0.5;
	ymotion += 0.25;
}"
"1037436","3D Terrain tunnel 3","mySketch","/**
  * Same as last one with bit improved rendering / animation
  */

PImage colormap;
PImage heightmap;
PImage water;

float xmotion = 0;
float ymotion = 0;
float rmotion = 0;

int[] pex = new int[dots * 2];
int[] pey = new int[dots * 2];

int elems = 64; // can improve the rendering quality by increasing it and lowering the xrad_step / yrad_step variable
int dots = 128; // improve tunnel quality (to be used with rect_size)

int dots_step = 1;
int elems_step = 1;

void draw_landscape() {
  int rect_size = 1;
  
  // apply motion blur
  //fill(0, 0, 0, 0);
  //rect(0, 0, 800, 600);
	//background(0);
  
  noStroke();
  
  // initial circle size
  int bsize = 16;
  
  int xoff = 800 / 2;
  int yoff = 600 / 2;
  
  // the circles stepping
  int xrad_step = 10;
  int yrad_step = 10;
  
  // max motion deform.
  int xdeform = 180;
  int ydeform = 180;
  
  float crepeat = 0.2 + abs(sin(xmotion/2+cos(ymotion)))/2; // heightmap / colormap repeat
  int wrepeat = 0.05; // water texture repeat
  
  // we start by eliminating the blur effect at the end of the tunnel
  fill(0, 0, 0);
  ellipse(xoff + sin(360 * (PI / 180) + xmotion) * xdeform, yoff + cos(360 * (PI / 180) + ymotion) * xdeform, bsize * 1.5, bsize * 1.5);
  
  for (int e = 0; e < elems; e += elems_step) {
    float de = (float)e / elems;
		float de2 = (float)(e + elems_step) / elems;
    
    // fog computation
    float bd = 1.-max(min((0.5-abs(de - 0.5)) * 2, 1), 0.005);
    
    float ex = sin(de * 360 * (PI / 180)+xmotion);
    float ey = cos(de * 360 * (PI / 180)+ymotion);
     
    float xrad = e * xrad_step + bsize + sin(de * 360 * (PI / 180) + xmotion) * 4;
    float yrad = e * yrad_step + bsize + cos(de * 360 * (PI / 180) + xmotion) * 4;
    
    float final_ex = xoff + ex * xdeform * (1-de);
    
    float xpp = (de * 360 * (PI / 180)) / 2;
		float xpp2 = (de2 * 360 * (PI / 180)) / 2;
    
    // pre-computing textures lookup
    int yyd = (((int)(de * (colormap.height * crepeat)) % colormap.height)) * colormap.width;
    int wyd = (((int)(de * (colormap.height * wrepeat)) % colormap.height)) * colormap.width; 
		
		int j = 0;

    for (int d = 0; d < dots; d += dots_step) {
      float dd = (float)d / dots;
			float dd2 = (float)(d + dots_step) / dots;
      
      float xp = dd * 360 * (PI / 180);
      float yp = dd * 360 * (PI / 180);
			
      float xp2 = dd2 * 360 * (PI / 180);
      float yp2 = dd2 * 360 * (PI / 180);
			
      xp2 += xpp2 + rmotion;
      yp2 += xpp2 + rmotion;
      
      xp += xpp + rmotion;
      yp += xpp + rmotion;
      
      // compute height & apply it
			int hl = ((int)abs(heightmap.height / 2 + (de * heightmap.height + bsize) * cos(yp+xmotion) * crepeat+xmotion*100) % heightmap.height) * heightmap.width;
      float normalized_height = (heightmap.pixels[(((int)abs(heightmap.width / 2 + (de * heightmap.width + bsize) * sin(xp+xmotion) * crepeat+xmotion*100)) % heightmap.width) + hl] >> 16 & 0xFF) / 255.0;
			hl = ((int)abs(heightmap.height / 2 + (de2 * heightmap.height + bsize) * cos(yp2+xmotion) * crepeat+xmotion*100) % heightmap.height) * heightmap.width;
      float normalized_height2 = (heightmap.pixels[(((int)abs(heightmap.width / 2 + (de2 * heightmap.width + bsize) * sin(xp2+xmotion) * crepeat+xmotion*100)) % heightmap.width) + hl] >> 16 & 0xFF) / 255.0;
      
      float h = 1.0 - normalized_height * (1.-de);
			float h2 = 1.0 - normalized_height2 * (1.-de2);
      
      float final_x = final_ex + sin(xp) * xrad * h;
      float final_y = yoff + ey * ydeform + cos(yp) * yrad * h;
			
      float final_x2 = final_ex + sin(xp2) * xrad * h2;
      float final_y2 = yoff + ey * ydeform + cos(yp2) * yrad * h2;
			
      // do not compute outside boundary
      if (final_x >= 1280 || final_x < -400 || final_y >= 1024 | final_y < -400) {
				quad(pex[j], pey[j], final_x, final_y, final_x2, final_y2, pex[j+dots], pey[j+dots]);
				
				j += 1;
				
        continue;
      }
      
      // apply colormap / texture
      int xxd = ((int)(dd * (colormap.width * crepeat)) % colormap.width);

      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]));
      int g = (int)(green(colormap.pixels[cl]));
      int b = (int)(blue(colormap.pixels[cl]));
      
      // water map
      int wxd = ((int)(dd * (colormap.width * wrepeat)) % colormap.width);

      int wcl = (int)wxd + wyd;
      
      int wr = (int)(red(water.pixels[wcl]));
      int wg = (int)(green(water.pixels[wcl]));
      int wb = (int)(blue(water.pixels[wcl]));
      
      float finalr = r, finalg = g , finalb = b;
      float water_level = 0.2;
      if (normalized_height < water_level) {
        float wl = normalized_height * (1.0 / water_level);
        
        finalr = lerp(wr, r, wl);
        finalg = lerp(wg, g, wl);
        finalb = lerp(wb, b, wl);
      }
      
      float snow_level = 0.45;
      if (normalized_height > snow_level) {
        float wl = (normalized_height - snow_level) * (1.0 / snow_level);
        
        finalr = lerp(r, 255, wl);
        finalg = lerp(g, 255, wl);
        finalb = lerp(b, 255, wl);
      }
      
      finalr = lerp((int)finalr, 0, bd);
      finalg = lerp((int)finalg, 0, bd);
      finalb = lerp((int)finalb, 0, bd);
      
      fill(finalr, finalg, finalb, 224);
      
      //rect(final_x, final_y, rect_size, rect_size);
			//stroke(finalr, finalg, finalb);
			//line(pex[j], pey[j], final_x, final_y);
			//line(final_x, final_y, final_x2, final_y2);
			
			quad(pex[j], pey[j], final_x, final_y, final_x2, final_y2, pex[j+dots], pey[j+dots]);
			
			pex[j] = final_x;
			pey[j] = final_y;

			pex[j+dots] = final_x2;
			pey[j+dots] = final_y2;
			
			j += 1;
    }
  }
  
  xmotion += 0.05;
  ymotion += 0.025;
  rmotion += 0;//0.012;
}

void setup() {
  size(800, 600);

  frameRate(60); 
  
  colormap = loadImage(""colormap.jpg"");
  
  water = loadImage(""water.jpg"");
  
  heightmap = loadImage(""heightmap.jpg"");

  background(0);
}

void draw() {
  //ckground(0);
 
  draw_landscape();
}"
"1037436","3D Terrain tunnel 3","mySketch","/**
  * Same as last one with bit improved rendering / animation
  */

PImage colormap;
PImage heightmap;
PImage water;

float xmotion = 0;
float ymotion = 0;
float rmotion = 0;

int[] pex = new int[dots * 2];
int[] pey = new int[dots * 2];

int elems = 64; // can improve the rendering quality by increasing it and lowering the xrad_step / yrad_step variable
int dots = 128; // improve tunnel quality (to be used with rect_size)

int dots_step = 1;
int elems_step = 1;

void draw_landscape() {
  int rect_size = 1;
  
  // apply motion blur
  //fill(0, 0, 0, 0);
  //rect(0, 0, 800, 600);
	//background(0);
  
  noStroke();
  
  // initial circle size
  int bsize = 16;
  
  int xoff = 800 / 2;
  int yoff = 600 / 2;
  
  // the circles stepping
  int xrad_step = 10;
  int yrad_step = 10;
  
  // max motion deform.
  int xdeform = 180;
  int ydeform = 180;
  
  float crepeat = 0.2 + abs(sin(xmotion/2+cos(ymotion)))/2; // heightmap / colormap repeat
  int wrepeat = 0.05; // water texture repeat
  
  // we start by eliminating the blur effect at the end of the tunnel
  fill(0, 0, 0);
  ellipse(xoff + sin(360 * (PI / 180) + xmotion) * xdeform, yoff + cos(360 * (PI / 180) + ymotion) * xdeform, bsize * 1.5, bsize * 1.5);
  
  for (int e = 0; e < elems; e += elems_step) {
    float de = (float)e / elems;
		float de2 = (float)(e + elems_step) / elems;
    
    // fog computation
    float bd = 1.-max(min((0.5-abs(de - 0.5)) * 2, 1), 0.005);
    
    float ex = sin(de * 360 * (PI / 180)+xmotion);
    float ey = cos(de * 360 * (PI / 180)+ymotion);
     
    float xrad = e * xrad_step + bsize + sin(de * 360 * (PI / 180) + xmotion) * 4;
    float yrad = e * yrad_step + bsize + cos(de * 360 * (PI / 180) + xmotion) * 4;
    
    float final_ex = xoff + ex * xdeform * (1-de);
    
    float xpp = (de * 360 * (PI / 180)) / 2;
		float xpp2 = (de2 * 360 * (PI / 180)) / 2;
    
    // pre-computing textures lookup
    int yyd = (((int)(de * (colormap.height * crepeat)) % colormap.height)) * colormap.width;
    int wyd = (((int)(de * (colormap.height * wrepeat)) % colormap.height)) * colormap.width; 
		
		int j = 0;

    for (int d = 0; d < dots; d += dots_step) {
      float dd = (float)d / dots;
			float dd2 = (float)(d + dots_step) / dots;
      
      float xp = dd * 360 * (PI / 180);
      float yp = dd * 360 * (PI / 180);
			
      float xp2 = dd2 * 360 * (PI / 180);
      float yp2 = dd2 * 360 * (PI / 180);
			
      xp2 += xpp2 + rmotion;
      yp2 += xpp2 + rmotion;
      
      xp += xpp + rmotion;
      yp += xpp + rmotion;
      
      // compute height & apply it
			int hl = ((int)abs(heightmap.height / 2 + (de * heightmap.height + bsize) * cos(yp+xmotion) * crepeat+xmotion*100) % heightmap.height) * heightmap.width;
      float normalized_height = (heightmap.pixels[(((int)abs(heightmap.width / 2 + (de * heightmap.width + bsize) * sin(xp+xmotion) * crepeat+xmotion*100)) % heightmap.width) + hl] >> 16 & 0xFF) / 255.0;
			hl = ((int)abs(heightmap.height / 2 + (de2 * heightmap.height + bsize) * cos(yp2+xmotion) * crepeat+xmotion*100) % heightmap.height) * heightmap.width;
      float normalized_height2 = (heightmap.pixels[(((int)abs(heightmap.width / 2 + (de2 * heightmap.width + bsize) * sin(xp2+xmotion) * crepeat+xmotion*100)) % heightmap.width) + hl] >> 16 & 0xFF) / 255.0;
      
      float h = 1.0 - normalized_height * (1.-de);
			float h2 = 1.0 - normalized_height2 * (1.-de2);
      
      float final_x = final_ex + sin(xp) * xrad * h;
      float final_y = yoff + ey * ydeform + cos(yp) * yrad * h;
			
      float final_x2 = final_ex + sin(xp2) * xrad * h2;
      float final_y2 = yoff + ey * ydeform + cos(yp2) * yrad * h2;
			
      // do not compute outside boundary
      if (final_x >= 1280 || final_x < -400 || final_y >= 1024 | final_y < -400) {
				quad(pex[j], pey[j], final_x, final_y, final_x2, final_y2, pex[j+dots], pey[j+dots]);
				
				j += 1;
				
        continue;
      }
      
      // apply colormap / texture
      int xxd = ((int)(dd * (colormap.width * crepeat)) % colormap.width);

      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]));
      int g = (int)(green(colormap.pixels[cl]));
      int b = (int)(blue(colormap.pixels[cl]));
      
      // water map
      int wxd = ((int)(dd * (colormap.width * wrepeat)) % colormap.width);

      int wcl = (int)wxd + wyd;
      
      int wr = (int)(red(water.pixels[wcl]));
      int wg = (int)(green(water.pixels[wcl]));
      int wb = (int)(blue(water.pixels[wcl]));
      
      float finalr = r, finalg = g , finalb = b;
      float water_level = 0.2;
      if (normalized_height < water_level) {
        float wl = normalized_height * (1.0 / water_level);
        
        finalr = lerp(wr, r, wl);
        finalg = lerp(wg, g, wl);
        finalb = lerp(wb, b, wl);
      }
      
      float snow_level = 0.45;
      if (normalized_height > snow_level) {
        float wl = (normalized_height - snow_level) * (1.0 / snow_level);
        
        finalr = lerp(r, 255, wl);
        finalg = lerp(g, 255, wl);
        finalb = lerp(b, 255, wl);
      }
      
      finalr = lerp((int)finalr, 0, bd);
      finalg = lerp((int)finalg, 0, bd);
      finalb = lerp((int)finalb, 0, bd);
      
      fill(finalr, finalg, finalb, 224);
      
      //rect(final_x, final_y, rect_size, rect_size);
			//stroke(finalr, finalg, finalb);
			//line(pex[j], pey[j], final_x, final_y);
			//line(final_x, final_y, final_x2, final_y2);
			
			quad(pex[j], pey[j], final_x, final_y, final_x2, final_y2, pex[j+dots], pey[j+dots]);
			
			pex[j] = final_x;
			pey[j] = final_y;

			pex[j+dots] = final_x2;
			pey[j+dots] = final_y2;
			
			j += 1;
    }
  }
  
  xmotion += 0.05;
  ymotion += 0.025;
  rmotion += 0;//0.012;
}

void setup() {
  size(800, 600);

  frameRate(60); 
  
  colormap = loadImage(""G4XAva5.png"");
  
  water = loadImage(""snow-texture-winter-background-1186174.jpg"");
  
  heightmap = loadImage(""cgxJEfN.png"");

  background(0);
}

void draw() {
  //ckground(0);
 
  draw_landscape();
}"
"1036226","IFS Luth²","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 6;

function setup() {
  createCanvas(800, 800);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (1.5 + abs(sin(x / width * PI * 0.25 + cos(y / height * PI * 0.25 + pow(x/ width, 1) * PI * 0.25)))), y: (width / (1.0) + x - y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.25 + x) / 1 + j * (20), y: (height / 4 - y * 2 / j + (x / 4.0)) / 1.0 + j * (80) };
}

function f3(x, y, j) {
	return { x: (width * 0.5 - x * j) / (16 * (j / 14+xmotion/20) + x / (width / (10))), y: y / 8 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (3.25) - x + y / (1.95 * j * ((0.5 - y / width) * 10))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 10, y: (height / 2 - y * 1.15 / j + (x / 10.075)) / 1.75 + j * (50) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (4.0 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 5000) {
		for (let i = 0; i < 10000; i += 1) {
			for (let j = 5; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let ny1 = x[j] / width*2-1;
				let nx1 = y[j] / height*1.75;
				let inx1 =((0.05)+pow(abs(2.0-nx1)/2, 2));
				let nx11 = y[j] / width*2-1;//abs(0.5-y[j] / height)*2;
				let inx3 =((0.15)+pow((0.5-nx11)/2, 4));
				let nx2 = y2[j] / height;
				let inx2 = 0.45+pow(nx2, 0.5);
				
				let e = 0.75;

				if (iter > 20) {
					stroke((xmotion*64+iter*64)%360, 128, 255, 0.0125 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);
					//point(width - x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					//point(x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					
					//point(x2[j] * inx2+5, height / 1 - y2[j]/2.5);
					//point(width - x2[j] * inx2-5, height / 1 - y2[j]/2.5);
					//point(x[j] / 4.0 * inx3 - width / 4 * sin(nx1*PI*0.5), y[j]/2);
					//point(width - (width - x[j] / 4.0 * inx3 - width / 4 * sin(nx1*PI*0.5)), y[j]/2);
					//point(width / 1.95 - x[j] / 4.0 * inx3 - width / 4 * sin(nx1*PI*0.5), height - y[j]/2);
					//point(width - (width / 1.95 - x[j] / 4.0 * inx3 - width / 4 * sin(nx1*PI*0.5)), height - y[j]/2);
					point(width / 2 - x[j] / 6, height - y[j]/2);
					point(width / 2 + x[j] / 6, height - y[j]/2);
					point(x[j] / 2.0 * inx1 + width / 4.0 * abs(cos(ny1*PI*0.5 * pow(sin(nx1 * PI *0.15), 4))), (y[j]/2.5));
					point(width - (x[j] / 2.0 * inx1 + width / 4.0 * abs(cos(ny1*PI*0.5 * pow(sin(nx1 * PI *0.15), 4)))), (y[j]/2.5));
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	} else {
		iter = 0;
		xmotion += 0.01;
	}

	//xmotion += 1;
	ymotion += 0.25;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"1035454","IFS Luth","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 6;

function setup() {
  createCanvas(800, 800);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (1.5 + abs(sin(x / width * PI * 0.25 + cos(y / height * PI * 0.25 + pow(x/ width, 1) * PI * 0.25)))), y: (width / (1.0) + x - y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.25 + x) / 1 + j * (20), y: (height / 4 - y * 2 / j + (x / 4.0)) / 1.0 + j * (80) };
}

function f3(x, y, j) {
	return { x: (width * 1.5 - x * j) / (16 * (j / 12+xmotion/20) + x / (width / (10))), y: y / 4 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (3.25) - x + y / (1.95 * j * ((0.5 - y / width) * 10))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 10, y: (height / 2 - y * 1.15 / j + (x / 10.075)) / 1.75 + j * (50) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (4.0 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 5000) {
		for (let i = 0; i < 10000; i += 1) {
			for (let j = 5; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let ny1 = x[j] / width*2-1;
				let nx1 = y[j] / height*1.5;
				let inx1 =((0.05)+pow(abs(0.5-nx1)/2, 2));
				let nx11 = y[j] / width*2-1;//abs(0.5-y[j] / height)*2;
				let inx3 =((0.15)+pow((0.5-nx11)/2, 4));
				let nx2 = y2[j] / height;
				let inx2 = 0.45+pow(nx2, 0.5);
				
				let e = 0.75;

				if (iter > 20) {
					stroke((xmotion*64+iter*64)%360, 128, 255, 0.0125 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);
					//point(width - x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					//point(x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					
					//point(x2[j] * inx2+5, height / 1 - y2[j]/2.5);
					//point(width - x2[j] * inx2-5, height / 1 - y2[j]/2.5);
					//point(x[j] / 4.0 * inx3 - width / 4 * sin(nx1*PI*0.5), y[j]/2);
					//point(width - (width - x[j] / 4.0 * inx3 - width / 4 * sin(nx1*PI*0.5)), y[j]/2);
					//point(width / 1.95 - x[j] / 4.0 * inx3 - width / 4 * sin(nx1*PI*0.5), height - y[j]/2);
					//point(width - (width / 1.95 - x[j] / 4.0 * inx3 - width / 4 * sin(nx1*PI*0.5)), height - y[j]/2);
					point(width / 2 - x[j] / 6, height - y[j]/2);
					point(width / 2 + x[j] / 6, height - y[j]/2);
					point(x[j] / 2.0 * inx1 + width / 3.5 * abs(cos(ny1*PI*0.25 * pow(sin(nx1 * PI *0.25), 4))), (height / 8 + y[j]/2.5));
					point(width - (x[j] / 2.0 * inx1 + width / 3.5 * abs(cos(ny1*PI*0.25 * pow(sin(nx1 * PI *0.25), 4)))), (height / 8 + y[j]/2.5));
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	} else {
		iter = 0;
		xmotion += 0.01;
	}

	//xmotion += 1;
	ymotion += 0.25;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"1034680","Xolotl","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 6;

function setup() {
  createCanvas(800, 800);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (1.5 + abs(sin(x / width * PI * 1 + cos(y / height * PI * 1 + pow(x/ width, 1) * PI * 4)))), y: (width / (1.0) + x - y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.25 + x) / 1 + j * (50), y: (height / 4 - y * 2 / j + (x / 4.0)) / 1.0 + j * (80) };
}

function f3(x, y, j) {
	return { x: (width * 1.5 - x * j) / (16 * (j / 12+xmotion/20) + x / (width / (10))), y: y / 4 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (3.25) - x + y / (1.95 * j * ((0.5 - y / width) * 10))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 10, y: (height / 2 - y * 1.15 / j + (x / 10.075)) / 1.75 + j * (50) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (4.0 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 5000) {
		for (let i = 0; i < 10000; i += 1) {
			for (let j = 5; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let ny1 = x[j] / width*2-1;
				let nx1 = y[j] / height;
				let inx1 =((0.15)+pow((0.5-nx1)/2, 2));
				let nx11 = y[j] / width*2-1;//abs(0.5-y[j] / height)*2;
				let inx3 =((0.15)+pow((0.5-nx11)/2, 4));
				let nx2 = y2[j] / height;
				let inx2 = 0.45+pow(nx2, 0.5);
				
				let e = 0.75;

				if (iter > 20) {
					stroke((xmotion*64+iter*64)%360, 128, 255, 0.0125 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);
					//point(width - x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					//point(x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					
					//point(x2[j] * inx2+5, height / 1 - y2[j]/2.5);
					//point(width - x2[j] * inx2-5, height / 1 - y2[j]/2.5);
					point(width / 2 - x[j] / 4.0 * inx3 - width / 4 * sin(nx1*PI*0.5), y[j]/2);
					point(width - (width / 2 - x[j] / 4.0 * inx3 - width / 4 * sin(nx1*PI*0.5)), y[j]/2);
					//point(width / 1.95 - x[j] / 4.0 * inx3 - width / 4 * sin(nx1*PI*0.5), height - y[j]/2);
					//point(width - (width / 1.95 - x[j] / 4.0 * inx3 - width / 4 * sin(nx1*PI*0.5)), height - y[j]/2);
					//point(width / 2 - x[j] / 6, y[j]/2);
					//point(width / 2 + x[j] / 6, y[j]/2);
					point(x[j] / 2.0 * inx1 + width / 8.5 * abs(cos(ny1*PI*0.25 * pow(sin(nx1 * PI *1.25), 4))), height / 8 + y[j]/2.5);
					point(width - (x[j] / 2.0 * inx1 + width / 8.5 * abs(cos(ny1*PI*0.25 * pow(sin(nx1 * PI *1.25), 4)))), height / 8 + y[j]/2.5);
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	} else {
		iter = 0;
		xmotion += 0.01;
	}

	//xmotion += 1;
	ymotion += 0.25;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"1032939","IFS Gate²","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 6;

function setup() {
  createCanvas(800, 800);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (1.0 + abs(sin(x / width * PI * 1.5 + cos(((y / height)*2-1) * PI * 4.5 + pow(x/ width, 10) * PI * 4.5)))), y: (width / (1.0) + x - y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.25 + x) / 1 + j * (70), y: (height / 8 - y * 2 / j + (x / 4.0*(1-y/height))) / 1.0 + j * (70) };
}

function f3(x, y, j) {
	return { x: (width * 0.5 - x * j) / (16 * (j / 8) + x / (width / (10))), y: y / 3 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.0 + abs(sin(x / width * PI * 1.75 + cos(((y / height)*2-1) * PI * 3 + pow(x/ width, 10) * PI * 0.5)))), y: (width / (1.0) + x - y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.25 + x) / 1 + j * (70), y: (height / 8 - y * 2 / j + (x / 4.0*(1-y/height))) / 1.0 + j * (70) };
}

function f6(x, y, j) {
	return { x: (width * 0.5 - x * j) / (16 * (j / 8) + x / (width / (10))), y: y / 3 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 5000) {
		for (let i = 0; i < 10000; i += 1) {
			for (let j = 5; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let ny1 = x[j] / width;
				let nx1 = y[j] / height/2;
				let inx1 =((0.25)+pow((0.5-nx1), 8));
				let nx3 = y[j] / height;
				let inx3 =((0.25)+pow((1.25-nx3), 1));
				let nx2 = y2[j] / height;
				let inx2 = 0.45+pow(nx2, 0.5);
				
				let e = 0.75;

				if (iter > 20) {
					stroke((xmotion*64+iter*64)%360, 128, 255, 0.0125 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);
					//point(width - x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					//point(x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					
					//point(x2[j] * inx2+5, height / 1 - y2[j]/2.5);
					//point(width - x2[j] * inx2-5, height / 1 - y2[j]/2.5);
					//point(width / 2 - x[j] / 2.0 * inx1 - width / 4 * sin(nx1*PI*0.5), height - y[j]/2);
					//point(x[j] / 8, y[j]/4);
					point(y2[j] / 4, height - x2[j]/8);
					point(width - y2[j] / 4, height - x2[j]/8);
					
				//point(width /3.75+ y[j] / 8, x[j]/24);
			//	point(width-(width /3.75+ y[j] / 8), x[j]/24);
					point(x[j] / 8, height - y[j]/2);
					point(width - x[j] / 8, height - y[j]/2);
					//point(width - x[j] / 8, y[j]/4);					
					
					point(width / 8.35+ x[j] / 8 + width / 16 * abs(cos(ny1*PI*2 * pow(sin(nx1 * PI *0.5), 4))), (height / 124 + y[j]/2.5-height/3));
					point(width - (width / 8.35 + x[j] / 8 + width / 16 * abs(cos(ny1*PI*2 * pow(sin(nx1 * PI *0.5), 4)))), height / 124 + y[j]/2.5-height/3);
					
					point(width / 1.25 + x[j] / 2.75 * inx1 + width / 16 * abs(cos(ny1*PI*0.25 * pow(sin(nx1 * PI *0.75), 4))), (y[j]/2.5));
					point(width - (width / 1.25 + x[j] / 2.75 * inx1 + width / 16 * abs(cos(ny1*PI*0.25 * pow(sin(nx1 * PI *0.75), 4)))), y[j]/2.5);
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	} else {
		iter = 0;
		xmotion += 0.01;
	}

	//xmotion += 1;
	ymotion += 0.25;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"1032939","IFS Gate²","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 6;

function setup() {
  createCanvas(800, 800);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (1.0 + abs(sin(x / width * PI * 1.5 + cos(((y / height)*2-1) * PI * 4.5 + pow(x/ width, 10) * PI * 4.5)))), y: (width / (1.0) + x - y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.25 + x) / 1 + j * (70), y: (height / 8 - y * 2 / j + (x / 4.0*(1-y/height))) / 1.0 + j * (70) };
}

function f3(x, y, j) {
	return { x: (width * 0.5 - x * j) / (16 * (j / 8) + x / (width / (10))), y: y / 3 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.0 + abs(sin(x / width * PI * 1.75 + cos(((y / height)*2-1) * PI * 3 + pow(x/ width, 10) * PI * 0.5)))), y: (width / (1.0) + x - y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.25 + x) / 1 + j * (70), y: (height / 8 - y * 2 / j + (x / 4.0*(1-y/height))) / 1.0 + j * (70) };
}

function f6(x, y, j) {
	return { x: (width * 0.5 - x * j) / (16 * (j / 8) + x / (width / (10))), y: y / 3 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 5000) {
		for (let i = 0; i < 10000; i += 1) {
			for (let j = 5; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let ny1 = x[j] / width;
				let nx1 = y[j] / height/2;
				let inx1 =((0.25)+pow((0.5-nx1), 8));
				let nx3 = y[j] / height;
				let inx3 =((0.25)+pow((1.25-nx3), 1));
				let nx2 = y2[j] / height;
				let inx2 = 0.45+pow(nx2, 0.5);
				
				let e = 0.75;

				if (iter > 20) {
					stroke((xmotion*64+iter*64)%360, 128, 255, 0.0125 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);
					//point(width - x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					//point(x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					
					//point(x2[j] * inx2+5, height / 1 - y2[j]/2.5);
					//point(width - x2[j] * inx2-5, height / 1 - y2[j]/2.5);
					//point(width / 2 - x[j] / 2.0 * inx1 - width / 4 * sin(nx1*PI*0.5), height - y[j]/2);
					//point(x[j] / 8, y[j]/4);
					point(y2[j] / 4, height - x2[j]/8);
					point(width - y2[j] / 4, height - x2[j]/8);
					
				//point(width /3.75+ y[j] / 8, x[j]/24);
			//	point(width-(width /3.75+ y[j] / 8), x[j]/24);
					point(x[j] / 8, height - y[j]/2);
					point(width - x[j] / 8, height - y[j]/2);
					//point(width - x[j] / 8, y[j]/4);					
					
					point(width / 8.35+ x[j] / 8 + width / 16 * abs(cos(ny1*PI*2 * pow(sin(nx1 * PI *0.5), 4))), (height / 124 + y[j]/2.5-height/3));
					point(width - (width / 8.35 + x[j] / 8 + width / 16 * abs(cos(ny1*PI*2 * pow(sin(nx1 * PI *0.5), 4)))), height / 124 + y[j]/2.5-height/3);
					
					point(width / 1.25 + x[j] / 2.75 * inx1 + width / 16 * abs(cos(ny1*PI*0.25 * pow(sin(nx1 * PI *0.75), 4))), (y[j]/2.5));
					point(width - (width / 1.25 + x[j] / 2.75 * inx1 + width / 16 * abs(cos(ny1*PI*0.25 * pow(sin(nx1 * PI *0.75), 4)))), y[j]/2.5);
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	} else {
		iter = 0;
		xmotion += 0.01;
	}

	//xmotion += 1;
	ymotion += 0.25;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"1027464","IFS Gate","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 6;

function setup() {
  createCanvas(800, 800);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (1.0 + abs(sin(x / width * PI * 4 + cos(((y / height)*2-1) * PI * 4.5 + pow(x/ width, 10) * PI * 4.5)))), y: (width / (1.0) + x - y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.25 + x) / 1 + j * (70), y: (height / 8 - y * 2 / j + (x / 4.0*(1-y/height))) / 1.0 + j * (70) };
}

function f3(x, y, j) {
	return { x: (width * 0.5 - x * j) / (16 * (j / 8) + x / (width / (10))), y: y / 3 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (3.25) - x + y / (1.95 * j * ((0.5 - y / width) * 10))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 10, y: (height / 2 - y * 1.15 / j + (x / 10.075)) / 1.75 + j * (50) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (4.0 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 5000) {
		for (let i = 0; i < 10000; i += 1) {
			for (let j = 5; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let ny1 = x[j] / width;
				let nx1 = y[j] / height/2;
				let inx1 =((0.25)+pow((0.5-nx1), 8));
				let nx3 = y[j] / height;
				let inx3 =((0.25)+pow((1.25-nx3), 1));
				let nx2 = y2[j] / height;
				let inx2 = 0.45+pow(nx2, 0.5);
				
				let e = 0.75;

				if (iter > 20) {
					stroke((xmotion*64+iter*64)%360, 128, 255, 0.0125 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);
					//point(width - x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					//point(x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					
					//point(x2[j] * inx2+5, height / 1 - y2[j]/2.5);
					//point(width - x2[j] * inx2-5, height / 1 - y2[j]/2.5);
					//point(width / 2 - x[j] / 2.0 * inx1 - width / 4 * sin(nx1*PI*0.5), height - y[j]/2);
					//point(x[j] / 8, y[j]/4);
					point(y[j] / 4, height - x[j]/8);
					point(width - y[j] / 4, height - x[j]/8);
				point(width / 1.88 + y[j] / 4 - width / 8, x[j]/6);
				point(width / 2.12 - y[j] / 4 + width / 8, x[j]/6);
					point(x[j] / 8, height - y[j]/2);
					point(width - x[j] / 8, height - y[j]/2);
					//point(width - x[j] / 8, y[j]/4);					
					
					point(width / 8.35+ x[j] / 10 + width / 16 * abs(cos(ny1*PI*0.5 * pow(sin(nx1 * PI *0.75), 4))), (height / 124 + y[j]/2.5));
					point(width - (width / 8.35 + x[j] / 10 + width / 16 * abs(cos(ny1*PI*0.5 * pow(sin(nx1 * PI *0.75), 4)))), height / 124 + y[j]/2.5);
					
					point(width / 1.25 + x[j] / 0.75 * inx1 + width / 16 * abs(cos(ny1*PI*0.5 * pow(sin(nx1 * PI *0.75), 4))), (y[j]/2.5));
					point(width - (width / 1.25 + x[j] / 0.75 * inx1 + width / 16 * abs(cos(ny1*PI*0.5 * pow(sin(nx1 * PI *0.75), 4)))), y[j]/2.5);
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	} else {
		iter = 0;
		xmotion += 0.01;
	}

	//xmotion += 1;
	ymotion += 0.25;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"1027332","Turtle","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 6;

function setup() {
  createCanvas(800, 800);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (1.0 + abs(sin(x / width * PI * 2 + cos(y / height * PI * 0.25 + pow(x/ width, 1) * PI * 0.25)))), y: (width / (1) + x - y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.25 + x) / 1 + j * (80), y: (height / 8 - y * 1 / j + (x / 4.0)) / 1.0 + j * (70) };
}

function f3(x, y, j) {
	return { x: (width * 0.5 - x * j) / (16 * (j / 12) + x / (width / (10))), y: y / 3 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (3.25) - x + y / (1.95 * j * ((0.5 - y / width) * 10))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 10, y: (height / 2 - y * 1.15 / j + (x / 10.075)) / 1.75 + j * (50) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (4.0 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 5000) {
		for (let i = 0; i < 10000; i += 1) {
			for (let j = 5; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let ny1 = x[j] / width;
				let nx1 = y[j] / height/2;
				let inx1 =((0.25)+pow((0.5-nx1), 8));
				let nx2 = y2[j] / height;
				let inx2 = 0.45+pow(nx2, 0.5);
				
				let e = 0.75;

				if (iter > 20) {
					stroke((xmotion*64+iter*64)%360, 128, 255, 0.0125 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);
					//point(width - x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					//point(x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					
					//point(x2[j] * inx2+5, height / 1 - y2[j]/2.5);
					//point(width - x2[j] * inx2-5, height / 1 - y2[j]/2.5);
					//point(width / 2 - x[j] / 2.0 * inx1 - width / 4 * sin(nx1*PI*0.5), height - y[j]/2);
					//point(x[j] / 8, y[j]/4);
					point(x[j] / 16, height - y[j]/4);
					point(width - x[j] / 16, height - y[j]/4);
					//point(width - x[j] / 8, y[j]/4);
					point(width / 2 + x[j] / 1.25 * inx1 + width / 16 * abs(cos(ny1*PI*0.5 * pow(sin(nx1 * PI *0.75), 4))), height / 8 + y[j]/2.5);
					point(width - (width / 2 + x[j] / 1.25 * inx1 + width / 16 * abs(cos(ny1*PI*0.5 * pow(sin(nx1 * PI *0.75), 4)))), height / 8 + y[j]/2.5);
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	} else {
		iter = 0;
		xmotion += 0.01;
	}

	//xmotion += 1;
	ymotion += 0.25;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"1025475","AA CA","mySketch","float xmotion = 8.8;
float ymotion = 2.2;

float start;

void draw_func() {
	/*if ((frameCount % 400) == 0) {
		background(0);
		
		start = random(width / 2.5, width / 2.2);
	}*/
	
	noStroke();
	
	strokeWeight(1.5);
	
	loadPixels();
	for (int y = 0; y < height; y += 1) {
		int yy;
		if (y == 0) {
			yy = (height - 1) * width;
		} else {
			yy = (y % height) * width;
		}
		for (int x = 0; x < width; x += 1) {
			color p;
			if (x == 0) {
				p = pixels[yy + (width - 1)];
			} else {
				p = pixels[yy + (x % width)];
			}
			
			if (brightness(p) > 12 && brightness(p) < 16) {
				noFill();
				float n = (0.5 - noise((float)x/width+xmotion/1,(float)y/height+ymotion/1))*2;
				float n2 = (0.5-noise((float)y/height+ymotion/1,(float)x/width+xmotion/1))*2;
				
				stroke((abs(hue(p) + n*2) + 4) % 360, (saturation(p) + n * 2 + 10) % 128, 255, 32 + n * 8);
				
				float s = n * 1;
				
				line(x - s, y - s, x + s, y + s);
				line(x - s, y + s, x + s, y - s);
			  line(width - x - s, height - y - s, width - x + s, height - y + s);
				line(width - x - s, height - y + s, width - x + s, height - y - s);
				
				rect(x + n, y + n, 1, 1);
				rect(width - x  - n2, y - n2, 1, 1);
			}
		}
	}

	xmotion += 0.0005;
	ymotion += 0.0001;
}

void setup() {
  size(800, 800);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	noiseDetail(7,0.65);
	
	frameRate(30);
	
	start = random(width / 2.5, width / 2.2);
	
	noFill();
	noStroke();
  strokeWeight(1);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	stroke(210, 0, 255, 24);
	bezier(random(-width, width), random(-height, height), random(-width, width), random(-height, height), random(-width, width), random(-height, height), random(-width, width), random(-height, height));
	ellipse(width / 4, height / 2, 64, 64);
	//arc(width / 2, height / 1.5, 250, 250, 0, PI/2, CHORD);
	fill(200, 0, 255, 1);
	stroke(200, 0, 255, 1);
	strokeWeight(3);
	noFill();
	//arc(width / 2, height / 1.5, 200, 32, 0, PI, CHORD);

	//smooth();
}

void draw() {
  draw_func();
}"
"1021708","Chromo","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 6;

function setup() {
  createCanvas(800, 800);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (1.5 + abs(sin(x / width * PI * 1 + cos(y / height * PI * 1 + pow(x/ width, 1) * PI * 2)))), y: (width / (1.0) + x - y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.25 + x) / 1 + j * (20), y: (height / 4 - y * 3 / j + (x / 4.0)) / 1.0 + j * (80) };
}

function f3(x, y, j) {
	return { x: (width * 1.5 - x * j) / (16 * (j / 12+xmotion/20) + x / (width / (10))), y: y / 4 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (3.25) - x + y / (1.95 * j * ((0.5 - y / width) * 10))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 10, y: (height / 2 - y * 1.15 / j + (x / 10.075)) / 1.75 + j * (50) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (4.0 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 5000) {
		for (let i = 0; i < 10000; i += 1) {
			for (let j = 5; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let ny1 = x[j] / width*2-1;
				let nx1 = y[j] / height;
				let inx1 =((0.15)+pow((0.5-nx1), 2));
				let nx2 = y2[j] / height;
				let inx2 = 0.45+pow(nx2, 0.5);
				
				let e = 0.75;

				if (iter > 20) {
					stroke((xmotion*64+iter*64)%360, 128, 255, 0.0125 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);
					//point(width - x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					//point(x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					
					//point(x2[j] * inx2+5, height / 1 - y2[j]/2.5);
					//point(width - x2[j] * inx2-5, height / 1 - y2[j]/2.5);
					//point(width / 2 - x[j] / 2.0 * inx1 - width / 4 * sin(nx1*PI*0.5), height - y[j]/2);
					//point(x[j] / 2.0 * inx1, y[j]);
					//point(width - x[j] / 2.0 * inx1, height - y[j]);
					point(width / 2 + x[j] / 2.0 * inx1 + width / 12.5 * abs(cos(ny1*PI*0.5 * pow(sin(nx1 * PI *0.75), 4))), height / 8 + y[j]/2.5);
					point(width - (width / 2 + x[j] / 2.0 * inx1 + width / 12.5 * abs(cos(ny1*PI*0.5 * pow(sin(nx1 * PI *0.75), 4)))), height / 8 + y[j]/2.5);
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	} else {
		iter = 0;
		xmotion += 0.01;
	}

	//xmotion += 1;
	ymotion += 0.25;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"1021040","IFS42","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 6;

function setup() {
  createCanvas(800, 800);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (1.5 + abs(sin(x / width * PI * 2 + cos(y / height * PI * 32 + pow(x/ width, 1) * PI * 2)))), y: (width / (1.0) + x - y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.25 + x) / 1 + j * (80), y: (height / 4 - y * 2 / j + (x / 3.0)) / 1.0 + j * (80) };
}

function f3(x, y, j) {
	return { x: (width * 1.5 - x * j) / (16 * (j / 12+xmotion/20) + x / (width / (10))), y: y / 4 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (3.25) - x + y / (1.95 * j * ((0.5 - y / width) * 10))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 10, y: (height / 2 - y * 1.15 / j + (x / 10.075)) / 1.75 + j * (50) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (4.0 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 5000) {
		for (let i = 0; i < 10000; i += 1) {
			for (let j = 5; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let ny1 = x[j] / width*2-1;
				let nx1 = y[j] / height;
				let inx1 =1.0-((0.5)+pow((0.75-nx1), 2));
				let nx2 = y2[j] / height;
				let inx2 = 0.45+pow(nx2, 0.5);
				
				let e = 0.75;

				if (iter > 20) {
					stroke((xmotion*64+iter*64)%360, 128, 255, 0.0325 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);
					//point(width - x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					//point(x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					
					//point(x2[j] * inx2+5, height / 1 - y2[j]/2.5);
					//point(width - x2[j] * inx2-5, height / 1 - y2[j]/2.5);
					//point(width / 2 - x[j] / 2.0 * inx1 - width / 4 * sin(nx1*PI*0.5), height - y[j]/2);
					point(width / 2 + x[j] / 3.0 * inx1 + width / 12.5 * abs(cos(ny1*PI*0.5 * pow(sin(nx1 * PI *0.5), 4))), height / 8 + y[j]/2.5);
					point(width - (width / 2 + x[j] / 3.0 * inx1 + width / 12.5 * abs(cos(ny1*PI*0.5 * pow(sin(nx1 * PI *0.5), 4)))), height-(height / 8 + y[j]/2.5));
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	} else {
		iter = 0;
		xmotion += 0.01;
	}

	//xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"1021033","Ribbons","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 6;

function setup() {
  createCanvas(800, 800);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (1.5 + abs(sin(x / width * PI * 2 + cos(y / height * PI * 32 + pow(x/ width, 1) * PI * 2)))), y: (width / (1.0) + x - y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.25 + x) / 1 + j * (80), y: (height / 4 - y * 2 / j + (x / 3.0)) / 1.0 + j * (80) };
}

function f3(x, y, j) {
	return { x: (width * 1.5 - x * j) / (16 * (j / 12+xmotion/20) + x / (width / (10))), y: y / 4 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (3.25) - x + y / (1.95 * j * ((0.5 - y / width) * 10))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 10, y: (height / 2 - y * 1.15 / j + (x / 10.075)) / 1.75 + j * (50) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (4.0 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 5000) {
		for (let i = 0; i < 10000; i += 1) {
			for (let j = 5; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let ny1 = x[j] / width*2-1;
				let nx1 = y[j] / height;
				let inx1 =1.0-((0.5)+pow((0.75-nx1), 2));
				let nx2 = y2[j] / height;
				let inx2 = 0.45+pow(nx2, 0.5);
				
				let e = 0.75;

				if (iter > 20) {
					stroke((xmotion*64+iter*64)%360, 128, 255, 0.0325 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);
					//point(width - x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					//point(x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					
					//point(x2[j] * inx2+5, height / 1 - y2[j]/2.5);
					//point(width - x2[j] * inx2-5, height / 1 - y2[j]/2.5);
					//point(width / 2 - x[j] / 2.0 * inx1 - width / 4 * sin(nx1*PI*0.5), height - y[j]/2);
					point(width / 2 + x[j] / 3.0 * inx1 + width / 12.5 * abs(cos(ny1*PI*0.5 * pow(sin(nx1 * PI *0.5), 4))), height / 8 + y[j]/2.5);
					point(width - (width / 2 + x[j] / 3.0 * inx1 + width / 12.5 * abs(cos(ny1*PI*0.5 * pow(sin(nx1 * PI *0.5), 4)))), height / 8 + y[j]/2.5);
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	} else {
		iter = 0;
		xmotion += 0.01;
	}

	//xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"1021032","Bandages","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 6;

function setup() {
  createCanvas(800, 800);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (1.5 + abs(sin(x / width * PI * 2 + cos(y / height * PI * 32 + pow(x/ width, 1) * PI * 2)))), y: (width / (1.0) + x - y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.25 + x) / 1 + j * (20), y: (height / 4 - y * 2 / j + (x / 3.0)) / 1.0 + j * (80) };
}

function f3(x, y, j) {
	return { x: (width * 1.5 - x * j) / (16 * (j / 12+xmotion/20) + x / (width / (10))), y: y / 4 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (3.25) - x + y / (1.95 * j * ((0.5 - y / width) * 10))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 10, y: (height / 2 - y * 1.15 / j + (x / 10.075)) / 1.75 + j * (50) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (4.0 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 5000) {
		for (let i = 0; i < 10000; i += 1) {
			for (let j = 5; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let ny1 = x[j] / width*2-1;
				let nx1 = y[j] / height;
				let inx1 =1.0-((0.5)+pow((0.75-nx1), 2));
				let nx2 = y2[j] / height;
				let inx2 = 0.45+pow(nx2, 0.5);
				
				let e = 0.75;

				if (iter > 20) {
					stroke((xmotion*64+iter*64)%360, 128, 255, 0.0325 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);
					//point(width - x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					//point(x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					
					//point(x2[j] * inx2+5, height / 1 - y2[j]/2.5);
					//point(width - x2[j] * inx2-5, height / 1 - y2[j]/2.5);
					//point(width / 2 - x[j] / 2.0 * inx1 - width / 4 * sin(nx1*PI*0.5), height - y[j]/2);
					point(width / 2 + x[j] / 3.0 * inx1 + width / 12.5 * abs(cos(ny1*PI*0.5 * pow(sin(nx1 * PI *0.5), 4))), height / 8 + y[j]/2.5);
					point(width - (width / 2 + x[j] / 3.0 * inx1 + width / 12.5 * abs(cos(ny1*PI*0.5 * pow(sin(nx1 * PI *0.5), 4)))), height / 8 + y[j]/2.5);
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	} else {
		iter = 0;
		xmotion += 0.01;
	}

	//xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"1018604","Cks","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 8;

function setup() {
  createCanvas(800, 800);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (2.5), y: (width / (1.0) + x - y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.25 * x) / 1 + j * 60, y: (height / 1 - y * 1.25 / j + (x / 2.0)) / 1.0 + j * (1) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 - x * j) / (y/100 * (j / 8) + x / (width / (1.85))), y: y / 1.5 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (3.25) - x + y / (1.95 * j * ((0.5 - y / width) * 10))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 10, y: (height / 2 - y * 1.15 / j + (x / 10.075)) / 1.75 + j * (50) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (4.0 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 5; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let nx1 = y[j] / height;
				let inx1 = 0.25+pow(2-nx1, 1);
				let nx2 = y2[j] / height;
				let inx2 = 0.45+pow(nx2, 0.5);
				
				let e = 0.75;

				if (iter > 20) {
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.0225 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);
					//point(width - x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					//point(x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					
					//point(x2[j] * inx2+5, height / 1 - y2[j]/2.5);
					//point(width - x2[j] * inx2-5, height / 1 - y2[j]/2.5);
					//point(width / 2 - x[j] / 8 * inx1, height - y[j]/2);
					//point(width / 2 + x[j] / 8 * inx1, height - y[j]/2);
					
					//point(width - x[j] / 8 * inx1,  y[j]/2);
					//point(x[j] / 8 * inx1, y[j]/2);
					point(width - y[j] / 3.5 * inx1, height - x[j]/1);
					point(y[j] / 3.5 * inx1,height - x[j]/1);
					//point(width / 4 - x[j] / , y[j]/3);
					//point(width - width / 4 + x[j] / 8, y[j]/3);
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"1018603","Portal²²","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 8;

function setup() {
  createCanvas(800, 800);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (2.5), y: (width / (1.0) + x - y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.25 * x) / 1 + j * 60, y: (height / 2 - y * 1.25 / j + (x / 4.0)) / 1.0 + j * (100) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 - x * j) / (y/100 * (j / 8) + x / (width / (10.85))), y: y / 1.5 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (3.25) - x + y / (1.95 * j * ((0.5 - y / width) * 10))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 10, y: (height / 2 - y * 1.15 / j + (x / 10.075)) / 1.75 + j * (50) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (4.0 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 5; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let nx1 = y[j] / height;
				let inx1 = 0.25+pow(2-nx1, 1);
				let nx2 = y2[j] / height;
				let inx2 = 0.45+pow(nx2, 0.5);
				
				let e = 0.75;

				if (iter > 20) {
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.0225 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);
					//point(width - x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					//point(x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					
					//point(x2[j] * inx2+5, height / 1 - y2[j]/2.5);
					//point(width - x2[j] * inx2-5, height / 1 - y2[j]/2.5);
					//point(width / 2 - x[j] / 8 * inx1, height - y[j]/2);
					//point(width / 2 + x[j] / 8 * inx1, height - y[j]/2);
					
					//point(width - x[j] / 8 * inx1,  y[j]/2);
					//point(x[j] / 8 * inx1, y[j]/2);
					point(width - y[j] / 3.5 * inx1, height - x[j]/1);
					point(y[j] / 3.5 * inx1,height - x[j]/1);
					//point(width / 4 - x[j] / , y[j]/3);
					//point(width - width / 4 + x[j] / 8, y[j]/3);
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"1017582","My Sketch","mySketch","function setup() {
	createCanvas(800, 800);
	
	background(0);
	
	colorMode(HSL, 360, 1, 1, 1);
	
	noiseDetail(7, 0.6);
}

function draw() {
	background(0);
	
	noFill();
	strokeWeight(1);
	
	stroke(0, 0, 255, 1);
	
	let nbi = 64;
	let nbj = 4;
	let cs = 64;
	for (let i = 0; i < nbi; i += 1) {
		let ni = i / nbi;
		let si = 1 / nbi;
		
		let x1 = width / 2 + sin(ni * PI * 2) * 600;
		let y1 = height / 1 + cos(ni * PI * 2) * 600;
		
		let x2 = width / 2 + sin((ni + si) * PI * 2) * 600;
		let y2 = height / 1 + cos((ni + si) * PI * 2) * 600;
		
		let x3 = width / 2 + sin(ni * PI * 2) * 600;
		let y3 = height / 1 + cs + cos(ni * PI * 2) * 600;
		
		let x4 = width / 2 + sin((ni + si) * PI * 2) * 600;
		let y4 = height / 1 + cs + cos((ni + si) * PI * 2) * 600;
		
		stroke(0, 0, 255, 1);
		line(x1, y1, x2, y2);
		line(x3, y3, x4, y4);

		let ix1 = x1, iy1 = y1, ix2 = x2, iy2 = y2;
		let lx1, ly1;
		
		for (let j = 1; j < nbj; j += 1) {
			let nj = j / nbj;
			let njs = nj * cs;
			
			let n = (abs(0.5 - noise(ni * 32, nj * 32)) * 2) / 8;
			
			lx1 = ix1;
			ly1 = iy1;
			
			ix1 = width / 2 + sin(ni * PI * 2 + n) * 600;
			iy1 = height / 1 + njs + cos(ni * PI * 2 + n) * 600;

			ix2 = width / 2 + sin((ni + si) * PI * 2 + n) * 600;
			iy2 = height / 1 + njs + cos((ni + si) * PI * 2 + n) * 600;
			
			//stroke((nj * 360 + ni * 360) % 360, 0.5, 0.75, 1);
			//line(ix1, iy1, ix2, iy2);
			
			line(lx1, ly1, ix1, iy1);
		}
		
		//stroke(360, 0.5, 0.75, 1);
		line(ix1, iy1, x4, y4);
	}
}"
"1017276","Portal²","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 6;

function setup() {
  createCanvas(800, 800);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (2.25), y: (width / (1) + x - y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.25 + x) / 1 + j * (80), y: (height / 4 - y * 2 / j + (x / 3.0)) / 1.0 + j * (80) };
}

function f3(x, y, j) {
	return { x: (width * 0.5 - x * j) / (16 * (j / 12+xmotion/20) + x / (width / (10))), y: y / 3 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (3.25) - x + y / (1.95 * j * ((0.5 - y / width) * 10))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 10, y: (height / 2 - y * 1.15 / j + (x / 10.075)) / 1.75 + j * (50) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (4.0 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 5000) {
		for (let i = 0; i < 10000; i += 1) {
			for (let j = 5; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let ny1 = x[j] / width;
				let nx1 = y[j] / height;
				let inx1 = (0.25)+pow((1-nx1), 2);
				let nx2 = y2[j] / height;
				let inx2 = 0.45+pow(nx2, 0.5);
				
				let e = 0.75;

				if (iter > 20) {
					stroke((xmotion*64+iter*64)%360, 128, 255, 0.0325 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);
					//point(width - x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					//point(x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					
					//point(x2[j] * inx2+5, height / 1 - y2[j]/2.5);
					//point(width - x2[j] * inx2-5, height / 1 - y2[j]/2.5);
					//point(width / 2 - x[j] / 2.0 * inx1 - width / 4 * sin(nx1*PI*0.5), height - y[j]/2);
					point(width / 2 + x[j] / 2.0 * inx1 + width / 5.5 * abs(cos(ny1*PI*0.25)), y[j]/2.25);
					point(width - (width / 2 + x[j] / 2.0 * inx1 + width / 5.5 * abs(cos(ny1*PI*0.25))), y[j]/2.25);
					//point(width / 2 + x[j] / 4, y[j]/3);
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	} else {
		iter = 0;
		xmotion += 0.01;
	}

	//xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"1012785","Portal","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 6;

function setup() {
  createCanvas(800, 800);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (2.25), y: (width / (1.0) + x - y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.25 + x) / 1 + j * (80), y: (height / 4 - y * 2 / j + (x / 3.0)) / 1.0 + j * (80) };
}

function f3(x, y, j) {
	return { x: (width * 0.5 - x * j) / (16 * (j / 12) + x / (width / (10))), y: y / 3.25 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (3.25) - x + y / (1.95 * j * ((0.5 - y / width) * 10))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 10, y: (height / 2 - y * 1.15 / j + (x / 10.075)) / 1.75 + j * (50) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (4.0 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 5000) {
		for (let i = 0; i < 10000; i += 1) {
			for (let j = 5; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let ny1 = x[j] / width;
				let nx1 = y[j] / height;
				let inx1 = (0.35)+pow((1-nx1), 2);
				let nx2 = y2[j] / height;
				let inx2 = 0.45+pow(nx2, 0.5);
				
				let e = 0.75;

				if (iter > 20) {
					stroke((xmotion*64+iter*64)%360, 128, 255, 0.0125 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);
					//point(width - x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					//point(x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					
					//point(x2[j] * inx2+5, height / 1 - y2[j]/2.5);
					//point(width - x2[j] * inx2-5, height / 1 - y2[j]/2.5);
					//point(width / 2 - x[j] / 2.0 * inx1 - width / 4 * sin(nx1*PI*0.5), height - y[j]/2);
					point(width / 1.9 + x[j] / 2.0 * inx1 + width / 6.5 * abs(cos(ny1*PI*0.5)), y[j]/2);
					point(width - (width / 1.9 + x[j] / 2.0 * inx1 + width / 6.5 * abs(cos(ny1*PI*0.5))), y[j]/2);
					//point(width / 2 + x[j] / 8.25 * inx1, y[j]/2.0);
					//point(width / 2 - x[j] / 4, y[j]/3);
					//point(width / 2 + x[j] / 4, y[j]/3);
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	} else {
		iter = 0;
		xmotion += 0.01;
	}

	//xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"1012692","T0","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 6;

function setup() {
  createCanvas(800, 800);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (2.25), y: (width / (1) + x - y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.25 + x) / 1 + j * (80), y: (height / 4 - y * 2 / j + (x / 3.0)) / 1.0 + j * (80) };
}

function f3(x, y, j) {
	return { x: (width * 0.5 - x * j) / (16 * (j / 12+xmotion/20) + x / (width / (10))), y: y / 3 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (3.25) - x + y / (1.95 * j * ((0.5 - y / width) * 10))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 10, y: (height / 2 - y * 1.15 / j + (x / 10.075)) / 1.75 + j * (50) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (4.0 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 5000) {
		for (let i = 0; i < 10000; i += 1) {
			for (let j = 5; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let ny1 = x[j] / width;
				let nx1 = y[j] / height;
				let inx1 = (0.25)+pow((nx1), 1);
				let nx2 = y2[j] / height;
				let inx2 = 0.45+pow(nx2, 0.5);
				
				let e = 0.75;

				if (iter > 20) {
					stroke((xmotion*64+iter*64)%360, 128, 255, 0.0325 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);
					//point(width - x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					//point(x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					
					//point(x2[j] * inx2+5, height / 1 - y2[j]/2.5);
					//point(width - x2[j] * inx2-5, height / 1 - y2[j]/2.5);
					//point(width / 2 - x[j] / 2.0 * inx1 - width / 4 * sin(nx1*PI*0.5), height - y[j]/2);
					point(width / 2 + x[j] / 2.0 * inx1 + width / 5.5 * abs(cos(ny1*PI*0.5)), y[j]/2);
					point(width - (width / 2 + x[j] / 2.0 * inx1 + width / 5.5 * abs(cos(ny1*PI*0.5))), y[j]/2);
					//point(width / 2 + x[j] / 8.25 * inx1, y[j]/2.0);
					//point(width / 2 - x[j] / 4, y[j]/3);
					//point(width / 2 + x[j] / 4, y[j]/3);
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	} else {
		iter = 0;
		xmotion += 0.01;
	}

	//xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"1012672","Cross","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 6;

function setup() {
  createCanvas(800, 800);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (2.25), y: (width / (1) + x - y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.25 + x) / 1 + j * (80), y: (height / 4 - y * 2 / j + (x / 3.0)) / 1.0 + j * (80) };
}

function f3(x, y, j) {
	return { x: (width * 0.5 - x * j) / (16 * (j / 12+xmotion/20) + x / (width / (10))), y: y / 3 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (3.25) - x + y / (1.95 * j * ((0.5 - y / width) * 10))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 10, y: (height / 2 - y * 1.15 / j + (x / 10.075)) / 1.75 + j * (50) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (4.0 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 5000) {
		for (let i = 0; i < 10000; i += 1) {
			for (let j = 5; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let ny1 = x[j] / width;
				let nx1 = y[j] / height;
				let inx1 = (0.25)+pow((1-nx1), 2);
				let nx2 = y2[j] / height;
				let inx2 = 0.45+pow(nx2, 0.5);
				
				let e = 0.75;

				if (iter > 20) {
					stroke((xmotion*64+iter*64)%360, 128, 255, 0.0325 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);
					//point(width - x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					//point(x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					
					//point(x2[j] * inx2+5, height / 1 - y2[j]/2.5);
					//point(width - x2[j] * inx2-5, height / 1 - y2[j]/2.5);
					//point(width / 2 - x[j] / 2.0 * inx1 - width / 4 * sin(nx1*PI*0.5), height - y[j]/2);
					point(width / 2 + x[j] / 2.0 * inx1 + width / 5.5 * abs(cos(ny1*PI*1.5)), y[j]/2);
					point(width - (width / 2 + x[j] / 2.0 * inx1 + width / 5.5 * abs(cos(ny1*PI*1.5))), y[j]/2);
					//point(width / 2 + x[j] / 8.25 * inx1, y[j]/2.0);
					//point(width / 2 - x[j] / 4, y[j]/3);
					//point(width / 2 + x[j] / 4, y[j]/3);
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	} else {
		iter = 0;
		xmotion += 0.01;
	}

	//xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"1011686","AA Patterns","mySketch","float xmotion = 8.8;
float ymotion = 2.2;

float start;

void draw_func() {
	if ((frameCount % 400) == 0) {
		background(0);
		
		start = random(width / 2.5, width / 2.2);
	}
	
	noStroke();
	
	strokeWeight(2);
	
	loadPixels();
	for (int y = 0; y < height; y += 2) {
		int yy;
		if (y == 0) {
			yy = (height - 1) * width;
		} else {
			yy = (y % height) * width;
		}
		for (int x = 0; x < width; x += 2) {
			color p;
			if (x == 0) {
				p = pixels[yy + (width - 1)];
			} else {
				p = pixels[yy + (x % width)];
			}
			
			if (brightness(p) > 0 && brightness(p) < 12) {
				noFill();
				float n = (0.5-noise((float)x/width+xmotion*2,(float)y/height+ymotion*2))*2;
				float n2 = (0.5-noise((float)y/height+ymotion*2,(float)x/width+xmotion*2))*2;
				
				stroke(abs(hue(p) + n*2) + 4, 100, 255, 48 + n * 16);
				
				int s = 1 + abs(n) * 2;
				
				line(x - s, y - s, x + s, y + s);
				line(x - s, y + s, x + s, y - s);
			  line(width - x - s, height - y - s, width - x + s, height - y + s);
				line(width - x - s, height - y + s, width - x + s, height - y - s);
				
				rect(x + n, y + n, random(1, 2), random(1, 2));
				rect(width - x  - n2, y - n2, random(1, 2), random(1, 2));
			}
		}
	}
	
	noFill();
	noStroke();
  strokeWeight(8);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	stroke(200, 128, 255, 1);
	ellipse(width / 2, height / 2, 32, 32);
	arc(width / 2, height / 2, 500, 500, 0, PI/4, CHORD);
	fill(200, 128, 255, 1);
	stroke(200, 128, 255, 1);
	strokeWeight(3);
	noFill();
	//arc(width / 2, height / 1.5, 200, 32, 0, PI, CHORD);

	xmotion += 0.004;
	ymotion += 0.001;
}

void setup() {
  size(800, 800);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	noiseDetail(7,0.65);
	
	frameRate(30);
	
	start = random(width / 2.5, width / 2.2);
	
	//smooth();
}

void draw() {
  draw_func();
}"
"1011659","Opening²","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 6;

function setup() {
  createCanvas(800, 800);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (1.0), y: (width / (1.15) + x - y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 3 * x) / 1 + j * 20, y: (height / 6 - y * 1 / j + (x / 4.0)) / 1.0 + j * (80) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 - x * j) / (y/40 * (j / 8) + x / (width / (5.85))), y: y / 2.5 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (3.25) - x + y / (1.95 * j * ((0.5 - y / width) * 10))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 10, y: (height / 2 - y * 1.15 / j + (x / 10.075)) / 1.75 + j * (50) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (4.0 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 5; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let nx1 = y[j] / height * 2. - 1.;
				let inx1 = 0.25+pow(1-nx1, 1);
				let nx2 = y2[j] / height;
				let inx2 = 0.45+pow(nx2, 0.5);
				
				let e = 0.75;

				if (iter > 20) {
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.0225 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);
					//point(width - x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					//point(x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					
					//point(x2[j] * inx2+5, height / 1 - y2[j]/2.5);
					//point(width - x2[j] * inx2-5, height / 1 - y2[j]/2.5);
					point(width / 2 - x[j] / 8 * inx1, height - y[j]/2);
					point(width / 2 + x[j] / 8 * inx1, height - y[j]/2);
					
					point(width - x[j] / 8 * inx1,  y[j]/2);
					point(x[j] / 8 * inx1, y[j]/2);
					point(width - y[j] / 3 * inx1, height - x[j]/2);
					point(y[j] / 3 * inx1,height - x[j]/2);
					//point(width / 4 - x[j] / , y[j]/3);
					//point(width - width / 4 + x[j] / 8, y[j]/3);
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"1011650","E12","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 6;

function setup() {
  createCanvas(800, 800);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (1.25), y: (width / (1.25-j/8) + x - y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.5 * x) / 1 + j * 1, y: (height / 4 - x * 1.0 / j + (y / 2.0)) / 1.0 + j * (80) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 - x * j) / (4 * (j / 1) + x / (width / (1.85))), y: y / 2.0 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (3.25) - x + y / (1.95 * j * ((0.5 - y / width) * 10))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 10, y: (height / 2 - y * 1.15 / j + (x / 10.075)) / 1.75 + j * (50) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (4.0 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 900000) {
		for (let i = 0; i < 10000; i += 1) {
			for (let j = 5; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let nx1 = y[j] / height;
				let inx1 = 0.05+pow(1-nx1, 2.0);
				let nx2 = y2[j] / height;
				let inx2 = 0.45+pow(nx2, 0.5);
				
				let e = 0.75;

				if (iter > 20) {
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 0 * pow((j / ifs), 2), 255, 0.0225 * a);
					point(height / 2 - y[j]/4, x[j] * inx1+5);
					point(height / 2 + y[j]/4, x[j] * inx1+5);

					point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					point(y[j]/1.95, width - x[j] * inx1+5);
					point(width - x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					point(x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					point(height / 1 - y[j]/1.5, width - x[j] * inx1+5);
					point(y[j]/1.5, width - x[j] * inx1+5);
					//point(width - x[j] / 8, height - y[j]/4);
				//	oint(x[j] / 8, height - y[j]/4);
					//point(width / 2 - x[j] / 8, height - y[j]/4);
					//point(width - y[j] / 4.5 - width / 2, height - x[j]/4);
					//point(width / 2 - x[j] / 4.5 - width * 0.005, y[j]/4);
					//point(width / 2 + x[j] / 4.5 + width * 0.005, height - y[j]/4);
					//point(width + y[j] / 4.5 - width / 2, x[j]/4);
					//point(width / 2 - y[j] / 5, height - x[j]/4);
					//point(width / 2 + y[j] / 5, height - x[j]/4);
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"1011433","Flow field 3","mySketch","// simple vector field with a twist

let normals = [];
let particl = [];

let fun_index = 0;

const fun = [
	(nx, ny) => { return { x: sin(nx * PI * 2 + cos(ny * PI * 4) * PI * 2), y: cos(ny * PI * 2 + sin(nx * PI * 2) * PI * 2) } }
];

let pcount = 10000;
let batchc = 3333; // basically how much particles to refresh / frame (pcount / batchc = 3 frames for whole refresh which is roughly 20fps on my i7 7700)

function setup() {
	createCanvas(600, 600);
	background(100);
	
	noiseDetail(4, 0.7);
	
	colorMode(HSB, 360, 1, 1, 1);
	
	rectMode(CENTER);
	
	noStroke();
	
	background(0);
	/*
	for (let i = 0; i < width * height; i += 1) {
		//particl[i] = { x: random(0, width), y: random(0, height) };
		particl[i] = { x: i % width, y: floor(i / width), vx: 1, vy: 1 };
	}
	*/
	for (let i = 0; i < pcount; i += 1) {
		particl[i] = { x: random(0, width), y: random(0, height), b: 0, bl: noise(i/pcount*4) > 0.5 ? 1: 0.0, a: random() };
	}
	
	generateNormals(fun[0]);
}

function generateNormals(f) {
	stroke(0, 0.5, 1, 1);
	
	let offx = random(0, 1);
	
	for (let y = 0; y < height; y += 1) {
		for (let x = 0; x < width; x += 1) {
			let nx = x / width;
			let ny = y / height;
			
			//let n = noise(nx * 4, ny * 4); // sampled point
			
			let nx0 = noise(nx * 4 - 0.05 + offx, ny * 1); // left
			let nx1 = noise(nx * 4 + 0.05 + offx, ny * 1); // right
			let ny1 = noise(nx * 4 + offx, ny * 4 + 0.05); // top
			let ny0 = noise(nx * 4 + offx, ny * 4 - 0.05); // bottom
			
			let dzdx= (nx1-nx0) / 2;
			let dzdy= (ny1-ny0) / 2;
			
			// vector length
			let len = sqrt((dzdx * dzdx) + (dzdy * dzdy))+0.001;
			
			// normalize
			dzdx /= len;
			dzdy /= len;
			
			normals[x + y * width] = f(nx, ny);
			
			// line(x, y, x + -dzdx * 1, y + -dzdy * 1);
		}
	}
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	rectMode(CORNERS);
	
	noStroke();
	fill(0, 0, 0, 0.05);
	rect(0, 0, width, height);
	
	if (frameCount % 60 == 0) {
		fun_index += 1;
		fun_index %= fun.length;
		
		//generateNormals(fun[fun_index]);
	}
	
	rectMode(CENTER);
	//background(0);
/*
  // display noise map
	for (let y = 0; y < 800; y += 16) {
		for (let x = 0; x < 800; x += 16) {
			let nx = x / 800;
			let ny = y / 800;
			
			let n = noise(nx * 4, ny * 4);
			
			fill(0, 0, pow(n, 1.25), 1);
			rect(x, y, 16, 16);
		}
	}
*/
	
	noStroke();
	fill(0, 0, 1, 1);
	//loadPixels();
	
	let start_index = frameCount % floor(pcount/batchc) * batchc;
	
	for (let i = 0; i < start_index; i += 1) {
		let p = particl[i];
		let px = floor(p.x);
		let py = floor(p.y);
		fill(170 + abs(p.b) / width/10 % 100, abs(p.b / width) / 255 % 1, p.bl, p.a);
		rect(px, py, 1, 1);
	}
	
	for (let i = start_index+batchc; i < pcount - (start_index+batchc); i += 1) {
		let p = particl[i];
		let px = floor(p.x);
		let py = floor(p.y);
		fill(170 + abs(p.b) / width/10 % 100, abs(p.b / width) / 255 % 1, p.bl, p.a);
		rect(px, py, 1, 1);
	}
	
	for (let i = start_index; i < start_index+batchc; i += 1) {
		let p = particl[i];
		//let p2 = particl[i-1];

		let px = floor(p.x);
		let py = floor(p.y);

		let index2 = px + py * width;
		let d = normals[index2];

		fill(170 + abs(p.b) / width/10 % 90, abs(p.b / width) / 512 % 0.95, p.bl, p.a);
		//pixels[(px + py * width) * 4+0] = d.b;
		//pixels[(px + py * width) * 4+1] = d.b;
		//pixels[(px + py * width) * 4+2] = d.b;
		rect(px, py, 1, 1);
		//point(px, py);
		//line(px, py, floor(p2.x), floor(p2.y));

		p.x += d.x;
		p.y += d.y;
		p.b += d.x * d.y * 10000;

		if (frameCount % 1000 < 500) {
			d.x += (p.x / width*2-1) / 2;
			d.y += (p.y / height*2-1) / 2;
		} else {
			d.x -= (p.x / width*2-1) / 2;
			d.y -= (p.y / height*2-1) / 2;
		}
		/*
		if (floor(p.x) == width/2) {
			p.x = 0;//(random() > 0.5) ? 0 : width - 1;
		}
		if (floor(p.y) == width/2) {
			p.y = 0;//(random() > 0.5) ? 0 : height - 1;
		}*/
		if (p.x > width) {
			p.x = random(width/2 - 24, width/2 + 24);
		}
		if (p.y > height) {
			p.y = random(height/2 - 24, height/2 + 24);
		}
		if (p.x < 0) {
			p.x = random(width/2 - 24, width/2 + 24);
		}
		if (p.y < 0) {
			p.y = random(height/2 - 24, height/2 + 24);
		}
	}
	//updatePixels();
	
	xmotion += 0.1;
	ymotion += 0.0075;
}"
"1011433","Flow field 3","mySketch","// simple vector field with a twist

let normals = [];
let particl = [];

let fun_index = 0;

const fun = [
	(nx, ny) => { return { x: sin(nx * PI * 1 + cos(ny * PI * 8) * PI * 1), y: cos(ny * PI * 1 + sin(nx * PI * 8) * PI * 1) } }
];

let pcount = 512*512;
let batchc = 5000; // basically how much particles to refresh / frame (pcount / batchc = 3 frames for whole refresh which is roughly 20fps on my i7 7700)

let heightmap;
let colormap;

function preload() {
  heightmap = loadImage('text.jpg');
	colormap = loadImage('beach.png');
}

function setup() {
	createCanvas(512, 512);
	background(100);
	
	noiseDetail(4, 0.7);
	
	colorMode(HSB, 360, 1, 1, 1);
	
	rectMode(CENTER);
	
	noStroke();
	
	background(0);
	/*
	for (let i = 0; i < width * height; i += 1) {
		//particl[i] = { x: random(0, width), y: random(0, height) };
		particl[i] = { x: i % width, y: floor(i / width), vx: 1, vy: 1 };
	}
	*/
	colormap.loadPixels();
	for (let i = 0; i < pcount; i += 1) {
		//let x = floor(random(0, colormap.width));
		//let y = floor(random(0, colormap.height));
		
		let index = i*4;//(x + y * colormap.width) * 4;
		particl[i] = { x: i%512, y: i/512, b:0, r: colormap.pixels[index], g: colormap.pixels[index+1], bb: colormap.pixels[index+2], a: 1 };
	}
	
	generateNormals(fun[0]);
}

function generateNormals(f) {
	stroke(0, 0.5, 1, 1);
	
	let offx = random(0, 1);
	
	heightmap.loadPixels();
	
	for (let y = 0; y < heightmap.height; y += 1) {
		for (let x = 0; x < heightmap.width; x += 1) {
			normals[x + y * width] = { x: 0, y: 0 };
		}
	}
	
	for (let y = 1; y < heightmap.height-1; y += 1) {
		for (let x = 1; x < heightmap.width-1; x += 1) {
			let nx = x / heightmap.width;
			let ny = y / heightmap.height;
			
			let index = (x + y * width) * 4;
			
			let nx0 = heightmap.pixels[((x - 1) + y * width) * 4] / 255;
			let nx1 = heightmap.pixels[((x + 1) + y * width) * 4] / 255;
			let ny1 = heightmap.pixels[(x + (y - 1) * width) * 4] / 255;
			let ny0 = heightmap.pixels[(x + (y + 1) * width) * 4] / 255;
			//let n = noise(nx * 4, ny * 4); // sampled point
			
			//let nx0 = noise(nx * 4 - 0.05 + offx, ny * 1); // left
			//let nx1 = noise(nx * 4 + 0.05 + offx, ny * 1); // right
			//let ny1 = noise(nx * 4 + offx, ny * 4 + 0.05); // top
			//let ny0 = noise(nx * 4 + offx, ny * 4 - 0.05); // bottom
			
			let dzdx= (nx1-nx0) / 2;
			let dzdy= (ny1-ny0) / 2;
			
			// vector length
			let len = sqrt((dzdx * dzdx) + (dzdy * dzdy))+0.001;
			
			// normalize
			dzdx /= len;
			dzdy /= len;
			
			normals[x + y * width] = /*f(nx, ny);*/{ x: dzdx, y: dzdy };//f(nx, ny);
			
			// line(x, y, x + -dzdx * 1, y + -dzdy * 1);
		}
	}
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	rectMode(CORNERS);
	
	noStroke();
	fill(0, 0, 0, 0.025);
	rect(0, 0, width, height);
	
	if (frameCount % 60 == 0) {
		fun_index += 1;
		fun_index %= fun.length;
		
		//generateNormals(fun[fun_index]);
	}
	
	//rectMode(CENTER);
	//background(0);
/*
  // display noise map
	for (let y = 0; y < 800; y += 16) {
		for (let x = 0; x < 800; x += 16) {
			let nx = x / 800;
			let ny = y / 800;
			
			let n = noise(nx * 4, ny * 4);
			
			fill(0, 0, pow(n, 1.25), 1);
			rect(x, y, 16, 16);
		}
	}
*/
	
	noStroke();
	fill(0, 0, 1, 1);
	loadPixels();
	
	let start_index = frameCount % floor(pcount/batchc) * batchc;
	/*
	for (let i = 0; i < start_index; i += 1) {
		let p = particl[i];
		let px = floor(p.x);
		let py = floor(p.y);
		pixels[(px + py * width) * 4+0] = p.r;
		pixels[(px + py * width) * 4+1] = p.g;
		pixels[(px + py * width) * 4+2] = p.bb;
	}
	
	for (let i = start_index+batchc; i < pcount - (start_index+batchc); i += 1) {
		let p = particl[i];
		let px = floor(p.x);
		let py = floor(p.y);
		pixels[(px + py * width) * 4+0] = p.r;
		pixels[(px + py * width) * 4+1] = p.g;
		pixels[(px + py * width) * 4+2] = p.bb;
	}*/
	
	for (let i = start_index; i < start_index+batchc; i += 1) {
		let p = particl[i];
		//let p2 = particl[i-1];

		let px = floor(p.x);
		let py = floor(p.y);

		let index2 = px + py * width;
		let d = normals[index2];

		//fill(0, 0, p.bl, p.a);
		pixels[(px + py * width) * 4+0] += p.r;
		pixels[(px + py * width) * 4+1] += p.g;
		pixels[(px + py * width) * 4+2] += p.bb;
		//rect(px, py, 1, 1);
		//point(px, py);
		//line(px, py, floor(p2.x), floor(p2.y));

		p.x += d.x;
		p.y += d.y;
		//p.b += d.x * d.y * 10000;
/*
		if (frameCount % 1000 < 500) {
			d.x += (p.x / width*2-1) / 2;
			d.y += (p.y / height*2-1) / 2;
		} else {
			d.x -= (p.x / width*2-1) / 2;
			d.y -= (p.y / height*2-1) / 2;
		}*/
		/*
		if (floor(p.x) == width/2) {
			p.x = 0;//(random() > 0.5) ? 0 : width - 1;
		}
		if (floor(p.y) == width/2) {
			p.y = 0;//(random() > 0.5) ? 0 : height - 1;
		}*/
		if (p.x > width) {
			p.x = random(width/2 - 24, width/2 + 24);
		}
		if (p.y > height) {
			p.y = random(height/2 - 24, height/2 + 24);
		}
		if (p.x < 0) {
			p.x = random(width/2 - 24, width/2 + 24);
		}
		if (p.y < 0) {
			p.y = random(height/2 - 24, height/2 + 24);
		}
	}
	updatePixels();
	
	xmotion += 0.1;
	ymotion += 0.0075;
}"
"1011433","Flow field 3","mySketch","// simple vector field with a twist

let normals = [];
let particl = [];

let fun_index = 0;

const fun = [
	(nx, ny) => { return { x: sin(nx * PI * 4 + abs(cos(ny * PI * 10) * PI * 1)), y: abs(cos(ny * PI * 1 + sin(nx * PI * 0.5) * PI * 1)) } }
];

let pcount = 512*512;
let batchc = 10000; // basically how much particles to refresh / frame (pcount / batchc = 3 frames for whole refresh which is roughly 20fps on my i7 7700)

let heightmap;
let colormap;

function preload() {
  heightmap = loadImage('text.jpg');
	colormap = loadImage('beach.png');
}

function setup() {
	createCanvas(512, 512);
	background(100);
	
	noiseDetail(1, 0.7);
	
	colorMode(HSB, 360, 1, 1, 1);
	
	rectMode(CENTER);
	
	noStroke();
	
	background(0);
	/*
	for (let i = 0; i < width * height; i += 1) {
		//particl[i] = { x: random(0, width), y: random(0, height) };
		particl[i] = { x: i % width, y: floor(i / width), vx: 1, vy: 1 };
	}
	*/
	colormap.loadPixels();
	for (let i = 0; i < pcount; i += 1) {
		//let x = floor(random(0, colormap.width));
		//let y = floor(random(0, colormap.height));
		
		let index = i*4;//(x + y * colormap.width) * 4;
		particl[i] = { x: i%512, y: i/512, b:0, r: colormap.pixels[index], g: colormap.pixels[index+1], bb: colormap.pixels[index+2], a: 1 };
	}
	
	generateNormals(fun[0]);
}

function generateNormals(f) {
	stroke(0, 0.5, 1, 1);
	
	let offx = random(0, 1);
	
	heightmap.loadPixels();
	
	for (let y = 0; y < heightmap.height; y += 1) {
		for (let x = 0; x < heightmap.width; x += 1) {
			normals[x + y * width] = { x: 0, y: 0 };
		}
	}
	
	for (let y = 1; y < heightmap.height-1; y += 1) {
		for (let x = 1; x < heightmap.width-1; x += 1) {
			let nx = x / heightmap.width;
			let ny = y / heightmap.height;
			
			let index = (x + y * width) * 4;
			
			//let nx0 = heightmap.pixels[((x - 1) + y * width) * 4] / 255;
			//let nx1 = heightmap.pixels[((x + 1) + y * width) * 4] / 255;
			//let ny1 = heightmap.pixels[(x + (y - 1) * width) * 4] / 255;
			//let ny0 = heightmap.pixels[(x + (y + 1) * width) * 4] / 255;
			//let n = noise(nx * 4, ny * 4); // sampled point
			
			let nx0 = noise(nx * 4 - 0.05 + offx, ny * 1); // left
			let nx1 = noise(nx * 4 + 0.05 + offx, ny * 1); // right
			let ny1 = noise(nx * 4 + offx, ny * 4 + 0.05); // top
			let ny0 = noise(nx * 4 + offx, ny * 4 - 0.05); // bottom
			
			let dzdx= (nx1-nx0) / 2;
			let dzdy= (ny1-ny0) / 2;
			
			// vector length
			let len = sqrt((dzdx * dzdx) + (dzdy * dzdy))+0.001;
			
			// normalize
			dzdx /= len;
			dzdy /= len;
			
			normals[x + y * width] = { x: dzdx, y: dzdy };//f(nx, ny);
			
			// line(x, y, x + -dzdx * 1, y + -dzdy * 1);
		}
	}
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	rectMode(CORNERS);
	
	noStroke();
	fill(0, 0, 0, 0.2);
	rect(0, 0, width, height);
	
	if (frameCount % 60 == 0) {
		fun_index += 1;
		fun_index %= fun.length;
		
		//generateNormals(fun[fun_index]);
	}
	
	//rectMode(CENTER);
	//background(0);
/*
  // display noise map
	for (let y = 0; y < 800; y += 16) {
		for (let x = 0; x < 800; x += 16) {
			let nx = x / 800;
			let ny = y / 800;
			
			let n = noise(nx * 4, ny * 4);
			
			fill(0, 0, pow(n, 1.25), 1);
			rect(x, y, 16, 16);
		}
	}
*/
	
	noStroke();
	fill(0, 0, 1, 1);
	loadPixels();
	
	let start_index = frameCount % floor(pcount/batchc) * batchc;
	
	for (let i = 0; i < start_index; i += 1) {
		let p = particl[i];
		let px = floor(p.x);
		let py = floor(p.y);
		pixels[(px + py * width) * 4+0] = p.r;
		pixels[(px + py * width) * 4+1] = p.g;
		pixels[(px + py * width) * 4+2] = p.bb;
	}
	
	for (let i = start_index+batchc; i < pcount - (start_index+batchc); i += 1) {
		let p = particl[i];
		let px = floor(p.x);
		let py = floor(p.y);
		pixels[(px + py * width) * 4+0] = p.r;
		pixels[(px + py * width) * 4+1] = p.g;
		pixels[(px + py * width) * 4+2] = p.bb;
	}
	
	for (let i = start_index; i < start_index+batchc; i += 1) {
		let p = particl[i];
		//let p2 = particl[i-1];

		let px = floor(p.x);
		let py = floor(p.y);

		let index2 = px + py * width;
		let d = normals[index2];

		//fill(0, 0, p.bl, p.a);
		pixels[(px + py * width) * 4+0] += p.r;
		pixels[(px + py * width) * 4+1] += p.g;
		pixels[(px + py * width) * 4+2] += p.bb;
		//rect(px, py, 1, 1);
		//point(px, py);
		//line(px, py, floor(p2.x), floor(p2.y));

		p.x += d.x;
		p.y += d.y;
		//p.b += d.x * d.y * 10000;
/*
		if (frameCount % 1000 < 500) {
			d.x += (p.x / width*2-1) / 2;
			d.y += (p.y / height*2-1) / 2;
		} else {
			d.x -= (p.x / width*2-1) / 2;
			d.y -= (p.y / height*2-1) / 2;
		}*/
		/*
		if (floor(p.x) == width/2) {
			p.x = 0;//(random() > 0.5) ? 0 : width - 1;
		}
		if (floor(p.y) == width/2) {
			p.y = 0;//(random() > 0.5) ? 0 : height - 1;
		}*/
		if (p.x > width) {
			p.x = random(width/2 - 24, width/2 + 24);
		}
		if (p.y > height) {
			p.y = random(height/2 - 24, height/2 + 24);
		}
		if (p.x < 0) {
			p.x = random(width/2 - 24, width/2 + 24);
		}
		if (p.y < 0) {
			p.y = random(height/2 - 24, height/2 + 24);
		}
	}
	updatePixels();
	
	xmotion += 0.1;
	ymotion += 0.0075;
}"
"1009687","IFS10","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 6;

function setup() {
  createCanvas(800, 800);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (1.0), y: (width / (1.15) + x - y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 3 * x) / 1 + j * 100, y: (height / 6 - y * 1 / j + (x / 4.0)) / 1.0 + j * (10) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 - x * j) / (y/40 * (j / 8) + x / (width / (5.85))), y: y / 2.5 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (3.25) - x + y / (1.95 * j * ((0.5 - y / width) * 10))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 10, y: (height / 2 - y * 1.15 / j + (x / 10.075)) / 1.75 + j * (50) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (4.0 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 5; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let nx1 = y[j] / height * 2. - 1.;
				let inx1 = 0.25+pow(1-nx1, 1);
				let nx2 = y2[j] / height;
				let inx2 = 0.45+pow(nx2, 0.5);
				
				let e = 0.75;

				if (iter > 20) {
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.0225 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);
					//point(width - x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					//point(x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					
					//point(x2[j] * inx2+5, height / 1 - y2[j]/2.5);
					//point(width - x2[j] * inx2-5, height / 1 - y2[j]/2.5);
					point(width / 2 - x[j] / 8 * inx1, height - y[j]/2);
				  point(width / 2 + x[j] / 8 * inx1, height - y[j]/2);
					
					point(width - x[j] / 8 * inx1,  y[j]/2);
					point(x[j] / 8 * inx1, y[j]/2);
					point(width - y[j] / 2 * inx1, height - x[j]/2);
					point(y[j] / 2 * inx1,height - x[j]/2);
					//point(width / 4 - x[j] / , y[j]/3);
					//point(width - width / 4 + x[j] / 8, y[j]/3);
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"1009687","IFS10","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 6;

function setup() {
  createCanvas(800, 800);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (1.0), y: (width / (1.15) + x - y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 3 * x) / 1 + j * 100, y: (height / 6 - y * 1 / j + (x / 4.0)) / 1.0 + j * (10) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 - x * j) / (y/40 * (j / 8) + x / (width / (5.85))), y: y / 2.5 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (3.25) - x + y / (1.95 * j * ((0.5 - y / width) * 10))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 10, y: (height / 2 - y * 1.15 / j + (x / 10.075)) / 1.75 + j * (50) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (4.0 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 5; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let nx1 = y[j] / height * 2. - 1.;
				let inx1 = 0.25+pow(1-nx1, 1);
				let nx2 = y2[j] / height;
				let inx2 = 0.45+pow(nx2, 0.5);
				
				let e = 0.75;

				if (iter > 20) {
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.0225 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);
					//point(width - x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					//point(x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					
					//point(x2[j] * inx2+5, height / 1 - y2[j]/2.5);
					//point(width - x2[j] * inx2-5, height / 1 - y2[j]/2.5);
					point(width / 2 - x[j] / 8 * inx1, height - y[j]/2);
				  point(width / 2 + x[j] / 8 * inx1, height - y[j]/2);
					
					point(width - x[j] / 8 * inx1,  y[j]/2);
					point(x[j] / 8 * inx1, y[j]/2);
					point(width - y[j] / 2 * inx1, height - x[j]/2);
					point(y[j] / 2 * inx1,height - x[j]/2);
					//point(width / 4 - x[j] / , y[j]/3);
					//point(width - width / 4 + x[j] / 8, y[j]/3);
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"1009668","Burnt","mySketch","// software rendering noise heightfield normal map with blinn phong shading

let normals = [];
let details = [];

// https://iquilezles.org/www/articles/palettes/palettes.htm
function pal(t, a, b, c, d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

function setup() {
	createCanvas(600, 600);
	background(100);
	
	colorMode(HSB, 360, 1, 1, 1);
	
	rectMode(CORNER);
	
	noStroke();
	
	background(0);
	
	generateNormals();
}

function generateNormals () {
	for (let y = 0; y < height; y += 1) {
		for (let x = 0; x < width; x += 1) {
			let nx = x / width;
			let ny = y / height;
			
			let npx = x / width * 2 - 1;
			let npy = y / height * 2 - 1;
			
			let scale = 4;
			let offset = 0.5;
			
			noiseDetail(4, 0.5);
			
			let n2 = noise(nx / 2, ny / 2) * 1.025;
			
			noiseDetail(8, 0.7);
			
			let dc = norm(min(pow(1-dist(npx, npy, 0, 0)*0.1775, 0.25), 1) * pow(0.05+abs(((sin((0.5-nx)*2 * PI * 2+ cos(ny * PI * 4))+(sin((0.5-ny)*2 * PI * 2)))/2)), 0.075), 0, 1);
			
			let n = (noise(nx * scale, ny * scale)+n2)/2 * dc; // sampled point
			
			let nx0 = (noise(nx * scale - offset, ny * scale)+n2)/2; // left
			let nx1 = (noise(nx * scale + offset, ny * scale)+n2)/2; // right
			let ny1 = (noise(nx * scale, ny * scale + offset)+n2)/2; // top
			let ny0 = (noise(nx * scale, ny * scale - offset)+n2)/2; // bottom
			
			let dzdx = (nx1-nx0) / 2;
			let dzdy = (ny1-ny0) / 2;
			
			// vector length
			let len = sqrt((dzdx * dzdx) + (dzdy * dzdy));
			
			// normalize
			dzdx /= len;
			dzdy /= len;
			
			normals[x + y * width] = { x: dzdx, y: dzdy, z: n };
			
			details[x + y * width] = norm(n*n2, 0, 1);
			
			//line(x, y, x + -dzdx * 10, y + -dzdy * 10);
		}
	}
	
	drawStuff();
}

function drawStuff() {
	noStroke();
	loadPixels();
	for (let y = floor(random(0, 4)); y < height; y += 4) {
		for (let x = floor(random(0, 4)); x < width; x += 4) {
			let n = normals[x + y * width];
			
			let nx = x / width;
			let ny = y / height;
			
			let npx = x / width * 2 - 1;
			let npy = y / height * 2 - 1;
			
			let spec_mul = 1;
			
			let light_z_pos = 3; // above
			
			let lpx = light_npx - npx;
			let lpy = light_npy - npy;
			let lpz = light_z_pos - n.z;
			
			let light_dst = sqrt((lpx * lpx) + (lpy * lpy) + (lpz * lpz));
			lpx /= light_dst;
			lpy /= light_dst;
			lpz /= light_dst;
			light_dst = light_dst * light_dst;
			
			let n_dot_l = n.x * lpx + n.y * lpy + n.z * lpz;
			let lambert = max(n_dot_l, 0);
			
			let specular = 0;
			if (lambert > 0) {
				specular = pow(max(norm(n_dot_l, 0, 1), 0), 4*spec_mul);
			}
			
			//let det = details[x + y * width];
			noiseDetail(3, 0.75);
			let det = noise(nx * 1 + xmotion/4, ny * 1 + ymotion/7)*1.25;

			let ambient = 0.1;
			let diffuse_color = 180 + n.z * 100;
			let brightness = (n.z * (ambient + lambert * 1 / light_dst + specular * 8 / light_dst));

			brightness = pow(brightness, 1.0 / 2.2);
			//brightness_rgb = floor(brightness * 255);
			
			let pa1 = 0.7, pa2 = 0.5, pa3 = 0.5;
			let pb1 = 0.75, pb2 = 0.5, pb3 = 0.5;
			let pc1 = 0.75, pc2 = 0.5, pc3 = 0.5;

			let pdr = 0.5 - det / 10;
			let pdg = 0.25 + n.z / 2;
			let pdb = 0.45 + det / 4 * n.z / 4;
			
			var rf = (pal(n.z, pa1, pb1, pc1, pdr) * brightness * 255);
			var gf = (pal(n.z, pa2, pb2, pc2, pdg) * brightness * 255);
			var bf = (pal(n.z, pa3, pb3, pc3, pdb) * brightness * 255);

/*    // slow
			if (diffuse > 0) {
				fill(diffuse_color, 0.0, brightness, 1);
				rect(x, y, 1, 1);
			}
*/
			pixels[(x + y * width) * 4 + 0] = rf; // inverse can be cool as well
			pixels[(x + y * width) * 4 + 1] = gf;
			pixels[(x + y * width) * 4 + 2] = bf;
		}
	}
	updatePixels();
}

let light_npx = 0;
let light_npy = 0;

let xmotion = 0;
let ymotion = 0;

function draw() {
drawStuff();
	
	light_npx = cos(xmotion);
	light_npy = sin(ymotion);
	
	xmotion += 0.05;
	ymotion += 0.05;	
}"
"1007806","Texture","mySketch","// software rendering noise heightfield normapmap with blinn phong shading
// inverted colors island looking like some cloudy giants

let normals = [];
let details = [];

// https://iquilezles.org/www/articles/palettes/palettes.htm
function pal(t, a, b, c, d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

function setup() {
	createCanvas(600, 600);
	background(100);
	
	colorMode(HSB, 360, 1, 1, 1);
	
	rectMode(CORNER);
	
	noStroke();
	
	background(0);
	
	generateNormals();
}

function generateNormals () {
	for (let y = 0; y < height; y += 1) {
		for (let x = 0; x < width; x += 1) {
			let nx = x / width;
			let ny = y / height;
			
			let npx = x / width * 2 - 1;
			let npy = y / height * 2 - 1;
			
			let scale = 8;
			let offset = 0.005;
			
			noiseDetail(4, 0.5);
			
			let n2 = noise(nx / 2, ny / 2) * 1.025;
			
			noiseDetail(6, 0.6);
			
			let dc = norm(min(pow(1-dist(npx, npy, 0, 0)*0.1775, 0.25), 1) * pow(0.001+abs(((sin((0.5-nx)*2 * PI * 2+ cos(ny * PI * 4))+(sin((0.5-ny)*2 * PI * 2)))/2)), 0.05), 0, 1);
			
			let n = (noise(nx * scale, ny * scale)+n2)/2 * dc; // sampled point
			
			let nx0 = (noise(nx * scale - offset, ny * scale)+n2)/2; // left
			let nx1 = (noise(nx * scale + offset, ny * scale)+n2)/2; // right
			let ny1 = (noise(nx * scale, ny * scale + offset)+n2)/2; // top
			let ny0 = (noise(nx * scale, ny * scale - offset)+n2)/2; // bottom
			
			let dzdx = (nx1-nx0) / 2;
			let dzdy = (ny1-ny0) / 2;
			
			// vector length
			let len = sqrt((dzdx * dzdx) + (dzdy * dzdy));
			
			// normalize
			dzdx /= len;
			dzdy /= len;
			
			normals[x + y * width] = { x: dzdx, y: dzdy, z: n };
			
			details[x + y * width] = norm(n*n2, 0, 1);
			
			//line(x, y, x + -dzdx * 10, y + -dzdy * 10);
		}
	}
	
	drawStuff();
}

function drawStuff() {
	noStroke();
	loadPixels();
	for (let y = floor(random(0, 4)); y < height; y += 4) {
		for (let x = floor(random(0, 4)); x < width; x += 4) {
			let n = normals[x + y * width];
			
			let nx = x / width;
			let ny = y / height;
			
			let npx = x / width * 2 - 1;
			let npy = y / height * 2 - 1;
			
			let spec_mul = 1;
			
			let light_z_pos = 5; // above
			
			let lpx = light_npx - npx;
			let lpy = light_npy - npy;
			let lpz = light_z_pos - n.z;
			
			let light_dst = sqrt((lpx * lpx) + (lpy * lpy) + (lpz * lpz));
			lpx /= light_dst;
			lpy /= light_dst;
			lpz /= light_dst;
			light_dst = light_dst * light_dst;
			
			let n_dot_l = n.x * lpx + n.y * lpy + n.z * lpz;
			let lambert = max(n_dot_l, 0);
			
			let specular = 0;
			if (lambert > 0) {
				specular = pow(max(norm(n_dot_l, 0, 1), 0), 4*spec_mul);
			}
			
			//let det = details[x + y * width];
			noiseDetail(3, 0.75);
			let det = noise(nx * 4 + xmotion/4, ny * 4 + ymotion/7)*1.25;

			let ambient = 0.1;
			let diffuse_color = 180 + n.z * 100;
			let brightness = (n.z * (ambient + lambert * 1 / light_dst + specular * 8 / light_dst));

			brightness = pow(brightness, 1.0 / 2.2);
			//brightness_rgb = floor(brightness * 255);
			
			let pa1 = 0.7, pa2 = 0.5, pa3 = 0.5;
			let pb1 = 0.75, pb2 = 0.5, pb3 = 0.5;
			let pc1 = 0.75, pc2 = 0.5, pc3 = 0.5;

			let pdr = 0.5 - det / 10;
			let pdg = 0.25 + n.z / 2;
			let pdb = 0.45 + det / 4 * n.z / 4;
			
			var rf = (pal(n.z, pa1, pb1, pc1, pdr) * brightness * 255);
			var gf = (pal(n.z, pa2, pb2, pc2, pdg) * brightness * 255);
			var bf = (pal(n.z, pa3, pb3, pc3, pdb) * brightness * 255);

/*    // slow
			if (diffuse > 0) {
				fill(diffuse_color, 0.0, brightness, 1);
				rect(x, y, 1, 1);
			}
*/
			pixels[(x + y * width) * 4 + 0] = 255-rf; // inverse can be cool as well
			pixels[(x + y * width) * 4 + 1] = 255-gf;
			pixels[(x + y * width) * 4 + 2] = 255-bf;
		}
	}
	updatePixels();
}

let light_npx = 0;
let light_npy = 0;

let xmotion = 0;
let ymotion = 0;

function draw() {
drawStuff();
	
	light_npx = cos(xmotion);
	light_npy = sin(ymotion);
	
	xmotion += 0.05;
	ymotion += 0.05;	
}"
"1007193","Solaris","mySketch","// software rendering noise heightfield bumpmap with blinn phong shading
// inverted colors island looking like some cloudy giants

let normals = [];
let details = [];

// https://iquilezles.org/www/articles/palettes/palettes.htm
function pal(t, a, b, c, d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

function setup() {
	createCanvas(600, 600);
	background(100);
	
	colorMode(HSB, 360, 1, 1, 1);
	
	rectMode(CORNER);
	
	noStroke();
	
	background(0);
	
	generateNormals();
}

function generateNormals () {
	for (let y = 0; y < height; y += 1) {
		for (let x = 0; x < width; x += 1) {
			let nx = x / width;
			let ny = y / height;
			
			let npx = x / width * 2 - 1;
			let npy = y / height * 2 - 1;
			
			let scale = 3;
			let offset = 0.05;
			
			noiseDetail(9, 0.75);
			
			let dc = min((1-dist(npx, npy, 0, 0)*0.775), 1);
			
			let n = noise(nx * scale, ny * scale) * dc; // sampled point
			
			let nx0 = noise(nx * scale - offset, ny * scale) * dc; // left
			let nx1 = noise(nx * scale + offset, ny * scale) * dc; // right
			let ny1 = noise(nx * scale, ny * scale + offset) * dc; // top
			let ny0 = noise(nx * scale, ny * scale - offset) * dc; // bottom
			
			let dzdx = (nx1-nx0) / 2;
			let dzdy = (ny1-ny0) / 2;
			
			// vector length
			let len = sqrt((dzdx * dzdx) + (dzdy * dzdy));
			
			// normalize
			dzdx /= len;
			dzdy /= len;
			
			normals[x + y * width] = { x: dzdx, y: dzdy, z: n };
			
			// 2
			noiseDetail(8, 0.5);
			
			let n2 = noise(nx * 2, ny * 16);
			
			details[x + y * width] = n;
			
			//line(x, y, x + -dzdx * 10, y + -dzdy * 10);
		}
	}
	
	drawStuff();
}

function drawStuff() {
	noStroke();
	loadPixels();
	for (let y = floor(random(0, 4)); y < height; y += 4) {
		for (let x = floor(random(0, 4)); x < width; x += 4) {
			let n = normals[x + y * width];
			
			let nx = x / width;
			let ny = y / height;
			
			let npx = x / width * 2 - 1;
			let npy = y / height * 2 - 1;
			
			let spec_mul = 1;
			if (n.z < 0.25) {
				n.x += random(-1, 1) * 0.75;
				n.y += random(-1, 1) * 0.75;
				n.z += 0.1;
				spec_mul *= 4.0;
			}
			
			let light_z_pos = 2; // above
			
			let lpx = light_npx - npx;
			let lpy = light_npy - npy;
			let lpz = light_z_pos - n.z;
			
			let light_dst = sqrt((lpx * lpx) + (lpy * lpy) + (lpz * lpz));
			lpx /= light_dst;
			lpy /= light_dst;
			lpz /= light_dst;
			light_dst = light_dst * light_dst;
			
			let n_dot_l = n.x * lpx + n.y * lpy + n.z * lpz;
			let lambert = max(n_dot_l, 0);
			
			let specular = 0;
			if (lambert > 0) {
				specular = pow(max(norm(n_dot_l, 0, 1), 0), 2*spec_mul);
			}
			
			//let det = details[x + y * width];
			noiseDetail(3, 0.75);
			let det = noise(nx * 4 + xmotion/4, ny * 4 + ymotion/7)*2;

			let ambient = 0.1;
			let diffuse_color = 180 + n.z * 100;
			let brightness = ceil((n.z * (ambient + lambert * 0.1 / light_dst + specular * 1 / light_dst)) * 8) / 8 * det;

			brightness = pow(brightness, 1.0 / 2.2);
			//brightness_rgb = floor(brightness * 255);
			
			let pa1 = 0.7, pa2 = 0.5, pa3 = 0.5;
			let pb1 = 0.75, pb2 = 0.5, pb3 = 0.5;
			let pc1 = 0.75, pc2 = 0.5, pc3 = 0.5;

			let pdr = 0.5 - det / 10;
			let pdg = 0.35 + n.z / 2;
			let pdb = 0.75 + det / 4 * n.z / 4;
			
			var rf = (pal(n.z, pa1, pb1, pc1, pdr) * brightness * 255);
			var gf = (pal(n.z, pa2, pb2, pc2, pdg) * brightness * 255);
			var bf = (pal(n.z, pa3, pb3, pc3, pdb) * brightness * 255);

/*    // slow
			if (diffuse > 0) {
				fill(diffuse_color, 0.0, brightness, 1);
				rect(x, y, 1, 1);
			}
*/
			pixels[(x + y * width) * 4 + 0] = 255-rf; // inverse can be cool as well
			pixels[(x + y * width) * 4 + 1] = 255-gf;
			pixels[(x + y * width) * 4 + 2] = 255-bf;
		}
	}
	updatePixels();
}

let light_npx = 0;
let light_npy = 0;

let xmotion = 0;
let ymotion = 0;

function draw() {
drawStuff();
	
	light_npx = cos(xmotion)/2;
	light_npy = sin(ymotion)/2;
	
	xmotion += 0.05;
	ymotion += 0.05;	
}"
"1007193","Solaris","mySketch","// software rendering noise heightfield normapmap with blinn phong shading
// inverted colors island looking like some cloudy giants

let normals = [];
let details = [];

// https://iquilezles.org/www/articles/palettes/palettes.htm
function pal(t, a, b, c, d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

function setup() {
	createCanvas(600, 600);
	background(100);
	
	colorMode(HSB, 360, 1, 1, 1);
	
	rectMode(CORNER);
	
	noStroke();
	
	background(0);
	
	generateNormals();
}

function generateNormals () {
	for (let y = 0; y < height; y += 1) {
		for (let x = 0; x < width; x += 1) {
			let nx = x / width;
			let ny = y / height;
			
			let npx = x / width * 2 - 1;
			let npy = y / height * 2 - 1;
			
			let scale = 3;
			let offset = 0.05;
			
			noiseDetail(9, 0.75);
			
			let dc = min((1-dist(npx, npy, 0, 0)*0.775), 1);
			
			let n = noise(nx * scale, ny * scale) * dc; // sampled point
			
			let nx0 = noise(nx * scale - offset, ny * scale) * dc; // left
			let nx1 = noise(nx * scale + offset, ny * scale) * dc; // right
			let ny1 = noise(nx * scale, ny * scale + offset) * dc; // top
			let ny0 = noise(nx * scale, ny * scale - offset) * dc; // bottom
			
			let dzdx = (nx1-nx0) / 2;
			let dzdy = (ny1-ny0) / 2;
			
			// vector length
			let len = sqrt((dzdx * dzdx) + (dzdy * dzdy));
			
			// normalize
			dzdx /= len;
			dzdy /= len;
			
			normals[x + y * width] = { x: dzdx, y: dzdy, z: n };
			
			// 2
			noiseDetail(8, 0.5);
			
			let n2 = noise(nx * 2, ny * 16);
			
			details[x + y * width] = n;
			
			//line(x, y, x + -dzdx * 10, y + -dzdy * 10);
		}
	}
	
	drawStuff();
}

function drawStuff() {
	noStroke();
	loadPixels();
	for (let y = floor(random(0, 4)); y < height; y += 4) {
		for (let x = floor(random(0, 4)); x < width; x += 4) {
			let n = normals[x + y * width];
			
			let nx = x / width;
			let ny = y / height;
			
			let npx = x / width * 2 - 1;
			let npy = y / height * 2 - 1;
			
			let spec_mul = 1;
			if (n.z < 0.25) {
				n.x += random(-1, 1) * 0.75;
				n.y += random(-1, 1) * 0.75;
				n.z += 0.1;
				spec_mul *= 4.0;
			}
			
			let light_z_pos = 2; // above
			
			let lpx = light_npx - npx;
			let lpy = light_npy - npy;
			let lpz = light_z_pos - n.z;
			
			let light_dst = sqrt((lpx * lpx) + (lpy * lpy) + (lpz * lpz));
			lpx /= light_dst;
			lpy /= light_dst;
			lpz /= light_dst;
			light_dst = light_dst * light_dst;
			
			let n_dot_l = n.x * lpx + n.y * lpy + n.z * lpz;
			let lambert = max(n_dot_l, 0);
			
			let specular = 0;
			if (lambert > 0) {
				specular = pow(max(norm(n_dot_l, 0, 1), 0), 2*spec_mul);
			}
			
			//let det = details[x + y * width];
			noiseDetail(3, 0.75);
			let det = noise(nx * 4 + xmotion/4, ny * 4 + ymotion/7)*2;

			let ambient = 0.1;
			let diffuse_color = 180 + n.z * 100;
			let brightness = ceil((n.z * (ambient + lambert * 0.1 / light_dst + specular * 1 / light_dst)) * 8) / 8 * det;

			brightness = pow(brightness, 1.0 / 2.2);
			//brightness_rgb = floor(brightness * 255);
			
			let pa1 = 0.7, pa2 = 0.5, pa3 = 0.5;
			let pb1 = 0.75, pb2 = 0.5, pb3 = 0.5;
			let pc1 = 0.75, pc2 = 0.5, pc3 = 0.5;

			let pdr = 0.5 - det / 10;
			let pdg = 0.35 + n.z / 2;
			let pdb = 0.75 + det / 4 * n.z / 4;
			
			var rf = (pal(n.z, pa1, pb1, pc1, pdr) * brightness * 255);
			var gf = (pal(n.z, pa2, pb2, pc2, pdg) * brightness * 255);
			var bf = (pal(n.z, pa3, pb3, pc3, pdb) * brightness * 255);

/*    // slow
			if (diffuse > 0) {
				fill(diffuse_color, 0.0, brightness, 1);
				rect(x, y, 1, 1);
			}
*/
			pixels[(x + y * width) * 4 + 0] = 255-rf; // inverse can be cool as well
			pixels[(x + y * width) * 4 + 1] = 255-gf;
			pixels[(x + y * width) * 4 + 2] = 255-bf;
		}
	}
	updatePixels();
}

let light_npx = 0;
let light_npy = 0;

let xmotion = 0;
let ymotion = 0;

function draw() {
drawStuff();
	
	light_npx = cos(xmotion)/2;
	light_npy = sin(ymotion)/2;
	
	xmotion += 0.05;
	ymotion += 0.05;	
}"
"1007191","Turbulence","mySketch","// software rendering noise heightfield bumpmap with blinn phong shading
// inverted colors island looking like some cloudy giants

let normals = [];
let details = [];

// https://iquilezles.org/www/articles/palettes/palettes.htm
function pal(t, a, b, c, d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

function setup() {
	createCanvas(600, 600);
	background(100);
	
	colorMode(HSB, 360, 1, 1, 1);
	
	rectMode(CORNER);
	
	noStroke();
	
	background(0);
	
	generateNormals();
}

function generateNormals () {
	for (let y = 0; y < height; y += 1) {
		for (let x = 0; x < width; x += 1) {
			let nx = x / width;
			let ny = y / height;
			
			let npx = x / width * 2 - 1;
			let npy = y / height * 2 - 1;
			
			let scale = 4;
			let offset = 0.05;
			
			noiseDetail(9, 0.6);
			
			let dc = min((1-dist(npx, npy, 0, 0)*0.725), 1);
			
			let n = noise(nx * scale, ny * scale) * dc; // sampled point
			
			let nx0 = noise(nx * scale - offset, ny * scale) * dc; // left
			let nx1 = noise(nx * scale + offset, ny * scale) * dc; // right
			let ny1 = noise(nx * scale, ny * scale + offset) * dc; // top
			let ny0 = noise(nx * scale, ny * scale - offset) * dc; // bottom
			
			let dzdx = (nx1-nx0) / 2;
			let dzdy = (ny1-ny0) / 2;
			
			// vector length
			let len = sqrt((dzdx * dzdx) + (dzdy * dzdy));
			
			// normalize
			dzdx /= len;
			dzdy /= len;
			
			normals[x + y * width] = { x: dzdx, y: dzdy, z: n };
			
			// 2
			noiseDetail(8, 0.5);
			
			let n2 = noise(nx * 2, ny * 16);
			
			details[x + y * width] = n;
			
			//line(x, y, x + -dzdx * 10, y + -dzdy * 10);
		}
	}
	
	drawStuff();
}

function drawStuff() {
	noStroke();
	loadPixels();
	for (let y = floor(random(0, 4)); y < height; y += 4) {
		for (let x = floor(random(0, 4)); x < width; x += 4) {
			let n = normals[x + y * width];
			
			let nx = x / width;
			let ny = y / height;
			
			let npx = x / width * 2 - 1;
			let npy = y / height * 2 - 1;
			
			let spec_mul = 1;
			if (n.z < 0.25) {
				n.x += random(-1, 1) * 0.25;
				n.y += random(-1, 1) * 0.25;
				n.z += 0.05;
				spec_mul *= 2.0;
			}
			
			let light_z_pos = 2; // above
			
			let lpx = light_npx - npx;
			let lpy = light_npy - npy;
			let lpz = light_z_pos - n.z;
			
			let light_dst = sqrt((lpx * lpx) + (lpy * lpy) + (lpz * lpz));
			lpx /= light_dst;
			lpy /= light_dst;
			lpz /= light_dst;
			light_dst = light_dst * light_dst;
			
			let n_dot_l = n.x * lpx + n.y * lpy + n.z * lpz;
			let lambert = max(n_dot_l, 0);
			
			let specular = 0;
			if (lambert > 0) {
				specular = pow(max(norm(n_dot_l, 0, 1), 0), 2*spec_mul);
			}
			
			//let det = details[x + y * width];
			noiseDetail(3, 0.75);
			let det = noise(nx * 4 + xmotion/4, ny * 4 + ymotion/7)*2;

			let ambient = 0.1;
			let diffuse_color = 180 + n.z * 100;
			let brightness = ceil((n.z * (ambient + lambert * 1 / light_dst + specular * 1 / light_dst)) * 8) / 8 * det;

			brightness = pow(brightness, 1.0 / 2.2);
			//brightness_rgb = floor(brightness * 255);
			
			let pa1 = 0.7, pa2 = 0.5, pa3 = 0.5;
			let pb1 = 0.75, pb2 = 0.5, pb3 = 0.5;
			let pc1 = 0.75, pc2 = 0.5, pc3 = 0.5;

			let pdr = 0.5 - det / 10;
			let pdg = 0.35 + n.z / 2;
			let pdb = 0.75 + n.z / 4 * det / 8;
			
			var rf = (pal(n.z, pa1, pb1, pc1, pdr) * brightness * 255);
			var gf = (pal(n.z, pa2, pb2, pc2, pdg) * brightness * 255);
			var bf = (pal(n.z, pa3, pb3, pc3, pdb) * brightness * 255);

/*    // slow
			if (diffuse > 0) {
				fill(diffuse_color, 0.0, brightness, 1);
				rect(x, y, 1, 1);
			}
*/
			pixels[(x + y * width) * 4 + 0] = 255-rf; // inverse can be cool as well
			pixels[(x + y * width) * 4 + 1] = 255-gf;
			pixels[(x + y * width) * 4 + 2] = 255-bf;
		}
	}
	updatePixels();
}

let light_npx = 0;
let light_npy = 0;

let xmotion = 0;
let ymotion = 0;

function draw() {
drawStuff();
	
	light_npx = cos(xmotion)/2;
	light_npy = sin(ymotion)/2;
	
	xmotion += 0.05;
	ymotion += 0.05;	
}"
"1007171","Atoll","mySketch","// software rendering noise heightfield bumpmap with blinn phong shading

let normals = [];
let details = [];

// https://iquilezles.org/www/articles/palettes/palettes.htm
function pal(t, a, b, c, d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

function setup() {
	createCanvas(600, 600);
	background(100);
	
	colorMode(HSB, 360, 1, 1, 1);
	
	rectMode(CORNER);
	
	noStroke();
	
	background(0);
	
	generateNormals();
}

function generateNormals () {
	for (let y = 0; y < height; y += 1) {
		for (let x = 0; x < width; x += 1) {
			let nx = x / width;
			let ny = y / height;
			
			let npx = x / width * 2 - 1;
			let npy = y / height * 2 - 1;
			
			let scale = 6;
			let offset = 0.0005;
			
			noiseDetail(7, 0.35);
			
			let dc = min((dist(npx, npy, 0, 0))*1.5, 1);
			
			let n = noise(nx * scale, ny * scale) * dc; // sampled point
			
			let nx0 = noise(nx * scale - offset, ny * scale) * dc; // left
			let nx1 = noise(nx * scale + offset, ny * scale) * dc; // right
			let ny1 = noise(nx * scale, ny * scale + offset) * dc; // top
			let ny0 = noise(nx * scale, ny * scale - offset) * dc; // bottom
			
			let dzdx = (nx1-nx0) / 2;
			let dzdy = (ny1-ny0) / 2;
			
			// vector length
			let len = sqrt((dzdx * dzdx) + (dzdy * dzdy));
			
			// normalize
			dzdx /= len;
			dzdy /= len;
			
			normals[x + y * width] = { x: dzdx, y: dzdy, z: n };
			
			// 2
			noiseDetail(8, 0.5);
			
			let n2 = noise(nx * 2, ny * 16);
			
			details[x + y * width] = n;
			
			//line(x, y, x + -dzdx * 10, y + -dzdy * 10);
		}
	}
	
	drawStuff();
}

function drawStuff() {
	noStroke();
	loadPixels();
	for (let y = floor(random(0, 4)); y < height; y += 4) {
		for (let x = floor(random(0, 4)); x < width; x += 4) {
			let n = normals[x + y * width];
			
			let nx = x / width;
			let ny = y / height;
			
			let npx = x / width * 2 - 1;
			let npy = y / height * 2 - 1;
			
			let spec_mul = 1;
			if (n.z < 0.25) {
				n.x += random(-1, 1) * 0.5;
				n.y += random(-1, 1) * 0.5;
				n.z += 0.05;
				spec_mul *= 2.0;
			}
			
			let light_z_pos = 1.75; // above
			
			let lpx = light_npx - npx;
			let lpy = light_npy - npy;
			let lpz = light_z_pos - n.z;
			
			let light_dst = sqrt((lpx * lpx) + (lpy * lpy) + (lpz * lpz));
			lpx /= light_dst;
			lpy /= light_dst;
			lpz /= light_dst;
			light_dst = light_dst * light_dst;
			
			let n_dot_l = n.x * lpx + n.y * lpy + n.z * lpz;
			let lambert = max(n_dot_l, 0);
			
			let specular = 0;
			if (lambert > 0) {
				specular = pow(max(norm(n_dot_l, 0, 1), 0), 8*spec_mul);
			}
			
			//let det = details[x + y * width];
			noiseDetail(3, 0.75);
			let det = noise(nx * 4 + xmotion/4, ny * 4 + ymotion/7)*2;

			let ambient = 0.1;
			let diffuse_color = 180 + n.z * 100;
			let brightness = ceil((n.z * (ambient + lambert * 2 / light_dst + specular * 2 / light_dst)) * 8) / 8 * det;

			brightness = pow(brightness, 1.0 / 2.2);
			//brightness_rgb = floor(brightness * 255);
			
			let pa1 = 0.7, pa2 = 0.5, pa3 = 0.5;
			let pb1 = 0.75, pb2 = 0.5, pb3 = 0.5;
			let pc1 = 0.75, pc2 = 0.5, pc3 = 0.5;

			let pdr = 0.5 - det / 10;
			let pdg = 0.55 + n.z / 4;
			let pdb = 0.75 + n.z / 4 * det / 8;
			
			var rf = (pal(n.z, pa1, pb1, pc1, pdr) * brightness * 255);
			var gf = (pal(n.z, pa2, pb2, pc2, pdg) * brightness * 255);
			var bf = (pal(n.z, pa3, pb3, pc3, pdb) * brightness * 255);

/*    // slow
			if (diffuse > 0) {
				fill(diffuse_color, 0.0, brightness, 1);
				rect(x, y, 1, 1);
			}
*/
			pixels[(x + y * width) * 4 + 0] = rf;
			pixels[(x + y * width) * 4 + 1] = gf;
			pixels[(x + y * width) * 4 + 2] = bf;
		}
	}
	updatePixels();
}

let light_npx = 0;
let light_npy = 0;

let xmotion = 0;
let ymotion = 0;

function draw() {
drawStuff();
	
	light_npx = cos(xmotion)/2;
	light_npy = sin(ymotion)/2;
	
	xmotion += 0.05;
	ymotion += 0.05;	
}"
"1007171","Atoll","mySketch","// software rendering noise heightfield bumpmap (normal map) with blinn phong shading

let normals = [];
let details = [];

// https://iquilezles.org/www/articles/palettes/palettes.htm
function pal(t, a, b, c, d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

function setup() {
	createCanvas(600, 600);
	background(100);
	
	colorMode(HSB, 360, 1, 1, 1);
	
	rectMode(CORNER);
	
	noStroke();
	
	background(0);
	
	generateNormals();
}

function generateNormals () {
	for (let y = 0; y < height; y += 1) {
		for (let x = 0; x < width; x += 1) {
			let nx = x / width;
			let ny = y / height;
			
			let npx = x / width * 2 - 1;
			let npy = y / height * 2 - 1;
			
			let scale = 6;
			let offset = 0.0005;
			
			noiseDetail(7, 0.35);
			
			let dc = min((dist(npx, npy, 0, 0))*1.5, 1);
			
			let n = noise(nx * scale, ny * scale) * dc; // sampled point
			
			let nx0 = noise(nx * scale - offset, ny * scale) * dc; // left
			let nx1 = noise(nx * scale + offset, ny * scale) * dc; // right
			let ny1 = noise(nx * scale, ny * scale + offset) * dc; // top
			let ny0 = noise(nx * scale, ny * scale - offset) * dc; // bottom
			
			let dzdx = (nx1-nx0) / 2;
			let dzdy = (ny1-ny0) / 2;
			
			// vector length
			let len = sqrt((dzdx * dzdx) + (dzdy * dzdy));
			
			// normalize
			dzdx /= len;
			dzdy /= len;
			
			normals[x + y * width] = { x: dzdx, y: dzdy, z: n };
			
			// 2
			noiseDetail(8, 0.5);
			
			let n2 = noise(nx * 2, ny * 16);
			
			details[x + y * width] = n;
			
			//line(x, y, x + -dzdx * 10, y + -dzdy * 10);
		}
	}
	
	drawStuff();
}

function drawStuff() {
	noStroke();
	loadPixels();
	for (let y = floor(random(0, 4)); y < height; y += 4) {
		for (let x = floor(random(0, 4)); x < width; x += 4) {
			let n = normals[x + y * width];
			
			let nx = x / width;
			let ny = y / height;
			
			let npx = x / width * 2 - 1;
			let npy = y / height * 2 - 1;
			
			let spec_mul = 1;
			if (n.z < 0.25) {
				n.x += random(-1, 1) * 0.5;
				n.y += random(-1, 1) * 0.5;
				n.z += 0.05;
				spec_mul *= 2.0;
			}
			
			let light_z_pos = 1.75; // above
			
			let lpx = light_npx - npx;
			let lpy = light_npy - npy;
			let lpz = light_z_pos - n.z;
			
			let light_dst = sqrt((lpx * lpx) + (lpy * lpy) + (lpz * lpz));
			lpx /= light_dst;
			lpy /= light_dst;
			lpz /= light_dst;
			light_dst = light_dst * light_dst;
			
			let n_dot_l = n.x * lpx + n.y * lpy + n.z * lpz;
			let lambert = max(n_dot_l, 0);
			
			let specular = 0;
			if (lambert > 0) {
				specular = pow(max(norm(n_dot_l, 0, 1), 0), 8*spec_mul);
			}
			
			//let det = details[x + y * width];
			noiseDetail(3, 0.75);
			let det = noise(nx * 4 + xmotion/4, ny * 4 + ymotion/7)*2;

			let ambient = 0.1;
			let diffuse_color = 180 + n.z * 100;
			let brightness = ceil((n.z * (ambient + lambert * 2 / light_dst + specular * 2 / light_dst)) * 8) / 8 * det;

			brightness = pow(brightness, 1.0 / 2.2);
			//brightness_rgb = floor(brightness * 255);
			
			let pa1 = 0.7, pa2 = 0.5, pa3 = 0.5;
			let pb1 = 0.75, pb2 = 0.5, pb3 = 0.5;
			let pc1 = 0.75, pc2 = 0.5, pc3 = 0.5;

			let pdr = 0.5 - det / 10;
			let pdg = 0.55 + n.z / 4;
			let pdb = 0.75 + n.z / 4 * det / 8;
			
			var rf = (pal(n.z, pa1, pb1, pc1, pdr) * brightness * 255);
			var gf = (pal(n.z, pa2, pb2, pc2, pdg) * brightness * 255);
			var bf = (pal(n.z, pa3, pb3, pc3, pdb) * brightness * 255);

/*    // slow
			if (diffuse > 0) {
				fill(diffuse_color, 0.0, brightness, 1);
				rect(x, y, 1, 1);
			}
*/
			pixels[(x + y * width) * 4 + 0] = rf;
			pixels[(x + y * width) * 4 + 1] = gf;
			pixels[(x + y * width) * 4 + 2] = bf;
		}
	}
	updatePixels();
}

let light_npx = 0;
let light_npy = 0;

let xmotion = 0;
let ymotion = 0;

function draw() {
drawStuff();
	
	light_npx = cos(xmotion)/2;
	light_npy = sin(ymotion)/2;
	
	xmotion += 0.05;
	ymotion += 0.05;	
}"
"1007110","Soft normal mapping noise","mySketch","// software rendering noise heightfield bumpmap with blinn phong shading

let normals = [];

function setup() {
	createCanvas(600, 600);
	background(100);
	
	noiseDetail(8, 0.4);
	
	colorMode(HSB, 360, 1, 1, 1);
	
	rectMode(CORNER);
	
	noStroke();
	
	background(0);
	
	generateNormals();
}

function generateNormals () {
	for (let y = 0; y < height; y += 1) {
		for (let x = 0; x < width; x += 1) {
			let nx = x / width;
			let ny = y / height;
			
			let scale = 8;
			let offset = 0.0005;
			
			let n = noise(nx * scale, ny * scale); // sampled point
			
			let nx0 = noise(nx * scale - offset, ny * scale); // left
			let nx1 = noise(nx * scale + offset, ny * scale); // right
			let ny1 = noise(nx * scale, ny * scale + offset); // top
			let ny0 = noise(nx * scale, ny * scale - offset); // bottom
			
			let dzdx= (nx1-nx0) / 2;
			let dzdy= (ny1-ny0) / 2;
			
			// vector length
			let len = sqrt((dzdx * dzdx) + (dzdy * dzdy));
			
			// normalize
			dzdx /= len;
			dzdy /= len;
			
			normals[x + y * width] = { x: dzdx, y: dzdy, z: n };
			
			//line(x, y, x + -dzdx * 10, y + -dzdy * 10);
		}
	}
	
	drawStuff();
}

function drawStuff() {
	noStroke();
	loadPixels();
	for (let y = floor(random(0, 4)); y < height; y += 4) {
		for (let x = floor(random(0, 4)); x < width; x += 4) {
			let n = normals[x + y * width];
			
			let npx = x / width * 2 - 1;
			let npy = y / height * 2 - 1;
			
			let lpx = light_npx - npx;
			let lpy = light_npy - npy;
			let lpz = 2.5 - n.z;
			
			let light_dst = sqrt((lpx * lpx) + (lpy * lpy) + (lpz * lpz));
			lpx /= light_dst;
			lpy /= light_dst;
			lpz /= light_dst;
			light_dst = light_dst * light_dst;
			
			let n_dot_l = n.x * lpx + n.y * lpy + n.z * lpz;
			let lambert = max(n_dot_l, 0);
			
			let specular = 0;
			if (lambert > 0) {
				specular = pow(max(norm(n_dot_l, 0, 1), 0), 16);
			}
/*
			let blinnPhong = pow(max(min(norm(n_dot_l, 0, 1), 1), 0), 1);
*/			
			let diffuse_color = 180 + n.z * 100;
			let brightness = n.z * (0.05 + lambert * 1 / light_dst + specular * 1 / light_dst);//intensity * 1 / light_dst;

			brightness = pow(brightness, 1.0 / 2.2);
			brightness_rgb = floor(brightness * 255);
			//if (diffuse > 0) {
				//fill(diffuse_color, 0.0, brightness, 1);
				//rect(x, y, 1, 1);
			//}
			pixels[(x + y * width) * 4 + 0] = brightness_rgb;
			pixels[(x + y * width) * 4 + 1] = brightness_rgb;
			pixels[(x + y * width) * 4 + 2] = brightness_rgb;
		}
	}
	updatePixels();
}

let light_npx = 0;
let light_npy = 0;

let xmotion = 0;
let ymotion = 0;

function draw() {
drawStuff();
	
	light_npx = cos(xmotion)/2;
	light_npy = sin(ymotion)/2;
	
	xmotion += 0.05;
	ymotion += 0.05;
/*
  // display noise map
	for (let y = 0; y < 800; y += 16) {
		for (let x = 0; x < 800; x += 16) {
			let nx = x / 800;
			let ny = y / 800;
			
			let n = noise(nx * 4, ny * 4);
			
			fill(0, 0, pow(n, 1.25), 1);
			rect(x, y, 16, 16);
		}
	}
*/
	
	//stroke(0, 0.5, 1, 1);
	
}"
"1007110","Soft normal mapping noise","mySketch","// software rendering noise heightfield bumpmap with blinn phong shading

let normals = [];

function setup() {
	createCanvas(600, 600);
	background(100);
	
	noiseDetail(8, 0.4);
	
	colorMode(HSB, 360, 1, 1, 1);
	
	rectMode(CORNER);
	
	noStroke();
	
	background(0);
	
	generateNormals();
}

function generateNormals () {
	for (let y = 0; y < height; y += 1) {
		for (let x = 0; x < width; x += 1) {
			let nx = x / width;
			let ny = y / height;
			
			let scale = 8;
			let offset = 0.0005;
			
			let n = noise(nx * scale, ny * scale); // sampled point
			
			let nx0 = noise(nx * scale - offset, ny * scale); // left
			let nx1 = noise(nx * scale + offset, ny * scale); // right
			let ny1 = noise(nx * scale, ny * scale + offset); // top
			let ny0 = noise(nx * scale, ny * scale - offset); // bottom
			
			let dzdx= (nx1-nx0) / 2;
			let dzdy= (ny1-ny0) / 2;
			
			// vector length
			let len = sqrt((dzdx * dzdx) + (dzdy * dzdy));
			
			// normalize
			dzdx /= len;
			dzdy /= len;
			
			normals[x + y * width] = { x: dzdx, y: dzdy, z: n };
			
			//line(x, y, x + -dzdx * 10, y + -dzdy * 10);
		}
	}
	
	drawStuff();
}

function drawStuff() {
	noStroke();
	loadPixels();
	for (let y = floor(random(0, 4)); y < height; y += 4) {
		for (let x = floor(random(0, 4)); x < width; x += 4) {
			let n = normals[x + y * width];
			
			let npx = x / width * 2 - 1;
			let npy = y / height * 2 - 1;
			
			let lpx = light_npx - npx;
			let lpy = light_npy - npy;
			let lpz = 2 - n.z;
			
			let light_dst = sqrt((lpx * lpx) + (lpy * lpy) + (lpz * lpz));
			lpx /= light_dst;
			lpy /= light_dst;
			lpz /= light_dst;
			light_dst = light_dst * light_dst;
			
			let n_dot_l = n.x * lpx + n.y * lpy + n.z * lpz;
			let lambert = max(n_dot_l, 0);
			
			let specular = 0;
			if (lambert > 0) {
				specular = pow(max(norm(n_dot_l, 0, 1), 0), 8);
			}
/*
			let blinnPhong = pow(max(min(norm(n_dot_l, 0, 1), 1), 0), 1);
*/			
			let diffuse_color = 180 + n.z * 100;
			let brightness = n.z * (0.025 + lambert * 1 / light_dst + specular * 1 / light_dst);//intensity * 1 / light_dst;

			brightness = pow(brightness, 1.0 / 2.2);
			brightness_rgb = floor(brightness * 255);
			//if (diffuse > 0) {
				//fill(diffuse_color, 0.0, brightness, 1);
				//rect(x, y, 1, 1);
			//}
			pixels[(x + y * width) * 4 + 0] = brightness_rgb;
			pixels[(x + y * width) * 4 + 1] = brightness_rgb;
			pixels[(x + y * width) * 4 + 2] = brightness_rgb;
		}
	}
	updatePixels();
}

let light_npx = 0;
let light_npy = 0;

let xmotion = 0;
let ymotion = 0;

function draw() {
drawStuff();
	
	light_npx = cos(xmotion)/2;
	light_npy = sin(ymotion)/2;
	
	xmotion += 0.05;
	ymotion += 0.05;
/*
  // display noise map
	for (let y = 0; y < 800; y += 16) {
		for (let x = 0; x < 800; x += 16) {
			let nx = x / 800;
			let ny = y / 800;
			
			let n = noise(nx * 4, ny * 4);
			
			fill(0, 0, pow(n, 1.25), 1);
			rect(x, y, 16, 16);
		}
	}
*/
	
	//stroke(0, 0.5, 1, 1);
	
}"
"1007110","Soft normal mapping noise","mySketch","// software rendering noise heightfield bumpmap with blinn phong shading

let normals = [];

function setup() {
	createCanvas(600, 600);
	background(100);
	
	noiseDetail(8, 0.4);
	
	colorMode(HSB, 360, 1, 1, 1);
	
	rectMode(CORNER);
	
	noStroke();
	
	background(0);
	
	generateNormals();
}

function generateNormals () {
	for (let y = 0; y < height; y += 1) {
		for (let x = 0; x < width; x += 1) {
			let nx = x / width;
			let ny = y / height;
			
			let scale = 8;
			let offset = 0.0005;
			
			let n = noise(nx * scale, ny * scale); // sampled point
			
			let nx0 = noise(nx * scale - offset, ny * scale); // left
			let nx1 = noise(nx * scale + offset, ny * scale); // right
			let ny1 = noise(nx * scale, ny * scale + offset); // top
			let ny0 = noise(nx * scale, ny * scale - offset); // bottom
			
			let dzdx= (nx1-nx0) / 2;
			let dzdy= (ny1-ny0) / 2;
			
			// vector length
			let len = sqrt((dzdx * dzdx) + (dzdy * dzdy));
			
			// normalize
			dzdx /= len;
			dzdy /= len;
			
			normals[x + y * width] = { x: dzdx, y: dzdy, z: n };
			
			//line(x, y, x + -dzdx * 10, y + -dzdy * 10);
		}
	}
	
	drawStuff();
}

function drawStuff() {
	noStroke();
	loadPixels();
	for (let y = floor(random(0, 4)); y < height; y += 4) {
		for (let x = floor(random(0, 4)); x < width; x += 4) {
			let n = normals[x + y * width];
			
			let npx = x / width * 2 - 1;
			let npy = y / height * 2 - 1;
			
			let lpx = light_npx - npx;
			let lpy = light_npy - npy;
			let lpz = 2 - n.z;
			
			let light_dst = sqrt((lpx * lpx) + (lpy * lpy) + (lpz * lpz));
			lpx /= light_dst;
			lpy /= light_dst;
			lpz /= light_dst;
			light_dst = light_dst * light_dst;
			
			let n_dot_l = n.x * lpx + n.y * lpy + n.z * lpz;
			let lambert = max(n_dot_l, 0);
			
			let specular = 0;
			if (lambert > 0) {
				specular = pow(max(norm(n_dot_l, 0, 1), 0), 8);
			}

			let ambient = 0.025;
			let diffuse_color = 180 + n.z * 100;
			let brightness = n.z * (ambient + lambert * 1 / light_dst + specular * 1 / light_dst);//intensity * 1 / light_dst;

			brightness = pow(brightness, 1.0 / 2.2);
			brightness_rgb = floor(brightness * 255);

/*    // slow
			if (diffuse > 0) {
				fill(diffuse_color, 0.0, brightness, 1);
				rect(x, y, 1, 1);
			}
*/
			pixels[(x + y * width) * 4 + 0] = brightness_rgb;
			pixels[(x + y * width) * 4 + 1] = brightness_rgb;
			pixels[(x + y * width) * 4 + 2] = brightness_rgb;
		}
	}
	updatePixels();
}

let light_npx = 0;
let light_npy = 0;

let xmotion = 0;
let ymotion = 0;

function draw() {
drawStuff();
	
	light_npx = cos(xmotion)/2;
	light_npy = sin(ymotion)/2;
	
	xmotion += 0.05;
	ymotion += 0.05;
/*
  // display noise map
	for (let y = 0; y < 800; y += 16) {
		for (let x = 0; x < 800; x += 16) {
			let nx = x / 800;
			let ny = y / 800;
			
			let n = noise(nx * 4, ny * 4);
			
			fill(0, 0, pow(n, 1.25), 1);
			rect(x, y, 16, 16);
		}
	}
*/
	
	//stroke(0, 0.5, 1, 1);
	
}"
"1007110","Soft normal mapping noise","mySketch","// software rendering noise heightfield bumpmap with blinn phong shading

let normals = [];

function setup() {
	createCanvas(600, 600);
	background(100);
	
	noiseDetail(8, 0.4);
	
	colorMode(HSB, 360, 1, 1, 1);
	
	rectMode(CORNER);
	
	noStroke();
	
	background(0);
	
	generateNormals();
}

function generateNormals () {
	for (let y = 0; y < height; y += 1) {
		for (let x = 0; x < width; x += 1) {
			let nx = x / width;
			let ny = y / height;
			
			let scale = 8;
			let offset = 0.0005;
			
			let n = noise(nx * scale, ny * scale); // sampled point
			
			let nx0 = noise(nx * scale - offset, ny * scale); // left
			let nx1 = noise(nx * scale + offset, ny * scale); // right
			let ny1 = noise(nx * scale, ny * scale + offset); // top
			let ny0 = noise(nx * scale, ny * scale - offset); // bottom
			
			let dzdx= (nx1-nx0) / 2;
			let dzdy= (ny1-ny0) / 2;
			
			// vector length
			let len = sqrt((dzdx * dzdx) + (dzdy * dzdy));
			
			// normalize
			dzdx /= len;
			dzdy /= len;
			
			normals[x + y * width] = { x: dzdx, y: dzdy, z: n };
			
			//line(x, y, x + -dzdx * 10, y + -dzdy * 10);
		}
	}
	
	drawStuff();
}

function drawStuff() {
	noStroke();
	loadPixels();
	for (let y = floor(random(0, 4)); y < height; y += 4) {
		for (let x = floor(random(0, 4)); x < width; x += 4) {
			let n = normals[x + y * width];
			
			let npx = x / width * 2 - 1;
			let npy = y / height * 2 - 1;
			
			let lpx = light_npx - npx;
			let lpy = light_npy - npy;
			let lpz = 2 - n.z;
			
			let light_dst = sqrt((lpx * lpx) + (lpy * lpy) + (lpz * lpz));
			lpx /= light_dst;
			lpy /= light_dst;
			lpz /= light_dst;
			light_dst = light_dst * light_dst;
			
			let n_dot_l = n.x * lpx + n.y * lpy + n.z * lpz;
			let lambert = max(n_dot_l, 0);
			
			let specular = 0;
			if (lambert > 0) {
				specular = pow(max(norm(n_dot_l, 0, 1), 0), 8);
			}

			let ambient = 0.025;
			let diffuse_color = 180 + n.z * 100;
			let brightness = n.z * (ambient + lambert * 1 / light_dst + specular * 1 / light_dst);

			brightness = pow(brightness, 1.0 / 2.2);
			brightness_rgb = floor(brightness * 255);

/*    // slow
			if (diffuse > 0) {
				fill(diffuse_color, 0.0, brightness, 1);
				rect(x, y, 1, 1);
			}
*/
			pixels[(x + y * width) * 4 + 0] = brightness_rgb;
			pixels[(x + y * width) * 4 + 1] = brightness_rgb;
			pixels[(x + y * width) * 4 + 2] = brightness_rgb;
		}
	}
	updatePixels();
}

let light_npx = 0;
let light_npy = 0;

let xmotion = 0;
let ymotion = 0;

function draw() {
drawStuff();
	
	light_npx = cos(xmotion)/2;
	light_npy = sin(ymotion)/2;
	
	xmotion += 0.05;
	ymotion += 0.05;
/*
  // display noise map
	for (let y = 0; y < 800; y += 16) {
		for (let x = 0; x < 800; x += 16) {
			let nx = x / 800;
			let ny = y / 800;
			
			let n = noise(nx * 4, ny * 4);
			
			fill(0, 0, pow(n, 1.25), 1);
			rect(x, y, 16, 16);
		}
	}
*/
	
	//stroke(0, 0.5, 1, 1);
	
}"
"1007110","Soft normal mapping noise","mySketch","// software rendering noise heightfield bumpmap with blinn phong shading

let normals = [];

function setup() {
	createCanvas(600, 600);
	background(100);
	
	noiseDetail(8, 0.4);
	
	colorMode(HSB, 360, 1, 1, 1);
	
	rectMode(CORNER);
	
	noStroke();
	
	background(0);
	
	generateNormals();
}

function generateNormals () {
	for (let y = 0; y < height; y += 1) {
		for (let x = 0; x < width; x += 1) {
			let nx = x / width;
			let ny = y / height;
			
			let scale = 8;
			let offset = 0.0005;
			
			let n = noise(nx * scale, ny * scale); // sampled point
			
			let nx0 = noise(nx * scale - offset, ny * scale); // left
			let nx1 = noise(nx * scale + offset, ny * scale); // right
			let ny1 = noise(nx * scale, ny * scale + offset); // top
			let ny0 = noise(nx * scale, ny * scale - offset); // bottom
			
			let dzdx= (nx1-nx0) / 2;
			let dzdy= (ny1-ny0) / 2;
			
			// vector length
			let len = sqrt((dzdx * dzdx) + (dzdy * dzdy));
			
			// normalize
			dzdx /= len;
			dzdy /= len;
			
			normals[x + y * width] = { x: dzdx, y: dzdy, z: n };
			
			//line(x, y, x + -dzdx * 10, y + -dzdy * 10);
		}
	}
	
	drawStuff();
}

function drawStuff() {
	noStroke();
	loadPixels();
	for (let y = floor(random(0, 4)); y < height; y += 4) {
		for (let x = floor(random(0, 4)); x < width; x += 4) {
			let n = normals[x + y * width];
			
			let npx = x / width * 2 - 1;
			let npy = y / height * 2 - 1;
			
			let light_z_pos = 2; // above
			
			let lpx = light_npx - npx;
			let lpy = light_npy - npy;
			let lpz = light_z_pos - n.z;
			
			let light_dst = sqrt((lpx * lpx) + (lpy * lpy) + (lpz * lpz));
			lpx /= light_dst;
			lpy /= light_dst;
			lpz /= light_dst;
			light_dst = light_dst * light_dst;
			
			let n_dot_l = n.x * lpx + n.y * lpy + n.z * lpz;
			let lambert = max(n_dot_l, 0);
			
			let specular = 0;
			if (lambert > 0) {
				specular = pow(max(norm(n_dot_l, 0, 1), 0), 8);
			}

			let ambient = 0.025;
			let diffuse_color = 180 + n.z * 100;
			let brightness = n.z * (ambient + lambert * 1 / light_dst + specular * 1 / light_dst);

			brightness = pow(brightness, 1.0 / 2.2);
			brightness_rgb = floor(brightness * 255);

/*    // slow
			if (diffuse > 0) {
				fill(diffuse_color, 0.0, brightness, 1);
				rect(x, y, 1, 1);
			}
*/
			pixels[(x + y * width) * 4 + 0] = brightness_rgb;
			pixels[(x + y * width) * 4 + 1] = brightness_rgb;
			pixels[(x + y * width) * 4 + 2] = brightness_rgb;
		}
	}
	updatePixels();
}

let light_npx = 0;
let light_npy = 0;

let xmotion = 0;
let ymotion = 0;

function draw() {
drawStuff();
	
	light_npx = cos(xmotion)/2;
	light_npy = sin(ymotion)/2;
	
	xmotion += 0.05;
	ymotion += 0.05;
/*
  // display noise map
	for (let y = 0; y < 800; y += 16) {
		for (let x = 0; x < 800; x += 16) {
			let nx = x / 800;
			let ny = y / 800;
			
			let n = noise(nx * 4, ny * 4);
			
			fill(0, 0, pow(n, 1.25), 1);
			rect(x, y, 16, 16);
		}
	}
*/
	
	//stroke(0, 0.5, 1, 1);
	
}"
"1007110","Soft normal mapping noise","mySketch","// software rendering noise heightfield bumpmap with blinn phong shading

let normals = [];

function setup() {
	createCanvas(600, 600);
	background(100);
	
	noiseDetail(8, 0.4);
	
	colorMode(HSB, 360, 1, 1, 1);
	
	rectMode(CORNER);
	
	noStroke();
	
	background(0);
	
	generateNormals();
}

function generateNormals () {
	for (let y = 0; y < height; y += 1) {
		for (let x = 0; x < width; x += 1) {
			let nx = x / width;
			let ny = y / height;
			
			let scale = 8;
			let offset = 0.0005;
			
			let n = noise(nx * scale, ny * scale); // sampled point
			
			let nx0 = noise(nx * scale - offset, ny * scale); // left
			let nx1 = noise(nx * scale + offset, ny * scale); // right
			let ny1 = noise(nx * scale, ny * scale + offset); // top
			let ny0 = noise(nx * scale, ny * scale - offset); // bottom
			
			let dzdx= (nx1-nx0) / 2;
			let dzdy= (ny1-ny0) / 2;
			
			// vector length
			let len = sqrt((dzdx * dzdx) + (dzdy * dzdy));
			
			// normalize
			dzdx /= len;
			dzdy /= len;
			
			normals[x + y * width] = { x: dzdx, y: dzdy, z: n };
			
			//line(x, y, x + -dzdx * 10, y + -dzdy * 10);
		}
	}
	
	drawStuff();
}

function drawStuff() {
	noStroke();
	loadPixels();
	for (let y = floor(random(0, 4)); y < height; y += 4) {
		for (let x = floor(random(0, 4)); x < width; x += 4) {
			let n = normals[x + y * width];
			
			let npx = x / width * 2 - 1;
			let npy = y / height * 2 - 1;
			
			let light_z_pos = 2; // above
			
			let lpx = light_npx - npx;
			let lpy = light_npy - npy;
			let lpz = light_z_pos - n.z;
			
			let light_dst = sqrt((lpx * lpx) + (lpy * lpy) + (lpz * lpz));
			lpx /= light_dst;
			lpy /= light_dst;
			lpz /= light_dst;
			light_dst = light_dst * light_dst;
			
			let n_dot_l = n.x * lpx + n.y * lpy + n.z * lpz;
			let lambert = max(n_dot_l, 0);
			
			let specular = 0;
			if (lambert > 0) {
				specular = pow(max(norm(n_dot_l, 0, 1), 0), 8);
			}

			let ambient = 0.025;
			let diffuse_color = 180 + n.z * 100;
			let brightness = n.z * (ambient + lambert * 1 / light_dst + specular * 1 / light_dst);

			brightness = pow(brightness, 1.0 / 2.2);
			brightness_rgb = floor(brightness * 255);

/*    // slow
			if (diffuse > 0) {
				fill(diffuse_color, 0.0, brightness, 1);
				rect(x, y, 1, 1);
			}
*/
			pixels[(x + y * width) * 4 + 0] = brightness_rgb;
			pixels[(x + y * width) * 4 + 1] = brightness_rgb;
			pixels[(x + y * width) * 4 + 2] = brightness_rgb;
		}
	}
	updatePixels();
}

let light_npx = 0;
let light_npy = 0;

let xmotion = 0;
let ymotion = 0;

function draw() {
drawStuff();
	
	light_npx = cos(xmotion)/2;
	light_npy = sin(ymotion)/2;
	
	xmotion += 0.05;
	ymotion += 0.05;	
}"
"1007110","Soft normal mapping noise","mySketch","// software rendering noise heightfield bumpmap with blinn phong shading

let normals = [];

function setup() {
	createCanvas(600, 600);
	background(100);
	
	noiseDetail(8, 0.4);
	
	colorMode(HSB, 360, 1, 1, 1);
	
	rectMode(CORNER);
	
	noStroke();
	
	background(0);
	
	generateNormals();
}

function generateNormals () {
	for (let y = 0; y < height; y += 1) {
		for (let x = 0; x < width; x += 1) {
			let nx = x / width;
			let ny = y / height;
			
			let scale = 8;
			let offset = 0.0005;
			
			let n = noise(nx * scale, ny * scale); // sampled point
			
			let nx0 = noise(nx * scale - offset, ny * scale); // left
			let nx1 = noise(nx * scale + offset, ny * scale); // right
			let ny1 = noise(nx * scale, ny * scale + offset); // top
			let ny0 = noise(nx * scale, ny * scale - offset); // bottom
			
			let dzdx= (nx1-nx0) / 2;
			let dzdy= (ny1-ny0) / 2;
			
			// vector length
			let len = sqrt((dzdx * dzdx) + (dzdy * dzdy));
			
			// normalize
			dzdx /= len;
			dzdy /= len;
			
			normals[x + y * width] = { x: dzdx, y: dzdy, z: n };
			
			//line(x, y, x + -dzdx * 10, y + -dzdy * 10);
		}
	}
	
	drawStuff();
}

function drawStuff() {
	noStroke();
	loadPixels();
	for (let y = floor(random(0, 4)); y < height; y += 4) {
		for (let x = floor(random(0, 4)); x < width; x += 4) {
			let n = normals[x + y * width];
			
			let npx = x / width * 2 - 1;
			let npy = y / height * 2 - 1;
			
			let light_z_pos = 2; // above
			
			let lpx = light_npx - npx;
			let lpy = light_npy - npy;
			let lpz = light_z_pos - n.z;
			
			let light_dst = sqrt((lpx * lpx) + (lpy * lpy) + (lpz * lpz));
			lpx /= light_dst;
			lpy /= light_dst;
			lpz /= light_dst;
			light_dst = light_dst * light_dst;
			
			let n_dot_l = n.x * lpx + n.y * lpy + n.z * lpz;
			let lambert = max(n_dot_l, 0);
			
			let specular = 0;
			if (lambert > 0) {
				specular = pow(max(norm(n_dot_l, 0, 1), 0), 8);
			}

			let ambient = 0.025;
			let diffuse_color = 180 + n.z * 100;
			let brightness = n.z * (ambient + lambert * 1 / light_dst + specular * 1 / light_dst);

			brightness = pow(brightness, 1.0 / 2.2);
			brightness_rgb = floor(brightness * 255);

/*    // slow
			if (diffuse > 0) {
				fill(diffuse_color, 0.0, brightness, 1);
				rect(x, y, 1, 1);
			}
*/
			pixels[(x + y * width) * 4 + 0] = brightness_rgb;
			pixels[(x + y * width) * 4 + 1] = brightness_rgb;
			pixels[(x + y * width) * 4 + 2] = brightness_rgb;
		}
	}
	updatePixels();
}

let light_npx = 0;
let light_npy = 0;

let xmotion = 0;
let ymotion = 0;

function draw() {
drawStuff();
	
	light_npx = cos(xmotion)/2;
	light_npy = sin(ymotion)/2;
	
	xmotion += 0.05;
	ymotion += 0.05;	
}"
"1007110","Soft normal mapping noise","mySketch","// software rendering noise heightfield bumpmap with blinn phong shading

let normals = [];
let details = [];

// https://iquilezles.org/www/articles/palettes/palettes.htm
function pal(t, a, b, c, d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

function setup() {
	createCanvas(600, 600);
	background(100);
	
	colorMode(HSB, 360, 1, 1, 1);
	
	rectMode(CORNER);
	
	noStroke();
	
	background(0);
	
	generateNormals();
}

function generateNormals () {
	for (let y = 0; y < height; y += 1) {
		for (let x = 0; x < width; x += 1) {
			let nx = x / width;
			let ny = y / height;
			
			let scale = 8;
			let offset = 0.0005;
			
			noiseDetail(7, 0.35);
			
			let n = noise(nx * scale, ny * scale); // sampled point
			
			let nx0 = noise(nx * scale - offset, ny * scale); // left
			let nx1 = noise(nx * scale + offset, ny * scale); // right
			let ny1 = noise(nx * scale, ny * scale + offset); // top
			let ny0 = noise(nx * scale, ny * scale - offset); // bottom
			
			let dzdx = (nx1-nx0) / 2;
			let dzdy = (ny1-ny0) / 2;
			
			// vector length
			let len = sqrt((dzdx * dzdx) + (dzdy * dzdy));
			
			// normalize
			dzdx /= len;
			dzdy /= len;
			
			normals[x + y * width] = { x: dzdx, y: dzdy, z: n };
			
			// 2
			noiseDetail(8, 0.5);
			
			let n2 = noise(nx * 16, ny * 16);
			
			details[x + y * width] = n;
			
			//line(x, y, x + -dzdx * 10, y + -dzdy * 10);
		}
	}
	
	drawStuff();
}

function drawStuff() {
	noStroke();
	loadPixels();
	for (let y = floor(random(0, 4)); y < height; y += 4) {
		for (let x = floor(random(0, 4)); x < width; x += 4) {
			let n = normals[x + y * width];
			
			let npx = x / width * 2 - 1;
			let npy = y / height * 2 - 1;
			
			let light_z_pos = 2; // above
			
			let lpx = light_npx - npx;
			let lpy = light_npy - npy;
			let lpz = light_z_pos - n.z;
			
			let light_dst = sqrt((lpx * lpx) + (lpy * lpy) + (lpz * lpz));
			lpx /= light_dst;
			lpy /= light_dst;
			lpz /= light_dst;
			light_dst = light_dst * light_dst;
			
			let n_dot_l = n.x * lpx + n.y * lpy + n.z * lpz;
			let lambert = max(n_dot_l, 0);
			
			let specular = 0;
			if (lambert > 0) {
				specular = pow(max(norm(n_dot_l, 0, 1), 0), 8);
			}

			let ambient = 0.025;
			let diffuse_color = 180 + n.z * 100;
			let brightness = n.z * (ambient + lambert * 2 / light_dst + specular * 2 / light_dst);

			brightness = pow(brightness, 1.0 / 2.2);
			//brightness_rgb = floor(brightness * 255);
			
			let det = details[x + y * width];
			
			let pa1 = 0.7, pa2 = 0.5, pa3 = 0.5;
			let pb1 = 0.75, pb2 = 0.5, pb3 = 0.5;
			let pc1 = 0.75, pc2 = 0.5, pc3 = 0.5;

			let pdr = 0.5 - det / 10;
			let pdg = 0.625 + n.z / 6;
			let pdb = 0.75 + n.z / 4;

			var rf = pal(n.z, pa1, pb1, pc1, pdr) * brightness * 255;
			var gf = pal(n.z, pa2, pb2, pc2, pdg) * brightness * 255;
			var bf = pal(n.z, pa3, pb3, pc3, pdb) * brightness * 255;

/*    // slow
			if (diffuse > 0) {
				fill(diffuse_color, 0.0, brightness, 1);
				rect(x, y, 1, 1);
			}
*/
			pixels[(x + y * width) * 4 + 0] = rf;
			pixels[(x + y * width) * 4 + 1] = gf;
			pixels[(x + y * width) * 4 + 2] = bf;
		}
	}
	updatePixels();
}

let light_npx = 0;
let light_npy = 0;

let xmotion = 0;
let ymotion = 0;

function draw() {
drawStuff();
	
	light_npx = cos(xmotion)/2;
	light_npy = sin(ymotion)/2;
	
	xmotion += 0.05;
	ymotion += 0.05;	
}"
"1007110","Soft normal mapping noise","mySketch","// software rendering noise heightfield bumpmap with blinn phong shading

let normals = [];
let details = [];

// https://iquilezles.org/www/articles/palettes/palettes.htm
function pal(t, a, b, c, d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

function setup() {
	createCanvas(600, 600);
	background(100);
	
	colorMode(HSB, 360, 1, 1, 1);
	
	rectMode(CORNER);
	
	noStroke();
	
	background(0);
	
	generateNormals();
}

function generateNormals () {
	for (let y = 0; y < height; y += 1) {
		for (let x = 0; x < width; x += 1) {
			let nx = x / width;
			let ny = y / height;
			
			let scale = 8;
			let offset = 0.0005;
			
			noiseDetail(7, 0.35);
			
			let n = noise(nx * scale, ny * scale); // sampled point
			
			let nx0 = noise(nx * scale - offset, ny * scale); // left
			let nx1 = noise(nx * scale + offset, ny * scale); // right
			let ny1 = noise(nx * scale, ny * scale + offset); // top
			let ny0 = noise(nx * scale, ny * scale - offset); // bottom
			
			let dzdx = (nx1-nx0) / 2;
			let dzdy = (ny1-ny0) / 2;
			
			// vector length
			let len = sqrt((dzdx * dzdx) + (dzdy * dzdy));
			
			// normalize
			dzdx /= len;
			dzdy /= len;
			
			normals[x + y * width] = { x: dzdx, y: dzdy, z: n };
			
			// 2
			noiseDetail(8, 0.5);
			
			let n2 = noise(nx * 16, ny * 16);
			
			details[x + y * width] = n;
			
			//line(x, y, x + -dzdx * 10, y + -dzdy * 10);
		}
	}
	
	drawStuff();
}

function drawStuff() {
	noStroke();
	loadPixels();
	for (let y = floor(random(0, 4)); y < height; y += 4) {
		for (let x = floor(random(0, 4)); x < width; x += 4) {
			let n = normals[x + y * width];
			
			let npx = x / width * 2 - 1;
			let npy = y / height * 2 - 1;
			
			let light_z_pos = 2; // above
			
			let lpx = light_npx - npx;
			let lpy = light_npy - npy;
			let lpz = light_z_pos - n.z;
			
			let light_dst = sqrt((lpx * lpx) + (lpy * lpy) + (lpz * lpz));
			lpx /= light_dst;
			lpy /= light_dst;
			lpz /= light_dst;
			light_dst = light_dst * light_dst;
			
			let n_dot_l = n.x * lpx + n.y * lpy + n.z * lpz;
			let lambert = max(n_dot_l, 0);
			
			let specular = 0;
			if (lambert > 0) {
				specular = pow(max(norm(n_dot_l, 0, 1), 0), 8);
			}

			let ambient = 0.025;
			let diffuse_color = 180 + n.z * 100;
			let brightness = n.z * (ambient + lambert * 2 / light_dst + specular * 2 / light_dst);

			brightness = pow(brightness, 1.0 / 2.2);
			//brightness_rgb = floor(brightness * 255);
			
			let det = details[x + y * width];
			
			let pa1 = 0.7, pa2 = 0.5, pa3 = 0.5;
			let pb1 = 0.75, pb2 = 0.5, pb3 = 0.5;
			let pc1 = 0.75, pc2 = 0.5, pc3 = 0.5;

			let pdr = 0.5 - det / 10;
			let pdg = 0.625 + n.z / 6;
			let pdb = 0.75 + n.z / 4;

			var rf = pal(n.z, pa1, pb1, pc1, pdr) * brightness * 255;
			var gf = pal(n.z, pa2, pb2, pc2, pdg) * brightness * 255;
			var bf = pal(n.z, pa3, pb3, pc3, pdb) * brightness * 255;

/*    // slow
			if (diffuse > 0) {
				fill(diffuse_color, 0.0, brightness, 1);
				rect(x, y, 1, 1);
			}
*/
			pixels[(x + y * width) * 4 + 0] = rf;
			pixels[(x + y * width) * 4 + 1] = gf;
			pixels[(x + y * width) * 4 + 2] = bf;
		}
	}
	updatePixels();
}

let light_npx = 0;
let light_npy = 0;

let xmotion = 0;
let ymotion = 0;

function draw() {
drawStuff();
	
	light_npx = cos(xmotion)/2;
	light_npy = sin(ymotion)/2;
	
	xmotion += 0.05;
	ymotion += 0.05;	
}"
"1007110","Soft normal mapping noise","mySketch","// software rendering noise heightfield bumpmap with blinn phong shading

let normals = [];
let details = [];

// https://iquilezles.org/www/articles/palettes/palettes.htm
function pal(t, a, b, c, d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

function setup() {
	createCanvas(600, 600);
	background(100);
	
	colorMode(HSB, 360, 1, 1, 1);
	
	rectMode(CORNER);
	
	noStroke();
	
	background(0);
	
	generateNormals();
}

function generateNormals () {
	for (let y = 0; y < height; y += 1) {
		for (let x = 0; x < width; x += 1) {
			let nx = x / width;
			let ny = y / height;
			
			let scale = 8;
			let offset = 0.0005;
			
			noiseDetail(7, 0.35);
			
			let n = noise(nx * scale, ny * scale); // sampled point
			
			let nx0 = noise(nx * scale - offset, ny * scale); // left
			let nx1 = noise(nx * scale + offset, ny * scale); // right
			let ny1 = noise(nx * scale, ny * scale + offset); // top
			let ny0 = noise(nx * scale, ny * scale - offset); // bottom
			
			let dzdx = (nx1-nx0) / 2;
			let dzdy = (ny1-ny0) / 2;
			
			// vector length
			let len = sqrt((dzdx * dzdx) + (dzdy * dzdy));
			
			// normalize
			dzdx /= len;
			dzdy /= len;
			
			normals[x + y * width] = { x: dzdx, y: dzdy, z: n };
			
			// 2
			noiseDetail(8, 0.5);
			
			let n2 = noise(nx * 2, ny * 16);
			
			details[x + y * width] = n;
			
			//line(x, y, x + -dzdx * 10, y + -dzdy * 10);
		}
	}
	
	drawStuff();
}

function drawStuff() {
	noStroke();
	loadPixels();
	for (let y = floor(random(0, 4)); y < height; y += 4) {
		for (let x = floor(random(0, 4)); x < width; x += 4) {
			let n = normals[x + y * width];
			
			let nx = x / width;
			let ny = y / height;
			
			let npx = x / width * 2 - 1;
			let npy = y / height * 2 - 1;
			
			let light_z_pos = 2; // above
			
			let lpx = light_npx - npx;
			let lpy = light_npy - npy;
			let lpz = light_z_pos - n.z;
			
			let light_dst = sqrt((lpx * lpx) + (lpy * lpy) + (lpz * lpz));
			lpx /= light_dst;
			lpy /= light_dst;
			lpz /= light_dst;
			light_dst = light_dst * light_dst;
			
			let n_dot_l = n.x * lpx + n.y * lpy + n.z * lpz;
			let lambert = max(n_dot_l, 0);
			
			let specular = 0;
			if (lambert > 0) {
				specular = pow(max(norm(n_dot_l, 0, 1), 0), 8);
			}

			let ambient = 0.1;
			let diffuse_color = 180 + n.z * 100;
			let brightness = n.z * (ambient + lambert * 2 / light_dst + specular * 2 / light_dst);

			brightness = pow(brightness, 1.0 / 2.2);
			//brightness_rgb = floor(brightness * 255);
			
			let det = details[x + y * width];
			
			let pa1 = 0.7, pa2 = 0.5, pa3 = 0.5;
			let pb1 = 0.75, pb2 = 0.5, pb3 = 0.5;
			let pc1 = 0.75, pc2 = 0.5, pc3 = 0.5;

			let pdr = 0.5 - det / 10;
			let pdg = 0.625 + n.z / 6;
			let pdb = 0.75 + n.z / 4;

			var rf = pal(n.z, pa1, pb1, pc1, pdr) * brightness * 255;
			var gf = pal(n.z, pa2, pb2, pc2, pdg) * brightness * 255;
			var bf = pal(n.z, pa3, pb3, pc3, pdb) * brightness * 255;

/*    // slow
			if (diffuse > 0) {
				fill(diffuse_color, 0.0, brightness, 1);
				rect(x, y, 1, 1);
			}
*/
			pixels[(x + y * width) * 4 + 0] = rf;
			pixels[(x + y * width) * 4 + 1] = gf;
			pixels[(x + y * width) * 4 + 2] = bf;
		}
	}
	updatePixels();
}

let light_npx = 0;
let light_npy = 0;

let xmotion = 0;
let ymotion = 0;

function draw() {
drawStuff();
	
	light_npx = cos(xmotion)/2;
	light_npy = sin(ymotion)/2;
	
	xmotion += 0.05;
	ymotion += 0.05;	
}"
"1007110","Soft normal mapping noise","mySketch","// software rendering noise heightfield bumpmap (more specifically normal map) with blinn phong shading

let normals = [];
let details = [];

// https://iquilezles.org/www/articles/palettes/palettes.htm
function pal(t, a, b, c, d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

function setup() {
	createCanvas(600, 600);
	background(100);
	
	colorMode(HSB, 360, 1, 1, 1);
	
	rectMode(CORNER);
	
	noStroke();
	
	background(0);
	
	generateNormals();
}

function generateNormals () {
	for (let y = 0; y < height; y += 1) {
		for (let x = 0; x < width; x += 1) {
			let nx = x / width;
			let ny = y / height;
			
			let scale = 8;
			let offset = 0.0005;
			
			noiseDetail(7, 0.35);
			
			let n = noise(nx * scale, ny * scale); // sampled point
			
			let nx0 = noise(nx * scale - offset, ny * scale); // left
			let nx1 = noise(nx * scale + offset, ny * scale); // right
			let ny1 = noise(nx * scale, ny * scale + offset); // top
			let ny0 = noise(nx * scale, ny * scale - offset); // bottom
			
			let dzdx = (nx1-nx0) / 2;
			let dzdy = (ny1-ny0) / 2;
			
			// vector length
			let len = sqrt((dzdx * dzdx) + (dzdy * dzdy));
			
			// normalize
			dzdx /= len;
			dzdy /= len;
			
			normals[x + y * width] = { x: dzdx, y: dzdy, z: n };
			
			// 2
			noiseDetail(8, 0.5);
			
			let n2 = noise(nx * 2, ny * 16);
			
			details[x + y * width] = n;
			
			//line(x, y, x + -dzdx * 10, y + -dzdy * 10);
		}
	}
	
	drawStuff();
}

function drawStuff() {
	noStroke();
	loadPixels();
	for (let y = floor(random(0, 4)); y < height; y += 4) {
		for (let x = floor(random(0, 4)); x < width; x += 4) {
			let n = normals[x + y * width];
			
			let nx = x / width;
			let ny = y / height;
			
			let npx = x / width * 2 - 1;
			let npy = y / height * 2 - 1;
			
			let light_z_pos = 2; // above
			
			let lpx = light_npx - npx;
			let lpy = light_npy - npy;
			let lpz = light_z_pos - n.z;
			
			let light_dst = sqrt((lpx * lpx) + (lpy * lpy) + (lpz * lpz));
			lpx /= light_dst;
			lpy /= light_dst;
			lpz /= light_dst;
			light_dst = light_dst * light_dst;
			
			let n_dot_l = n.x * lpx + n.y * lpy + n.z * lpz;
			let lambert = max(n_dot_l, 0);
			
			let specular = 0;
			if (lambert > 0) {
				specular = pow(max(norm(n_dot_l, 0, 1), 0), 8);
			}

			let ambient = 0.1;
			let diffuse_color = 180 + n.z * 100;
			let brightness = n.z * (ambient + lambert * 2 / light_dst + specular * 2 / light_dst);

			brightness = pow(brightness, 1.0 / 2.2);
			//brightness_rgb = floor(brightness * 255);
			
			let det = details[x + y * width];
			
			let pa1 = 0.7, pa2 = 0.5, pa3 = 0.5;
			let pb1 = 0.75, pb2 = 0.5, pb3 = 0.5;
			let pc1 = 0.75, pc2 = 0.5, pc3 = 0.5;

			let pdr = 0.5 - det / 10;
			let pdg = 0.625 + n.z / 6;
			let pdb = 0.75 + n.z / 4;

			var rf = pal(n.z, pa1, pb1, pc1, pdr) * brightness * 255;
			var gf = pal(n.z, pa2, pb2, pc2, pdg) * brightness * 255;
			var bf = pal(n.z, pa3, pb3, pc3, pdb) * brightness * 255;

/*    // slow
			if (diffuse > 0) {
				fill(diffuse_color, 0.0, brightness, 1);
				rect(x, y, 1, 1);
			}
*/
			pixels[(x + y * width) * 4 + 0] = rf;
			pixels[(x + y * width) * 4 + 1] = gf;
			pixels[(x + y * width) * 4 + 2] = bf;
		}
	}
	updatePixels();
}

let light_npx = 0;
let light_npy = 0;

let xmotion = 0;
let ymotion = 0;

function draw() {
drawStuff();
	
	light_npx = cos(xmotion)/2;
	light_npy = sin(ymotion)/2;
	
	xmotion += 0.05;
	ymotion += 0.05;	
}"
"1006288","3D Terrain tunnel 3","mySketch","/**
  * Same as last one with bit improved rendering / animation
  */

PImage colormap;
PImage heightmap;
PImage water;

float xmotion = 0;
float ymotion = 0;
float rmotion = 0;

int[] pex = new int[dots * 2];
int[] pey = new int[dots * 2];

int elems = 64; // can improve the rendering quality by increasing it and lowering the xrad_step / yrad_step variable
int dots = 128; // improve tunnel quality (to be used with rect_size)

int dots_step = 1;
int elems_step = 1;

void draw_landscape() {
  int rect_size = 1;
  
  // apply motion blur
  //fill(0, 0, 0, 0);
  //rect(0, 0, 800, 600);
	//background(0);
  
  noStroke();
  
  // initial circle size
  int bsize = 16;
  
  int xoff = 800 / 2;
  int yoff = 600 / 2;
  
  // the circles stepping
  int xrad_step = 10;
  int yrad_step = 10;
  
  // max motion deform.
  int xdeform = 80;
  int ydeform = 80;
  
  float crepeat = 0.2 + abs(sin(xmotion/2+cos(ymotion)))/2; // heightmap / colormap repeat
  int wrepeat = 0.05; // water texture repeat
  
  // we start by eliminating the blur effect at the end of the tunnel
  fill(0, 0, 0);
  ellipse(xoff + sin(360 * (PI / 180) + xmotion) * xdeform, yoff + cos(360 * (PI / 180) + ymotion) * xdeform, bsize * 1.5, bsize * 1.5);
  
  for (int e = 0; e < elems; e += elems_step) {
    float de = (float)e / elems;
		float de2 = (float)(e + elems_step) / elems;
    
    // fog computation
    float bd = 1.-max(min((0.5-abs(de - 0.5)) * 2, 1), 0.005);
    
    float ex = sin(de * 360 * (PI / 180)+xmotion);
    float ey = cos(de * 360 * (PI / 180)+ymotion);
     
    float xrad = e * xrad_step + bsize + sin(de * 360 * (PI / 180) + xmotion) * 4;
    float yrad = e * yrad_step + bsize + cos(de * 360 * (PI / 180) + xmotion) * 4;
    
    float final_ex = xoff + ex * xdeform;
    
    float xpp = (de * 360 * (PI / 180)) / 2;
		float xpp2 = (de2 * 360 * (PI / 180)) / 2;
    
    // pre-computing textures lookup
    int yyd = (((int)(de * (colormap.height * crepeat)) % colormap.height)) * colormap.width;
    int wyd = (((int)(de * (colormap.height * wrepeat)) % colormap.height)) * colormap.width; 
		
		int j = 0;

    for (int d = 0; d < dots; d += dots_step) {
      float dd = (float)d / dots;
			float dd2 = (float)(d + dots_step) / dots;
      
      float xp = dd * 360 * (PI / 180);
      float yp = dd * 360 * (PI / 180);
			
      float xp2 = dd2 * 360 * (PI / 180);
      float yp2 = dd2 * 360 * (PI / 180);
			
      xp2 += xpp2 + rmotion;
      yp2 += xpp2 + rmotion;
      
      xp += xpp + rmotion;
      yp += xpp + rmotion;
      
      // compute height & apply it
			int hl = ((int)abs(heightmap.height / 2 + (de * heightmap.height + bsize) * cos(yp+xmotion) * crepeat+xmotion*100) % heightmap.height) * heightmap.width;
      float normalized_height = (heightmap.pixels[(((int)abs(heightmap.width / 2 + (de * heightmap.width + bsize) * sin(xp+xmotion) * crepeat+xmotion*100)) % heightmap.width) + hl] >> 16 & 0xFF) / 255.0;
			hl = ((int)abs(heightmap.height / 2 + (de2 * heightmap.height + bsize) * cos(yp2+xmotion) * crepeat+xmotion*100) % heightmap.height) * heightmap.width;
      float normalized_height2 = (heightmap.pixels[(((int)abs(heightmap.width / 2 + (de2 * heightmap.width + bsize) * sin(xp2+xmotion) * crepeat+xmotion*100)) % heightmap.width) + hl] >> 16 & 0xFF) / 255.0;
      
      float h = 1.0 - normalized_height * (1.-de);
			float h2 = 1.0 - normalized_height2 * (1.-de2);
      
      float final_x = final_ex + sin(xp) * xrad * h;
      float final_y = yoff + ey * ydeform + cos(yp) * yrad * h;
			
      float final_x2 = final_ex + sin(xp2) * xrad * h2;
      float final_y2 = yoff + ey * ydeform + cos(yp2) * yrad * h2;
			
      // do not compute outside boundary
      if (final_x >= 1280 || final_x < -400 || final_y >= 1024 | final_y < -400) {
				quad(pex[j], pey[j], final_x, final_y, final_x2, final_y2, pex[j+dots], pey[j+dots]);
				
				j += 1;
				
        continue;
      }
      
      // apply colormap / texture
      int xxd = ((int)(dd * (colormap.width * crepeat)) % colormap.width);

      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]));
      int g = (int)(green(colormap.pixels[cl]));
      int b = (int)(blue(colormap.pixels[cl]));
      
      // water map
      int wxd = ((int)(dd * (colormap.width * wrepeat)) % colormap.width);

      int wcl = (int)wxd + wyd;
      
      int wr = (int)(red(water.pixels[wcl]));
      int wg = (int)(green(water.pixels[wcl]));
      int wb = (int)(blue(water.pixels[wcl]));
      
      float finalr = r, finalg = g , finalb = b;
      float water_level = 0.2;
      if (normalized_height < water_level) {
        float wl = normalized_height * (1.0 / water_level);
        
        finalr = lerp(wr, r, wl);
        finalg = lerp(wg, g, wl);
        finalb = lerp(wb, b, wl);
      }
      
      float snow_level = 0.45;
      if (normalized_height > snow_level) {
        float wl = (normalized_height - snow_level) * (1.0 / snow_level);
        
        finalr = lerp(r, 255, wl);
        finalg = lerp(g, 255, wl);
        finalb = lerp(b, 255, wl);
      }
      
      finalr = lerp((int)finalr, 0, bd);
      finalg = lerp((int)finalg, 0, bd);
      finalb = lerp((int)finalb, 0, bd);
      
      fill(finalr, finalg, finalb, 192);
      
      //rect(final_x, final_y, rect_size, rect_size);
			//stroke(finalr, finalg, finalb);
			//line(pex[j], pey[j], final_x, final_y);
			//line(final_x, final_y, final_x2, final_y2);
			
			quad(pex[j], pey[j], final_x, final_y, final_x2, final_y2, pex[j+dots], pey[j+dots]);
			
			pex[j] = final_x;
			pey[j] = final_y;

			pex[j+dots] = final_x2;
			pey[j+dots] = final_y2;
			
			j += 1;
    }
  }
  
  xmotion += 0.05;
  ymotion += 0.025;
  rmotion += 0;//0.012;
}

void setup() {
  size(800, 600);

  frameRate(60); 
  
  colormap = loadImage(""colormap.jpg"");
  
  water = loadImage(""water.jpg"");
  
  heightmap = loadImage(""heightmap.jpg"");

  background(0);
}

void draw() {
  //ckground(0);
 
  draw_landscape();
}"
"1006288","3D Terrain tunnel 3","mySketch","/**
  * Same as last one with bit improved rendering / animation
  */

PImage colormap;
PImage heightmap;
PImage water;

float xmotion = 0;
float ymotion = 0;
float rmotion = 0;

int[] pex = new int[dots * 2];
int[] pey = new int[dots * 2];

int elems = 64; // can improve the rendering quality by increasing it and lowering the xrad_step / yrad_step variable
int dots = 128; // improve tunnel quality (to be used with rect_size)

int dots_step = 1;
int elems_step = 1;

void draw_landscape() {
  int rect_size = 1;
  
  // apply motion blur
  //fill(0, 0, 0, 0);
  //rect(0, 0, 800, 600);
	//background(0);
  
  noStroke();
  
  // initial circle size
  int bsize = 16;
  
  int xoff = 800 / 2;
  int yoff = 600 / 2;
  
  // the circles stepping
  int xrad_step = 10;
  int yrad_step = 10;
  
  // max motion deform.
  int xdeform = 80;
  int ydeform = 80;
  
  float crepeat = 0.2 + abs(sin(xmotion/2+cos(ymotion)))/2; // heightmap / colormap repeat
  int wrepeat = 0.05; // water texture repeat
  
  // we start by eliminating the blur effect at the end of the tunnel
  fill(0, 0, 0);
  ellipse(xoff + sin(360 * (PI / 180) + xmotion) * xdeform, yoff + cos(360 * (PI / 180) + ymotion) * xdeform, bsize * 1.5, bsize * 1.5);
  
  for (int e = 0; e < elems; e += elems_step) {
    float de = (float)e / elems;
		float de2 = (float)(e + elems_step) / elems;
    
    // fog computation
    float bd = 1.-max(min((0.5-abs(de - 0.5)) * 2, 1), 0.005);
    
    float ex = sin(de * 360 * (PI / 180)+xmotion);
    float ey = cos(de * 360 * (PI / 180)+ymotion);
     
    float xrad = e * xrad_step + bsize + sin(de * 360 * (PI / 180) + xmotion) * 4;
    float yrad = e * yrad_step + bsize + cos(de * 360 * (PI / 180) + xmotion) * 4;
    
    float final_ex = xoff + ex * xdeform;
    
    float xpp = (de * 360 * (PI / 180)) / 2;
		float xpp2 = (de2 * 360 * (PI / 180)) / 2;
    
    // pre-computing textures lookup
    int yyd = (((int)(de * (colormap.height * crepeat)) % colormap.height)) * colormap.width;
    int wyd = (((int)(de * (colormap.height * wrepeat)) % colormap.height)) * colormap.width; 
		
		int j = 0;

    for (int d = 0; d < dots; d += dots_step) {
      float dd = (float)d / dots;
			float dd2 = (float)(d + dots_step) / dots;
      
      float xp = dd * 360 * (PI / 180);
      float yp = dd * 360 * (PI / 180);
			
      float xp2 = dd2 * 360 * (PI / 180);
      float yp2 = dd2 * 360 * (PI / 180);
			
      xp2 += xpp2 + rmotion;
      yp2 += xpp2 + rmotion;
      
      xp += xpp + rmotion;
      yp += xpp + rmotion;
      
      // compute height & apply it
			int hl = ((int)abs(heightmap.height / 2 + (de * heightmap.height + bsize) * cos(yp+xmotion) * crepeat+xmotion*100) % heightmap.height) * heightmap.width;
      float normalized_height = (heightmap.pixels[(((int)abs(heightmap.width / 2 + (de * heightmap.width + bsize) * sin(xp+xmotion) * crepeat+xmotion*100)) % heightmap.width) + hl] >> 16 & 0xFF) / 255.0;
			hl = ((int)abs(heightmap.height / 2 + (de2 * heightmap.height + bsize) * cos(yp2+xmotion) * crepeat+xmotion*100) % heightmap.height) * heightmap.width;
      float normalized_height2 = (heightmap.pixels[(((int)abs(heightmap.width / 2 + (de2 * heightmap.width + bsize) * sin(xp2+xmotion) * crepeat+xmotion*100)) % heightmap.width) + hl] >> 16 & 0xFF) / 255.0;
      
      float h = 1.0 - normalized_height * (1.-de);
			float h2 = 1.0 - normalized_height2 * (1.-de2);
      
      float final_x = final_ex + sin(xp) * xrad * h;
      float final_y = yoff + ey * ydeform + cos(yp) * yrad * h;
			
      float final_x2 = final_ex + sin(xp2) * xrad * h2;
      float final_y2 = yoff + ey * ydeform + cos(yp2) * yrad * h2;
			
      // do not compute outside boundary
      if (final_x >= 1280 || final_x < -400 || final_y >= 1024 | final_y < -400) {
				quad(pex[j], pey[j], final_x, final_y, final_x2, final_y2, pex[j+dots], pey[j+dots]);
				
				j += 1;
				
        continue;
      }
      
      // apply colormap / texture
      int xxd = ((int)(dd * (colormap.width * crepeat)) % colormap.width);

      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]));
      int g = (int)(green(colormap.pixels[cl]));
      int b = (int)(blue(colormap.pixels[cl]));
      
      // water map
      int wxd = ((int)(dd * (colormap.width * wrepeat)) % colormap.width);

      int wcl = (int)wxd + wyd;
      
      int wr = (int)(red(water.pixels[wcl]));
      int wg = (int)(green(water.pixels[wcl]));
      int wb = (int)(blue(water.pixels[wcl]));
      
      float finalr = r, finalg = g , finalb = b;
      float water_level = 0.2;
      if (normalized_height < water_level) {
        float wl = normalized_height * (1.0 / water_level);
        
        finalr = lerp(wr, r, wl);
        finalg = lerp(wg, g, wl);
        finalb = lerp(wb, b, wl);
      }
      
      float snow_level = 0.45;
      if (normalized_height > snow_level) {
        float wl = (normalized_height - snow_level) * (1.0 / snow_level);
        
        finalr = lerp(r, 255, wl);
        finalg = lerp(g, 255, wl);
        finalb = lerp(b, 255, wl);
      }
      
      finalr = lerp((int)finalr, 0, bd);
      finalg = lerp((int)finalg, 0, bd);
      finalb = lerp((int)finalb, 0, bd);
      
      fill(finalr, finalg, finalb, 192);
      
      //rect(final_x, final_y, rect_size, rect_size);
			//stroke(finalr, finalg, finalb);
			//line(pex[j], pey[j], final_x, final_y);
			//line(final_x, final_y, final_x2, final_y2);
			
			quad(pex[j], pey[j], final_x, final_y, final_x2, final_y2, pex[j+dots], pey[j+dots]);
			
			pex[j] = final_x;
			pey[j] = final_y;

			pex[j+dots] = final_x2;
			pey[j+dots] = final_y2;
			
			j += 1;
    }
  }
  
  xmotion += 0.05;
  ymotion += 0.025;
  rmotion += 0;//0.012;
}

void setup() {
  size(800, 600);

  frameRate(60); 
  
  colormap = loadImage(""colormap.jpg"");
  
  water = loadImage(""water.jpg"");
  
  heightmap = loadImage(""heightmap.jpg"");

  background(0);
}

void draw() {
  //ckground(0);
 
  draw_landscape();
}"
"1006288","3D Terrain tunnel 3","mySketch","/**
  * Same as last one with bit improved rendering / animation
  */

PImage colormap;
PImage heightmap;
PImage water;

float xmotion = 0;
float ymotion = 0;
float rmotion = 0;

int[] pex = new int[dots * 2];
int[] pey = new int[dots * 2];

int elems = 64; // can improve the rendering quality by increasing it and lowering the xrad_step / yrad_step variable
int dots = 128; // improve tunnel quality (to be used with rect_size)

int dots_step = 1;
int elems_step = 1;

void draw_landscape() {
  int rect_size = 1;
  
  // apply motion blur
  //fill(0, 0, 0, 0);
  //rect(0, 0, 800, 600);
	//background(0);
  
  noStroke();
  
  // initial circle size
  int bsize = 16;
  
  int xoff = 800 / 2;
  int yoff = 600 / 2;
  
  // the circles stepping
  int xrad_step = 10;
  int yrad_step = 10;
  
  // max motion deform.
  int xdeform = 80;
  int ydeform = 80;
  
  float crepeat = 0.2 + abs(sin(xmotion/2+cos(ymotion)))/2; // heightmap / colormap repeat
  int wrepeat = 0.05; // water texture repeat
  
  // we start by eliminating the blur effect at the end of the tunnel
  fill(0, 0, 0);
  ellipse(xoff + sin(360 * (PI / 180) + xmotion) * xdeform, yoff + cos(360 * (PI / 180) + ymotion) * xdeform, bsize * 1.5, bsize * 1.5);
  
  for (int e = 0; e < elems; e += elems_step) {
    float de = (float)e / elems;
		float de2 = (float)(e + elems_step) / elems;
    
    // fog computation
    float bd = 1.-max(min((0.5-abs(de - 0.5)) * 2, 1), 0.005);
    
    float ex = sin(de * 360 * (PI / 180)+xmotion);
    float ey = cos(de * 360 * (PI / 180)+ymotion);
     
    float xrad = e * xrad_step + bsize + sin(de * 360 * (PI / 180) + xmotion) * 4;
    float yrad = e * yrad_step + bsize + cos(de * 360 * (PI / 180) + xmotion) * 4;
    
    float final_ex = xoff + ex * xdeform;
    
    float xpp = (de * 360 * (PI / 180)) / 2;
		float xpp2 = (de2 * 360 * (PI / 180)) / 2;
    
    // pre-computing textures lookup
    int yyd = (((int)(de * (colormap.height * crepeat)) % colormap.height)) * colormap.width;
    int wyd = (((int)(de * (colormap.height * wrepeat)) % colormap.height)) * colormap.width; 
		
		int j = 0;

    for (int d = 0; d < dots; d += dots_step) {
      float dd = (float)d / dots;
			float dd2 = (float)(d + dots_step) / dots;
      
      float xp = dd * 360 * (PI / 180);
      float yp = dd * 360 * (PI / 180);
			
      float xp2 = dd2 * 360 * (PI / 180);
      float yp2 = dd2 * 360 * (PI / 180);
			
      xp2 += xpp2 + rmotion;
      yp2 += xpp2 + rmotion;
      
      xp += xpp + rmotion;
      yp += xpp + rmotion;
      
      // compute height & apply it
			int hl = ((int)abs(heightmap.height / 2 + (de * heightmap.height + bsize) * cos(yp+xmotion) * crepeat+xmotion*100) % heightmap.height) * heightmap.width;
      float normalized_height = (heightmap.pixels[(((int)abs(heightmap.width / 2 + (de * heightmap.width + bsize) * sin(xp+xmotion) * crepeat+xmotion*100)) % heightmap.width) + hl] >> 16 & 0xFF) / 255.0;
			hl = ((int)abs(heightmap.height / 2 + (de2 * heightmap.height + bsize) * cos(yp2+xmotion) * crepeat+xmotion*100) % heightmap.height) * heightmap.width;
      float normalized_height2 = (heightmap.pixels[(((int)abs(heightmap.width / 2 + (de2 * heightmap.width + bsize) * sin(xp2+xmotion) * crepeat+xmotion*100)) % heightmap.width) + hl] >> 16 & 0xFF) / 255.0;
      
      float h = 1.0 - normalized_height * (1.-de);
			float h2 = 1.0 - normalized_height2 * (1.-de2);
      
      float final_x = final_ex + sin(xp) * xrad * h;
      float final_y = yoff + ey * ydeform + cos(yp) * yrad * h;
			
      float final_x2 = final_ex + sin(xp2) * xrad * h2;
      float final_y2 = yoff + ey * ydeform + cos(yp2) * yrad * h2;
			
      // do not compute outside boundary
      if (final_x >= 1280 || final_x < -400 || final_y >= 1024 | final_y < -400) {
				quad(pex[j], pey[j], final_x, final_y, final_x2, final_y2, pex[j+dots], pey[j+dots]);
				
				j += 1;
				
        continue;
      }
      
      // apply colormap / texture
      int xxd = ((int)(dd * (colormap.width * crepeat)) % colormap.width);

      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]));
      int g = (int)(green(colormap.pixels[cl]));
      int b = (int)(blue(colormap.pixels[cl]));
      
      // water map
      int wxd = ((int)(dd * (colormap.width * wrepeat)) % colormap.width);

      int wcl = (int)wxd + wyd;
      
      int wr = (int)(red(water.pixels[wcl]));
      int wg = (int)(green(water.pixels[wcl]));
      int wb = (int)(blue(water.pixels[wcl]));
      
      float finalr = r, finalg = g , finalb = b;
      float water_level = 0.2;
      if (normalized_height < water_level) {
        float wl = normalized_height * (1.0 / water_level);
        
        finalr = lerp(wr, r, wl);
        finalg = lerp(wg, g, wl);
        finalb = lerp(wb, b, wl);
      }
      
      float snow_level = 0.45;
      if (normalized_height > snow_level) {
        float wl = (normalized_height - snow_level) * (1.0 / snow_level);
        
        finalr = lerp(r, 255, wl);
        finalg = lerp(g, 255, wl);
        finalb = lerp(b, 255, wl);
      }
      
      finalr = lerp((int)finalr, 0, bd);
      finalg = lerp((int)finalg, 0, bd);
      finalb = lerp((int)finalb, 0, bd);
      
      fill(finalr, finalg, finalb, 224);
      
      //rect(final_x, final_y, rect_size, rect_size);
			//stroke(finalr, finalg, finalb);
			//line(pex[j], pey[j], final_x, final_y);
			//line(final_x, final_y, final_x2, final_y2);
			
			quad(pex[j], pey[j], final_x, final_y, final_x2, final_y2, pex[j+dots], pey[j+dots]);
			
			pex[j] = final_x;
			pey[j] = final_y;

			pex[j+dots] = final_x2;
			pey[j+dots] = final_y2;
			
			j += 1;
    }
  }
  
  xmotion += 0.05;
  ymotion += 0.025;
  rmotion += 0;//0.012;
}

void setup() {
  size(800, 600);

  frameRate(60); 
  
  colormap = loadImage(""colormap.jpg"");
  
  water = loadImage(""water.jpg"");
  
  heightmap = loadImage(""heightmap.jpg"");

  background(0);
}

void draw() {
  //ckground(0);
 
  draw_landscape();
}"
"1005102","Flow field 3","mySketch","// simple vector field with a twist

let normals = [];
let particl = [];

let fun_index = 0;

const fun = [
	(nx, ny) => { return { x: sin(nx * PI * 2 + cos(ny * PI * 4) * PI * 2), y: cos(ny * PI * 2 + sin(nx * PI * 2) * PI * 2) } }
];

let pcount = 10000;
let batchc = 3333; // basically how much particles to refresh / frame (pcount / batchc = 3 frames for whole refresh which is roughly 20fps on my i7 7700)

function setup() {
	createCanvas(600, 600);
	background(100);
	
	noiseDetail(4, 0.7);
	
	colorMode(HSB, 360, 1, 1, 1);
	
	rectMode(CENTER);
	
	noStroke();
	
	background(0);
	/*
	for (let i = 0; i < width * height; i += 1) {
		//particl[i] = { x: random(0, width), y: random(0, height) };
		particl[i] = { x: i % width, y: floor(i / width), vx: 1, vy: 1 };
	}
	*/
	for (let i = 0; i < pcount; i += 1) {
		particl[i] = { x: random(0, width), y: random(0, height), b: 0, bl: noise(i/pcount*4) > 0.5 ? 1: 0.0, a: random() };
	}
	
	generateNormals(fun[0]);
}

function generateNormals(f) {
	stroke(0, 0.5, 1, 1);
	
	let offx = random(0, 1);
	
	for (let y = 0; y < height; y += 1) {
		for (let x = 0; x < width; x += 1) {
			let nx = x / width;
			let ny = y / height;
			
			//let n = noise(nx * 4, ny * 4); // sampled point
			
			let nx0 = noise(nx * 4 - 0.05 + offx, ny * 1); // left
			let nx1 = noise(nx * 4 + 0.05 + offx, ny * 1); // right
			let ny1 = noise(nx * 4 + offx, ny * 4 + 0.05); // top
			let ny0 = noise(nx * 4 + offx, ny * 4 - 0.05); // bottom
			
			let dzdx= (nx1-nx0) / 2;
			let dzdy= (ny1-ny0) / 2;
			
			// vector length
			let len = sqrt((dzdx * dzdx) + (dzdy * dzdy))+0.001;
			
			// normalize
			dzdx /= len;
			dzdy /= len;
			
			normals[x + y * width] = f(nx, ny);
			
			// line(x, y, x + -dzdx * 1, y + -dzdy * 1);
		}
	}
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	rectMode(CORNERS);
	
	noStroke();
	fill(0, 0, 0, 0.05);
	rect(0, 0, width, height);
	
	if (frameCount % 60 == 0) {
		fun_index += 1;
		fun_index %= fun.length;
		
		//generateNormals(fun[fun_index]);
	}
	
	rectMode(CENTER);
	//background(0);
/*
  // display noise map
	for (let y = 0; y < 800; y += 16) {
		for (let x = 0; x < 800; x += 16) {
			let nx = x / 800;
			let ny = y / 800;
			
			let n = noise(nx * 4, ny * 4);
			
			fill(0, 0, pow(n, 1.25), 1);
			rect(x, y, 16, 16);
		}
	}
*/
	
	noStroke();
	fill(0, 0, 1, 1);
	//loadPixels();
	
	let start_index = frameCount % floor(pcount/batchc) * batchc;
	
	for (let i = 0; i < start_index; i += 1) {
		let p = particl[i];
		let px = floor(p.x);
		let py = floor(p.y);
		fill(170 + abs(p.b) / width/10 % 100, abs(p.b / width) / 255 % 1, p.bl, p.a);
		rect(px, py, 1, 1);
	}
	
	for (let i = start_index+batchc; i < pcount - (start_index+batchc); i += 1) {
		let p = particl[i];
		let px = floor(p.x);
		let py = floor(p.y);
		fill(170 + abs(p.b) / width/10 % 100, abs(p.b / width) / 255 % 1, p.bl, p.a);
		rect(px, py, 1, 1);
	}
	
	for (let i = start_index; i < start_index+batchc; i += 1) {
		let p = particl[i];
		//let p2 = particl[i-1];

		let px = floor(p.x);
		let py = floor(p.y);

		let index2 = px + py * width;
		let d = normals[index2];

		fill(170 + abs(p.b) / width/10 % 90, abs(p.b / width) / 512 % 0.95, p.bl, p.a);
		//pixels[(px + py * width) * 4+0] = d.b;
		//pixels[(px + py * width) * 4+1] = d.b;
		//pixels[(px + py * width) * 4+2] = d.b;
		rect(px, py, 1, 1);
		//point(px, py);
		//line(px, py, floor(p2.x), floor(p2.y));

		p.x += d.x;
		p.y += d.y;
		p.b += d.x * d.y * 10000;

		if (frameCount % 1000 < 500) {
			d.x += (p.x / width*2-1) / 2;
			d.y += (p.y / height*2-1) / 2;
		} else {
			d.x -= (p.x / width*2-1) / 2;
			d.y -= (p.y / height*2-1) / 2;
		}
		/*
		if (floor(p.x) == width/2) {
			p.x = 0;//(random() > 0.5) ? 0 : width - 1;
		}
		if (floor(p.y) == width/2) {
			p.y = 0;//(random() > 0.5) ? 0 : height - 1;
		}*/
		if (p.x > width) {
			p.x = random(width/2 - 24, width/2 + 24);
		}
		if (p.y > height) {
			p.y = random(height/2 - 24, height/2 + 24);
		}
		if (p.x < 0) {
			p.x = random(width/2 - 24, width/2 + 24);
		}
		if (p.y < 0) {
			p.y = random(height/2 - 24, height/2 + 24);
		}
	}
	//updatePixels();
	
	xmotion += 0.1;
	ymotion += 0.0075;
}"
"1004822","Opening","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 6;

function setup() {
  createCanvas(800, 800);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (1.0), y: (width / (1.15) + x - y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 3 * x) / 1 + j * 40, y: (height / 6 - y * 2 / j + (x / 4.0)) / 1.0 + j * (80) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 - x * j) / (y/40 * (j / 8) + x / (width / (5.85))), y: y / 2.5 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (3.25) - x + y / (1.95 * j * ((0.5 - y / width) * 10))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 10, y: (height / 2 - y * 1.15 / j + (x / 10.075)) / 1.75 + j * (50) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (4.0 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 5; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let nx1 = y[j] / height * 2. - 1.;
				let inx1 = 0.25+pow(1-nx1, 1);
				let nx2 = y2[j] / height;
				let inx2 = 0.45+pow(nx2, 0.5);
				
				let e = 0.75;

				if (iter > 20) {
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.0225 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);
					//point(width - x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					//point(x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					
					//point(x2[j] * inx2+5, height / 1 - y2[j]/2.5);
					//point(width - x2[j] * inx2-5, height / 1 - y2[j]/2.5);
					point(width / 2 - x[j] / 8 * inx1, height - y[j]/2);
					point(width / 2 + x[j] / 8 * inx1, height - y[j]/2);
					
					point(width - x[j] / 8 * inx1,  y[j]/2);
					point(x[j] / 8 * inx1, y[j]/2);
					point(width - y[j] / 3 * inx1, height - x[j]/2);
					point(y[j] / 3 * inx1,height - x[j]/2);
					//point(width / 4 - x[j] / , y[j]/3);
					//point(width - width / 4 + x[j] / 8, y[j]/3);
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"1004816","Seal","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 6;

function setup() {
  createCanvas(800, 800);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (1.0), y: (width / (1.15) + x - y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 3 * x) / 1 + j * 40, y: (height / 6 - y * 2 / j + (x / 4.0)) / 1.0 + j * (80) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 - x * j) / (y/50 * (j / 8) + x / (width / (5.85))), y: y / 2.5 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (3.25) - x + y / (1.95 * j * ((0.5 - y / width) * 10))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 10, y: (height / 2 - y * 1.15 / j + (x / 10.075)) / 1.75 + j * (50) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (4.0 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 5; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let nx1 = y[j] / height * 2. - 1.;
				let inx1 = 0.95+pow(1-nx1, 2);
				let nx2 = y2[j] / height;
				let inx2 = 0.45+pow(nx2, 0.5);
				
				let e = 0.75;

				if (iter > 20) {
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.0225 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);
					//point(width - x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					//point(x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					
					//point(x2[j] * inx2+5, height / 1 - y2[j]/2.5);
					//point(width - x2[j] * inx2-5, height / 1 - y2[j]/2.5);
					point(width / 2 - x[j] / 8 * inx1, height - y[j]/2);
					point(width / 2 + x[j] / 8 * inx1, height - y[j]/2);
					point(width - x[j] / 8 * inx1,  y[j]/2);
					point(x[j] / 8 * inx1, y[j]/2);
					//point(width / 2 - x[j] / 4, y[j]/3);
					//point(width / 2 + x[j] / 4, y[j]/3);
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"1004806","Meltphace","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 6;

function setup() {
  createCanvas(800, 800);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (2.0), y: (width / (1.15) + x - y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 3 * x) / 1 + j * 40, y: (height / 6 - y * 2 / j + (x / 2.0)) / 1.0 + j * (70) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 - x * j) / (y/100 * (j / 4) + x / (width / (5.85))), y: y / 2.5 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (3.25) - x + y / (1.95 * j * ((0.5 - y / width) * 10))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 10, y: (height / 2 - y * 1.15 / j + (x / 10.075)) / 1.75 + j * (50) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (4.0 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 5; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let nx1 = y[j] / height * 2. - 1.;
				let inx1 = 0.25+pow(1-nx1, 2);
				let nx2 = y2[j] / height;
				let inx2 = 0.45+pow(nx2, 0.5);
				
				let e = 0.75;

				if (iter > 20) {
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 220, 0.0225 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);
					//point(width - x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					//point(x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					
					//point(x2[j] * inx2+5, height / 1 - y2[j]/2.5);
					//point(width - x2[j] * inx2-5, height / 1 - y2[j]/2.5);
					point(width / 2 - x[j] / 4 * inx1, height - y[j]/2);
					point(width / 2 + x[j] / 4 * inx1, height - y[j]/2);
					point(width - x[j] / 4 * inx1, height - y[j]/2);
					point(x[j] / 4 * inx1, height - y[j]/2);
					//point(width / 2 - x[j] / 4, y[j]/3);
					//point(width / 2 + x[j] / 4, y[j]/3);
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"1004782","Flow field²","mySketch","// simple vector field with a twist

let normals = [];
let particl = [];

let fun_index = 0;

const fun = [
	(nx, ny, nx2, ny2) => { return { x: sin(nx * PI * 2 + cos(ny * PI * 2) * PI * 4), y: cos(ny * PI * 2 + pow(sin(nx * PI * 2), 2) * PI * 4)} }
];

function setup() {
	createCanvas(600, 600);
	background(100);
	
	noiseDetail(5, 0.7);
	
	colorMode(HSB, 360, 1, 1, 1);
	
	rectMode(CENTER);
	
	noStroke();
	
	background(0);
	/*
	for (let i = 0; i < width * height; i += 1) {
		//particl[i] = { x: random(0, width), y: random(0, height) };
		particl[i] = { x: i % width, y: floor(i / width), vx: 1, vy: 1 };
	}
	*/
	for (let i = 0; i < 10000; i += 1) {
		particl[i] = { x: random(0, width), y: random(0, height), b: 0 };
	}
	
	generateNormals(fun[0]);
}

function generateNormals(f) {
	stroke(0, 0.5, 1, 1);
	
	let offx = random(0, 1);
	
	for (let y = 0; y < height; y += 1) {
		for (let x = 0; x < width; x += 1) {
			let nx = x / width;
			let ny = y / height;
			
			//let n = noise(nx * 4, ny * 4); // sampled point
			
			let nx0 = noise(nx * 4 - 0.05 + offx, ny * 1); // left
			let nx1 = noise(nx * 4 + 0.05 + offx, ny * 1); // right
			let ny1 = noise(nx * 4 + offx, ny * 4 + 0.05); // top
			let ny0 = noise(nx * 4 + offx, ny * 4 - 0.05); // bottom
			
			let dzdx= (nx1-nx0) / 2;
			let dzdy= (ny1-ny0) / 2;
			
			// vector length
			let len = sqrt((dzdx * dzdx) + (dzdy * dzdy))+0.001;
			
			// normalize
			dzdx /= len;
			dzdy /= len;
			
			normals[x + y * width] = f(nx, ny, dzdx, dzdy);
			
			// line(x, y, x + -dzdx * 1, y + -dzdy * 1);
		}
	}
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	rectMode(CORNERS);
	
	noStroke();
	fill(0, 0, 0, 0.25);
	rect(0, 0, width, height);
	
	if (frameCount % 60 == 0) {
		fun_index += 1;
		fun_index %= fun.length;
		
		//generateNormals(fun[fun_index]);
	}
	
	rectMode(CENTER);
	//background(0);
/*
  // display noise map
	for (let y = 0; y < 800; y += 16) {
		for (let x = 0; x < 800; x += 16) {
			let nx = x / 800;
			let ny = y / 800;
			
			let n = noise(nx * 4, ny * 4);
			
			fill(0, 0, pow(n, 1.25), 1);
			rect(x, y, 16, 16);
		}
	}
*/
	
	noStroke();
	fill(0, 0, 1, 1);
	//loadPixels();
	for (let i = 1; i < 7000; i += 1) {
		let p = particl[i];
		//let p2 = particl[i-1];

		let px = floor(p.x);
		let py = floor(p.y);

		let index2 = px + py * width;
		let d = normals[index2];

		fill(170 + abs(p.b) / width % 100, abs(p.b / width) / 512%0.6, 1, 1);
		//pixels[(px + py * width) * 4+0] = d.b;
		//pixels[(px + py * width) * 4+1] = d.b;
		//pixels[(px + py * width) * 4+2] = d.b;
		rect(px, py, 1, 1);
		//point(px, py);
		//line(px, py, floor(p2.x), floor(p2.y));

		p.x += d.x;
		p.y += d.y;
		p.b += d.x * d.y * 10000;
/*
		if (frameCount % 500 > 240) {*/
			//d.x += (p.x / width*2-1) / 2;
			//d.y += (p.y / height*2-1) / 2;
	/*	} else {
			d.x -= (p.x / width*2-1) / 2;
			d.y -= (p.y / height*2-1) / 2;
		}*/
		/*
		if (floor(p.x) == width/2) {
			p.x = 0;//(random() > 0.5) ? 0 : width - 1;
		}
		if (floor(p.y) == width/2) {
			p.y = 0;//(random() > 0.5) ? 0 : height - 1;
		}*/
		if (p.x > width) {
			p.x = random(width/2 - 24, width/2 + 24);
		}
		if (p.y > height) {
			p.y = random(height/2 - 24, height/2 + 24);
		}
		if (p.x < 0) {
			p.x = random(width/2 - 24, width/2 + 24);
		}
		if (p.y < 0) {
			p.y = random(height/2 - 24, height/2 + 24);
		}
	}
	//updatePixels();
	
	xmotion += 0.1;
	ymotion += 0.0075;
}"
"1004782","Flow field²","mySketch","// simple vector field with a twist

let normals = [];
let particl = [];

let fun_index = 0;

const fun = [
	(nx, ny, nx2, ny2) => { return { x: sin(nx * PI * 3 + cos(ny * PI * 2) * PI * 2) * (0.5-noise(nx * 1))*2, y: cos(ny * PI * 4 + pow(sin(nx * PI * 2), 2) * PI * 2) * (0.5-noise(ny * 1))*2, b: 0} }
];

function setup() {
	createCanvas(600, 600);
	background(100);
	
	noiseDetail(5, 0.7);
	
	colorMode(HSB, 360, 1, 1, 1);
	
	rectMode(CENTER);
	
	noStroke();
	
	background(0);
	/*
	for (let i = 0; i < width * height; i += 1) {
		//particl[i] = { x: random(0, width), y: random(0, height) };
		particl[i] = { x: i % width, y: floor(i / width), vx: 1, vy: 1 };
	}
	*/
	for (let i = 0; i < 10000; i += 1) {
		particl[i] = { x: random(0, width), y: random(0, height), b: 0, bl: noise(i/10000*4) > 0.5 ? 1: 0.0, a: random()/4 };
	}
	
	generateNormals(fun[0]);
}

function generateNormals(f) {
	stroke(0, 0.5, 1, 1);
	
	let offx = random(0, 1);
	
	for (let y = 0; y < height; y += 1) {
		for (let x = 0; x < width; x += 1) {
			let nx = x / width;
			let ny = y / height;
			
			//let n = noise(nx * 4, ny * 4); // sampled point
			
			let nx0 = noise(nx * 4 - 0.05 + offx, ny * 1); // left
			let nx1 = noise(nx * 4 + 0.05 + offx, ny * 1); // right
			let ny1 = noise(nx * 4 + offx, ny * 4 + 0.05); // top
			let ny0 = noise(nx * 4 + offx, ny * 4 - 0.05); // bottom
			
			let dzdx= (nx1-nx0) / 2;
			let dzdy= (ny1-ny0) / 2;
			
			// vector length
			let len = sqrt((dzdx * dzdx) + (dzdy * dzdy))+0.001;
			
			// normalize
			dzdx /= len;
			dzdy /= len;
			
			normals[x + y * width] = f(nx, ny, dzdx, dzdy);
			
			// line(x, y, x + -dzdx * 1, y + -dzdy * 1);
		}
	}
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	rectMode(CORNERS);
	
	noStroke();
	fill(0, 0, 0, max(0, 1-(frameCount/ 100)));
	rect(0, 0, width, height);
	
	if (frameCount % 60 == 0) {
		fun_index += 1;
		fun_index %= fun.length;
		
		//generateNormals(fun[fun_index]);
	}
	
	rectMode(CENTER);
	//background(0);
/*
  // display noise map
	for (let y = 0; y < 800; y += 16) {
		for (let x = 0; x < 800; x += 16) {
			let nx = x / 800;
			let ny = y / 800;
			
			let n = noise(nx * 4, ny * 4);
			
			fill(0, 0, pow(n, 1.25), 1);
			rect(x, y, 16, 16);
		}
	}
*/
	
	noStroke();
	fill(0, 0, 1, 1);
	//loadPixels();
	for (let i = 1; i < 7000; i += 1) {
		let p = particl[i];
		//let p2 = particl[i-1];

		let px = floor(p.x);
		let py = floor(p.y);

		let index2 = px + py * width;
		let d = normals[index2];

		fill(170 + abs(p.b) / width % 100, abs(p.b / width) / 512%1, p.bl, p.a);
		//pixels[(px + py * width) * 4+0] = d.b;
		//pixels[(px + py * width) * 4+1] = d.b;
		//pixels[(px + py * width) * 4+2] = d.b;
		rect(px, py, 1, 1);
		//point(px, py);
		//line(px, py, floor(p2.x), floor(p2.y));

		p.x += d.x;
		p.y += d.y;
		p.b += d.x * d.y * 10000;
/*
		if (frameCount % 500 > 240) {*/
			//d.x += (p.x / width*2-1) / 2;
			//d.y += (p.y / height*2-1) / 2;
	/*	} else {
			d.x -= (p.x / width*2-1) / 2;
			d.y -= (p.y / height*2-1) / 2;
		}*/
		/*
		if (floor(p.x) == width/2) {
			p.x = 0;//(random() > 0.5) ? 0 : width - 1;
		}
		if (floor(p.y) == width/2) {
			p.y = 0;//(random() > 0.5) ? 0 : height - 1;
		}*/
		if (p.x > width) {
			p.x = random(width/2 - 24, width/2 + 24);
		}
		if (p.y > height) {
			p.y = random(height/2 - 24, height/2 + 24);
		}
		if (p.x < 0) {
			p.x = random(width/2 - 24, width/2 + 24);
		}
		if (p.y < 0) {
			p.y = random(height/2 - 24, height/2 + 24);
		}
	}
	//updatePixels();
	
	xmotion += 0.1;
	ymotion += 0.0075;
}"
"1004782","Flow field²","mySketch","// simple vector field with a twist

let normals = [];
let particl = [];

let fun_index = 0;

const fun = [
	(nx, ny, nx2, ny2) => { return { x: sin(nx * PI * 3 + cos(ny * PI * 2) * PI * 2), y: cos(ny * PI * 4 + pow(sin(nx * PI * 2), 2) * PI * 2), b: 0} }
];

function setup() {
	createCanvas(600, 600);
	background(100);
	
	noiseDetail(5, 0.7);
	
	colorMode(HSB, 360, 1, 1, 1);
	
	rectMode(CENTER);
	
	noStroke();
	
	background(0);
	/*
	for (let i = 0; i < width * height; i += 1) {
		//particl[i] = { x: random(0, width), y: random(0, height) };
		particl[i] = { x: i % width, y: floor(i / width), vx: 1, vy: 1 };
	}
	*/
	for (let i = 0; i < 10000; i += 1) {
		particl[i] = { x: random(0, width), y: random(0, height), b: 0, bl: noise(i/10000*4) > 0.5 ? 1: 0.0, a: random()/4 };
	}
	
	generateNormals(fun[0]);
}

function generateNormals(f) {
	stroke(0, 0.5, 1, 1);
	
	let offx = random(0, 1);
	
	for (let y = 0; y < height; y += 1) {
		for (let x = 0; x < width; x += 1) {
			let nx = x / width;
			let ny = y / height;
			
			//let n = noise(nx * 4, ny * 4); // sampled point
			
			let nx0 = noise(nx * 4 - 0.05 + offx, ny * 1); // left
			let nx1 = noise(nx * 4 + 0.05 + offx, ny * 1); // right
			let ny1 = noise(nx * 4 + offx, ny * 4 + 0.05); // top
			let ny0 = noise(nx * 4 + offx, ny * 4 - 0.05); // bottom
			
			let dzdx= (nx1-nx0) / 2;
			let dzdy= (ny1-ny0) / 2;
			
			// vector length
			let len = sqrt((dzdx * dzdx) + (dzdy * dzdy))+0.001;
			
			// normalize
			dzdx /= len;
			dzdy /= len;
			
			normals[x + y * width] = f(nx, ny, dzdx, dzdy);
			
			// line(x, y, x + -dzdx * 1, y + -dzdy * 1);
		}
	}
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	rectMode(CORNERS);
	
	noStroke();
	fill(0, 0, 0, max(0, 1-(frameCount/ 100)));
	rect(0, 0, width, height);
	
	if (frameCount % 60 == 0) {
		fun_index += 1;
		fun_index %= fun.length;
		
		//generateNormals(fun[fun_index]);
	}
	
	rectMode(CENTER);
	//background(0);
/*
  // display noise map
	for (let y = 0; y < 800; y += 16) {
		for (let x = 0; x < 800; x += 16) {
			let nx = x / 800;
			let ny = y / 800;
			
			let n = noise(nx * 4, ny * 4);
			
			fill(0, 0, pow(n, 1.25), 1);
			rect(x, y, 16, 16);
		}
	}
*/
	
	noStroke();
	fill(0, 0, 1, 1);
	//loadPixels();
	for (let i = 1; i < 7000; i += 1) {
		let p = particl[i];
		//let p2 = particl[i-1];

		let px = floor(p.x);
		let py = floor(p.y);

		let index2 = px + py * width;
		let d = normals[index2];

		fill(170 + abs(p.b) / width % 100, abs(p.b / width) / 512%1, p.bl, p.a);
		//pixels[(px + py * width) * 4+0] = d.b;
		//pixels[(px + py * width) * 4+1] = d.b;
		//pixels[(px + py * width) * 4+2] = d.b;
		rect(px, py, 1, 1);
		//point(px, py);
		//line(px, py, floor(p2.x), floor(p2.y));

		p.x += d.x;
		p.y += d.y;
		p.b += d.x * d.y * 10000;
/*
		if (frameCount % 500 > 240) {*/
			//d.x += (p.x / width*2-1) / 2;
			//d.y += (p.y / height*2-1) / 2;
	/*	} else {
			d.x -= (p.x / width*2-1) / 2;
			d.y -= (p.y / height*2-1) / 2;
		}*/
		/*
		if (floor(p.x) == width/2) {
			p.x = 0;//(random() > 0.5) ? 0 : width - 1;
		}
		if (floor(p.y) == width/2) {
			p.y = 0;//(random() > 0.5) ? 0 : height - 1;
		}*/
		if (p.x > width) {
			p.x = random(width/2 - 24, width/2 + 24);
		}
		if (p.y > height) {
			p.y = random(height/2 - 24, height/2 + 24);
		}
		if (p.x < 0) {
			p.x = random(width/2 - 24, width/2 + 24);
		}
		if (p.y < 0) {
			p.y = random(height/2 - 24, height/2 + 24);
		}
	}
	//updatePixels();
	
	xmotion += 0.1;
	ymotion += 0.0075;
}"
"1004772","Flow field","mySketch","// simple vector field with a twist

let normals = [];
let particl = [];

let fun_index = 0;

const fun = [
	(nx, ny) => { return { x: sin(nx * PI * 2 + cos(ny * PI * 2) * PI * 4), y: cos(ny * PI * 2 + sin(nx * PI * 2) * PI * 4) } }
];

function setup() {
	createCanvas(600, 600);
	background(100);
	
	noiseDetail(4, 0.7);
	
	colorMode(HSB, 360, 1, 1, 1);
	
	rectMode(CENTER);
	
	noStroke();
	
	background(0);
	/*
	for (let i = 0; i < width * height; i += 1) {
		//particl[i] = { x: random(0, width), y: random(0, height) };
		particl[i] = { x: i % width, y: floor(i / width), vx: 1, vy: 1 };
	}
	*/
	for (let i = 0; i < 50000; i += 1) {
		particl[i] = { x: random(0, width), y: random(0, height), b: 0 };
	}
	
	generateNormals(fun[0]);
}

function generateNormals(f) {
	stroke(0, 0.5, 1, 1);
	
	let offx = random(0, 1);
	
	for (let y = 0; y < height; y += 1) {
		for (let x = 0; x < width; x += 1) {
			let nx = x / width;
			let ny = y / height;
			
			//let n = noise(nx * 4, ny * 4); // sampled point
			
			let nx0 = noise(nx * 4 - 0.05 + offx, ny * 1); // left
			let nx1 = noise(nx * 4 + 0.05 + offx, ny * 1); // right
			let ny1 = noise(nx * 4 + offx, ny * 4 + 0.05); // top
			let ny0 = noise(nx * 4 + offx, ny * 4 - 0.05); // bottom
			
			let dzdx= (nx1-nx0) / 2;
			let dzdy= (ny1-ny0) / 2;
			
			// vector length
			let len = sqrt((dzdx * dzdx) + (dzdy * dzdy))+0.001;
			
			// normalize
			dzdx /= len;
			dzdy /= len;
			
			normals[x + y * width] = f(nx, ny);
			
			// line(x, y, x + -dzdx * 1, y + -dzdy * 1);
		}
	}
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	rectMode(CORNERS);
	
	noStroke();
	fill(0, 0, 0, 0.25);
	rect(0, 0, width, height);
	
	if (frameCount % 60 == 0) {
		fun_index += 1;
		fun_index %= fun.length;
		
		//generateNormals(fun[fun_index]);
	}
	
	rectMode(CENTER);
	//background(0);
/*
  // display noise map
	for (let y = 0; y < 800; y += 16) {
		for (let x = 0; x < 800; x += 16) {
			let nx = x / 800;
			let ny = y / 800;
			
			let n = noise(nx * 4, ny * 4);
			
			fill(0, 0, pow(n, 1.25), 1);
			rect(x, y, 16, 16);
		}
	}
*/
	
	noStroke();
	fill(0, 0, 1, 1);
	//loadPixels();
	for (let i = 1; i < 10000; i += 1) {
		let p = particl[i];
		//let p2 = particl[i-1];

		let px = floor(p.x);
		let py = floor(p.y);

		let index2 = px + py * width;
		let d = normals[index2];

		fill(170 + abs(p.b) / width % 100, abs(p.b / width) / 512, 1, 1);
		//pixels[(px + py * width) * 4+0] = d.b;
		//pixels[(px + py * width) * 4+1] = d.b;
		//pixels[(px + py * width) * 4+2] = d.b;
		rect(px, py, 1, 1);
		//point(px, py);
		//line(px, py, floor(p2.x), floor(p2.y));

		p.x += d.x;
		p.y += d.y;
		p.b += d.x * d.y * 10000;
/*
		if (frameCount % 500 > 240) {*/
			d.x += (p.x / width*2-1) / 2;
			d.y += (p.y / height*2-1) / 2;
	/*	} else {
			d.x -= (p.x / width*2-1) / 2;
			d.y -= (p.y / height*2-1) / 2;
		}*/
		/*
		if (floor(p.x) == width/2) {
			p.x = 0;//(random() > 0.5) ? 0 : width - 1;
		}
		if (floor(p.y) == width/2) {
			p.y = 0;//(random() > 0.5) ? 0 : height - 1;
		}*/
		if (p.x > width) {
			p.x = random(width/2 - 24, width/2 + 24);
		}
		if (p.y > height) {
			p.y = random(height/2 - 24, height/2 + 24);
		}
		if (p.x < 0) {
			p.x = random(width/2 - 24, width/2 + 24);
		}
		if (p.y < 0) {
			p.y = random(height/2 - 24, height/2 + 24);
		}
	}
	//updatePixels();
	
	xmotion += 0.1;
	ymotion += 0.0075;
}"
"1004772","Flow field","mySketch","// simple vector field with a twist

let normals = [];
let particl = [];

let fun_index = 0;

const fun = [
	(nx, ny) => { return { x: sin(nx * PI * 2 + cos(ny * PI * 2) * PI * 4), y: cos(ny * PI * 2 + sin(nx * PI * 2) * PI * 4) } }
];

function setup() {
	createCanvas(600, 600);
	background(100);
	
	noiseDetail(4, 0.7);
	
	colorMode(HSB, 360, 1, 1, 1);
	
	rectMode(CENTER);
	
	noStroke();
	
	background(0);
	/*
	for (let i = 0; i < width * height; i += 1) {
		//particl[i] = { x: random(0, width), y: random(0, height) };
		particl[i] = { x: i % width, y: floor(i / width), vx: 1, vy: 1 };
	}
	*/
	for (let i = 0; i < 5000; i += 1) {
		particl[i] = { x: random(0, width), y: random(0, height), b: 0 };
	}
	
	generateNormals(fun[0]);
}

function generateNormals(f) {
	stroke(0, 0.5, 1, 1);
	
	let offx = random(0, 1);
	
	for (let y = 0; y < height; y += 1) {
		for (let x = 0; x < width; x += 1) {
			let nx = x / width;
			let ny = y / height;
			
			//let n = noise(nx * 4, ny * 4); // sampled point
			
			let nx0 = noise(nx * 4 - 0.05 + offx, ny * 1); // left
			let nx1 = noise(nx * 4 + 0.05 + offx, ny * 1); // right
			let ny1 = noise(nx * 4 + offx, ny * 4 + 0.05); // top
			let ny0 = noise(nx * 4 + offx, ny * 4 - 0.05); // bottom
			
			let dzdx= (nx1-nx0) / 2;
			let dzdy= (ny1-ny0) / 2;
			
			// vector length
			let len = sqrt((dzdx * dzdx) + (dzdy * dzdy))+0.001;
			
			// normalize
			dzdx /= len;
			dzdy /= len;
			
			normals[x + y * width] = f(nx, ny);
			
			// line(x, y, x + -dzdx * 1, y + -dzdy * 1);
		}
	}
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	rectMode(CORNERS);
	
	noStroke();
	fill(0, 0, 0, 0.25);
	rect(0, 0, width, height);
	
	if (frameCount % 60 == 0) {
		fun_index += 1;
		fun_index %= fun.length;
		
		//generateNormals(fun[fun_index]);
	}
	
	rectMode(CENTER);
	//background(0);
/*
  // display noise map
	for (let y = 0; y < 800; y += 16) {
		for (let x = 0; x < 800; x += 16) {
			let nx = x / 800;
			let ny = y / 800;
			
			let n = noise(nx * 4, ny * 4);
			
			fill(0, 0, pow(n, 1.25), 1);
			rect(x, y, 16, 16);
		}
	}
*/
	
	noStroke();
	fill(0, 0, 1, 1);
	//loadPixels();
	for (let i = 1; i < 5000; i += 1) {
		let p = particl[i];
		//let p2 = particl[i-1];

		let px = floor(p.x);
		let py = floor(p.y);

		let index2 = px + py * width;
		let d = normals[index2];

		fill(170 + abs(p.b) / width % 100, abs(p.b / width) / 512 % 1, 1, 1);
		//pixels[(px + py * width) * 4+0] = d.b;
		//pixels[(px + py * width) * 4+1] = d.b;
		//pixels[(px + py * width) * 4+2] = d.b;
		rect(px, py, 1, 1);
		//point(px, py);
		//line(px, py, floor(p2.x), floor(p2.y));

		p.x += d.x;
		p.y += d.y;
		p.b += d.x * d.y * 10000;

		if (frameCount % 1000 < 500) {
			d.x += (p.x / width*2-1) / 2;
			d.y += (p.y / height*2-1) / 2;
		} else {
			d.x -= (p.x / width*2-1) / 2;
			d.y -= (p.y / height*2-1) / 2;
		}
		/*
		if (floor(p.x) == width/2) {
			p.x = 0;//(random() > 0.5) ? 0 : width - 1;
		}
		if (floor(p.y) == width/2) {
			p.y = 0;//(random() > 0.5) ? 0 : height - 1;
		}*/
		if (p.x > width) {
			p.x = random(width/2 - 24, width/2 + 24);
		}
		if (p.y > height) {
			p.y = random(height/2 - 24, height/2 + 24);
		}
		if (p.x < 0) {
			p.x = random(width/2 - 24, width/2 + 24);
		}
		if (p.y < 0) {
			p.y = random(height/2 - 24, height/2 + 24);
		}
	}
	//updatePixels();
	
	xmotion += 0.1;
	ymotion += 0.0075;
}"
"1003145","Piranha plant","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 6;

function setup() {
  createCanvas(800, 800);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (2.25), y: (width / (1) + x - y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.25 * x) / 1 + j * 90, y: (height / 4 - y * 1 / j + (x / 2.0)) / 1.0 + j * (50) };
}

function f3(x, y, j) {
	return { x: (width * 0.5 - x * j) / (16 * (j / 9) + x / (width / (1.85))), y: y / 1.95 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (3.25) - x + y / (1.95 * j * ((0.5 - y / width) * 10))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 10, y: (height / 2 - y * 1.15 / j + (x / 10.075)) / 1.75 + j * (50) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (4.0 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 5; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let nx1 = y[j] / height*2.-1;
				let inx1 = 0.95+pow(1-nx1, 3);
				let nx2 = y2[j] / height;
				let inx2 = 0.45+pow(nx2, 0.5);
				
				let e = 0.75;

				if (iter > 20) {
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 255, 0.0225 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);
					//point(width - x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					//point(x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					
					//point(x2[j] * inx2+5, height / 1 - y2[j]/2.5);
					//point(width - x2[j] * inx2-5, height / 1 - y2[j]/2.5);
					point(width / 2 - x[j] / 8.25 * inx1, height - y[j]/2.0);
					//point(width / 2 + x[j] / 8.25 * inx1, y[j]/2.0);
					//point(width / 2 - x[j] / 4, y[j]/3);
					//point(width / 2 + x[j] / 4, y[j]/3);
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"997777","t10","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 7;

function setup() {
  createCanvas(800, 800);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (2.25), y: (width / (1.0) + x - y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.25 * x) / 1 + j * 40, y: (height / 4 - y * 2 / j + (x / 2.0)) / 1.0 + j * (100) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 - x * j) / (1 * (j / 1) + x / (width / (5.85))), y: y / 1.75 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (3.25) - x + y / (1.95 * j * ((0.5 - y / width) * 10))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 10, y: (height / 2 - y * 1.15 / j + (x / 10.075)) / 1.75 + j * (50) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (4.0 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 5; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let nx1 = y[j] / height;
				let inx1 = 0.75+pow(1-nx1, 2);
				let nx2 = y2[j] / height;
				let inx2 = 0.45+pow(nx2, 0.5);
				
				let e = 0.75;

				if (iter > 20) {
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.0225 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);
					//point(width - x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					//point(x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					
					point(y[j] / 4 * inx1-width / 8, height / 1. - x[j]/4.0);
					point(width - y[j]/4 * inx1-5+width / 8, height / 1. - x[j]/4.0);
					point(width / 2 - x[j] / 3 * inx1, y[j]/2.5);
					point(width / 2 + x[j] / 3 * inx1, y[j]/2.5);
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"994293","S18","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 6;

function setup() {
  createCanvas(800, 800);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (2.25), y: (width / (1.0) + x - y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.25 * (x - y / 20)) / 1 + j * (90 - x / 80), y: (height / 4 - y * 2 / j + (x / 2.0)) / 1.0 + j * (70 + y / 40) };
}

function f3(x, y, j) {
	return { x: (width * 0.5 - x * j) / (16 * (j / 9) + x / (width / 1.85)), y: y / 1.95 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.25), y: (width / (1.0) + x - y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.25 * (x - y / 20)) / 1 + j * (50 - x / 80), y: (height / 8 - y * 3 / j + (x / 2.0)) / 1.0 + j * (20 + y / 40) };
}

function f6(x, y, j) {
	return { x: (width * 0.5 - x * j) / (16 * (j / 9) + x / (width / (7.85))), y: y / 2.0 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 5; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let nx1 = y[j] / height * 2.0 - 1;
				let inx1 = 0.25+pow(1-nx1, 1);
				let nx2 = y2[j] / height;
				let inx2 = 0.45+pow(nx2, 0.5);
				
				let e = 0.75;

				if (iter > 20) {
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.0225 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);
					//point(width - x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					//point(x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					
					//point(x2[j] * inx2+5, height / 1 - y2[j]/2.5);
					//point(width - x2[j] * inx2-5, height / 1 - y2[j]/2.5);
					point(width / 2 - x[j] / 4.25 * inx1 + 180, y[j]/2.0);
					point(width / 2 + x[j] / 4.25 * inx1 - 180, y[j]/2.0);

					point(y[j] / 4.25 * inx1 + 100, height - x[j]/2.5);
					point(width - y[j] / 4.25 * inx1 - 100, height - x[j]/2.5);
					
					//point(x2[j] / 2.25 * inx1, y2[j]/4.75);
					//point(width - x2[j] / 2.25 * inx1, y2[j]/4.75);
					
					//point(width / 2 - x[j] / 4, y[j]/3);
					//point(width / 2 + x[j] / 4, y[j]/3);
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"994283","S17","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 6;

function setup() {
  createCanvas(800, 800);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (2.25), y: (width / (1.0) + x - y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.25 * (x - y / 20)) / 1 + j * (90 - x / 40), y: (height / 4 - y * 2 / j + (x / 2.0)) / 1.0 + j * (70 + y / 40) };
}

function f3(x, y, j) {
	return { x: (width * 0.5 - x * j) / (16 * (j / 9) + x / (width / (1.85))), y: y / 1.95 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.25), y: (width / (1.0) + x - y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.25 * (x - y / 20)) / 1 + j * (50 - x / 80), y: (height / 8 - y * 3 / j + (x / 2.0)) / 1.0 + j * (20 + y / 40) };
}

function f6(x, y, j) {
	return { x: (width * 0.5 - x * j) / (16 * (j / 9) + x / (width / (7.85))), y: y / 2.0 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 5; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let nx1 = y[j] / height;
				let inx1 = 0.75+pow(1-nx1, 2);
				let nx2 = y2[j] / height;
				let inx2 = 0.45+pow(nx2, 0.5);
				
				let e = 0.75;

				if (iter > 20) {
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.0225 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);
					//point(width - x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					//point(x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					
					//point(x2[j] * inx2+5, height / 1 - y2[j]/2.5);
					//point(width - x2[j] * inx2-5, height / 1 - y2[j]/2.5);
					point(width / 2 - x[j] / 3.25 * inx1, y[j]/2.5);
					point(width / 2 + x[j] / 3.25 * inx1, y[j]/2.5);
					
					point(x2[j] / 2.25 * inx1, y2[j]/1.75);
					point(width - x2[j] / 2.25 * inx1, y2[j]/1.75);
					//point(width / 2 - x[j] / 4, y[j]/3);
					//point(width / 2 + x[j] / 4, y[j]/3);
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"993871","T1","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 6;

function setup() {
  createCanvas(800, 800);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (2.25), y: (width / (1.0) + x - y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.25 * x) / 1 + j * 90, y: (height / 4 - y * 2 / j + (x / 2.0)) / 1.0 + j * (70) };
}

function f3(x, y, j) {
	return { x: (width * 0.5 - x * j) / (16 * (j / 9) + x / (width / (5.85))), y: y / 1.95 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (3.25) - x + y / (1.95 * j * ((0.5 - y / width) * 10))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 10, y: (height / 2 - y * 1.15 / j + (x / 10.075)) / 1.75 + j * (50) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (4.0 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 5; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let nx1 = y[j] / height;
				let inx1 = 0.75+pow(1-nx1, 2);
				let nx2 = y2[j] / height;
				let inx2 = 0.45+pow(nx2, 0.5);
				
				let e = 0.75;

				if (iter > 20) {
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.0225 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);
					//point(width - x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					//point(x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					
					//point(x2[j] * inx2+5, height / 1 - y2[j]/2.5);
					//point(width - x2[j] * inx2-5, height / 1 - y2[j]/2.5);
					point(width / 2 - x[j] / 4.25 * inx1, y[j]/4.0);
					point(width / 2 + x[j] / 4.25 * inx1, y[j]/4.0);
					
					point(x[j] / 4.25 * inx1, height - y[j]/3.0);
					point(width - x[j] / 4.25 * inx1, height - y[j]/3.0);
					//point(width / 2 - x[j] / 4, y[j]/3);
					//point(width / 2 + x[j] / 4, y[j]/3);
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"993852","S15","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 6;

function setup() {
  createCanvas(800, 800);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (2.25), y: (width / (1.0) + x - y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.25 * x) / 1 + j * 90, y: (height / 4 - y * 1 / j + (x / 2.0)) / 1.0 + j * (70) };
}

function f3(x, y, j) {
	return { x: (width * 0.5 - x * j) / (16 * (j / 9) + x / (width / (5.85))), y: y / 1.95 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (3.25) - x + y / (1.95 * j * ((0.5 - y / width) * 10))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 10, y: (height / 2 - y * 1.15 / j + (x / 10.075)) / 1.75 + j * (50) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (4.0 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 5; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let nx1 = y[j] / height;
				let inx1 = 0.75+pow(1-nx1, 2);
				let nx2 = y2[j] / height;
				let inx2 = 0.45+pow(nx2, 0.5);
				
				let e = 0.75;

				if (iter > 20) {
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.0225 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);
					//point(width - x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					//point(x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					
					//point(x2[j] * inx2+5, height / 1 - y2[j]/2.5);
					//point(width - x2[j] * inx2-5, height / 1 - y2[j]/2.5);
					point(width / 2 - x[j] / 4.25, y[j]/3.0);
					point(width / 2 + x[j] / 4.25, y[j]/3.0);
					//point(width / 2 - x[j] / 4, y[j]/3);
					//point(width / 2 + x[j] / 4, y[j]/3);
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"991241","E11","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 6;

function setup() {
  createCanvas(800, 800);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (2.25), y: (width / (1.5-j/8) + x - y / (0.45 * j * ((0.5 - y / width) * 8))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.0 * x) / 1 + j * 80, y: (height / 2 - y * 3 / j + (x / 2.0)) / 1.0 + j * (100) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 - x * j) / (4 * (j / 9) + x / (width / (8.85))), y: y / 1.95 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (3.25) - x + y / (1.95 * j * ((0.5 - y / width) * 10))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 10, y: (height / 2 - y * 1.15 / j + (x / 10.075)) / 1.75 + j * (50) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (4.0 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 10000; i += 1) {
			for (let j = 5; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let nx1 = y[j] / height;
				let inx1 = 0.75+pow(1-nx1, 2);
				let nx2 = y2[j] / height;
				let inx2 = 0.45+pow(nx2, 0.5);
				
				let e = 0.75;

				if (iter > 20) {
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.0325 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);
					//point(width - x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					//point(x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					
					//point(x2[j] * inx2+5, height / 1 - y2[j]/2.5);
					//point(width - x2[j] * inx2-5, height / 1 - y2[j]/2.5);
					point(width / 2 - x[j] / 3.5, y[j]/3);
					point(width / 2 + x[j] / 3.5, y[j]/3);
					//point(width / 2 - x[j] / 4, y[j]/3);
					//point(width / 2 + x[j] / 4, y[j]/3);
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"991235","M11","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 6;

function setup() {
  createCanvas(800, 800);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (2.25), y: (width / (1.5-j/8) + x - y / (0.45 * j * ((0.5 - y / width) * 8))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.25 * x) / 1 + j * 90, y: (height / 2 - y * 3 / j + (x / 2.0)) / 1.0 + j * (100) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 - x * j) / (4 * (j / 1) + x / (width / (8.85))), y: y / 1.95 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (3.25) - x + y / (1.95 * j * ((0.5 - y / width) * 10))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 10, y: (height / 2 - y * 1.15 / j + (x / 10.075)) / 1.75 + j * (50) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (4.0 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 5; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let nx1 = y[j] / height;
				let inx1 = 0.75+pow(1-nx1, 2);
				let nx2 = y2[j] / height;
				let inx2 = 0.45+pow(nx2, 0.5);
				
				let e = 0.75;

				if (iter > 20) {
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.0525 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);
					//point(width - x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					//point(x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					
					//point(x2[j] * inx2+5, height / 1 - y2[j]/2.5);
					//point(width - x2[j] * inx2-5, height / 1 - y2[j]/2.5);
					point(width / 2 - x[j] / 4.5, y[j]/3);
					point(width / 2 + x[j] / 4.5, y[j]/3);
					//point(width / 2 - x[j] / 4, y[j]/3);
					//point(width / 2 + x[j] / 4, y[j]/3);
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"991231","R11","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 6;

function setup() {
  createCanvas(800, 800);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (2.25), y: (width / (1.5-j/8) + x - y / (0.45 * j * ((0.5 - y / width) * 8))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.25 * x) / 1 + j * 90, y: (height / 2 - y * 3 / j + (x / 2.0)) / 1.0 + j * (100) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 - x * j) / (4 * (j / 9) + x / (width / (8.85))), y: y / 1.95 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (3.25) - x + y / (1.95 * j * ((0.5 - y / width) * 10))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 10, y: (height / 2 - y * 1.15 / j + (x / 10.075)) / 1.75 + j * (50) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (4.0 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 5; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let nx1 = y[j] / height;
				let inx1 = 0.75+pow(1-nx1, 2);
				let nx2 = y2[j] / height;
				let inx2 = 0.45+pow(nx2, 0.5);
				
				let e = 0.75;

				if (iter > 20) {
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.0225 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);
					//point(width - x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					//point(x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					
					//point(x2[j] * inx2+5, height / 1 - y2[j]/2.5);
					//point(width - x2[j] * inx2-5, height / 1 - y2[j]/2.5);
					point(width / 2 - x[j] / 4, y[j]/2.5);
					point(width / 2 + x[j] / 4, y[j]/2.5);
					//point(width / 2 - x[j] / 4, y[j]/3);
					//point(width / 2 + x[j] / 4, y[j]/3);
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"991226","S15","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 6;

function setup() {
  createCanvas(800, 800);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (2.25), y: (width / (1.0) + x - y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.5 * x) / 1 + j * 90, y: (height / 4 - y * 2 / j + (x / 1.0)) / 1.0 + j * (1) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 - x * j) / (6 * (j / 9) + x / (width / (6.85))), y: y / 1.95 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (3.25) - x + y / (1.95 * j * ((0.5 - y / width) * 10))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 10, y: (height / 2 - y * 1.15 / j + (x / 10.075)) / 1.75 + j * (50) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (4.0 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 5; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let nx1 = y[j] / height;
				let inx1 = 0.75+pow(1-nx1, 2);
				let nx2 = y2[j] / height;
				let inx2 = 0.45+pow(nx2, 0.5);
				
				let e = 0.75;

				if (iter > 20) {
					stroke(210 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.0525 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);
					//point(width - x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					//point(x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					
					//point(x2[j] * inx2+5, height / 1 - y2[j]/2.5);
					//point(width - x2[j] * inx2-5, height / 1 - y2[j]/2.5);
					point(width / 2 - x[j] / 4, y[j]/3);
					point(width / 2 + x[j] / 4, y[j]/3);
					point(x[j] / 6, height - y[j]/4.5);
					point(width - x[j] / 6, height - y[j]/4.5);
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"991194","M42","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 6;

function setup() {
  createCanvas(800, 800);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (1.75), y: (width / (0.8) + x / 1.5 - y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.1 * x) / 1 + j * 90, y: (height / 4 - y * 1 / j + (x / 2.0)) / 1.0 + j * (100) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 - x * j) / (9 * (j / 9) + x / (width / (5.85))), y: y / 1.25 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (3.25) - x + y / (1.95 * j * ((0.5 - y / width) * 10))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 10, y: (height / 2 - y * 1.15 / j + (x / 10.075)) / 1.75 + j * (50) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (4.0 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 5; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let nx1 = y[j] / height;
				let inx1 = 0.75+pow(1-nx1, 2);
				let nx2 = y2[j] / height;
				let inx2 = 0.45+pow(nx2, 0.5);
				
				let e = 0.75;

				if (iter > 20) {
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.0225 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);
					//point(width - x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					//point(x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					
					//point(x2[j] * inx2+5, height / 1 - y2[j]/2.5);
					//point(width - x2[j] * inx2-5, height / 1 - y2[j]/2.5);
					point(width / 2 - x[j] / 4, y[j]/2.5);
					point(width / 2 + x[j] / 4, y[j]/2.5);
					//point(width / 2 - x[j] / 4, y[j]/3);
					//point(width / 2 + x[j] / 4, y[j]/3);
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"991194","M42","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 6;

function setup() {
  createCanvas(800, 800);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (1.75), y: (width / (0.8) + x / 1.5 - y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.1 * x) / 1 + j * 90, y: (height / 4 - y * 1 / j + (x / 2.0)) / 1.0 + j * (100) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 - x * j) / (9 * (j / 9) + x / (width / (5.85))), y: y / 1.25 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (3.25) - x + y / (1.95 * j * ((0.5 - y / width) * 10))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 10, y: (height / 2 - y * 1.15 / j + (x / 10.075)) / 1.75 + j * (50) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (4.0 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 5; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let nx1 = y[j] / height;
				let inx1 = 0.75+pow(1-nx1, 2);
				let nx2 = y2[j] / height;
				let inx2 = 0.45+pow(nx2, 0.5);
				
				let e = 0.75;

				if (iter > 20) {
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.0125 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);
					//point(width - x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					//point(x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					
					//point(x2[j] * inx2+5, height / 1 - y2[j]/2.5);
					//point(width - x2[j] * inx2-5, height / 1 - y2[j]/2.5);
					point(width / 2 - x[j] / 3.75, y[j]/2.3-height / 12);
					point(width / 2 + x[j] / 3.75, y[j]/2.3-height / 12);
					//point(width / 2 - x[j] / 4, y[j]/3);
					//point(width / 2 + x[j] / 4, y[j]/3);
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"991187","F8","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 6;

function setup() {
  createCanvas(800, 800);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (2.25), y: (width / (1.0) + x - y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.25 * x) / 1 + j * 60, y: (height / 4 - y * 2 / j + (x / 2.0)) / 1.0 + j * (100) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 - x * j) / (3 * (j / 1) + x / (width / (5.85))), y: y / 1.25 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (3.25) - x + y / (1.95 * j * ((0.5 - y / width) * 10))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 10, y: (height / 2 - y * 1.15 / j + (x / 10.075)) / 1.75 + j * (50) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (4.0 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 5; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let nx1 = y[j] / height;
				let inx1 = 0.75+pow(1-nx1, 2);
				let nx2 = y2[j] / height;
				let inx2 = 0.45+pow(nx2, 0.5);
				
				let e = 0.75;

				if (iter > 20) {
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.0225 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);
					//point(width - x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					//point(x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					
					//point(x2[j] * inx2+5, height / 1 - y2[j]/2.5);
					//point(width - x2[j] * inx2-5, height / 1 - y2[j]/2.5);
					point(width / 2 - x[j] / 4, y[j]/2.5);
					point(width / 2 + x[j] / 4, y[j]/2.5);
					//point(width / 2 - x[j] / 4, y[j]/3);
					//point(width / 2 + x[j] / 4, y[j]/3);
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"991184","O2","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 6;

function setup() {
  createCanvas(800, 800);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (2.25), y: (width / (1.0) + x - y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.25 * x) / 1 + j * 60, y: (height / 4 - y * 2 / j + (x / 2.0)) / 1.0 + j * (180) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 - x * j) / (6 * (j / 9) + x / (width / (5.85))), y: y / 1.25 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (3.25) - x + y / (1.95 * j * ((0.5 - y / width) * 10))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 10, y: (height / 2 - y * 1.15 / j + (x / 10.075)) / 1.75 + j * (50) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (4.0 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 5; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let nx1 = y[j] / height;
				let inx1 = 0.75+pow(1-nx1, 2);
				let nx2 = y2[j] / height;
				let inx2 = 0.45+pow(nx2, 0.5);
				
				let e = 0.75;

				if (iter > 20) {
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.0225 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);
					//point(width - x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					//point(x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					
					//point(x2[j] * inx2+5, height / 1 - y2[j]/2.5);
					//point(width - x2[j] * inx2-5, height / 1 - y2[j]/2.5);
					point(width / 2 - x[j] / 4, y[j]/2.5);
					point(width / 2 + x[j] / 4, y[j]/2.5);
					//point(width / 2 - x[j] / 4, y[j]/3);
					//point(width / 2 + x[j] / 4, y[j]/3);
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"991184","O2","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 6;

function setup() {
  createCanvas(800, 800);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (2.75), y: (width / (1.0) + x - y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.25 * x) / 1 + j * 40, y: (height / 4 - y * 2 / j + (x / 2.0)) / 1.0 + j * (20) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 - x * j) / (4 * (j / 9) + x / (width / (5.85))), y: y / 1.25 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (3.25) - x + y / (1.95 * j * ((0.5 - y / width) * 10))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 10, y: (height / 2 - y * 1.15 / j + (x / 10.075)) / 1.75 + j * (50) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (4.0 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 5; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let nx1 = y[j] / height * 2. - 1.;
				let inx1 = 0.25+pow(1-nx1, 2);
				let nx2 = y2[j] / height;
				let inx2 = 0.45+pow(nx2, 0.5);
				
				let e = 0.75;

				if (iter > 20) {
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.0225 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);
					//point(width - x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					//point(x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					
					//point(x2[j] * inx2+5, height / 1 - y2[j]/2.5);
					//point(width - x2[j] * inx2-5, height / 1 - y2[j]/2.5);
					point(width / 2 - x[j] / 4 * inx1, height - y[j]/2);
					point(width / 2 + x[j] / 4 * inx1, height - y[j]/2);
					point(width - x[j] / 4 * inx1, height - y[j]/2);
					point(x[j] / 4 * inx1, height - y[j]/2);
					//point(width / 2 - x[j] / 4, y[j]/3);
					//point(width / 2 + x[j] / 4, y[j]/3);
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"991180","S14","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 6;

function setup() {
  createCanvas(800, 800);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (2.25), y: (width / (1.0) + x - y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.25 * x) / 1 + j * 90, y: (height / 4 - y * 2 / j + (x / 2.0)) / 1.0 + j * (100) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 - x * j) / (6 * (j / 9) + x / (width / (5.85))), y: y / 1.95 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (3.25) - x + y / (1.95 * j * ((0.5 - y / width) * 10))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 10, y: (height / 2 - y * 1.15 / j + (x / 10.075)) / 1.75 + j * (50) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (4.0 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 5; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let nx1 = y[j] / height;
				let inx1 = 0.75+pow(1-nx1, 2);
				let nx2 = y2[j] / height;
				let inx2 = 0.45+pow(nx2, 0.5);
				
				let e = 0.75;

				if (iter > 20) {
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.0225 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);
					//point(width - x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					//point(x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					
					//point(x2[j] * inx2+5, height / 1 - y2[j]/2.5);
					//point(width - x2[j] * inx2-5, height / 1 - y2[j]/2.5);
					point(width / 2 - x[j] / 4, y[j]/2.5);
					point(width / 2 + x[j] / 4, y[j]/2.5);
					//point(width / 2 - x[j] / 4, y[j]/3);
					//point(width / 2 + x[j] / 4, y[j]/3);
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"991179","D12","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 6;

function setup() {
  createCanvas(800, 800);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (2.25), y: (width / (1.0) + x - y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.25 * x) / 1 + j * 90, y: (height / 4 - y * 2 / j + (x / 2.0)) / 1.0 + j * (100) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 - x * j) / (4 * (j / 9) + x / (width / (8.85))), y: y / 1.95 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (3.25) - x + y / (1.95 * j * ((0.5 - y / width) * 10))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 10, y: (height / 2 - y * 1.15 / j + (x / 10.075)) / 1.75 + j * (50) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (4.0 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 5; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let nx1 = y[j] / height;
				let inx1 = 0.75+pow(1-nx1, 2);
				let nx2 = y2[j] / height;
				let inx2 = 0.45+pow(nx2, 0.5);
				
				let e = 0.75;

				if (iter > 20) {
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.0225 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);
					//point(width - x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					//point(x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					
					//point(x2[j] * inx2+5, height / 1 - y2[j]/2.5);
					//point(width - x2[j] * inx2-5, height / 1 - y2[j]/2.5);
					point(width / 2 - x[j] / 4, y[j]/2.5);
					point(width / 2 + x[j] / 4, y[j]/2.5);
					//point(width / 2 - x[j] / 4, y[j]/3);
					//point(width / 2 + x[j] / 4, y[j]/3);
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"991177","M11","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 6;

function setup() {
  createCanvas(800, 800);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (2.25), y: (width / (2.0) + x - y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.25 * x) / 1 + j * 90, y: (height / 2 - y * 3 / j + (x / 2.0)) / 1.0 + j * (100) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 - x * j) / (4 * (j / 9) + x / (width / (8.85))), y: y / 1.95 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (3.25) - x + y / (1.95 * j * ((0.5 - y / width) * 10))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 10, y: (height / 2 - y * 1.15 / j + (x / 10.075)) / 1.75 + j * (50) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (4.0 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 5; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let nx1 = y[j] / height;
				let inx1 = 0.75+pow(1-nx1, 2);
				let nx2 = y2[j] / height;
				let inx2 = 0.45+pow(nx2, 0.5);
				
				let e = 0.75;

				if (iter > 20) {
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.0225 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);
					//point(width - x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					//point(x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					
					//point(x2[j] * inx2+5, height / 1 - y2[j]/2.5);
					//point(width - x2[j] * inx2-5, height / 1 - y2[j]/2.5);
					point(width / 2 - x[j] / 4, y[j]/2.5);
					point(width / 2 + x[j] / 4, y[j]/2.5);
					//point(width / 2 - x[j] / 4, y[j]/3);
					//point(width / 2 + x[j] / 4, y[j]/3);
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"991163","F10","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 6;

function setup() {
  createCanvas(800, 800);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (2.25), y: abs(width / (2.0) - x + y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.5 * x) / 1 + j * 60, y: (height / 2 - y * 3 / j + (x / 4.0)) / 1.0 + j * (100) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 - x * j) / (4 * (j / 8) + x / (width / (1.85))), y: y / 1.75 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (3.25) - x + y / (1.95 * j * ((0.5 - y / width) * 10))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 1, y: (height / 2 - y * 1.15 / j + (x / 10.075)) / 1.75 + j * (15) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (4.0 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 5; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let nx1 = y[j] / height;
				let inx1 = 0.75+pow(1-nx1, 2);
				let nx2 = y2[j] / height;
				let inx2 = 0.45+pow(nx2, 0.5);
				
				let e = 0.75;

				if (iter > 20) {
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.0225 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);
					//point(width - x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					//point(x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					
					//point(x[j] * inx2+5, height / 1 - y[j]/2.5);
					//point(width - x[j] * inx2-5, height / 1 - y[j]/2.5);
					point(width / 2 - x[j] / 4, height - y[j]/4);
					point(width / 2 + x[j] / 4, height - y[j]/4);
					point(width / 2 - x[j] / 4, y[j]/2);
					point(width / 2 + x[j] / 4, y[j]/2);
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"990360","S10","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 6;

function setup() {
  createCanvas(800, 800);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (1.25), y: abs(width / (2.0) - x + y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 1.75 * x) / 1 + j * 100, y: (height / 2 - y * 1 / j + (x / 4.0)) / 1.0 + j * (10) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 - x * j) / (3 * (j / 5) + x / (width / (2))), y: y / 1.75 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (3.25) - x + y / (1.95 * j * ((0.5 - y / width) * 10))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 1, y: (height / 2 - y * 1.15 / j + (x / 10.075)) / 1.75 + j * (15) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (4.0 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 5; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let nx1 = y[j] / height;
				let inx1 = 0.75+pow(1-nx1, 2);
				let nx2 = y2[j] / height;
				let inx2 = 0.45+pow(nx2, 0.5);
				
				let e = 0.75;

				if (iter > 20) {
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.0225 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);
					//point(width - x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					//point(x[j] * 0.5 * inx1, height / 1 - y[j]/2);
					
					//point(x[j] * inx2+5, height / 1 - y[j]/2.5);
					//point(width - x[j] * inx2-5, height / 1 - y[j]/2.5);
					point(width / 2 - x[j] / 3, height / 2 + y[j]/2);
					point(width / 2 + x[j] / 3, height / 2 + y[j]/2);
					point(width / 2 - x[j] / 3, height / 2 - y[j]/2);
					point(width / 2 + x[j] / 3, height / 2 - y[j]/2);
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"984919","D1","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 4;

function setup() {
  createCanvas(windowHeight, windowHeight);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (2.35), y: abs(width / (1.35) - x + y / (0.5 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 60, y: (height / 2 - y * 1.25 / j + (x / 1)) / 1.75 + j * (10) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 - x * j) / (1.75 * j + x / (width / 0.8)), y: y / 1.05 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (1.25) - x + y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 80, y: (height / 1.45 - y * 1.015 / j + (x / 1.75)) / 1.75 + j * (50) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (2.465 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 1; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let nx1 = y[j] / height;
				let inx1 = 0.5+pow(1-nx1, 3);
				let nx2 = y2[j] / height;
				let inx2 = 0.5+pow(nx2, 2.5);
				let ny1 = abs(0.5 - x[j] / width) * 2;
				let ny = x[j] / width;
				let iny = pow(1-ny1, 0.5);
				let iny2 = 0.05+pow(1-ny1, 0.5);
				let iny3 = 0.5 + abs(sin(ny * PI * 1));
				
				let e = 0.75;

				if (iter > 20) {
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.0275 * a);
					point(y[j] * 0.75 * inx1, x[j]);
					point(width - y[j] * 0.75 * inx1, height - x[j]);
					
					point(x[j] * 1.5 * inx1, height - y[j]);
					//point(width / 1.5 - y[j] * 0.75 * inx1, height - x[j]);
					
					point(x[j] / 1 * inx2, y[j]);
					point(width - x[j] / 1 * inx2, y[j]);

					point(y[j] / 1.0 * inx1, height /2- x[j]/2);
					point(width - y[j] / 1.0 * inx1, height /2+ x[j]/2);
					point(x[j] / 1 * inx2, height / 2 + y[j]);
					point(width - x[j] / 0.75 * inx1, height - y[j]);
					point(width - x[j] / 0.75 * inx1, y[j]);
					
					//point(width / 2.75 - x[j] / 4.5 * inx1, height / 2.5 - y[j] / 4 * iny2);
					//point(width / 2.75 + x[j] / 4.5 * inx1, height / 2.5 - y[j] / 4 * iny2);
					
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);

					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 3.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), height - yy, x + random(-128, 128), height - (yy - random(32, height)));
		}
	}/*
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}*/
}"
"984919","D1","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 4;

function setup() {
  createCanvas(windowHeight, windowHeight);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (2.35), y: abs(width / (1.35) - x + y / (0.5 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 60, y: (height / 2 - y * 1.25 / j + (x / 1)) / 1.75 + j * (10) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 - x * j) / (1.75 * j + x / (width / 0.8)), y: y / 1.05 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (1.25) - x + y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 80, y: (height / 1.45 - y * 1.015 / j + (x / 1.75)) / 1.75 + j * (50) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (2.465 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 1; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let nx1 = y[j] / height;
				let inx1 = 0.5+pow(1-nx1, 3);
				let nx2 = y2[j] / height;
				let inx2 = 0.5+pow(nx2, 2.5);
				let ny1 = abs(0.5 - x[j] / width) * 2;
				let ny = x[j] / width;
				let iny = pow(1-ny1, 0.5);
				let iny2 = 0.05+pow(1-ny1, 0.5);
				let iny3 = 0.5 + abs(sin(ny * PI * 1));
				
				let e = 0.75;

				if (iter > 20) {
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.0275 * a);
					point(y[j] * 0.75 * inx1, x[j]);
					point(width - y[j] * 0.75 * inx1, height - x[j]);
					
					point(x[j] * 1.5 * inx1, height - y[j]);
					//point(width / 1.5 - y[j] * 0.75 * inx1, height - x[j]);
					
					point(x[j] / 1 * inx2, y[j]);
					point(width - x[j] / 1 * inx2, y[j]);

					point(y[j] / 1.0 * inx1, height /2- x[j]/2);
					point(width - y[j] / 1.0 * inx1, height /2+ x[j]/2);
					point(x[j] / 1 * inx2, height / 2 + y[j]);
					point(width - x[j] / 0.75 * inx1, height - y[j]);
					point(width - x[j] / 0.75 * inx1, y[j]);
					
					//point(width / 2.75 - x[j] / 4.5 * inx1, height / 2.5 - y[j] / 4 * iny2);
					//point(width / 2.75 + x[j] / 4.5 * inx1, height / 2.5 - y[j] / 4 * iny2);
					
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);

					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 3.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), height - yy, x + random(-128, 128), height - (yy - random(32, height)));
		}
	}/*
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}*/
}"
"981797","D0","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 4;

function setup() {
  createCanvas(windowHeight, windowHeight);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (2.05), y: abs(width / (2.0) - x + y / (1.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.095 * x) / 1 + j * (4 + y / 10), y: (height / 2 - y * 2 / j + (x / 1.0)) / 1.25 + j * (100 - x / 10) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 - x * j) / (1 * (j / 2) + y / (width / 25)), y: y / 1.25 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.5), y: abs(width / (1.75) - x + y / (1.95 * j * ((0.5 - y / width) * 800))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * (1 + y / 10), y: (height / 2 - y * 0.5 / j + (x / 1.5)) / 1.75 + j * (100) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (1.0 * j + x / (width / 10)), y: y / 1.05 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 1; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let nx1 = y[j] / height;
				let inx1 = 0.15+pow(nx1, 2);
				let nx2 = y2[j] / height;
				let inx2 = 0.75+pow(nx1, 3.5);
				let inx3 = (0.5+pow(nx2, 1.5));
				let inx4 = 0.9+pow(1 - nx1, 4.5);
				
				let e = 0.75;

				if (iter > 20) {
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.0225 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);

					point(x[j] * inx1+5, height / 1 - y[j]/1.385);
					point(width - x[j] * inx1-5, height / 1 - y[j]/1.385);
					
					//point(width / 2 - x[j] * 0.75 * inx3+5, height / 1.2 - y[j]/1.5);
					//point(width / 2 + x[j] * 0.75 * inx3-5, height / 1.2 - y[j]/1.5);
					point(x[j] / 1 * inx2+5, y[j]/1.65);
					point(width - x[j] / 1 * inx2-5, y[j]/1.65);
					
					point(width / 2 - x2[j] / 2.5 * inx3+1, (height - (y2[j])/2) - height / 2);//(y[j]/1.85 - height / 4));
				  point(width / 2 + x2[j] / 2.5 * inx3-1, (height - (y2[j])/2) - height / 2);//(y[j]/1.85 - height / 4));	
					
					point(width / 2 - x[j] / 0.5 * inx2+5, (y[j]/1.85 - height / 4));
					point(width / 2 + x[j] / 0.5 * inx2-5, (y[j]/1.85 - height / 4));	
					
					point(width / 2 - x2[j] / 1.1 * inx4, height - (y[j]/2.0) + height / 32);
					point(width / 2 + x2[j] / 1.1 * inx4, height - (y[j]/2.0) + height / 32);	
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"981797","D0","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 4;

function setup() {
  createCanvas(windowHeight, windowHeight);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (2.05), y: abs(width / (2.0) - x + y / (1.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.095 * x) / 1 + j * (4 + y / 10), y: (height / 2 - y * 2 / j + (x / 1.0)) / 1.25 + j * (100 - x / 10) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 - x * j) / (1 * (j / 2) + y / (width / 25)), y: y / 1.25 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.5), y: abs(width / (1.75) - x + y / (1.95 * j * ((0.5 - y / width) * 800))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * (1 + y / 10), y: (height / 2 - y * 0.5 / j + (x / 1.5)) / 1.75 + j * (100) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (1.0 * j + x / (width / 10)), y: y / 1.05 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 1; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let nx1 = y[j] / height;
				let inx1 = 0.15+pow(nx1, 2);
				let nx2 = y2[j] / height;
				let inx2 = 0.75+pow(nx1, 3.5);
				let inx3 = (0.5+pow(nx2, 1.5));
				let inx4 = 0.9+pow(1 - nx1, 4.5);
				
				let e = 0.75;

				if (iter > 20) {
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.0225 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);

					point(x[j] * inx1+5, height / 1 - y[j]/1.385);
					point(width - x[j] * inx1-5, height / 1 - y[j]/1.385);
					
					//point(width / 2 - x[j] * 0.75 * inx3+5, height / 1.2 - y[j]/1.5);
					//point(width / 2 + x[j] * 0.75 * inx3-5, height / 1.2 - y[j]/1.5);
					point(x[j] / 1 * inx2+5, y[j]/1.65);
					point(width - x[j] / 1 * inx2-5, y[j]/1.65);
					
					point(width / 2 - x2[j] / 2.5 * inx3+1, (height - (y2[j])/2) - height / 2);//(y[j]/1.85 - height / 4));
				  point(width / 2 + x2[j] / 2.5 * inx3-1, (height - (y2[j])/2) - height / 2);//(y[j]/1.85 - height / 4));	
					
					point(width / 2 - x[j] / 0.5 * inx2+5, (y[j]/1.85 - height / 4));
					point(width / 2 + x[j] / 0.5 * inx2-5, (y[j]/1.85 - height / 4));	
					
					point(width / 2 - x2[j] / 1.1 * inx4, height - (y[j]/2.0) + height / 32);
					point(width / 2 + x2[j] / 1.1 * inx4, height - (y[j]/2.0) + height / 32);	
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"981797","D0","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 4;

function setup() {
  createCanvas(800, 800);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (2.0), y: abs(width / (2.0) - x + y / (1.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.095 * x) / 1 + j * (4 + y / 35), y: (height / 2 - y * 1.65 / j + (x / 1.0)) / 1.25 + j * (100 - x / 5) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 - x * j) / (1 * (j / 2) + y / (width / 25)), y: y / 1.25 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.5), y: abs(width / (1.75) - x + y / (1.95 * j * ((0.5 - y / width) * 800))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * (1 + y / 10), y: (height / 2 - y * 0.5 / j + (x / 1.5)) / 1.75 + j * (100) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (1.0 * j + x / (width / 10)), y: y / 1.05 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 1; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let nx1 = y[j] / height;
				let inx1 = 0.5+pow(nx1, 2);
				let nx2 = y2[j] / height;
				let inx2 = 0.75+pow(nx1, 3.5);
				let inx3 = (0.5+pow(nx2, 1.5));
				let inx4 = 0.9+pow(1 - nx1, 4.5);
				
				let e = 0.75;

				if (iter > 20) {
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 255, 0.0125 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);

					point(x[j] * inx1+5, height / 1 - y[j]/1.385);
					point(width - x[j] * inx1-5, height / 1 - y[j]/1.385);
					
					//point(width / 2 - x[j] * 0.75 * inx3+5, height / 1.2 - y[j]/1.5);
					//point(width / 2 + x[j] * 0.75 * inx3-5, height / 1.2 - y[j]/1.5);
					point(x[j] / 1 * inx2+5, y[j]/1.65);
					point(width - x[j] / 1 * inx2-5, y[j]/1.65);
					
					point(width / 2 - x2[j] / 2.5 * inx3+1, (height - (y2[j])/2) - height / 3.15);//(y[j]/1.85 - height / 4));
				  point(width / 2 + x2[j] / 2.5 * inx3-1, (height - (y2[j])/2) - height / 3.15);//(y[j]/1.85 - height / 4));	
					
					point(y[j] / 1.5 * inx4, x[j]/1.0);
					point(width - y[j] / 1.5 * inx4, x[j]/1.0);	
					
					point(width - x[j] / 1.0 * inx4, height - (y[j]/1.0) + height / 32);
					point(x[j] / 1.0 * inx4, height - (y[j]/1.0) + height / 32);	
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"979537","C8","mySketch","function andres_circle(x_centre, y_centre, r, c) {	
	let x = 0;
	let y = r;
	let d = r - 1;
	
	for (let i = 0; i < 140; i += 4) {
		let ni = 1 - i / 140;
		
		while (y >= x) {
			let k = noise(x / width * 8, y / height * 8);
			let j = abs(k * i * 0.025);
			
			rect(x_centre + x - j, y_centre + y - j, 1, 1);
			rect(x_centre + y - j, y_centre + x - j, 1, 1);
			rect(x_centre - x + j, y_centre + y - j, 1, 1);
			rect(x_centre - y + j, y_centre + x - j, 1, 1);
			rect(x_centre + x - j, y_centre - y + j, 1, 1);
			rect(x_centre + y - j, y_centre - x + j, 1, 1);
			rect(x_centre - x + j, y_centre - y + j, 1, 1);
			rect(x_centre - y + j, y_centre - x + j, 1, 1);

			if (d >= 2 * x) { 
				d = d - 2 * x - 1;
				x = x + 1;
			} else if (d < 2 * (r - y)) {
				d = d + 2 * y - 1;
				y = y - 1;
			} else { 
				d = d + 2 * (y - x - 1);
				y = y - 1;
				x = x + 1;
			}
		}
		
		let k = noise(ni * 32);
		
		x = ni * 1;
		y = r*sqrt(2 + ni/3);
		d = r - 1 + (((i % 8) == 0) ? 0 : (i * r * 2));
		
		stroke(80 * ni * c + k * 80, 0, 255 * ni, 92 * ni);
	}
}

let xmotion = 0;
function setup() {
	createCanvas(900, 900);
	
	colorMode(HSL, 360, 255, 255, 255);
	ellipseMode(CENTER);
	
	generate();
	
	noiseDetail(7, 0.7);
}

function draw() {

}

function generate() {
	noStroke();
	
	background(0);
/*	
	fill(0, 0, 0, 255);
	ellipse(width / 3, height / 3, width / 2.25, width / 2.25);
	
	ellipse(width / 2, height / 1.75, width / 2.25, width / 2.25);
	ellipse(width / 1.5, height / 2.75, width / 3.0, width / 3.0);
*/
	
	noFill();
	stroke(0, 0, 0, 255);
	
	let r = 4;
	for (let i = 0; i < 11; i += 1) {
		push();
		translate(width / 2, height / 2);
		rotate(i * 45);
		
		andres_circle(0, 0, r * sqrt(2), i / 11);
		pop();
		
		r = r * sqrt(2.15);
	}
	
/*
	stroke(0, 0, 0, 255);
	andres_circle(width / 2.65, height / 2.75, width / 4);
	stroke(0, 0, 0, 255);
	andres_circle(width / 2, height - height / 3, width / 4);
	stroke(0, 0, 0, 255);
	andres_circle(width - width / 3.5, height / 2.95, width / 7);
*/
/*
	fill(226, 20, 64);
	rect(0, 0, width, height);
	
	let x = 0;
	let y = 0;
	let i = 0;
	let j = 0;
	
	for (i = 0; i < 64; i += 1) {
		let ni = i / 64;
		
		let ra = random(32, 128);
		let xx = random(0, width);
		let yy = random(0, height);
		
		for (j = 0; j < 64; j += 1) {
			let nj = pow(j / 64, 0.25);

			fill(0, 0, 255 * (1 - nj), 1);
			ellipse(xx, yy, ra * nj, ra * nj);
		}
	}
	
	noFill();
	for (x = 0; x < width; x += 4) {
		for (y = 0; y < height; y += 4) {
			if (random() > 0.7) {
				stroke(0, 0, 224, random(0.01, 0.1));
				line(x + random(-4, 4), y + random(-4, 4), x + random(-4, 4), y + random(-4, 4));
			}
		}
	}
*/
}"
"979536","C7","mySketch","function andres_circle(x_centre, y_centre, r, c) {	
	let x = 0;
	let y = r;
	let d = r - 1;
	
	for (let i = 0; i < 240; i += 2) {
		let ni = i / 240;
		
		while (y >= x) {
			let k = noise(x / width * 8, y / height * 8);
			let j = abs(k * i * 0.025);
			
			rect(x_centre + x - j, y_centre + y - j, 1, 1);
			rect(x_centre + y - j, y_centre + x - j, 1, 1);
			rect(x_centre - x + j, y_centre + y - j, 1, 1);
			rect(x_centre - y + j, y_centre + x - j, 1, 1);
			rect(x_centre + x - j, y_centre - y + j, 1, 1);
			rect(x_centre + y - j, y_centre - x + j, 1, 1);
			rect(x_centre - x + j, y_centre - y + j, 1, 1);
			rect(x_centre - y + j, y_centre - x + j, 1, 1);

			if (d >= 2 * x) { 
				d = d - 2 * x - 1;
				x = x + 1;
			} else if (d < 2 * (r - y)) {
				d = d + 2 * y - 1;
				y = y - 1;
			} else { 
				d = d + 2 * (y - x - 1);
				y = y - 1;
				x = x + 1;
			}
		}
		
		let k = noise(ni * 32);
		
		x = ni * 100;
		y = r*sqrt(2 + ni/8);
		d = r - 1 + (((i % 8) == 0) ? 0 : (i * r * 2));
		
		stroke(80 + 80 * ni * c + k * 200, 92, 255 * ni, 128 * ni);
	}
}

let xmotion = 0;
function setup() {
	createCanvas(900, 900);
	
	colorMode(HSL, 360, 255, 255, 255);
	ellipseMode(CENTER);
	
	generate();
	
	noiseDetail(7, 0.7);
}

function draw() {

}

function generate() {
	noStroke();
	
	background(0);

	noFill();
	stroke(0, 0, 0, 255);
	
	let r = 4;
	for (let i = 0; i < 11; i += 1) {
		push();
		translate(width / 2, height / 2);
		rotate(i * 40);
		
		andres_circle(0, 0, r * sqrt(2), i / 11);
		pop();
		
		r = r * sqrt(2.075);
	}
}"
"979525","C6","mySketch","function andres_circle(x_centre, y_centre, r, c) {	
	let x = 0;
	let y = r;
	let d = r - 1;
	
	for (let i = 0; i < 240; i += 4) {
		let ni = 1 - i / 240;
		
		while (y >= x) {
			let k = noise(x / width * 8, y / height * 8);
			let j = abs(k * i * 0.025);
			
			rect(x_centre + x - j, y_centre + y - j, 1, 1);
			rect(x_centre + y - j, y_centre + x - j, 1, 1);
			rect(x_centre - x + j, y_centre + y - j, 1, 1);
			rect(x_centre - y + j, y_centre + x - j, 1, 1);
			rect(x_centre + x - j, y_centre - y + j, 1, 1);
			rect(x_centre + y - j, y_centre - x + j, 1, 1);
			rect(x_centre - x + j, y_centre - y + j, 1, 1);
			rect(x_centre - y + j, y_centre - x + j, 1, 1);

			if (d >= 2 * x) { 
				d = d - 2 * x - 1;
				x = x + 1;
			} else if (d < 2 * (r - y)) {
				d = d + 2 * y - 1;
				y = y - 1;
			} else { 
				d = d + 2 * (y - x - 1);
				y = y - 1;
				x = x + 1;
			}
		}
		
		let k = noise(ni * 32);
		
		x = ni * 1;
		y = r*sqrt(2 + ni/3);
		d = r - 1 + (((i % 8) == 0) ? 0 : (i * r * 2));
		
		stroke(170 + 20 * ni * c + k * 120, 92, 255 * ni, 92 * ni);
	}
}

let xmotion = 0;
function setup() {
	createCanvas(900, 900);
	
	colorMode(HSL, 360, 255, 255, 255);
	ellipseMode(CENTER);
	
	generate();
	
	noiseDetail(7, 0.7);
}

function draw() {

}

function generate() {
	noStroke();
	
	background(0);

	noFill();
	stroke(0, 0, 0, 255);
	
	let r = 4;
	for (let i = 0; i < 11; i += 1) {
		push();
		translate(width / 2, height / 2);
		rotate(i * 40);
		
		andres_circle(0, 0, r * sqrt(2), i / 11);
		pop();
		
		r = r * sqrt(2.075);
	}
}"
"977450","ink","mySketch","function setup() {
	createCanvas(400, 400);
	background(0);
	
	noiseDetail(6, 0.6);
	
	rectMode(CENTER);
	
	noStroke();
}

let z = 0;

function draw() {
	for (let x = 0; x < width; x += 4) {
		for (let y = 0; y < height; y += 4) {
			let n = noise(x / width*8+z, y / height*8+z);
			let c = 0;
			if (n > 0.5) {
				c = 255;
			}
			
			fill(c, c, c, 32);
			rect(x , y, 4, 4);
		}
	}

	z += 0.01;
}"
"976358","3D IFS Fractal","mySketch","// 3D IFS with points based rendering

let frame = 0;

let step = 0.003; // control surface stepping, lower = higher quality (but too slow for realtime)
let scale = 0.4; // cube scale

let x = 0;
let y = 0;
let z = 0;
let fx = 0;
let fy = 0;
let fz = 0;

let iter = 1;

let zdepth = 900;

let depthbuffer = [];

function XorGen(seed) {
  var me = this;

  // Set up generator function.
  me.next = function() {
    var w = me.w,
        X = me.X, i = me.i, t, v;
    // Update Weyl generator.
    me.w = w = (w + 0x61c88647) | 0;
    // Update xor generator.
    v = X[(i + 34) & 127];
    t = X[i = ((i + 1) & 127)];
    v ^= v << 13;
    t ^= t << 17;
    v ^= v >>> 15;
    t ^= t >>> 12;
    // Update Xor generator array state.
    v = X[i] = v ^ t;
    me.i = i;
    // Result is the combination.
    return (v + (w ^ (w >>> 16))) | 0;
  };

  function init(me, seed) {
    var t, v, i, j, w, X = [], limit = 128;
    if (seed === (seed | 0)) {
      // Numeric seeds initialize v, which is used to generates X.
      v = seed;
      seed = null;
    } else {
      // String seeds are mixed into v and X one character at a time.
      seed = seed + '\0';
      v = 0;
      limit = Math.max(limit, seed.length);
    }
    // Initialize circular array and weyl value.
    for (i = 0, j = -32; j < limit; ++j) {
      // Put the unicode characters into the array, and shuffle them.
      if (seed) v ^= seed.charCodeAt((j + 32) % seed.length);
      // After 32 shuffles, take v as the starting w value.
      if (j === 0) w = v;
      v ^= v << 10;
      v ^= v >>> 15;
      v ^= v << 4;
      v ^= v >>> 13;
      if (j >= 0) {
        w = (w + 0x61c88647) | 0;     // Weyl.
        t = (X[j & 127] ^= (v + w));  // Combine xor and weyl to init array.
        i = (0 == t) ? i + 1 : 0;     // Count zeroes.
      }
    }
    // We have detected all zeroes; make the key nonzero.
    if (i >= 128) {
      X[(seed && seed.length || 0) & 127] = -1;
    }
    // Run the generator 512 times to further mix the state before using it.
    // Factoring this as a function slows the main generator, so it is just
    // unrolled here.  The weyl generator is not advanced while warming up.
    i = 127;
    for (j = 4 * 128; j > 0; --j) {
      v = X[(i + 34) & 127];
      t = X[i = ((i + 1) & 127)];
      v ^= v << 13;
      t ^= t << 17;
      v ^= v >>> 15;
      t ^= t >>> 12;
      X[i] = v ^ t;
    }
    // Storing state as object members is faster than using closure variables.
    me.w = w;
    me.X = X;
    me.i = i;
  }

  init(me, seed);
}

function copy1(f, t) {
  t.i = f.i;
  t.w = f.w;
  t.X = f.X.slice();
  return t;
}

function impl(seed, opts) {
  if (seed == null) seed = +(new Date);
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / ((1 << 30) * 4); };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / ((1 << 30) * 4),
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  if (state) {
    if (state.X) copy(state, xg);
    prng.state = function() { return copy1(xg, {}); }
  }
  return prng;
}
	
let rng = 0;

function setup() {
	createCanvas(800, 800);

	background(0);

	noStroke();

	noiseDetail(7, 0.7);

	// initialize depth buffer
	for (let i = 0.0; i <= width; i += 1) {
		for (let j = 0.0; j <= height; j += 1) {
			depthbuffer[i + j * width] = -Infinity;
		}
	}
	
	fx = random(0, width);
	fy = random(0, height);
	fz = random(0, zdepth);
	
	noStroke();
	
	rng = impl(10);
}

function draw() {
	//background(0);
	
	// progressive rendering
	for (let i = 0.0; i <= 10000; i += 1) {
		draw3d();
	}
	
	//frame += 1.5;
}

function f1(x, y, z) {
	return { x: x / 2, y: y / 2, z: zdepth - z / 2 };
}

function f2(x, y, z) {
	return { x: (width / 2 + x) / 2, y: (height + y) / 2, z: z / 2 };
}

function f3(x, y, z) {
	return { x: (width + x) / 2, y: y / 1, z: zdepth / 2 + z / 2 };
}

function f4(x, y, z) {
	return { x: x / 2, y: (height / 2 + y) / 2, z: z / 2 };
}

function f5(x, y, z) {
	return { x: x / 2, y: (height + y) / 2, z: zdepth / 2 + z / 2 };
}

var f = [f1, f2, f3, f4, f5];

function draw3d() {
	  let index = floor(rng.double() * 5); // better rng ?
		let r = f[index](fx, fy, fz);

		fx = r.x; fy = r.y; fz = r.z;
	
	x = fx / width;
	y = fy / height;
	z = fz / zdepth;

	let rxa = 2 + 0.0 * frame;
	let rya = 1.7 + 0.0 * frame;

	// rotation values
	let crx = cos(rxa);
	let cry = cos(rya);
	let srx = sin(rxa);
	let sry = sin(rya);
	
	// rm = rotation matrix
	let rm = [0,0,0,0,0,0,0,0,0];

	rm[0] = cry;     /*rm[1] = 0.0f;*/ rm[2] = -sry;
	rm[3] = sry * srx; rm[4] = crx;    rm[5] = cry * srx;
	rm[6] = sry * crx; rm[7] = -srx;   rm[8] = cry * crx;
	
	let x2 = width / 2;
	let y2 = height / 2;

		let vr = [0,0,0];

		let pz = 2.0 * z - 1.0; // normalize screen space

		vr[2] = pz * scale;
		//for (y = 0.0; y <= 1.0; y += inc) {
			let py = 2.0 * y - 1.0;

			vr[1] = py * scale;

				let px = (2.0 * x - 1.0);
				vr[0] = px * scale;

				// rotate/transform our points
				let vrr = [
						rm[0] * vr[0] + rm[3] * vr[1] + rm[6] * vr[2],
						rm[1] * vr[0] + rm[4] * vr[1] + rm[7] * vr[2],
						rm[2] * vr[0] + rm[5] * vr[1] + rm[8] * vr[2]
                ];
	
				// compute length & normalize
				let le = sqrt((vrr[0] * vrr[0]) + (vrr[1] * vrr[1]) + (vrr[2] * vrr[2]));
			  let vrn = [ vrr[0] / le, vrr[1] / le, vrr[2] / le ];
	
				// since we were in normalized space we scale it to screen space and translate it at the center of the screen
				let posx = x2 - round(vrr[0] * height);
				let posy = y2 - round(vrr[1] * height);
	
				let depth = vrn[2] * noise(x, y, z);
	
				// z-buffer (do nothing if farther; replace if nearest)
				let zbuffer_index = posx + posy * width;
				let zb_depth = depthbuffer[zbuffer_index];
				if (zb_depth > depth) {
					return;
				}
	
				depthbuffer[zbuffer_index] = depth;
				//let dst = 1-dist(px, 0.0, py, 0.0, pz, 0.0);
				depth = pow(depth, 2);
				posy -= height / 16;

				fill(255, 255, 255, depth * 92);

				rect(posx, posy, 1, 1);
	
				let xx = (random() > 0.5 ? random(1, 8) : -random(1, 8));
				let yy = (random() > 0.5 ? random(1, 8) : -random(1, 8));
				fill(128, 128, 128, depth * 92);
				rect(posx + xx, posy + yy, 1, 1);
	
}"
"975978","S10²","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 4;

function setup() {
  createCanvas(windowHeight, windowHeight);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (2.0), y: abs(width / (2.0) - x + y / (1.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 3 * x) / 1 + j * (20 + y / 20), y: (height / 2 - y * 2 / j + (x / 1.0)) / 1.25 + j * (100 - x / 10) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 - x * j) / (8 * (j / 2) + x / (width / 1)), y: y / 1.25 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (3.25) - x + y / (1.95 * j * ((0.5 - y / width) * 10))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 1, y: (height / 2 - y * 1.15 / j + (x / 10.075)) / 1.75 + j * (15) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (1.065 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 1; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let nx1 = y[j] / height;
				let inx1 = 0.5+pow(1-nx1, 2);
				let nx2 = y2[j] / height;
				let inx2 = 0.75+pow(nx2, 3.5);
			
				let e = 0.75;

				if (iter > 20) {
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.0225 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);
					
					point(x[j] * inx1+5, height / 1 - y[j]/1.385);
					point(width - x[j] * inx1-5, height / 1 - y[j]/1.385);
					
					//point(width / 2 - x[j] * 0.5 * inx1+5, height / 1.2 - y[j]/1.5);
					//point(width / 2 + x[j] * 0.5 * inx1-5, height / 1.2 - y[j]/1.5);
					point(x[j] / 1 * inx2+5, y[j]/1.65);
					point(width - x[j] / 1 * inx2-5, y[j]/1.65);
					point(width / 2 - x[j] / 0.75 * inx2+5, height - (y[j]/1.85 - height / 4));//(y[j]/1.85 - height / 4));
					point(width / 2 + x[j] / 0.75 * inx2-5, height - (y[j]/1.85 - height / 4));//(y[j]/1.85 - height / 4));	
					point(width / 2 - x[j] / 0.75 * inx2+5, (y[j]/1.85 - height / 4));
					point(width / 2 + x[j] / 0.75 * inx2-5, (y[j]/1.85 - height / 4));	
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"973223","dem42","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 4;

function setup() {
  createCanvas(windowHeight, windowHeight);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (2.35), y: abs(width / (1.35) - x + y / (0.5 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 60, y: (height / 2 - y * 1.25 / j + (x / 1)) / 1.75 + j * (10) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 - x * j) / (1.75 * j + x / (width / 0.8)), y: y / 1.05 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (1.25) - x + y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 80, y: (height / 1.45 - y * 1.015 / j + (x / 1.75)) / 1.75 + j * (50) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (2.465 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 1; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let nx1 = y[j] / height;
				let inx1 = 0.5+pow(1-nx1, 3);
				let nx2 = y2[j] / height;
				let inx2 = 0.5+pow(nx2, 2.5);
				let ny1 = abs(0.5 - x[j] / width) * 2;
				let ny = x[j] / width;
				let iny = pow(1-ny1, 0.5);
				let iny2 = 0.05+pow(1-ny1, 0.5);
				let iny3 = 0.5 + abs(sin(ny * PI * 1));
				
				let e = 0.75;

				if (iter > 20) {
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.0425 * a);
					point(x[j] * 0.75 * inx1, y[j]/2);
					point(width - x[j] * 0.75 * inx1, y[j]/2);
					//point(x[j] / 1 * inx1, height / 2 - y[j]/2);
					//point(width - x[j] / 1 * inx1, height / 2 - y[j]/2);
					point(x[j] / 0.5 * inx1, height - y[j]/2);
					point(width - x[j] / 0.5 * inx1, height - y[j]/2);
					point(x[j] / 1 * inx2, y[j]);
					point(width - x[j] / 1 * inx2, y[j]);
					//point(width / 2 - x2[j] / 3.5 * inx2, height / 2.5 + y[j] / 3 * iny2);
					//point(width / 2 + x2[j] / 3.5 * inx2, height / 2.5 + y[j] / 3 * iny2);
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);

					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 3.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), height - yy, x + random(-128, 128), height - (yy - random(32, height)));
		}
	}/*
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}*/
}"
"973048","Pelote","mySketch","function andres_circle(x_centre, y_centre, r, j) {	
	let x = 0;
	let y = r;
	let d = r - 1;
	
	for (let i = 0; i < 200; i += 2) {
		let ni = i / 200 * 3;
		
		while (y >= x) {
			//if (y % 8 == 0) {
			//	ni = (1 - (i / 200)) * 4;
			//}
			let k = noise(x / width * 12, y / height * 12, ni * 8);
			let j = abs(k * i * 0.55);
			
			if (k < 0.125)
				rect(x_centre + x + j, y_centre + y + j, 1, 1);
			if (k < 0.25)
				rect(x_centre + y + j, y_centre + x + j, 1, 1);
			if (k < 0.375)
				rect(x_centre - x - j, y_centre + y + j, 1, 1);
			if (k < 0.5)
				rect(x_centre - y - j, y_centre + x + j, 1, 1);
		  if (k < 0.625)
				rect(x_centre + x + j, y_centre - y - j, 1, 1);
			if (k < 0.75)
				rect(x_centre + y + j, y_centre - x - j, 1, 1);
			if (k < 0.875)
				rect(x_centre - x - j, y_centre - y - j, 1, 1);
			if (k < 1)
				rect(x_centre - y - j, y_centre - x - j, 1, 1);

			if (d >= 2 * x) { 
				d = d - 2 * x - 1;
				x = x + 1;
			} else if (d < 2 * (r - y)) {
				d = d + 2 * y - 1;
				y = y - 1;
			} else { 
				d = d + 2 * (y - x - 1);
				y = y - 1;
				x = x + 1;
			}
		}
		
		let k = noise(ni * 8);
		
		x = 2 * ni *j * k;
		y = r - (k * r / 16);
		d = r - 1;
		
		stroke(92 * (1 - ni / 3), 32 * (ni / 3), 255 * ((ni / 3) / 2) * k, 64 * ni);
	}
}


function setup() {
	createCanvas(800, 800);
	
	background(255);
	
	//colorMode(HSL, 360, 255, 255);
	ellipseMode(CENTER);
	
	generate();
	
	noiseDetail(7, 0.7);
}

function draw() {

}

function generate() {
	noStroke();
	
	background(0);
/*	
	fill(0, 0, 0, 255);
	ellipse(width / 3, height / 3, width / 2.25, width / 2.25);
	
	ellipse(width / 2, height / 1.75, width / 2.25, width / 2.25);
	ellipse(width / 1.5, height / 2.75, width / 3.0, width / 3.0);
*/
	
	stroke(0, 0, 0, 255);
	for (let i = 0; i <= 8; i += 1) {
		push();
		translate(width / 2, height / 2);
		rotate(i / 8 * 180);
		if (i == 0) {
			andres_circle(0, 0, width / 8 * ((1 + i) / 4), i);
		} else {
			andres_circle(0, 0, width / 8 * (i / 2) - width / 8, i);
		}
		pop();
	}
	
/*
	stroke(0, 0, 0, 255);
	andres_circle(width / 2.65, height / 2.75, width / 4);
	stroke(0, 0, 0, 255);
	andres_circle(width / 2, height - height / 3, width / 4);
	stroke(0, 0, 0, 255);
	andres_circle(width - width / 3.5, height / 2.95, width / 7);
*/
/*
	fill(226, 20, 64);
	rect(0, 0, width, height);
	
	let x = 0;
	let y = 0;
	let i = 0;
	let j = 0;
	
	for (i = 0; i < 64; i += 1) {
		let ni = i / 64;
		
		let ra = random(32, 128);
		let xx = random(0, width);
		let yy = random(0, height);
		
		for (j = 0; j < 64; j += 1) {
			let nj = pow(j / 64, 0.25);

			fill(0, 0, 255 * (1 - nj), 1);
			ellipse(xx, yy, ra * nj, ra * nj);
		}
	}
	
	noFill();
	for (x = 0; x < width; x += 4) {
		for (y = 0; y < height; y += 4) {
			if (random() > 0.7) {
				stroke(0, 0, 224, random(0.01, 0.1));
				line(x + random(-4, 4), y + random(-4, 4), x + random(-4, 4), y + random(-4, 4));
			}
		}
	}
*/
}"
"973024","C5","mySketch","function andres_circle(x_centre, y_centre, r, j) {	
	let x = 0;
	let y = r;
	let d = r - 1;
	
	for (let i = 0; i < 200; i += 1) {
		let ni = i / 200 * 3;
		
		while (y >= x) {
			//if (y % 8 == 0) {
			//	ni = (1 - (i / 200)) * 4;
			//}
			let k = noise(x / width * 12, y / height * 12, ni * 3);
			let j = abs(k * i * 0.55);
			
			rect(x_centre + x + j, y_centre + y + j, 1, 1);
			rect(x_centre + y + j, y_centre + x + j, 1, 1);
			//if (j % 2 == 0)
				rect(x_centre - x - j, y_centre + y + j, 1, 1);
			rect(x_centre - y - j, y_centre + x + j, 1, 1);
			rect(x_centre + x + j, y_centre - y - j, 1, 1);
			//if (j % 2 == 0)
				rect(x_centre + y + j, y_centre - x - j, 1, 1);
			rect(x_centre - x - j, y_centre - y - j, 1, 1);
			//if (j % 3 == 0)
			rect(x_centre - y - j, y_centre - x - j, 1, 1);

			if (d >= 2 * x) { 
				d = d - 2 * x - 1;
				x = x + 1;
			} else if (d < 2 * (r - y)) {
				d = d + 2 * y - 1;
				y = y - 1;
			} else { 
				d = d + 2 * (y - x - 1);
				y = y - 1;
				x = x + 1;
			}
		}
		
		x = 2 *ni *j;
		y = r;
		d = r - 1;
		
		let k = noise(ni * 8);
		
		stroke(192 * ((1 - ni / 3) / 2) * k, 0, 128 * (1 - ni / 6), 64 * ni);
	}
}


function setup() {
	createCanvas(800, 800);
	
	background(255);
	
	//colorMode(HSL, 360, 255, 255);
	ellipseMode(CENTER);
	
	generate();
	
	noiseDetail(7, 0.7);
}

function draw() {

}

function generate() {
	noStroke();
	
	background(0);
/*	
	fill(0, 0, 0, 255);
	ellipse(width / 3, height / 3, width / 2.25, width / 2.25);
	
	ellipse(width / 2, height / 1.75, width / 2.25, width / 2.25);
	ellipse(width / 1.5, height / 2.75, width / 3.0, width / 3.0);
*/
	
	stroke(0, 0, 0, 255);
	for (let i = 0; i <= 8; i += 1) {
		push();
		translate(width / 2, height / 2);
		rotate(i / 8 * 180);
		if (i == 0) {
			andres_circle(0, 0, width / 8 * ((1 + i) / 4), i);
		} else {
			andres_circle(0, 0, width / 8 * (i / 2) - width / 8, i);
		}
		pop();
	}
	
/*
	stroke(0, 0, 0, 255);
	andres_circle(width / 2.65, height / 2.75, width / 4);
	stroke(0, 0, 0, 255);
	andres_circle(width / 2, height - height / 3, width / 4);
	stroke(0, 0, 0, 255);
	andres_circle(width - width / 3.5, height / 2.95, width / 7);
*/
/*
	fill(226, 20, 64);
	rect(0, 0, width, height);
	
	let x = 0;
	let y = 0;
	let i = 0;
	let j = 0;
	
	for (i = 0; i < 64; i += 1) {
		let ni = i / 64;
		
		let ra = random(32, 128);
		let xx = random(0, width);
		let yy = random(0, height);
		
		for (j = 0; j < 64; j += 1) {
			let nj = pow(j / 64, 0.25);

			fill(0, 0, 255 * (1 - nj), 1);
			ellipse(xx, yy, ra * nj, ra * nj);
		}
	}
	
	noFill();
	for (x = 0; x < width; x += 4) {
		for (y = 0; y < height; y += 4) {
			if (random() > 0.7) {
				stroke(0, 0, 224, random(0.01, 0.1));
				line(x + random(-4, 4), y + random(-4, 4), x + random(-4, 4), y + random(-4, 4));
			}
		}
	}
*/
}"
"972059","C4","mySketch","function andres_circle(x_centre, y_centre, r) {	
	let x = 0;
	let y = r;
	let d = r - 1;
	
	for (let i = 0; i < 180; i += 2) {
		let ni = 1 - i / 180;
		
		while (y >= x) {
			let k = 1 - noise(x / width * 64, y / height * 64);
			let j = abs(k * i * 0.125);
			
			rect(x_centre + x - j, y_centre + y - j, 1, 1);
			rect(x_centre + y - j, y_centre + x - j, 1, 1);
			rect(x_centre - x + j, y_centre + y - j, 1, 1);
			rect(x_centre - y + j, y_centre + x - j, 1, 1);
			rect(x_centre + x - j, y_centre - y + j, 1, 1);
			rect(x_centre + y - j, y_centre - x + j, 1, 1);
			rect(x_centre - x + j, y_centre - y + j, 1, 1);
			rect(x_centre - y + j, y_centre - x + j, 1, 1);

			if (d >= 2 * x) { 
				d = d - 2 * x - 1;
				x = x + 1;
			} else if (d < 2 * (r - y)) {
				d = d + 2 * y - 1;
				y = y - 1;
			} else { 
				d = d + 2 * (y - x - 1);
				y = y - 1;
				x = x + 1;
			}
		}
		
		x = 0;
		y = r;
		d = r - 1 + (((i % 8) == 0) ? 0 : (i * r * 6));
		
		stroke(255 * ni, 255 * ni, 255 * ni, 128 * ni);
	}
}


function setup() {
	createCanvas(700, 700);
	
	background(255);
	
	//colorMode(HSL, 360, 255, 255);
	ellipseMode(CENTER);
	
	generate();
	
	noiseDetail(7, 0.7);
}

function draw() {

}

function generate() {
	noStroke();
	
	background(0);
/*	
	fill(0, 0, 0, 255);
	ellipse(width / 3, height / 3, width / 2.25, width / 2.25);
	
	ellipse(width / 2, height / 1.75, width / 2.25, width / 2.25);
	ellipse(width / 1.5, height / 2.75, width / 3.0, width / 3.0);
*/
	
	fill(0, 0, 0, 1);
	stroke(0, 0, 0, 255);
	for (let i = 1; i < 4; i += 1) {
		push();
		translate(width / 2, height / 2);
		rotate(i / 4 * 360);
		andres_circle(0, 0, width / 2 * (i / 4));
		pop();
	}
	
/*
	stroke(0, 0, 0, 255);
	andres_circle(width / 2.65, height / 2.75, width / 4);
	stroke(0, 0, 0, 255);
	andres_circle(width / 2, height - height / 3, width / 4);
	stroke(0, 0, 0, 255);
	andres_circle(width - width / 3.5, height / 2.95, width / 7);
*/
/*
	fill(226, 20, 64);
	rect(0, 0, width, height);
	
	let x = 0;
	let y = 0;
	let i = 0;
	let j = 0;
	
	for (i = 0; i < 64; i += 1) {
		let ni = i / 64;
		
		let ra = random(32, 128);
		let xx = random(0, width);
		let yy = random(0, height);
		
		for (j = 0; j < 64; j += 1) {
			let nj = pow(j / 64, 0.25);

			fill(0, 0, 255 * (1 - nj), 1);
			ellipse(xx, yy, ra * nj, ra * nj);
		}
	}
	
	noFill();
	for (x = 0; x < width; x += 4) {
		for (y = 0; y < height; y += 4) {
			if (random() > 0.7) {
				stroke(0, 0, 224, random(0.01, 0.1));
				line(x + random(-4, 4), y + random(-4, 4), x + random(-4, 4), y + random(-4, 4));
			}
		}
	}
*/
}"
"972059","C4","mySketch","function andres_circle(x_centre, y_centre, r) {	
	let x = 0;
	let y = r;
	let d = r - 1;
	
	for (let i = 0; i < 180; i += 2) {
		let ni = 1 - i / 180;
		
		while (y >= x) {
			let k = 1 - noise(x / width * 64, y / height * 64);
			let j = abs(k * i * 0.125);
			
			rect(x_centre + x - j, y_centre + y - j, 1, 1);
			rect(x_centre + y - j, y_centre + x - j, 1, 1);
			rect(x_centre - x + j, y_centre + y - j, 1, 1);
			rect(x_centre - y + j, y_centre + x - j, 1, 1);
			rect(x_centre + x - j, y_centre - y + j, 1, 1);
			rect(x_centre + y - j, y_centre - x + j, 1, 1);
			rect(x_centre - x + j, y_centre - y + j, 1, 1);
			rect(x_centre - y + j, y_centre - x + j, 1, 1);

			if (d >= 2 * x) { 
				d = d - 2 * x - 1;
				x = x + 1;
			} else if (d < 2 * (r - y)) {
				d = d + 2 * y - 1;
				y = y - 1;
			} else { 
				d = d + 2 * (y - x - 1);
				y = y - 1;
				x = x + 1;
			}
		}
		
		x = 0;
		y = r;
		d = r - 1 + (((i % 8) == 0) ? 0 : (i * r * 2));
		
		stroke(255 * ni, 255 * ni, 255 * ni, 128 * ni);
	}
}


function setup() {
	createCanvas(700, 700);
	
	background(255);
	
	//colorMode(HSL, 360, 255, 255);
	ellipseMode(CENTER);
	
	generate();
	
	noiseDetail(7, 0.7);
}

function draw() {

}

function generate() {
	noStroke();
	
	background(0);
/*	
	fill(0, 0, 0, 255);
	ellipse(width / 3, height / 3, width / 2.25, width / 2.25);
	
	ellipse(width / 2, height / 1.75, width / 2.25, width / 2.25);
	ellipse(width / 1.5, height / 2.75, width / 3.0, width / 3.0);
*/
	
	fill(0, 0, 0, 1);
	stroke(0, 0, 0, 255);
	for (let i = 1; i < 4; i += 1) {
		push();
		translate(width / 2, height / 2);
		rotate(i / 4 * 360);
		andres_circle(0, 0, width / 2 * (i / 4));
		pop();
	}
	
/*
	stroke(0, 0, 0, 255);
	andres_circle(width / 2.65, height / 2.75, width / 4);
	stroke(0, 0, 0, 255);
	andres_circle(width / 2, height - height / 3, width / 4);
	stroke(0, 0, 0, 255);
	andres_circle(width - width / 3.5, height / 2.95, width / 7);
*/
/*
	fill(226, 20, 64);
	rect(0, 0, width, height);
	
	let x = 0;
	let y = 0;
	let i = 0;
	let j = 0;
	
	for (i = 0; i < 64; i += 1) {
		let ni = i / 64;
		
		let ra = random(32, 128);
		let xx = random(0, width);
		let yy = random(0, height);
		
		for (j = 0; j < 64; j += 1) {
			let nj = pow(j / 64, 0.25);

			fill(0, 0, 255 * (1 - nj), 1);
			ellipse(xx, yy, ra * nj, ra * nj);
		}
	}
	
	noFill();
	for (x = 0; x < width; x += 4) {
		for (y = 0; y < height; y += 4) {
			if (random() > 0.7) {
				stroke(0, 0, 224, random(0.01, 0.1));
				line(x + random(-4, 4), y + random(-4, 4), x + random(-4, 4), y + random(-4, 4));
			}
		}
	}
*/
}"
"972049","C3","mySketch","function andres_circle(x_centre, y_centre, r) {	
	let x = 0;
	let y = r;
	let d = r - 1;
	
	for (let i = 0; i < 100; i += 1) {
		let ni = i / 100;
		
		while (y >= x) {
			let k = noise(x / width * 4, y / height * 4);
			let j = abs(k * i * 0.35);
			
			rect(x_centre + x - j, y_centre + y - j, 1, 1);
			rect(x_centre + y - j, y_centre + x - j, 1, 1);
			rect(x_centre - x - j, y_centre + y - j, 1, 1);
			rect(x_centre - y - j, y_centre + x - j, 1, 1);
			rect(x_centre + x - j, y_centre - y - j, 1, 1);
			rect(x_centre + y - j, y_centre - x - j, 1, 1);
			rect(x_centre - x - j, y_centre - y - j, 1, 1);
			rect(x_centre - y - j, y_centre - x - j, 1, 1);

			if (d >= 2 * x) { 
				d = d - 2 * x - 1;
				x = x + 1;
			} else if (d < 2 * (r - y)) {
				d = d + 2 * y - 1;
				y = y - 1;
			} else { 
				d = d + 2 * (y - x - 1);
				y = y - 1;
				x = x + 1;
			}
		}
		
		x = 0;
		y = r;
		d = r - 1;
		
		stroke(0, 0, 0, 64 * ni);
	}
}


function setup() {
	createCanvas(700, 700);
	
	background(255);
	
	//colorMode(HSL, 360, 255, 255);
	ellipseMode(CENTER);
	
	generate();
	
	noiseDetail(7, 0.7);
}

function draw() {

}

function generate() {
	noStroke();
	
	background(0);
/*	
	fill(0, 0, 0, 255);
	ellipse(width / 3, height / 3, width / 2.25, width / 2.25);
	
	ellipse(width / 2, height / 1.75, width / 2.25, width / 2.25);
	ellipse(width / 1.5, height / 2.75, width / 3.0, width / 3.0);
*/
	
	stroke(0, 0, 0, 255);
	for (let i = 0; i < 10; i += 1) {
		push();
		translate(width / 2, height / 2);
		rotate(i / 10 * 360);
		andres_circle(0, 0, 10 + width / 2 * (i / 10));
		pop();
	}
	
/*
	stroke(0, 0, 0, 255);
	andres_circle(width / 2.65, height / 2.75, width / 4);
	stroke(0, 0, 0, 255);
	andres_circle(width / 2, height - height / 3, width / 4);
	stroke(0, 0, 0, 255);
	andres_circle(width - width / 3.5, height / 2.95, width / 7);
*/
/*
	fill(226, 20, 64);
	rect(0, 0, width, height);
	
	let x = 0;
	let y = 0;
	let i = 0;
	let j = 0;
	
	for (i = 0; i < 64; i += 1) {
		let ni = i / 64;
		
		let ra = random(32, 128);
		let xx = random(0, width);
		let yy = random(0, height);
		
		for (j = 0; j < 64; j += 1) {
			let nj = pow(j / 64, 0.25);

			fill(0, 0, 255 * (1 - nj), 1);
			ellipse(xx, yy, ra * nj, ra * nj);
		}
	}
	
	noFill();
	for (x = 0; x < width; x += 4) {
		for (y = 0; y < height; y += 4) {
			if (random() > 0.7) {
				stroke(0, 0, 224, random(0.01, 0.1));
				line(x + random(-4, 4), y + random(-4, 4), x + random(-4, 4), y + random(-4, 4));
			}
		}
	}
*/
}"
"971401","C2","mySketch","function andres_circle(x_centre, y_centre, r) {	
	let x = 0;
	let y = r;
	let d = r - 1;
	
	for (let i = 0; i < 200; i += 1) {
		let ni = i / 200;
		
		while (y >= x) {
			let k = noise(x / width * 6, y / height * 6);
			let j = abs(k * i * 1);
			
			rect(x_centre + x - j, y_centre + y - j, 1, 1);
			rect(x_centre + y - j, y_centre + x - j, 1, 1);
			rect(x_centre - x + j, y_centre + y - j, 1, 1);
			rect(x_centre - y + j, y_centre + x - j, 1, 1);
			rect(x_centre + x - j, y_centre - y + j, 1, 1);
			rect(x_centre + y - j, y_centre - x + j, 1, 1);
			rect(x_centre - x + j, y_centre - y + j, 1, 1);
			rect(x_centre - y + j, y_centre - x + j, 1, 1);

			if (d >= 2 * x) { 
				d = d - 2 * x - 1;
				x = x + 1;
			} else if (d < 2 * (r - y)) {
				d = d + 2 * y - 1;
				y = y - 1;
			} else { 
				d = d + 2 * (y - x - 1);
				y = y - 1;
				x = x + 1;
			}
		}
		
		x = 0;
		y = r;
		d = r - 1;
		
		stroke(0, 0, 0, 64 * ni);
	}
}


function setup() {
	createCanvas(800, 800);
	
	background(255);
	
	//colorMode(HSL, 360, 255, 255);
	ellipseMode(CENTER);
	
	generate();
	
	noiseDetail(7, 0.7);
}

function draw() {

}

function generate() {
	noStroke();
	
	background(255);
/*	
	fill(0, 0, 0, 255);
	ellipse(width / 3, height / 3, width / 2.25, width / 2.25);
	
	ellipse(width / 2, height / 1.75, width / 2.25, width / 2.25);
	ellipse(width / 1.5, height / 2.75, width / 3.0, width / 3.0);
*/
	
	stroke(0, 0, 0, 255);
	for (let i = 0; i < 4; i += 1) {
		push();
		translate(width / 2, height / 2);
		rotate(i / 4 * 180);
		andres_circle(0, 0, 1 + width / 1.5 * (i / 4));
		pop();
	}
	
/*
	stroke(0, 0, 0, 255);
	andres_circle(width / 2.65, height / 2.75, width / 4);
	stroke(0, 0, 0, 255);
	andres_circle(width / 2, height - height / 3, width / 4);
	stroke(0, 0, 0, 255);
	andres_circle(width - width / 3.5, height / 2.95, width / 7);
*/
/*
	fill(226, 20, 64);
	rect(0, 0, width, height);
	
	let x = 0;
	let y = 0;
	let i = 0;
	let j = 0;
	
	for (i = 0; i < 64; i += 1) {
		let ni = i / 64;
		
		let ra = random(32, 128);
		let xx = random(0, width);
		let yy = random(0, height);
		
		for (j = 0; j < 64; j += 1) {
			let nj = pow(j / 64, 0.25);

			fill(0, 0, 255 * (1 - nj), 1);
			ellipse(xx, yy, ra * nj, ra * nj);
		}
	}
	
	noFill();
	for (x = 0; x < width; x += 4) {
		for (y = 0; y < height; y += 4) {
			if (random() > 0.7) {
				stroke(0, 0, 224, random(0.01, 0.1));
				line(x + random(-4, 4), y + random(-4, 4), x + random(-4, 4), y + random(-4, 4));
			}
		}
	}
*/
}"
"971401","C2","mySketch","function andres_circle(x_centre, y_centre, r, j) {	
	let x = 0;
	let y = r;
	let d = r - 1;
	
	for (let i = 0; i < 200; i += 1) {
		let ni = i / 200;
		
		while (y >= x) {
			let k = noise(x / width * 6, y / height * 6);
			let j = abs(k * i * 1);
			
			rect(x_centre + x - j, y_centre + y - j, 1, 1);
			rect(x_centre + y - j, y_centre + x - j, 1, 1);
			if (j % 2 == 0)
			rect(x_centre - x + j, y_centre + y - j, 1, 1);
			rect(x_centre - y + j, y_centre + x - j, 1, 1);
			rect(x_centre + x - j, y_centre - y + j, 1, 1);
			if (j % 2 == 0)
			rect(x_centre + y - j, y_centre - x + j, 1, 1);
			rect(x_centre - x + j, y_centre - y + j, 1, 1);
			rect(x_centre - y + j, y_centre - x + j, 1, 1);

			if (d >= 2 * x) { 
				d = d - 2 * x - 1;
				x = x + 1;
			} else if (d < 2 * (r - y)) {
				d = d + 2 * y - 1;
				y = y - 1;
			} else { 
				d = d + 2 * (y - x - 1);
				y = y - 1;
				x = x + 1;
			}
		}
		
		x = 0;
		y = r;
		d = r - 1;
		
		stroke(0, 0, 0, 64 * ni);
	}
}


function setup() {
	createCanvas(800, 800);
	
	background(255);
	
	//colorMode(HSL, 360, 255, 255);
	ellipseMode(CENTER);
	
	generate();
	
	noiseDetail(7, 0.7);
}

function draw() {

}

function generate() {
	noStroke();
	
	background(0);
/*	
	fill(0, 0, 0, 255);
	ellipse(width / 3, height / 3, width / 2.25, width / 2.25);
	
	ellipse(width / 2, height / 1.75, width / 2.25, width / 2.25);
	ellipse(width / 1.5, height / 2.75, width / 3.0, width / 3.0);
*/
	
	stroke(0, 0, 0, 255);
	for (let i = 0; i < 4; i += 1) {
		push();
		translate(width / 2, height / 2);
		rotate(i / 4 * 180);
		andres_circle(0, 0, 1 + width / 1.75 * (i / 4));
		pop();
	}
	
/*
	stroke(0, 0, 0, 255);
	andres_circle(width / 2.65, height / 2.75, width / 4);
	stroke(0, 0, 0, 255);
	andres_circle(width / 2, height - height / 3, width / 4);
	stroke(0, 0, 0, 255);
	andres_circle(width - width / 3.5, height / 2.95, width / 7);
*/
/*
	fill(226, 20, 64);
	rect(0, 0, width, height);
	
	let x = 0;
	let y = 0;
	let i = 0;
	let j = 0;
	
	for (i = 0; i < 64; i += 1) {
		let ni = i / 64;
		
		let ra = random(32, 128);
		let xx = random(0, width);
		let yy = random(0, height);
		
		for (j = 0; j < 64; j += 1) {
			let nj = pow(j / 64, 0.25);

			fill(0, 0, 255 * (1 - nj), 1);
			ellipse(xx, yy, ra * nj, ra * nj);
		}
	}
	
	noFill();
	for (x = 0; x < width; x += 4) {
		for (y = 0; y < height; y += 4) {
			if (random() > 0.7) {
				stroke(0, 0, 224, random(0.01, 0.1));
				line(x + random(-4, 4), y + random(-4, 4), x + random(-4, 4), y + random(-4, 4));
			}
		}
	}
*/
}"
"971399","C1","mySketch","function andres_circle(x_centre, y_centre, r) {	
	let x = 0;
	let y = r;
	let d = r - 1;
	
	for (let i = 0; i < 100; i += 1) {
		let ni = 1 - i / 100;
		
		while (y >= x) {
			let k = noise(x / width * 6, y / height * 6);
			let j = abs(k * i * 1.3);
			
			rect(x_centre + x - j, y_centre + y - j, 1, 1);
			rect(x_centre + y - j, y_centre + x - j, 1, 1);
			rect(x_centre - x + j, y_centre + y - j, 1, 1);
			rect(x_centre - y + j, y_centre + x - j, 1, 1);
			rect(x_centre + x - j, y_centre - y + j, 1, 1);
			rect(x_centre + y - j, y_centre - x + j, 1, 1);
			rect(x_centre - x + j, y_centre - y + j, 1, 1);
			rect(x_centre - y + j, y_centre - x + j, 1, 1);

			if (d >= 2 * x) { 
				d = d - 2 * x - 1;
				x = x + 1;
			} else if (d < 2 * (r - y)) {
				d = d + 2 * y - 1;
				y = y - 1;
			} else { 
				d = d + 2 * (y - x - 1);
				y = y - 1;
				x = x + 1;
			}
		}
		
		x = 0;
		y = r;
		d = r - 1;
		
		stroke(0, 0, 0, 64 * ni);
	}
}


function setup() {
	createCanvas(700, 700);
	
	background(255);
	
	//colorMode(HSL, 360, 255, 255);
	ellipseMode(CENTER);
	
	generate();
	
	noiseDetail(7, 0.7);
}

function draw() {

}

function generate() {
	noStroke();
	
	background(255);
/*	
	fill(0, 0, 0, 255);
	ellipse(width / 3, height / 3, width / 2.25, width / 2.25);
	
	ellipse(width / 2, height / 1.75, width / 2.25, width / 2.25);
	ellipse(width / 1.5, height / 2.75, width / 3.0, width / 3.0);
*/
	
	stroke(0, 0, 0, 255);
	for (let i = 0; i < 10; i += 1) {
		push();
		translate(width / 2, height / 2);
		rotate(i / 10 * 360);
		andres_circle(0, 0, 1 + width / 1.95 * (i / 10));
		pop();
	}
	
/*
	stroke(0, 0, 0, 255);
	andres_circle(width / 2.65, height / 2.75, width / 4);
	stroke(0, 0, 0, 255);
	andres_circle(width / 2, height - height / 3, width / 4);
	stroke(0, 0, 0, 255);
	andres_circle(width - width / 3.5, height / 2.95, width / 7);
*/
/*
	fill(226, 20, 64);
	rect(0, 0, width, height);
	
	let x = 0;
	let y = 0;
	let i = 0;
	let j = 0;
	
	for (i = 0; i < 64; i += 1) {
		let ni = i / 64;
		
		let ra = random(32, 128);
		let xx = random(0, width);
		let yy = random(0, height);
		
		for (j = 0; j < 64; j += 1) {
			let nj = pow(j / 64, 0.25);

			fill(0, 0, 255 * (1 - nj), 1);
			ellipse(xx, yy, ra * nj, ra * nj);
		}
	}
	
	noFill();
	for (x = 0; x < width; x += 4) {
		for (y = 0; y < height; y += 4) {
			if (random() > 0.7) {
				stroke(0, 0, 224, random(0.01, 0.1));
				line(x + random(-4, 4), y + random(-4, 4), x + random(-4, 4), y + random(-4, 4));
			}
		}
	}
*/
}"
"964622","S10","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 4;

function setup() {
  createCanvas(windowHeight, windowHeight);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (2.05), y: abs(width / (2.0) - x + y / (1.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.095 * x) / 1 + j * (4 + y / 10), y: (height / 2 - y * 2 / j + (x / 1.0)) / 1.25 + j * (100 - x / 10) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 - x * j) / (8 * (j / 2) + x / (width / 1)), y: y / 1.25 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (3.25) - x + y / (1.95 * j * ((0.5 - y / width) * 10))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 1, y: (height / 2 - y * 1.15 / j + (x / 10.075)) / 1.75 + j * (15) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (1.065 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 1; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let nx1 = y[j] / height;
				let inx1 = 0.5+pow(1-nx1, 2);
				let nx2 = y2[j] / height;
				let inx2 = 0.75+pow(nx2, 3.5);
			
				let e = 0.75;

				if (iter > 20) {
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.0225 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);

					point(x[j] * inx1+5, height / 1 - y[j]/1.385);
					point(width - x[j] * inx1-5, height / 1 - y[j]/1.385);
					
					//point(width / 2 - x[j] * 0.5 * inx1+5, height / 1.2 - y[j]/1.5);
					//point(width / 2 + x[j] * 0.5 * inx1-5, height / 1.2 - y[j]/1.5);
					point(x[j] / 1 * inx2+5, y[j]/1.65);
					point(width - x[j] / 1 * inx2-5, y[j]/1.65);
					point(width / 2 - x[j] / 0.75 * inx2+5, height - (y[j]/1.85 - height / 4));//(y[j]/1.85 - height / 4));
					point(width / 2 + x[j] / 0.75 * inx2-5, height - (y[j]/1.85 - height / 4));//(y[j]/1.85 - height / 4));	
					point(width / 2 - x[j] / 0.75 * inx2+5, (y[j]/1.85 - height / 4));
					point(width / 2 + x[j] / 0.75 * inx2-5, (y[j]/1.85 - height / 4));	
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"963856","Papilio Fractal","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 4;

function setup() {
  createCanvas(800, 800);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (2.05), y: abs(width / (1.5) - x + y / (1.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.0 * x) / 1 + j * (1 + y / 10), y: (height / 2 - y * 2 / j + (x / 1.0)) / 1.25 + j * (20 - x / 10) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.75 - x * j) / (8 * (j / 4) + x / (width / 100)), y: y / 2.25 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (2.0), y: abs(width / (1.5) - x + y / (1.45 * j * ((0.5 - y / width) * 800))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.0 * x) / 1 + j * (1 + y / 10), y: (height / 2 - y * 2 / j + (x / 1.0)) / 1.25 + j * (20 - x / 10) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 - x * j) / (8 * (j / 6) + x / (width / 100)), y: y / 2.25 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 0; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let nx1 = y[j] / height;
				let inx1 = 0.5+pow(nx1, 3);
				let nx2 = y2[j] / height;
				let inx2 = 0.5+pow(nx1, 3.5);
				let inx3 = abs(sin(nx1 * PI * 2.9));
				let inx4 = 0.05+pow(nx1, 1.5);
				let ny1 = abs(0.5 - x[j] / width) * 2;
				let ny = x[j] / width;
				let iny = pow(1-ny1, 0.5);
				let iny2 = 0.05+pow(1-ny1, 0.5);
				let iny3 = 0.25 + abs(sin(ny * PI * 2));
				
				let e = 0.75;

				if (iter > 20) {
					stroke(200+(i / 1000) + 300 * (iter / 500000), 32 * pow((j / ifs), 2), 200, 0.0825 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);


					point(width / 2 + x[j] * inx4*0.25, height / 2.35 - y[j]*0.25*iny);
					point(width / 2 - x[j] * inx4*0.25, height / 2.35 - y[j]*0.25*iny);
					
					point(width / 2 + x[j] * inx1*1.95, height / 1.85 - y[j]*1*iny);
					point(width / 2 - x[j] * inx1*1.95, height / 1.85 - y[j]*1*iny);
					point(width / 2 + x2[j] * inx2*1.15, height / 0.925 - (height/ 1.85 - y2[j]*0.75*iny2));
					point(width / 2 - x2[j] * inx2*1.15, height / 0.925 - (height/ 1.85 - y2[j]*0.75*iny2));

					stroke(240 + (i / 1000) + 250 * (iter / 500000), 16 * pow((j / ifs), 2), 200, 0.02925 * a);
					point(width / 2 + x[j] * inx3*0.025, height / 1.705 - y[j]*0.25);
					point(width / 2 - x[j] * inx3*0.025, height / 1.705 - y[j]*0.25);
					
					//point(width / 2 - x[j] * 1 * inx2+5, height / 2 - y[j]/2.5);
					//point(width / 2 + x[j] * 1 * inx2-5, height / 2 - y[j]/2.5);
					//point(width / 2 - x[j] / 1 * inx2, y[j]/1.45*iny2+60);
					//point(width / 2 + x[j] / 1 * inx2, y[j]/1.45*iny2+60);
					//point(width - x[j] / 0.8 * inx2, y[j]/1.65*iny2);
					//point(x[j] / 0.8 * inx2-5, y[j]/1.65*iny2);
					//point(x[j] * inx2*1.25+5, height - (y[j]/1.85 - height / 8));
					//point(width - x[j]* inx2*1.25-5, height - (y[j]/1.85 - height / 8));	
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"963856","Papilio Fractal","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 4;

function setup() {
  createCanvas(800, 800);
  background(255);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	//generate();
}

function f1(x, y, j) {
	return { x: y / (2.05), y: abs(width / (1.5) - x + y / (1.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.0 * x) / 1 + j * (1 + y / 10), y: (height / 2 - y * 2 / j + (x / 1.0)) / 1.25 + j * (20 - x / 10) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.75 - x * j) / (8 * (j / 4) + x / (width / 100)), y: y / 2.25 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (2.0), y: abs(width / (1.5) - x + y / (1.45 * j * ((0.5 - y / width) * 800))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.0 * x) / 1 + j * (1 + y / 10), y: (height / 2 - y * 2 / j + (x / 1.0)) / 1.25 + j * (20 - x / 10) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 - x * j) / (8 * (j / 6) + x / (width / 100)), y: y / 2.25 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 5000000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 0; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let nx1 = y[j] / height;
				let inx1 = 0.5+pow(nx1, 3);
				let nx2 = y2[j] / height;
				let inx2 = 0.5+pow(nx1, 3.5);
				let inx3 = abs(sin(nx1 * PI * 2.9));
				let inx4 = 0.05+pow(nx1, 1.5);
				let ny1 = abs(0.5 - x[j] / width) * 2;
				let ny = x[j] / width;
				let iny = pow(1-ny1, 0.5);
				let iny2 = 0.05+pow(1-ny1, 0.5);
				let iny3 = 0.25 + abs(sin(ny * PI * 2));
				
				let e = 0.75;

				if (iter > 20) {
					stroke(200+(i / 1000) + 300 * (iter / 500000), 32 * pow((j / ifs), 2), 0, 0.0125 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);

					
					point(width / 2 + x[j] * inx1*1.95, height / 1.85 - y[j]*1*iny);
					point(width / 2 - x[j] * inx1*1.95, height / 1.85 - y[j]*1*iny);
					point(width / 2 + x2[j] * inx2*1.15, height / 0.925 - (height/ 1.85 - y2[j]*0.75*iny2));
					point(width / 2 - x2[j] * inx2*1.15, height / 0.925 - (height/ 1.85 - y2[j]*0.75*iny2));

					stroke(240 + (i / 1000) + 250 * (iter / 500000), 16 * pow((j / ifs), 2), 0, 0.00825 * a);
					point(width / 2 + x[j] * inx4*0.25, height / 2.35 - y[j]*0.25*iny);
					point(width / 2 - x[j] * inx4*0.25, height / 2.35 - y[j]*0.25*iny);
					if (y[j] > -height * 0.1 && y[j] < height / 1.5) { // clamp body so it don't leak above / below
						point(width / 2 + x[j] * inx3*0.025, height / 1.705 - y[j]*0.25);
						point(width / 2 - x[j] * inx3*0.025, height / 1.705 - y[j]*0.25);
					}
					
					//point(width / 2 - x[j] * 1 * inx2+5, height / 2 - y[j]/2.5);
					//point(width / 2 + x[j] * 1 * inx2-5, height / 2 - y[j]/2.5);
					//point(width / 2 - x[j] / 1 * inx2, y[j]/1.45*iny2+60);
					//point(width / 2 + x[j] / 1 * inx2, y[j]/1.45*iny2+60);
					//point(width - x[j] / 0.8 * inx2, y[j]/1.65*iny2);
					//point(x[j] / 0.8 * inx2-5, y[j]/1.65*iny2);
					//point(x[j] * inx2*1.25+5, height - (y[j]/1.85 - height / 8));
					//point(width - x[j]* inx2*1.25-5, height - (y[j]/1.85 - height / 8));	
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 192 + pow(ny, 1) * 68, 0.002);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"963856","Papilio Fractal","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 4;

function setup() {
  createCanvas(800, 800);
  background(255);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	//generate();
}

function f1(x, y, j) {
	return { x: y / (2.05), y: abs(width / (1.5) - x + y / (1.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.0 * x) / 1 + j * (1 + y / 10), y: (height / 2 - y * 2 / j + (x / 1.0)) / 1.25 + j * (20 - x / 10) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.75 - x * j) / (8 * (j / 4) + x / (width / 100)), y: y / 2.25 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (2.0), y: abs(width / (1.5) - x + y / (1.45 * j * ((0.5 - y / width) * 800))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.0 * x) / 1 + j * (1 + y / 10), y: (height / 2 - y * 2 / j + (x / 1.0)) / 1.25 + j * (20 - x / 10) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 - x * j) / (8 * (j / 6) + x / (width / 100)), y: y / 2.25 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 5000000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 0; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let nx1 = y[j] / height;
				let inx1 = 0.5+pow(nx1, 3);
				let nx2 = y2[j] / height;
				let inx2 = 0.5+pow(nx1, 3.5);
				let inx3 = abs(sin(nx1 * PI * 2.9));
				let inx4 = 0.05+pow(nx1, 1.5);
				let ny1 = abs(0.5 - x[j] / width) * 2;
				let ny = x[j] / width;
				let iny = pow(1-ny1, 0.5);
				let iny2 = 0.05+pow(1-ny1, 0.5);
				let iny3 = 0.25 + abs(sin(ny * PI * 2));
				
				let e = 0.75;

				if (iter > 20) {
					stroke(200+(i / 1000) + 300 * (iter / 500000), 32 * pow((j / ifs), 2), 0, 0.0125 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);

					
					point(width / 2 + x[j] * inx1*1.95, height / 1.85 - y[j]*1*iny);
					point(width / 2 - x[j] * inx1*1.95, height / 1.85 - y[j]*1*iny);
					point(width / 2 + x2[j] * inx2*1.15, height / 0.925 - (height/ 1.85 - y2[j]*0.75*iny2));
					point(width / 2 - x2[j] * inx2*1.15, height / 0.925 - (height/ 1.85 - y2[j]*0.75*iny2));

					stroke(240 + (i / 1000) + 250 * (iter / 500000), 16 * pow((j / ifs), 2), 0, 0.00825 * a);
					point(width / 2 + x[j] * inx4*0.25, height / 2.35 - y[j]*0.25*iny);
					point(width / 2 - x[j] * inx4*0.25, height / 2.35 - y[j]*0.25*iny);
					if (y[j] > -height * 0.1 && y[j] < height / 1.5) { // clamp body so it don't leak above / below
						point(width / 2 + x[j] * inx3*0.025, height / 1.705 - y[j]*0.25);
						point(width / 2 - x[j] * inx3*0.025, height / 1.705 - y[j]*0.25);
					}
					
					//point(width / 2 - x[j] * 1 * inx2+5, height / 2 - y[j]/2.5);
					//point(width / 2 + x[j] * 1 * inx2-5, height / 2 - y[j]/2.5);
					//point(width / 2 - x[j] / 1 * inx2, y[j]/1.45*iny2+60);
					//point(width / 2 + x[j] / 1 * inx2, y[j]/1.45*iny2+60);
					//point(width - x[j] / 0.8 * inx2, y[j]/1.65*iny2);
					//point(x[j] / 0.8 * inx2-5, y[j]/1.65*iny2);
					//point(x[j] * inx2*1.25+5, height - (y[j]/1.85 - height / 8));
					//point(width - x[j]* inx2*1.25-5, height - (y[j]/1.85 - height / 8));	
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 192 + pow(ny, 1) * 68, 0.002);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"961210","c5","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 5;

function setup() {
  createCanvas(windowHeight, windowHeight);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (1.25), y: abs(width / (1.125) - x + y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 1.75 * x) / 1 + j * 40, y: (height / 4 - y * 1 / j + (x / 2.5)) / 1.25 + j * (20) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 - x * j) / (2 * (j / 4) + x / (width / (20))), y: y / 1.25 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (2.25), y: abs(width / (1.125) - x + y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 1.275 * x) / 1 + j * 100, y: (height / 4 - y * 1 / j + (x / 2.5)) / 1.25 + j * (20) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 - x * j) / (1 * (j / 4) + x / (width / (20))), y: y / 1.25 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 3; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let nx1 = y[j] / height;
				let inx1 = 0.75+pow(1-nx1, 2);
				let nx2 = y2[j] / height;
				let inx2 = 0.15+pow(nx2, 0.5);
				
				let e = 0.75;

				if (iter > 20) {
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.0225 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);
					point(width / 2 - x2[j] * 0.5 * inx2+5, height / 1 - y2[j]/1.6);
					point(width / 2 + x2[j] * 0.5 * inx2+5, height / 1 - y2[j]/1.6);
			
					point(width / 2 - x[j] / 2 * inx1+5, y[j]/2);
					point(width / 2 + x[j] / 2 * inx1-5, y[j]/2);
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"961210","c5","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 5;

function setup() {
  createCanvas(windowHeight, windowHeight);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (1.25), y: abs(width / (1.125) - x + y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 1.75 * x) / 1 + j * 40, y: (height / 4 - y * 1 / j + (x / 2.5)) / 1.25 + j * (20) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 - x * j) / (2 * (j / 4) + x / (width / (20))), y: y / 1.25 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (2.25), y: abs(width / (1.125) - x + y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 1.275 * x) / 1 + j * 100, y: (height / 4 - y * 1 / j + (x / 2.5)) / 1.25 + j * (20) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 - x * j) / (1 * (j / 4) + x / (width / (20))), y: y / 1.25 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 3; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let nx1 = y[j] / height;
				let inx1 = 0.75+pow(1-nx1, 2);
				let nx2 = y2[j] / height;
				let inx2 = 0.15+pow(nx2, 0.25)* inx1;
				
				let e = 0.75;

				if (iter > 20) {
					stroke(200 * (j / ifs) * (i / 10000) + 200 * (iter / 10000), 32 * pow((j / ifs), 2), 150, 0.0225 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);
					point(width / 2 - x2[j] * 0.5 * inx2, height / 1 - y2[j]/1.6);
					point(width / 2 + x2[j] * 0.5 * inx2, height / 1 - y2[j]/1.6);
			
					point(width / 2 - x[j] / 2 * inx1, y[j]/2);
					point(width / 2 + x[j] / 2 * inx1, y[j]/2);
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"960453","c4","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 5;

function setup() {
  createCanvas(windowHeight, windowHeight);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (1.25), y: abs(width / (1.125) - x + y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 1.75 * x) / 1 + j * 40, y: (height / 4 - y * 1 / j + (x / 2.5)) / 1.25 + j * (20) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 - x * j) / (2 * (j / 4) + x / (width / (20))), y: y / 1.25 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (3.25) - x + y / (1.95 * j * ((0.5 - y / width) * 10))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 1, y: (height / 2 - y * 1.15 / j + (x / 10.075)) / 1.75 + j * (15) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (1.065 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 3; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let nx1 = y[j] / height;
				let inx1 = 0.75+pow(1-nx1, 2);
				let nx2 = y2[j] / height;
				let inx2 = 0.45+pow(nx2, 0.5);
				
				let e = 0.75;

				if (iter > 20) {
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.0225 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);
					point(width / 2 - x[j] * 0.75 * inx2+5, height / 1 - y[j]/1+height / 4);
					point(width / 2 + x[j] * 0.75 * inx2+5, height / 1 - y[j]/1+height / 4);
					
					//point(x[j] * inx2+5, height / 1 - y[j]/2.5);
					//point(width - x[j] * inx2-5, height / 1 - y[j]/2.5);
					point(width / 2 - x[j] / 2 * inx1+5, y[j]/1.75 - height / 12);
					point(width / 2 + x[j] / 2 * inx1-5, y[j]/1.75 - height / 12);
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"960441","G20","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 5;

function setup() {
  createCanvas(windowHeight, windowHeight);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (2.25), y: abs(width / (1.35) - x + y / (10.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 1.25 * x) / 1 + j * 10, y: (height / 1.0 - y * 1 / j + (x / 10.25)) / 1.25 + j * (20) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 + x * j - y / 2) / (2.5 * (j / 2) + x / (width / 0.25)), y: y / 1.25 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (2.0), y: abs(width / (2.25) - x + y / (1.95 * j * ((0.5 - y / width) * 800))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 10, y: (height / 2 - y * 1.15 / j + (x / 10.075)) / 1.75 + j * (15) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (2.065 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 3; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let nx1 = y[j] / height;
				let inx1 = 0.5+pow(1-nx1, 2);
				let nx2 = y2[j] / height;
				let inx2 = 0.75+pow(nx2, 3.5);
			
				let e = 0.75;

				if (iter > 20) {
					stroke(360 * (j / ifs) * (i / 500) + 200 * (iter / 10000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.0025 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);

					point(width / 2 - x[j] * inx1, height / 2 + y[j]/0.75-200);
					point(width / 2 + x[j] * inx1, height / 2 + y[j]/0.75-200);

					point(x[j] * inx1, y[j]/0.75-200);
					point(width - x[j] * inx1-5, y[j]/0.75-200);
					point(x[j] * inx1, height / 1 - y[j]/1.85 + 50);
					point(width - x[j] * inx1, height / 1 - y[j]/1.85+50);
					point(x[j] * 1 * inx2, height / 1 - y[j]/1);
					point(width - x[j] * 1 * inx2-5, height / 1 - y[j]/1);
					point(width / 2 - x[j] / 1 * inx1+5, y[j]/2.25 - height / 12);
					point(width / 2 + x[j] / 1 * inx1-5, y[j]/2.25 - height / 12);
					//point(width / 2 - x[j] / 3 * inx1+5, height / 2 + y[j]/3.25);

					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.0125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(width / 2 + x2[j] / 2 * inx1, height / 1.5 - y2[j]);
					//point(width / 2 - x2[j] / 2 * inx1, height / 1.5 - y2[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"960186","dem12","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 4;

function setup() {
  createCanvas(windowHeight, windowHeight);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (2.35), y: abs(width / (1.35) - x + y / (0.5 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 60, y: (height / 2 - y * 1.025 / j + (x / 1)) / 1.75 + j * (1) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 - x * j) / (1.75 * j + x / (width / 0.8)), y: y / 1.05 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (1.25) - x + y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 80, y: (height / 1.45 - y * 1.015 / j + (x / 1.75)) / 1.75 + j * (50) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (2.465 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 1; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let nx1 = y[j] / height;
				let inx1 = 0.5+pow(1-nx1, 3);
				let nx2 = y2[j] / height;
				let inx2 = 0.25+pow(nx2, 1.5);
				let ny1 = abs(0.5 - x[j] / width) * 2;
				let ny = x[j] / width;
				let iny = pow(1-ny1, 0.5);
				let iny2 = 0.25+pow(1-ny1, 0.5);
				let iny3 = 1.0 + (sin(ny * PI * 4))/3;
				
				let e = 0.75;

				if (iter > 20) {
					stroke(200 * (iter / 500000 * j), 192 * pow((j / ifs), 2) * a, 200, 0.0425 * a);
					//point(x[j] / 0.75 * inx1, y[j]);
					//point(width - x[j] / 0.75 * inx1, y[j]);
					//point(width / 2 - x[j] / 1, height -y[j]/3);
					//point(width / 2 + x[j] / 1, height -y[j]/3);
					point(width / 2 - x[j] / 0.575 * inx1, height / 0.95 - y[j]/1*iny3);
					point(width / 2 + x[j] / 0.575 * inx1, height / 0.95 - y[j]/1*iny3);
					//point( x[j] / 1 * inx2, y[j]/1.15-height/2);
					//point(width - x[j] / 1 * inx2, y[j]/1.15-height/2);
					//point(width / 2 - x[j] / 2 * inx2, y[j]/2.15*iny3-height/2);
					//point(width / 2 + x[j] / 2 * inx2, y[j]/2.15*iny3-height/2);
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);

					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 3.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), height - yy, x + random(-128, 128), height - (yy - random(32, height)));
		}
	}/*
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}*/
}"
"958022","S9","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 4;

function setup() {
  createCanvas(windowHeight, windowHeight);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (2.05), y: abs(width / (2.0) - x + y / (1.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.095 * x) / 1 + j * (4 + y / 10), y: (height / 2 - y * 2 / j + (x / 1.0)) / 1.25 + j * (100 - x / 10) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 - x * j) / (8 * (j / 2) + x / (width / 1)), y: y / 1.25 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (3.25) - x + y / (1.95 * j * ((0.5 - y / width) * 10))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 1, y: (height / 2 - y * 1.15 / j + (x / 10.075)) / 1.75 + j * (15) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (1.065 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 1; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let nx1 = y[j] / height;
				let inx1 = 0.5+pow(1-nx1, 2);
				let nx2 = y2[j] / height;
				let inx2 = 0.75+pow(nx2, 3.5);
				let ny1 = abs(0.5 - x[j] / width) * 2;
				let ny = x[j] / width;
				let iny = pow(1-ny1, 0.5);
				let iny2 = 0.25+pow(ny1, 0.5);
				let iny3 = 0.25 + abs(sin(ny * PI * 2));
				
				let e = 0.75;

				if (iter > 20) {
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.0225 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);

					point(x[j] * inx1*1.25+5, height / 1 - y[j]*1.5*iny-50);
					point(width - x[j] * inx1*1.25-5, height / 1 - y[j]*1.5*iny-50);
					
					//point(width / 2 - x[j] * 1 * inx2+5, height / 2 - y[j]/2.5);
					//point(width / 2 + x[j] * 1 * inx2-5, height / 2 - y[j]/2.5);
					point(width / 2 - x[j] / 1 * inx2, y[j]/1.45*iny2+60);
					point(width / 2 + x[j] / 1 * inx2, y[j]/1.45*iny2+60);
					//point(width - x[j] / 0.8 * inx2, y[j]/1.65*iny2);
					//point(x[j] / 0.8 * inx2-5, y[j]/1.65*iny2);
					point(x[j] * inx2*1.25+5, height - (y[j]/1.85 - height / 8));
					point(width - x[j]* inx2*1.25-5, height - (y[j]/1.85 - height / 8));	
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"957963","S8","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 4;

function setup() {
  createCanvas(windowHeight, windowHeight);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (2.05), y: abs(width / (2.0) - x + y / (1.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.095 * x) / 1 + j * (4 + y / 10), y: (height / 2 - y * 2 / j + (x / 1.0)) / 1.25 + j * (100 - x / 10) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 - x * j) / (8 * (j / 2) + x / (width / 1)), y: y / 1.25 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (3.25) - x + y / (1.95 * j * ((0.5 - y / width) * 10))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 1, y: (height / 2 - y * 1.15 / j + (x / 10.075)) / 1.75 + j * (15) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (1.065 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 1; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let nx1 = y[j] / height;
				let inx1 = 0.5+pow(1-nx1, 2);
				let nx2 = y2[j] / height;
				let inx2 = 0.75+pow(nx2, 3.5);
			
				let e = 0.75;

				if (iter > 20) {
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.0225 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);

					point(x[j] * inx1+5, height / 1 - y[j]/1.385);
					point(width - x[j] * inx1-5, height / 1 - y[j]/1.385);
					
					//point(width / 2 - x[j] * 0.5 * inx1+5, height / 1.2 - y[j]/1.5);
					//point(width / 2 + x[j] * 0.5 * inx1-5, height / 1.2 - y[j]/1.5);
					point(width / 2 - x[j] / 0.8 * inx2+5, y[j]/1.65);
					point(width / 2 + x[j] / 0.8 * inx2-5, y[j]/1.65);
					point(width / 2 - x[j] / 0.75 * inx2+5, height - (y[j]/1.85 - height / 4));
					point(width / 2 + x[j] / 0.75 * inx2-5, height - (y[j]/1.85 - height / 4));	
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"957199","G6","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 4;

function setup() {
  createCanvas(windowHeight, windowHeight);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (2.25), y: abs(width / (1.5) - x + y / (1.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.25 * x) / 1 + j * (10 + x / 40), y: (height / 2 - y * 1 / j + (x / 1.5)) / 1.25 + j * (100) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 - x * j) / (4 * (j / 2) + x / (width / 1)), y: y / 1.25 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (3.25) - x + y / (1.95 * j * ((0.5 - y / width) * 10))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 1, y: (height / 2 - y * 1.15 / j + (x / 10.075)) / 1.75 + j * (15) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (1.065 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 1; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let nx1 = y[j] / height;
				let inx1 = 0.5+pow(1-nx1, 2);
				let nx2 = y2[j] / height;
				let inx2 = 0.75+pow(nx2, 3.5);
			
				let e = 0.75;

				if (iter > 20) {
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.0225 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);

					point(x[j] * inx1+5, height / 1 - y[j]/1.385);
					point(width - x[j] * inx1-5, height / 1 - y[j]/1.385);
					point(width / 2 - x[j] * 1 * inx2+5, height / 1 - y[j]/1);
					point(width / 2 + x[j] * 1 * inx2-5, height / 1 - y[j]/1);
					point(width / 2 - x[j] / 0.75 * inx1+5, y[j]/1.85 - height / 12);
					point(width / 2 + x[j] / 0.75 * inx1-5, y[j]/1.85 - height / 12);
					
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"957128","G5","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 4;

function setup() {
  createCanvas(windowHeight, windowHeight);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (2.25), y: abs(width / (1.725) - x + y / (1.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.25 * x) / 1 + j * 40, y: (height / 1 - y * 1 / j + (x / 1.5)) / 1.25 + j * (10) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 - x * j) / (4 * (j / 2) + x / (width / 10)), y: y / 1.25 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (3.25) - x + y / (1.95 * j * ((0.5 - y / width) * 10))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 1, y: (height / 2 - y * 1.15 / j + (x / 10.075)) / 1.75 + j * (15) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (1.065 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 1; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let nx1 = y[j] / height;
				let inx1 = 0.5+pow(1-nx1, 2);
				let nx2 = y2[j] / height;
				let inx2 = 0.75+pow(nx2, 3.5);
			
				let e = 0.75;

				if (iter > 20) {
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.0425 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);

					
					point(x[j] * inx1+5, height / 1 - y[j]/1.85);
					point(width - x[j] * inx1-5, height / 1 - y[j]/1.85);
					point(width / 2 - x[j] * 1 * inx2+5, height / 1 - y[j]/1);
					point(width / 2 + x[j] * 1 * inx2-5, height / 1 - y[j]/1);
					point(width / 2 - x[j] / 1 * inx1+5, y[j]/2.25 - height / 12);
					point(width / 2 + x[j] / 1 * inx1-5, y[j]/2.25 - height / 12);
					
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"957118","G4","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 4;

function setup() {
  createCanvas(windowHeight, windowHeight);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (2.25), y: abs(width / (1.725) - x + y / (1.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.25 * x) / 1 + j * 60, y: (height / 1.5 - y * 1 / j + (x / 1.5)) / 1.25 + j * (10) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 - x * j) / (4 * (j / 2) + x / (width / 10)), y: y / 1.25 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (3.25) - x + y / (1.95 * j * ((0.5 - y / width) * 10))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 1, y: (height / 2 - y * 1.15 / j + (x / 10.075)) / 1.75 + j * (15) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (1.065 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 1; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let nx1 = y[j] / height;
				let inx1 = 0.5+pow(1-nx1, 2);
				let nx2 = y2[j] / height;
				let inx2 = 0.75+pow(nx2, 3.5);
			
				let e = 0.75;

				if (iter > 20) {
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.0425 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);

					
					point(x[j] * inx1+5, height / 1 - y[j]/1.85);
					point(width - x[j] * inx1-5, height / 1 - y[j]/1.85);
					point(width / 2 - x[j] * 1 * inx2+5, height / 1 - y[j]/1);
					point(width / 2 + x[j] * 1 * inx2-5, height / 1 - y[j]/1);
					point(width / 2 - x[j] / 1 * inx1+5, y[j]/2.25 - height / 12);
					point(width / 2 + x[j] / 1 * inx1-5, y[j]/2.25 - height / 12);
					
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"956464","Pieces Croco","mySketch","var xmotion = 0;
var ymotion = 0;

var objs = [];
var nn = 100;

// https://iquilezles.org/www/articles/palettes/palettes.htm
function pal(t, a, b, c, d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

function setup() {
	createCanvas(600, 600);
	
	background(0);
	
	noiseDetail(7, 0.7);
	
	for (var n = 0; n < nn; n += 1) {
		objs[n] = { x: width * random(), y: 0, vx: random(-1, 1) / 6000, vy: 1, n: random(-1, 1) * width };
	}
	
	ellipseMode(CENTER);
	rectMode(CENTER);
}
let a = 1; b = 1; c = 1;
function compute() {
	fill(0);
	
	strokeWeight(2);

	for (var n = 0; n < nn; n += 1) {
		objs[n].n += objs[n].vx;
		objs[n].y += objs[n].vy;
		objs[n].x = -width + noise(objs[n].n) * width * 2;
		
		objs[n].y %= height;
		if (objs[n].y == 0) {
			for (var no = 0; no < nn; no += 1) {
			objs[no].n = random(-1, 1) * width
			}
	//fill(0, 0, 0, 64);
	//rect(width / 2+random(-width, width), height / 2, width, height+random(-width, width));
		}
		
		var dd = Infinity;
		var did = n;
		
		for (var i = 0; i < nn; i += 1) {
			var d = (abs((objs[n].x - objs[i].x) * (objs[n].x - objs[i].x)) + abs((objs[n].y - objs[i].y) * (objs[n].y - objs[i].y))); // sqrt
			if (i !== n && d < dd) {
				did = i;
				dd = d;
			}
		}
		
		if (did !== n) {
			objs[did].vx = -objs[did].vx;
		}
		
		var pa1 = 0.5, pa2 = 0.5, pa3 = 0.5;
		var pb1 = 0.75, pb2 = 0.5, pb3 = 0.5;
		var pc1 = 0.75, pc2 = 0.5, pc3 = 0.5;

		var pdr = 0.05*a;
		var pdg = 0.35*b;
		var pdb = 0.25*c;

		var pt = noise(objs[n].n * 30 + xmotion);

		var rf = pal(pt, pa1, pb1, pc1, pdr) * 255;
		var gf = pal(pt, pa2, pb2, pc2, pdg) * 255;
		var bf = pal(pt, pa3, pb3, pc3, pdb) * 255;
		
		stroke(rf, gf, bf, 255);
		line(objs[n].x, objs[n].y, objs[did].x, objs[did].y);
		noStroke();
		//noFill();
		//stroke(0, 0, 0, 255);
		//fill(0, 0, 0, 255);
		//rect(objs[n].x, objs[n].y, 1, 1);
		//rect(objs[did].x, objs[did].y, 1, 1);
	}
}

function draw() {
	noStroke();
/*
	fill(0, 0, 0, 1);
	rect(0, 0, windowWidth, windowHeight);
*/
	compute();
	
	xmotion += 0.0008;
	ymotion += 0.0002;
}"
"956454","Pieces 10","mySketch","var xmotion = 0;
var ymotion = 0;

var objs = [];
var nn = 500;

// https://iquilezles.org/www/articles/palettes/palettes.htm
function pal(t, a, b, c, d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

function setup() {
	createCanvas(600, 600);
	
	background(0);
	
	noiseDetail(7, 0.7);
	
	for (var n = 0; n < nn; n += 1) {
		objs[n] = { x: width * random(), y: 0, vx: random(-1, 1) / 6000, vy: 1, n: random(-1, 1) * width };
	}
	
	ellipseMode(CENTER);
	rectMode(CENTER);
}
let a = 1; b = 1; c = 1;
function compute() {
	fill(0);
	
	strokeWeight(10);

	for (var n = 0; n < nn; n += 1) {
		objs[n].n += objs[n].vx;
		objs[n].y += objs[n].vy;
		objs[n].x = -width + noise(objs[n].n) * width * 2;
		
		objs[n].y %= height;
		if (objs[n].y == 0) {
			objs[n].n = random(-1, 1) * width
	//fill(0, 0, 0, 64);
	//rect(width / 2+random(-width, width), height / 2, width, height+random(-width, width));
		}
		
		var dd = Infinity;
		var did = n;
		
		for (var i = 0; i < nn; i += 1) {
			var d = (abs((objs[n].x - objs[i].x) * (objs[n].x - objs[i].x)) + abs((objs[n].y - objs[i].y) * (objs[n].y - objs[i].y))); // sqrt
			if (i !== n && d < dd) {
				did = i;
				dd = d;
			}
		}
		
		if (did !== n) {
			objs[did].vx = -objs[did].vx;
		}
		
		var pa1 = 0.75, pa2 = 0.75, pa3 = 0.75;
		var pb1 = 0.5, pb2 = 0.5, pb3 = 0.5;
		var pc1 = 1, pc2 = 1, pc3 = 0.5;

		var pdr = 0.7*a;
		var pdg = 0.8*b;
		var pdb = 0.3*c;

		var pt = noise(objs[n].n * 30 + xmotion);

		var rf = pal(pt, pa1, pb1, pc1, pdr) * 255;
		var gf = pal(pt, pa2, pb2, pc2, pdg) * 255;
		var bf = pal(pt, pa3, pb3, pc3, pdb) * 255;
		
		stroke(rf, gf, bf, 255);
		line(objs[n].x, objs[n].y, objs[did].x, objs[did].y);
		noStroke();
		//noFill();
		//stroke(0, 0, 0, 255);
		fill(0, 0, 0, 255);
		rect(objs[n].x, objs[n].y, 1, 1);
		rect(objs[did].x, objs[did].y, 1, 1);
	}
}

function draw() {
	noStroke();
/*
	fill(0, 0, 0, 1);
	rect(0, 0, windowWidth, windowHeight);
*/
	compute();
	
	xmotion += 0.0008;
	ymotion += 0.0002;
}"
"956408","skull","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 4;

function setup() {
  createCanvas(windowHeight, windowHeight);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (1.75 + x / width / 2 ), y: abs(width / (1.0) - x + y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 1.75 * x + x / 16) / 1 + j * 10, y: (height / 4 - y * 0.95 / j + (x / 2.25)) / 1 + j * (200) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 - x * j * 2) / (1.0 * (j / 2) + x / (width / (20))), y: y / 1.75 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (3.25) - x + y / (1.95 * j * ((0.5 - y / width) * 80))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 10, y: (height / 4 - y * 1.05 / j + (x / 10.075)) / 1.75 + j * (16) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (1.65 * j + x / (width / 4)), y: y / 1.5 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 1; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let nx1 = y[j] / height;
				let inx1 = 0.35+pow(1-nx1, 2);
				let nx2 = y2[j] / height;
				let inx2 = 0.125+pow(nx2, 1.5);
				let inx3 = 0.5+pow(1-nx2, 1.5);
				
				let e = 0.75;

				if (iter > 20) {
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.0225 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);
					//point(x[j] * 1.25 * inx2+5, y[j]/125);
					//point(width - x[j] * 1.25 * inx2+5, y[j]/125);
					
					//point(width / 8 - x[j]/3 * (1-inx3), height - y[j]/4);
					//point(width / 8 + x[j]/3 * (1-inx3), height - y[j]/4);
					//point(width/2 - x[j] * (1-inx2), height - y[j]/4);	
					point(width - y[j]/2+10, x[j] * (1-inx2)*0.5+5);
					point(y[j]/2-10, x[j] * (1-inx2)*0.5+5);
					point(x[j] * inx3/2.5+5, y[j]/3);
					point(width - x[j]/2.5 * inx3-5, y[j]/3);
					//point(x[j] * inx3/3.5+5, height - y[j]/2);
					//point(width - x[j]/3.5 * inx3-5, height - y[j]/2);
					
					point(width / 2 + x[j] * 2 * inx2, height - y[j]/1.1 - height / 8);
					point(width / 2 - x[j] * 2 * inx2, height - y[j]/1.1 - height / 8);
					point(width / 2 - x[j] / 1 * inx1+5, y[j]/1.25 - height / 1);
					point(width / 2 + x[j] / 1 * inx1-5, y[j]/1.25 - height / 1);
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"956035","eye","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 4;

function setup() {
  createCanvas(windowHeight, windowHeight);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (1.25), y: abs(width / (1.125) - x + y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 1.75 * x) / 1 + j * 40, y: (height / 4 - y * 1 / j + (x / 2.5)) / 1.25 + j * (200) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 - x * j) / (2 * (j / 4) + x / (width / (20))), y: y / 1.25 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (3.25) - x + y / (1.95 * j * ((0.5 - y / width) * 10))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 1, y: (height / 2 - y * 1.15 / j + (x / 10.075)) / 1.75 + j * (15) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (1.065 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 1; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let nx1 = y[j] / height;
				let inx1 = 0.5+pow(1-nx1, 2);
				let nx2 = y2[j] / height;
				let inx2 = 0.45+pow(nx2, 2.5);
				
				let e = 0.75;

				if (iter > 20) {
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.0225 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);
					point(width / 2 - x[j] * 1.5 * inx2+5, height / 1 - y[j]/1+200);
					point(width / 2 + x[j] * 1.5 * inx2+5, height / 1 - y[j]/1+200);
					
					point(x[j] * inx2+5, height / 1 - y[j]/1.85);
					point(width - x[j] * inx2-5, height / 1 - y[j]/1.85);
					point(width / 2 - x[j] / 1 * inx1+5, y[j]/2.25 - height / 12);
					point(width / 2 + x[j] / 1 * inx1-5, y[j]/2.25 - height / 12);
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"956011","G2","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 4;

function setup() {
  createCanvas(windowHeight, windowHeight);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (1.25), y: abs(width / (1.125) - x + y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 1.25 * x) / 1 + j * 40, y: (height / 2 - y * 1 / j + (x / 1.75)) / 1.25 + j * (100) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 - x * j) / (2 * (j / 4) + x / (width / 10)), y: y / 1.25 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (3.25) - x + y / (1.95 * j * ((0.5 - y / width) * 10))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 1, y: (height / 2 - y * 1.15 / j + (x / 10.075)) / 1.75 + j * (15) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (1.065 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 1; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let nx1 = y[j] / height;
				let inx1 = 0.5+pow(1-nx1, 2);
				let nx2 = y2[j] / height;
				let inx2 = 0.45+pow(nx2, 2.5);
				
				let e = 0.75;

				if (iter > 20) {
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.0425 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);
					point(width / 2 - x[j] * 1.5 * inx2+5, height / 1 - y[j]/1);
					point(width / 2 + x[j] * 1.5 * inx2+5, height / 1 - y[j]/1);
					
					point(x[j] * inx2+5, height / 1 - y[j]/1.85);
					point(width - x[j] * inx2-5, height / 1 - y[j]/1.85);
					point(width / 2 - x[j] / 1 * inx1+5, y[j]/2.25 - height / 12);
					point(width / 2 + x[j] / 1 * inx1-5, y[j]/2.25 - height / 12);
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"954951","dem10","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 4;

function setup() {
  createCanvas(windowHeight, windowHeight);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (2.35), y: abs(width / (1.35) - x + y / (0.5 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 60, y: (height / 2 - y * 1.25 / j + (x / 1)) / 1.75 + j * (10) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 - x * j) / (1.75 * j + x / (width / 0.8)), y: y / 1.05 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.65), y: abs(width / (1.35) - x + y / (10.5 * j * ((0.5 - y / width) * 800))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.25 * x + y / 4.75) / 1 + j * 0, y: (height / 5 - y * 1.25 / j + (x / 4)) / 1.75 + j * (180) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 - x * j) / (1.75 * j + x / (width / 0.8)), y: y / 1.5 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 1; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let nx1 = y[j] / height;
				let inx1 = 0.45+pow(1-nx1, 0.75);
				let nx2 = y2[j] / height;
				let inx2 = 0.5+pow(1-nx2, 2.5);
				let ny1 = abs(0.5 - x[j] / width) * 2;
				let ny = x[j] / width;
				let iny = pow(1-ny1, 0.5);
				let iny2 = 0.25+pow(1-ny1, 0.5);
				let iny3 = 0.25 + abs(sin(ny * PI * 2));
				
				let e = 0.75;

				if (iter > 20) {
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.0825 * a);
					point(width/2 + x2[j] / 1 * inx1, y2[j]/1.2*iny3 - height / 6);
					point(width/2 - x2[j] / 1 * inx1, y2[j]/1.2*iny3 - height / 6);
					//point(x[j] / 1 * inx1, height / 2 - y[j]/2);
					//point(width - x[j] / 1 * inx1, height / 2 - y[j]/2);
					//point(width / 2 - x[j] / 0.5 * inx1, height / 0.85 - y[j]/1);
					//point(width / 2 + x[j] / 0.5 * inx1, height / 0.85 - y[j]/1);
					//point( x[j] / 1 * inx2, y[j]/1.15-height/2);
					//point(width - x[j] / 1 * inx2, y[j]/1.15-height/2);
					point(width / 2 - x[j] * 2 * inx1, y[j]/1.65*iny3+height/2.5);
					point(width / 2 + x[j] * 2 * inx1, y[j]/1.65*iny3+height/2.5);
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);

					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 3.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), height - yy, x + random(-128, 128), height - (yy - random(32, height)));
		}
	}/*
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}*/
}"
"954123","Wild","mySketch","// finally with some clouds :) needed to be tuned a bit!
// different shading on the sea
// change the seeds; shading of both sea & sky vary greatly

function setup() {
	createCanvas(600, 600);
	
	noStroke();
	
	background(0);
	
	colorMode(HSL, 360, 255, 255, 1);
	
	noiseSeed(23);
	noiseDetail(8, 0.75);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	generate();
}

function draw() {
	
}

function generate() {
	noStroke();
	
	background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 2) {
		let ny = y / height;
		for (x = 0; x < width+8; x += 1) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx, ny);
			
			let yy = height / 3.1 + y - n * height;
			fill(200 + 25 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.5 + ny * PI * 2 + 0.25))), 118, 128 + pow(ny, 1) * 128, 1);
			rect(x, yy, 4, 5);
		}
	}
	
	for (y = height/1.85; y > 0; y -= 1) {
		let ny = y / height/1.85;
		for (x = 0; x < width; x += 1) {
			if (random() > 0.75) {
				stroke(0, 0, 0, random(0, 0.05));
				let xx = x + random(-4, 4);
				line(xx, y, xx + random(-6, 6)*ny, y + random(-6, 6)*ny);
			}
		}
	}

	for (y = 0; y < height / 2; y += 1) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 8) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.05);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-100, 100), y + random(-100, 100));
			}
		}
	}
	
	for (y = 0; y < height / 2; y += 1) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 1) {
			let n = noise(x / width, y / height*4);
			if (random() > 0.25 + n) {
				stroke(0, 0, 255, random() * 0.0075*n);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-100, 100), y + random(-20, 20));
			}
		}
	}
	
	let wl = 255 * (height / 976);
	let m = 0; // get max y
	for (y = 0; y < (height - m); y += 1) {
		let ny = y / height;
		let noy = noise(ny);
		
		for (x = -32; x < width+32; x += 1) {
			let yy = (height / 2 + noise(x / width) * 24) + y + m;
			
			let nx = x / width;
			let nox = noise(nx * 4, ny * 4)
			let nox2 = (noise(nx/2, ny/2));
			let nox3 = noise(nx * 1, ny * 3);
			let n = (sin(nx * PI * 2.5 + ny * PI * 10 + nox * PI * 3.15)) / 1.5 * nox2;
			
			if (random() > 0.15) {
				stroke(10 + (nox2) * 40, 140 * nox3, 248*nox3-random(248) * n, random() * 0.5 * pow(ny, 0.3));
				let xx = x + random(-2, 2);
				line(xx, yy, xx + random(-80, 80) * n * noy * ny + nox3*20*ny, yy + random(-140, 140) * n * ny);
			}
			if (random() > 0.05) {
			n = (sin(nx * PI * 1.5 + ny * PI * 8 + nox * PI * 4.15)) / 2 * nox2;
				stroke(10 + (nox2) * 40, 140 * nox3, 200*nox3-random(200) * n, random() * 0.75 * pow(ny, 0.3));
				xx = x + random(-20, 20);
				line(xx, yy, xx + random(-8, 8) * n * noy * ny + nox3*100*ny, yy + random(-140, 140) * n * ny);
		}
			if (random() > 0.05) {
			n = (sin(nx * PI * 1.5 + ny * PI * 4 + nox * PI *3.15)) / 2 * nox2;
				stroke(10 + (nox2) * 30, 140 * nox3, 200*nox3-random(248) * n, random() * 0.75 * pow(ny, 0.3));
				xx = x + random(-4, 4);
				line(xx, yy, xx + random(-40, 40) * n * noy * ny + nox3*80*ny, yy + random(-200, 200) * n * ny);
		}
			if (random() > 0.15) {
			n = (sin(nx * PI * 2.5 + ny * PI * 1 + nox * PI * 2.15)) / 2 * nox2;
				stroke(20 + (nox2) * 30, 140 * nox3, 180*nox3-random(100) * n, random() * 0.75 * pow(ny, 0.3));
				xx = x + random(-20, 20);
				line(xx, yy, xx + random(-80, 80) * n * noy * ny + nox3*70*ny, yy + random(-140, 140) * n * ny);
		}
		}
	}
	/*
	for (y = 0; y < (height - m); y += 1) {
		let ny = y / height;
		let noy = noise(ny);
		
		for (x = -32; x < width+32; x += 1) {
			let yy = (height / 2 + noise(x / width) * 4) + y + m;
			
			let nx = x / width;
			let nox = noise(nx * 4, ny * 4)
			let nox2 = (noise(nx/2, ny/2));
			let nox3 = noise(nx * 1, ny * 3);
			let ss = exp(-pow(nx - 0.5 + cos(PI * 0.5 + (ny) * PI * 1)/2, 2)*2 + 0.15);
			let n = (sin(nx * PI * 0.5 + ny * PI * 1 + nox * PI * 1.15)) / 0.5 * nox2;
			
			if (random() > 0.0) {
				stroke(10 + (nox2) * 40, 140 * nox3 + 20 * (1-ss), (248*nox3-random(248) * n)+200*(1-ss), random() * 0.5 * pow(ny, 0.3));
				let xx = x + random(-2, 2);
				line(xx, yy, xx + random(-8, 8) * ny + nox3*10*ny * (ss), yy + random(-4, 4) * n * ny);
			}
		}
	}*/

	for (y = 0; y < height / 2; y += 16) {
		let ny = y / height;
		let noy = noise(ny);
		for (x = 0; x < width; x += 3) {
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = noise(nx, ny);
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2 * nox2;

			let yy = y;

			if (random() > 0.9991) {
				stroke(0, 0, 0, 1);
				strokeWeight(0.5);
				let tx = x + random(1, 6);
				let ty = yy + random(1, 6);
				line(x, yy, tx, ty);
				line(tx, ty, tx + random(1, 4) * (1-ny), ty - random(1, 1) * (1-ny));
			}
		}
	}
}"
"954082","dem9","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 4;

function setup() {
  createCanvas(windowHeight, windowHeight);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (2.35), y: abs(width / (1.35) - x + y / (0.5 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 60, y: (height / 2 - y * 1.025 / j + (x / 1)) / 1.75 + j * (60) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 - x * j) / (1.75 * j + x / (width / 0.8)), y: y / 1.05 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (1.25) - x + y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 80, y: (height / 1.45 - y * 1.015 / j + (x / 1.75)) / 1.75 + j * (50) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (2.465 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 1; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let nx1 = y[j] / height;
				let inx1 = 0.5+pow(1-nx1, 3);
				let nx2 = y2[j] / height;
				let inx2 = 0.5+pow(1-nx2, 2.5);
				let ny1 = abs(0.5 - x[j] / width) * 2;
				let ny = x[j] / width;
				let iny = pow(1-ny1, 0.5);
				let iny2 = 0.25+pow(1-ny1, 0.5);
				let iny3 = 0.25 + abs(sin(ny * PI * 2));
				
				let e = 0.75;

				if (iter > 20) {
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.0425 * a);
					point(x[j] / 0.75 * inx1, y[j]);
					point(width - x[j] / 0.75 * inx1, y[j]);
					point(x[j] / 1 * inx1, height / 2 - y[j]/2);
					point(width - x[j] / 1 * inx1, height / 2 - y[j]/2);
					point(width / 2 - x[j] / 0.5 * inx1, height / 0.85 - y[j]/1);
					point(width / 2 + x[j] / 0.5 * inx1, height / 0.85 - y[j]/1);
					point( x[j] / 1 * inx2, y[j]/1.15-height/2);
					point(width - x[j] / 1 * inx2, y[j]/1.15-height/2);
					point(width / 2 - x[j] / 2 * inx2, y[j]/2.15*iny3-height/2);
					point(width / 2 + x[j] / 2 * inx2, y[j]/2.15*iny3-height/2);
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);

					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 3.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), height - yy, x + random(-128, 128), height - (yy - random(32, height)));
		}
	}/*
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}*/
}"
"953804","Beach","mySketch","// finally with some clouds :) needed to be tuned a bit!
// different shading on the sea
// with some kind of beach
// change the seeds; shading of both sea & sky vary greatly

function setup() {
	createCanvas(600, 600);
	
	noStroke();
	
	background(0);
	
	colorMode(HSL, 360, 255, 255, 1);
	
	noiseSeed(100);
	noiseDetail(8, 0.75);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	generate();
}

function draw() {
	
}

function generate() {
	noStroke();
	
	background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 2) {
		let ny = y / height;
		for (x = 0; x < width+8; x += 1) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx, ny);
			
			let yy = height / 3.1 + y - n * height;
			fill(200 + 20 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.5 + ny * PI * 2 + 0.25))), 118, 128 + pow(ny, 1) * 128, 1);
			rect(x, yy, 4, 5);
		}
	}
	
	for (y = height/1.85; y > 0; y -= 1) {
		let ny = y / height/1.85;
		for (x = 0; x < width; x += 1) {
			if (random() > 0.75) {
				stroke(0, 0, 0, random(0, 0.05));
				let xx = x + random(-4, 4);
				line(xx, y, xx + random(-6, 6)*ny, y + random(-6, 6)*ny);
			}
		}
	}

	for (y = 0; y < height / 2; y += 1) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 8) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.025);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-100, 100), y + random(-100, 100));
			}
		}
	}
	
	for (y = 0; y < height / 2; y += 1) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 1) {
			let n = noise(x / width, y / height*4);
			if (random() > 0.25 + n) {
				stroke(0, 0, 255, random() * 0.05*n);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-100, 100), y + random(-20, 20));
			}
		}
	}
	
	let wl = 255 * (height / 976);
	let m = 0; // get max y
	for (y = 0; y < (height - m); y += 1) {
		let ny = y / height;
		let noy = noise(ny);
		
		for (x = -32; x < width+32; x += 1) {
			let yy = (height / 2 + noise(x / width) * 8) + y + m;
			
			let nx = x / width;
			let nox = noise(nx * 16, ny * 32);
			let nox2 = (noise(nx*3, ny*3));
			let nox3 = noise(nx / 4, ny / 4);
			let n = (sin(nx * PI * 2.5 + ny * PI * 10 + nox * PI * 20.15)) / 2 * nox2;
			
			if (random() > 0.25) {
				stroke(180 + (nox2) * 20, 140 * nox3, 248*nox3-random(200) * n, random() * 0.45 * pow(ny, 0.3));
				let xx = x + random(-2, 2);
				line(xx, yy, xx + random(-100, 100) * n * noy * ny + nox3*200*ny, yy + random(-100, 100) * n * ny);
			}
		}
	}
	
	for (y = 0; y < (height - m); y += 1) {
		let ny = y / height;
		let noy = noise(ny);
		
		for (x = -32; x < width+32; x += 1) {
			let yy = (height / 1.605 + noise(x / width) * 16 + 100 * sin(x / width * PI * 0.7)) + y + m;
			
			let nx = x / width;
			let nox = noise(nx * 16, ny * 16);
			let nox2 = (noise(nx*30, ny*30));
			let nox3 = noise(nx * 40, ny * 40);
			let n = (sin(nx * PI * 2.5 + ny * PI * 0.5 + nox * PI * 1.15)) / 2 * nox2;
			
			if (random() > 0.25 && nox3 > 0.75) {
				stroke(45 + (nox2) * 20, 0 * nox3, 255*nox3-random(1) * n, random() * 0.3 * pow(ny, 0.5));
				let xx = x + random(-2, 2);
				line(xx, yy, xx + random(-400, 400) * n * noy * ny + nox3*400*ny, yy + random(-400, 400) * n * ny);
			}
		}
	}
	
	for (y = 0; y < (height - m); y += 1) {
		let ny = y / height;
		let noy = noise(ny);
		
		for (x = -32; x < width+32; x += 1) {
			let yy = (height / 1.6 + noise(x / width) * 100 + 100 * sin(x / width * PI * 0.6)) + y + m;
			
			let nx = x / width;
			let nox = noise(nx / 8, ny / 8);
			let nox2 = (noise(nx*3, ny*3));
			let nox3 = noise(nx / 4, ny / 4);
			let n = (sin(nx * PI * 2.5 + ny * PI * 3 + nox * PI * 4.15)) / 2 * nox2;
			
			if (random() > 0.25) {
				stroke(45 + (nox2) * 20, 140 * nox3, 248*nox3-random(200) * n, random() * 0.45 * pow(ny, 0.3));
				let xx = x + random(-2, 2);
				line(xx, yy, xx + random(-100, 100) * n * noy * ny + nox3*200*ny, yy + random(-100, 100) * n * ny);
			}
		}
	}
	
	for (y = 0; y < (height - m); y += 1) {
		let ny = y / height;
		let noy = noise(ny);
		
		for (x = -32; x < width+32; x += 1) {
			let yy = (height / 1.1 + noise(x / width) * 8 + 50 * sin(x / width * PI * 0.6)) + y + m;
			
			let nx = x / width;
			let nox = noise(nx * 16, ny * 32);
			let nox2 = (noise(nx*3, ny*3));
			let nox3 = noise(nx / 4, ny / 4);
			let n = (sin(nx * PI * 2.5 + ny * PI * 10 + nox * PI * 20.15)) / 2 * nox2;
			
			if (random() > 0.25) {
				stroke(80 + (nox2) * 20, 140 * nox3, 248*nox3-random(200) * n, random() * 0.45 * pow(ny, 0.3));
				let xx = x + random(-2, 2);
				line(xx, yy, xx + random(-100, 100) * n * noy * ny + nox3*200*ny, yy + random(-100, 100) * n * ny);
			}
		}
	}

	for (y = 0; y < height / 2; y += 16) {
		let ny = y / height;
		let noy = noise(ny);
		for (x = 0; x < width; x += 3) {
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = noise(nx, ny);
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2 * nox2;

			let yy = y;

			if (random() > 0.9991) {
				stroke(0, 0, 0, 1);
				strokeWeight(0.5);
				let tx = x + random(1, 6);
				let ty = yy + random(1, 6);
				line(x, yy, tx, ty);
				line(tx, ty, tx + random(1, 4) * (1-ny), ty - random(1, 1) * (1-ny));
			}
		}
	}
}"
"953554","Grainy ocean 3","mySketch","// finally with some clouds :) needed to be tuned a bit!
// different shading on the sea
// change the seeds; shading of both sea & sky vary greatly

function setup() {
	createCanvas(600, 600);
	
	noStroke();
	
	background(0);
	
	colorMode(HSL, 360, 255, 255, 1);
	
	noiseSeed(100);
	noiseDetail(8, 0.75);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	generate();
}

function draw() {
	
}

function generate() {
	noStroke();
	
	background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 2) {
		let ny = y / height;
		for (x = 0; x < width+8; x += 1) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx, ny);
			
			let yy = height / 3.1 + y - n * height;
			fill(200 + 20 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.5 + ny * PI * 2 + 0.25))), 118, 128 + pow(ny, 1) * 128, 1);
			rect(x, yy, 4, 5);
		}
	}
	
	for (y = height/1.85; y > 0; y -= 1) {
		let ny = y / height/1.85;
		for (x = 0; x < width; x += 1) {
			if (random() > 0.75) {
				stroke(0, 0, 0, random(0, 0.05));
				let xx = x + random(-4, 4);
				line(xx, y, xx + random(-6, 6)*ny, y + random(-6, 6)*ny);
			}
		}
	}

	for (y = 0; y < height / 2; y += 1) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 8) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.025);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-100, 100), y + random(-100, 100));
			}
		}
	}
	
	for (y = 0; y < height / 2; y += 1) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 1) {
			let n = noise(x / width, y / height*4);
			if (random() > 0.25 + n) {
				stroke(0, 0, 255, random() * 0.05*n);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-100, 100), y + random(-20, 20));
			}
		}
	}
	
	let wl = 255 * (height / 976);
	let m = 0; // get max y
	for (y = 0; y < (height - m); y += 1) {
		let ny = y / height;
		let noy = noise(ny);
		
		for (x = -32; x < width+32; x += 1) {
			let yy = (height / 2 + noise(x / width) * 8) + y + m;
			
			let nx = x / width;
			let nox = noise(nx * 16, ny * 32);
			let nox2 = (noise(nx*3, ny*3));
			let nox3 = noise(nx / 4, ny / 4);
			let n = (sin(nx * PI * 2.5 + ny * PI * 10 + nox * PI * 20.15)) / 2 * nox2;
			
			if (random() > 0.25) {
				stroke(180 + (nox2) * 20, 140 * nox3, 248*nox3-random(200) * n, random() * 0.45 * pow(ny, 0.3));
				let xx = x + random(-2, 2);
				line(xx, yy, xx + random(-100, 100) * n * noy * ny + nox3*200*ny, yy + random(-100, 100) * n * ny);
			}
		}
	}

	for (y = 0; y < height / 2; y += 16) {
		let ny = y / height;
		let noy = noise(ny);
		for (x = 0; x < width; x += 3) {
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = noise(nx, ny);
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2 * nox2;

			let yy = y;

			if (random() > 0.9991) {
				stroke(0, 0, 0, 1);
				strokeWeight(0.5);
				let tx = x + random(1, 6);
				let ty = yy + random(1, 6);
				line(x, yy, tx, ty);
				line(tx, ty, tx + random(1, 4) * (1-ny), ty - random(1, 1) * (1-ny));
			}
		}
	}
}"
"953542","dem8","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 4;

function setup() {
  createCanvas(windowHeight, windowHeight);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (2.35), y: abs(width / (1.35) - x + y / (0.5 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 60, y: (height / 2 - y * 1.25 / j + (x / 1)) / 1.75 + j * (10) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 - x * j) / (1.75 * j + x / (width / 0.8)), y: y / 1.05 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (1.25) - x + y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 80, y: (height / 1.45 - y * 1.015 / j + (x / 1.75)) / 1.75 + j * (50) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (2.465 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 1; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let nx1 = y[j] / height;
				let inx1 = 0.5+pow(1-nx1, 3);
				let nx2 = y2[j] / height;
				let inx2 = 0.5+pow(1-nx2, 2.5);
				let ny1 = abs(0.5 - x[j] / width) * 2;
				let ny = x[j] / width;
				let iny = pow(1-ny1, 0.5);
				let iny2 = 0.25+pow(1-ny1, 0.5);
				let iny3 = 0.25 + abs(sin(ny * PI * 2));
				
				let e = 0.75;

				if (iter > 20) {
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.0425 * a);
					point(x[j] / 0.75 * inx1, y[j]);
					point(width - x[j] / 0.75 * inx1, y[j]);
					point(x[j] / 1 * inx1, height / 2 - y[j]/2);
					point(width - x[j] / 1 * inx1, height / 2 - y[j]/2);
					point(width / 2 - x[j] / 0.5 * inx1, height / 0.85 - y[j]/1);
					point(width / 2 + x[j] / 0.5 * inx1, height / 0.85 - y[j]/1);
					point( x[j] / 1 * inx2, y[j]/1.15-height/2);
					point(width - x[j] / 1 * inx2, y[j]/1.15-height/2);
					point(width / 2 - x[j] / 2 * inx2, y[j]/2.15*iny3-height/2);
					point(width / 2 + x[j] / 2 * inx2, y[j]/2.15*iny3-height/2);
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);

					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 3.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), height - yy, x + random(-128, 128), height - (yy - random(32, height)));
		}
	}/*
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}*/
}"
"953541","dem7","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 4;

function setup() {
  createCanvas(windowHeight, windowHeight);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (2.35), y: abs(width / (1.35) - x + y / (0.5 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 60, y: (height / 2 - y * 1.25 / j + (x / 1)) / 1.75 + j * (10) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 - x * j) / (1.75 * j + x / (width / 0.8)), y: y / 1.05 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (1.25) - x + y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 80, y: (height / 1.45 - y * 1.015 / j + (x / 1.75)) / 1.75 + j * (50) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (2.465 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 1; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let nx1 = y[j] / height;
				let inx1 = 0.5+pow(1-nx1, 3);
				let nx2 = y2[j] / height;
				let inx2 = 0.5+pow(1-nx2, 2.5);
				let ny1 = abs(0.5 - x[j] / width) * 2;
				let ny = x[j] / width;
				let iny = pow(1-ny1, 0.5);
				let iny2 = 0.25+pow(1-ny1, 0.5);
				let iny3 = 0.25 + abs(sin(ny * PI * 2));
				
				let e = 0.75;

				if (iter > 20) {
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.0425 * a);
					point(x[j] / 0.75 * inx1, y[j]);
					point(width - x[j] / 0.75 * inx1, y[j]);
					point(x[j] / 1 * inx1, height / 2 - y[j]/2);
					point(width - x[j] / 1 * inx1, height / 2 - y[j]/2);
					point(width / 2 - x[j] / 1 * inx1, height / 1 - y[j]/1.5);
					point(width / 2 + x[j] / 1 * inx1, height / 1 - y[j]/1.5);
					point( x[j] / 1 * inx2, y[j]/1.15-height/2);
					point(width - x[j] / 1 * inx2, y[j]/1.15-height/2);
					point(width / 2 - x[j] / 2 * inx2, y[j]/2.15*iny3-height/2);
					point(width / 2 + x[j] / 2 * inx2, y[j]/2.15*iny3-height/2);
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);

					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 3.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), height - yy, x + random(-128, 128), height - (yy - random(32, height)));
		}
	}/*
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}*/
}"
"953515","Offscreen + Physarum","mySketch","// slime mold simulation with offscreen buffer as trail map :)

var xmotion = 0;
var ymotion = 0;

var objs = [];
var trail_map = [];

var nnx = 255;
var nny = 24;

let buff;
let den;

let img;

function preload() {
    //img = loadImage('bc.png');
}

function setup() {
	createCanvas(1080, 608);
	
	colorMode(HSB, 360, 255, 255);
	
	background(255);
	
	noiseDetail(7, 0.7);
	
	buff = createGraphics(width, height);
	
	var inc = 0;
	for (var nx = 0; nx < nnx; nx += 1) {
	 var nmx = nx / nnx;
	 for (var ny = 0; ny < nny; ny += 1) {
		var n = parseInt(nx + ny * nnx);
		 
		var nmy = ny / nny;
		
		var no = noise(nmx * nmy);
		 
		var ni = inc / (nnx * nny);
		
		objs[n] = {
			lx: nmx * width,
			ly: ((n % 4) == 0) ? height-64 : (((n % 4) == 1)) ? height-64 - width / 6 :(((n % 4) == 2)) ? height-64 - width / 6*2 :0, //+ nmy * (height / 2),
			// paper
			la: random(-PI * 2, PI * 2), // modify this for more shapes
			// paper : 1
			lv: 1,
			d: 1,
			n: no,
			so: 9, // agent sensor offset,
			sa: 30// agent sensor angle (degree)
		};
		 
		inc += 1;
	 }
	}
	
	den = pixelDensity();
	
	buff.background(0, 0, 0);
	buff.fill(255,255,255);
  buff.textSize(width / 6);
	buff.textStyle(BOLD);
  buff.textAlign(CENTER, BASELINE);
	buff.text('at the heart', width / 2, height-64-width / 6*2);
	buff.text('of it all', width / 2, height-64-width / 6);
	buff.text('COIL', width / 2, height-64);
	
	//buff.text('INSTAGRAM', width / 2, height / 1.5);
	/*
	for (var i = 0; i < width*8; i += 1) {
	buff.ellipse(random(0, width), random(0, height), random(0, width / 4), random(0, height / 4));
	}*/
	//buff.image(img, 0, 200);
buff.filter(INVERT);
/*
	for (var i = 0; i < width; i += 1) {
		let ni = abs(0.5 - i / width) * 2;
		for (var j = 0; j < height; j += 1) {
			let nj = abs(0.5 - j / height) * 2;
			trail_map[i + j * width] = tan(nj * PI * 1) + cos(ni * PI * 2);
		}
	}
*/
	ellipseMode(CENTER);
	rectMode(CENTER);
}

function getpindex(x, y) {
	return (y * width + x) * (den * 4);
}

function compute() {
	fill(0);
	
	strokeWeight(2);
	
	buff.loadPixels();

	for (var nx = 0; nx < nnx; nx += 1) {
	 for (var ny = 0; ny < nny; ny += 1) {
		var n = parseInt(nx + ny * nnx);
		 
		var obj = objs[n];
		
		var sensor_offset = obj.so;
		var sensor_angle = radians(obj.sa);
		
		// agent sensors
		var lhx = round(sin(obj.la - sensor_angle) * sensor_offset);
		var lhy = round(cos(obj.la - sensor_angle) * sensor_offset);
		var fhx = round(sin(obj.la) * sensor_offset);
		var fhy = round(cos(obj.la) * sensor_offset);
		var rhx = round(sin(obj.la + sensor_angle) * sensor_offset);
		var rhy = round(cos(obj.la + sensor_angle) * sensor_offset);
		
		var ailx = parseInt(obj.lx + lhx);
		var aily = parseInt(obj.ly + lhy);
		var aifx = parseInt(obj.lx + fhx);
		var aify = parseInt(obj.ly + fhy);
		var airx = parseInt(obj.lx + rhx);
		var airy = parseInt(obj.ly + rhy);
		
		ailx = ailx < 0 ? ailx + width : ailx;
		aily = aily < 0 ? aily + height : aily;
		aifx = aifx < 0 ? aifx + width : aifx;
		aify = aify < 0 ? aify + height : aify;
		airx = airx < 0 ? airx + width : airx;
		airy = airy < 0 ? airy + height : airy;
		
		ailx %= width;
		aily %= height;
		aifx %= width;
		aify %= height;
		airx %= width;
		airy %= height;
		 
		// sensor sample
		var s1 = buff.pixels[getpindex(ailx, aily)]; // left
		var s2 = buff.pixels[getpindex(aifx, aify)]; // forward
		var s3 = buff.pixels[getpindex(airx, airy)]; // right
		
/*
		// debug sensor
		fill(255, 0, 0, 255);
		rect(ailx, aily, 1, 1);
		rect(aifx, aify, 1, 1);
		rect(airx, airy, 1, 1);
*/	
/*
		if (frameCount % 60 == 0) {
			obj.la += PI / 2;
		}
*/
	
		// agent behavior based on sampled sensor
		if (s2 < s1 && s2 < s3) {
			// turn left or right randomly
			obj.la += random(PI / 2, -PI / 2);
			// paper
			//obj.la += (random() > 0.5 ? PI / 2 : -PI / 2);
		} else if (s1 < s3) {
			// turn left
			obj.la -= PI / 2;
		} else if (s3 < s1) {
			// turn right
			obj.la += PI / 2;
		}
		
		obj.lx += obj.lv * sin(obj.la);
		obj.ly += obj.lv * cos(obj.la);
		 
		 if (obj.lx < 0 || obj.lx > width) {
				continue; 
		 }
		 
		 if (obj.ly < 0 || obj.ly > height) {
				continue; 
		 }
		
		// boundary checks
		/*obj.lx = obj.lx < 0 ? obj.lx + width - 1 : obj.lx;
		obj.lx %= width;
		obj.ly = obj.ly < 0 ? obj.ly + height - 1 : obj.ly;
		obj.ly %= height;*/
		
		// deposit diffusion (3x3 mean kernel)
		// should probably go after deposit step though
		var i = parseInt(obj.lx + obj.ly * width);
		var b = buff.pixels[getpindex(obj.lx, obj.ly)] / 255;

		var lx = parseInt(obj.lx);
		var ly = parseInt(obj.ly);

		var xb = (lx - 1);
		var yb = (ly - 1);
		var xbl = xb < 0 ? width - 1 : xb;
		var ybl = yb < 0 ? height - 1 : yb;
		var xbu = (lx + 1) % width;
		var ybu = (ly + 1) % height;
		/*
		var v1 = trail_map[xbl + ly * width];
		var v2 = trail_map[xbu + ly * width];
		var v3 = trail_map[xbl + ybl * width];
		var v4 = trail_map[xbl + ybu * width];
		var v5 = trail_map[xbu + ybl * width];
		var v6 = trail_map[xbu + ybu * width];
		var v7 = trail_map[lx + ybl * width];
		var v8 = trail_map[lx + ybu * width];
		
		var vm = (v1 + v2 + v3 + v4 + v5 + v6 + v7 + v8) / 8 / 5;
		*/
		buff.pixels[getpindex(xbl, ly)] = b;
		buff.pixels[getpindex(xbu, ly)] = b;
		buff.pixels[getpindex(xbl, ybl)] = b;
		buff.pixels[getpindex(xbl, ybu)] = b;
		buff.pixels[getpindex(xbu, ybl)] = b;
		buff.pixels[getpindex(xbu, ybu)] = b;
		buff.pixels[getpindex(lx, ybl)] = b;
		buff.pixels[getpindex(lx, ybu)] = b;
		
		// deposit
		buff.pixels[getpindex(obj.lx, obj.ly)] = obj.d;
		
		// agent display
		var ll = 440;
		var t = 1;//(noise(obj.n + xmotion * 4) * 2) * (pow((1 - min(ll, frameCount) / ll), 6.5 * (((abs(0.5-obj.ly / height)/8) * 6))));

		var sph = (1 - abs((0.5 - obj.lx / width) * 2));
		var color = 224 + noise(obj.n + xmotion * 2) * 32 * sph;
		fill(0, 0, 255-(color * (1 - abs(0.5-obj.ly / height)*2) * 8), t / 6);
		 noStroke();
		//stroke(0, 0, color, t);
		rect(obj.lx, obj.ly, 1, 1);
		
/*
		if (trail_map[parseInt(i)] > 1) {
			trail_map[parseInt(i)] = 1;
		}
*/
	 }
	}
	
	//buff.updatePixels();
	
	//buff.loadPixels();
	
	// deposit decay
	for (var y = 0; y < height; y += 1) {
		for (var x = 0; x < width; x += 1) {
			var v = buff.pixels[getpindex(x, y)];
			buff.pixels[getpindex(x, y)] -= 0.1;
			if (buff.pixels[getpindex(x, y)] < 0) {
				buff.pixels[getpindex(x, y)] = 0;
			}
		}
	}
	
	buff.updatePixels();
/*
	if (frameCount % 60 == 0) {
		var st = 1 + parseInt(random() * (nn / 8));
		for (var y = 0; y < nn; y += st) {
			objs[y].lx = random() * width;
			objs[y].ly = random() * height;
		}
	}
*/
}

function draw() {
	noStroke();
	
	rectMode(CORNER);
/*
	fill(0, 0, 0, 8);
	rect(0, 0, width, height);
*/
	rectMode(CENTER);
	
	compute();
//image(buff, 0,0);
	xmotion += 0.05;
	ymotion += 0.0002;
}"
"953355","Grainy ocean 2","mySketch","function setup() {
	createCanvas(600, 600);
	
	noStroke();
	
	background(0);
	
	colorMode(HSL, 360, 255, 255, 1);
	
	noiseSeed(200);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	generate();
}

function draw() {
	
}

function generate() {
	noStroke();
	
	background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width+8; x += 1) {
			let nx = x / width;
			let n = noise(nx / 24, ny / 24);
			let n2 = noise(nx, ny);
			
			let yy = height / 3.9 + y - n * height;
			fill(200 + 20 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.5 + ny * PI * 2 + 0.25))), 118, 128 + pow(ny, 1) * 128, 1);
			rect(x, yy, 4, 5);
		}
	}
	
	for (y = height; y > 0; y -= 8) {
		for (x = 0; x < width; x += 8) {
			if (random() > 0.85) {
				stroke(0, 0, 0, random(0, 0.15));
				let xx = x + random(-4, 4);
				line(xx, y, xx + random(-1, 1), y + random(-1, 1));
			}
		}
	}

	for (y = 0; y < height / 2; y += 1) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 8) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.025);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-100, 100), y + random(-100, 100));
			}
		}
	}
	
	for (y = 0; y < height / 2; y += 1) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 1) {
			let n = noise(x / width, y / height*4);
			if (random() > 0.25 + n) {
				stroke(0, 0, 255, random() * 0.05*n);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-100, 100), y + random(-20, 20));
			}
		}
	}
	
	let wl = 255 * (height / 976);
	let m = 0; // get max y
	for (y = 0; y < (height - m); y += 1) {
		let ny = y / height;
		let noy = noise(ny);
		
		for (x = -32; x < width+32; x += 1) {
			let yy = (height / 2 + noise(x / width) * 8) + y + m;
			
			let nx = x / width;
			let nox = noise(nx * 2, ny * 16);
			let nox2 = (noise(nx*3, ny*3));
			let nox3 = noise(nx / 4, ny / 4);
			let n = (sin(nx * PI * 2.5 + ny * PI * 10 + nox * PI * 2.15)) / 2 * nox2;
			
			if (random() > 0.25) {
				stroke(180 + (nox2) * 20, 140 * nox3, 248*nox3-random(200) * n, random() * 0.45 * pow(ny, 0.3));
				let xx = x + random(-2, 2);
				line(xx, yy, xx + random(-100, 100) * n * noy * ny + nox3*200*ny, yy + random(-100, 100) * n * ny);
			}
		}
	}

	for (y = 0; y < height / 2; y += 16) {
		let ny = y / height;
		let noy = noise(ny);
		for (x = 0; x < width; x += 3) {
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = noise(nx, ny);
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2 * nox2;

			let yy = y;

			if (random() > 0.9991) {
				stroke(0, 0, 0, 1);
				strokeWeight(0.5);
				let tx = x + random(1, 6);
				let ty = yy + random(1, 6);
				line(x, yy, tx, ty);
				line(tx, ty, tx + random(1, 4) * (1-ny), ty - random(1, 1) * (1-ny));
			}
		}
	}
}"
"951387","G1","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 4;

function setup() {
  createCanvas(windowHeight, windowHeight);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (1.5), y: abs(width / (1.025) - x + y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 1.25 * x) / 1 + j * 100, y: (height / 1.45 - y * 2 / j + (x / 1.75)) / 1.75 + j * (40) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 - x * j) / (3 * j + x / (width / 10)), y: y / 1.7 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (3.25) - x + y / (1.95 * j * ((0.5 - y / width) * 10))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 1, y: (height / 2 - y * 1.15 / j + (x / 10.075)) / 1.75 + j * (15) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (1.065 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 1; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let nx1 = y[j] / height;
				let inx1 = 0.5+pow(1-nx1, 2);
				let nx2 = y2[j] / height;
				let inx2 = 0.45+pow(nx2, 2.5);
				
				let e = 0.75;

				if (iter > 20) {
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.0425 * a);
					//point(height / 1 - y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(y[j]/1.95, width / 2 - x[j] * inx1+5);
					//point(height / 1 - y[j]/1.95, width - x[j] * inx1+5);
					//point(y[j]/1.95, width - x[j] * inx1+5);
					//point(width / 2 - x[j] * 1.5 * inx2+5, height / 1 - y[j]/2+200);
					//point(width / 2 + x[j] * 1.5 * inx2+5, height / 1 - y[j]/2+200);
					
					point(x[j] * inx2+5, height / 1 - y[j]/1.85);
					point(width - x[j] * inx2-5, height / 1 - y[j]/1.85);
					point(width / 2 - x[j] / 1 * inx1+5, y[j]/2.25);
					point(width / 2 + x[j] / 1 * inx1-5, y[j]/2.25);
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"949534","t10","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 4;

function setup() {
  createCanvas(900, 900);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (1.75), y: abs(width / (1) - x / 1 + y / (0.5 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.25 * x) / 1 + j *(60+x/20-y/40), y: (height / 1 - y * 1.25 / j + (x / 4)) / 1.5 + j * (100+x/20-y/40) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 - x * j + y / 2) / (1.5 * j + x / (width / 4)), y: y / 2.05 + x / 10 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.75), y: abs(width / (1.25) - x + y / (0.5 * j * ((0.5 - y / width) * 800))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j *(60+x/20-y/40), y: (height / 4 - y * 1.25 / j + (x / 8)) / 1.75 + j * (10) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 - x * j) / (1.05 * j + x / (width / 0.8)), y: y / 1.025 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 1; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let nx1 = y[j] / height;
				let inx1 = 0.5+pow(1-nx1, 3);
				let nx2 = y2[j] / height;
				let inx2 = 0.5+pow(1-nx2, 2.5);
				let inx3 = 0.25+pow(1-nx2, 2.);
				let ny1 = abs(0.5 - x[j] / width) * 2;
				let ny = x[j] / width;
				let iny = pow(1-ny1, 0.5);
				let iny2 = 0.5 + abs(cos(ny * PI * 0.15 + nx1 * PI * 0.5));
				let iny3 = 0.25 + abs(sin(ny * PI * 1));
				
				let e = 0.75;

				if (iter > 20) {
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.0425 * a);
					//point(x[j] / 1 * inx3 - 150 * inx1, 20 + y2[j]/1);
					//point(width - x[j] / 1 * inx3 + 150 * inx1, 20 + y2[j]/1);
					//point(width / 2 - x2[j] / 2.25 * inx3 + 1 * inx1, height / 6 - y2[j]/2);
					//point(width / 2 + x2[j] / 2.25 * inx3 - 1 * inx1, height / 6 - y2[j]/2);
					point(width / 2 - x2[j] / 1 * inx3+2, y2[j]/2.125-150);
					point(width / 2 + x2[j] / 1 * inx3-2, y2[j]/2.125-150);
					//point(x[j] / 1 * inx3+2, height / 1 - y[j]/1.125+50);
					//point(width - x[j] / 1 * inx3-2, height / 1 - y[j]/1.125+50);
					point(width / 2 - x[j] / 1 * inx3+2, height / 1 - y[j]/1);
					point(width / 2 + x[j] / 1 * inx3-2, height / 1 - y[j]/1);
					//point( x[j] / 3 * inx1, y[j]/2*iny2);
					//point(width - x[j] / 3 * inx1, y[j]/2*iny2);
					point( width / 2 - x[j] / 2 * inx2, y[j]/1.015*iny3-height/2);
					point(width / 2 + x[j] / 2 * inx2, y[j]/1.015*iny3-height/2);
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);

					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 10 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 3.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-92, 92), height - yy, x + random(-92, 92), height - (yy - random(1, height)));
		}
	}/*
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}*/
}"
"949516","t9","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 4;

function setup() {
  createCanvas(900, 900);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (1.75), y: abs(width / (1.5) - x / 1 + y / (0.5 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.25 * x) / 1 + j *20, y: (height / 2 - y * 1.25 / j + (x / 2)) / 1.5 + j * (100) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 - x * j + y / 2) / (1.5 * j + x / (width / 4)), y: y / 2.05 + x / 10 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.95), y: abs(width / (1.25) - x + y / (0.5 * j * ((0.5 - y / width) * 800))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.75 * x) / 1 + j * (40), y: (height / 2 - y * 1.25 / j + (x / 2.5)) / 1.75 + j * (1) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 - x * j) / (1 * j + x / (width / 10)), y: y / 1.15 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 1; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let nx1 = y[j] / height;
				let inx1 = 0.5+pow(1-nx1, 3);
				let nx2 = y2[j] / height;
				let inx2 = 0.5+pow(1-nx2, 2.5);
				let inx3 = 0.25+pow(1-nx2, 4.5);
				let ny1 = abs(0.15 - x[j] / width) * 2;
				let ny = x[j] / width;
				let iny = pow(1-ny1, 0.5);
				let iny2 = 0.5 + abs(cos(ny * PI * 0.15 + nx1 * PI * 0.5));
				let iny3 = 0.25 + abs(sin(ny * PI * 1));
				
				let e = 0.75;

				if (iter > 20) {
					stroke(300 - 100 * (j / ifs) * (i / 200) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 255, 0.0425 * a);
					//point(x[j] / 1 * inx3 - 150 * inx1, 20 + y2[j]/1);
					//point(width - x[j] / 1 * inx3 + 150 * inx1, 20 + y2[j]/1);
					//point(width / 2 - x2[j] / 2.25 * inx3 + 1 * inx1, height / 6 - y2[j]/2);
					//point(width / 2 + x2[j] / 2.25 * inx3 - 1 * inx1, height / 6 - y2[j]/2);
					point(width / 2 - x2[j] / 1 * inx3, y2[j]/1.2);
					point(width / 2 + x2[j] / 1 * inx3, y2[j]/1.2);
					point(x2[j] *2 * inx3-10, height - y2[j]/1.1+60);
					point(width - x2[j] *2 * inx3+10, height - y2[j]/1.1+60);
					//point(x[j] / 1 * inx3+2, height / 1 - y[j]/1.125+50);
					//point(width - x[j] / 1 * inx3-2, height / 1 - y[j]/1.125+50);
					//point(width / 2 - x[j] / 1 * inx3+2, height / 1 - y[j]/1);
					//point(width / 2 + x[j] / 1 * inx3-2, height / 1 - y[j]/1);
					//point( x[j] / 3 * inx1, y[j]/2*iny2);
					//point(width - x[j] / 3 * inx1, y[j]/2*iny2);
					//point( width / 2 - x[j] / 2 * inx2, y[j]/1.015*iny3-height/2);
					//point(width / 2 + x[j] / 2 * inx2, y[j]/1.015*iny3-height/2);
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);

					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 10 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 3.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-92, 92), height - yy, x + random(-92, 92), height - (yy - random(1, height)));
		}
	}/*
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}*/
}"
"949490","t8","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 4;

function setup() {
  createCanvas(windowHeight, windowHeight);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (1.75), y: abs(width / (2) - x / 1 + y / (0.5 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.25 * x) / 1 + j *80, y: (height / 1 - y * 1.25 / j + (x / 2)) / 1.5 + j * (40) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 - x * j + y / 2) / (1.5 * j + x / (width / 4)), y: y / 2.05 + x / 10 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.75), y: abs(width / (1.25) - x + y / (0.5 * j * ((0.5 - y / width) * 800))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j *100, y: (height / 4 - y * 1.25 / j + (x / 2)) / 1.75 + j * (40) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 - x * j) / (1.05 * j + x / (width / 0.8)), y: y / 1.05 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 1; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let nx1 = y[j] / height;
				let inx1 = 0.5+pow(1-nx1, 3);
				let nx2 = y2[j] / height;
				let inx2 = 0.5+pow(1-nx2, 2.5);
				let inx3 = 0.25+pow(1-nx2, 2.);
				let ny1 = abs(0.5 - x[j] / width) * 2;
				let ny = x[j] / width;
				let iny = pow(1-ny1, 0.5);
				let iny2 = 0.5 + abs(cos(ny * PI * 0.15 + nx1 * PI * 0.5));
				let iny3 = 0.25 + abs(sin(ny * PI * 1));
				
				let e = 0.75;

				if (iter > 20) {
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.0425 * a);
					//point(x[j] / 1 * inx3 - 150 * inx1, 20 + y2[j]/1);
					//point(width - x[j] / 1 * inx3 + 150 * inx1, 20 + y2[j]/1);
					//point(width / 2 - x2[j] / 2.25 * inx3 + 1 * inx1, height / 6 - y2[j]/2);
					//point(width / 2 + x2[j] / 2.25 * inx3 - 1 * inx1, height / 6 - y2[j]/2);
					point(width / 2 - x2[j] / 1 * inx3+2, y2[j]/2.125-150);
					point(width / 2 + x2[j] / 1 * inx3-2, y2[j]/2.125-150);
					//point(x[j] / 1 * inx3+2, height / 1 - y[j]/1.125+50);
					//point(width - x[j] / 1 * inx3-2, height / 1 - y[j]/1.125+50);
					point(width / 2 - x[j] / 1 * inx3+2, height / 1 - y[j]/1);
					point(width / 2 + x[j] / 1 * inx3-2, height / 1 - y[j]/1);
					//point( x[j] / 3 * inx1, y[j]/2*iny2);
					//point(width - x[j] / 3 * inx1, y[j]/2*iny2);
					point( width / 2 - x[j] / 2 * inx2, y[j]/1.015*iny3-height/2);
					point(width / 2 + x[j] / 2 * inx2, y[j]/1.015*iny3-height/2);
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);

					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 10 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 3.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-92, 92), height - yy, x + random(-92, 92), height - (yy - random(1, height)));
		}
	}/*
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}*/
}"
"947325","t2","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 4;

function setup() {
  createCanvas(windowHeight, windowHeight);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (1.75), y: abs(width / (1.05) - x / 1 + y / (0.5 * j * ((0.5 - y / width) * 100))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j *80, y: (height / 4 - y * 1.5 / j + (x / 2)) / 1.95 + j * (100) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 - x * j + y / 8) / (1.5 * j + x / (width / 10)), y: y / 2.05 + x / 10 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.75), y: abs(width / (1.25) - x + y / (0.5 * j * ((0.5 - y / width) * 800))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j *100, y: (height / 4 - y * 1.25 / j + (x / 2)) / 1.75 + j * (40) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 - x * j) / (1.05 * j + x / (width / 0.8)), y: y / 2.05 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 1; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let nx1 = y[j] / height;
				let inx1 = 0.5+pow(1-nx1, 3);
				let nx2 = y2[j] / height;
				let inx2 = 0.5+pow(1-nx2, 2.5);
				let inx3 = 0.25+pow(1-nx2, 2.);
				let ny1 = abs(0.5 - x[j] / width) * 2;
				let ny = x[j] / width;
				let iny = pow(1-ny1, 0.5);
				let iny2 = 0.5 + abs(cos(ny * PI * 0.15 + nx1 * PI * 0.5));
				let iny3 = 0.25 + abs(sin(ny * PI * 1));
				
				let e = 0.75;

				if (iter > 20) {
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.0425 * a);
					//point(x[j] / 1 * inx3 - 150 * inx1, 20 + y2[j]/1);
					//point(width - x[j] / 1 * inx3 + 150 * inx1, 20 + y2[j]/1);
					//point(width / 2 - x2[j] / 2.25 * inx3 + 1 * inx1, height / 6 - y2[j]/2);
					//point(width / 2 + x2[j] / 2.25 * inx3 - 1 * inx1, height / 6 - y2[j]/2);
					point(width / 2 - x2[j] / 1 * inx3+2, y2[j]/2.125-150);
					point(width / 2 + x2[j] / 1 * inx3-2, y2[j]/2.125-150);
					//point(x[j] / 1 * inx3+2, height / 1 - y[j]/1.125+50);
					//point(width - x[j] / 1 * inx3-2, height / 1 - y[j]/1.125+50);
					point(width / 2 - x[j] / 1 * inx3+2, height / 1 - y[j]/1);
					point(width / 2 + x[j] / 1 * inx3-2, height / 1 - y[j]/1);
					//point( x[j] / 3 * inx1, y[j]/2*iny2);
					//point(width - x[j] / 3 * inx1, y[j]/2*iny2);
					point( width / 2 - x[j] / 2 * inx2, y[j]/1.015*iny3-height/2);
					point(width / 2 + x[j] / 2 * inx2, y[j]/1.015*iny3-height/2);
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);

					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 3.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), height - yy, x + random(-128, 128), height - (yy - random(32, height)));
		}
	}/*
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}*/
}"
"946388","t1","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 4;

function setup() {
  createCanvas(windowHeight, windowHeight);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (1.75), y: abs(width / (1.25) - x + y / (0.5 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 100, y: (height / 5 - y * 1.025 / j + (x / 2)) / 1.75 + j * (40) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 - x * j) / (1.25 * j + x / (width / 0.8)), y: y / 1.05 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.75), y: abs(width / (1.25) - x + y / (0.5 * j * ((0.5 - y / width) * 800))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 100, y: (height / 10 - y * 2.025 / j + (x / 1)) / 1.75 + j * (10) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 - x * j) / (1.75 * j + x / (width / 0.8)), y: y / 2.25 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 1; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let nx1 = y[j] / height;
				let inx1 = 0.35+pow(1-nx1, 3);
				let nx2 = y2[j] / height;
				let inx2 = 0.5+pow(1-nx2, 2.5);
				let ny1 = abs(0.5 - x[j] / width) * 2;
				let ny = x[j] / width;
				let iny = pow(1-ny1, 0.5);
				let iny2 = 0.5 + abs(cos(ny * PI * 0.15 + nx1 * PI * 0.5));
				let iny3 = 0.25 + abs(sin(ny * PI * 1));
				
				let e = 0.75;

				if (iter > 20) {
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.0425 * a);
					point(width / 2 - x2[j] / 1.5 * inx1 + 1 * inx1, height / 5 - y2[j]/5);
					point(width / 2 + x2[j] / 1.5 * inx1 - 1 * inx1, height / 5 - y2[j]/5);
					point(width / 2 - x[j] / 1 * inx1+2, height / 1 - y[j]/1.125+50);
					point(width / 2 + x[j] / 1 * inx1-2, height / 1 - y[j]/1.125+50);
					//point( x[j] / 3 * inx1, y[j]/2*iny2);
					//point(width - x[j] / 3 * inx1, y[j]/2*iny2);
					point( width / 2 - x[j] / 2 * inx2, y[j]/1.015*iny3-height/2);
					point(width / 2 + x[j] / 2 * inx2, y[j]/1.015*iny3-height/2);
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);

					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 3.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), height - yy, x + random(-128, 128), height - (yy - random(32, height)));
		}
	}/*
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}*/
}"
"946383","cthu1","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 4;

function setup() {
  createCanvas(windowHeight, windowHeight);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (1.75), y: abs(width / (1.25) - x + y / (0.5 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 100, y: (height / 5 - y * 1.025 / j + (x / 2)) / 1.75 + j * (40) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 - x * j) / (1.25 * j + x / (width / 0.8)), y: y / 1.05 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (1.25) - x + y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 80, y: (height / 1.45 - y * 1.015 / j + (x / 1.75)) / 1.75 + j * (50) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (2.465 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 1; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let nx1 = y[j] / height;
				let inx1 = 0.35+pow(1-nx1, 3);
				let nx2 = y2[j] / height;
				let inx2 = 0.5+pow(1-nx2, 2.5);
				let ny1 = abs(0.5 - x[j] / width) * 2;
				let ny = x[j] / width;
				let iny = pow(1-ny1, 0.5);
				let iny2 = 0.5 + abs(cos(ny * PI * 0.15 + nx1 * PI * 0.5));
				let iny3 = 0.25 + abs(sin(ny * PI * 1));
				
				let e = 0.75;

				if (iter > 20) {
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.0425 * a);
					point(width / 2 - x[j] / 1.5 * inx1 + 2 * inx1, height / 3 - y[j]/1.75*iny2);
					point(width / 2 + x[j] / 1.5 * inx1 - 2 * inx1, height / 3 - y[j]/1.75*iny2);
					point(width / 2 - x[j] / 1 * inx1, height / 1 - y[j]/1.25+50);
					point(width / 2 + x[j] / 1 * inx1, height / 1 - y[j]/1.25+50);
					//point( x[j] / 3 * inx1, y[j]/2*iny2);
					//point(width - x[j] / 3 * inx1, y[j]/2*iny2);
					point( width / 2 - x[j] / 2 * inx2, y[j]/1.015*iny3-height/2);
					point(width / 2 + x[j] / 2 * inx2, y[j]/1.015*iny3-height/2);
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);

					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 3.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), height - yy, x + random(-128, 128), height - (yy - random(32, height)));
		}
	}/*
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}*/
}"
"946376","dem6","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 4;

function setup() {
  createCanvas(windowHeight, windowHeight);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (1.35), y: abs(width / (1.35) - x + y / (0.5 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 60, y: (height / 4 - y * 1.25 / j + (x / 1)) / 1.75 + j * (1) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 - x * j) / (1.75 * j + x / (width / 0.8)), y: y / 1.05 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (1.25) - x + y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 80, y: (height / 1.45 - y * 1.015 / j + (x / 1.75)) / 1.75 + j * (50) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (2.465 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 1; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let nx1 = y[j] / height;
				let inx1 = 0.5+pow(1-nx1, 3);
				let nx2 = y2[j] / height;
				let inx2 = 0.5+pow(1-nx2, 2.5);
				let ny1 = abs(0.5 - x[j] / width) * 2;
				let ny = x[j] / width;
				let iny = pow(1-ny1, 0.5);
				let iny2 = 0.25+pow(1-ny1, 0.5);
				let iny3 = 0.25 + abs(sin(ny * PI * 2));
				
				let e = 0.75;

				if (iter > 20) {
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.0425 * a);
					point(width / 2 - x[j] / 1 * inx1-50, height / 2 - y[j]/0.95);
					point(width / 2 + x[j] / 1 * inx1+50, height / 2 - y[j]/0.95);
					point(width / 2 - x[j] / 1 * inx1, height / 1 - y[j]/1.5);
					point(width / 2 + x[j] / 1 * inx1, height / 1 - y[j]/1.5);
					point( x[j] / 1 * inx2, y[j]/1.15-height/2);
					point(width - x[j] / 1 * inx2, y[j]/1.15-height/2);
					point( width / 2 - x[j] / 2 * inx2, y[j]/1.15*iny3-height/2);
					point(width / 2 + x[j] / 2 * inx2, y[j]/1.15*iny3-height/2);
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);

					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 3.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), height - yy, x + random(-128, 128), height - (yy - random(32, height)));
		}
	}/*
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}*/
}"
"946375","city1","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 4;

function setup() {
  createCanvas(windowHeight, windowHeight);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (1.25), y: abs(width / (1.25) - x + y / (0.5 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 60, y: (height / 4 - y * 1.25 / j + (x / 1)) / 1.75 + j * (1) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 - x * j) / (1.75 * j + x / (width / 0.8)), y: y / 1.05 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (1.25) - x + y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 80, y: (height / 1.45 - y * 1.015 / j + (x / 1.75)) / 1.75 + j * (50) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (2.465 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 1; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let nx1 = y[j] / height;
				let inx1 = 0.5+pow(1-nx1, 3);
				let nx2 = y2[j] / height;
				let inx2 = 0.5+pow(1-nx2, 2.5);
				let ny1 = abs(0.5 - x[j] / width) * 2;
				let ny = x[j] / width;
				let iny = pow(1-ny1, 0.5);
				let iny2 = 0.25+pow(1-ny1, 0.5);
				let iny3 = 0.25 + abs(sin(ny * PI * 2));
				
				let e = 0.75;

				if (iter > 20) {
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.0425 * a);
					point(width / 2 - x[j] / 1 * inx1-50, height / 2 - y[j]/0.95);
					point(width / 2 + x[j] / 1 * inx1+50, height / 2 - y[j]/0.95);
					point(width / 2 - x[j] / 1 * inx1, height / 1 - y[j]/1.5);
					point(width / 2 + x[j] / 1 * inx1, height / 1 - y[j]/1.5);
					point( x[j] / 1 * inx2, y[j]/1.15-height/2);
					point(width - x[j] / 1 * inx2, y[j]/1.15-height/2);
					point( width / 2 - x[j] / 2 * inx2, y[j]/1.15*iny3-height/2);
					point(width / 2 + x[j] / 2 * inx2, y[j]/1.15*iny3-height/2);
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);

					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 3.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), height - yy, x + random(-128, 128), height - (yy - random(32, height)));
		}
	}/*
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}*/
}"
"946375","city1","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 4;

function setup() {
  createCanvas(windowHeight, windowHeight);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (1.25), y: abs(width / (1.25) - x + y / (0.5 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 60, y: (height / 4 - y * 1.25 / j + (x / 10)) / 1.75 + j * (1) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 - x * j) / (1.75 * j + x / (width / 0.8)), y: y / 1.05 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (1.25) - x + y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 80, y: (height / 1.45 - y * 1.015 / j + (x / 1.75)) / 1.75 + j * (50) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (2.465 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 1; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let nx1 = y[j] / height;
				let inx1 = 0.5+pow(1-nx1, 3);
				let nx2 = y2[j] / height;
				let inx2 = 0.5+pow(1-nx2, 2.5);
				let ny1 = abs(0.5 - x[j] / width) * 2;
				let ny = x[j] / width;
				let iny = pow(1-ny1, 0.5);
				let iny2 = 0.25+pow(1-ny1, 0.5);
				let iny3 = 0.25 + abs(sin(ny * PI * 2));
				
				let e = 0.75;

				if (iter > 20) {
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.0425 * a);
					point(width / 2 - x[j] / 1 * inx1-50, height / 2 - y[j]/0.95);
					point(width / 2 + x[j] / 1 * inx1+50, height / 2 - y[j]/0.95);
					point(width / 2 - x[j] / 1 * inx1, height / 1 - y[j]/1.5);
					point(width / 2 + x[j] / 1 * inx1, height / 1 - y[j]/1.5);
					point( x[j] / 1 * inx2, y[j]/1.15-height/2);
					point(width - x[j] / 1 * inx2, y[j]/1.15-height/2);
					point( width / 2 - x[j] / 2 * inx2, y[j]/1.15*iny3-height/2);
					point(width / 2 + x[j] / 2 * inx2, y[j]/1.15*iny3-height/2);
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);

					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 3.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), height - yy, x + random(-128, 128), height - (yy - random(32, height)));
		}
	}/*
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}*/
}"
"946359","dem5","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 4;

function setup() {
  createCanvas(windowHeight, windowHeight);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (1.25), y: abs(width / (1.25) - x + y / (0.5 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 80, y: (height / 4 - y * 1.25 / j + (x / 1)) / 1.75 + j * (1) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 - x * j) / (1.75 * j + x / (width / 0.8)), y: y / 1.5 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (1.25) - x + y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 80, y: (height / 1.45 - y * 1.015 / j + (x / 1.75)) / 1.75 + j * (50) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (2.465 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 1; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let nx1 = y[j] / height;
				let inx1 = 0.5+pow(1-nx1, 3);
				let nx2 = y2[j] / height;
				let inx2 = 0.5+pow(1-nx2, 2.5);
				let ny1 = abs(0.5 - x[j] / width) * 2;
				let ny = x[j] / width;
				let iny = pow(1-ny1, 0.5);
				let iny2 = 0.25+pow(1-ny1, 0.5);
				let iny3 = 0.25 + abs(sin(ny * PI * 2));
				
				let e = 0.75;

				if (iter > 20) {
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.0425 * a);
					point(width / 2 - x[j] / 1 * inx1+5, height / 1 - y[j]/1.25);
					point(width / 2 + x[j] / 1 * inx1-5, height / 1 - y[j]/1.25);
					point( x[j] / 2 * inx2, y[j]/1.15-height/2);
					point(width - x[j] / 2 * inx2, y[j]/1.15-height/2);
					point( width / 2 - x[j] / 1 * inx2, y[j]/1.15*iny3-height/2);
					point(width / 2 + x[j] / 1 * inx2, y[j]/1.15*iny3-height/2);
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);

					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 3.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), height - yy, x + random(-128, 128), height - (yy - random(32, height)));
		}
	}/*
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}*/
}"
"942931","dem4","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 4;

function setup() {
  createCanvas(windowHeight, windowHeight);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (1.0925), y: abs(width / (1.25) - x + y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.125 * x) / 1 + j * 80, y: (height / 1.45 - y * 1.015 / j + (x / 1.75)) / 1.75 + j * (100) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 - x * j) / (2.4965 * j + x / (width / 0.8)), y: y / 1.47459845 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (1.25) - x + y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 80, y: (height / 1.45 - y * 1.015 / j + (x / 1.75)) / 1.75 + j * (50) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (2.465 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 1; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let nx1 = y[j] / height;
				let inx1 = 0.5+pow(1-nx1, 2);
				let nx2 = y2[j] / height;
				let inx2 = 0.5+pow(1-nx2, 2.5);
				
				let e = 0.75;

				if (iter > 20) {
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.0425 * a);
					point(width / 2 - x[j] / 1 * inx1+5, height / 1 - y[j]/1.15);
					point(width / 2 + x[j] / 1 * inx1-5, height / 1 - y[j]/1.15);
					point(width / 2 + x[j] / 1 * inx2, y[j]/1.15-height/2);
					point(width /2- x[j] / 1 * inx2, y[j]/1.15-height/2);
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);

					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"942920","cockpit","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 4;

function setup() {
  createCanvas(windowHeight, windowHeight);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (1.0925), y: abs(width / (1.25) - x + y / (0.45 * j * ((0.5 - y / width) * 800))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.125 * x) / 1 + j * 80, y: (height / 1.45 - y * 1.015 / j + (x / 1.75)) / 1.75 + j * (100) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 - x * j) / (2.4965 * j + x / (width / 0.8)), y: y / 1.47459845 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (3.25) - x + y / (1.95 * j * ((0.5 - y / width) * 10))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 1, y: (height / 2 - y * 1.15 / j + (x / 10.075)) / 1.75 + j * (15) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (1.065 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 1; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let nx1 = y[j] / height;
				let inx1 = 0.5+pow(1-nx1, 2);
				let nx2 = y2[j] / height;
				let inx2 = 0.5+pow(1-nx2, 2.5);
				
				let e = 0.75;

				if (iter > 20) {
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.0425 * a);
					point(width / 2 - x[j] / 1 * inx1+5, height / 1 - y[j]/2.15);
					point(width / 2 + x[j] / 1 * inx1-5, height / 1 - y[j]/2.15);
					point(width / 2 + x[j] / 1 * inx1, y[j]/1.15-height/2);
					point(width /2- x[j] / 1 * inx1, y[j]/1.15-height/2);
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					//point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					//point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					//point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					//point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"942511","dem","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 4;

function setup() {
  createCanvas(windowHeight, windowHeight);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (1.0925), y: abs(width / (3.95) - x + y / (0.45 * j * ((0.5 - y / width) * 80))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.125 * x) / 1 + j * 4, y: (height / 1.45 - y * 1.015 / j + (x / 1.75)) / 1.75 + j * (100) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 - x * j) / (1.4965 * j + x / (width / 0.8)), y: y / 1.47459845 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (3.25) - x + y / (1.95 * j * ((0.5 - y / width) * 10))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 1, y: (height / 2 - y * 1.15 / j + (x / 10.075)) / 1.75 + j * (15) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (1.065 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 1; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				let nx1 = y[j] / height;
				let inx1 = 0.5+pow(1-nx1, 2);
				let nx2 = y2[j] / height;
				let inx2 = 0.5+pow(1-nx2, 2.5);
				
				let e = 0.75;

				if (iter > 20) {
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.0425 * a);
					point(width / 2. - x[j] / 2 * inx1+6, height / 1 - y[j]/2.35);
					point(width / 2. + x[j] / 2 * inx1-6, height / 1 - y[j]/2.35);
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					point(width / 2 + width / 2 - x2[j] / 1.025 * inx2, height - y2[j] / 0.45);
					point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, height - y2[j] / 0.45);
					point(width / 2 + width / 2 - x2[j] / 1.025 * inx2,y2[j] / 0.85-100);
					point(width / 2 - width / 2 + x2[j]/ 1.025 * inx2, y2[j] / 0.85 - 100);
					point(width / 2 + width / 2 - x2[j] / 2.15 * inx2,height / 2 +y2[j] / 1.045);
					point(width / 2 - width / 2 + x2[j]/ 2.15 * inx2, height / 2 +y2[j] / 1.045);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"941791","dem","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 4;

function setup() {
  createCanvas(windowHeight, windowHeight);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (1.0925), y: abs(width / (1.95) - x + y / (0.45 * j * ((0.5 - y / width) * 80))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 1.125 * x) / 1 + j * 1, y: (height / 1.45 - y * 1.015 / j + (x / 1.75)) / 1.75 + j * (5) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 - x * j) / (1.4965 * j + x / (width / 0.8)), y: y / 1.7459845 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (2.75) - x + y / (1.45 * j * ((0.5 - y / width) * 10))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 10, y: (height / 2 - y * 1.15 / j + (x / 1.75)) / 1.75 + j * (20) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (10.065 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 1; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				
				
				let nx1 = y[j] / height;
				let inx1 = 0.5+pow(1-nx1, 2);
				let nx2 = y2[j] / height;
				let inx2 = 0.5+pow(1-nx2, 2);
				
				let e = 0.75;

				if (iter > 20) {
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.0425 * a);
					point(width / 2 - x[j] / 1.8 * inx1, height / 1.175 - y[j]/1.35);
					point(width / 2 + x[j] / 1.8 * inx1, height / 1.175 - y[j]/1.35);
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					point(width / 2 + width / 2 - x2[j] / 1.15 * inx2, height - y2[j] / 0.45);
					point(width / 2 - width / 2 + x2[j]/ 1.15 * inx2, height - y2[j] / 0.45);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"940742","gate","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 4;

function setup() {
  createCanvas(windowHeight, windowHeight);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (1.0925), y: abs(width / (8.95) - x + y / (0.45 * j * ((0.5 - y / width) * 8))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.125 * x) / 1 + j * 1, y: (height / 3.5 - y * 1.015 / j + (x / 1.75)) / 1.75 + j * (40) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 - x * j) / (1.04965 * j + x / (width / 0.8)), y: y / 1.00745 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (2.75) - x + y / (1.45 * j * ((0.5 - y / width) * 10))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 10, y: (height / 2 - y * 1.15 / j + (x / 1.75)) / 1.75 + j * (20) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (1.065 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 1; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;
				
				let a = (j / ifs);
				
				
				
				let nx1 = y[j] / height;
				let inx1 = 0.5+pow(1-nx1, 2);
				let nx2 = y2[j] / height;
				let inx2 = 0.5+pow(1-nx2, 2);
				
				let e = 0.75;

				if (iter > 20) {
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.0425 * a);
					point(width / 2 - x[j] / 1.8 * inx1, height / 3.75 - y[j]/1.35);
					point(width / 2 + x[j] / 1.8 * inx1, height / 3.75 - y[j]/1.35);
					stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 200, 0.125 * a);
					point(width / 2 + width / 2 - x2[j] / 1.15 * inx2, height - y2[j] / 0.45);
					point(width / 2 - width / 2 + x2[j]/ 1.15 * inx2, height - y2[j] / 0.45);
					//point(x[j] / 1 * inx1, y[j]);
					//point(width - x[j]/ 1 * inx1, y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.02);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"939376","Normal","mySketch","function setup() {
	createCanvas(800, 800);
	background(100);
	
	noiseDetail(8, 0.4);
	
	colorMode(HSB, 360, 1, 1, 1);
	
	rectMode(CENTER);
	
	noStroke();
	
	background(0);
}

function draw() {
	for (let y = 0; y < 800; y += 16) {
		for (let x = 0; x < 800; x += 16) {
			let nx = x / 800;
			let ny = y / 800;
			
			let n = noise(nx * 4, ny * 4);
			
			fill(0, 0, pow(n, 1.25), 1);
			rect(x, y, 16, 16);
		}
	}
	
	for (let y = 0; y < 800; y += 8) {
		for (let x = 0; x < 800; x += 8) {
			let nx = x / 800;
			let ny = y / 800;
			
			let n = noise(nx * 4, ny * 4);
			
			let nx0 = noise(nx * 4 - 0.05, ny * 4);
			let nx1 = noise(nx * 4 + 0.05, ny * 4);
			let ny1 = noise(nx * 4, ny * 4 + 0.05);
			let ny0 = noise(nx * 4, ny * 4 - 0.05);
			
let dzdx=(nx1-nx0)/2;
let dzdy=(ny1-ny0)/2;
			
			stroke(0, 0.5, 1, 1);
			line(x, y, x + -dzdx * 100, y + -dzdy * 100);
		}
	}
	noStroke();
}"
"939376","Normal","mySketch","function setup() {
	createCanvas(800, 800);
	background(100);
	
	noiseDetail(8, 0.4);
	
	colorMode(HSB, 360, 1, 1, 1);
	
	rectMode(CENTER);
	
	noStroke();
	
	background(0);
}

function draw() {

/*
  // display noise map
	for (let y = 0; y < 800; y += 16) {
		for (let x = 0; x < 800; x += 16) {
			let nx = x / 800;
			let ny = y / 800;
			
			let n = noise(nx * 4, ny * 4);
			
			fill(0, 0, pow(n, 1.25), 1);
			rect(x, y, 16, 16);
		}
	}
*/
	
	stroke(0, 0.5, 1, 1);
	
	for (let y = 0; y < 800; y += 4) {
		for (let x = 0; x < 800; x += 4) {
			let nx = x / 800;
			let ny = y / 800;
			
			// let n = noise(nx * 4, ny * 4); // sampled point
			
			let nx0 = noise(nx * 4 - 0.05, ny * 4); // left
			let nx1 = noise(nx * 4 + 0.05, ny * 4); // right
			let ny1 = noise(nx * 4, ny * 4 + 0.05); // top
			let ny0 = noise(nx * 4, ny * 4 - 0.05); // bottom
			
			let dzdx= (nx1-nx0) / 2;
			let dzdy= (ny1-ny0) / 2;
			
			// vector length
			let len = sqrt((dzdx * dzdx) + (dzdy * dzdy));
			
			// normalize
			dzdx /= len;
			dzdy /= len;
			
			line(x, y, x + -dzdx * 1, y + -dzdy * 1);
		}
	}
	
}"
"939287","States 3","mySketch","var xmotion = 0;
var ymotion = 0;

var objs = [];
var nn = 480;

// https://iquilezles.org/www/articles/palettes/palettes.htm
function pal(t, a, b, c, d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

function setup() {
	createCanvas(1000, 1000);
	
	background(0);
	
	noiseDetail(7, 0.7);
	
	for (var n = 0; n < nn; n += 1) {
		objs[n] = { x: windowWidth * random(), y: 0, vx: random(-1, 1) / 6000, vy: 1, n: random(-1, 1) * windowWidth, vv: random() };
	}
	
	ellipseMode(CENTER);
	rectMode(CENTER);
}

function compute() {
	fill(0);
	
	strokeWeight(1);

	for (var n = 0; n < nn; n += 1) {
		objs[n].n += objs[n].vx;
		objs[n].y += objs[n].vy;
		objs[n].x = -windowWidth + noise(objs[n].n+sin(xmotion*objs[n].y/windowHeight)/8) * windowWidth *2;
		
		//objs[n].y %= windowHeight;
		if (objs[n].y > windowHeight) {
			objs[n].y = 0;
			//objs[n].x += windowWidth * objs[n].n;
			//objs[n].x %= windowWidth;
			objs[n].n = random(-1, 1) * windowWidth
		}
		
		var dd = Infinity;
		var did = n;

		for (var i = 0; i < nn; i += 1) {
			var d = (abs((objs[n].x - objs[i].x) * (objs[n].x - objs[i].x)) + abs((objs[n].y - objs[i].y) * (objs[n].y - objs[i].y))); // sqrt
			if (i !== n && d < dd) {//1 * abs(objs[n].n)) {
				did = i;
				dd = d;
			}
		}
		
		if (did !== n) {
			objs[did].vx = -objs[did].vx;
		}
		
		var pa1 = 0.95, pa2 = 0.5 + cos(xmotion) / 2, pa3 = 0.95;
		var pb1 = objs[n].vv, pb2 = objs[n].vv, pb3 = objs[n].vv;
		var pc1 = 1, pc2 = 1, pc3 = 0.95;

		var pdr = objs[n].vv*0.8;
		var pdg = objs[n].vv*0.9;
		var pdb = objs[n].vv*0.95;

		var pt = noise(objs[n].n / windowWidth * 2 + xmotion*1.1);

		var rf = pal(pt, pa1, pb1, pc1, pdr) * 255;
		var gf = pal(pt, pa2, pb2, pc2, pdg) * 255;
		var bf = pal(pt, pa3, pb3, pc3, pdb) * 255;
		
		noFill();
		stroke(rf, gf, bf, 255 * pt);
		//line(objs[n].x, objs[n].y, objs[did].x, objs[did].y);
		//bezier(objs[n].x, objs[n].y, objs[n].x + objs[n].n, objs[n].y, objs[n].x, objs[n].y, objs[did].x, objs[did].y);
		bezier(objs[n].y, objs[n].x/1.05 + objs[n].n, objs[n].y/1.05, objs[n].x, objs[n].y, objs[n].x/1.05, objs[did].y/1.05, objs[did].x);
		//bezier(windowWidth - objs[n].x, windowHeight - objs[n].y, windowWidth - objs[n].x + objs[n].n, windowHeight - objs[n].y, windowWidth - objs[n].x, windowHeight - objs[n].y, windowWidth - objs[did].x, windowHeight - objs[did].y);
		//bezier(windowHeight - objs[n].y, windowWidth - objs[n].x + objs[n].n, windowHeight - objs[n].y, windowWidth - objs[n].x, windowHeight - objs[n].y, windowWidth - objs[n].x, windowHeight - objs[did].y, windowWidth - objs[did].x);
		noStroke();
		//noFill();
		stroke(pt*360, 0, 255, 255 * pt);
		//fill(pt*360, 0, 198, 255 * pt);
		//rect(objs[n].x, objs[n].y, 1 * pt, 1 * pt);
		//rect(objs[did].x, objs[did].y, 1, 1);
	}
}

function draw() {
	noStroke();
/*
	fill(0, 0, 0, 1);
	rect(0, 0, windowWidth, windowHeight);
*/
	compute();
	
	xmotion += 0.0008;
	ymotion += 0.0002;
}"
"938860","States²","mySketch","var xmotion = 0;
var ymotion = 0;

var objs = [];
var nn = 500;

// https://iquilezles.org/www/articles/palettes/palettes.htm
function pal(t, a, b, c, d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

function setup() {
	createCanvas(1000, 1000);
	
	background(0);
	
	noiseDetail(7, 0.7);
	
	for (var n = 0; n < nn; n += 1) {
		objs[n] = { x: windowWidth * random(), y: 0, vx: random(-1, 1) / 6000, vy: 1, n: random(-1, 1) * windowWidth, vv: random() };
	}
	
	ellipseMode(CENTER);
	rectMode(CENTER);
}

function compute() {
	fill(0);
	
	strokeWeight(1);

	for (var n = 0; n < nn; n += 1) {
		objs[n].n += objs[n].vx;
		objs[n].y += objs[n].vy;
		objs[n].x = -windowWidth + noise(objs[n].n+sin(xmotion*objs[n].y/windowHeight)/8) * windowWidth *2;
		
		//objs[n].y %= windowHeight;
		if (objs[n].y > windowHeight) {
			objs[n].y = 0;
			//objs[n].x += windowWidth * objs[n].n;
			//objs[n].x %= windowWidth;
			objs[n].n = random(-1, 1) * windowWidth
		}
		
		var dd = Infinity;
		var did = n;

		for (var i = 0; i < nn; i += 1) {
			var d = (abs((objs[n].x - objs[i].x) * (objs[n].x - objs[i].x)) + abs((objs[n].y - objs[i].y) * (objs[n].y - objs[i].y))); // sqrt
			if (i !== n && d < dd) {//1 * abs(objs[n].n)) {
				did = i;
				dd = d;
			}
		}
		
		if (did !== n) {
			objs[did].vx = -objs[did].vx;
		}
		
		var pa1 = 0.95, pa2 = 0.95, pa3 = 0.75;
		var pb1 = objs[n].vv, pb2 = objs[n].vv, pb3 = objs[n].vv;
		var pc1 = 1, pc2 = 1, pc3 = 0.95;

		var pdr = objs[n].vv*0.8;
		var pdg = objs[n].vv*0.9;
		var pdb = objs[n].vv*0.95;

		var pt = noise(objs[n].n / windowWidth * 2 + xmotion/1);

		var rf = pal(pt, pa1, pb1, pc1, pdr) * 255;
		var gf = pal(pt, pa2, pb2, pc2, pdg) * 255;
		var bf = pal(pt, pa3, pb3, pc3, pdb) * 255;
		
		noFill();
		stroke(rf, gf, bf, 255);
		//line(objs[n].x, objs[n].y, objs[did].x, objs[did].y);
		bezier(objs[n].x, objs[n].y, objs[n].x + objs[n].n, objs[n].y, objs[n].x, objs[n].y, objs[did].x, objs[did].y);
		noStroke();
		//noFill();
		stroke(pt*360, 128, 198, 255);
		fill(pt*360, 128, 198, 255);
		rect(objs[n].x, objs[n].y, 1 * pt, 1 * pt);
		//rect(objs[did].x, objs[did].y, 1, 1);
	}
}

function draw() {
	noStroke();
/*
	fill(0, 0, 0, 1);
	rect(0, 0, windowWidth, windowHeight);
*/
	compute();
	
	xmotion += 0.0008;
	ymotion += 0.0002;
}"
"936844","ifs10","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 4;

function setup() {
  createCanvas(windowHeight, windowHeight);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (1.0925), y: abs(width / (2.95) - x + y / (0.45 * j * ((0.5 - y / width) * 20))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 10, y: (height / 3.5 - y * 1.015 / j + (x / 1.75)) / 1.75 + j * (40) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (1.4965 * j + x / (width / 0.8)), y: y / 1.0745 + j };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (2.75) - x + y / (1.45 * j * ((0.5 - y / width) * 10))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 10, y: (height / 2 - y * 1.15 / j + (x / 1.75)) / 1.75 + j * (40) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (1.065 * j + x / (width / 0.8)), y: y / 1.745 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 1; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;

				stroke(200 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 128 * pow((j / ifs), 1.25), 192, 0.125 * (j / ifs));

				let e = 0.75;

				if (iter > 20) {
					point(width / 2 - x[j] / 1.25 - width / 512, height / 4.5 - y[j]/2 - width / 24);
					point(width / 2 + x[j] / 1.25 + width / 512, height / 4.5 - y[j]/2 - width / 24);
					point(x2[j] / 1., height - y2[j] / 0.5);
					point(width - x2[j]/ 1., height - y2[j] / 0.5);
					point(x[j], y[j]);
					point(width - x[j], y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.05);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"936839","Sam9","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 4;

function setup() {
  createCanvas(windowHeight, windowHeight);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (1.0925), y: abs(width / (2.95) - x + y / (0.45 * j * ((0.5 - y / width) * 20))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 10, y: (height / 3.5 - y * 1.015 / j + (x / 1.75)) / 1.75 + j * (40) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (1.4965 * j + x / (width / 0.8)), y: y / 1.00745 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (2.75) - x + y / (1.45 * j * ((0.5 - y / width) * 10))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 10, y: (height / 2 - y * 1.15 / j + (x / 1.75)) / 1.75 + j * (20) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (1.065 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 1; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;

				stroke(100 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 192, 0.125 * (j / ifs));

				let e = 0.75;

				if (iter > 20) {
					point(width / 2 - x[j] / 1.25, height / 3 - y[j]/1.5);
					point(width / 2 + x[j] / 1.25 , height / 3 - y[j]/1.5);
					point(width / 2 + width / 2 - x2[j] / 1.25, height - y2[j] / 0.5);
					point(width / 2 - width / 2 + x2[j]/ 1.25, height - y2[j] / 0.5);
					point(x[j], y[j]);
					point(width - x[j]/ 1, y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.05);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"936837","Sam8","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 4;

function setup() {
  createCanvas(windowHeight, windowHeight);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (1.0925), y: abs(width / (2.95) - x + y / (0.45 * j * ((0.5 - y / width) * 20))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1 + j * 10, y: (height / 3.5 - y * 1.015 / j + (x / 1.75)) / 1.75 + j * (40) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (1.4965 * j + x / (width / 0.8)), y: y / 1.00745 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (1.75) - x + y / (1.45 * j * ((0.5 - y / width) * 10))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 1 * x) / 1 + j * 1, y: (height / 2 - y * 1.15 / j + (x / 1.75)) / 1.75 + j * (20) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (1.065 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 1; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;

				stroke(100 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 192, 0.125 * (j / ifs));

				let e = 0.75;

				if (iter > 20) {
					point(width / 2 - x[j] / 1.25, height / 3 - y[j]/1.75);
					point(width / 2 + x[j] / 1.25 , height / 3 - y[j]/1.75);
					point(width / 2 + width / 2 - x2[j] / 1.25, height - y2[j] / 1.25);
					point(width / 2 - width / 2 + x2[j]/ 1.25, height - y2[j] / 1.25);
					point(x[j], y[j]);
					point(width - x[j]/ 1, y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.05);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"935411","Sam3","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 4;

function setup() {
  createCanvas(windowHeight, windowHeight);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (1.0925), y: abs(width / (2.25) - x + y / (1.45 * j * ((0.5 - y / width) * 12))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 1 * x) / 1 + j * 40, y: (height / 2.5 - y * 1.15 / j + (x / 1.75)) / 1.75 + j * (1) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (0.965 * j + x / (width / 1.8)), y: y / 2.745 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.05925), y: abs(width / (1.75) - x + y / (1.45 * j * ((0.5 - y / width) * 10))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 1 * x) / 1 + j * 40, y: (height / 2 - y * 1.15 / j + (x / 1.75)) / 1.75 + j * (20) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (1.065 * j + x / (width / 0.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 1; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;

				stroke(100 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 64 * pow((j / ifs), 2), 192, 0.125 * (j / ifs));

				let e = 0.75;

				if (iter > 20) {
					//point(width / 2 - x[j] / 1.25, height / 4 - y[j]/2.75);
					//point(width / 2 + x[j] / 1.25 , height / 4 - y[j]/2.75);
					point(width / 2 + width / 64 - x2[j] / 1.25, height - y2[j] / 1.25);
					point(width / 2 - width / 64 + x2[j]/ 1.25, height - y2[j] / 1.25);
					point(width / 2 - x[j] / 1, y[j] / 1.5);
					point(width / 2 + x[j]/ 1, y[j] / 1.5);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.05);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"935370","Sam2","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 4;

function setup() {
  createCanvas(windowHeight, windowHeight);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (1.0925), y: abs(width / (2.25) - x + y / (1.45 * j * ((0.5 - y / width) * 14))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 1 * x) / 1 + j * 40, y: (height / 2 - y * 1.15 / j + (x / 1.75)) / 1.75 + j * (20) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (0.965 * j + x / (width / 1.8)), y: y / 2.745 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.0925), y: abs(width / (2) - x + y / (1.45 * j * ((0.5 - y / width) * 10))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 1 * x) / 1 + j * 40, y: (height / 2 - y * 1.15 / j + (x / 1.75)) / 1.75 + j * (20) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (1.065 * j + x / (width / 1.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 1; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;

				stroke(170 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 255 * pow((j / ifs), 2), 192, 0.125 * (j / ifs));

				let e = 0.75;

				if (iter > 20) {
					//point(width / 2 - x[j] / 1.25, height / 4 - y[j]/2.75);
					//point(width / 2 + x[j] / 1.25 , height / 4 - y[j]/2.75);
					point(width / 2 + width / 64 - x2[j] / 1.25, height - y2[j] / 1.25);
					point(width / 2 - width / 64 + x2[j]/ 1.25, height - y2[j] / 1.25);
					point(width / 2 - x[j] / 1, y[j] / 1.5);
					point(width / 2 + x[j]/ 1, y[j] / 1.5);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.05);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"935143","Sam","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];
let x2 = [];
let y2 = [];

let ifs = 4;

function setup() {
  createCanvas(windowHeight, windowHeight);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
		x2[i] = random(0, width);
		y2[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (1.0925), y: abs(width / (2) - x + y / (1.45 * j * ((0.5 - y / width) * 14))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 1 * x) / 1 + j * 40, y: (height / 2 - y * 1.15 / j + (x / 1.75)) / 1.75 + j * (20) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (1.065 * j + x / (width / 1.8)), y: y / 1.45 };
}

var f = [f1, f2, f3];

function f4(x, y, j) {
	return { x: y / (1.0925), y: abs(width / (2) - x + y / (1.45 * j * ((0.5 - y / width) * 10))) };
}

function f5(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 1 * x) / 1 + j * 40, y: (height / 2 - y * 1.15 / j + (x / 1.75)) / 1.75 + j * (20) };
}

function f6(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (1.065 * j + x / (width / 1.8)), y: y / 1.45 };
}

var ff = [f4, f5, f6];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 1; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;
				
				r = ff[index](x2[j], y2[j], j);

				x2[j] = r.x; y2[j] = r.y;

				stroke(120 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 255 * pow((j / ifs), 2), 192, 0.125 * (j / ifs));

				let e = 0.75;

				if (iter > 20) {
					//point(width / 2 - x[j] / 1.25, height / 4 - y[j]/2.75);
					//point(width / 2 + x[j] / 1.25 , height / 4 - y[j]/2.75);
					point(width / 2 + width / 64 - x2[j] / 1.25, height - y2[j] / 1.25);
					point(width / 2 - width / 64 + x2[j]/ 1.25, height - y2[j] / 1.25);
					point(width / 2 - x[j] / 1.05, y[j] / 1.5);
					point(width / 2 + x[j]/ 1.05, y[j] / 1.5);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.05);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"934868","Krystal","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];

let ifs = 8;

function setup() {
  createCanvas(windowHeight, windowHeight);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (1.0925), y: abs(width / 2.985 - x + y / (1.075 * j * ((0.5 + y / width) * 4))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 8.0711 * x) / 12.025 + j * 20 + abs(sin(j / ifs * PI * 1) * 0.35) * y, y: (height * 0.845 - y * 1.15 / j + (x / 1.5)) / (2.75) + j * 20 };
}

function f3(x, y, j) {
	return { x: abs(width * 0.05 * j / (y / 1.5) + x * j) / (30.045 * j + x / (width / 4.5)), y: x + abs(sin(j / ifs * PI * 1)) * y };
}

var f = [f1, f2, f3];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 1; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;

				stroke(64 + 224 *  (1 - j / ifs), 16 + 48 * (1 - j / ifs), 192, 0.125 * (j / ifs));

				let e = 0.75;

				if (iter > 20) {
					//point(y[j]*0.5, x[j]);
					//point(width - y[j]*0.5, x[j]);
					//point(width - x[j] + width * 0.05, y[j] * j);
					point(x[j] / 2, y[j] / 1.25);
					point(width - x[j] / 2, y[j] / 1.25);
					point(width / 2 - x[j], height - y[j]);
					point(width / 2 + x[j], height - y[j]);
					//point(width - x[j], height - y[j]);
					//point(x[j] - width * 0.05, y[j] * j);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}/*
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.05);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}*/
}"
"934590","Krystal","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];

let ifs = 10;

function setup() {
  createCanvas(windowHeight, windowHeight);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (1.0925), y: abs(width / 40.985 - x + y / (4.075 * j * ((0.5 + y / width) * 1))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 8.0711 * x) / 32.025 + j * 10 + abs(sin(j / ifs * PI * 1) * 0.35) * y, y: (height * 0.45 - y * 1.15 / j + (x / 1.5)) / (2.75) + j * 20 };
}

function f3(x, y, j) {
	return { x: abs(width * 0.25 * j / (y / 1.5) + x * j) / (4.045 * j + x / (width / 0.5)), y: y + abs(sin(j / ifs * PI * 2)) * x };
}

var f = [f1, f2, f3];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 1; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;

				stroke(224, 16 + 92 * (1 - j / ifs), 192, 0.125 * (j / ifs));

				let e = 0.75;

				if (iter > 20) {
					point(width / 2 + x[j]*1.5, y[j]);
					point(width / 2 - x[j]*1.5, y[j]);
					//point(width - x[j] + width * 0.05, y[j] * j);
					point(x[j], height - y[j]);
					point(width - x[j] - 4, height - y[j]);
					//point(width - x[j], height - y[j]);
					//point(x[j] - width * 0.05, y[j] * j);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}/*
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.05);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}*/
}"
"934590","Krystal","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];

let ifs = 10;

function setup() {
  createCanvas(windowHeight, windowHeight);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (1.0925), y: abs(width / 1.985 - x + y / (1.075 * j * ((0.5 + y / width) * 16))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 1.0711 * x) / 1.025 + j * 100 + abs(sin(j / ifs * PI * 1) * 0.05) * y, y: (height * 1.45 - y * 1.15 / j + (x / 1.5)) / (2.75) + j * 10 };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 * j / (y / 1.5) + x * (j / ifs * y/200)) / (1.045 * j + x / (width / 0.5)), y: x + abs(sin(j / ifs * PI * 2)) * y };
}

var f = [f1, f2, f3];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 1; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;

				stroke(128 + 128 * (1 - j / ifs), 16 + 92 * (1 - j / ifs), 192, 0.125 * (j / ifs));

				let e = 0.75;

				if (iter > 20) {
					point(width / 2 + x[j]*0.15, height / 2 + y[j]*0.5);
					point(width / 2 - x[j]*0.5, height / 2 + y[j]*0.5);
					point(width - x[j]*0.5 + width * 0.05, height / 2 - y[j] * 0.5);
					point(x[j]*0.35, height/2 -y[j] * 0.45);
					//point(width - x[j], height/2 + y[j]/2);
					//point(width - x[j], height - y[j]);
					//point(x[j] - width * 0.05, y[j] * j);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}/*
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.05);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}*/
}"
"934590","Krystal","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];

let ifs = 10;

function setup() {
  createCanvas(windowHeight, windowHeight);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (1.0925), y: abs(width / 40.985 - x + y / (4.075 * j * ((0.5 + y / width) * 1))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 8.0711 * x) / 32.025 + j * 10 + abs(sin(j / ifs * PI * 1) * 0.35) * y, y: (height * 0.45 - y * 1.15 / j + (x / 1.5)) / (2.75) + j * 20 };
}

function f3(x, y, j) {
	return { x: abs(width * 0.25 * j / (y / 1.5) + x * j) / (4.045 * j + x / (width / 0.5)), y: y + abs(sin(j / ifs * PI * 2)) * x };
}

var f = [f1, f2, f3];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 1; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;

				stroke(224, 16 + 92 * (1 - j / ifs), 192, 0.125 * (j / ifs));

				let e = 0.75;

				if (iter > 20) {
					point(width / 2 + x[j]*1.5, y[j]);
					point(width / 2 - x[j]*1.5, y[j]);
					//point(width - x[j] + width * 0.05, y[j] * j);
					point(x[j], height - y[j]);
					point(width - x[j] - 4, height - y[j]);
					//point(width - x[j], height - y[j]);
					//point(x[j] - width * 0.05, y[j] * j);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}/*
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.05);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}*/
}"
"934357","ifs9","mySketch","// ifs
// https://flam3.com/flame_draves.pdf
// stacked with symmetry
// would need some normalization...

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];

let ifs = 6;

function setup() {
  createCanvas(1000, 1000);
  background(0);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 100, 100, 255);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
	}
}

function f1(x, y, j) {
	return { x: x / (10.85 - (cos(y / width * PI * (j / ifs * 20))) * 9.75), y: abs(width / 2 + x - y / 2.05) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 1.5 * x) / 1.25 + (j / ifs * 40 + noise(x / width, y / height, j / ifs) * 256), y: abs(height / 2 - y) / (5.5 - abs(cos(x / width * PI * abs(0.5 - j / ifs) * 2))*3) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 - x) / 1.5, y: y / 1.25 + noise(x / width, y / height, j / ifs) * 128 };
}

var f = [f1, f2, f3];

var iter = 0;

function draw() {
	//fill(0, 0, 0, 1);
	//rect(0, 0, width, height);
	
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 0; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;

				fill(167 + 64 * ((j + 1) / ifs), 24 * (j / ifs), 100 * ((j + 1) / ifs), 255 * (i / 1000) / 6);

				let e = 1;

				if (iter > 20) {
					ellipse(x[j], y[j], e, e);	
					ellipse(y[j], x[j], e, e);	
					ellipse(x[j], height - y[j], e, e);	
					ellipse(height - y[j], x[j], e, e);	
					ellipse(height - y[j], width - x[j], e, e);	
					ellipse(height - x[j], width - y[j], e, e);	
				}
			}

			iter += 1;
		}
	}
	
	xmotion += 1;
	ymotion += 1;
}"
"934310","Demilich2","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];

let ifs = 8;

function setup() {
  createCanvas(windowHeight, windowHeight);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (1.0925), y: abs(width / 4 - x + y / (1.45 + j * ((0.5 - y / width) * 250))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 1 * x) / 1 + j * (100 + x / 32), y: (height - y * 1.5 / j + (x / 2)) + j * (1) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 + y / 1 + x / 2) / (1 + j * x / (width / 2)), y: x / 1.25 + j };
}

var f = [f1, f2, f3];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 1; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;

				stroke(360 - 360 * (j / ifs) * (i / 1000) + 300 * (iter / 500000) * (r.x / width * r.y / height), 128 * pow((j / ifs), 2), 192, 0.125 * (j / ifs));

				let e = 0.75;

				if (iter > 20) {
					point(width - x[j]*0.75, height / 2 - y[j]/2.);
					point(x[j]*0.75, height / 2 - y[j]/2.);
					point(width / 2 - x[j] / 2.5, height / 2.25 + y[j]/2.75);
					point(width / 2 + x[j] / 2.5, height / 2.25 + y[j]/2.75);
					//point(width / 2 + x[j]/1.5, height / 1.5 + y[j]/2.75);
					//point(width / 2 - x[j]/1.5, height / 1.5 + y[j]/2.75);
					//point(width - x[j] / 1.8, height / 4 + y[j] / 1.75);
					//point(x[j]/ 1.8, height / 4 + y[j] / 1.75);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.05);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"934147","ifs8","mySketch","// ifs
// https://flam3.com/flame_draves.pdf
// stacked with symmetry
// would need some normalization...

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];

let ifs = 6;

function setup() {
  createCanvas(1000, 1000);
  background(0);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 100, 100, 255);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
	}
}

function f1(x, y, j) {
	return { x: x / (10.85 - (cos(y / width * PI * (j / ifs * 20))) * 9.75), y: abs(width / 2 + x - y / 2.05) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 1.5 * x) / 1.25, y: abs(height / 2 - y) / (5.5 - abs(cos(x / width * PI * abs(0.5 - j / ifs) * 2))*3) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 - x) / 1.5, y: y / 1.25 };
}

var f = [f1, f2, f3];

var iter = 0;

function draw() {
	//fill(0, 0, 0, 1);
	//rect(0, 0, width, height);
	
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 0; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;

				fill(167 + 64 * ((j + 1) / ifs), 24 * (j / ifs), 100 * ((j + 1) / ifs), 255 * (i / 1000) / 6);

				let e = 1;

				if (iter > 20) {
					ellipse(x[j], y[j], e, e);	
					ellipse(y[j], x[j], e, e);	
					ellipse(x[j], height - y[j], e, e);	
					ellipse(height - y[j], x[j], e, e);	
					ellipse(height - y[j], width - x[j], e, e);	
					ellipse(height - x[j], width - y[j], e, e);	
				}
			}

			iter += 1;
		}
	}
	
	xmotion += 1;
	ymotion += 1;
}"
"932557","Demilich","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];

let ifs = 8;

function setup() {
  createCanvas(windowHeight, windowHeight);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (1.0925), y: abs(width / (32) - x + y / (1.45 * j * ((0.5 - y / width) * 10))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 1 * x) / 1 + j * 100, y: (height - y * 4.15 / j + (x / 1.75)) / 1.75 + j * (10) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.25 * j / y - x * j) / (1.065 * j + x / (width / 1.8)), y: y / 1.45 };
}

var f = [f1, f2, f3];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 1; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;

				stroke(360 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 255 * pow((j / ifs), 2), 192, 0.125 * (j / ifs));

				let e = 0.75;

				if (iter > 20) {
					point(width - x[j] / 1.5, height / 4 - y[j]/2.75);
					point(x[j] / 1.5 , height / 4 - y[j]/2.75);
					point(width - x[j] / 2, height / 4 + y[j] / 2);
					point(x[j]/ 2, height / 4 + y[j] / 2);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.05);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"932557","Demilich","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];

let ifs = 8;

function setup() {
  createCanvas(windowHeight, windowHeight);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (1.0925), y: abs(width / (32) - x + y / (1.45 * j * ((0.5 - y / width) * 10))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 1 * x) / 1 + j * 120, y: (height - y * 4.15 / j + (x / 1.75)) / 1.75 + j * (10) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.25 * j / y - x * j) / (1.065 * j + x / (width / 1.8)), y: y / 1.45 };
}

var f = [f1, f2, f3];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 1; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;

				stroke(360 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 255 * pow((j / ifs), 2), 192, 0.125 * (j / ifs));

				let e = 0.75;

				if (iter > 20) {
					point(width - x[j] / 1.25, height / 4 - y[j]/2.75);
					point(x[j] / 1.25 , height / 4 - y[j]/2.75);
					point(width - x[j] / 1.8, height / 4 + y[j] / 1.75);
					point(x[j]/ 1.8, height / 4 + y[j] / 1.75);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.05);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"932498","Gê","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];

let ifs = 8;

function setup() {
  createCanvas(windowHeight, windowHeight);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (1.05), y: abs(width / (128) - x + y / (10.075 * j * ((0.5 - y / width) * 10))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 1.0711 * x) / 1 + j * 70, y: (height - y * 4.15 / j + (x / 1.75)) / 1.75 + j * (110 + y / 256) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (1.65 * j + x / (width / 1.8)), y: y / 2 };
}

var f = [f1, f2, f3];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 1; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;

				stroke(32 * (j / ifs) * (i / 1000) + 1000 * (iter / 500000) * (r.x / width * r.y / height), 255 * pow((j / ifs), 2), 192, 0.125 * (j / ifs));

				let e = 0.75;

				if (iter > 20) {
					point(width - x[j], height / 2 - y[j]/1.5);
					point(x[j], height / 2 - y[j]/1.5);
					point(width - x[j], height / 2 + y[j]);
					point(x[j], height / 2 + y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.05);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"932498","Gê","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];

let ifs = 8;

function setup() {
  createCanvas(windowHeight, windowHeight);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (1.05), y: abs(width / (128) - x + y / (10.075 * j * ((0.5 - y / width) * 10))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 1.0711 * x) / 1 + j * 70, y: (height - y * 4.15 / j + (x / 1.75)) / 1.75 + j * (110 + y / 256) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 * j / y - x * j) / (1.65 * j + x / (width / 1.8)), y: y / 2 };
}

var f = [f1, f2, f3];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 1; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;

				stroke(32 * (j / ifs) * (i / 1000) + 1000 * (iter / 500000) * (r.x / width * r.y / height), 255 * pow((j / ifs), 2), 192, 0.125 * (j / ifs));

				let e = 0.75;

				if (iter > 20) {
					point(width - x[j], height / 2 - y[j]/1.5);
					point(x[j], height / 2 - y[j]/1.5);
					point(width - x[j], height / 2 + y[j]);
					point(x[j], height / 2 + y[j]);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.05);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"932488","ifsnout","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];

let ifs = 8;

function setup() {
  createCanvas(windowHeight, windowHeight);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (1.0925), y: abs(width / (512) - x + y / (0.45 * j * ((0.5 - y / width) * 10))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 1.0711 * x) / 1 + j * 70, y: (height - y * 4.15 / j + (x / 1.75)) / 1.75 + j * (100) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.25 * j / y - x * j) / (2.65 * j + x / (width / 1.8)), y: y / 1.45 };
}

var f = [f1, f2, f3];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 1; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;

				stroke(360 - 360 * (j / ifs) * (i / 1000) + 200 * (iter / 500000) * (r.x / width * r.y / height), 255 * pow((j / ifs), 2), 192, 0.125 * (j / ifs));

				let e = 0.75;

				if (iter > 20) {
					point(width - x[j]*0.45, height / 3 - y[j]/1.75);
					point(x[j] *0.45, height / 3 - y[j]/1.75);
					point(width - x[j] / 2, height / 3 + y[j] / 2.5);
					point(x[j]/ 2, height / 3 + y[j] / 2.5);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.05);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"930367","Rainy / Foggy swamp exp","mySketch","// ifs + landscape

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];

let ifs = 4;

function setup() {
  createCanvas(windowWidth, windowHeight);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (1.925), y: abs(width / 1.95 - x + y / (1.75 * ((0.05 + y / width) * 1))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.711 * x) / 1.025 + j * 120, y: (height / 1 - y / 1.15 + (x / 0.75)) / (1.75) };
}

function f3(x, y, j) {
	return { x: abs(width * 1.25 - x * j) / (9.045 + x / (width / 1.8)), y: y / 1.65 };
}

var f = [f1, f2, f3];

var iter = 0;

function draw() {
	//fill(0, 0, 0, 1);
	//rect(0, 0, width, height);
	/*
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 1; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;

				stroke(167 + 64, 0 * (j / ifs), 192, 0.125 * (j / ifs));

				let e = 0.75;

				if (iter > 20) {
					//point(width / 2 + x[j], y[j]);
					point(width - x[j] / 1.5 + width * 0.05, y[j] * j);
					point(x[j]/1.5, height - y[j] - height / 1.95);
					point(width - x[j]/1.5, height - y[j] - height / 1.95);
					point(x[j] / 1.5 - width * 0.05, y[j] * j);
					
					//point(x[j], height / 2 + y[j]);
					//point(x[j], height / 1.3 - y[j]-15);
					//point(width - x[j], height / 1.3 - y[j]-15);
					//point(width / 2 - x[j], height - y[j] + 150);
					//point(width / 2 + x[j], height - y[j] + 150);
					
					//point(x[j] + width / 2, height / 1.3 - y[j] + 200);
					//point(width - x[j] - width / 2, height / 1.3 - y[j] + 200);
					
					//ellipse(width / 1.05 - y[j], height * 0.9 - x[j], e, e);
					//ellipse(width / 1.05 + y[j], height * 0.9 - x[j], e, e);
					//ellipse(y[j] - width * 0.15, height * 0.945 - x[j], e, e);
					//ellipse(y[j] - width * 0.15, height * 0.945 - x[j], e, e);
					//ellipse(x[j], y[j], e, e);	
					//ellipse(width / 2 - y[j], x[j], e, e);	
					//ellipse(width / 2 + y[j], x[j], e, e);	
					//ellipse(x[j], height - y[j], e, e);	
					
					//ellipse(height - y[j], x[j], e, e);	
					//ellipse(height - y[j], width - x[j], e, e);	
					//ellipse(height - x[j], width - y[j], e, e);
				}
			}

			iter += 1;
		}
	}*//* else if (iter == 500000) {
		// compositing
		blendMode(MULTIPLY);
		fill(240, 0, 50, 255);
		rect(width / 6, height / 1.75, width / 2.6, height / 1.2);
	  rect(width - width / 6, height / 1.75, width / 2.6, height / 1.2);
	  rect(width / 2, height / 1.31, width / 3.55, height / 1.25);
		
		blendMode(BLEND);
		fill(0, 60, 100, 255);
		//stroke(0, 0, 100, 255);
		ellipse(width / 2 - 42, 72, 20, 16);
	  ellipse(width / 2 + 42, 72, 20, 16);
	
		iter += 1;
	}*/

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 170 + pow(ny, 1) * 68, 1);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	
	for (y = 0; y < height/1.2; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.05);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
	
	//fill(0, 0, 0, 1);
	//rect(width / 2, height / 2 - height / 2.5 / 2 + 40, width / 10, height / 2.5);
	
	let wl = 255 * (height / 976);
	let m = 0; // get max y
	for (y = 0; y < (height - m); y += 1) {
		let ny = y / height;
		let noy = noise(ny);
		
		for (x = 0; x < width; x += 1) {
			let yy = (height / 2.25) + y + m;
			
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let ss = 1-exp(-pow(nx - 0.5 + cos(PI * 1.5 + (ny) * PI * 10)/2, 2)*7 + 0.15);
			let nox2 = (0.5 - noise(nx, ny)) * 2;
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 0.5 + ny * PI * 1 + nox * PI * 2.15)) / 2 * nox2;
			let ss2 = ss * abs(sin(nx-0.5  * PI * 2));
			
			
			if (random() > 0.05) {
				
				let xx = x + random(-2, 2);
				let yh2 = random(-200, 200) * n * (ny * 1.5) * ss;
				noStroke();
				
				if (random() > 0.995 && n > 0.05 && ss > 0.4) {
					fill(64, 64, 48, random(0.5,1));
					rect(xx, yy - yh2, random(2, 8) * ny, 8 + 40 * ny);
				}
				
				stroke(80 + 0 + (nox2) * 16 + 40 * (1-ss), 90 * nox3 * ss + 20 * (1-ss), (255*nox3-random(200) * n)*ss+100*(1-ss), random() * 0.45 * pow(ny, 0.01));
				line(xx, yy, xx + random(-200, 200) * n * noy * ny * (ss) + random(-40, 40) * n * ny * (1-ss), yy + yh2);
			}
		}
	}
	
	for (y = 0; y < height; y += 16) {
		let ny = y / height;
		let noy = noise(ny);
		for (x = 0; x < width; x += 3) {
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = noise(nx, ny);
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2 * nox2;

			let yy = height / 8 + y - n * (height / 3) * (1 - ny);

			if (random() > 0.999) {
				stroke(0, 0, 0, 1);
				strokeWeight(0.5);
				let tx = x + random(1, 6);
				let ty = yy + random(1, 6);
				line(x, yy, tx, ty);
				line(tx, ty, tx + random(1, 6) * (1-ny), ty - random(1, 4) * (1-ny));
			}
		}
	}
}"
"930359","Scrubs","mySketch","// ifs + landscape

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];

let ifs = 4;

function setup() {
  createCanvas(900, windowHeight);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
	}
	
	background(0, 0, 0, 1);
	
	//generate();
}

function f1(x, y, j) {
	return { x: y / (2.45), y: abs(width / 4.95 + x - y / (20.75 * ((0.05 + y / width) * 1))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 0.711 + x) / 1.625 + j * 100, y: (height / 1.05 - y / 2.15 + (x / 1.75)) / (1.75) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 - x + j * 100) / (2.045 + x / (width / 1.8)), y: y / 1.25 };
}

var f = [f1, f2, f3];

var iter = 0;

function draw() {
	//fill(0, 0, 0, 1);
	//rect(0, 0, width, height);
	
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 1; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;

				let nj = j / ifs;
				if (nj > 0.25) {
					stroke(noise(r.x, r.y) * (j / ifs) * 100, 40 * nj, 255, 0.075 * (1 - nj));
				} else {
					stroke(random(0, 50) + 200 * (nj * noise(r.x, r.y)), 255 * (1-nj), 255, 0.115 * nj);
				}

				let e = 0.75;

				if (iter > 20) {
					//point(width / 2 + x[j], y[j]);
					
					//point(width - x[j] / 1.45 + width * 0.05, y[j] * j);
					point(width - x[j] / 1 - 16 + width * 0.05, height - y[j] * j);
					//point(width - x[j] / 1.5 - 180 + width * 0.05, y[j] * j);
					point(width - x[j] / 0.5 - width / 3.025 + width * 0.05, y[j] * j);
					//point(width - x[j]/1.5, height - y[j] - height / 1.95);
					//point(x[j]/1.5, height - y[j] - height / 1.95);
					//point(x[j] / 1.45 - width * 0.05, y[j] * j);
					point(x[j] / 1 - width * 0.05 + 16, height - y[j] * j);
					//point(x[j] / 1.5 - width * 0.05 + 180, y[j] * j);
					point(x[j] / 0.5 - width * 0.05 + width / 3.025, y[j] * j);
					//point(x[j], height / 2 + y[j]);
					//point(x[j], height / 1.3 - y[j]-15);
					//point(width - x[j], height / 1.3 - y[j]-15);
					//point(width / 2 - x[j], height - y[j] + 150);
					//point(width / 2 + x[j], height - y[j] + 150);
					
					//point(x[j] + width / 2, height / 1.3 - y[j] + 200);
					//point(width - x[j] - width / 2, height / 1.3 - y[j] + 200);
					
					//ellipse(width / 1.05 - y[j], height * 0.9 - x[j], e, e);
					//ellipse(width / 1.05 + y[j], height * 0.9 - x[j], e, e);
					//ellipse(y[j] - width * 0.15, height * 0.945 - x[j], e, e);
					//ellipse(y[j] - width * 0.15, height * 0.945 - x[j], e, e);
					//ellipse(x[j], y[j], e, e);	
					//ellipse(width / 2 - y[j], x[j], e, e);	
					//ellipse(width / 2 + y[j], x[j], e, e);	
					//ellipse(x[j], height - y[j], e, e);	
					
					//ellipse(height - y[j], x[j], e, e);	
					//ellipse(height - y[j], width - x[j], e, e);	
					//ellipse(height - x[j], width - y[j], e, e);
				}
			}

			iter += 1;
		}
	}/* else if (iter == 500000) {
		// compositing
		blendMode(MULTIPLY);
		fill(240, 0, 50, 255);
		rect(width / 6, height / 1.75, width / 2.6, height / 1.2);
	  rect(width - width / 6, height / 1.75, width / 2.6, height / 1.2);
	  rect(width / 2, height / 1.31, width / 3.55, height / 1.25);
		
		blendMode(BLEND);
		fill(0, 60, 100, 255);
		//stroke(0, 0, 100, 255);
		ellipse(width / 2 - 42, 72, 20, 16);
	  ellipse(width / 2 + 42, 72, 20, 16);
	
		iter += 1;
	}*/

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	fill(220, 64, 255, 1);
	rect(width / 2, height / 2, width, height);
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;
/*
	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
*/
	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(0, 0, 220 + pow(ny, 1) * 35, 0.025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	/*
	for (y = 0; y < height/1.2; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.05);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
	*/
	//fill(0, 0, 0, 1);
	//rect(width / 2, height / 2 - height / 2.5 / 2 + 40, width / 10, height / 2.5);
	
	let wl = 255 * (height / 976);
	let m = 0; // get max y
	for (y = 0; y < (height - m); y += 1) {
		let ny = y / height;
		let noy = noise(ny);
		
		for (x = 0; x < width; x += 1) {
			let yy = (height / 1.95) + y + m;
			
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let ss = 1 - exp(-pow(nx - 0.5 + cos(PI * 1.5 + (ny + nox / 3) * PI * 8)/2, 2.25)*7 + 0.15);
			let nox2 = (0.5 - noise(nx, ny)) * 2;
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 0.5 + ny * PI * 1 + nox * PI * 2.15)) / 2 * nox2;
			let ss2 = ss * abs(sin(nx-0.5  * PI * 2));
			
			
			if (random() > 0.05) {
				
				let xx = x + random(-2, 2);
				let yh2 = random(-200, 200) * n * (ny * 1.5) * ss;
				noStroke();
				
				if (random() > 0.995 && n > 0.05 && ss > 0.6) {
					fill(64, 64, 48, random(0.5,1));
					rect(xx, yy - yh2, random(2, 8) * ny, 8 + 40 * ny);
				}
				
				stroke(80 + 0 + (nox2) * 16 + 40 * (1-ss), 90 * nox3 * ss + 20 * (1-ss), (255*nox3-random(200) * n)*ss+100*(1-ss), random() * 0.45 * pow(ny, 0.01));
				line(xx, yy, xx + random(-200, 200) * n * noy * ny * (ss) + random(-40, 40) * n * ny * (1-ss), yy + yh2);
			}
		}
	}
	
	for (y = 0; y < height; y += 16) {
		let ny = y / height;
		let noy = noise(ny);
		for (x = 0; x < width; x += 3) {
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = noise(nx, ny);
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2 * nox2;

			let yy = height / 8 + y - n * (height / 3) * (1 - ny);

			if (random() > 0.999) {
				stroke(0, 0, 0, 1);
				strokeWeight(0.5);
				let tx = x + random(1, 6);
				let ty = yy + random(1, 6);
				line(x, yy, tx, ty);
				line(tx, ty, tx + random(1, 6) * (1-ny), ty - random(1, 4) * (1-ny));
			}
		}
	}
}"
"930359","Scrubs","mySketch","// ifs + landscape

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];

let ifs = 4;

function setup() {
  createCanvas(900, 1000);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
	}
	
	background(0, 0, 0, 1);
	
	//generate();
}

function f1(x, y, j) {
	return { x: y / (2.45), y: abs(width / 4.95 + x - y / (20.75 * ((0.05 + y / width) * 1))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 0.711 + x) / 1.625 + j * 100, y: (height / 1.05 - y / 2.15 + (x / 1.75)) / (1.75) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 - x + j * 100) / (2.045 + x / (width / 1.8)), y: y / 1.25 };
}

var f = [f1, f2, f3];

var iter = 0;

function draw() {
	//fill(0, 0, 0, 1);
	//rect(0, 0, width, height);
	
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 1; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;

				let nj = j / ifs;
				if (nj > 0.25) {
					stroke(noise(r.x, r.y) * (j / ifs) * 100, 40 * nj, 255, 0.075 * (1 - nj));
				} else {
					stroke(random(0, 50) + 200 * (nj * noise(r.x, r.y)), 255 * (1-nj), 255, 0.115 * nj);
				}

				let e = 0.75;

				if (iter > 20) {
					//point(width / 2 + x[j], y[j]);
					
					//point(width - x[j] / 1.45 + width * 0.05, y[j] * j);
					point(width - x[j] / 1 - 16 + width * 0.05, height - y[j] * j);
					//point(width - x[j] / 1.5 - 180 + width * 0.05, y[j] * j);
					point(width - x[j] / 0.5 - width / 3.025 + width * 0.05, y[j] * j);
					//point(width - x[j]/1.5, height - y[j] - height / 1.95);
					//point(x[j]/1.5, height - y[j] - height / 1.95);
					//point(x[j] / 1.45 - width * 0.05, y[j] * j);
					point(x[j] / 1 - width * 0.05 + 16, height - y[j] * j);
					//point(x[j] / 1.5 - width * 0.05 + 180, y[j] * j);
					point(x[j] / 0.5 - width * 0.05 + width / 3.025, y[j] * j);
					//point(x[j], height / 2 + y[j]);
					//point(x[j], height / 1.3 - y[j]-15);
					//point(width - x[j], height / 1.3 - y[j]-15);
					//point(width / 2 - x[j], height - y[j] + 150);
					//point(width / 2 + x[j], height - y[j] + 150);
					
					//point(x[j] + width / 2, height / 1.3 - y[j] + 200);
					//point(width - x[j] - width / 2, height / 1.3 - y[j] + 200);
					
					//ellipse(width / 1.05 - y[j], height * 0.9 - x[j], e, e);
					//ellipse(width / 1.05 + y[j], height * 0.9 - x[j], e, e);
					//ellipse(y[j] - width * 0.15, height * 0.945 - x[j], e, e);
					//ellipse(y[j] - width * 0.15, height * 0.945 - x[j], e, e);
					//ellipse(x[j], y[j], e, e);	
					//ellipse(width / 2 - y[j], x[j], e, e);	
					//ellipse(width / 2 + y[j], x[j], e, e);	
					//ellipse(x[j], height - y[j], e, e);	
					
					//ellipse(height - y[j], x[j], e, e);	
					//ellipse(height - y[j], width - x[j], e, e);	
					//ellipse(height - x[j], width - y[j], e, e);
				}
			}

			iter += 1;
		}
	}/* else if (iter == 500000) {
		// compositing
		blendMode(MULTIPLY);
		fill(240, 0, 50, 255);
		rect(width / 6, height / 1.75, width / 2.6, height / 1.2);
	  rect(width - width / 6, height / 1.75, width / 2.6, height / 1.2);
	  rect(width / 2, height / 1.31, width / 3.55, height / 1.25);
		
		blendMode(BLEND);
		fill(0, 60, 100, 255);
		//stroke(0, 0, 100, 255);
		ellipse(width / 2 - 42, 72, 20, 16);
	  ellipse(width / 2 + 42, 72, 20, 16);
	
		iter += 1;
	}*/

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	fill(220, 64, 255, 1);
	rect(width / 2, height / 2, width, height);
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;
/*
	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
*/
	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(0, 0, 220 + pow(ny, 1) * 35, 0.025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	/*
	for (y = 0; y < height/1.2; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.05);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
	*/
	//fill(0, 0, 0, 1);
	//rect(width / 2, height / 2 - height / 2.5 / 2 + 40, width / 10, height / 2.5);
	
	let wl = 255 * (height / 976);
	let m = 0; // get max y
	for (y = 0; y < (height - m); y += 1) {
		let ny = y / height;
		let noy = noise(ny);
		
		for (x = 0; x < width; x += 1) {
			let yy = (height / 1.95) + y + m;
			
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let ss = 1 - exp(-pow(nx - 0.5 + cos(PI * 1.5 + (ny + nox / 3) * PI * 8)/2, 2.25)*7 + 0.15);
			let nox2 = (0.5 - noise(nx, ny)) * 2;
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 0.5 + ny * PI * 1 + nox * PI * 2.15)) / 2 * nox2;
			let ss2 = ss * abs(sin(nx-0.5  * PI * 2));
			
			
			if (random() > 0.05) {
				
				let xx = x + random(-2, 2);
				let yh2 = random(-200, 200) * n * (ny * 1.5) * ss;
				noStroke();
				
				if (random() > 0.995 && n > 0.05 && ss > 0.6) {
					fill(64, 64, 48, random(0.5,1));
					rect(xx, yy - yh2, random(2, 8) * ny, 8 + 40 * ny);
				}
				
				stroke(80 + 0 + (nox2) * 16 + 40 * (1-ss), 90 * nox3 * ss + 20 * (1-ss), (255*nox3-random(200) * n)*ss+100*(1-ss), random() * 0.45 * pow(ny, 0.01));
				line(xx, yy, xx + random(-200, 200) * n * noy * ny * (ss) + random(-40, 40) * n * ny * (1-ss), yy + yh2);
			}
		}
	}
	
	for (y = 0; y < height; y += 16) {
		let ny = y / height;
		let noy = noise(ny);
		for (x = 0; x < width; x += 3) {
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = noise(nx, ny);
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2 * nox2;

			let yy = height / 8 + y - n * (height / 3) * (1 - ny);

			if (random() > 0.999) {
				stroke(0, 0, 0, 1);
				strokeWeight(0.5);
				let tx = x + random(1, 6);
				let ty = yy + random(1, 6);
				line(x, yy, tx, ty);
				line(tx, ty, tx + random(1, 6) * (1-ny), ty - random(1, 4) * (1-ny));
			}
		}
	}
}"
"927082","Krystal","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];

let ifs = 10;

function setup() {
  createCanvas(windowHeight, windowHeight);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (1.0925), y: abs(width / 40.985 - x + y / (4.075 * j * ((0.5 + y / width) * 1))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 8.0711 * x) / 32.025 + j * 10 + abs(sin(j / ifs * PI * 1)) * y, y: (height * 0.45 - y * 1.15 / j + (x / 1.5)) / (2.75) + j * 20 };
}

function f3(x, y, j) {
	return { x: abs(width * 4.25 * j / (y / 1.5) + x * j) / (4.045 * j + x / (width / 0.5)), y: y + abs(sin(j / ifs * PI * 2)) * x };
}

var f = [f1, f2, f3];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 1; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;

				stroke(224, 16 + 128 * (1 - j / ifs), 192, 0.125 * (j / ifs));

				let e = 0.75;

				if (iter > 20) {
					//point(width / 2 + x[j], y[j]);
					//point(width - x[j] + width * 0.05, y[j] * j);
					point(x[j], height - y[j]);
					point(width - x[j] - 4, height - y[j]);
					//point(width - x[j], height - y[j]);
					//point(x[j] - width * 0.05, y[j] * j);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}/*
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.05);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}*/
}"
"927063","Kal 2","mySketch","let e = [];
let max = 256;
let max_l = 4;
let max_r = 4;

function setup() {
	createCanvas(windowWidth, windowHeight);
	background(0);
	
	colorMode(HSL, 360, 255, 255, 255);
	
	for (let j = 0; j < max; j += 1) {
		e[j] = { x: 0, y: 0, r: j / max * PI * 64, rv: random(-1, 1) };
	}
}

let xm = 0;

function draw() {
	//background(0);
	
	noStroke();
	fill(0, 0, 255, 16 * abs(cos(xm / 8 + PI)));
	rect(0, 0, width, height);
	
	noFill();

	for (let j = 0; j < max / 2; j += 1) {
		let nj = j / max;
		
		let o = e[j];
		
		let b = 255 - pow((1 - nj) * 1.025, 32) * 255;
		stroke(abs(sin(nj * PI * 2+ xm / 8)) * 360, 128, b, 255 * abs(sin(nj * PI * 2 + xm)));
		
		strokeWeight(16 * (1 - nj));
		
		push();
		translate(width / 2 + sin(nj*2 + o.r + xm) * 32, height / 2 + cos(nj*2 + o.r + xm) * 32);
		rotate(o.r);
		translate(-width / 2, -height / 2);
		scale(pow(nj * 12, 1.75));
		
		for (let l = 0; l <= max_l; l += 1) {
			let ln = l / max_l;
			line(o.x - width * 16, o.y + ln * height * 16, o.x + width * 16, o.y + ln * height * 16);
		}
		
		for (let r = 0; r <= max_r; r += 1) {
			let lr = r / max_r;
			line(o.x + lr * width * 16, o.y - height * 16, o.x + lr * width * 16, o.y + height * 8);
		}
		pop();
		
		//o.r += o.rv / 128;
	}
	
	xm += 0.025;
}"
"927057","Kal","mySketch","let e = [];
let max = 256;
let max_l = 16;
let max_r = 16;

function setup() {
	createCanvas(windowWidth, windowHeight);
	background(0);
	
	for (let j = 0; j < max; j += 1) {
		e[j] = { x: 0, y: 0, r: j / max * PI * 64, rv: random(-1, 1) };
	}
}

let xm = 0;

function draw() {
	//background(0);
	
	noStroke();
	fill(255, 255, 255, 1);
	rect(0, 0, width, height);
	
	noFill();

	for (let j = 0; j < max / 2; j += 1) {
		let nj = j / max;
		
		let o = e[j];
		
		let b = pow((1 - nj) * 1.05, 8) * 255;
		stroke(b, b, b, 255 * abs(sin(nj * PI * 8 + xm)));
		
		strokeWeight(16 * (1 - nj));
		
		push();
		translate(width / 2 + sin(nj*2 + o.r + xm) * 32, height / 2 + cos(nj*2 + o.r + xm) * 32);
		rotate(o.r);
		translate(-width / 2, -height / 2);
		scale(pow(nj * 8, 1.75));
		
		for (let l = 0; l <= max_l; l += 1) {
			let ln = l / max_l;
			line(o.x - width * 16, o.y + ln * height * 16, o.x + width * 16, o.y + ln * height * 16);
		}
		
		for (let r = 0; r <= max_r; r += 1) {
			let lr = r / max_r;
			line(o.x + lr * width * 16, o.y - height * 16, o.x + lr * width * 16, o.y + height * 8);
		}
		pop();
		
		//o.r += o.rv / 128;
	}
	
	xm += 0.025;
}"
"927057","Kal","mySketch","let e = [];
let max = 256;
let max_l = 16;
let max_r = 16;

function setup() {
	createCanvas(windowWidth, windowHeight);
	background(0);
	
	colorMode(HSL, 360, 255, 255, 255);
	
	for (let j = 0; j < max; j += 1) {
		e[j] = { x: 0, y: 0, r: j / max * PI * 64, rv: random(-1, 1) };
	}
}

let xm = 0;

function draw() {
	//background(0);
	
	noStroke();
	fill(0, 0, 255, 1);
	rect(0, 0, width, height);
	
	noFill();

	for (let j = 0; j < max / 2; j += 1) {
		let nj = j / max;
		
		let o = e[j];
		
		let b = pow((1 - nj) * 1.05, 8) * 255;
		stroke(abs(sin(nj * PI * 2 + xm / 8)) * 360, 128, b, 255 * abs(sin(nj * PI * 8 + xm)));
		
		strokeWeight(16 * (1 - nj));
		
		push();
		translate(width / 2 + sin(nj*2 + o.r + xm) * 32, height / 2 + cos(nj*2 + o.r + xm) * 32);
		rotate(o.r);
		translate(-width / 2, -height / 2);
		scale(pow(nj * 8, 1.75));
		
		for (let l = 0; l <= max_l; l += 1) {
			let ln = l / max_l;
			line(o.x - width * 16, o.y + ln * height * 16, o.x + width * 16, o.y + ln * height * 16);
		}
		
		for (let r = 0; r <= max_r; r += 1) {
			let lr = r / max_r;
			line(o.x + lr * width * 16, o.y - height * 16, o.x + lr * width * 16, o.y + height * 8);
		}
		pop();
		
		//o.r += o.rv / 128;
	}
	
	xm += 0.025;
}"
"927002","Rainy / Foggy swamp","mySketch","// ifs + landscape

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];

let ifs = 4;

function setup() {
  createCanvas(900 - 1, windowHeight);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (1.925), y: abs(width / 1.95 - x + y / (1.75 * ((0.05 + y / width) * 1))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.711 * x) / 1.025 + j * 120, y: (height / 1 - y / 1.15 + (x / 0.75)) / (1.75) };
}

function f3(x, y, j) {
	return { x: abs(width * 1.25 - x * j) / (9.045 + x / (width / 1.8)), y: y / 1.65 };
}

var f = [f1, f2, f3];

var iter = 0;

function draw() {
	//fill(0, 0, 0, 1);
	//rect(0, 0, width, height);
	/*
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 1; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;

				stroke(167 + 64, 0 * (j / ifs), 192, 0.125 * (j / ifs));

				let e = 0.75;

				if (iter > 20) {
					//point(width / 2 + x[j], y[j]);
					point(width - x[j] / 1.5 + width * 0.05, y[j] * j);
					point(x[j]/1.5, height - y[j] - height / 1.95);
					point(width - x[j]/1.5, height - y[j] - height / 1.95);
					point(x[j] / 1.5 - width * 0.05, y[j] * j);
					
					//point(x[j], height / 2 + y[j]);
					//point(x[j], height / 1.3 - y[j]-15);
					//point(width - x[j], height / 1.3 - y[j]-15);
					//point(width / 2 - x[j], height - y[j] + 150);
					//point(width / 2 + x[j], height - y[j] + 150);
					
					//point(x[j] + width / 2, height / 1.3 - y[j] + 200);
					//point(width - x[j] - width / 2, height / 1.3 - y[j] + 200);
					
					//ellipse(width / 1.05 - y[j], height * 0.9 - x[j], e, e);
					//ellipse(width / 1.05 + y[j], height * 0.9 - x[j], e, e);
					//ellipse(y[j] - width * 0.15, height * 0.945 - x[j], e, e);
					//ellipse(y[j] - width * 0.15, height * 0.945 - x[j], e, e);
					//ellipse(x[j], y[j], e, e);	
					//ellipse(width / 2 - y[j], x[j], e, e);	
					//ellipse(width / 2 + y[j], x[j], e, e);	
					//ellipse(x[j], height - y[j], e, e);	
					
					//ellipse(height - y[j], x[j], e, e);	
					//ellipse(height - y[j], width - x[j], e, e);	
					//ellipse(height - x[j], width - y[j], e, e);
				}
			}

			iter += 1;
		}
	}*//* else if (iter == 500000) {
		// compositing
		blendMode(MULTIPLY);
		fill(240, 0, 50, 255);
		rect(width / 6, height / 1.75, width / 2.6, height / 1.2);
	  rect(width - width / 6, height / 1.75, width / 2.6, height / 1.2);
	  rect(width / 2, height / 1.31, width / 3.55, height / 1.25);
		
		blendMode(BLEND);
		fill(0, 60, 100, 255);
		//stroke(0, 0, 100, 255);
		ellipse(width / 2 - 42, 72, 20, 16);
	  ellipse(width / 2 + 42, 72, 20, 16);
	
		iter += 1;
	}*/

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 170 + pow(ny, 1) * 68, 1);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	
	for (y = 0; y < height/1.2; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.05);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
	
	//fill(0, 0, 0, 1);
	//rect(width / 2, height / 2 - height / 2.5 / 2 + 40, width / 10, height / 2.5);
	
	let wl = 255 * (height / 976);
	let m = 0; // get max y
	for (y = 0; y < (height - m); y += 1) {
		let ny = y / height;
		let noy = noise(ny);
		
		for (x = 0; x < width; x += 1) {
			let yy = (height / 2.5) + y + m;
			
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let ss = 1-exp(-pow(nx - 0.5 + cos(PI * 1.5 + (-ny) * PI * 1)/2, 2)*7);
			let nox2 = (0.5 - noise(nx, ny)) * 2;
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 0.5 + ny * PI * 1 + nox * PI * 2.15)) / 2 * nox2;
			let ss2 = ss * abs(sin(nx-0.5  * PI * 2));
			
			
			if (random() > 0.05) {
				
				let xx = x + random(-2, 2);
				let yh2 = random(-200, 200) * n * (ny * 1.5) * ss;
				noStroke();
				
				if (random() > 0.995 && n > 0.05 && ss > 0.4) {
					fill(64, 64, 48, random(0.5,1));
					rect(xx, yy - yh2, random(2, 8) * ny, 8 + 40 * ny);
				}
				
				stroke(80 + 0 + (nox2) * 16 + 40 * (1-ss), 90 * nox3 * ss + 20 * (1-ss), (255*nox3-random(200) * n)*ss+100*(1-ss), random() * 0.45 * pow(ny, 0.01));
				line(xx, yy, xx + random(-200, 200) * n * noy * ny * (ss) + random(-40, 40) * n * ny * (1-ss), yy + yh2);
			}
		}
	}
}"
"927002","Rainy / Foggy swamp","mySketch","// ifs + landscape

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];

let ifs = 4;

function setup() {
  createCanvas(900, windowHeight);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (1.925), y: abs(width / 1.95 - x + y / (1.75 * ((0.05 + y / width) * 1))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.711 * x) / 1.025 + j * 120, y: (height / 1 - y / 1.15 + (x / 0.75)) / (1.75) };
}

function f3(x, y, j) {
	return { x: abs(width * 1.25 - x * j) / (9.045 + x / (width / 1.8)), y: y / 1.65 };
}

var f = [f1, f2, f3];

var iter = 0;

function draw() {
	//fill(0, 0, 0, 1);
	//rect(0, 0, width, height);
	/*
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 1; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;

				stroke(167 + 64, 0 * (j / ifs), 192, 0.125 * (j / ifs));

				let e = 0.75;

				if (iter > 20) {
					//point(width / 2 + x[j], y[j]);
					point(width - x[j] / 1.5 + width * 0.05, y[j] * j);
					point(x[j]/1.5, height - y[j] - height / 1.95);
					point(width - x[j]/1.5, height - y[j] - height / 1.95);
					point(x[j] / 1.5 - width * 0.05, y[j] * j);
					
					//point(x[j], height / 2 + y[j]);
					//point(x[j], height / 1.3 - y[j]-15);
					//point(width - x[j], height / 1.3 - y[j]-15);
					//point(width / 2 - x[j], height - y[j] + 150);
					//point(width / 2 + x[j], height - y[j] + 150);
					
					//point(x[j] + width / 2, height / 1.3 - y[j] + 200);
					//point(width - x[j] - width / 2, height / 1.3 - y[j] + 200);
					
					//ellipse(width / 1.05 - y[j], height * 0.9 - x[j], e, e);
					//ellipse(width / 1.05 + y[j], height * 0.9 - x[j], e, e);
					//ellipse(y[j] - width * 0.15, height * 0.945 - x[j], e, e);
					//ellipse(y[j] - width * 0.15, height * 0.945 - x[j], e, e);
					//ellipse(x[j], y[j], e, e);	
					//ellipse(width / 2 - y[j], x[j], e, e);	
					//ellipse(width / 2 + y[j], x[j], e, e);	
					//ellipse(x[j], height - y[j], e, e);	
					
					//ellipse(height - y[j], x[j], e, e);	
					//ellipse(height - y[j], width - x[j], e, e);	
					//ellipse(height - x[j], width - y[j], e, e);
				}
			}

			iter += 1;
		}
	}*//* else if (iter == 500000) {
		// compositing
		blendMode(MULTIPLY);
		fill(240, 0, 50, 255);
		rect(width / 6, height / 1.75, width / 2.6, height / 1.2);
	  rect(width - width / 6, height / 1.75, width / 2.6, height / 1.2);
	  rect(width / 2, height / 1.31, width / 3.55, height / 1.25);
		
		blendMode(BLEND);
		fill(0, 60, 100, 255);
		//stroke(0, 0, 100, 255);
		ellipse(width / 2 - 42, 72, 20, 16);
	  ellipse(width / 2 + 42, 72, 20, 16);
	
		iter += 1;
	}*/

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 170 + pow(ny, 1) * 68, 1);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	
	for (y = 0; y < height/1.2; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.05);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
	
	//fill(0, 0, 0, 1);
	//rect(width / 2, height / 2 - height / 2.5 / 2 + 40, width / 10, height / 2.5);
	
	let wl = 255 * (height / 976);
	let m = 0; // get max y
	for (y = 0; y < (height - m); y += 1) {
		let ny = y / height;
		let noy = noise(ny);
		
		for (x = 0; x < width; x += 1) {
			let yy = (height / 2.25) + y + m;
			
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let ss = 1-exp(-pow(nx - 0.5 + cos(PI * 1.5 + (ny) * PI * 10)/2, 2)*7 + 0.15);
			let nox2 = (0.5 - noise(nx, ny)) * 2;
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 0.5 + ny * PI * 1 + nox * PI * 2.15)) / 2 * nox2;
			let ss2 = ss * abs(sin(nx-0.5  * PI * 2));
			
			
			if (random() > 0.05) {
				
				let xx = x + random(-2, 2);
				let yh2 = random(-200, 200) * n * (ny * 1.5) * ss;
				noStroke();
				
				if (random() > 0.995 && n > 0.05 && ss > 0.4) {
					fill(64, 64, 48, random(0.5,1));
					rect(xx, yy - yh2, random(2, 8) * ny, 8 + 40 * ny);
				}
				
				stroke(80 + 0 + (nox2) * 16 + 40 * (1-ss), 90 * nox3 * ss + 20 * (1-ss), (255*nox3-random(200) * n)*ss+100*(1-ss), random() * 0.45 * pow(ny, 0.01));
				line(xx, yy, xx + random(-200, 200) * n * noy * ny * (ss) + random(-40, 40) * n * ny * (1-ss), yy + yh2);
			}
		}
	}
	
	for (y = 0; y < height; y += 16) {
		let ny = y / height;
		let noy = noise(ny);
		for (x = 0; x < width; x += 3) {
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = noise(nx, ny);
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2 * nox2;

			let yy = height / 8 + y - n * (height / 3) * (1 - ny);

			if (random() > 0.999) {
				stroke(0, 0, 0, 1);
				strokeWeight(0.5);
				let tx = x + random(1, 6);
				let ty = yy + random(1, 6);
				line(x, yy, tx, ty);
				line(tx, ty, tx + random(1, 6) * (1-ny), ty - random(1, 4) * (1-ny));
			}
		}
	}
}"
"927002","Rainy / Foggy swamp","mySketch","// landscape
function setup() {
  createCanvas(900, windowHeight);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);

	generate();
}

function draw() {

}

function generate() {
	noStroke();
	
	fill(220, 64, 255, 1);
	rect(width / 2, height / 2, width, height);
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;
/*
	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
*/
	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(0, 0, 220 + pow(ny, 1) * 35, 0.025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	/*
	for (y = 0; y < height/1.2; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.05);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
	*/
	//fill(0, 0, 0, 1);
	//rect(width / 2, height / 2 - height / 2.5 / 2 + 40, width / 10, height / 2.5);
	
	let wl = 255 * (height / 976);
	let m = 0; // get max y
	for (y = 0; y < (height - m); y += 1) {
		let ny = y / height;
		let noy = noise(ny);
		
		for (x = 0; x < width; x += 1) {
			let yy = (height / 1.95) + y + m;
			
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let ss = 1 - exp(-pow(nx - 0.5 + cos(PI * 1.5 + (ny + nox / 3) * PI * 8)/2, 2.25)*7 + 0.15);
			let nox2 = (0.5 - noise(nx, ny)) * 2;
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 0.5 + ny * PI * 1 + nox * PI * 2.15)) / 2 * nox2;
			let ss2 = ss * abs(sin(nx-0.5  * PI * 2));
			
			
			if (random() > 0.05) {
				
				let xx = x + random(-2, 2);
				let yh2 = random(-200, 200) * n * (ny * 1.5) * ss;
				noStroke();
				
				if (random() > 0.995 && n > 0.05 && ss > 0.6) {
					fill(64, 64, 48, random(0.5,1));
					rect(xx, yy - yh2, random(2, 8) * ny, 8 + 40 * ny);
				}
				
				stroke(80 + 0 + (nox2) * 16 + 40 * (1-ss), 90 * nox3 * ss + 20 * (1-ss), (255*nox3-random(200) * n)*ss+100*(1-ss), random() * 0.45 * pow(ny, 0.01));
				line(xx, yy, xx + random(-200, 200) * n * noy * ny * (ss) + random(-40, 40) * n * ny * (1-ss), yy + yh2);
			}
		}
	}
	
	for (y = 0; y < height; y += 16) {
		let ny = y / height;
		let noy = noise(ny);
		for (x = 0; x < width; x += 3) {
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = noise(nx, ny);
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2 * nox2;

			let yy = height / 8 + y - n * (height / 3) * (1 - ny);

			if (random() > 0.999) {
				stroke(0, 0, 0, 1);
				strokeWeight(0.5);
				let tx = x + random(1, 6);
				let ty = yy + random(1, 6);
				line(x, yy, tx, ty);
				line(tx, ty, tx + random(1, 6) * (1-ny), ty - random(1, 4) * (1-ny));
			}
		}
	}
}"
"927002","Rainy / Foggy swamp","mySketch","// landscape
function setup() {
  createCanvas(900, windowHeight);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);

	generate();
}

function draw() {

}

function generate() {
	noStroke();
	
	fill(220, 64, 255, 1);
	rect(width / 2, height / 2, width, height);
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;
/*
	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
*/
	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(0, 0, 220 + pow(ny, 1) * 35, 0.025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	/*
	for (y = 0; y < height/1.2; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.05);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
	*/
	//fill(0, 0, 0, 1);
	//rect(width / 2, height / 2 - height / 2.5 / 2 + 40, width / 10, height / 2.5);
	
	let wl = 255 * (height / 976);
	let m = 0; // get max y
	for (y = 0; y < (height - m); y += 1) {
		let ny = y / height;
		let noy = noise(ny);
		
		for (x = 0; x < width; x += 1) {
			let yy = (height / 1.95) + y + m;
			
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let ss = 1 - exp(-pow(nx - 0.5 + cos(PI * 1.5 + (ny + nox / 3) * PI * 8)/2, 2.25)*7 + 0.15);
			let nox2 = (0.5 - noise(nx, ny)) * 2;
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 0.5 + ny * PI * 1 + nox * PI * 2.15)) / 2 * nox2;
			let ss2 = ss * abs(sin(nx-0.5  * PI * 2));
			
			
			if (random() > 0.05) {
				
				let xx = x + random(-2, 2);
				let yh2 = random(-200, 200) * n * (ny * 1.5) * ss;
				noStroke();
				
				if (random() > 0.995 && n > 0.05 && ss > 0.6) {
					fill(64, 64, 48, random(0.5,1));
					rect(xx, yy - yh2, random(2, 8) * ny, 8 + 40 * ny);
				}
				
				stroke(80 + 0 + (nox2) * 16 + 40 * (1-ss), 90 * nox3 * ss + 20 * (1-ss), (255*nox3-random(200) * n)*ss+100*(1-ss), random() * 0.45 * pow(ny, 0.01));
				line(xx, yy, xx + random(-200, 200) * n * noy * ny * (ss) + random(-40, 40) * n * ny * (1-ss), yy + yh2);
			}
		}
	}
	
	for (y = 0; y < height; y += 16) {
		let ny = y / height;
		let noy = noise(ny);
		for (x = 0; x < width; x += 3) {
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = noise(nx, ny);
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2 * nox2;

			let yy = height / 8 + y - n * (height / 3) * (1 - ny);

			if (random() > 0.999) {
				stroke(0, 0, 0, 1);
				strokeWeight(0.5);
				let tx = x + random(1, 6);
				let ty = yy + random(1, 6);
				line(x, yy, tx, ty);
				line(tx, ty, tx + random(1, 6) * (1-ny), ty - random(1, 4) * (1-ny));
			}
		}
	}
}"
"926242","Fraktal","mySketch","// ifs

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];

let ifs = 8;

function setup() {
  createCanvas(windowHeight, windowHeight);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (1.0925), y: abs(width / 40.985 - x + y / (4.075 * j * ((0.5 + y / width) * 1))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 8.0711 * x) / 4.025 + j * 10, y: (height * 1.25 - y * 4.15 / j + (x / 1.75)) / (1.75) + j * 10 };
}

function f3(x, y, j) {
	return { x: abs(width * 4.25 * j / y - x * j) / (4.045 * j + x / (width / 1.8)), y: y / 2. };
}

var f = [f1, f2, f3];

var iter = 0;

function draw() {
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 1; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;

				stroke(167 + 64, 0 * (j / ifs), 192, 0.125 * (j / ifs));

				let e = 0.75;

				if (iter > 20) {
					//point(width / 2 + x[j], y[j]);
					//point(width - x[j] + width * 0.05, y[j] * j);
					point(width / 2 - x[j], height - y[j]);
					point(width / 2 + x[j], height - y[j]);
					//point(width - x[j], height - y[j]);
					//point(x[j] - width * 0.05, y[j] * j);
				}
			}

			iter += 1;
		}
	}

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	for (y = 0; y < height; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.05);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
}"
"924596","ifs+plane compo","mySketch","// ifs + landscape

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];

let ifs = 4;

function setup() {
  createCanvas(900 - 1, windowHeight);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
	}
	
	generate();
}

function f1(x, y, j) {
	return { x: y / (1.925), y: abs(width / 1.95 - x + y / (1.75 * ((0.05 + y / width) * 1))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2.711 * x) / 1.025 + j * 120, y: (height / 1 - y / 1.15 + (x / 0.75)) / (1.75) };
}

function f3(x, y, j) {
	return { x: abs(width * 1.25 - x * j) / (9.045 + x / (width / 1.8)), y: y / 1.65 };
}

var f = [f1, f2, f3];

var iter = 0;

function draw() {
	//fill(0, 0, 0, 1);
	//rect(0, 0, width, height);
	
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 1; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;

				stroke(167 + 64, 0 * (j / ifs), 192, 0.125 * (j / ifs));

				let e = 0.75;

				if (iter > 20) {
					//point(width / 2 + x[j], y[j]);
					point(width - x[j] / 1.5 + width * 0.05, y[j] * j);
					point(x[j]/1.5, height - y[j] - height / 1.95);
					point(width - x[j]/1.5, height - y[j] - height / 1.95);
					point(x[j] / 1.5 - width * 0.05, y[j] * j);
					
					//point(x[j], height / 2 + y[j]);
					//point(x[j], height / 1.3 - y[j]-15);
					//point(width - x[j], height / 1.3 - y[j]-15);
					//point(width / 2 - x[j], height - y[j] + 150);
					//point(width / 2 + x[j], height - y[j] + 150);
					
					//point(x[j] + width / 2, height / 1.3 - y[j] + 200);
					//point(width - x[j] - width / 2, height / 1.3 - y[j] + 200);
					
					//ellipse(width / 1.05 - y[j], height * 0.9 - x[j], e, e);
					//ellipse(width / 1.05 + y[j], height * 0.9 - x[j], e, e);
					//ellipse(y[j] - width * 0.15, height * 0.945 - x[j], e, e);
					//ellipse(y[j] - width * 0.15, height * 0.945 - x[j], e, e);
					//ellipse(x[j], y[j], e, e);	
					//ellipse(width / 2 - y[j], x[j], e, e);	
					//ellipse(width / 2 + y[j], x[j], e, e);	
					//ellipse(x[j], height - y[j], e, e);	
					/*
					ellipse(height - y[j], x[j], e, e);	
					ellipse(height - y[j], width - x[j], e, e);	
					ellipse(height - x[j], width - y[j], e, e);*/
				}
			}

			iter += 1;
		}
	}/* else if (iter == 500000) {
		// compositing
		blendMode(MULTIPLY);
		fill(240, 0, 50, 255);
		rect(width / 6, height / 1.75, width / 2.6, height / 1.2);
	  rect(width - width / 6, height / 1.75, width / 2.6, height / 1.2);
	  rect(width / 2, height / 1.31, width / 3.55, height / 1.25);
		
		blendMode(BLEND);
		fill(0, 60, 100, 255);
		//stroke(0, 0, 100, 255);
		ellipse(width / 2 - 42, 72, 20, 16);
	  ellipse(width / 2 + 42, 72, 20, 16);
	
		iter += 1;
	}*/

	xmotion += 1;
	ymotion += 1;
}

function generate() {
	noStroke();
	
	//background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 120 + pow(ny, 1) * 68, 0.0025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	
/*	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 170 + pow(ny, 1) * 68, 1);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}*/
	/*
	for (y = height; y > 0; y -= 8) {
		for (x = 0; x < width; x += 8) {
			if (random() > 0.85) {
				stroke(0, 0, 0, random(0, 0.25));
				let xx = x + random(-4, 4);
				line(xx, y, xx + random(-1, 1), y + random(-1, 1));
			}
		}
	}
*/
	for (y = 0; y < height/1.2; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.05);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
	
	//fill(0, 0, 0, 1);
	//rect(width / 2, height / 2 - height / 2.5 / 2 + 40, width / 10, height / 2.5);
	
	let wl = 255 * (height / 976);
	let m = 0; // get max y
	for (y = 0; y < (height - m); y += 1) {
		let ny = y / height;
		let noy = noise(ny);
		
		for (x = 0; x < width; x += 1) {
			let yy = (height / 1.2 + noise(x / width) * 8) + y + m;
			
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = (0.5 - noise(nx, ny)) * 2;
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 0.5 + ny * PI * 1 + nox * PI * 2.15)) / 2 * nox2;
			
			if (random() > 0.15) {
				
				let xx = x + random(-2, 2);
				let yh2 = random(-200, 200) * n * (ny * 1.5);
				noStroke();
				
				if (random() > 0.996 && n > 0.05) {
					fill(64, 64, 48, 1);
					rect(xx, yy - yh2, random(2, 8) * ny, 48 * ny);
				}
				
				stroke(0 + (nox2) * 8, 100 * nox3, (200*nox3-random(200) * n), random() * 0.45 * pow(ny, 0.3));
				line(xx, yy, xx + random(-200, 200) * n * noy * ny, yy + yh2);
			}
		}
	}
}"
"923988","My Sketch","mySketch","// ifs
// https://flam3.com/flame_draves.pdf
// + falling sand with a different rule

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];

let ifs = 1;

function setup() {
  createCanvas(800 - 1, 800 - 1);
  background(0);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 100, 100, 255);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
	}
	
	d();
}

function f1(x, y, j) {
	return { x: x / (3.85 - abs(cos(y / width * PI * (j / ifs * 4))) * 0.75), y: abs(width / 2 + x - y / 2) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) / 1.5 * y) / 1.25, y: abs(height - y / 2) / (4.5 - abs(cos(x / width * PI * abs(0.5 - (1+j) / ifs) * 2))*0.5) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.45 - x + (y / 4.5)) / 4.25, y: y / 2.25 };
}

var f = [f1, f2, f3];

var iter = 0;

function draw() {
	//fill(0, 0, 0, 32);
	//rect(0, 0, width, height);
	//background(0);
	/*
	if (iter < 500000 && frameCount < 40) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 0; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;

				fill(0, 0, 255, 255 * (i / 4000) / 1);

				let e = 1;
				
				ellipse(random(0, width), random(0, height), 1, 1);

				if (iter > 20) {
					//ellipse(x[j], y[j], e, e);	
					//ellipse(x[j], y[j], e, e);	
					//ellipse(y[j], height - x[j], e, e);	
					//ellipse(x[j], height - y[j], e, e);	
					//ellipse(y[j], x[j], e, e);	
					//ellipse(height - y[j], x[j], e, e);	
					//ellipse(height - y[j], width - x[j], e, e);	
					//ellipse(height - x[j], width - y[j], e, e);
				}
			}

			iter += 1;
		}
	}*/
	

}

function d() {
	for (let i = 0; i < 10000; i += 1) {
				fill(0, 0, random()*255,32);
				ellipse(random(0, width), random(0, height), 1, 1);
	}
	
	
	//if (frameCount > 60) {
	loadPixels();
			        for(let row = 1; row < height-1; ++row)
        {
            for(let col = 1; col < width-1; ++col)
            {
let a = 0.01;
let b = 0.5;
		//let d = pixelDensity();
		//let l = 4 * (width * d) * (height * d);
							let i = col * 4 + row * width * 4;
							let i2 = (col - 1) * 4 + row * width * 4;
							let i3 = col * 4 + (row - 1) * width * 4;
							let i4 = (col + 1) * 4 + row * width * 4;
							let i5 = col * 4 + (row + 1) * width * 4;
							
                let output_x = pixels[i]/255 + pixels[i2]/255 * (1.0 - a) + pixels[i4]/255 * (1.0 - b);
                let output_y = pixels[i]/255 + pixels[i3]/255 * (1.0 - a) + pixels[i5]/255 * (1.0 - b);

                let sum = 0.5*(output_x + output_y);

                pixels[i] = sum * 255;
							pixels[i+1] = sum * 255;
							pixels[i+2] = sum * 255;
							pixels[i+3] = 255;
            }
        }
		
	updatePixels();
	//}
	
	xmotion += 1;
	ymotion += 1;
}"
"923988","My Sketch","mySketch","// ifs
// https://flam3.com/flame_draves.pdf
// + falling sand with a different rule

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];

let ifs = 1;

function setup() {
  createCanvas(400 - 1, 400 - 1);
  background(0);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 100, 100, 255);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
	}
	
	d();
}

function f1(x, y, j) {
	return { x: x / (3.85 - abs(cos(y / width * PI * (j / ifs * 4))) * 0.75), y: abs(width / 2 + x - y / 2) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) / 1.5 * y) / 1.25, y: abs(height - y / 2) / (4.5 - abs(cos(x / width * PI * abs(0.5 - (1+j) / ifs) * 2))*0.5) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.45 - x + (y / 4.5)) / 4.25, y: y / 2.25 };
}

var f = [f1, f2, f3];

var iter = 0;

function draw() {
	noStroke();
	fill(0, 0, 0, 220);
	rect(0, 0, width, height);
	//background(0);
	/*
	if (iter < 500000 && frameCount < 40) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 0; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;

				fill(0, 0, 255, 255 * (i / 4000) / 1);

				let e = 1;
				
				ellipse(random(0, width), random(0, height), 1, 1);

				if (iter > 20) {
					//ellipse(x[j], y[j], e, e);	
					//ellipse(x[j], y[j], e, e);	
					//ellipse(y[j], height - x[j], e, e);	
					//ellipse(x[j], height - y[j], e, e);	
					//ellipse(y[j], x[j], e, e);	
					//ellipse(height - y[j], x[j], e, e);	
					//ellipse(height - y[j], width - x[j], e, e);	
					//ellipse(height - x[j], width - y[j], e, e);
				}
			}

			iter += 1;
		}
	}*/
	
d();
}

function d() {
	noFill();
	for (let i = 0; i < 4; i += 1) {
				stroke(0, 0, random()*255,128);
				ellipse(width/2,height/2, width/2, height/2);
	}
	
	var ar = []
	//if (frameCount > 60) {
	loadPixels();
			        for(let row = 2; row < height-2; ++row)
        {
            for(let col = 2; col < width-2; ++col)
            {
let a = -.175-noise(row / height+xmotion, col / width+ymotion)/8;
let b = -0.95;
		//let d = pixelDensity();
		//let l = 4 * (width * d) * (height * d);
							let i = col * 4 + row * width * 4;
							let i2 = (col - 1) * 4 + row * width * 4;
							let i3 = col * 4 + (row - 1) * width * 4;
							let i4 = (col + 1) * 4 + row * width * 4;
							let i5 = col * 4 + (row + 1) * width * 4;
							let i6 = (col+1) * 4 + (row + 1) * width * 4;
							let i7 = (col-1) * 4 + (row - 1) * width * 4;
							
                let output_x = pixels[i]/255 + pixels[i2]/255 * (1.0 - a);
							  let output_x2 = pixels[i]/255 + pixels[i4]/255 * (1.0 - a);
                let output_y = pixels[i]/255 + pixels[i3]/255 * (1.0 - a);
							let output_y2 = pixels[i]/255 + pixels[i5]/255 * (1.0 - a);

                let sum = 0.5*((output_y+output_y2)/2);
							
							ar[i] = pixels[i] = sum * 255;
               pixels[i] = ar[i];
							pixels[i+1] = ar[i];
							pixels[i+2] = ar[i];
							pixels[i+3] = 255;
							
            }
        }
			        for(let row = height-1; row>1 ; --row)
        {
            for(let col = width-1; col > 0; --col)
            {
let a = -.7275-noise(row / height+xmotion, col / width+ymotion)/8;
let b = -0.95;
		//let d = pixelDensity();
		//let l = 4 * (width * d) * (height * d);
							let i = col * 4 + row * width * 4;
							let i2 = (col - 1) * 4 + row * width * 4;
							let i3 = col * 4 + (row - 1) * width * 4;
							let i4 = (col + 1) * 4 + row * width * 4;
							let i5 = col * 4 + (row + 1) * width * 4;
							let i6 = (col+1) * 4 + (row + 1) * width * 4;
							let i7 = (col-1) * 4 + (row - 1) * width * 4;
							
                let output_x = pixels[i]/255 + pixels[i2]/255 * (1.0 - a);
							  let output_x2 = pixels[i]/255 + pixels[i4]/255 * (1.0 - a);
                let output_y = pixels[i]/255 + pixels[i3]/255 * (1.0 - b);
							let output_y2 = pixels[i]/255 + pixels[i5]/255 * (1.0 - b);

                let sum = 0.5*((output_x2+output_y2)/2);
							
							ar[i] = pixels[i] = sum * 255;
               pixels[i] = ar[i];
							pixels[i+1] = ar[i];
							pixels[i+2] = ar[i];
							pixels[i+3] = 255;
							
            }
        }
	/*
			        for(let row = 1; row < height-1; ++row)
        {
            for(let col = 1; col < width-1; ++col)
            {
							
							let i = col * 4 + row * width * 4;

                pixels[i] = ar[i];
							pixels[i+1] = ar[i];
							pixels[i+2] = ar[i];
							pixels[i+3] = 255;
						}
				}
		*/
	updatePixels();
	//}
	
	xmotion += 1;
	ymotion += 1;
}"
"918224","Offscreen + Physarum","mySketch","// same as ""slime mold simulation""
// some cool figures can be made by tweaking lx / ly parameters

var xmotion = 0;
var ymotion = 0;

var objs = [];
var trail_map = [];

var nnx = 32;
var nny = 32;

let buff;
let den;

function setup() {
	createCanvas(800, 800);
	
	colorMode(HSB, 360, 255, 255);
	
	background(0);
	
	noiseDetail(7, 0.7);
	
	buff = createGraphics(800, 800);
	
	var inc = 0;
	for (var nx = 0; nx < nnx; nx += 1) {
	 var nmx = nx / nnx;
	 for (var ny = 0; ny < nny; ny += 1) {
		var n = parseInt(nx + ny * nnx);
		 
		var nmy = ny / nny;
		
		var no = noise(nmx * nmy);
		 
		var ni = inc / (nnx * nny);
		
		objs[n] = {
			lx: nmx * width,
			ly: height / 4 + nmy * (height / 2),
			// paper
			la: random(-PI * 2, PI * 2), // modify this for more shapes
			// paper : 1
			lv: 1,
			d: 1,
			n: no,
			so: 6, // agent sensor offset,
			sa: 45// agent sensor angle (degree)
		};
		 
		inc += 1;
	 }
	}
	
	den = pixelDensity();
	
	buff.background(0, 0, 0);
	buff.fill(255,255,255);
  buff.textSize(width / 4);
	buff.textStyle(BOLD);
  buff.textAlign(CENTER, CENTER);
	buff.text('test', width / 2, height / 2);
	buff.filter(INVERT);

/*
	for (var i = 0; i < width; i += 1) {
		let ni = abs(0.5 - i / width) * 2;
		for (var j = 0; j < height; j += 1) {
			let nj = abs(0.5 - j / height) * 2;
			trail_map[i + j * width] = tan(nj * PI * 1) + cos(ni * PI * 2);
		}
	}
*/
	ellipseMode(CENTER);
	rectMode(CENTER);
}

function getpindex(x, y) {
	return (y * width + x) * (den * 4);
}

function compute() {
	fill(0);
	
	strokeWeight(2);
	
	buff.loadPixels();

	for (var nx = 0; nx < nnx; nx += 1) {
	 for (var ny = 0; ny < nny; ny += 1) {
		var n = parseInt(nx + ny * nnx);
		 
		var obj = objs[n];
		
		var sensor_offset = obj.so;
		var sensor_angle = radians(obj.sa);
		
		// agent sensors
		var lhx = round(sin(obj.la - sensor_angle) * sensor_offset);
		var lhy = round(cos(obj.la - sensor_angle) * sensor_offset);
		var fhx = round(sin(obj.la) * sensor_offset);
		var fhy = round(cos(obj.la) * sensor_offset);
		var rhx = round(sin(obj.la + sensor_angle) * sensor_offset);
		var rhy = round(cos(obj.la + sensor_angle) * sensor_offset);
		
		var ailx = parseInt(obj.lx + lhx);
		var aily = parseInt(obj.ly + lhy);
		var aifx = parseInt(obj.lx + fhx);
		var aify = parseInt(obj.ly + fhy);
		var airx = parseInt(obj.lx + rhx);
		var airy = parseInt(obj.ly + rhy);
		
		ailx = ailx < 0 ? ailx + width : ailx;
		aily = aily < 0 ? aily + height : aily;
		aifx = aifx < 0 ? aifx + width : aifx;
		aify = aify < 0 ? aify + height : aify;
		airx = airx < 0 ? airx + width : airx;
		airy = airy < 0 ? airy + height : airy;
		
		ailx %= width;
		aily %= height;
		aifx %= width;
		aify %= height;
		airx %= width;
		airy %= height;
		 
		// sensor sample
		var s1 = buff.pixels[getpindex(ailx, aily)]; // left
		var s2 = buff.pixels[getpindex(aifx, aify)]; // forward
		var s3 = buff.pixels[getpindex(airx, airy)]; // right
		
/*
		// debug sensor
		fill(255, 0, 0, 255);
		rect(ailx, aily, 1, 1);
		rect(aifx, aify, 1, 1);
		rect(airx, airy, 1, 1);
*/	
/*
		if (frameCount % 60 == 0) {
			obj.la += PI / 2;
		}
*/
	
		// agent behavior based on sampled sensor
		if (s2 < s1 && s2 < s3) {
			// turn left or right randomly
			//obj.la += random(PI / 2, -PI / 2);
			// paper
			obj.la += (random() > 0.5 ? PI / 2 : -PI / 2);
		} else if (s1 < s3) {
			// turn left
			obj.la -= PI / 2;
		} else if (s3 < s1) {
			// turn right
			obj.la += PI / 2;
		}
		
		obj.lx += obj.lv * sin(obj.la);
		obj.ly += obj.lv * cos(obj.la);
		 
		 if (obj.lx < 0 || obj.lx > width) {
				continue; 
		 }
		 
		 if (obj.ly < 0 || obj.ly > height) {
				continue; 
		 }
		
		// boundary checks
		/*obj.lx = obj.lx < 0 ? obj.lx + width - 1 : obj.lx;
		obj.lx %= width;
		obj.ly = obj.ly < 0 ? obj.ly + height - 1 : obj.ly;
		obj.ly %= height;*/
		
		// deposit diffusion (3x3 mean kernel)
		// should probably go after deposit step though
		var i = parseInt(obj.lx + obj.ly * width);
		var b = buff.pixels[getpindex(obj.lx, obj.ly)] / 255;

		var lx = parseInt(obj.lx);
		var ly = parseInt(obj.ly);

		var xb = (lx - 1);
		var yb = (ly - 1);
		var xbl = xb < 0 ? width - 1 : xb;
		var ybl = yb < 0 ? height - 1 : yb;
		var xbu = (lx + 1) % width;
		var ybu = (ly + 1) % height;
		/*
		var v1 = trail_map[xbl + ly * width];
		var v2 = trail_map[xbu + ly * width];
		var v3 = trail_map[xbl + ybl * width];
		var v4 = trail_map[xbl + ybu * width];
		var v5 = trail_map[xbu + ybl * width];
		var v6 = trail_map[xbu + ybu * width];
		var v7 = trail_map[lx + ybl * width];
		var v8 = trail_map[lx + ybu * width];
		
		var vm = (v1 + v2 + v3 + v4 + v5 + v6 + v7 + v8) / 8 / 5;
		*/
		buff.pixels[getpindex(xbl, ly)] = b;
		buff.pixels[getpindex(xbu, ly)] = b;
		buff.pixels[getpindex(xbl, ybl)] = b;
		buff.pixels[getpindex(xbl, ybu)] = b;
		buff.pixels[getpindex(xbu, ybl)] = b;
		buff.pixels[getpindex(xbu, ybu)] = b;
		buff.pixels[getpindex(lx, ybl)] = b;
		buff.pixels[getpindex(lx, ybu)] = b;
		
		// deposit
		buff.pixels[getpindex(obj.lx, obj.ly)] = obj.d;
		
		// agent display
		var ll = 440;
		var t = (noise(obj.n + xmotion * 4) * 2) * (pow((1 - min(ll, frameCount) / ll), 6.5 * (((abs(0.5-obj.ly / height)/8) * 6))));

		var sph = (1 - abs((0.5 - obj.lx / width) * 2));
		var color = 224 + noise(obj.n + xmotion * 2) * 32 * sph;
		fill(0, 0, color * (1 - abs(0.5-obj.ly / height)*2) * 8, t / 4);
		 noStroke();
		//stroke(0, 0, color, t);
		rect(obj.lx, obj.ly, 1, 1);
		
/*
		if (trail_map[parseInt(i)] > 1) {
			trail_map[parseInt(i)] = 1;
		}
*/
	 }
	}
	
	//buff.updatePixels();
	
	//buff.loadPixels();
	
	// deposit decay
	for (var y = 0; y < height; y += 1) {
		for (var x = 0; x < width; x += 1) {
			var v = buff.pixels[getpindex(x, y)];
			buff.pixels[getpindex(x, y)] -= 0.000001;
			if (buff.pixels[getpindex(x, y)] < 0) {
				buff.pixels[getpindex(x, y)] = 0;
			}
		}
	}
	
	buff.updatePixels();
/*
	if (frameCount % 60 == 0) {
		var st = 1 + parseInt(random() * (nn / 8));
		for (var y = 0; y < nn; y += st) {
			objs[y].lx = random() * width;
			objs[y].ly = random() * height;
		}
	}
*/
}

function draw() {
	noStroke();
	
	rectMode(CORNER);
/*
	fill(0, 0, 0, 8);
	rect(0, 0, width, height);
*/
	rectMode(CENTER);
	
	compute();
	//image(buff, 0,0);
	xmotion += 0.05;
	ymotion += 0.0002;
}"
"918224","Offscreen + Physarum","mySketch","// slime mold simulation with offscreen buffer as trail map :)

var xmotion = 0;
var ymotion = 0;

var objs = [];
var trail_map = [];

var nnx = 128;
var nny = 24;

let buff;
let den;

let img;

function preload() {
    //img = loadImage('bc.png');
}

function setup() {
	createCanvas(windowWidth, 400);
	
	colorMode(HSB, 360, 255, 255);
	
	background(0);
	
	noiseDetail(7, 0.7);
	
	buff = createGraphics(width, height);
	
	var inc = 0;
	for (var nx = 0; nx < nnx; nx += 1) {
	 var nmx = nx / nnx;
	 for (var ny = 0; ny < nny; ny += 1) {
		var n = parseInt(nx + ny * nnx);
		 
		var nmy = ny / nny;
		
		var no = noise(nmx * nmy);
		 
		var ni = inc / (nnx * nny);
		
		objs[n] = {
			lx: nmx * width,
			ly: height, //+ nmy * (height / 2),
			// paper
			la: random(-PI * 2, PI * 2), // modify this for more shapes
			// paper : 1
			lv: 1,
			d: 1,
			n: no,
			so: 3, // agent sensor offset,
			sa: 45// agent sensor angle (degree)
		};
		 
		inc += 1;
	 }
	}
	
	den = pixelDensity();
	
	buff.background(0, 0, 0);
	buff.fill(255,255,255);
  buff.textSize(width / 7);
	buff.textStyle(BOLD);
  buff.textAlign(CENTER, BASELINE);
	buff.text('PROCESSING', width / 2, height);
	buff.filter(INVERT);
	
	//buff.image(img, 0, 200);
//buff.filter(INVERT);
/*
	for (var i = 0; i < width; i += 1) {
		let ni = abs(0.5 - i / width) * 2;
		for (var j = 0; j < height; j += 1) {
			let nj = abs(0.5 - j / height) * 2;
			trail_map[i + j * width] = tan(nj * PI * 1) + cos(ni * PI * 2);
		}
	}
*/
	ellipseMode(CENTER);
	rectMode(CENTER);
}

function getpindex(x, y) {
	return (y * width + x) * (den * 4);
}

function compute() {
	fill(0);
	
	strokeWeight(2);
	
	buff.loadPixels();

	for (var nx = 0; nx < nnx; nx += 1) {
	 for (var ny = 0; ny < nny; ny += 1) {
		var n = parseInt(nx + ny * nnx);
		 
		var obj = objs[n];
		
		var sensor_offset = obj.so;
		var sensor_angle = radians(obj.sa);
		
		// agent sensors
		var lhx = round(sin(obj.la - sensor_angle) * sensor_offset);
		var lhy = round(cos(obj.la - sensor_angle) * sensor_offset);
		var fhx = round(sin(obj.la) * sensor_offset);
		var fhy = round(cos(obj.la) * sensor_offset);
		var rhx = round(sin(obj.la + sensor_angle) * sensor_offset);
		var rhy = round(cos(obj.la + sensor_angle) * sensor_offset);
		
		var ailx = parseInt(obj.lx + lhx);
		var aily = parseInt(obj.ly + lhy);
		var aifx = parseInt(obj.lx + fhx);
		var aify = parseInt(obj.ly + fhy);
		var airx = parseInt(obj.lx + rhx);
		var airy = parseInt(obj.ly + rhy);
		
		ailx = ailx < 0 ? ailx + width : ailx;
		aily = aily < 0 ? aily + height : aily;
		aifx = aifx < 0 ? aifx + width : aifx;
		aify = aify < 0 ? aify + height : aify;
		airx = airx < 0 ? airx + width : airx;
		airy = airy < 0 ? airy + height : airy;
		
		ailx %= width;
		aily %= height;
		aifx %= width;
		aify %= height;
		airx %= width;
		airy %= height;
		 
		// sensor sample
		var s1 = buff.pixels[getpindex(ailx, aily)]; // left
		var s2 = buff.pixels[getpindex(aifx, aify)]; // forward
		var s3 = buff.pixels[getpindex(airx, airy)]; // right
		
/*
		// debug sensor
		fill(255, 0, 0, 255);
		rect(ailx, aily, 1, 1);
		rect(aifx, aify, 1, 1);
		rect(airx, airy, 1, 1);
*/	
/*
		if (frameCount % 60 == 0) {
			obj.la += PI / 2;
		}
*/
	
		// agent behavior based on sampled sensor
		if (s2 < s1 && s2 < s3) {
			// turn left or right randomly
			//obj.la += random(PI / 2, -PI / 2);
			// paper
			obj.la += (random() > 0.5 ? PI / 2 : -PI / 2);
		} else if (s1 < s3) {
			// turn left
			obj.la -= PI / 2;
		} else if (s3 < s1) {
			// turn right
			obj.la += PI / 2;
		}
		
		obj.lx += obj.lv * sin(obj.la);
		obj.ly += obj.lv * cos(obj.la);
		 
		 if (obj.lx < 0 || obj.lx > width) {
				continue; 
		 }
		 
		 if (obj.ly < 0 || obj.ly > height) {
				continue; 
		 }
		
		// boundary checks
		/*obj.lx = obj.lx < 0 ? obj.lx + width - 1 : obj.lx;
		obj.lx %= width;
		obj.ly = obj.ly < 0 ? obj.ly + height - 1 : obj.ly;
		obj.ly %= height;*/
		
		// deposit diffusion (3x3 mean kernel)
		// should probably go after deposit step though
		var i = parseInt(obj.lx + obj.ly * width);
		var b = buff.pixels[getpindex(obj.lx, obj.ly)] / 255;

		var lx = parseInt(obj.lx);
		var ly = parseInt(obj.ly);

		var xb = (lx - 1);
		var yb = (ly - 1);
		var xbl = xb < 0 ? width - 1 : xb;
		var ybl = yb < 0 ? height - 1 : yb;
		var xbu = (lx + 1) % width;
		var ybu = (ly + 1) % height;
		/*
		var v1 = trail_map[xbl + ly * width];
		var v2 = trail_map[xbu + ly * width];
		var v3 = trail_map[xbl + ybl * width];
		var v4 = trail_map[xbl + ybu * width];
		var v5 = trail_map[xbu + ybl * width];
		var v6 = trail_map[xbu + ybu * width];
		var v7 = trail_map[lx + ybl * width];
		var v8 = trail_map[lx + ybu * width];
		
		var vm = (v1 + v2 + v3 + v4 + v5 + v6 + v7 + v8) / 8 / 5;
		*/
		buff.pixels[getpindex(xbl, ly)] = b;
		buff.pixels[getpindex(xbu, ly)] = b;
		buff.pixels[getpindex(xbl, ybl)] = b;
		buff.pixels[getpindex(xbl, ybu)] = b;
		buff.pixels[getpindex(xbu, ybl)] = b;
		buff.pixels[getpindex(xbu, ybu)] = b;
		buff.pixels[getpindex(lx, ybl)] = b;
		buff.pixels[getpindex(lx, ybu)] = b;
		
		// deposit
		buff.pixels[getpindex(obj.lx, obj.ly)] = obj.d;
		
		// agent display
		var ll = 440;
		var t = 1;//(noise(obj.n + xmotion * 4) * 2) * (pow((1 - min(ll, frameCount) / ll), 6.5 * (((abs(0.5-obj.ly / height)/8) * 6))));

		var sph = (1 - abs((0.5 - obj.lx / width) * 2));
		var color = 224 + noise(obj.n + xmotion * 2) * 32 * sph;
		fill(0, 0, color * (1 - abs(0.5-obj.ly / height)*2) * 8, t / 4);
		 noStroke();
		//stroke(0, 0, color, t);
		rect(obj.lx, obj.ly, 1, 1);
		
/*
		if (trail_map[parseInt(i)] > 1) {
			trail_map[parseInt(i)] = 1;
		}
*/
	 }
	}
	
	//buff.updatePixels();
	
	//buff.loadPixels();
	
	// deposit decay
	for (var y = 0; y < height; y += 1) {
		for (var x = 0; x < width; x += 1) {
			var v = buff.pixels[getpindex(x, y)];
			buff.pixels[getpindex(x, y)] -= 0.1;
			if (buff.pixels[getpindex(x, y)] < 0) {
				buff.pixels[getpindex(x, y)] = 0;
			}
		}
	}
	
	buff.updatePixels();
/*
	if (frameCount % 60 == 0) {
		var st = 1 + parseInt(random() * (nn / 8));
		for (var y = 0; y < nn; y += st) {
			objs[y].lx = random() * width;
			objs[y].ly = random() * height;
		}
	}
*/
}

function draw() {
	noStroke();
	
	rectMode(CORNER);
/*
	fill(0, 0, 0, 8);
	rect(0, 0, width, height);
*/
	rectMode(CENTER);
	
	compute();
//image(buff, 0,0);
	xmotion += 0.05;
	ymotion += 0.0002;
}"
"918173","Distant beacon","mySketch","function setup() {
	createCanvas(windowWidth, windowHeight);
	
	noStroke();
	
	background(0);
	
	colorMode(HSL, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	generate();
}

function draw() {
	
}

function generate() {
	noStroke();
	
	background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	
	for (y = -128; y < height + height; y += 1) {
		let ny = y / height;
		let noy = noise(ny);
		
		for (x = 0; x < width / 2; x += 4) {			
			if (random() > 0.3) {
				let yy = y * 0.8;

				let nox0 = x / width;
				let nx = abs(0.5 - nox0) * 2;
				let nox = noise(nx * 8, ny * 8);
				let nox2 = (0.5 - noise(nx, ny)) * 2;
				let nox3 = noise(nx * 2, ny * 2);
				let n = (sin(nx * PI * 0.5 + ny * PI * 2 + nox * PI * 10));
				
				let xx = x + random(-2, 2) + width / 2;
				let yh2 = (width / 48) * nox2 * pow(ny, 0.7);
				noStroke();

				stroke(210 + abs(nox2) * 8, 32 + 64 * abs(nox2), 160 - 110 * nx + 90 * abs(n), 0.08 * abs(n) * pow(ny / 2, 0.8) + 0.5 * pow(nx / 2.1, 4));
				line(xx, height - yy, xx + nox2 * (width / 32) * (1 - ny) * 2, height - yy - yh2);
				line(width - xx, height - yy, width - (xx + nox2 * (width / 32) * (1 - ny) * 5), height - (yy + yh2));
			}
		}
	}
	
	let cx = width / 2;
	let cy = height / 2.5;
	let rr = height * 8;
	
	strokeWeight(1);
	for (y = 0; y < 10000; y += 1) {
		let cyy = y / 10000;
		let cccx = cx + sin(cyy * PI * 2) * (rr / 2.05);
		stroke(random(50, 60), random(128, 200), 255, 0.05);
		line(cccx + random(-cx, cx) / 16, cy + random(-cx, cx) / 16 - rr / 2.5 + cos(cyy * PI * 2) * (rr / 1.85), cx, cy / 2);
	}
	/*
	rr = height / 64;
	for (y = 0; y < 100; y += 1) {
		let cyy = y / 100;
		let cccx = cx + sin(cyy * PI * 2) * (rr / 2.05);
		stroke(random(50, 60), random(128, 200), random(230, 255), 0.5);
		line(cccx + random(-cx, cx), cy + random(-cx, cx) - rr / 2.5 + cos(cyy * PI * 2) * (rr / 1.85), cx, cy / 2);
	}
	*/
	//noStroke();
	//fill(random(50, 60), 128, 255, 1);
	//ellipse(cx, cy - rr / 2.5, width / 48, height / 24);
}"
"918173","Distant beacon","mySketch","function setup() {
	createCanvas(windowWidth, windowHeight);
	
	noStroke();
	
	background(0);
	
	colorMode(HSL, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	generate();
}

function draw() {
	
}

function generate() {
	noStroke();
	
	background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	
	for (y = -128; y < height + height; y += 1) {
		let ny = y / height;
		let noy = noise(ny);
		
		for (x = 0; x < width / 2; x += 4) {			
			if (random() > 0.3) {
				let yy = y * 0.8;

				let nox0 = x / width;
				let nx = abs(0.5 - nox0) * 2;
				let nox = noise(nx * 8, ny * 8);
				let nox2 = (0.5 - noise(nx, ny)) * 2;
				let nox3 = noise(nx * 2, ny * 2);
				let n = (sin(nx * PI * 0.5 + ny * PI * 2 + nox * PI * 10));
				
				let xx = x + random(-2, 2) + width / 2;
				let yh2 = (width / 48) * nox2 * pow(ny, 0.7);
				noStroke();

				stroke(210 + abs(nox2) * 8, 32 + 64 * abs(nox2), 160 - 110 * nx + 90 * abs(n), 0.08 * abs(n) * pow(ny / 2, 0.8) + 0.5 * pow(nx / 2.1, 4));
				line(xx, height - yy, xx + nox2 * (width / 32) * (1 - ny) * 2, height - yy - yh2);
				line(width - xx, height - yy, width - (xx + nox2 * (width / 32) * (1 - ny) * 5), height - (yy + yh2));
			}
		}
	}
	
	let cx = width / 2;
	let cy = height / 2.5;
	let rr = height * 8;
	
	strokeWeight(1);
	for (y = 0; y < 10000; y += 1) {
		let cyy = y / 10000;
		let cccx = cx + sin(cyy * PI * 2) * (rr / 2.05);
		stroke(random(50, 60), random(128, 200), 255, 0.05);
		line(cccx + random(-cx, cx) / 16, cy + random(-cx, cx) / 16 - rr / 2.5 + cos(cyy * PI * 2) * (rr / 1.85), cx, cy / 2);
	}
	/*
	rr = height / 64;
	for (y = 0; y < 100; y += 1) {
		let cyy = y / 100;
		let cccx = cx + sin(cyy * PI * 2) * (rr / 2.05);
		stroke(random(50, 60), random(128, 200), random(230, 255), 0.5);
		line(cccx + random(-cx, cx), cy + random(-cx, cx) - rr / 2.5 + cos(cyy * PI * 2) * (rr / 1.85), cx, cy / 2);
	}
	*/
	//noStroke();
	//fill(random(50, 60), 128, 255, 1);
	//ellipse(cx, cy - rr / 2.5, width / 48, height / 24);
}"
"913519","My Sketch","mySketch","function setup() {
	createCanvas(windowWidth, windowHeight);
	
	noStroke();
	
	background(0);
	
	colorMode(HSL, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	generateBackground();
}

let ymotion = 0;

function draw() {
	//background(0);
	
	strokeWeight(1);
	
	let y = 0;
	for (y = 0; y < height / 2; y += 1) {
		let ny = y / (height / 2);
		let nny = 1 - ny;
		let yy = y + height / 2;
		
		let n = noise(ny * 8 + ymotion);
		
		let fuite = width / 2;
		
		// grass
		let gcw = fuite * nny;
		stroke(102, 80, 164 - 32 * n, 1);
		line(0, yy, gcw, yy);
		line(width, yy, width - gcw, yy);
		
		// track
		let tpx = gcw
		let tw = 16 * ny;
		stroke(0, 0, 255, 1);
		line(tpx, yy, tpx + tw, yy);
		line(width - tpx, yy, width - (tpx + tw), yy);
		
		let track_height = height / 2 / 8;
		
		let tbpx = tpx + tw;
		if (abs(y + ymotion) % track_height > track_height / 2) {
			stroke(50, 255, 32, 1);
		} else {
			stroke(50, 255, 64, 1);
		}
		line(tbpx, yy, fuite, yy);
		line(width - tbpx, yy, width - fuite, yy);
	}
	
	ymotion -= 0.05;
}

function generateBackground() {
	noStroke();
	
	background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;
	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 24, ny / 24);
			let n2 = noise(nx, ny);
			
			let yy = height / 3.9 + y - n * height;
			fill(224 - 20 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))), 118, 128 + pow(ny, 1) * 128, 1);
			rect(x, yy, 4, 5);
		}
	}
}"
"912697","My Sketch","mySketch","function setup() {
	createCanvas(windowWidth, windowHeight);
	background(100);
	
	colorMode(HSL, 360, 255, 255);
	ellipseMode(CENTER);
	
	generate();
}

function draw() {

}

function generate() {
	noStroke();
	
	fill(226, 20, 64);
	rect(0, 0, width, height);
	
	let x = 0;
	let y = 0;
	let i = 0;
	let j = 0;
	
	for (i = 0; i < 64; i += 1) {
		let ni = i / 64;
		
		let ra = random(32, 128);
		let xx = random(0, width);
		let yy = random(0, height);
		
		for (j = 0; j < 64; j += 1) {
			let nj = pow(j / 64, 0.25);

			fill(0, 0, 255 * (1 - nj), 1);
			ellipse(xx, yy, ra * nj, ra * nj);
		}
	}
	
	noFill();
	for (x = 0; x < width; x += 4) {
		for (y = 0; y < height; y += 4) {
			if (random() > 0.7) {
				stroke(0, 0, 224, random(0.01, 0.1));
				line(x + random(-4, 4), y + random(-4, 4), x + random(-4, 4), y + random(-4, 4));
			}
		}
	}
}"
"911711","Escape","mySketch","function setup() {
	createCanvas(windowWidth, windowHeight);
	
	noStroke();
	
	background(0);
	
	colorMode(HSL, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	generate();
}

function draw() {
	
}

function isInsideEllipse(h, k, x, y, a, b) {
   return (pow((x - h), 2) / pow(a, 2)) + (pow((y - k), 2) / pow(b, 2));
}

function generate() {
	noStroke();
	
	background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 24, ny / 24);
			let n2 = noise(nx / 8, ny / 8);
			
			let yy = height / 3.9 + y - n * height;
			fill(60 - 30 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 2 + 0.25))), 0, 148 + pow(ny, 1) * 200, random(0.15, 0.25));
			stroke(0, 0, random(0, 128), random(0,0.025));
			ellipse(x + random(-8, 8), yy + random(-8, 8), 16, 16);
		}
	}
	
	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 170 + pow(ny, 1) * 68, 0.025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	
	let cx = width / 2;
	let cy = height / 1.45;
	let rr = height / 1.25;

	noStroke();
	fill(0, 0, 0, 1);
	ellipse(cx, cy, rr, rr);
	
	for (y = 0; y < 300; y += 1) {
		let cyy = y / 300;
		for (x = 0; x < 16; x += 1) {
			fill(random(190, 224), 255, random(220, 255), random(0.005, 0.125));
			ellipse(cx + sin(cyy * PI * 4) * (rr * 0.95), cy + cos(cyy * PI * 4) * (rr * 0.95), random(1, width), random(8, rr / 1.5));
		}
	}
	/*
	for (y = 0; y < 30000; y += 1) {
		let cyy = y / 30000;
		for (x = 0; x < 2; x += 1) {
			let rx = width / 32;
			let ry = height / 32;
			
			cy = height / 4.5;
			
			fill(random(0, 48), 255, random(220, 255), random(0.005, 0.025));
			ellipse(cx + random(-width, width), cy - rr / 5 * 0.3 + random(0, rr / 5), rx, ry);
			fill(random(48, 92), 255, random(220, 255), random(0.005, 0.025));
			ellipse(cx + random(-width, width), cy - rr / 5 * 0.5 + random(0, rr / 5), rx, ry);
			fill(random(150, 198), 255, random(220, 255), random(0.005, 0.025));
			ellipse(cx + random(-width, width), cy - rr / 5 * 0.7 + random(0, rr / 5), rx, ry);
			fill(random(192+48, 192+48*2), 255, random(220, 255), random(0.005, 0.025));
			ellipse(cx + random(-width, width), cy - rr / 5 * 0.9 + random(0, rr / 5), rx, ry);
			fill(random(192+48*2, 192+48*3), 255, random(220, 255), random(0.005, 0.025));
			ellipse(cx + random(-width, width), cy - rr / 5 * 1.1 + random(0, rr / 5), rx, ry);
		}
	}
	*/
	cx = width / 2;
	cy = height / 1.45;
	rr = height / 1.25;
	
	/*
	for (y = 0; y < 1000; y += 1) {
		let cyy = y / 1000;
		for (x = 0; x < 128; x += 1) {
			fill(random(190, 224), 0, 255 * (x / 128), random(0.005, 0.25));
			ellipse(cx + sin(cyy * PI * 4) * (rr * 1.425), cy * (x / 128) + cos(cyy * PI * 4) * (rr * 0.95), 32, 32);
		}
	}*/
	
	for (y = 0; y < 20000; y += 1) {
		let cyy = y / 20000;
		for (x = 0; x < 2; x += 1) {
			if (random() > 0.9) {
				let cccx = cx + sin(cyy * PI * 2) * (rr / 0.025);
				stroke(220, random(0, 255), random(0, 255), random(0.05, 0.225));
				line(cccx + random(-32, 32), cy + random(-32, 32) - rr / 0.5 + cos(cyy * PI * 2) * (rr / 1.0), cx, height / 1.25);
			}
		}
	}
	
	for (y = 0; y < 20000; y += 1) {
		let cyy = y / 20000;
		for (x = 0; x < 2; x += 1) {
			if (random() > 0.5) {
				let cccx = cx + sin(cyy * PI * 2) * (rr / 2.05);
				stroke(0, 0, random(224, 255), random(0.05, 0.5));
				line(cccx + random(-32, 32), cy + random(-32, 32) - rr / 4.5 + cos(cyy * PI * 2) * (rr / 1.85), cx, height / 0.85);
			}
		}
	}
	
	//ellipse(cx + rr / 0.95, cy - rr / 2, rr / 6, rr / 6);
	//ellipse(cx + rr / 0.85, cy - rr / 2.3, rr / 20, rr / 20);
	/*for (y = -1; y < 16; y += 1) {
		let ny = y / 16;
		
		if (y == -1) {
			fill(0, 0, 255, 1);
			ellipse(cx - rr / 4, cy - rr / 2.5 * ny, rr / 4, rr / 4);
			ellipse(cx + rr / 4, cy - rr / 2.5 * ny, rr / 4, rr / 4);
		} else {
			fill(0, 0, 255 * (1 - ny), 0.25 * (1-ny));
			ellipse(cx - rr / 4, cy - rr / 2.5 * ny, rr / 4 * ny, rr / 4 * ny);
			ellipse(cx + rr / 4, cy - rr / 2.5 * ny, rr / 4 * ny, rr / 4 * ny);
		}
		//fill(random(0, 224), 128, 64 * (ny), 0.25 * (ny));
		//ellipse(cx + rr / 0.95, cy - rr / 2, rr / 6 * ny, rr / 6 * ny);
		//ellipse(cx + rr / 0.85, cy - rr / 2.3, rr / 20 * ny, rr / 20 * ny);
	}*/
	
	fill(0, 0, 255, 0.25);
	noStroke();
	ellipse(cx, cy - rr / 2.5, rr / 2, rr / 1.5);

	for (y = 0; y < 64; y += 1) {
		let ny = y / 64;
		
		fill(184 + 80 * pow(ny, 0.5),0, 16 * pow(ny, 0.5), 0.5 * (1-ny));
		//strokeWeight(width / 32 * ny);
		//noFill();
		ellipse(cx, cy - rr / 2.5, rr / 1.85 * ny, rr / 1.45 * ny);
	}
	noStroke();
strokeWeight(0.95);
/*
	fill(0, 0, 192, 1);
	ellipse(cx, cy - rr / 4.5, rr / 2.8, rr / 1.85);
	fill(224, 255, 200, 1);
	ellipse(cx, cy - rr / 4.5, rr / 2.9, rr / 2);

	for (y = 0; y < 32; y += 1) {
		let ny = 1 - y / 32;
		
		fill(random(200, 224), 255, 128 * (1 - ny), 0.05);
		ellipse(cx, cy - rr / 4.5 * pow(ny, 0.25), rr / 4 * ny, rr / 2);
		ellipse(cx, height - (cy - rr / 4.5 * pow(ny, 0.15)), rr / 4 * ny, rr / 2);
	}*/

	for (y = 0; y < height; y += 8) {
		let ny = y / height;
		for (x = 0; x < width; x += 8) {
			let nx = x / width;
			let n = noise(nx / 3, ny / 5);
			let n2 = noise(nx * 4, ny * 4);
			
			let yy = height - height / 24 + y - n * height;
			fill(120, 64 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 4.25 + ny * PI * 8 + 4.25))), 40 + pow(ny, 1) * 255, 1);
			stroke(0, 0, random(0, 255), random(0,0.15));
			//ellipse(x + random(-1, 1), yy + random(-1, 1), 18, 12 * ((1-ny) * 3));
			
			stroke(0, 0, random(0, 255), random(0,0.25));
			line(random(x - 4, x + 4), random(y - 4, y + 4), random(x - 4, x + 4), random(y - 4, y + 4));
		}
	}

	/*
	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 200 + pow(ny, 1) * 68, 0.1);
			line(x + random(-256, 256), yy, x + random(-256, 256), yy - random(32, height / 8));
		}
	}
*/
	
	for (y = height; y > 0; y -= 8) {
		for (x = 0; x < width; x += 8) {
			if (random() > 0.85) {
				stroke(0, 0, 0, random(0, 0.25));
				let xx = x + random(-4, 4);
				line(xx, y, xx + random(-1, 1), y + random(-1, 1));
			}
		}
	}

	for (y = 0; y < height / 2; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.05);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
	
	//fill(0, 0, 0, 1);
	//rect(width / 2, height / 2 - height / 2.5 / 2 + 40, width / 10, height / 2.5);
	
	let wl = 255 * (height / 976);
	let m = 0; // get max y
	for (y = 0; y < (height - m); y += 1) {
		let ny = y / height;
		let noy = noise(ny);
		
		for (x = 0; x < width; x += 1) {
			let yy = (height / 10.5 + noise(x / width) * 8) + y + m;
			
			let nx = x / width;
			let nnx = abs(nx - 0.5) * 2;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = (0.5 - noise(nx, ny)) * 2;
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 0.5 + ny * PI * 1 + nox * PI * 2.15)) / 2 * nox2;
			
			//let ocx = cx + sin(nx * PI * 2) * (rr / 1.5);
			//let ocy = (cy - rr / 4.5) + cos(ny * PI * 2) * (rr / 1.25);
			
			let ise = isInsideEllipse(cx, (cy - rr / 2.5), x, yy, (rr / 1.25) / 2.0, (rr / 2.125) / 2);
			let ise2 = isInsideEllipse(cx, (cy - rr / 2.5), x, yy, (rr / 2) / 2.0, (rr / 1.5) / 2);
			
			if (random() > 0.1 && ise2 > 1) {
				
				let xx = x + random(-2, 2);
				let yh2 = random(-height / 8, height / 8) * n * ny * nnx * (ise / 8);
				noStroke();
				
				/*
				if (random() > 0.996 && n > 0.05) {
					fill(64, 64, 48, 1);
					rect(xx, yy - yh2, random(2, 8) * ny, 48 * ny);
				}
				*/
				// 100 * nox3
				stroke(180 + 60 * pow((1-nnx), 0.95), 64 * nox3, (200*nox3-random(200) * n), random() * 0.45 * pow(ny, 0.93)  * (ise / 4));

				line(xx, yy, xx + random(-width / 5, width / 5) * n * noy * ny* pow((nnx), 0.95) * (ise / 12), yy + yh2);
			}
		}
	}
	/*
	for (x = 0; x < 8; x += 1) {
		let xx = random(0, width);
		let yy = random(height / 2, height);
		for (y = 0; y < 100; y += 1) {
			let ny = y / 100;
			
			noStroke();
			fill(110, 255, 10, 0.05);
			ellipse(xx + random(-32, 32) * ny, yy + 100 * ny, random(1, 64), random(1, 64));
		}
	}*/
}"
"911452","Mono","mySketch","function setup() {
	createCanvas(windowWidth, windowHeight);
	
	noStroke();
	
	background(0);
	
	colorMode(HSL, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	generate();
}

function draw() {
	
}

function isInsideEllipse(h, k, x, y, a, b) {
   return (pow((x - h), 2) / pow(a, 2)) + (pow((y - k), 2) / pow(b, 2));
}

function generate() {
	noStroke();
	
	background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 24, ny / 24);
			let n2 = noise(nx / 8, ny / 8);
			
			let yy = height / 3.9 + y - n * height;
			fill(60 - 30 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 2 + 0.25))), 0, 148 + pow(ny, 1) * 200, random(0.15, 0.25));
			stroke(0, 0, random(0, 128), random(0,0.025));
			ellipse(x + random(-8, 8), yy + random(-8, 8), 16, 16);
		}
	}
	
	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 170 + pow(ny, 1) * 68, 0.025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	
	let cx = width / 2;
	let cy = height / 1.45;
	let rr = height / 1.25;

	noStroke();
	fill(0, 0, 0, 1);
	ellipse(cx, cy, rr, rr);
	
	for (y = 0; y < 300; y += 1) {
		let cyy = y / 300;
		for (x = 0; x < 16; x += 1) {
			fill(random(190, 224), 255, random(220, 255), random(0.005, 0.125));
			ellipse(cx + sin(cyy * PI * 4) * (rr * 0.95), cy + cos(cyy * PI * 4) * (rr * 0.95), random(1, width), random(8, rr / 1.5));
		}
	}
	/*
	for (y = 0; y < 30000; y += 1) {
		let cyy = y / 30000;
		for (x = 0; x < 2; x += 1) {
			let rx = width / 32;
			let ry = height / 32;
			
			cy = height / 3.5;
			
			fill(random(0, 48), 255, random(220, 255), random(0.005, 0.025));
			ellipse(cx + random(-width, width), cy - rr / 5 * 0.2 + random(0, rr / 5), rx/2, ry/2);
			fill(random(48, 92), 255, random(220, 255), random(0.005, 0.025));
			ellipse(cx + random(-width, width), cy - rr / 5 * 0.4 + random(0, rr / 5), rx/2, ry/2);
			fill(random(150, 198), 255, random(220, 255), random(0.005, 0.025));
			ellipse(cx + random(-width, width), cy - rr / 5 * 0.6 + random(0, rr / 5), rx/2, ry/2);
			fill(random(192+48, 192+48*2), 255, random(220, 255), random(0.005, 0.025));
			ellipse(cx + random(-width, width), cy - rr / 5 * 0.8 + random(0, rr / 5), rx/2, ry/2);
			fill(random(192+48*2, 192+48*3), 255, random(220, 255), random(0.005, 0.025));
			ellipse(cx + random(0, width), cy - rr / 5 * 1.0 + random(0, rr / 5), rx/2, ry/2);
		}
	}
	*/
	cx = width / 2;
	cy = height / 1.45;
	rr = height / 1.25;
	
	/*
	for (y = 0; y < 1000; y += 1) {
		let cyy = y / 1000;
		for (x = 0; x < 128; x += 1) {
			fill(random(190, 224), 0, 255 * (x / 128), random(0.005, 0.25));
			ellipse(cx + sin(cyy * PI * 4) * (rr * 1.425), cy * (x / 128) + cos(cyy * PI * 4) * (rr * 0.95), 32, 32);
		}
	}*/

	for (y = 0; y < 20000; y += 1) {
		let cyy = y / 20000;
		for (x = 0; x < 2; x += 1) {
			if (random() > 0.95) {
				let cccx = cx + sin(cyy * PI * 2) * (rr / 0.45);
				stroke(220, random(0, 255), random(180, 255), random(0.05, 0.125));
				line(cccx + random(-32, 32), cy + random(-32, 32) - rr / 4.5 + cos(cyy * PI * 2) * (rr / 0.35), cx, height / 2.5);
			} else if (random() > 0.9) {
				let cccx = cx + sin(cyy * PI * 2) * (rr / 1.25);
				stroke(220, random(0, 255), random(192, 255), random(0.05, 0.125));
				line(cccx + random(-32, 32), cy + random(-32, 32) - rr / 4.5 + cos(cyy * PI * 2) * (rr / 1.0), cx, height / 2.5);
			} else if (random() > 0.5) {
				let cccx = cx + sin(cyy * PI * 2) * (rr / 2.05);
				stroke(0, 0, random(224, 255), random(0.05, 0.025));
				line(cccx + random(-32, 32), cy + random(-32, 32) - rr / 4.5 + cos(cyy * PI * 2) * (rr / 1.85), cx, height / 2.5);
			}
		}
	}
	
	//ellipse(cx + rr / 0.95, cy - rr / 2, rr / 6, rr / 6);
	//ellipse(cx + rr / 0.85, cy - rr / 2.3, rr / 20, rr / 20);
	/*for (y = -1; y < 16; y += 1) {
		let ny = y / 16;
		
		if (y == -1) {
			fill(0, 0, 255, 1);
			ellipse(cx - rr / 4, cy - rr / 2.5 * ny, rr / 4, rr / 4);
			ellipse(cx + rr / 4, cy - rr / 2.5 * ny, rr / 4, rr / 4);
		} else {
			fill(0, 0, 255 * (1 - ny), 0.25 * (1-ny));
			ellipse(cx - rr / 4, cy - rr / 2.5 * ny, rr / 4 * ny, rr / 4 * ny);
			ellipse(cx + rr / 4, cy - rr / 2.5 * ny, rr / 4 * ny, rr / 4 * ny);
		}
		//fill(random(0, 224), 128, 64 * (ny), 0.25 * (ny));
		//ellipse(cx + rr / 0.95, cy - rr / 2, rr / 6 * ny, rr / 6 * ny);
		//ellipse(cx + rr / 0.85, cy - rr / 2.3, rr / 20 * ny, rr / 20 * ny);
	}*/
	
	fill(0, 0, 255, 0.25);
	noStroke();
	rect(cx, cy - rr / 2.5, rr / 2, rr / 1.5);

	for (y = 0; y < 64; y += 1) {
		let ny = y / 64;
		
		fill(184 + 80 * pow(ny, 0.5),0, 16 * pow(ny, 0.5), 0.5 * (1-ny));
		//strokeWeight(width / 32 * ny);
		//noFill();
		rect(cx, cy - rr / 2.5, rr / 1.85 * ny, rr / 1.45 * ny);
	}
	noStroke();
strokeWeight(0.85);
/*
	fill(0, 0, 192, 1);
	ellipse(cx, cy - rr / 4.5, rr / 2.8, rr / 1.85);
	fill(224, 255, 200, 1);
	ellipse(cx, cy - rr / 4.5, rr / 2.9, rr / 2);

	for (y = 0; y < 32; y += 1) {
		let ny = 1 - y / 32;
		
		fill(random(200, 224), 255, 128 * (1 - ny), 0.05);
		ellipse(cx, cy - rr / 4.5 * pow(ny, 0.25), rr / 4 * ny, rr / 2);
		ellipse(cx, height - (cy - rr / 4.5 * pow(ny, 0.15)), rr / 4 * ny, rr / 2);
	}*/

	for (y = 0; y < height; y += 8) {
		let ny = y / height;
		for (x = 0; x < width; x += 8) {
			let nx = x / width;
			let n = noise(nx / 3, ny / 5);
			let n2 = noise(nx * 4, ny * 4);
			
			let yy = height - height / 24 + y - n * height;
			fill(120, 64 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 4.25 + ny * PI * 8 + 4.25))), 40 + pow(ny, 1) * 255, 1);
			stroke(0, 0, random(0, 255), random(0,0.15));
			//ellipse(x + random(-1, 1), yy + random(-1, 1), 18, 12 * ((1-ny) * 3));
			
			stroke(0, 0, random(0, 255), random(0,0.25));
			line(random(x - 4, x + 4), random(y - 4, y + 4), random(x - 4, x + 4), random(y - 4, y + 4));
		}
	}

	/*
	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 200 + pow(ny, 1) * 68, 0.1);
			line(x + random(-256, 256), yy, x + random(-256, 256), yy - random(32, height / 8));
		}
	}
*/
	
	for (y = height; y > 0; y -= 8) {
		for (x = 0; x < width; x += 8) {
			if (random() > 0.85) {
				stroke(0, 0, 0, random(0, 0.25));
				let xx = x + random(-4, 4);
				line(xx, y, xx + random(-1, 1), y + random(-1, 1));
			}
		}
	}

	for (y = 0; y < height / 2; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.05);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
	
	//fill(0, 0, 0, 1);
	//rect(width / 2, height / 2 - height / 2.5 / 2 + 40, width / 10, height / 2.5);
	
	let wl = 255 * (height / 976);
	let m = 0; // get max y
	for (y = 0; y < (height - m); y += 1) {
		let ny = y / height;
		let noy = noise(ny);
		
		for (x = 0; x < width; x += 1) {
			let yy = (height / 3.5 + noise(x / width) * 8) + y + m;
			
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = (0.5 - noise(nx, ny)) * 2;
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 0.5 + ny * PI * 1 + nox * PI * 2.15)) / 2 * nox2;
			
			//let ocx = cx + sin(nx * PI * 2) * (rr / 1.5);
			//let ocy = (cy - rr / 4.5) + cos(ny * PI * 2) * (rr / 1.25);
			
			if (random() > 0.1 && isInsideEllipse(cx, (cy - rr / 2.5), x, yy, (rr / 2) / 2.0, (rr / 1.5) / 2) > 1) {
				
				let xx = x + random(-2, 2);
				let yh2 = random(-height / 2, height / 2) * n * ny;
				noStroke();
				/*
				if (random() > 0.996 && n > 0.05) {
					fill(64, 64, 48, 1);
					rect(xx, yy - yh2, random(2, 8) * ny, 48 * ny);
				}
				*/
				stroke(224 + (nox2) * 48, 100 * nox3, (200*nox3-random(200) * n), random() * 0.45 * pow(ny, 0.93));
				line(xx, yy, xx + random(-width / 5, width / 5) * n * noy * ny, yy + yh2);
			}
		}
	}
	/*
	for (x = 0; x < 8; x += 1) {
		let xx = random(0, width);
		let yy = random(height / 2, height);
		for (y = 0; y < 100; y += 1) {
			let ny = y / 100;
			
			noStroke();
			fill(110, 255, 10, 0.05);
			ellipse(xx + random(-32, 32) * ny, yy + 100 * ny, random(1, 64), random(1, 64));
		}
	}*/
}"
"911452","Mono","mySketch","function setup() {
	createCanvas(windowWidth, windowHeight);
	
	noStroke();
	
	background(0);
	
	colorMode(HSL, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	generate();
}

function draw() {
	
}

function isInsideEllipse(h, k, x, y, a, b) {
   return (pow((x - h), 2) / pow(a, 2)) + (pow((y - k), 2) / pow(b, 2));
}

function generate() {
	noStroke();
	
	background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 24, ny / 24);
			let n2 = noise(nx / 8, ny / 8);
			
			let yy = height / 3.9 + y - n * height;
			fill(60 - 30 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 2 + 0.25))), 0, 148 + pow(ny, 1) * 200, random(0.15, 0.25));
			stroke(0, 0, random(0, 128), random(0,0.025));
			ellipse(x + random(-8, 8), yy + random(-8, 8), 16, 16);
		}
	}
	
	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 170 + pow(ny, 1) * 68, 0.025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	
	let cx = width / 2;
	let cy = height / 1.45;
	let rr = height / 1.25;

	noStroke();
	fill(0, 0, 0, 1);
	ellipse(cx, cy, rr, rr);
	
	for (y = 0; y < 300; y += 1) {
		let cyy = y / 300;
		for (x = 0; x < 16; x += 1) {
			fill(random(190, 224), 255, random(220, 255), random(0.005, 0.125));
			ellipse(cx + sin(cyy * PI * 4) * (rr * 0.95), cy + cos(cyy * PI * 4) * (rr * 0.95), random(1, width), random(8, rr / 1.5));
		}
	}
	/*
	for (y = 0; y < 30000; y += 1) {
		let cyy = y / 30000;
		for (x = 0; x < 2; x += 1) {
			let rx = width / 32;
			let ry = height / 32;
			
			cy = height / 3.5;
			
			fill(random(0, 48), 255, random(220, 255), random(0.005, 0.025));
			ellipse(cx + random(-width, width), cy - rr / 5 * 0.2 + random(0, rr / 5), rx/2, ry/2);
			fill(random(48, 92), 255, random(220, 255), random(0.005, 0.025));
			ellipse(cx + random(-width, width), cy - rr / 5 * 0.4 + random(0, rr / 5), rx/2, ry/2);
			fill(random(150, 198), 255, random(220, 255), random(0.005, 0.025));
			ellipse(cx + random(-width, width), cy - rr / 5 * 0.6 + random(0, rr / 5), rx/2, ry/2);
			fill(random(192+48, 192+48*2), 255, random(220, 255), random(0.005, 0.025));
			ellipse(cx + random(-width, width), cy - rr / 5 * 0.8 + random(0, rr / 5), rx/2, ry/2);
			fill(random(192+48*2, 192+48*3), 255, random(220, 255), random(0.005, 0.025));
			ellipse(cx + random(0, width), cy - rr / 5 * 1.0 + random(0, rr / 5), rx/2, ry/2);
		}
	}
	*/
	cx = width / 2;
	cy = height / 1.45;
	rr = height / 1.25;
	
	/*
	for (y = 0; y < 1000; y += 1) {
		let cyy = y / 1000;
		for (x = 0; x < 128; x += 1) {
			fill(random(190, 224), 0, 255 * (x / 128), random(0.005, 0.25));
			ellipse(cx + sin(cyy * PI * 4) * (rr * 1.425), cy * (x / 128) + cos(cyy * PI * 4) * (rr * 0.95), 32, 32);
		}
	}*/

	for (y = 0; y < 20000; y += 1) {
		let cyy = y / 20000;
		for (x = 0; x < 2; x += 1) {
			if (random() > 0.95) {
				let cccx = cx + sin(cyy * PI * 2) * (rr / 0.45);
				stroke(220, random(0, 255), random(180, 255), random(0.05, 0.125));
				line(cccx + random(-32, 32), cy + random(-32, 32) - rr / 4.5 + cos(cyy * PI * 2) * (rr / 0.35), cx, height / 2.5);
			} else if (random() > 0.9) {
				let cccx = cx + sin(cyy * PI * 2) * (rr / 1.25);
				stroke(220, random(0, 255), random(192, 255), random(0.05, 0.125));
				line(cccx + random(-32, 32), cy + random(-32, 32) - rr / 4.5 + cos(cyy * PI * 2) * (rr / 1.0), cx, height / 2.5);
			} else if (random() > 0.5) {
				let cccx = cx + sin(cyy * PI * 2) * (rr / 2.05);
				stroke(0, 0, random(224, 255), random(0.05, 0.025));
				line(cccx + random(-32, 32), cy + random(-32, 32) - rr / 4.5 + cos(cyy * PI * 2) * (rr / 1.85), cx, height / 2.5);
			}
		}
	}
	
	//ellipse(cx + rr / 0.95, cy - rr / 2, rr / 6, rr / 6);
	//ellipse(cx + rr / 0.85, cy - rr / 2.3, rr / 20, rr / 20);
	/*for (y = -1; y < 16; y += 1) {
		let ny = y / 16;
		
		if (y == -1) {
			fill(0, 0, 255, 1);
			ellipse(cx - rr / 4, cy - rr / 2.5 * ny, rr / 4, rr / 4);
			ellipse(cx + rr / 4, cy - rr / 2.5 * ny, rr / 4, rr / 4);
		} else {
			fill(0, 0, 255 * (1 - ny), 0.25 * (1-ny));
			ellipse(cx - rr / 4, cy - rr / 2.5 * ny, rr / 4 * ny, rr / 4 * ny);
			ellipse(cx + rr / 4, cy - rr / 2.5 * ny, rr / 4 * ny, rr / 4 * ny);
		}
		//fill(random(0, 224), 128, 64 * (ny), 0.25 * (ny));
		//ellipse(cx + rr / 0.95, cy - rr / 2, rr / 6 * ny, rr / 6 * ny);
		//ellipse(cx + rr / 0.85, cy - rr / 2.3, rr / 20 * ny, rr / 20 * ny);
	}*/
	
	fill(0, 0, 255, 0.25);
	noStroke();
	rect(cx, cy - rr / 2.5, rr / 2, rr / 1.5);

	for (y = 0; y < 64; y += 1) {
		let ny = y / 64;
		
		fill(184 + 80 * pow(ny, 0.5),0, 16 * pow(ny, 0.5), 0.5 * (1-ny));
		//strokeWeight(width / 32 * ny);
		//noFill();
		rect(cx, cy - rr / 2.5, rr / 1.85 * ny, rr / 1.45 * ny);
	}
	noStroke();
strokeWeight(0.85);
/*
	fill(0, 0, 192, 1);
	ellipse(cx, cy - rr / 4.5, rr / 2.8, rr / 1.85);
	fill(224, 255, 200, 1);
	ellipse(cx, cy - rr / 4.5, rr / 2.9, rr / 2);

	for (y = 0; y < 32; y += 1) {
		let ny = 1 - y / 32;
		
		fill(random(200, 224), 255, 128 * (1 - ny), 0.05);
		ellipse(cx, cy - rr / 4.5 * pow(ny, 0.25), rr / 4 * ny, rr / 2);
		ellipse(cx, height - (cy - rr / 4.5 * pow(ny, 0.15)), rr / 4 * ny, rr / 2);
	}*/

	for (y = 0; y < height; y += 8) {
		let ny = y / height;
		for (x = 0; x < width; x += 8) {
			let nx = x / width;
			let n = noise(nx / 3, ny / 5);
			let n2 = noise(nx * 4, ny * 4);
			
			let yy = height - height / 24 + y - n * height;
			fill(120, 64 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 4.25 + ny * PI * 8 + 4.25))), 40 + pow(ny, 1) * 255, 1);
			stroke(0, 0, random(0, 255), random(0,0.15));
			//ellipse(x + random(-1, 1), yy + random(-1, 1), 18, 12 * ((1-ny) * 3));
			
			stroke(0, 0, random(0, 255), random(0,0.25));
			line(random(x - 4, x + 4), random(y - 4, y + 4), random(x - 4, x + 4), random(y - 4, y + 4));
		}
	}

	/*
	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 200 + pow(ny, 1) * 68, 0.1);
			line(x + random(-256, 256), yy, x + random(-256, 256), yy - random(32, height / 8));
		}
	}
*/
	
	for (y = height; y > 0; y -= 8) {
		for (x = 0; x < width; x += 8) {
			if (random() > 0.85) {
				stroke(0, 0, 0, random(0, 0.25));
				let xx = x + random(-4, 4);
				line(xx, y, xx + random(-1, 1), y + random(-1, 1));
			}
		}
	}

	for (y = 0; y < height / 2; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.05);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
	
	//fill(0, 0, 0, 1);
	//rect(width / 2, height / 2 - height / 2.5 / 2 + 40, width / 10, height / 2.5);
	
	let wl = 255 * (height / 976);
	let m = 0; // get max y
	for (y = 0; y < (height - m); y += 1) {
		let ny = y / height;
		let noy = noise(ny);
		
		for (x = 0; x < width; x += 1) {
			let yy = (height / 3.5 + noise(x / width) * 8) + y + m;
			
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = (0.5 - noise(nx, ny)) * 2;
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 0.5 + ny * PI * 1 + nox * PI * 2.15)) / 2 * nox2;
			
			//let ocx = cx + sin(nx * PI * 2) * (rr / 1.5);
			//let ocy = (cy - rr / 4.5) + cos(ny * PI * 2) * (rr / 1.25);
			
			if (random() > 0.1 && isInsideEllipse(cx, (cy - rr / 2.5), x, yy, (rr / 2) / 2.0, (rr / 1.5) / 2) > 1) {
				
				let xx = x + random(-2, 2);
				let yh2 = random(-height / 2, height / 2) * n * ny;
				noStroke();
				/*
				if (random() > 0.996 && n > 0.05) {
					fill(64, 64, 48, 1);
					rect(xx, yy - yh2, random(2, 8) * ny, 48 * ny);
				}
				*/
				// 100 * nox3
				stroke(224 + (nox2) * 48, 0 * nox3, (200*nox3-random(200) * n), random() * 0.45 * pow(ny, 0.93));
				line(xx, yy, xx + random(-width / 5, width / 5) * n * noy * ny, yy + yh2);
			}
		}
	}
	/*
	for (x = 0; x < 8; x += 1) {
		let xx = random(0, width);
		let yy = random(height / 2, height);
		for (y = 0; y < 100; y += 1) {
			let ny = y / 100;
			
			noStroke();
			fill(110, 255, 10, 0.05);
			ellipse(xx + random(-32, 32) * ny, yy + 100 * ny, random(1, 64), random(1, 64));
		}
	}*/
}"
"911452","Mono","mySketch","function setup() {
	createCanvas(windowWidth, windowHeight);
	
	noStroke();
	
	background(0);
	
	colorMode(HSL, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	generate();
}

function draw() {
	
}

function isInsideEllipse(h, k, x, y, a, b) {
   return (pow((x - h), 2) / pow(a, 2)) + (pow((y - k), 2) / pow(b, 2));
}

function generate() {
	noStroke();
	
	background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 24, ny / 24);
			let n2 = noise(nx / 8, ny / 8);
			
			let yy = height / 3.9 + y - n * height;
			fill(60 - 30 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 2 + 0.25))), 0, 148 + pow(ny, 1) * 200, random(0.15, 0.25));
			stroke(0, 0, random(0, 128), random(0,0.025));
			ellipse(x + random(-8, 8), yy + random(-8, 8), 16, 16);
		}
	}
	
	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 170 + pow(ny, 1) * 68, 0.025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	
	let cx = width / 2;
	let cy = height / 1.45;
	let rr = height / 1.25;

	noStroke();
	fill(0, 0, 0, 1);
	ellipse(cx, cy, rr, rr);
	
	for (y = 0; y < 300; y += 1) {
		let cyy = y / 300;
		for (x = 0; x < 16; x += 1) {
			fill(random(190, 224), 255, random(220, 255), random(0.005, 0.125));
			ellipse(cx + sin(cyy * PI * 4) * (rr * 0.95), cy + cos(cyy * PI * 4) * (rr * 0.95), random(1, width), random(8, rr / 1.5));
		}
	}
	/*
	for (y = 0; y < 300; y += 1) {
		let cyy = y / 300;
		for (x = 0; x < 16; x += 1) {
			fill(random(0, 60), 255, random(128, 255), random(0.005, 0.725));
			ellipse(cx + sin(cyy * PI * 2) * (rr * 1.5), (cy - rr / 4.5) + cos(cyy * PI * 2) * (rr * 1.5), random(32), random(32));
		}
	}*/

	for (y = 0; y < 20000; y += 1) {
		let cyy = y / 20000;
		for (x = 0; x < 2; x += 1) {
			stroke(220, random(0, 255), random(0, 255), random(0.05, 0.025));
			let cccx = cx + sin(cyy * PI * 2) * (rr / 2.25);
			line(cccx + random(-32, 32), cy + random(-32, 32) - rr / 4.5 + cos(cyy * PI * 2) * (rr / 1.65), cx, height / 2.5);
		}
	}
	
	//ellipse(cx + rr / 0.95, cy - rr / 2, rr / 6, rr / 6);
	//ellipse(cx + rr / 0.85, cy - rr / 2.3, rr / 20, rr / 20);
	/*for (y = -1; y < 16; y += 1) {
		let ny = y / 16;
		
		if (y == -1) {
			fill(0, 0, 255, 1);
			ellipse(cx - rr / 4, cy - rr / 2.5 * ny, rr / 4, rr / 4);
			ellipse(cx + rr / 4, cy - rr / 2.5 * ny, rr / 4, rr / 4);
		} else {
			fill(0, 0, 255 * (1 - ny), 0.25 * (1-ny));
			ellipse(cx - rr / 4, cy - rr / 2.5 * ny, rr / 4 * ny, rr / 4 * ny);
			ellipse(cx + rr / 4, cy - rr / 2.5 * ny, rr / 4 * ny, rr / 4 * ny);
		}
		//fill(random(0, 224), 128, 64 * (ny), 0.25 * (ny));
		//ellipse(cx + rr / 0.95, cy - rr / 2, rr / 6 * ny, rr / 6 * ny);
		//ellipse(cx + rr / 0.85, cy - rr / 2.3, rr / 20 * ny, rr / 20 * ny);
	}*/
	
	fill(0, 0, 255, 1);
	noStroke();
	ellipse(cx, cy - rr / 4.5, rr / 1.5, rr / 1.25);
	
	for (y = 0; y < 64; y += 1) {
		let ny = y / 64;
		
		fill(0, 0, 224 + 30 * (1 - ny), 0.75 * (1-ny));
		ellipse(cx, cy - rr / 5.5, rr / 1.5 * ny, rr / 1.25 * ny);
	}

	fill(0, 0, 192, 1);
	ellipse(cx, cy - rr / 4.5, rr / 2.8, rr / 1.85);
	fill(224, 255, 200, 1);
	ellipse(cx, cy - rr / 4.5, rr / 2.9, rr / 2);

	for (y = 0; y < 32; y += 1) {
		let ny = 1 - y / 32;
		
		fill(random(200, 224), 255, 128 * (1 - ny), 0.05);
		ellipse(cx, cy - rr / 4.5 * pow(ny, 0.25), rr / 4 * ny, rr / 2);
		ellipse(cx, height - (cy - rr / 4.5 * pow(ny, 0.15)), rr / 4 * ny, rr / 2);
	}
/*
	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 3, ny / 5);
			let n2 = noise(nx * 4, ny * 4);
			
			let yy = height - height / 24 + y - n * height;
			fill(120, 64 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 4.25 + ny * PI * 8 + 4.25))), 40 + pow(ny, 1) * 255, 1);
			stroke(0, 0, random(0, 255), random(0,0.15));
			//ellipse(x + random(-1, 1), yy + random(-1, 1), 18, 12 * ((1-ny) * 3));
			
			stroke(0, 0, random(0, 255), random(0,0.25));
			line(random(x - 4, x + 4), random(y - 4, y + 4), random(x - 4, x + 4), random(y - 4, y + 4));
		}
	}
*/
	/*
	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 200 + pow(ny, 1) * 68, 0.1);
			line(x + random(-256, 256), yy, x + random(-256, 256), yy - random(32, height / 8));
		}
	}
*/
	
	for (y = height; y > 0; y -= 8) {
		for (x = 0; x < width; x += 8) {
			if (random() > 0.85) {
				stroke(0, 0, 0, random(0, 0.25));
				let xx = x + random(-4, 4);
				line(xx, y, xx + random(-1, 1), y + random(-1, 1));
			}
		}
	}

	for (y = 0; y < height / 2; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.05);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
	
	//fill(0, 0, 0, 1);
	//rect(width / 2, height / 2 - height / 2.5 / 2 + 40, width / 10, height / 2.5);
	
	let wl = 255 * (height / 976);
	let m = 0; // get max y
	for (y = 0; y < (height - m); y += 1) {
		let ny = y / height;
		let noy = noise(ny);
		
		for (x = 0; x < width; x += 1) {
			let yy = (height / 3.5 + noise(x / width) * 8) + y + m;
			
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = (0.5 - noise(nx, ny)) * 2;
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 0.5 + ny * PI * 1 + nox * PI * 2.15)) / 2 * nox2;
			
			//let ocx = cx + sin(nx * PI * 2) * (rr / 1.5);
			//let ocy = (cy - rr / 4.5) + cos(ny * PI * 2) * (rr / 1.25);
			
			if (random() > 0.1 && isInsideEllipse(cx, (cy - rr / 4.5), x, yy, (rr / 1.5) / 2, (rr / 1.25) / 2) > 1) {
				
				let xx = x + random(-2, 2);
				let yh2 = random(-400, 400) * n * ny;
				noStroke();
				/*
				if (random() > 0.996 && n > 0.05) {
					fill(64, 64, 48, 1);
					rect(xx, yy - yh2, random(2, 8) * ny, 48 * ny);
				}
				*/
				stroke(224 + (nox2) * 48, 100 * nox3, (200*nox3-random(200) * n), random() * 0.45 * pow(ny, 0.93));
				line(xx, yy, xx + random(-200, 200) * n * noy * ny, yy + yh2);
			}
		}
	}
	/*
	for (x = 0; x < 8; x += 1) {
		let xx = random(0, width);
		let yy = random(height / 2, height);
		for (y = 0; y < 100; y += 1) {
			let ny = y / 100;
			
			noStroke();
			fill(110, 255, 10, 0.05);
			ellipse(xx + random(-32, 32) * ny, yy + 100 * ny, random(1, 64), random(1, 64));
		}
	}*/
}"
"911452","Mono","mySketch","function setup() {
	createCanvas(windowWidth, windowHeight);
	
	noStroke();
	
	background(0);
	
	colorMode(HSL, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	generate();
}

function draw() {
	
}

function isInsideEllipse(h, k, x, y, a, b) {
   return (pow((x - h), 2) / pow(a, 2)) + (pow((y - k), 2) / pow(b, 2));
}

function generate() {
	noStroke();
	
	background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 24, ny / 24);
			let n2 = noise(nx / 8, ny / 8);
			
			let yy = height / 3.9 + y - n * height;
			fill(60 - 30 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 2 + 0.25))), 0, 148 + pow(ny, 1) * 200, random(0.15, 0.25));
			stroke(0, 0, random(0, 128), random(0,0.025));
			ellipse(x + random(-8, 8), yy + random(-8, 8), 16, 16);
		}
	}
	
	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 170 + pow(ny, 1) * 68, 0.025);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	
	let cx = width / 2;
	let cy = height / 1.45;
	let rr = height / 1.25;

	noStroke();
	fill(0, 0, 0, 1);
	ellipse(cx, cy, rr, rr);
	
	for (y = 0; y < 300; y += 1) {
		let cyy = y / 300;
		for (x = 0; x < 16; x += 1) {
			fill(random(190, 224), 255, random(220, 255), random(0.005, 0.125));
			ellipse(cx + sin(cyy * PI * 4) * (rr * 0.95), cy + cos(cyy * PI * 4) * (rr * 0.95), random(1, width), random(8, rr / 1.5));
		}
	}
	/*
	for (y = 0; y < 300; y += 1) {
		let cyy = y / 300;
		for (x = 0; x < 16; x += 1) {
			fill(random(0, 60), 255, random(128, 255), random(0.005, 0.725));
			ellipse(cx + sin(cyy * PI * 2) * (rr * 1.5), (cy - rr / 4.5) + cos(cyy * PI * 2) * (rr * 1.5), random(32), random(32));
		}
	}*/

	for (y = 0; y < 20000; y += 1) {
		let cyy = y / 20000;
		for (x = 0; x < 2; x += 1) {
			stroke(220, random(0, 255), random(0, 255), random(0.05, 0.025));
			let cccx = cx + sin(cyy * PI * 2) * (rr / 2.25);
			line(cccx + random(-32, 32), cy + random(-32, 32) - rr / 4.5 + cos(cyy * PI * 2) * (rr / 1.65), cx, height / 2.5);
		}
	}
	
	//ellipse(cx + rr / 0.95, cy - rr / 2, rr / 6, rr / 6);
	//ellipse(cx + rr / 0.85, cy - rr / 2.3, rr / 20, rr / 20);
	/*for (y = -1; y < 16; y += 1) {
		let ny = y / 16;
		
		if (y == -1) {
			fill(0, 0, 255, 1);
			ellipse(cx - rr / 4, cy - rr / 2.5 * ny, rr / 4, rr / 4);
			ellipse(cx + rr / 4, cy - rr / 2.5 * ny, rr / 4, rr / 4);
		} else {
			fill(0, 0, 255 * (1 - ny), 0.25 * (1-ny));
			ellipse(cx - rr / 4, cy - rr / 2.5 * ny, rr / 4 * ny, rr / 4 * ny);
			ellipse(cx + rr / 4, cy - rr / 2.5 * ny, rr / 4 * ny, rr / 4 * ny);
		}
		//fill(random(0, 224), 128, 64 * (ny), 0.25 * (ny));
		//ellipse(cx + rr / 0.95, cy - rr / 2, rr / 6 * ny, rr / 6 * ny);
		//ellipse(cx + rr / 0.85, cy - rr / 2.3, rr / 20 * ny, rr / 20 * ny);
	}*/
	
	fill(0, 0, 255, 1);
	noStroke();
	ellipse(cx, cy - rr / 4.5, rr / 1.5, rr / 1.25);
	
	for (y = 0; y < 64; y += 1) {
		let ny = y / 64;
		
		fill(0, 0, 224 + 30 * (1 - ny), 0.75 * (1-ny));
		ellipse(cx, cy - rr / 5.5, rr / 1.5 * ny, rr / 1.25 * ny);
	}

	fill(0, 0, 192, 1);
	ellipse(cx, cy - rr / 4.5, rr / 2.8, rr / 1.85);
	fill(224, 255, 200, 1);
	ellipse(cx, cy - rr / 4.5, rr / 2.9, rr / 2);

	for (y = 0; y < 32; y += 1) {
		let ny = 1 - y / 32;
		
		fill(random(200, 224), 255, 128 * (1 - ny), 0.05);
		ellipse(cx, cy - rr / 4.5 * pow(ny, 0.25), rr / 4 * ny, rr / 2);
		ellipse(cx, height - (cy - rr / 4.5 * pow(ny, 0.15)), rr / 4 * ny, rr / 2);
	}
/*
	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 3, ny / 5);
			let n2 = noise(nx * 4, ny * 4);
			
			let yy = height - height / 24 + y - n * height;
			fill(120, 64 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 4.25 + ny * PI * 8 + 4.25))), 40 + pow(ny, 1) * 255, 1);
			stroke(0, 0, random(0, 255), random(0,0.15));
			//ellipse(x + random(-1, 1), yy + random(-1, 1), 18, 12 * ((1-ny) * 3));
			
			stroke(0, 0, random(0, 255), random(0,0.25));
			line(random(x - 4, x + 4), random(y - 4, y + 4), random(x - 4, x + 4), random(y - 4, y + 4));
		}
	}
*/
	/*
	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 200 + pow(ny, 1) * 68, 0.1);
			line(x + random(-256, 256), yy, x + random(-256, 256), yy - random(32, height / 8));
		}
	}
*/
	
	for (y = height; y > 0; y -= 8) {
		for (x = 0; x < width; x += 8) {
			if (random() > 0.85) {
				stroke(0, 0, 0, random(0, 0.25));
				let xx = x + random(-4, 4);
				line(xx, y, xx + random(-1, 1), y + random(-1, 1));
			}
		}
	}

	for (y = 0; y < height / 2; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.05);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
	
	//fill(0, 0, 0, 1);
	//rect(width / 2, height / 2 - height / 2.5 / 2 + 40, width / 10, height / 2.5);
	
	let wl = 255 * (height / 976);
	let m = 0; // get max y
	for (y = 0; y < (height - m); y += 1) {
		let ny = y / height;
		let noy = noise(ny);
		
		for (x = 0; x < width; x += 1) {
			let yy = (height / 3.5 + noise(x / width) * 8) + y + m;
			
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = (0.5 - noise(nx, ny)) * 2;
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 0.5 + ny * PI * 1 + nox * PI * 2.15)) / 2 * nox2;
			
			//let ocx = cx + sin(nx * PI * 2) * (rr / 1.5);
			//let ocy = (cy - rr / 4.5) + cos(ny * PI * 2) * (rr / 1.25);
			
			if (random() > 0.1 && isInsideEllipse(cx, (cy - rr / 4.5), x, yy, (rr / 1.5) / 2, (rr / 1.25) / 2) > 1) {
				
				let xx = x + random(-2, 2);
				let yh2 = random(-400, 400) * n * ny;
				noStroke();
				/*
				if (random() > 0.996 && n > 0.05) {
					fill(64, 64, 48, 1);
					rect(xx, yy - yh2, random(2, 8) * ny, 48 * ny);
				}
				*/
				stroke(224 + (nox2) * 48, 100 * nox3, (200*nox3-random(200) * n), random() * 0.45 * pow(ny, 0.93));
				line(xx, yy, xx + random(-200, 200) * n * noy * ny, yy + yh2);
			}
		}
	}
	/*
	for (x = 0; x < 8; x += 1) {
		let xx = random(0, width);
		let yy = random(height / 2, height);
		for (y = 0; y < 100; y += 1) {
			let ny = y / 100;
			
			noStroke();
			fill(110, 255, 10, 0.05);
			ellipse(xx + random(-32, 32) * ny, yy + 100 * ny, random(1, 64), random(1, 64));
		}
	}*/
}"
"909934","Melnorme invert","mySketch","function setup() {
	createCanvas(windowWidth, windowHeight);
	
	noStroke();
	
	background(0);
	
	colorMode(HSL, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	generate();
}

function draw() {
	
}

function generate() {
	noStroke();
	
	background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 24, ny / 24);
			let n2 = noise(nx / 8, ny / 8);
			
			let yy = height / 3.9 + y - n * height;
			fill(60 - 30 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 2 + 0.25))), 0, 148 + pow(ny, 1) * 200, random(0.15, 0.25));
			stroke(0, 0, random(0, 128), random(0,0.025));
			ellipse(x + random(-8, 8), yy + random(-8, 8), 16, 16);
		}
	}
	
	let cx = width / 2;
	let cy = height / 1.95;
	let rr = height / 1.25;
	
	noStroke();
	fill(0, 0, 0, 1);
	ellipse(cx, cy, rr, rr);
	
	for (y = 0; y < 300; y += 1) {
		let cyy = y / 300;
		for (x = 0; x < 16; x += 1) {
			fill(random(190, 224), 255, random(224, 255), random(0.005, 0.025));
			ellipse(cx + sin(cyy * PI * 2) * (rr * 0.5), cy + cos(cyy * PI * 2) * (rr * 0.5), random(1, width), random(8, rr / 1.5));
		}
	}
	
	fill(0, 0, 255, 1);
	ellipse(cx - rr / 4, cy- rr / 2.5, rr / 4, rr / 4);
	ellipse(cx + rr / 4, cy - rr / 2.5, rr / 4, rr / 4);
	ellipse(cx + rr / 0.95, cy - rr / 2, rr / 6, rr / 6);
	ellipse(cx + rr / 0.85, cy - rr / 2.3, rr / 20, rr / 20);
	for (y = 0; y < 16; y += 1) {
		let ny = y / 16;
		
		fill(0, 0, 255 * (1 - ny), 0.25 * (1-ny));
		ellipse(cx - rr / 4, cy - rr / 2.5, rr / 4 * ny, rr / 4 * ny);
		ellipse(cx + rr / 4, cy - rr / 2.5, rr / 4 * ny, rr / 4 * ny);
		fill(random(0, 224), 128, 64 * (ny), 0.25 * (ny));
		ellipse(cx + rr / 0.95, cy - rr / 2, rr / 6 * ny, rr / 6 * ny);
		ellipse(cx + rr / 0.85, cy - rr / 2.3, rr / 20 * ny, rr / 20 * ny);
	}
	
	for (y = 0; y < 300; y += 1) {
		let cyy = y / 300;
		for (x = 0; x < 2; x += 1) {
			stroke(220, 0, random(0, 255), random(0.05, 0.25));
			let cccx = cx + sin(cyy * PI * 2) * (rr / 0.5);
			line(cccx + random(-8, 8), cy - rr / 4.5 + cos(cyy * PI * 2) * (rr / 1.5), cx, height / 1.5);
		}
	}
	
	fill(0, 0, 255, 1);
	noStroke();
	ellipse(cx, cy - rr / 4.5, rr / 1.5, rr / 1.25);
	
	for (y = 0; y < 64; y += 1) {
		let ny = y / 64;
		
		fill(0, 0, 224 + 30 * (1 - ny), 0.75 * (1-ny));
		ellipse(cx, cy - rr / 5.5, rr / 1.5 * ny, rr / 1.25 * ny);
	}
	
	fill(0, 0, 192, 1);
	rect(cx, cy - rr / 4.5, rr / 3.8, rr / 1.85);
	fill(224, 255, 200, 1);
	rect(cx, cy - rr / 4.5, rr / 4, rr / 2);

	for (y = 0; y < 32; y += 1) {
		let ny = 1 - y / 32;
		
		fill(random(212, 224), 255, 0 + 55 * (1 - ny), 0.75);
		rect(cx, cy - rr / 4.5 * pow(ny, 0.25), rr / 4, rr / 2 * ny);
	}
	
	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 3, ny / 5);
			let n2 = noise(nx * 4, ny * 4);
			
			let yy = height - height / 24 + y - n * height;
			fill(120, 64 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 4.25 + ny * PI * 8 + 4.25))), 40 + pow(ny, 1) * 255, 1);
			stroke(0, 0, random(0, 255), random(0,0.15));
			ellipse(x + random(-1, 1), yy + random(-1, 1), 18, 12 * ((1-ny) * 3));
			
			stroke(0, 0, random(0, 255), random(0,0.25));
			line(random(x - 4, x + 4), random(y - 4, y + 4), random(x - 4, x + 4), random(y - 4, y + 4));
		}
	}
	
	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 200 + pow(ny, 1) * 68, 0.1);
			line(x + random(-256, 256), yy, x + random(-256, 256), yy - random(32, height / 8));
		}
	}
	
	for (y = height; y > 0; y -= 8) {
		for (x = 0; x < width; x += 8) {
			if (random() > 0.85) {
				stroke(0, 0, 0, random(0, 0.25));
				let xx = x + random(-4, 4);
				line(xx, y, xx + random(-1, 1), y + random(-1, 1));
			}
		}
	}

	for (y = 0; y < height / 2; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.05);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
	
	//fill(0, 0, 0, 1);
	//rect(width / 2, height / 2 - height / 2.5 / 2 + 40, width / 10, height / 2.5);
	
	let wl = 255 * (height / 976);
	let m = 0; // get max y
	for (y = 0; y < (height - m); y += 1) {
		let ny = y / height;
		let noy = noise(ny);
		
		for (x = 0; x < width; x += 1) {
			let yy = (height / 2 + noise(x / width) * 8) + y + m;
			
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = (0.5 - noise(nx, ny)) * 2;
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 0.5 + ny * PI * 1 + nox * PI * 2.15)) / 2 * nox2;
			
			if (random() > 0.15) {
				
				let xx = x + random(-2, 2);
				let yh2 = random(-200, 200) * n * ny;
				noStroke();
				
				if (random() > 0.996 && n > 0.05) {
					fill(64, 64, 48, 1);
					rect(xx, yy - yh2, random(2, 8) * ny, 48 * ny);
				}
				
				stroke(128 + (nox2) * 8, 100 * nox3, (200*nox3-random(200) * n), random() * 0.45 * pow(ny, 0.3));
				line(xx, yy, xx + random(-200, 200) * n * noy * ny, yy + yh2);
			}
		}
	}
	
	filter(INVERT);
	
	/*
	for (x = 0; x < 8; x += 1) {
		let xx = random(0, width);
		let yy = random(height / 2, height);
		for (y = 0; y < 100; y += 1) {
			let ny = y / 100;
			
			noStroke();
			fill(110, 255, 10, 0.05);
			ellipse(xx + random(-32, 32) * ny, yy + 100 * ny, random(1, 64), random(1, 64));
		}
	}*/
}"
"909908","Melnorme","mySketch","function setup() {
	createCanvas(windowWidth, windowHeight);
	
	noStroke();
	
	background(0);
	
	colorMode(HSL, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	generate();
}

function draw() {
	
}

function generate() {
	noStroke();
	
	background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 24, ny / 24);
			let n2 = noise(nx / 8, ny / 8);
			
			let yy = height / 3.9 + y - n * height;
			fill(60 - 30 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 2 + 0.25))), 0, 148 + pow(ny, 1) * 200, random(0.15, 0.25));
			stroke(0, 0, random(0, 128), random(0,0.025));
			ellipse(x + random(-8, 8), yy + random(-8, 8), 16, 16);
		}
	}
	
	let cx = width / 2;
	let cy = height / 1.95;
	let rr = height / 1.25;
	
	noStroke();
	fill(0, 0, 0, 1);
	ellipse(cx, cy, rr, rr);
	
	for (y = 0; y < 300; y += 1) {
		let cyy = y / 300;
		for (x = 0; x < 16; x += 1) {
			fill(random(190, 224), 255, random(224, 255), random(0.005, 0.025));
			ellipse(cx + sin(cyy * PI * 2) * (rr * 0.5), cy + cos(cyy * PI * 2) * (rr * 0.5), random(1, width), random(8, rr / 1.5));
		}
	}
	
	fill(0, 0, 255, 1);
	ellipse(cx - rr / 4, cy- rr / 2.5, rr / 4, rr / 4);
	ellipse(cx + rr / 4, cy - rr / 2.5, rr / 4, rr / 4);
	ellipse(cx + rr / 0.95, cy - rr / 2, rr / 6, rr / 6);
	ellipse(cx + rr / 0.85, cy - rr / 2.3, rr / 20, rr / 20);
	for (y = 0; y < 16; y += 1) {
		let ny = y / 16;
		
		fill(0, 0, 255 * (1 - ny), 0.25 * (1-ny));
		ellipse(cx - rr / 4, cy - rr / 2.5, rr / 4 * ny, rr / 4 * ny);
		ellipse(cx + rr / 4, cy - rr / 2.5, rr / 4 * ny, rr / 4 * ny);
		fill(random(0, 224), 128, 64 * (ny), 0.25 * (ny));
		ellipse(cx + rr / 0.95, cy - rr / 2, rr / 6 * ny, rr / 6 * ny);
		ellipse(cx + rr / 0.85, cy - rr / 2.3, rr / 20 * ny, rr / 20 * ny);
	}
	
	for (y = 0; y < 300; y += 1) {
		let cyy = y / 300;
		for (x = 0; x < 2; x += 1) {
			stroke(220, 0, random(0, 255), random(0.05, 0.25));
			let cccx = cx + sin(cyy * PI * 2) * (rr / 0.5);
			line(cccx + random(-8, 8), cy - rr / 4.5 + cos(cyy * PI * 2) * (rr / 1.5), cx, height / 1.5);
		}
	}
	
	fill(0, 0, 255, 1);
	noStroke();
	ellipse(cx, cy - rr / 4.5, rr / 1.5, rr / 1.25);
	
	for (y = 0; y < 64; y += 1) {
		let ny = y / 64;
		
		fill(0, 0, 224 + 30 * (1 - ny), 0.75 * (1-ny));
		ellipse(cx, cy - rr / 5.5, rr / 1.5 * ny, rr / 1.25 * ny);
	}
	
	fill(0, 0, 192, 1);
	rect(cx, cy - rr / 4.5, rr / 3.8, rr / 1.85);
	fill(224, 255, 200, 1);
	rect(cx, cy - rr / 4.5, rr / 4, rr / 2);

	for (y = 0; y < 32; y += 1) {
		let ny = 1 - y / 32;
		
		fill(random(212, 224), 255, 0 + 55 * (1 - ny), 0.75);
		rect(cx, cy - rr / 4.5 * pow(ny, 0.25), rr / 4, rr / 2 * ny);
	}
	
	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 3, ny / 5);
			let n2 = noise(nx * 4, ny * 4);
			
			let yy = height - height / 24 + y - n * height;
			fill(120, 64 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 4.25 + ny * PI * 8 + 4.25))), 40 + pow(ny, 1) * 255, 1);
			stroke(0, 0, random(0, 255), random(0,0.15));
			ellipse(x + random(-1, 1), yy + random(-1, 1), 18, 12 * ((1-ny) * 3));
			
			stroke(0, 0, random(0, 255), random(0,0.25));
			line(random(x - 4, x + 4), random(y - 4, y + 4), random(x - 4, x + 4), random(y - 4, y + 4));
		}
	}
	
	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 200 + pow(ny, 1) * 68, 0.1);
			line(x + random(-256, 256), yy, x + random(-256, 256), yy - random(32, height / 8));
		}
	}
	
	for (y = height; y > 0; y -= 8) {
		for (x = 0; x < width; x += 8) {
			if (random() > 0.85) {
				stroke(0, 0, 0, random(0, 0.25));
				let xx = x + random(-4, 4);
				line(xx, y, xx + random(-1, 1), y + random(-1, 1));
			}
		}
	}

	for (y = 0; y < height / 2; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.05);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
	
	//fill(0, 0, 0, 1);
	//rect(width / 2, height / 2 - height / 2.5 / 2 + 40, width / 10, height / 2.5);
	
	let wl = 255 * (height / 976);
	let m = 0; // get max y
	for (y = 0; y < (height - m); y += 1) {
		let ny = y / height;
		let noy = noise(ny);
		
		for (x = 0; x < width; x += 1) {
			let yy = (height / 2 + noise(x / width) * 8) + y + m;
			
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = (0.5 - noise(nx, ny)) * 2;
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 0.5 + ny * PI * 1 + nox * PI * 2.15)) / 2 * nox2;
			
			if (random() > 0.15) {
				
				let xx = x + random(-2, 2);
				let yh2 = random(-200, 200) * n * ny;
				noStroke();
				
				if (random() > 0.996 && n > 0.05) {
					fill(64, 64, 48, 1);
					rect(xx, yy - yh2, random(2, 8) * ny, 48 * ny);
				}
				
				stroke(128 + (nox2) * 8, 100 * nox3, (200*nox3-random(200) * n), random() * 0.45 * pow(ny, 0.3));
				line(xx, yy, xx + random(-200, 200) * n * noy * ny, yy + yh2);
			}
		}
	}
	/*
	for (x = 0; x < 8; x += 1) {
		let xx = random(0, width);
		let yy = random(height / 2, height);
		for (y = 0; y < 100; y += 1) {
			let ny = y / 100;
			
			noStroke();
			fill(110, 255, 10, 0.05);
			ellipse(xx + random(-32, 32) * ny, yy + 100 * ny, random(1, 64), random(1, 64));
		}
	}*/
}"
"906623","Snow landscape","mySketch","function setup() {
	createCanvas(windowWidth, windowHeight);
	
	noStroke();
	
	background(0);
	
	colorMode(HSL, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	generate();
}

function draw() {
	
}

function generate() {
	noStroke();
	
	background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 24, ny / 24);
			let n2 = noise(nx / 8, ny / 8);
			
			let yy = height / 3.9 + y - n * height;
			fill(60 - 30 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 2 + 0.25))), 128, 0 + pow(ny, 1) * 100, random(0.25, 0.75));
			stroke(0, 0, random(0, 128), random(0,0.25));
			ellipse(x + random(-8, 8), yy + random(-8, 8), 16, 16);
		}
	}
	
	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 4, ny / 4);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			fill(0, 32 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))), 120 + pow(ny, 1) * 68, 1);
			stroke(0, 0, random(0, 255), random(0,0.15));
			ellipse(x + random(-1, 1), yy + random(-1, 1), 12, 12 * ((1-ny) * 8));
			
			stroke(0, 0, random(0, 255), random(0,0.15));
			line(random(x - 4, x + 4), random(y - 4, y + 4), random(x - 4, x + 4), random(y - 4, y + 4));
		}
	}
	
	for (y = 0; y < height; y += 2) {
		let ny = y / height;
		for (x = 0; x < width; x += 2) {
			let nx = x / width;
			let n = noise(nx / 4, ny / 4);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(0, 0, 120 + pow(ny, 1) * 68, random(0,0.45) * ny);
			line(random(x - 32, x + 32), random(yy-8, yy + 8), random(x - 32, x + 32), random(yy - 8, yy + 8));
		}
	}
	
	
	for (y = height; y > 0; y -= 8) {
		for (x = 0; x < width; x += 8) {
			if (random() > 0.5) {
				stroke(0, 0, 255, random(0, 0.45));
				let xx = x + random(-4, 4);
				line(xx, y, xx + random(-1, 1), y + random(-1, 1));
			}
		}
	}

	for (y = 0; y < height / 2.5; y += 2) {
		stroke(224, 128, 0, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.995) {
				stroke(0, 0, 255, random() * 0.25);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
	
	//fill(0, 0, 0, 1);
	//rect(width / 2, height / 2 - height / 2.5 / 2 + 40, width / 10, height / 2.5);
	
	let wl = 255 * (height / 976);
	let m = 0; // get max y
	for (y = 0; y < (height - m); y += 1) {
		let ny = y / height;
		let noy = noise(ny);
		
		for (x = 0; x < width; x += 1) {
			let yy = (height / 2 + noise(x / width) * 8) + y + m;
			
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = (0.5 - noise(nx, ny)) * 2;
			let nox3 = noise(nx / 2, ny / 2);
			let n = (sin(nx * PI * 4.5 + ny * PI * 1 + nox * PI * 2.15)) / 2 * nox2;
			
			if (random() > 0.15) {
				
				let xx = x + random(-2, 2);
				let yh2 = random(-100, 100) * n * pow(ny, 1.5);
				noStroke();
				
				let ce = sin(nx * PI * 1) * cos(ny * PI * 1.5) * pow(1-ny, 0.25);
				
				if (random() > 0.45 && ce > 0.) {
					fill(64, 64, 255, 1);
					rect(xx, yy - yh2 + random(-height, height), random(1, 5) * ny, 3 * ny);
				}
				
				stroke(128 + (nox2) * 8, 0 * nox3, (180*nox3-random(100) * n) + ce * 200, random() * 0.45 * pow(ny, 0.3));
				line(xx, yy, xx + random(-70, 70) * n * noy * ny, yy + yh2);
			}
		}
	}

	
/*
	for (y = 0; y < height / 2; y += 16) {
		let ny = y / height;
		let noy = noise(ny);
		for (x = 0; x < width; x += 3) {
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = noise(nx, ny);
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2 * nox2;

			let yy = y;

			if (random() > 0.999) {
				stroke(0, 0, 0, 1);
				strokeWeight(0.5);
				let tx = x + random(1, 6);
				let ty = yy + random(1, 6);
				line(x, yy, tx, ty);
				line(tx, ty, tx + random(1, 6) * (1-ny), ty - random(1, 4) * (1-ny));
			}
		}
	}*/
}"
"905624","ifs + compositing 2","mySketch","// ifs
// https://flam3.com/flame_draves.pdf
// with compositing to bring stuff up

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];

let ifs = 2;

function setup() {
  createCanvas(900 - 1, 900 - 1);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 100, 100, 255);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
	}
}

function f1(x, y, j) {
	return { x: y / (4.3 - abs(cos(x / width * PI * (j / ifs * 1))) * 2.5), y: abs(width / 1.95 - x + y / (2 * ((1 + y / width) * 4))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 1.11 * x) / 1.025, y: (height / 2 - y / 0.95 + (x / 8.5)) / (4.5 - abs(cos(x / width * PI * abs(0.5 - j / ifs) * 2))*3) };
}

function f3(x, y, j) {
	return { x: abs(width * 1.25 - x) / (9.045 + x / 512), y: y / 1.65 };
}

var f = [f1, f2, f3];

var iter = 0;

function draw() {
	//fill(0, 0, 0, 1);
	//rect(0, 0, width, height);
	
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 0; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;

				fill(167 + 64 * ((j + 1) / ifs), 0 * (j / ifs), 100 * ((j + 1) / ifs) * 1, 255 * (i / 400) / 1);

				let e = 0.75;

				if (iter > 20) {
					ellipse(width / 2 - x[j], y[j], e, e);
					ellipse(width / 2 + x[j], y[j], e, e);
					ellipse(x[j], height / 1.3 - y[j]-15, e, e);
					ellipse(width - x[j], height / 1.3 - y[j]-15, e, e);
					//ellipse(width / 2 - x[j], height - y[j] + 150, e, e);
					//ellipse(width / 2 + x[j], height - y[j] + 150, e, e);
					
					ellipse(x[j] + width / 2, height / 1.3 - y[j] + 200, e, e);
					ellipse(width - x[j] - width / 2, height / 1.3 - y[j] + 200, e, e);
					
					//ellipse(width / 1.05 - y[j], height * 0.9 - x[j], e, e);
					//ellipse(width / 1.05 + y[j], height * 0.9 - x[j], e, e);
					//ellipse(y[j] - width * 0.15, height * 0.945 - x[j], e, e);
					//ellipse(y[j] - width * 0.15, height * 0.945 - x[j], e, e);
					//ellipse(x[j], y[j], e, e);	
					//ellipse(width / 2 - y[j], x[j], e, e);	
					//ellipse(width / 2 + y[j], x[j], e, e);	
					//ellipse(x[j], height - y[j], e, e);	
					/*
					ellipse(height - y[j], x[j], e, e);	
					ellipse(height - y[j], width - x[j], e, e);	
					ellipse(height - x[j], width - y[j], e, e);*/
				}
			}

			iter += 1;
		}
	} else if (iter == 500000) {
		// compositing
		blendMode(MULTIPLY);
		fill(240, 0, 50, 255);
		rect(width / 6, height / 1.75, width / 2.6, height / 1.2);
	  rect(width - width / 6, height / 1.75, width / 2.6, height / 1.2);
	  rect(width / 2, height / 1.31, width / 3.55, height / 1.25);
		
		blendMode(BLEND);
		fill(0, 60, 100, 255);
		//stroke(0, 0, 100, 255);
		ellipse(width / 2 - 42, 72, 20, 16);
	  ellipse(width / 2 + 42, 72, 20, 16);
	
		iter += 1;
	}

	xmotion += 1;
	ymotion += 1;
}"
"905598","ifs + compositing","mySketch","// ifs
// https://flam3.com/flame_draves.pdf
// with compositing to bring stuff up

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];

let ifs = 1;

function setup() {
  createCanvas(900 - 1, 900 - 1);
  background(0);
	
	rectMode(CENTER);
	//ellipseMode(CENTER);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 100, 100, 255);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
	}
}

function f1(x, y, j) {
	return { x: y / (4.3 - abs(cos(x / width * PI * (j / ifs * 1))) * 2.5), y: abs(width / 1.95 - x + y / (4 * ((1 + y / width) * 4))) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 1.1 * x) / 1.025, y: (height / 2 - y / 0.95 + (x / 8.5)) / (4.5 - abs(cos(x / width * PI * abs(0.5 - j / ifs) * 2))*3) };
}

function f3(x, y, j) {
	return { x: abs(width * 1.25 - x) / (9.45 + x / 256), y: y / 1.65 };
}

var f = [f1, f2, f3];

var iter = 0;

function draw() {
	//fill(0, 0, 0, 1);
	//rect(0, 0, width, height);
	
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 0; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;

				fill(167 + 64 * ((j + 1) / ifs), 0 * (j / ifs), 100 * ((j + 1) / ifs), 100 * (i / 500) / 1);

				let e = 0.75;

				if (iter > 20) {
					ellipse(width / 2 - x[j], y[j], e, e);
					ellipse(width / 2 + x[j], y[j], e, e);
					ellipse(x[j], height / 1.3 - y[j]-50, e, e);
					ellipse(width - x[j], height / 1.3 - y[j]-50, e, e);
					ellipse(width / 1.05 - y[j], height * 0.9 - x[j], e, e);
					ellipse(width / 1.05 + y[j], height * 0.9 - x[j], e, e);
					//ellipse(y[j] - width * 0.15, height * 0.945 - x[j], e, e);
					//ellipse(y[j] - width * 0.15, height * 0.945 - x[j], e, e);
					//ellipse(x[j], y[j], e, e);	
					//ellipse(width / 2 - y[j], x[j], e, e);	
					//ellipse(width / 2 + y[j], x[j], e, e);	
					//ellipse(x[j], height - y[j], e, e);	
					/*
					ellipse(height - y[j], x[j], e, e);	
					ellipse(height - y[j], width - x[j], e, e);	
					ellipse(height - x[j], width - y[j], e, e);*/
				}
			}

			iter += 1;
		}
	} else if (iter == 500000) {
		// compositing
		blendMode(MULTIPLY);
		fill(240, 0, 50, 255);
		rect(width / 6, height / 1.75, width / 2.6, height / 1.25);
	  rect(width - width / 6, height / 1.75, width / 2.6, height / 1.25);
	  rect(width / 2, height / 1.32, width / 3.55, height / 1.25);
		
		blendMode(BLEND);
		fill(0, 60, 100, 255);
		//stroke(0, 0, 100, 255);
		ellipse(width / 2 - 42, 72, 20, 16);
	  ellipse(width / 2 + 42, 72, 20, 16);
	
		iter += 1;
	}

	xmotion += 1;
	ymotion += 1;
}"
"904603","Silicate","mySketch","// ifs
// https://flam3.com/flame_draves.pdf
// + falling sand with a different rule

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];

let ifs = 1;

function setup() {
  createCanvas(800 - 1, 800 - 1);
  background(0);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 100, 100, 255);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
	}
}

function f1(x, y, j) {
	return { x: x / (3.85 - abs(cos(y / width * PI * (j / ifs * 4))) * 0.75), y: abs(width / 2 + x - y / 2) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) / 1.5 * y) / 1.25, y: abs(height - y / 2) / (4.5 - abs(cos(x / width * PI * abs(0.5 - (1+j) / ifs) * 2))*0.5) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.45 - x + (y / 4.5)) / 4.25, y: y / 2.25 };
}

var f = [f1, f2, f3];

var iter = 0;

function draw() {
	//fill(0, 0, 0, 1);
	//rect(0, 0, width, height);
	
	if (iter < 500000 && frameCount < 40) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 0; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;

				fill(0, 0, 255, 255 * (i / 4000) / 1);

				let e = 1;

				if (iter > 20) {
					ellipse(x[j], y[j], e, e);	
					ellipse(x[j], y[j], e, e);	
					ellipse(y[j], height - x[j], e, e);	
					ellipse(x[j], height - y[j], e, e);	
					ellipse(y[j], x[j], e, e);	
					ellipse(height - y[j], x[j], e, e);	
					ellipse(height - y[j], width - x[j], e, e);	
					ellipse(height - x[j], width - y[j], e, e);
				}
			}

			iter += 1;
		}
	}
	
	if (frameCount > 60) {
	loadPixels();
	for (let j = 0; j < 1; j += 1) {
		let d = pixelDensity();
		let l = 4 * (width * d) * (height * d);
		
		for (let j = 0; j < width * height; j += 1) {
			f[j] = 0;
		}
		
		for (let y = height; y >= 0; y -= 1) {
			for (let x = 0; x < width; x += 1) {
				let i = x * 4 + y * width * 4;
				let b = (pixels[i] + pixels[i + 1] + pixels[i + 2]) / 3;
				let di = i + width * d * 4;
				let b2 = (pixels[di] + pixels[di + 1] + pixels[di + 2]) / 3;
				let b3 = (pixels[di + 4] + pixels[di + 4 + 1] + pixels[di + 4 + 2]) / 3;
				let b4 = (pixels[di - 4] + pixels[di - 4 + 1] + pixels[di - 4 + 2]) / 3;
				
				if (b < 1 && b2 > 100) {
					let r = pixels[di];
					let g = pixels[di + 1];
					let b = pixels[di + 2];
					
					pixels[di] = pixels[i];
					pixels[di + 1] = pixels[i + 1];
					pixels[di + 2] = pixels[i + 2];
					//pixels[di + 3] = pixels[i + 3];
					pixels[i] = 0;
					pixels[i + 1] = 0;
					pixels[i + 2] = 0;
					
					f[x + width * y] = 1;
				} else if (b > 100 && (b3 < 1 || b4 < 10) && b2 < 250 && f[x + width * y] == 0) {
					let r;
					let g;
					let b;
					if (b3 < 1) {
						r = pixels[i];
						g = pixels[i + 1];
						b = pixels[i + 2];
						pixels[di + 4] = pixels[i];
						pixels[di + 4 + 1] = pixels[i + 1];
						pixels[di + 4 + 2] = pixels[i + 2];
					} else if (b4 < 1) {
						r = pixels[i];
						g = pixels[i + 1];
						b = pixels[i + 2];
						pixels[di - 4] = pixels[i];
						pixels[di - 4 + 1] = pixels[i + 1];
						pixels[di - 4 + 2] = pixels[i + 2];
					}
					//pixels[i + 4 + 3] = pixels[i + 3];
					let n = noise(abs(0.5 - (x / width)) * 2 * 20, abs(0.5 - (y / height)) * 2 * 20);
					pixels[i] = n * r;
					pixels[i + 1] = n * g;
					pixels[i + 2] = n * b;
					//pixels[i + 3] = 0;
				}
			}
		}
		
		
		for (let j = 0; j < width * height; j += 1) {
			f[j] = 0;
		}
		
		for (let y = 0; y < height; y += 1) {
			for (let x = 0; x < width; x += 1) {
				let i = x * 4 + y * width * 4;
				let b = (pixels[i] + pixels[i + 1] + pixels[i + 2]) / 3;
				let di = i - width * d * 4;
				let b2 = (pixels[di] + pixels[di + 1] + pixels[di + 2]) / 3;
				let b3 = (pixels[di + 4] + pixels[di + 4 + 1] + pixels[di + 4 + 2]) / 3;
				let b4 = (pixels[di - 4] + pixels[di - 4 + 1] + pixels[di - 4 + 2]) / 3;
				
				if (b < 4 && b2 > 100) {
					let r = pixels[di];
					let g = pixels[di + 1];
					let b = pixels[di + 2];
					
					pixels[di] = pixels[i];
					pixels[di + 1] = pixels[i + 1];
					pixels[di + 2] = pixels[i + 2];
					//pixels[di + 3] = pixels[i + 3];
					pixels[i] = r;
					pixels[i + 1] = g;
					pixels[i + 2] = b;
					
					f[x + width * y] = 1;
				} else if (b > 0 && (b3 < 1 || b4 < 1) && b2 < 200 && f[x + width * y] == 0) {
					let r;
					let g;
					let b;
					let ii = i + round((0.5-noise(abs(0.5 - (x / width)) * 2 * 2, abs(0.5 - (y / height)) * 2 * 2))*2)*4;
					if (b3 < 1) {
						r = pixels[ii];
						g = pixels[ii + 1];
						b = pixels[ii + 2];
						pixels[di + 4] = pixels[ii];
						pixels[di + 4 + 1] = pixels[ii + 1];
						pixels[di + 4 + 2] = pixels[ii + 2];
					} else if (b4 < 1) {
						r = pixels[ii];
						g = pixels[ii + 1];
						b = pixels[ii + 2];
						pixels[di - 4] = pixels[ii];
						pixels[di - 4 + 1] = pixels[ii + 1];
						pixels[di - 4 + 2] = pixels[ii + 2];
					}
					//pixels[i + 4 + 3] = pixels[i + 3];
					let n = noise(abs(0.5 - (x / width)) * 2 * 2, abs(0.5 - (y / height)) * 2 * 2);
					pixels[ii] = n * r * 1.5;
					pixels[ii + 1] = n * g * 1.5;
					pixels[ii + 2] = n * b * 1.5;
					//pixels[i + 3] = 0;
				}
			}
		}
	}
	updatePixels();
	}
	
	xmotion += 1;
	ymotion += 1;
}"
"904601","Dirt","mySketch","// ifs
// https://flam3.com/flame_draves.pdf
// + falling sand with a different rule

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];

let ifs = 1;

function setup() {
  createCanvas(800 - 1, 800 - 1);
  background(0);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 100, 100, 255);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
	}
}

function f1(x, y, j) {
	return { x: x / (3.85 - abs(cos(y / width * PI * (j / ifs * 4))) * 0.75), y: abs(width / 2 + x - y / 2) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 1 * y) / 1.25, y: abs(height * 2 - y) / (4.5 - abs(cos(x / width * PI * abs(0.5 - (1+j) / ifs) * 2))*0.5) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.45 + x + (y / 1.5)) / 4.25, y: y / 1.25 };
}

var f = [f1, f2, f3];

var iter = 0;

function draw() {
	//fill(0, 0, 0, 1);
	//rect(0, 0, width, height);
	
	if (iter < 500000 && frameCount < 40) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 0; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;

				fill(0, 0, 255, 255 * (i / 4000) / 1);

				let e = 1;

				if (iter > 20) {
					ellipse(x[j], y[j], e, e);	
					ellipse(x[j], y[j], e, e);	
					ellipse(y[j], height - x[j], e, e);	
					ellipse(x[j], height - y[j], e, e);	
					ellipse(y[j], x[j], e, e);	
					ellipse(height - y[j], x[j], e, e);	
					ellipse(height - y[j], width - x[j], e, e);	
					ellipse(height - x[j], width - y[j], e, e);
				}
			}

			iter += 1;
		}
	}
	
	if (frameCount > 60) {
	loadPixels();
	for (let j = 0; j < 1; j += 1) {
		let d = pixelDensity();
		let l = 4 * (width * d) * (height * d);
		
		for (let j = 0; j < width * height; j += 1) {
			f[j] = 0;
		}
		
		for (let y = height; y >= 0; y -= 1) {
			for (let x = 0; x < width; x += 1) {
				let i = x * 4 + y * width * 4;
				let b = (pixels[i] + pixels[i + 1] + pixels[i + 2]) / 3;
				let di = i + width * d * 4;
				let b2 = (pixels[di] + pixels[di + 1] + pixels[di + 2]) / 3;
				let b3 = (pixels[di + 4] + pixels[di + 4 + 1] + pixels[di + 4 + 2]) / 3;
				let b4 = (pixels[di - 4] + pixels[di - 4 + 1] + pixels[di - 4 + 2]) / 3;
				
				if (b < 100 && b2 > 100) {
					let r = pixels[di];
					let g = pixels[di + 1];
					let b = pixels[di + 2];
					
					pixels[di] = pixels[i];
					pixels[di + 1] = pixels[i + 1];
					pixels[di + 2] = pixels[i + 2];
					//pixels[di + 3] = pixels[i + 3];
					pixels[i] = 0;
					pixels[i + 1] = 0;
					pixels[i + 2] = 0;
					
					f[x + width * y] = 1;
				} else if (b > 100 && (b3 < 1 || b4 < 10) && b2 < 250 && f[x + width * y] == 0) {
					let r;
					let g;
					let b;
					if (b3 < 1) {
						r = pixels[i];
						g = pixels[i + 1];
						b = pixels[i + 2];
						pixels[di + 4] = pixels[i];
						pixels[di + 4 + 1] = pixels[i + 1];
						pixels[di + 4 + 2] = pixels[i + 2];
					} else if (b4 < 1) {
						r = pixels[i];
						g = pixels[i + 1];
						b = pixels[i + 2];
						pixels[di - 4] = pixels[i];
						pixels[di - 4 + 1] = pixels[i + 1];
						pixels[di - 4 + 2] = pixels[i + 2];
					}
					//pixels[i + 4 + 3] = pixels[i + 3];
					let n = noise(abs(0.5 - (x / width)) * 2 * 20, abs(0.5 - (y / height)) * 2 * 20);
					pixels[i] = n * r;
					pixels[i + 1] = n * g;
					pixels[i + 2] = n * b;
					//pixels[i + 3] = 0;
				}
			}
		}
		
		
		for (let j = 0; j < width * height; j += 1) {
			f[j] = 0;
		}
		
		for (let y = 0; y < height; y += 1) {
			for (let x = 0; x < width; x += 1) {
				let i = x * 4 + y * width * 4;
				let b = (pixels[i] + pixels[i + 1] + pixels[i + 2]) / 3;
				let di = i - width * d * 4;
				let b2 = (pixels[di] + pixels[di + 1] + pixels[di + 2]) / 3;
				let b3 = (pixels[di + 4] + pixels[di + 4 + 1] + pixels[di + 4 + 2]) / 3;
				let b4 = (pixels[di - 4] + pixels[di - 4 + 1] + pixels[di - 4 + 2]) / 3;
				
				if (b < 4 && b2 > 200) {
					let r = pixels[di];
					let g = pixels[di + 1];
					let b = pixels[di + 2];
					
					pixels[di] = pixels[i];
					pixels[di + 1] = pixels[i + 1];
					pixels[di + 2] = pixels[i + 2];
					//pixels[di + 3] = pixels[i + 3];
					pixels[i] = r;
					pixels[i + 1] = g;
					pixels[i + 2] = b;
					
					f[x + width * y] = 1;
				} else if (b > 0 && (b3 < 1 || b4 < 1) && b2 < 200 && f[x + width * y] == 0) {
					let r;
					let g;
					let b;
					let ii = i + round((0.5-noise(abs(0.5 - (x / width)) * 2 * 2, abs(0.5 - (y / height)) * 2 * 2))*2)*4;
					if (b3 < 1) {
						r = pixels[ii];
						g = pixels[ii + 1];
						b = pixels[ii + 2];
						pixels[di + 4] = pixels[ii];
						pixels[di + 4 + 1] = pixels[ii + 1];
						pixels[di + 4 + 2] = pixels[ii + 2];
					} else if (b4 < 1) {
						r = pixels[ii];
						g = pixels[ii + 1];
						b = pixels[ii + 2];
						pixels[di - 4] = pixels[ii];
						pixels[di - 4 + 1] = pixels[ii + 1];
						pixels[di - 4 + 2] = pixels[ii + 2];
					}
					//pixels[i + 4 + 3] = pixels[i + 3];
					let n = noise(abs(0.5 - (x / width)) * 2 * 2, abs(0.5 - (y / height)) * 2 * 2);
					pixels[ii] = n * r * 2.5;
					pixels[ii + 1] = n * g * 2.5;
					pixels[ii + 2] = n * b * 2.5;
					//pixels[i + 3] = 0;
				}
			}
		}
	}
	updatePixels();
	}
	
	xmotion += 1;
	ymotion += 1;
}"
"904248","ifsand","mySketch","// ifs
// https://flam3.com/flame_draves.pdf
// + falling sand with a different rule

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];

let ifs = 4;

function setup() {
  createCanvas(800 - 1, 800 - 1);
  background(0);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 100, 100, 255);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
	}
}

function f1(x, y, j) {
	return { x: x / (3.85 - abs(cos(y / width * PI * (j / ifs * 1))) * 2.75), y: abs(width / 2 - x - y / 2.05) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 1 * x) / 1.25, y: abs(height - y) / (4.5 - abs(cos(x / width * PI * abs(0.5 - j / ifs) * 1))*3) };
}

function f3(x, y, j) {
	return { x: abs(width * 1.45 - x) / 3.45, y: y / 10.075 };
}

var f = [f1, f2, f3];

var iter = 0;

function draw() {
	//fill(0, 0, 0, 1);
	//rect(0, 0, width, height);
	
	if (iter < 500000 && frameCount < 40) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 0; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;

				fill(167 + 64 * ((j + 1) / ifs), 24 * (j / ifs), 100 * ((j + 1) / ifs), 255 * (i / 1000) / 1);

				let e = 1;

				if (iter > 20) {
					ellipse(x[j], y[j], e, e);	
					ellipse(y[j], x[j], e, e);	
					ellipse(x[j], height - y[j], e, e);	
					ellipse(height - y[j], x[j], e, e);	
					ellipse(height - y[j], width - x[j], e, e);	
					ellipse(height - x[j], width - y[j], e, e);
				}
			}

			iter += 1;
		}
	}
	
	if (frameCount > 40) {
	loadPixels();
	for (let j = 0; j < 2; j += 1) {
		let d = pixelDensity();
		let l = 4 * (width * d) * (height * d);
		
		for (let j = 0; j < width * height; j += 1) {
			f[j] = 0;
		}
		
		for (let y = height; y >= 0; y -= 1) {
			for (let x = 0; x < width; x += 1) {
				let i = x * 4 + y * width * 4;
				let b = (pixels[i] + pixels[i + 1] + pixels[i + 2]) / 3;
				let di = i + width * d * 4;
				let b2 = (pixels[di] + pixels[di + 1] + pixels[di + 2]) / 3;
				let b3 = (pixels[di + 4] + pixels[di + 4 + 1] + pixels[di + 4 + 2]) / 3;
				let b4 = (pixels[di - 4] + pixels[di - 4 + 1] + pixels[di - 4 + 2]) / 3;
				
				if (b < 4 && b2 > 200) {
					let r = pixels[di];
					let g = pixels[di + 1];
					let b = pixels[di + 2];
					
					pixels[di] = pixels[i];
					pixels[di + 1] = pixels[i + 1];
					pixels[di + 2] = pixels[i + 2];
					//pixels[di + 3] = pixels[i + 3];
					pixels[i] = r;
					pixels[i + 1] = g;
					pixels[i + 2] = b;
					
					f[x + width * y] = 1;
				} else if (b > 2 && (b3 < 1 || b4 < 1) && b2 < 10 && f[x + width * y] == 0) {
					let r;
					let g;
					let b;
					if (b3 < 1) {
						r = pixels[i];
						g = pixels[i + 1];
						b = pixels[i + 2];
						pixels[di + 4] = pixels[i];
						pixels[di + 4 + 1] = pixels[i + 1];
						pixels[di + 4 + 2] = pixels[i + 2];
					} else if (b4 < 1) {
						r = pixels[i];
						g = pixels[i + 1];
						b = pixels[i + 2];
						pixels[di - 4] = pixels[i];
						pixels[di - 4 + 1] = pixels[i + 1];
						pixels[di - 4 + 2] = pixels[i + 2];
					}
					//pixels[i + 4 + 3] = pixels[i + 3];
					pixels[i] = r;
					pixels[i + 1] = g;
					pixels[i + 2] = b;
					//pixels[i + 3] = 0;
				}
			}
		}
	}
	updatePixels();
	}
	
	xmotion += 1;
	ymotion += 1;
}"
"904232","Ocean + mountains","mySketch","// lets apply falling sand idea to that as well (initial idea from swamp + moutains sketch, derived from twitter post)

function setup() {
	createCanvas(800, 800);
	
	noStroke();
	
	background(255, 255, 255);
	
	colorMode(HSL, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	generate();
}

let f = [];
let finish = false;

function draw() {
	let c = 0;
if (finish == false) {
	loadPixels();
	for (let j = 0; j < 2; j += 1) {
		let d = pixelDensity();
		let l = 4 * (width * d) * (height * d);
		
		for (let j = 0; j < width * height; j += 1) {
			f[j] = 0;
		}
		
		for (let y = height; y >= 0; y -= 1) {
			for (let x = 0; x < width; x += 1) {
				let i = x * 4 + y * width * 4;
				let b = (pixels[i] + pixels[i + 1] + pixels[i + 2]) / 3;
				let di = i + width * d * 4;
				let b2 = (pixels[di] + pixels[di + 1] + pixels[di + 2]) / 3;
				let b3 = (pixels[di + 4] + pixels[di + 4 + 1] + pixels[di + 4 + 2]) / 3;
				let b4 = (pixels[di - 4] + pixels[di - 4 + 1] + pixels[di - 4 + 2]) / 3;
				
				if (b < 255 && b2 > 224) {
					//let r = pixels[di];
					//let g = pixels[di + 1];
					//let b = pixels[di + 2];
					
					pixels[di] = pixels[i];
					pixels[di + 1] = pixels[i + 1];
					pixels[di + 2] = pixels[i + 2];
					//pixels[di + 3] = pixels[i + 3];
					pixels[i] = 255;
					pixels[i + 1] = 255;
					pixels[i + 2] = 255;
					
					f[x + width * y] = 1;
					
					c += 1;
				} else if (b < 255 && (b3 > 254 || b4 > 254) && b2 < 255 && f[x + width * y] == 0) {
					let r;
					let g;
					let b;
					if (b3 > 254) {
						//r = pixels[i];
						//g = pixels[i + 1];
						//b = pixels[i + 2];
						pixels[di + 4] = pixels[i];
						pixels[di + 4 + 1] = pixels[i + 1];
						pixels[di + 4 + 2] = pixels[i + 2];
						
						c += 1;
					} else if (b4 > 254) {
						//r = pixels[i];
						//g = pixels[i + 1];
						//b = pixels[i + 2];
						pixels[di - 4] = pixels[i];
						pixels[di - 4 + 1] = pixels[i + 1];
						pixels[di - 4 + 2] = pixels[i + 2];
						
						c += 1;
					}
					//pixels[i + 4 + 3] = pixels[i + 3];
					pixels[i] = 255;
					pixels[i + 1] = 255;
					pixels[i + 2] = 255;
					//pixels[i + 3] = 0;
				}
			}
		}
	}
	updatePixels();
}
	if (c == 0 && finish == false) {
		let x = 0, y = 0;
		for (y = 0; y < height / 2; y += 4) {
			let ny = y / height;
			for (x = 0; x < width; x += 4) {
				let nx = x / width;
				let n = noise(nx / 12, ny / 12);
				let n2 = noise(nx * 4, ny - 4);

				let yy = height - height / 24 + y - n * height;

				stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 170 + pow(ny, 1) * 68, 0.025);
				line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
			}
		}
		
		for (y = 0; y < height / 2; y += 16) {
			let ny = y / height;
			let noy = noise(ny);
			for (x = 0; x < width; x += 3) {
				let nx = x / width;
				let nox = noise(nx * 2, ny * 8);
				let nox2 = noise(nx, ny);
				let nox3 = noise(nx / 8, ny / 8);
				let n = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2 * nox2;

				let yy = y;

				if (random() > 0.9992) {
					stroke(0, 0, 0, 1);
					strokeWeight(0.5);
					let tx = x + random(1, 6);
					let ty = yy + random(1, 6);
					line(x, yy, tx, ty);
					line(tx, ty, tx + random(1, 6) * (1-ny), ty - random(1, 4) * (1-ny));
				}
			}
		}
		
		finish = true;
	}
}


function generate() {
	noStroke();
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 24, ny / 24);
			let n2 = noise(nx, ny);
			
			let yy = height / 3.9 + y - n * height;
			fill(224 - 20 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))), 118, 128 + pow(ny, 1) * 128, 1);
			rect(x, yy, 4, 5);
		}
	}
	
	for (y = height; y > 0; y -= 8) {
		for (x = 0; x < width; x += 8) {
			if (random() > 0.85) {
				stroke(0, 0, 0, random(0, 0.25));
				let xx = x + random(-4, 4);
				line(xx, y, xx + random(-1, 1), y + random(-1, 1));
			}
		}
	}

	for (y = 0; y < height / 2; y += 1) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.05);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
	
	let wl = 255 * (height / 976);
	let m = 0; // get max y
	for (y = 0; y < (height - m); y += 1) {
		let ny = y / height;
		let noy = noise(ny);
		
		for (x = 0; x < width; x += 1) {
			let yy = (height / 2 + noise(x / width) * 8) + y + m;
			
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = (0.5 - noise(nx, ny)) * 2;
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 0.5 + ny * PI * 1 + nox * PI * 2.15)) / 2 * nox2;
			
			if (random() > 0.25) {
				stroke(224 + (nox2) * 24, 200 * nox3, 200*nox3-random(200) * n, random() * 0.45 * pow(ny, 0.3));
				let xx = x + random(-2, 2);
				line(xx, yy, xx + random(-200, 200) * n * noy * ny, yy + random(-20, 20) * n * ny);
			}
		}
	}
}"
"904232","Ocean + mountains","mySketch","// lets apply falling sand idea to that as well (initial idea from swamp + moutains sketch, derived from twitter post)

function setup() {
	createCanvas(800, 800);
	
	noStroke();
	
	background(255, 255, 255);
	
	colorMode(HSL, 360, 255, 255, 1);
	
	noiseSeed(31);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	generate();
}

let f = [];
let finish = false;

function draw() {
	let c = 0;
if (finish == false) {
	loadPixels();
	for (let j = 0; j < 2; j += 1) {
		let d = pixelDensity();
		let l = 4 * (width * d) * (height * d);
		
		for (let j = 0; j < width * height; j += 1) {
			f[j] = 0;
		}
		
		for (let y = height; y >= 0; y -= 1) {
			for (let x = 0; x < width; x += 1) {
				let i = x * 4 + y * width * 4;
				let b = (pixels[i] + pixels[i + 1] + pixels[i + 2]) / 3;
				let di = i + width * d * 4;
				let b2 = (pixels[di] + pixels[di + 1] + pixels[di + 2]) / 3;
				let b3 = (pixels[di + 4] + pixels[di + 4 + 1] + pixels[di + 4 + 2]) / 3;
				let b4 = (pixels[di - 4] + pixels[di - 4 + 1] + pixels[di - 4 + 2]) / 3;
				
				if (b < 255 && b2 > 224) {
					//let r = pixels[di];
					//let g = pixels[di + 1];
					//let b = pixels[di + 2];
					
					pixels[di] = pixels[i];
					pixels[di + 1] = pixels[i + 1];
					pixels[di + 2] = pixels[i + 2];
					//pixels[di + 3] = pixels[i + 3];
					pixels[i] = 255;
					pixels[i + 1] = 255;
					pixels[i + 2] = 255;
					
					f[x + width * y] = 1;
					
					c += 1;
				} else if (b < 255 && (b3 > 254 || b4 > 254) && b2 < 255 && f[x + width * y] == 0) {
					let r;
					let g;
					let b;
					if (b3 > 254) {
						//r = pixels[i];
						//g = pixels[i + 1];
						//b = pixels[i + 2];
						pixels[di + 4] = pixels[i];
						pixels[di + 4 + 1] = pixels[i + 1];
						pixels[di + 4 + 2] = pixels[i + 2];
						
						c += 1;
					} else if (b4 > 254) {
						//r = pixels[i];
						//g = pixels[i + 1];
						//b = pixels[i + 2];
						pixels[di - 4] = pixels[i];
						pixels[di - 4 + 1] = pixels[i + 1];
						pixels[di - 4 + 2] = pixels[i + 2];
						
						c += 1;
					}
					//pixels[i + 4 + 3] = pixels[i + 3];
					pixels[i] = 255;
					pixels[i + 1] = 255;
					pixels[i + 2] = 255;
					//pixels[i + 3] = 0;
				}
			}
		}
	}
	updatePixels();
}
	if (c == 0 && finish == false) {
		let x = 0, y = 0;
		for (y = 0; y < height / 2; y += 4) {
			let ny = y / height;
			for (x = 0; x < width; x += 4) {
				let nx = x / width;
				let n = noise(nx / 12, ny / 12);
				let n2 = noise(nx * 4, ny - 4);

				let yy = height - height / 24 + y - n * height;

				stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 170 + pow(ny, 1) * 68, 0.025);
				line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
			}
		}
		
		for (y = 0; y < height / 2; y += 16) {
			let ny = y / height;
			let noy = noise(ny);
			for (x = 0; x < width; x += 3) {
				let nx = x / width;
				let nox = noise(nx * 2, ny * 8);
				let nox2 = noise(nx, ny);
				let nox3 = noise(nx / 8, ny / 8);
				let n = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2 * nox2;

				let yy = y;

				if (random() > 0.9992) {
					stroke(0, 0, 0, 1);
					strokeWeight(0.5);
					let tx = x + random(1, 6);
					let ty = yy + random(1, 6);
					line(x, yy, tx, ty);
					line(tx, ty, tx + random(1, 6) * (1-ny), ty - random(1, 4) * (1-ny));
				}
			}
		}
		
		finish = true;
	}
}


function generate() {
	noStroke();
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 24, ny / 24);
			let n2 = noise(nx, ny);
			
			let yy = height / 3.9 + y - n * height;
			fill(224 - 20 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))), 118, 128 + pow(ny, 1) * 128, 1);
			rect(x, yy, 4, 5);
		}
	}
	
	for (y = height; y > 0; y -= 8) {
		for (x = 0; x < width; x += 8) {
			if (random() > 0.85) {
				stroke(0, 0, 0, random(0, 0.25));
				let xx = x + random(-4, 4);
				line(xx, y, xx + random(-1, 1), y + random(-1, 1));
			}
		}
	}

	for (y = 0; y < height / 2; y += 1) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.05);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
	
	let wl = 255 * (height / 976);
	let m = 0; // get max y
	for (y = 0; y < (height - m); y += 1) {
		let ny = y / height;
		let noy = noise(ny);
		
		for (x = 0; x < width; x += 1) {
			let yy = (height / 2 + noise(x / width) * 8) + y + m;
			
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = (0.5 - noise(nx, ny)) * 2;
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 0.5 + ny * PI * 1 + nox * PI * 2.15)) / 2 * nox2;
			
			if (random() > 0.25) {
				stroke(224 + (nox2) * 24, 200 * nox3, 200*nox3-random(200) * n, random() * 0.45 * pow(ny, 0.3));
				let xx = x + random(-2, 2);
				line(xx, yy, xx + random(-200, 200) * n * noy * ny, yy + random(-20, 20) * n * ny);
			}
		}
	}
}"
"904225","Rainy swamp + mountains","mySketch","// first rainy / foggy swamp then falling sand, once all sand is down draw rain / fog again
// idea from : https://twitter.com/eisism/status/1249856918627053568

function setup() {
	createCanvas(800, 800);
	
	noStroke();
	
	background(0);
	
	colorMode(HSL, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	generate();
}

let f = [];
let finish = false;

function draw() {
	let c = 0;
if (finish == false) {
	loadPixels();
	for (let j = 0; j < 2; j += 1) {
		let d = pixelDensity();
		let l = 4 * (width * d) * (height * d);
		
		for (let j = 0; j < width * height; j += 1) {
			f[j] = 0;
		}
		
		for (let y = height; y >= 0; y -= 1) {
			for (let x = 0; x < width; x += 1) {
				let i = x * 4 + y * width * 4;
				let b = (pixels[i] + pixels[i + 1] + pixels[i + 2]) / 3;
				let di = i + width * d * 4;
				let b2 = (pixels[di] + pixels[di + 1] + pixels[di + 2]) / 3;
				let b3 = (pixels[di + 4] + pixels[di + 4 + 1] + pixels[di + 4 + 2]) / 3;
				let b4 = (pixels[di - 4] + pixels[di - 4 + 1] + pixels[di - 4 + 2]) / 3;
				
				if (b < 255 && b2 > 224) {
					//let r = pixels[di];
					//let g = pixels[di + 1];
					//let b = pixels[di + 2];
					
					pixels[di] = pixels[i];
					pixels[di + 1] = pixels[i + 1];
					pixels[di + 2] = pixels[i + 2];
					//pixels[di + 3] = pixels[i + 3];
					pixels[i] = 255;
					pixels[i + 1] = 255;
					pixels[i + 2] = 255;
					
					f[x + width * y] = 1;
					
					c += 1;
				} else if (b < 255 && (b3 > 254 || b4 > 254) && b2 < 255 && f[x + width * y] == 0) {
					let r;
					let g;
					let b;
					if (b3 > 254) {
						//r = pixels[i];
						//g = pixels[i + 1];
						//b = pixels[i + 2];
						pixels[di + 4] = pixels[i];
						pixels[di + 4 + 1] = pixels[i + 1];
						pixels[di + 4 + 2] = pixels[i + 2];
						
						c += 1;
					} else if (b4 > 254) {
						//r = pixels[i];
						//g = pixels[i + 1];
						//b = pixels[i + 2];
						pixels[di - 4] = pixels[i];
						pixels[di - 4 + 1] = pixels[i + 1];
						pixels[di - 4 + 2] = pixels[i + 2];
						
						c += 1;
					}
					//pixels[i + 4 + 3] = pixels[i + 3];
					pixels[i] = 255;
					pixels[i + 1] = 255;
					pixels[i + 2] = 255;
					//pixels[i + 3] = 0;
				}
			}
		}
	}
	updatePixels();
}
	if (c == 0 && finish == false) {
		let x = 0, y = 0;
		for (y = 0; y < height / 2; y += 4) {
			let ny = y / height;
			for (x = 0; x < width; x += 4) {
				let nx = x / width;
				let n = noise(nx / 12, ny / 12);
				let n2 = noise(nx * 4, ny - 4);

				let yy = height - height / 24 + y - n * height;

				stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 170 + pow(ny, 1) * 68, 0.025);
				line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
			}
		}
		finish = true;
	}
}

function generate() {
	noStroke();
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 24, ny / 24);
			let n2 = noise(nx / 8, ny / 8);
			
			let yy = height / 3.9 + y - n * height;
			fill(60 - 30 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 2 + 0.25))), 0, 148 + pow(ny, 1) * 100, random(0.25, 0.75));
			stroke(0, 0, random(0, 128), random(0,0.025));
			ellipse(x + random(-8, 8), yy + random(-8, 8), 16, 16);
		}
	}
	
	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 170 + pow(ny, 1) * 68, 1);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	
	for (y = height; y > 0; y -= 8) {
		for (x = 0; x < width; x += 8) {
			if (random() > 0.85) {
				stroke(0, 0, 0, random(0, 0.25));
				let xx = x + random(-4, 4);
				line(xx, y, xx + random(-1, 1), y + random(-1, 1));
			}
		}
	}

	for (y = 0; y < height / 2; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.05);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
	
	//fill(0, 0, 0, 1);
	//rect(width / 2, height / 2 - height / 2.5 / 2 + 40, width / 10, height / 2.5);
	
	let wl = 255 * (height / 976);
	let m = 0; // get max y
	for (y = 0; y < (height - m); y += 1) {
		let ny = y / height;
		let noy = noise(ny);
		
		for (x = 0; x < width; x += 1) {
			let yy = (height / 2 + noise(x / width) * 8) + y + m;
			
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = (0.5 - noise(nx, ny)) * 2;
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 0.5 + ny * PI * 1 + nox * PI * 2.15)) / 2 * nox2;
			
			if (random() > 0.15) {
				
				let xx = x + random(-2, 2);
				let yh2 = random(-200, 200) * n * ny;
				noStroke();
				
				if (random() > 0.996 && n > 0.05) {
					fill(64, 64, 48, 1);
					rect(xx, yy - yh2, random(2, 8) * ny, 48 * ny);
				}
				
				stroke(128 + (nox2) * 8, 100 * nox3, (200*nox3-random(200) * n), random() * 0.45 * pow(ny, 0.3));
				line(xx, yy, xx + random(-200, 200) * n * noy * ny, yy + yh2);
			}
		}
	}
}"
"902672","Eroding sketches","mySketch","function setup() {
	createCanvas(400, 400);
}

function draw() {
	loadPixels();
	let d = pixelDensity();
	let l = 4 * (width * d) * (height * d);
	for (let i = l; i >= 0; i -= 4) {
		if (pixels[i] > 0 && pixels[i + width * d * 4] < 8) {
			pixels[i + width * d * 4] = pixels[i];
			pixels[i + width * d * 4 + 1] = pixels[i + 1];
			pixels[i + width * d * 4 + 2] = pixels[i + 2];
			pixels[i + width * d * 4 + 3] = pixels[i + 3];
			pixels[i] = 0;
			pixels[i + 1] = 0;
			pixels[i + 2] = 0;
			pixels[i + 3] = 0;
		}
	}
	updatePixels();
}"
"902672","Eroding sketches","mySketch","let img;

function preload() {
    img = loadImage('beach.png');
}

function setup() {
	createCanvas(400, 400);
	background(0);
	image(img, 0, 0, 400, 400);
}

function draw() {
	loadPixels();
	for (let j = 0; j < 4; j += 1) {
		let d = pixelDensity();
		let l = 4 * (width * d) * (height * d);
		for (let i = l; i >= 0; i -= 4) {
			let b = (pixels[i] + pixels[i + 1] + pixels[i + 2]) / 3;
			let di = i + width * d * 4;
			let b2 = (pixels[di] + pixels[di + 1] + pixels[di + 2]) / 3;
			let b3 = (pixels[i + 4] + pixels[i + 4 + 1] + pixels[i + 4 + 2]) / 3;
			let b4 = (pixels[i - 4] + pixels[i - 4 + 1] + pixels[i - 4 + 2]) / 3;
			if (b > 0 && b2 < 140) {
				pixels[di] = pixels[i];
				pixels[di + 1] = pixels[i + 1];
				pixels[di + 2] = pixels[i + 2];
				//pixels[i + width * d * 4 + 3] = pixels[i + 3];
				pixels[i] = 0;
				pixels[i + 1] = 0;
				pixels[i + 2] = 0;
			} else if (b > 180 && (b3 < 1 || b4 < 1)) {
				if (b3 < 1) {
					pixels[i + 4] = pixels[i];
					pixels[i + 4 + 1] = pixels[i + 1];
					pixels[i + 4 + 2] = pixels[i + 2];
				} else if (b4 < 1) {
					pixels[i - 4] = pixels[i];
					pixels[i - 4 + 1] = pixels[i + 1];
					pixels[i - 4 + 2] = pixels[i + 2];
				}
				//pixels[i + 4 + 3] = pixels[i + 3];
				pixels[i] = 0;
				pixels[i + 1] = 0;
				pixels[i + 2] = 0;
				//pixels[i + 3] = 0;
			}
		}
	}
	updatePixels();
}"
"902672","Eroding sketches","mySketch","// trying this for fun : https://twitter.com/eisism/status/1249856918627053568
// the rolling left & right is probably not right

let img;

function preload() {
    img = loadImage('cg1.png');
}

function setup() {
	createCanvas(800, 800);
	background(0);
	image(img, 0, 0, 800, 800);
	
	noiseDetail(7, 0.6);
}


let m = 255;
let mn = 0;

function draw() {
	loadPixels();
	for (let j = 0; j < 3; j += 1) {
		let d = pixelDensity();
		let l = 4 * (width * d) * (height * d);
		for (let y = height-1; y >= 1; y -= 1) {
			for (let x = 1; x < width-1; x += 1) {
				let i = x * 4 + y * width * 4;
				let b = (pixels[i] + pixels[i + 1] + pixels[i + 2]) / 3;
				let di = i + width * d * 4;
				let b2 = (pixels[di] + pixels[di + 1] + pixels[di + 2]) / 3;
				let b3 = (pixels[i + 4] + pixels[i + 4 + 1] + pixels[i + 4 + 2]) / 3;
				let b4 = (pixels[i - 4] + pixels[i - 4 + 1] + pixels[i - 4 + 2]) / 3;
				if (b > m && b2 > 0) {
					let r = pixels[di];
					let g = pixels[di + 1];
					let b = pixels[di + 2];
					
					pixels[di] = pixels[i];
					pixels[di + 1] = pixels[i + 1];
					pixels[di + 2] = pixels[i + 2];
					//pixels[i + width * d * 4 + 3] = pixels[i + 3];
					pixels[i] = r;
					pixels[i + 1] = g;
					pixels[i + 2] = b;
				} else if (b >= 8 && (b3 < 10 || b4 < 10)) {
					let r;
					let g;
					let b;
					if (b3 < 10) {
						r = pixels[i + 4];
						g = pixels[i + 4 + 1];
						b = pixels[i + 4 + 2];
						pixels[i + 4] = pixels[i];
						pixels[i + 4 + 1] = pixels[i + 1];
						pixels[i + 4 + 2] = pixels[i + 2];
					} else if (b4 < 10) {
						r = pixels[i - 4];
						g = pixels[i - 4 + 1];
						b = pixels[i - 4 + 2];
						pixels[i - 4] = pixels[i];
						pixels[i - 4 + 1] = pixels[i + 1];
						pixels[i - 4 + 2] = pixels[i + 2];
					}
					//pixels[i + 4 + 3] = pixels[i + 3];
					pixels[i] = r;
					pixels[i + 1] = g;
					pixels[i + 2] = b;
					//pixels[i + 3] = 0;
				}
			}
		}
	}
	updatePixels();
	
	m = noise(frameCount * 255) * 255;
	mn = m;
}"
"902672","Eroding sketches","mySketch","// trying this for fun : https://twitter.com/eisism/status/1249856918627053568
// the rolling left & right is probably not right

let img;

function preload() {
    img = loadImage('cg1.png');
}

function setup() {
	createCanvas(1400, 800);
	background(0);
	image(img, 0, 0, 1400, 800);
	
	noiseDetail(7, 0.6);
}


let m = 255;
let mn = 0;

function draw() {
	loadPixels();
	for (let j = 0; j < 3; j += 1) {
		let d = pixelDensity();
		let l = 4 * (width * d) * (height * d);
		for (let y = height-1; y >= 1; y -= 1) {
			for (let x = 1; x < width-1; x += 1) {
				let i = x * 4 + y * width * 4;
				let b = (pixels[i] + pixels[i + 1] + pixels[i + 2]) / 3;
				let di = i + width * d * 4;
				let b2 = (pixels[di] + pixels[di + 1] + pixels[di + 2]) / 3;
				let b3 = (pixels[i + 4] + pixels[i + 4 + 1] + pixels[i + 4 + 2]) / 3;
				let b4 = (pixels[i - 4] + pixels[i - 4 + 1] + pixels[i - 4 + 2]) / 3;
				if (b > m && b2 > 0) {
					let r = pixels[di];
					let g = pixels[di + 1];
					let b = pixels[di + 2];
					
					pixels[di] = pixels[i];
					pixels[di + 1] = pixels[i + 1];
					pixels[di + 2] = pixels[i + 2];
					//pixels[i + width * d * 4 + 3] = pixels[i + 3];
					pixels[i] = r;
					pixels[i + 1] = g;
					pixels[i + 2] = b;
				} else if (b >= 8 && (b3 < 10 || b4 < 10)) {
					let r;
					let g;
					let b;
					if (b3 < 10) {
						r = pixels[i + 4];
						g = pixels[i + 4 + 1];
						b = pixels[i + 4 + 2];
						pixels[i + 4] = pixels[i];
						pixels[i + 4 + 1] = pixels[i + 1];
						pixels[i + 4 + 2] = pixels[i + 2];
					} else if (b4 < 10) {
						r = pixels[i - 4];
						g = pixels[i - 4 + 1];
						b = pixels[i - 4 + 2];
						pixels[i - 4] = pixels[i];
						pixels[i - 4 + 1] = pixels[i + 1];
						pixels[i - 4 + 2] = pixels[i + 2];
					}
					//pixels[i + 4 + 3] = pixels[i + 3];
					pixels[i] = r;
					pixels[i + 1] = g;
					pixels[i + 2] = b;
					//pixels[i + 3] = 0;
				}
			}
		}
	}
	updatePixels();
	
	m = noise(frameCount * 255) * 255;
	mn = m;
}"
"902672","Eroding sketches","mySketch","// this is standard falling sand algorithm
// which started as a tentative to recreate this : https://twitter.com/eisism/status/1249856918627053568
// this depend heavily on the source image and on ""tolerance"" parameters (pixels brightness selection)

let img;

function preload() {
    img = loadImage('cg1.png');
}

let f = [];

function setup() {
	createCanvas(1400, 800);
	background(0);
	image(img, 0, 0, 1400, 800);
	
	noiseDetail(7, 0.6);
	
	rectMode(CENTER);
	textAlign(CENTER);
	
	colorMode(HSL, 360, 1, 1);
	
	noStroke();
}

function mouseClicked() {
	fill(random(0, 360), 1, 0.75, 255);
	rect(mouseX, mouseY, 60, 60);
	
	return false;
}


let m = 255;
let mn = 0;

function draw() {
	loadPixels();
	for (let j = 0; j < 2; j += 1) {
		let d = pixelDensity();
		let l = 4 * (width * d) * (height * d);
		
		for (let j = 0; j < width * height; j += 1) {
			f[j] = 0;
		}
		
		for (let y = height; y >= 0; y -= 1) {
			for (let x = 0; x < width; x += 1) {
				let i = x * 4 + y * width * 4;
				let b = (pixels[i] + pixels[i + 1] + pixels[i + 2]) / 3;
				let di = i + width * d * 4;
				let b2 = (pixels[di] + pixels[di + 1] + pixels[di + 2]) / 3;
				let b3 = (pixels[di + 4] + pixels[di + 4 + 1] + pixels[di + 4 + 2]) / 3;
				let b4 = (pixels[di - 4] + pixels[di - 4 + 1] + pixels[di - 4 + 2]) / 3;
				
				if (b > m && b2 < 16) {
					//let r = pixels[di];
					//let g = pixels[di + 1];
					//let b = pixels[di + 2];
					
					pixels[di] = pixels[i];
					pixels[di + 1] = pixels[i + 1];
					pixels[di + 2] = pixels[i + 2];
					//pixels[di + 3] = pixels[i + 3];
					pixels[i] = 0;
					pixels[i + 1] = 0;
					pixels[i + 2] = 0;
					
					f[x + width * y] = 1;
				} else if (b > mn && (b3 < 1 || b4 < 1) && b2 > 0 && f[x + width * y] == 0) {
					let r;
					let g;
					let b;
					if (b3 < 1) {
						//r = pixels[i];
						//g = pixels[i + 1];
						//b = pixels[i + 2];
						pixels[di + 4] = pixels[i];
						pixels[di + 4 + 1] = pixels[i + 1];
						pixels[di + 4 + 2] = pixels[i + 2];
					} else if (b4 < 1) {
						//r = pixels[i];
						//g = pixels[i + 1];
						//b = pixels[i + 2];
						pixels[di - 4] = pixels[i];
						pixels[di - 4 + 1] = pixels[i + 1];
						pixels[di - 4 + 2] = pixels[i + 2];
					}
					//pixels[i + 4 + 3] = pixels[i + 3];
					pixels[i] = 0;
					pixels[i + 1] = 0;
					pixels[i + 2] = 0;
					//pixels[i + 3] = 0;
				}
			}
		}
	}
	updatePixels();
	
	// 0 for classical falling sand parameters
	m = noise(frameCount / 4) * 180;
	mn = noise(frameCount / 2) * 180;
}"
"900051","Rainy / Foggy swamp","mySketch","function setup() {
	createCanvas(windowWidth, windowHeight);
	
	noStroke();
	
	background(0);
	
	colorMode(HSL, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	generate();
}

function draw() {
	
}

function generate() {
	noStroke();
	
	background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 24, ny / 24);
			let n2 = noise(nx / 8, ny / 8);
			
			let yy = height / 3.9 + y - n * height;
			fill(60 - 30 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 2 + 0.25))), 0, 148 + pow(ny, 1) * 100, random(0.25, 0.75));
			stroke(0, 0, random(0, 128), random(0,0.025));
			ellipse(x + random(-8, 8), yy + random(-8, 8), 16, 16);
		}
	}
	
	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			
			stroke(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 0, 170 + pow(ny, 1) * 68, 1);
			line(x + random(-128, 128), yy, x + random(-128, 128), yy - random(32, height));
		}
	}
	
	for (y = height; y > 0; y -= 8) {
		for (x = 0; x < width; x += 8) {
			if (random() > 0.85) {
				stroke(0, 0, 0, random(0, 0.25));
				let xx = x + random(-4, 4);
				line(xx, y, xx + random(-1, 1), y + random(-1, 1));
			}
		}
	}

	for (y = 0; y < height / 2; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.05);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
	
	//fill(0, 0, 0, 1);
	//rect(width / 2, height / 2 - height / 2.5 / 2 + 40, width / 10, height / 2.5);
	
	let wl = 255 * (height / 976);
	let m = 0; // get max y
	for (y = 0; y < (height - m); y += 1) {
		let ny = y / height;
		let noy = noise(ny);
		
		for (x = 0; x < width; x += 1) {
			let yy = (height / 2 + noise(x / width) * 8) + y + m;
			
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = (0.5 - noise(nx, ny)) * 2;
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 0.5 + ny * PI * 1 + nox * PI * 2.15)) / 2 * nox2;
			
			if (random() > 0.15) {
				
				let xx = x + random(-2, 2);
				let yh2 = random(-200, 200) * n * ny;
				noStroke();
				
				if (random() > 0.996 && n > 0.05) {
					fill(64, 64, 48, 1);
					rect(xx, yy - yh2, random(2, 8) * ny, 48 * ny);
				}
				
				stroke(128 + (nox2) * 8, 100 * nox3, (200*nox3-random(200) * n), random() * 0.45 * pow(ny, 0.3));
				line(xx, yy, xx + random(-200, 200) * n * noy * ny, yy + yh2);
			}
		}
	}
}"
"898052","Swamp","mySketch","function setup() {
	createCanvas(windowWidth, windowHeight);
	
	noStroke();
	
	background(0);
	
	colorMode(HSL, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	generate();
}

function draw() {
	
}

function generate() {
	noStroke();
	
	background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 24, ny / 24);
			let n2 = noise(nx / 8, ny / 8);
			
			let yy = height / 3.9 + y - n * height;
			fill(60 - 30 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 2 + 0.25))), 128, 148 + pow(ny, 1) * 100, random(0.25, 0.75));
			stroke(0, 0, random(0, 128), random(0,0.025));
			ellipse(x + random(-8, 8), yy + random(-8, 8), 16, 16);
		}
	}
	
	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 12, ny / 12);
			let n2 = noise(nx * 4, ny - 4);
			
			let yy = height - height / 24 + y - n * height;
			fill(100 - 60 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))) + random(-40, 40), 64, 170 + pow(ny, 1) * 68, 1);
			stroke(0, 0, random(0, 128), random(0,0.05));
			ellipse(x + random(-1, 1), yy + random(-1, 1), 16, 16);
		}
	}
	
	
	
	for (y = height; y > 0; y -= 8) {
		for (x = 0; x < width; x += 8) {
			if (random() > 0.85) {
				stroke(0, 0, 0, random(0, 0.25));
				let xx = x + random(-4, 4);
				line(xx, y, xx + random(-1, 1), y + random(-1, 1));
			}
		}
	}

	for (y = 0; y < height / 2; y += 2) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.05);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
	
	//fill(0, 0, 0, 1);
	//rect(width / 2, height / 2 - height / 2.5 / 2 + 40, width / 10, height / 2.5);
	
	let wl = 255 * (height / 976);
	let m = 0; // get max y
	for (y = 0; y < (height - m); y += 1) {
		let ny = y / height;
		let noy = noise(ny);
		
		for (x = 0; x < width; x += 1) {
			let yy = (height / 2 + noise(x / width) * 8) + y + m;
			
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = (0.5 - noise(nx, ny)) * 2;
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 0.5 + ny * PI * 1 + nox * PI * 2.15)) / 2 * nox2;
			
			if (random() > 0.15) {
				
				let xx = x + random(-2, 2);
				let yh2 = random(-200, 200) * n * ny;
				noStroke();
				
				if (random() > 0.996 && n > 0.05) {
					fill(64, 64, 48, 1);
					rect(xx, yy - yh2, random(2, 8) * ny, 48 * ny);
				}
				
				stroke(128 + (nox2) * 8, 100 * nox3, (200*nox3-random(200) * n), random() * 0.45 * pow(ny, 0.3));
				line(xx, yy, xx + random(-200, 200) * n * noy * ny, yy + yh2);
			}
		}
	}

	for (y = 0; y < height / 2; y += 16) {
		let ny = y / height;
		let noy = noise(ny);
		for (x = 0; x < width; x += 3) {
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = noise(nx, ny);
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2 * nox2;

			let yy = y;

			if (random() > 0.999) {
				stroke(0, 0, 0, 1);
				strokeWeight(0.5);
				let tx = x + random(1, 6);
				let ty = yy + random(1, 6);
				line(x, yy, tx, ty);
				line(tx, ty, tx + random(1, 6) * (1-ny), ty - random(1, 4) * (1-ny));
			}
		}
	}
}"
"897449","Grainy ocean","mySketch","function setup() {
	createCanvas(windowWidth, windowHeight);
	
	noStroke();
	
	background(0);
	
	colorMode(HSL, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	generate();
}

function draw() {
	
}

function generate() {
	noStroke();
	
	background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 24, ny / 24);
			let n2 = noise(nx, ny);
			
			let yy = height / 3.9 + y - n * height;
			fill(224 - 20 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))), 118, 128 + pow(ny, 1) * 128, 1);
			rect(x, yy, 4, 5);
		}
	}
	
	for (y = height; y > 0; y -= 8) {
		for (x = 0; x < width; x += 8) {
			if (random() > 0.85) {
				stroke(0, 0, 0, random(0, 0.25));
				let xx = x + random(-4, 4);
				line(xx, y, xx + random(-1, 1), y + random(-1, 1));
			}
		}
	}

	for (y = 0; y < height / 2; y += 1) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		//line(0, y, width, y);
	
		for (x = 0; x < width; x += 64) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.05);
				let xx = x + random(-2, 2);
				line(xx, y, xx + random(-200, 200), y + random(-1, 1));
			}
		}
	}
	
	let wl = 255 * (height / 976);
	let m = 0; // get max y
	for (y = 0; y < (height - m); y += 1) {
		let ny = y / height;
		let noy = noise(ny);
		
		for (x = 0; x < width; x += 1) {
			let yy = (height / 2 + noise(x / width) * 8) + y + m;
			
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = (0.5 - noise(nx, ny)) * 2;
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 0.5 + ny * PI * 1 + nox * PI * 2.15)) / 2 * nox2;
			
			if (random() > 0.25) {
				stroke(224 + (nox2) * 24, 200 * nox3, 200*nox3-random(200) * n, random() * 0.45 * pow(ny, 0.3));
				let xx = x + random(-2, 2);
				line(xx, yy, xx + random(-200, 200) * n * noy * ny, yy + random(-20, 20) * n * ny);
			}
		}
	}

	for (y = 0; y < height / 2; y += 16) {
		let ny = y / height;
		let noy = noise(ny);
		for (x = 0; x < width; x += 3) {
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = noise(nx, ny);
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2 * nox2;

			let yy = y;

			if (random() > 0.9992) {
				stroke(0, 0, 0, 1);
				strokeWeight(0.5);
				let tx = x + random(1, 6);
				let ty = yy + random(1, 6);
				line(x, yy, tx, ty);
				line(tx, ty, tx + random(1, 6) * (1-ny), ty - random(1, 4) * (1-ny));
			}
		}
	}
}"
"897421","Colors","mySketch","function setup() {
	createCanvas(windowWidth, windowHeight);
	
	noStroke();
	
	background(0);
	
	colorMode(HSL, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	generate();
}

function draw() {
	
}

function generate() {
	noStroke();
	
	background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	let wl = 255 * (height / 976);
	let m = 0; // get max y
	for (y = 0; y < (height - m); y += 1) {
		let yy = y + m;

		let ny = y / height;
		let noy = noise(ny);
		
		for (x = 0; x < width; x += 1) {
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = (0.5 - noise(nx, ny)) * 2;
			let nox3 = noise(nx / 4, ny / 4);
			let n = (sin(nx * PI * 4 + ny * PI * 2 + nox * PI * 1.15) % cos(ny * PI * 2 * nox3 + nx * PI * 2)) / 2 * nox2;
			
			if (random() > 0.1) {
				stroke(224 + abs(nox2) * 32, 200 * nox3, 200*nox3-random(200) * n, random() * 0.35);
				let xx = x + random(-2, 2);
				line(xx, yy, xx + random(-200, 200) * n * noy, yy + random(-20, 20) * n);
			}
		}
	}

}"
"897421","Colors","mySketch","function setup() {
	createCanvas(windowWidth, windowHeight);
	
	noStroke();
	
	background(0);
	
	colorMode(HSL, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	generate();
}

function draw() {
	
}

function generate() {
	noStroke();
	
	background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	let wl = 255 * (height / 976);
	let m = 0; // get max y
	for (y = 0; y < (height - m); y += 1) {
		let yy = y + m;

		let ny = y / height;
		let noy = noise(ny);
		
		for (x = 0; x < width; x += 1) {
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = (0.5 - noise(nx, ny)) * 2;
			let nox3 = noise(nx / 4, ny / 4);
			let n = (sin(nx * PI * 4 + ny * PI * 2 + nox * PI * 1.15) % cos(ny * PI * 2 * nox3 + nx * PI * 2)) / 2 * nox2;
			
			if (random() > 0.5) {
				stroke(224 + (nox2) * 24, 200 * nox3, 200*nox3-random(200) * n, random() * 0.35);
				let xx = x + random(-2, 2);
				line(xx, yy, xx + random(-200, 200) * n * noy, yy + random(-20, 20) * n);
			}
		}
	}

}"
"897421","Colors","mySketch","function setup() {
	createCanvas(windowWidth, windowHeight);
	
	noStroke();
	
	background(0);
	
	colorMode(HSL, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	generate();
}

function draw() {
	
}

function generate() {
	noStroke();
	
	background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	let wl = 255 * (height / 976);
	let m = 0; // get max y
	for (y = 0; y < (height - m); y += 1) {
		let yy = y + m;

		let ny = y / height;
		let noy = noise(ny);
		
		for (x = 0; x < width; x += 1) {
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = (0.5 - noise(nx, ny)) * 2;
			let nox3 = noise(nx / 4, ny / 4);
			let n = (sin(nx * PI * 4 + ny * PI * 2 + nox * PI * 1.15) % cos(ny * PI * 2 * nox3 + nx * PI * 2)) / 2 * nox2;
			
			if (random() > 0.5) {
				stroke(224 + (nox2) * 24, 200 * nox3, 200*nox3-random(200) * n, random() * 0.35);
				let xx = x + random(-2, 2);
				line(xx, yy, xx + random(-200, 200) * n * noy, yy + random(-20, 20) * n);
			}
		}
	}

}"
"896694","Drseaw","mySketch","function setup() {
	createCanvas(windowWidth, windowHeight);
	
	noStroke();
	
	background(0);
	
	colorMode(HSL, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	generate();
}

function draw() {
	
}

function generate() {
	noStroke();
	
	background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;

	let wl = 255 * (height / 976);
	let m = 0; // get max y
	for (y = 0; y < (height - m); y += 1) {
		let yy = y + m;

		let ny = y / height;
		let noy = noise(ny);
		
		for (x = 0; x < width; x += 1) {
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = (0.5 - noise(nx, ny)) * 2;
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 1.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2 * nox2;
			
			if (random() > 0.75) {
				stroke(224 + nox2 * 12, 128, random(32) * n, random() * 0.35);
				let xx = x + random(-2, 2);
				line(xx, yy, xx + random(-20, 20) * n, yy + random(-20, 20) * n);
			}
		}
	}

}"
"894376","2d landscape 2","mySketch","// 2d landscape generator, very sensitive to parameters
// started as a fake 3d landscape with noise

function setup() {
	createCanvas(windowWidth, windowHeight);
	background(0);
	
	colorMode(HSL, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	
	generate();
}

function draw() {
	
}

function generate() {
	background(0);
	
	noStroke();
	
	let x = 0, y = 0;
	let ystep = 1;
	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 24, ny / 24);
			let n2 = noise(nx, ny);
			
			let yy = height / 3.9 + y - n * height;
			fill(224 - 20 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))), 118, 128 + pow(ny, 1) * 128, 1);
			rect(x, yy, 4, 5);
		}
	}
	/*
	let m = 0; // get max y
	for (x = 0; x < width; x += 3) {
		let nx = x / width;
		let n = noise(nx, 0);
		let yy = height - n * (height / 2);

		m = max(m, yy);
	}
	
	for (y = height; y > 0; y -= 8) {
		for (x = 0; x < width; x += 8) {
			if (random() > 0.85) {
				stroke(0, 0, 255, random(0, 0.25));
				let xx = x + random(-4, 4);
				line(xx, y, xx + random(-4, 4), y + random(-4, 4));
			}
		}
	}
	
	let wl = 18;
	for (y = height; y > 0; y -= 2) {
		if (random() > 0.75) {
				stroke(0, 0, 255, random(0, 0.05));
			  strokeWeight(random(1, 16));
				line(random(-width * 64, width * 64), 0, random(-width * 64, width * 64), m - wl);
		}
	}
	
	for (y = 0; y < wl; y += 1) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		let yy = m - y;
		line(0, yy, width, yy);
		
		for (x = 0; x < width; x += 3) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random());
				let xx = x + random(-2, 2);
				line(xx, yy, xx + random(-2, 2), yy + random(-1, 1));
			}
		}
	}
	*/
	// landscape
	for (y = 0; y < height + 400; y += 2) {
		let ny = y / height;
		let noy = noise(ny);
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = noise(nx, ny);
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2 * nox2;
			let n2 = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2;//noise(nx * 14, ny * 14);
			
			let yy = height / 2 + y - n * (height / 3) * (1 - ny);
			noStroke();
			fill(40 + noy * 4, 
					 (128 + 32 * n2 + (noy * 160) * abs(sin(nx * PI * 3 + ny * PI * 8))) * pow(ny, 0.4), 
					 140 - 64 * pow(n2, 3) * pow(ny, 0.5) * nox - 8 * abs(sin(nx * PI * 24 + ny * PI * 64)),
					 1);
			ellipse(x, yy, 8, 2 + 19 * pow((1 - ny), 0.4));
			/*
			if (random() > 0.05 && n > 0.05) {
				let tx = x + random(-1, 1) * 8;
				stroke(50 + random(-10, 10), 255, 128, 1);
				strokeWeight(random(0.25, 1));
				line(tx, yy + 4, tx, yy - 38 + 16);
			}*/
		}
	}
	/*
	for (y = -13; y > -15; y -= ystep) {
		let ny = abs(y) / height;
		for (x = 0; x < width; x += 3) {
			let nx = x / width;
			let n = noise(nx, ny);

			let yy = height + y - n * (height / 2);

			if (random() > 0.965 + 0.035 * n) {
				stroke(0, 0, 0, 1);
				strokeWeight(0.5);
				let tx = x + random(1, 4);
				let ty = yy + random(1, 4);
				line(x, yy, tx, ty);
				line(tx, ty, tx + random(1, 4), ty - random(1, 3));
			}
		}
	}*/
}"
"894376","2d landscape 2","mySketch","// 2d landscape generator, very sensitive to parameters
// started as a fake 3d landscape with noise

function setup() {
	createCanvas(windowWidth, windowHeight);
	background(0);
	
	colorMode(HSL, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	generate();
}

function draw() {
	
}

function generate() {
	background(255);
	
	noStroke();
	
	let x = 0, y = 0;
	let ystep = 1;
	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 24, ny / 24);
			let n2 = noise(nx, ny);
			
			let yy = height / 3.9 + y - n * height;
			fill(224 - 20 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))), 118, 128 + pow(ny, 1) * 128, 1);
			rect(x, yy, 4, 5);
		}
	}
	
	let m = 0; // get max y
	for (x = 0; x < width; x += 3) {
		let y = -380;
		let ny = y / height;
		let nx = x / width;
		let nox = noise(nx * 2, ny * 8);
		let nox2 = noise(nx, ny);
		let nox3 = noise(nx / 8, ny / 8);
		let n = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2 * nox2;
		let n2 = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2;//noise(nx * 14, ny * 14);

		let yy = height / 2 + y - n * (height / 3) * (1 - ny);

		m = max(m, yy);
	}
	
	for (y = height; y > 0; y -= 8) {
		for (x = 0; x < width; x += 8) {
			if (random() > 0.9) {
				stroke(0, 0, 255, random(0, 0.25));
				let xx = x + random(-4, 4);
				line(xx, y, xx + random(-4, 4), y + random(-4, 4));
			}
		}
	}
	
	let wl = 128;
	for (y = height; y > 0; y -= 4) {
		if (random() > 0.5) {
				stroke(0, 0, 255, random(0, 0.05) * (y / height));
			  strokeWeight(random(1, 2));
				line(random(-width * 64, width * 64), 0, random(-width * 64, width * 64), m - wl);
		}
	}
	
	for (y = 0; y < wl; y += 1) {
		stroke(224, 128, 148, 1 * pow(1 - (y / wl), 0.5));
		strokeWeight(random(0.5, 1));
		
		let yy = m - y;
		line(0, yy, width, yy);
		
		for (x = 0; x < width; x += 3) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.5);
				let xx = x + random(-2, 2);
				line(xx, yy, xx + random(-2, 2), yy + random(-1, 1));
			}
		}
	}
noStroke();
	// landscape
	for (y = 0; y < height + 400; y += 2) {
		let ny = y / height;
		let noy = noise(ny);
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = noise(nx, ny);
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2 * nox2;
			let n2 = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2;//noise(nx * 14, ny * 14);
			
			let yy = height / 2 + y - n * (height / 3) * (1 - ny);
			
			fill(40 + noy * 4, 
					 (128 + 32 * n2 + (noy * 160) * abs(sin(nx * PI * 3 + ny * PI * 8))) * pow(ny, 0.4), 
					 140 - 64 * pow(n2, 3) * pow(ny, 0.5) * nox - 8 * abs(sin(nx * PI * 24 + ny * PI * 64)),
					 1);
			ellipse(x, yy, 12, 2 + 23 * pow((1 - ny), 0.4));
			/*
			if (random() > 0.05 && n > 0.05) {
				let tx = x + random(-1, 1) * 8;
				stroke(50 + random(-10, 10), 255, 128, 1);
				strokeWeight(random(0.25, 1));
				line(tx, yy + 4, tx, yy - 38 + 16);
			}*/
		}
	}
	/*
	for (y = -13; y > -15; y -= ystep) {
		let ny = abs(y) / height;
		for (x = 0; x < width; x += 3) {
			let nx = x / width;
			let n = noise(nx, ny);

			let yy = height + y - n * (height / 2);

			if (random() > 0.965 + 0.035 * n) {
				stroke(0, 0, 0, 1);
				strokeWeight(0.5);
				let tx = x + random(1, 4);
				let ty = yy + random(1, 4);
				line(x, yy, tx, ty);
				line(tx, ty, tx + random(1, 4), ty - random(1, 3));
			}
		}
	}*/
}"
"894376","2d landscape 2","mySketch","// 2d landscape generator, very sensitive to parameters
// started as a fake 3d landscape with noise

function setup() {
	createCanvas(windowWidth, windowHeight);
	background(0);
	
	colorMode(HSL, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	generate();
}

function draw() {
	
}

function generate() {
	background(255);
	
	noStroke();
	
	let x = 0, y = 0;
	let ystep = 1;
	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 24, ny / 24);
			let n2 = noise(nx, ny);
			
			let yy = height / 3.9 + y - n * height;
			fill(224 - 20 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))), 118, 128 + pow(ny, 1) * 128, 1);
			rect(x, yy, 4, 5);
		}
	}
	
	let m = 0; // get max y
	for (x = 0; x < width; x += 3) {
		let y = -380;
		let ny = y / height;
		let nx = x / width;
		let nox = noise(nx * 2, ny * 8);
		let nox2 = noise(nx, ny);
		let nox3 = noise(nx / 8, ny / 8);
		let n = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2 * nox2;
		let n2 = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2;//noise(nx * 14, ny * 14);

		let yy = height / 2 + y - n * (height / 3) * (1 - ny);

		m = max(m, yy);
	}
	
	for (y = height; y > 0; y -= 8) {
		for (x = 0; x < width; x += 8) {
			if (random() > 0.9) {
				stroke(0, 0, 255, random(0, 0.25));
				let xx = x + random(-4, 4);
				line(xx, y, xx + random(-4, 4), y + random(-4, 4));
			}
		}
	}
	
	let wl = 128;
	for (y = height; y > 0; y -= 4) {
		if (random() > 0.5) {
				stroke(0, 0, 255, random(0, 0.05) * (y / height));
			  strokeWeight(random(1, 2));
				line(random(-width * 64, width * 64), 0, random(-width * 64, width * 64), m - wl);
		}
	}
	
	for (y = 0; y < wl; y += 1) {
		stroke(224, 128, 148, 1 * pow(1 - (y / wl), 0.5));
		strokeWeight(random(0.5, 1));
		
		let yy = m - y;
		line(0, yy, width, yy);
		
		for (x = 0; x < width; x += 3) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.5);
				let xx = x + random(-2, 2);
				line(xx, yy, xx + random(-2, 2), yy + random(-1, 1));
			}
		}
	}
	
	noStroke();
	
	// landscape
	for (y = 0; y < height + 400; y += 2) {
		let ny = y / height;
		let noy = noise(ny);
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = noise(nx, ny);
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2 * nox2;

			let yy = height / 2 + y - n * (height / 3) * (1 - ny);
			
			let h = 40 + noy * 4 + nox * 16;
			let s = (128 + 32 * n + (noy * 160) * abs(sin((nx * PI * 3 + ny * PI * 8) * nox / 8))) * pow(ny, 0.4);
			let b = 140 - 64 * pow(n, 3) * pow(ny, 0.5) * nox - 8 * abs(sin((nx * PI * 4 + ny * PI * 4) * nox));
			
			if (n > 0.5) {
				stroke(0, 0, 0, 1);
				strokeWeight(0.15 * ny);
				fill(h, s, lerp(b, 210, 1 - (1 - n) / (1 - 0.5)), 1);
			} else {
				fill(h, s, b, 1);
			}
			ellipse(x, yy, 12, 2 + 23 * pow((1 - ny), 0.4));
			
			if (random() < (0.75 * (1 - n)) && h > 58 && s > 40) {
				let tx = x + random(-1, 1) * 8;
				stroke(60 + random(-10, 10), 128, 128, 1);
				strokeWeight(random(0.5, 4));
				line(tx, yy, tx, yy - 8);
				noStroke();
			}
		}
	}
	
	for (y = 0; y < height; y += 16) {
		let ny = y / height;
		let noy = noise(ny);
		for (x = 0; x < width; x += 3) {
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = noise(nx, ny);
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2 * nox2;

			let yy = height / 2 + y - n * (height / 3) * (1 - ny);

			if (random() > 0.999) {
				stroke(0, 0, 0, 1);
				strokeWeight(0.5);
				let tx = x + random(1, 6);
				let ty = yy + random(1, 6);
				line(x, yy, tx, ty);
				line(tx, ty, tx + random(1, 6) * (1-ny), ty - random(1, 4) * (1-ny));
			}
		}
	}
}"
"894376","2d landscape 2","mySketch","// 2d landscape generator, very sensitive to parameters
// started as a fake 3d landscape with noise

function setup() {
	createCanvas(windowWidth, windowHeight);
	background(0);
	
	colorMode(HSL, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	generate();
}

function draw() {
	
}

function generate() {
	background(255);
	
	noStroke();
	
	let x = 0, y = 0;
	let ystep = 1;
	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 24, ny / 24);
			let n2 = noise(nx, ny);
			
			let yy = height / 3.9 + y - n * height;
			fill(224 - 20 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))), 118, 128 + pow(ny, 1) * 128, 1);
			rect(x, yy, 4, 5);
		}
	}
	
	let m = 0; // get max y
	for (x = 0; x < width; x += 3) {
		let y = -380;
		let ny = y / height;
		let nx = x / width;
		let nox = noise(nx * 2, ny * 8);
		let nox2 = noise(nx, ny);
		let nox3 = noise(nx / 8, ny / 8);
		let n = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2 * nox2;
		let n2 = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2;//noise(nx * 14, ny * 14);

		let yy = height / 2 + y - n * (height / 3) * (1 - ny);

		m = max(m, yy);
	}
	
	for (y = height; y > 0; y -= 8) {
		for (x = 0; x < width; x += 8) {
			if (random() > 0.9) {
				stroke(0, 0, 255, random(0, 0.25));
				let xx = x + random(-4, 4);
				line(xx, y, xx + random(-4, 4), y + random(-4, 4));
			}
		}
	}
	
	let wl = 128;
	for (y = height; y > 0; y -= 4) {
		if (random() > 0.5) {
				stroke(0, 0, 255, random(0, 0.05) * (y / height));
			  strokeWeight(random(1, 2));
				line(random(-width * 64, width * 64), 0, random(-width * 64, width * 64), m - wl);
		}
	}
	
	for (y = 0; y < wl; y += 1) {
		stroke(224, 128, 148, 1 * pow(1 - (y / wl), 0.5));
		strokeWeight(random(0.5, 1));
		
		let yy = m - y;
		line(0, yy, width, yy);
		
		for (x = 0; x < width; x += 3) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.5);
				let xx = x + random(-2, 2);
				line(xx, yy, xx + random(-2, 2), yy + random(-1, 1));
			}
		}
	}
	
	noStroke();
	
	// landscape
	for (y = 0; y < height + 400; y += 2) {
		let ny = y / height;
		let noy = noise(ny);
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = noise(nx, ny);
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2 * nox2;

			let yy = height / 2 + y - n * (height / 3) * (1 - ny);
			
			let h = 40 + noy * 4 + nox * 16;
			let s = (128 + 32 * n + (noy * 160) * abs(sin((nx * PI * 3 + ny * PI * 8) * nox / 8))) * pow(ny, 0.4);
			let b = 140 - 30 * pow(1-n, 1.475);
			
			if (n > 0.5) {
				stroke(0, 0, 0, 1);
				strokeWeight(0.15 * ny);
				fill(h, s, lerp(b, 210, 1 - (1 - n) / (1 - 0.5)), 1);
			} else {
				fill(h, s, b, 1);
			}
			ellipse(x, yy, 12, 2 + 23 * pow((1 - ny), 0.4));
			
			if (random() < (0.995 * (1 - n)) && h > 58 && s > 40) {
				let i = 0;
				for (i = 0; i < 8; i += 1) {
					let tx = x + random(-4, 4) * 8;
					let ty = yy + random(-2, 8);
					stroke(60 + random(-10, 20), 128, b / (1.3 + random(-0.3, 0.6)), random());
					strokeWeight(0.5 + random(0.5, 3) * (1-ny));
					line(tx, ty, tx, ty - 8 * (1-ny));
					noStroke();
				}
			}
		}
	}
	
	for (y = 0; y < height; y += 16) {
		let ny = y / height;
		let noy = noise(ny);
		for (x = 0; x < width; x += 3) {
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = noise(nx, ny);
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2 * nox2;

			let yy = height / 2 + y - n * (height / 3) * (1 - ny);

			if (random() > 0.999) {
				stroke(0, 0, 0, 1);
				strokeWeight(0.5);
				let tx = x + random(1, 6);
				let ty = yy + random(1, 6);
				line(x, yy, tx, ty);
				line(tx, ty, tx + random(1, 6) * (1-ny), ty - random(1, 4) * (1-ny));
			}
		}
	}
}"
"894376","2d landscape 2","mySketch","// 2d landscape generator, very sensitive to parameters
// started as a fake 3d landscape with noise

function setup() {
	createCanvas(windowWidth, windowHeight);
	background(0);
	
	colorMode(HSL, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	generate();
}

function draw() {
	
}

function generate() {
	background(255);
	
	noStroke();
	
	let x = 0, y = 0;
	let ystep = 1;
	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 24, ny / 24);
			let n2 = noise(nx, ny);
			
			let yy = height / 3.9 + y - n * height;
			fill(224 - 20 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))), 118, 128 + pow(ny, 1) * 128, 1);
			rect(x, yy, 4, 5);
		}
	}
	
	let m = 0; // get max y
	for (x = 0; x < width; x += 3) {
		let y = -380;
		let ny = y / height;
		let nx = x / width;
		let nox = noise(nx * 2, ny * 8);
		let nox2 = noise(nx, ny);
		let nox3 = noise(nx / 8, ny / 8);
		let n = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2 * nox2;
		let n2 = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2;//noise(nx * 14, ny * 14);

		let yy = height / 2 + y - n * (height / 3) * (1 - ny);

		m = max(m, yy);
	}
	
	for (y = height; y > 0; y -= 8) {
		for (x = 0; x < width; x += 8) {
			if (random() > 0.9) {
				stroke(0, 0, 255, random(0, 0.25));
				let xx = x + random(-4, 4);
				line(xx, y, xx + random(-4, 4), y + random(-4, 4));
			}
		}
	}
	
	let wl = 128;
	for (y = height; y > 0; y -= 4) {
		if (random() > 0.5) {
				stroke(0, 0, 255, random(0, 0.05) * (y / height));
			  strokeWeight(random(1, 2));
				line(random(-width * 64, width * 64), 0, random(-width * 64, width * 64), m - wl);
		}
	}
	
	for (y = 0; y < wl; y += 1) {
		stroke(224, 128, 148, 1 * pow(1 - (y / wl), 0.5));
		strokeWeight(random(0.5, 1));
		
		let yy = m - y;
		line(0, yy, width, yy);
		
		for (x = 0; x < width; x += 3) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.5);
				let xx = x + random(-2, 2);
				line(xx, yy, xx + random(-2, 2), yy + random(-1, 1));
			}
		}
	}
	
	noStroke();
	
	// landscape
	for (y = 0; y < height + 400; y += 2) {
		let ny = y / height;
		let noy = noise(ny);
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = noise(nx, ny);
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2 * nox2;

			let yy = height / 2 + y - n * (height / 3) * (1 - ny);
			
			let h = 40 + noy * 4 + nox * 16;
			let s = (128 + 32 * n + (noy * 160) * abs(sin((nx * PI * 3 + ny * PI * 8) * nox / 8))) * pow(ny, 0.4);
			let b = 140 - 30 * pow(1-n, 1.475);
			
			if (n > 0.5) {
				stroke(0, 0, 0, 1);
				strokeWeight(0.15 * ny);
				fill(h, s, lerp(b, 210, 1 - (1 - n) / (1 - 0.5)), 1);
			} else {
				fill(h, s, b, 1);
			}
			ellipse(x, yy, 12, 2 + 23 * pow((1 - ny), 0.4));
			
			if (random() < (0.995 * (1 - n)) && s > 40) {
				let i = 0;
				for (i = 0; i < 16; i += 1) {
					let tx = x + random(-4, 4) * 8;
					let ty = yy + random(-2, 2);
					stroke(60 + random(-10, 20), 128, b / (1.3 + random(-0.3, 0.6)), 1);
					strokeWeight(0.5 + random(0.5, 3) * pow(ny, 0.5));
					line(tx, ty, tx, ty - 6 * pow(ny, 0.25));
					noStroke();
				}
			}
		}
	}
	
	for (y = 0; y < height; y += 16) {
		let ny = y / height;
		let noy = noise(ny);
		for (x = 0; x < width; x += 3) {
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = noise(nx, ny);
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2 * nox2;

			let yy = height / 2 + y - n * (height / 3) * (1 - ny);

			if (random() > 0.999) {
				stroke(0, 0, 0, 1);
				strokeWeight(0.5);
				let tx = x + random(1, 6);
				let ty = yy + random(1, 6);
				line(x, yy, tx, ty);
				line(tx, ty, tx + random(1, 6) * (1-ny), ty - random(1, 4) * (1-ny));
			}
		}
	}
}"
"894376","2d landscape 2","mySketch","// 2d landscape generator, sensitive to parameters
// same as the others with different parameters / stylized differently

function setup() {
	createCanvas(windowWidth, windowHeight);
	background(0);
	
	colorMode(HSL, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	generate();
}

function draw() {
	
}

function generate() {
	background(255);
	
	noStroke();
	
	let x = 0, y = 0;
	let ystep = 1;
	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 24, ny / 24);
			let n2 = noise(nx, ny);
			
			let yy = height / 3.9 + y - n * height;
			fill(224 - 20 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))), 118, 128 + pow(ny, 1) * 128, 1);
			rect(x, yy, 4, 5);
		}
	}
	
	let m = 0; // get max y
	for (x = 0; x < width; x += 3) {
		let y = -380;
		let ny = y / height;
		let nx = x / width;
		let nox = noise(nx * 2, ny * 8);
		let nox2 = noise(nx, ny);
		let nox3 = noise(nx / 8, ny / 8);
		let n = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2 * nox2;
		let n2 = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2;//noise(nx * 14, ny * 14);

		let yy = height / 2 + y - n * (height / 3) * (1 - ny);

		m = max(m, yy);
	}
	
	for (y = height; y > 0; y -= 8) {
		for (x = 0; x < width; x += 8) {
			if (random() > 0.9) {
				stroke(0, 0, 255, random(0, 0.25));
				let xx = x + random(-4, 4);
				line(xx, y, xx + random(-4, 4), y + random(-4, 4));
			}
		}
	}
	
	let wl = 128;
	for (y = height; y > 0; y -= 4) {
		if (random() > 0.5) {
				stroke(0, 0, 255, random(0, 0.05) * (y / height));
			  strokeWeight(random(1, 2));
				line(random(-width * 64, width * 64), 0, random(-width * 64, width * 64), m - wl);
		}
	}
	
	for (y = 0; y < wl; y += 1) {
		stroke(224, 128, 148, 1 * pow(1 - (y / wl), 0.5));
		strokeWeight(random(0.5, 1));
		
		let yy = m - y;
		line(0, yy, width, yy);
		
		for (x = 0; x < width; x += 3) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.5);
				let xx = x + random(-2, 2);
				line(xx, yy, xx + random(-2, 2), yy + random(-1, 1));
			}
		}
	}
	
	noStroke();
	
	// landscape
	for (y = 0; y < height + 400; y += 2) {
		let ny = y / height;
		let noy = noise(ny);
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = noise(nx, ny);
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2 * nox2;

			let yy = height / 2 + y - n * (height / 3) * (1 - ny);
			
			let h = 40 + noy * 4 + nox * 16;
			let s = (128 + 32 * n + (noy * 160) * abs(sin((nx * PI * 3 + ny * PI * 8) * nox / 8))) * pow(ny, 0.4);
			let b = 140 - 30 * pow(1-n, 1.475);
			
			if (n > 0.5) {
				stroke(0, 0, 0, 1);
				strokeWeight(0.15 * ny);
				fill(h, s, lerp(b, 210, 1 - (1 - n) / (1 - 0.5)), 1);
			} else {
				fill(h, s, b, 1);
			}
			ellipse(x, yy, 12, 2 + 23 * pow((1 - ny), 0.4));
			
			if (random() < (0.995 * (1 - n)) && s > 40) {
				let i = 0;
				for (i = 0; i < 16; i += 1) {
					let tx = x + random(-4, 4) * 8;
					let ty = yy + random(-2, 2);
					stroke(60 + random(-10, 20), 128, b / (1.3 + random(-0.3, 0.6)), 1);
					strokeWeight(0.5 + random(0.5, 3) * pow(ny, 0.5));
					line(tx, ty, tx, ty - 6 * pow(ny, 0.25));
					noStroke();
				}
			}
		}
	}
	
	for (y = 0; y < height; y += 16) {
		let ny = y / height;
		let noy = noise(ny);
		for (x = 0; x < width; x += 3) {
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = noise(nx, ny);
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2 * nox2;

			let yy = height / 8 + y - n * (height / 3) * (1 - ny);

			if (random() > 0.999) {
				stroke(0, 0, 0, 1);
				strokeWeight(0.5);
				let tx = x + random(1, 6);
				let ty = yy + random(1, 6);
				line(x, yy, tx, ty);
				line(tx, ty, tx + random(1, 6) * (1-ny), ty - random(1, 4) * (1-ny));
			}
		}
	}
}"
"894376","2d landscape 2","mySketch","// 2d landscape generator, sensitive to parameters
// same as the others with different parameters / stylized differently

function setup() {
	createCanvas(windowWidth, windowHeight);
	background(0);
	
	colorMode(HSL, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	generate();
}

function draw() {
	
}

function generate() {
	background(255);
	
	noStroke();
	
	let x = 0, y = 0;
	let ystep = 1;
	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 24, ny / 24);
			let n2 = noise(nx, ny);
			
			let yy = height / 3.9 + y - n * height;
			fill(224 - 20 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))), 118, 128 + pow(ny, 1) * 128, 1);
			rect(x, yy, 4, 5);
		}
	}
	
	let m = 0; // get max y
	for (x = 0; x < width; x += 3) {
		let y = -380;
		let ny = y / height;
		let nx = x / width;
		let nox = noise(nx * 2, ny * 8);
		let nox2 = noise(nx, ny);
		let nox3 = noise(nx / 8, ny / 8);
		let n = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2 * nox2;
		let n2 = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2;//noise(nx * 14, ny * 14);

		let yy = height / 2 + y - n * (height / 3) * (1 - ny);

		m = max(m, yy);
	}
	
	for (y = height; y > 0; y -= 8) {
		for (x = 0; x < width; x += 8) {
			if (random() > 0.9) {
				stroke(0, 0, 255, random(0, 0.25));
				let xx = x + random(-4, 4);
				line(xx, y, xx + random(-4, 4), y + random(-4, 4));
			}
		}
	}
	
	let wl = 128;
	for (y = height; y > 0; y -= 4) {
		if (random() > 0.5) {
				stroke(0, 0, 255, random(0, 0.05) * (y / height));
			  strokeWeight(random(1, 2));
				line(random(-width * 64, width * 64), 0, random(-width * 64, width * 64), m - wl);
		}
	}
	
	for (y = 0; y < wl; y += 1) {
		stroke(224, 128, 148, 1 * pow(1 - (y / wl), 0.5));
		strokeWeight(random(0.5, 1));
		
		let yy = m - y;
		line(0, yy, width, yy);
		
		for (x = 0; x < width; x += 3) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.5);
				let xx = x + random(-2, 2);
				line(xx, yy, xx + random(-2, 2), yy + random(-1, 1));
			}
		}
	}
	
	noStroke();
	
	// landscape
	for (y = 0; y < height + 400; y += 2) {
		let ny = y / height;
		let noy = noise(ny);
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = noise(nx, ny);
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2 * nox2;

			let yy = height / 2 + y - n * (height / 3) * (1 - ny);
			
			let h = 40 + noy * 4 + nox * 16;
			let s = (128 + 32 * n + (noy * 160) * abs(sin((nx * PI * 3 + ny * PI * 8) * nox / 8))) * pow(ny, 0.4);
			let b = 140 - 30 * pow(1-n, 1.475);
			
			if (n > 0.5) {
				stroke(0, 0, 0, 1);
				strokeWeight(0.15 * ny);
				fill(h, s, lerp(b, 210, 1 - (1 - n) / (1 - 0.5)), 1);
			} else {
				fill(h, s, b, 1);
			}
			ellipse(x, yy, 12, 2 + 23 * pow((1 - ny), 0.4));
			
			if (random() < (0.995 * (1 - n)) && s > 40) {
				let i = 0;
				for (i = 0; i < 16; i += 1) {
					let tx = x + random(-4, 4) * 8;
					let ty = yy + random(-2, 2);
					stroke(60 + random(-10, 20), 128, b / (1.3 + random(-0.3, 0.6)), 1);
					strokeWeight(0.5 + random(0.5, 3) * pow(ny, 0.5));
					line(tx, ty, tx, ty - 6 * pow(ny, 0.25));
					noStroke();
				}
			}
		}
	}
	
	for (y = 0; y < height; y += 16) {
		let ny = y / height;
		let noy = noise(ny);
		for (x = 0; x < width; x += 3) {
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = noise(nx, ny);
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2 * nox2;

			let yy = height / 8 + y - n * (height / 3) * (1 - ny);

			if (random() > 0.999) {
				stroke(0, 0, 0, 1);
				strokeWeight(0.5);
				let tx = x + random(1, 6);
				let ty = yy + random(1, 6);
				line(x, yy, tx, ty);
				line(tx, ty, tx + random(1, 6) * (1-ny), ty - random(1, 4) * (1-ny));
			}
		}
	}
}"
"894376","2d landscape 2","mySketch","// 2d landscape generator, sensitive to parameters
// same as the others with different parameters / stylized differently

function setup() {
	createCanvas(windowWidth, windowHeight);
	background(0);
	
	colorMode(HSL, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	generate();
}

function draw() {
	
}

function generate() {
	background(255);
	
	noStroke();
	
	let x = 0, y = 0;
	let ystep = 1;
	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 24, ny / 24);
			let n2 = noise(nx, ny);
			
			let yy = height / 3.9 + y - n * height;
			fill(224 - 20 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))), 118, 128 + pow(ny, 1) * 128, 1);
			rect(x, yy, 4, 5);
		}
	}
	
	let m = 0; // get max y
	for (x = 0; x < width; x += 3) {
		let y = 0;
		let ny = y / height;
		let nx = x / width;
		let nox = noise(nx * 2, ny * 8);
		let nox2 = noise(nx, ny);
		let nox3 = noise(nx / 8, ny / 8);
		let n = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2 * nox2;
		let n2 = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2;//noise(nx * 14, ny * 14);

		let yy = height / 2 + y - n * (height / 3) * (1 - ny);

		m = max(m, yy);
	}
	
	for (y = height; y > 0; y -= 8) {
		for (x = 0; x < width; x += 8) {
			if (random() > 0.9) {
				stroke(0, 0, 255, random(0, 0.25));
				let xx = x + random(-4, 4);
				line(xx, y, xx + random(-4, 4), y + random(-4, 4));
			}
		}
	}
	
	let wl = 255 * (height / 976);
	for (y = height; y > 0; y -= 4) {
		if (random() > 0.5) {
				stroke(0, 0, 255, random(0, 0.05) * (y / height));
			  strokeWeight(random(1, 2));
				line(random(-width * 64, width * 64), 0, random(-width * 64, width * 64), m - wl);
		}
	}
	
	for (y = 0; y < wl; y += 1) {
		stroke(224, 128, 148, 1 * pow(1 - (y / wl), 0.5));
		strokeWeight(random(0.5, 1));
		
		let yy = m - y;
		line(0, yy, width, yy);
		
		for (x = 0; x < width; x += 3) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.5);
				let xx = x + random(-2, 2);
				line(xx, yy, xx + random(-2, 2), yy + random(-1, 1));
			}
		}
	}
	
	noStroke();
	
	// landscape
	for (y = 0; y < height + 400; y += 2) {
		let ny = y / height;
		let noy = noise(ny);
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = noise(nx, ny);
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2 * nox2;

			let yy = height / 2 + y - n * (height / 3) * (1 - ny);
			
			let h = 40 + noy * 4 + nox * 16;
			let s = (128 + 32 * n + (noy * 160) * abs(sin((nx * PI * 3 + ny * PI * 8) * nox / 8))) * pow(ny, 0.4);
			let b = 140 - 30 * pow(1-n, 1.475);
			
			if (n > 0.5) {
				stroke(0, 0, 0, 1);
				strokeWeight(0.15 * ny);
				fill(h, s, lerp(b, 210, 1 - (1 - n) / (1 - 0.5)), 1);
			} else {
				fill(h, s, b, 1);
			}
			ellipse(x, yy, 12, 2 + 23 * pow((1 - ny), 0.4));
			
			if (random() < (0.995 * (1 - n)) && s > 40) {
				let i = 0;
				for (i = 0; i < 16; i += 1) {
					let tx = x + random(-4, 4) * 8;
					let ty = yy + random(-2, 2);
					stroke(60 + random(-10, 20), 128, b / (1.3 + random(-0.3, 0.6)), 1);
					strokeWeight(0.5 + random(0.5, 3) * pow(ny, 0.5));
					line(tx, ty, tx, ty - 6 * pow(ny, 0.25));
					noStroke();
				}
			}
		}
	}
	
	for (y = 0; y < height; y += 16) {
		let ny = y / height;
		let noy = noise(ny);
		for (x = 0; x < width; x += 3) {
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = noise(nx, ny);
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2 * nox2;

			let yy = height / 8 + y - n * (height / 3) * (1 - ny);

			if (random() > 0.999) {
				stroke(0, 0, 0, 1);
				strokeWeight(0.5);
				let tx = x + random(1, 6);
				let ty = yy + random(1, 6);
				line(x, yy, tx, ty);
				line(tx, ty, tx + random(1, 6) * (1-ny), ty - random(1, 4) * (1-ny));
			}
		}
	}
}"
"894376","2d landscape 2","mySketch","// 2d landscape generator, sensitive to parameters
// same as the others with different parameters / stylized differently

function setup() {
	createCanvas(windowWidth, windowHeight);
	
	noStroke();
	
	background(0);
	
	colorMode(HSL, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.85);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	generate();
}

function draw() {
	
}

function generate() {
	noStroke();
	
	background(0, 0, 255, 1);
	
	let x = 0, y = 0;
	let ystep = 1;
	for (y = 0; y < height; y += 4) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 24, ny / 24);
			let n2 = noise(nx, ny);
			
			let yy = height / 3.9 + y - n * height;
			fill(224 - 20 * pow(ny, 2.25) * (n2 * abs(sin(nx * PI * 0.25 + ny * PI * 8 + 0.25))), 118, 128 + pow(ny, 1) * 128, 1);
			rect(x, yy, 4, 5);
		}
	}
	
	let m = 0; // get max y
	for (x = 0; x < width; x += 3) {
		let y = 0;
		let ny = y / height;
		let nx = x / width;
		let nox = noise(nx * 2, ny * 8);
		let nox2 = noise(nx, ny);
		let nox3 = noise(nx / 8, ny / 8);
		let n = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2 * nox2;
		let n2 = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2;//noise(nx * 14, ny * 14);

		let yy = height / 2 + y - n * (height / 3) * (1 - ny);

		m = max(m, yy);
	}
	
	for (y = height; y > 0; y -= 8) {
		for (x = 0; x < width; x += 8) {
			if (random() > 0.9) {
				stroke(0, 0, 255, random(0, 0.25));
				let xx = x + random(-4, 4);
				line(xx, y, xx + random(-4, 4), y + random(-4, 4));
			}
		}
	}
	
	let wl = 255 * (height / 976);
	for (y = height; y > 0; y -= 4) {
		if (random() > 0.5) {
				stroke(0, 0, 255, random(0, 0.05) * (y / height));
			  strokeWeight(random(1, 2));
				line(random(-width * 64, width * 64), 0, random(-width * 64, width * 64), m - wl);
		}
	}
	
	for (y = 0; y < wl; y += 1) {
		stroke(224, 128, 148, 1 * pow(1 - (y / wl), 0.5));
		strokeWeight(random(0.5, 1));
		
		let yy = m - y;
		line(0, yy, width, yy);
		
		for (x = 0; x < width; x += 3) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random() * 0.5);
				let xx = x + random(-2, 2);
				line(xx, yy, xx + random(-2, 2), yy + random(-1, 1));
			}
		}
	}
	
	noStroke();
	
	// landscape
	for (y = 0; y < height + 400; y += 2) {
		let ny = y / height;
		let noy = noise(ny);
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = noise(nx, ny);
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2 * nox2;

			let yy = height / 2 + y - n * (height / 3) * (1 - ny);
			
			let h = 40 + noy * 4 + nox * 16;
			let s = (128 + 32 * n + (noy * 160) * abs(sin((nx * PI * 3 + ny * PI * 8) * nox / 8))) * pow(ny, 0.4);
			let b = 140 - 30 * pow(1-n, 1.475);
			
			if (n > 0.5) {
				stroke(0, 0, 0, 1);
				strokeWeight(0.15 * ny);
				fill(h, s, lerp(b, 210, 1 - (1 - n) / (1 - 0.5)), 1);
			} else {
				fill(h, s, b, 1);
			}
			ellipse(x, yy, 12, 2 + 23 * pow((1 - ny), 0.4));
			
			if (random() < (0.995 * (1 - n)) && s > 40) {
				let i = 0;
				for (i = 0; i < 16; i += 1) {
					let tx = x + random(-4, 4) * 8;
					let ty = yy + random(-2, 2);
					stroke(60 + random(-10, 20), 128, b / (1.3 + random(-0.3, 0.6)), 1);
					strokeWeight(0.5 + random(0.5, 3) * pow(ny, 0.5));
					line(tx, ty, tx, ty - 6 * pow(ny, 0.25));
					noStroke();
				}
			}
		}
	}
	
	for (y = 0; y < height; y += 16) {
		let ny = y / height;
		let noy = noise(ny);
		for (x = 0; x < width; x += 3) {
			let nx = x / width;
			let nox = noise(nx * 2, ny * 8);
			let nox2 = noise(nx, ny);
			let nox3 = noise(nx / 8, ny / 8);
			let n = (sin(nx * PI * 4 + ny * PI * 6 + nox * PI * 0.15) + cos(ny * PI * 10 * nox3 + nx * PI * 2)) / 2 * nox2;

			let yy = height / 8 + y - n * (height / 3) * (1 - ny);

			if (random() > 0.999) {
				stroke(0, 0, 0, 1);
				strokeWeight(0.5);
				let tx = x + random(1, 6);
				let ty = yy + random(1, 6);
				line(x, yy, tx, ty);
				line(tx, ty, tx + random(1, 6) * (1-ny), ty - random(1, 4) * (1-ny));
			}
		}
	}
}"
"893431","2d landscape","mySketch","function setup() {
	createCanvas(windowWidth, windowHeight);
	background(0);
	
	colorMode(HSL, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.65);
	
	rectMode(CENTER);
	
	generate();
}

function draw() {
	
}

function generate() {
	background(255);
	
	noStroke();
	
	let x = 0, y = 0;
	let ystep = 1;
	for (y = windowHeight; y > 0; y -= 2) {
		let ny = y / windowHeight;
		for (x = 0; x < windowWidth; x += 4) {
			let nx = x / windowWidth;
			let n = noise(nx / 8, ny / 8);
			let n2 = noise(nx * 24, ny * 24);
			
			let yy = height / 4 + y - n * height;
			fill(224 - 20 * pow(ny, 2.25), 118, 128 + pow(ny, 2) * 128, 1);
			rect(x, yy, 4, 4);
		}
	}
	
	for (y = windowHeight; y > 0; y -= ystep) {
		let ny = y / windowHeight;
		for (x = 0; x < windowWidth; x += 3) {
			let nx = x / windowWidth;
			let n = noise(nx, ny);
			let n2 = noise(nx * 14, ny * 14);
			
			let lo = 0;
			if (n > 0.8) {
				lo = 124;
			}
			
			let yy = height + y - n * (height / 2);
			noStroke();
			fill(64 + lo + n2 * 20, 172, 16 + 128 * n2 + 128 - 64 * (pow((1 - ny), 3.25)), 1);
			rect(x, yy, 4, 4);
			
			if (random() > 0.25 * ny + 0.5 && lo == 0) {
				let tx = x + random(-1, 1) * 8;
				stroke(72 + random(-10, 10), 148 * pow(1 - ny, 4.25), 128, 1);
				strokeWeight(random(1, 4));
				line(tx, yy, tx + random(-3, 3), yy - n * 8);
			}
		}
	}
	
	for (y = 0; y > -32; y -= ystep) {
		let ny = abs(y) / 32;
		for (x = 0; x < windowWidth; x += 3) {
			let nx = x / windowWidth;
			let n = noise(nx, ny);
			let n2 = noise(nx * 14, ny * 14);
			
			let lo = 0;
			if (n > 0.8) {
				lo = 124;
			}
			
			let yy = height + y - n * (height / 2);
			noStroke();
			//fill(64 + lo + n2 * 20, 172, 16 + 128 * n2 + 128 - 64 * (pow((1 - ny), 3.25)), 1);
			//rect(x, yy, 4, 4);
			
			if (random() > 0.25 * ny + 0.5 && lo == 0) {
				let tx = x + random(-1, 1) * 8;
				stroke(72 + random(-10, 10), 148 * pow(1 - ny, 4.25), 128, 1);
				strokeWeight(random(1, 4));
				line(tx, yy, tx + random(-3, 3), yy - n * 8);
			}
		}
	}
}"
"893431","2d landscape","mySketch","function setup() {
	createCanvas(windowWidth, windowHeight);
	background(0);
	
	colorMode(HSL, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.65);
	
	rectMode(CENTER);
	
	generate();
}

function draw() {
	
}

function generate() {
	background(255);
	
	noStroke();
	
	let x = 0, y = 0;
	let ystep = 1;
	for (y = windowHeight; y > 0; y -= 2) {
		let ny = y / windowHeight;
		for (x = 0; x < windowWidth; x += 4) {
			let nx = x / windowWidth;
			let n = noise(nx / 8, ny / 8);
			let n2 = noise(nx * 24, ny * 24);
			
			let yy = height / 4 + y - n * height;
			fill(224 - 20 * pow(ny, 2.25), 118, 128 + pow(ny, 2) * 128, 1);
			rect(x, yy, 4, 4);
		}
	}
	
	for (y = windowHeight; y > 0; y -= ystep) {
		let ny = y / windowHeight;
		for (x = 0; x < windowWidth; x += 3) {
			let nx = x / windowWidth;
			let n = noise(nx, ny);
			let n2 = noise(nx * 14, ny * 14);
			
			let lo = 0;
			if (n > 0.8) {
				lo = 124;
			}
			
			let yy = height + y - n * (height / 2);
			noStroke();
			fill(64 + lo + n2 * 20, 172, 16 + 128 * n2 + 128 - 64 * (pow((1 - ny), 3.25)), 1);
			rect(x, yy, 4, 4);
			
			if (random() > 0.25 * ny + 0.5 && lo == 0) {
				let tx = x + random(-1, 1) * 8;
				stroke(72 + random(-10, 10), 148 * pow(1 - ny, 4.25), 128, 1);
				strokeWeight(random(1, 4));
				line(tx, yy, tx + random(-3, 3), yy - n * 8);
			}
		}
	}
	
	for (y = -13; y > -15; y -= ystep) {
		let ny = abs(y) / windowHeight;
		for (x = 0; x < windowWidth; x += 3) {
			let nx = x / windowWidth;
			let n = noise(nx, ny);

			let yy = height + y - n * (height / 2);

			if (random() > 0.965 + 0.035 * n) {
				stroke(0, 0, 0, 1);
				strokeWeight(0.5);
				let tx = x + random(1, 4);
				let ty = yy + random(1, 4);
				line(x, yy, tx, ty);
				line(tx, ty, tx + random(1, 4), ty - random(1, 3));
			}
		}
	}
}"
"893431","2d landscape","mySketch","// 2d landscape generator, very sensitive to parameters
// started as a fake 3d landscape with noise

function setup() {
	createCanvas(windowWidth, windowHeight);
	background(0);
	
	colorMode(HSL, 360, 255, 255, 1);
	
	noiseSeed(42);
	noiseDetail(6, 0.65);
	
	rectMode(CENTER);
	
	generate();
}

function draw() {
	
}

function generate() {
	background(255);
	
	noStroke();
	
	let x = 0, y = 0;
	let ystep = 1;
	for (y = height; y > 0; y -= 2) {
		let ny = y / height;
		for (x = 0; x < width; x += 4) {
			let nx = x / width;
			let n = noise(nx / 8, ny / 8);
			let n2 = noise(nx * 24, ny * 24);
			
			let yy = height / 4 + y - n * height;
			fill(224 - 20 * pow(ny, 2.25), 118, 128 + pow(ny, 2) * 128, 1);
			rect(x, yy, 4, 4);
		}
	}
	
	let m = 0; // get max y
	for (x = 0; x < width; x += 3) {
		let nx = x / width;
		let n = noise(nx, 0);
		let yy = height - n * (height / 2);

		m = max(m, yy);
	}
	
	for (y = height; y > 0; y -= 8) {
		for (x = 0; x < width; x += 8) {
			if (random() > 0.85) {
				stroke(0, 0, 255, random(0, 0.25));
				let xx = x + random(-4, 4);
				line(xx, y, xx + random(-4, 4), y + random(-4, 4));
			}
		}
	}
	
	let wl = 18;
	for (y = height; y > 0; y -= 2) {
		if (random() > 0.75) {
				stroke(0, 0, 255, random(0, 0.05));
			  strokeWeight(random(1, 16));
				line(random(-width * 64, width * 64), 0, random(-width * 64, width * 64), m - wl);
		}
	}
	
	for (y = 0; y < wl; y += 1) {
		stroke(224, 128, 148, 1);
		strokeWeight(1);
		
		let yy = m - y;
		line(0, yy, width, yy);
		
		for (x = 0; x < width; x += 3) {
			if (random() > 0.75) {
				stroke(0, 0, 255, random());
				let xx = x + random(-2, 2);
				line(xx, yy, xx + random(-2, 2), yy + random(-1, 1));
			}
		}
	}
	
	// landscape
	for (y = height; y > 0; y -= ystep) {
		let ny = y / height;
		for (x = 0; x < width; x += 3) {
			let nx = x / width;
			let n = noise(nx, ny);
			let n2 = noise(nx * 14, ny * 14);
			
			let lo = 0;
			if (n > 0.8) {
				lo = 124;
			}
			
			let yy = height + y - n * (height / 2);
			noStroke();
			fill(64 + lo + n2 * 20, 172, 16 + 128 * n2 + 128 - 64 * (pow((1 - ny), 3.25)), 1);
			rect(x, yy, 4, 4);
			
			if (random() > 0.25 * ny + 0.5 && lo == 0) {
				let tx = x + random(-1, 1) * 8;
				stroke(72 + random(-10, 10), 148 * pow(1 - ny, 4.25), 128, 1);
				strokeWeight(random(1, 4));
				line(tx, yy, tx + random(-3, 3), yy - n * 8);
			}
		}
	}
	
	for (y = -13; y > -15; y -= ystep) {
		let ny = abs(y) / height;
		for (x = 0; x < width; x += 3) {
			let nx = x / width;
			let n = noise(nx, ny);

			let yy = height + y - n * (height / 2);

			if (random() > 0.965 + 0.035 * n) {
				stroke(0, 0, 0, 1);
				strokeWeight(0.5);
				let tx = x + random(1, 4);
				let ty = yy + random(1, 4);
				line(x, yy, tx, ty);
				line(tx, ty, tx + random(1, 4), ty - random(1, 3));
			}
		}
	}
}"
"886637","Ys","mySketch","// same as parallax checkerboard but everything depart from center with variable shape size based on distance
// white stroke is used to give some sort of shading
// with many shapes this give a 3d look (but slower)
// more distorsion and noise !

function setup() {
	createCanvas(900, 900);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseDetail(6, 0.7);
	
	noStroke();
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	//background(0);
	noStroke();
	fill(0, 0, 0, 0.2);
	rect(0, 0, width, height);
	
	let planes = 128;
	
	let sw = 100;
	let sh = 100;
	
	let xp_offset = 0;
	let yp_offset = 0;
	
	let w = width;
	let h = height;
	
	for (let p = 1; p <= planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let ainp = abs(0.5 - np) * 2;
		
		let sf = pow(0.15, inp) * 1.25;
		
		push();
		translate(width / 2, height / 2);
		scale(sf, sf);
		// slow
		//rotate(sf * 3 * inp + xmotion / 64);
		for (let y = 0; y <= h; y += sw) {
			for (let x = 0; x <= w; x += sh) {
				let nx = abs(0.5 - x / w) * 2;
				let ny = abs(0.5 - y / h) * 2;
				if (nx * ny > 0.1) { // checkerboard pattern					
					let no = noise(nx * 8, ny * 8) * noise(ainp * 32 + xmotion / 32);
					let no2 = noise(ainp / 2);
					
					let ss = sin(nx * ny * PI * 2 + inp * PI * 2 + xmotion / 32) + no * 1.25;
					
					//stroke(0, 0, 255, 1);
					//strokeWeight(0.25);
					noStroke();
					fill((240 + (1 - np) * 260 * sf + noise(np * 8 + xmotion / 32) * 48 + xmotion) % 360, 255 * np, 255 * np, sf / 4);
					ellipse(-width / 2 + (x /* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
							 	  -height / 2 + (y /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
									sw * ss * inp,
									sh * ss * inp);
				}
			}
		}
		pop();
	}
	
	xmotion += 1;
	ymotion += 1;
}"
"886637","Ys","mySketch","// same as parallax checkerboard but everything depart from center with variable shape size based on distance
// white stroke is used to give some sort of shading
// with many shapes this give a 3d look (but slower)
// more distorsion and noise !

function setup() {
	createCanvas(900, 900);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseDetail(6, 0.7);
	
	noStroke();
	
	rectMode(CENTER);
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	//background(0);
	noStroke();
	fill(0, 0, 0, 0.2);
	rect(0, 0, width, height);
	
	let planes = 128;
	
	let sw = 100;
	let sh = 100;
	
	let xp_offset = 0;
	let yp_offset = 0;
	
	let w = width;
	let h = height;
	
	for (let p = 1; p <= planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let ainp = abs(0.5 - np) * 2;
		
		let sf = pow(0.15, inp) * 4.25;
		
		push();
		translate(width / 2, height / 2);
		scale(sf + (sin(xmotion / 64)) * 4, sf + (sin(xmotion / 64)) * 4);
		// slow
		rotate(sf * 30 * inp + xmotion / 64);
		for (let y = 0; y <= h; y += sw) {
			for (let x = 0; x <= w; x += sh) {
				let nx = abs(0.5 - x / w) * 2;
				let ny = abs(0.5 - y / h) * 2;
				if (nx * ny< 0.1) { // checkerboard pattern					
					let no = noise(nx * 8, ny * 8) * noise(ainp * 32 + xmotion / 32);
					let no2 = noise(ainp / 2);
					
					let ss = sin(nx * ny * PI * 2 + inp * PI * 2 + xmotion / 32) + no * 1.25;
					
					//stroke(0, 0, 255, 1);
					//strokeWeight(0.25);
					noStroke();
					fill((240 + (1 - np) * 260 * sf + noise(np * 8 + xmotion / 32) * 48 + xmotion) % 360, 255 * np, 255 * np, sf / 4);
					rect(-width / 2 + (x /* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
							 	  -height / 2 + (y /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
									sw * ss * inp,
									sh * ss * inp);
				}
			}
		}
		pop();
	}
	
	xmotion += 1;
	ymotion += 1;
}"
"886637","Ys","mySketch","// same as parallax checkerboard but everything depart from center with variable shape size based on distance
// white stroke is used to give some sort of shading
// with many shapes this give a 3d look (but slower)
// more distorsion and noise !

function setup() {
	createCanvas(900, 900);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseDetail(6, 0.7);
	
	noStroke();
	
	rectMode(CENTER);
	ellipseMode(CENTER);
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	//background(0);
	noStroke();
	fill(0, 0, 0, 0.2);
	rect(width / 2, height / 2, width, height);
	
	let planes = 128;
	
	let sw = 100;
	let sh = 100;
	
	let xp_offset = 0;
	let yp_offset = 0;
	
	let w = width;
	let h = height;
	
	for (let p = 1; p <= planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let ainp = abs(0.5 - np) * 2;
		
		let sf = pow(0.25, inp) * 4.25;
		
		push();
		translate(width / 2, height / 2);
		scale(sf + (sin(xmotion / 64)) * 4, sf + (sin(xmotion / 64)) * 4);
		// slow
		rotate(sf * 16 * inp + xmotion / 64);
		for (let y = 0; y <= h; y += sw) {
			for (let x = 0; x <= w; x += sh) {
				let nx = abs(0.5 - x / w) * 2;
				let ny = abs(0.5 - y / h) * 2;
				if (nx * ny < 0.1) { // checkerboard pattern					
					let no = noise(nx * 8, ny * 8) * noise(ainp * 32 + xmotion / 128);
					let no2 = noise(ainp / 2);
					
					let ss = sin(nx * ny * PI * 2 * inp * PI * 2 + xmotion / 32) + no * 1.25;
					
					//stroke(0, 0, 255, 1);
					//strokeWeight(0.25);
					noStroke();
					fill((240 + (1 - np) * 64 * sf + noise(np * 8 + xmotion / 32) * 48 + xmotion) % 360, 255 * np, 255 * np, sf / 6);
					ellipse(-width / 2 + (x /* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
							 	  -height / 2 + (y /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
									sw * ss * inp,
									sh * ss * inp);
				}
			}
		}
		pop();
	}
	
	xmotion += 1;
	ymotion += 1;
}"
"886637","Ys","mySketch","// same as parallax checkerboard but everything depart from center with variable shape size based on distance
// white stroke is used to give some sort of shading
// with many shapes this give a 3d look (but slower)
// more distorsion and noise !

function setup() {
	createCanvas(900, 900);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseDetail(6, 0.7);
	
	noStroke();
	
	rectMode(CENTER);
	ellipseMode(CENTER);
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	//background(0);
	noStroke();
	fill(0, 0, 0, 0.2);
	rect(width / 2, height / 2, width, height);
	
	let planes = 128;
	
	let sw = 100;
	let sh = 100;
	
	let xp_offset = 0;
	let yp_offset = 0;
	
	let w = width;
	let h = height;
	
	for (let p = 1; p <= planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let ainp = abs(0.5 - np) * 2;
		
		let sf = pow(0.25, inp) * 4.25;
		
		push();
		translate(width / 2, height / 2);
		scale(sf + (sin(xmotion / 64)) * 4, sf + (sin(xmotion / 64)) * 4);
		// slow
		rotate(sf * 16 * inp + xmotion / 64);
		for (let y = 0; y <= h; y += sw) {
			for (let x = 0; x <= w; x += sh) {
				let nx = abs(0.5 - x / w) * 2;
				let ny = abs(0.5 - y / h) * 2;
				if (nx * ny < 0.1) { // checkerboard pattern					
					let no = noise(nx * 8, ny * 8) * noise(ainp * 32 + xmotion / 128);
					let no2 = noise(ainp / 2);
					
					let ss = sin(nx * ny * PI * 2 * inp * PI * 2 + xmotion / 32) + no * 1.25;
					
					//stroke(0, 0, 255, 1);
					//strokeWeight(0.25);
					noStroke();
					fill((240 + (1 - np) * 64 * sf + noise(np * 8 + xmotion / 32) * 48 + xmotion) % 360, 255 * np, 255 * np, sf / 6);
					ellipse(-width / 2 + (x /* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
							 	  -height / 2 + (y /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
									sw * ss * inp,
									sh * ss * inp);
				}
			}
		}
		pop();
	}
	
	xmotion += 1;
	ymotion += 1;
}"
"886637","Ys","mySketch","// same as parallax checkerboard but everything depart from center with variable shape size based on distance
// white stroke is used to give some sort of shading
// with many shapes this give a 3d look (but slower)
// more distorsion and noise !

function setup() {
	createCanvas(900, 900);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseDetail(6, 0.7);
	
	noStroke();
	
	rectMode(CENTER);
	ellipseMode(CENTER);
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	//background(0);
	noStroke();
	fill(0, 0, 0, 0.2);
	rect(width / 2, height / 2, width, height);
	
	let planes = 128;
	
	let sw = 100;
	let sh = 100;
	
	let xp_offset = 0;
	let yp_offset = 0;
	
	let w = width;
	let h = height;
	
	for (let p = 1; p <= planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let ainp = abs(0.5 - np) * 2;
		
		let sf = pow(0.25, inp) * 4.25;
		
		push();
		translate(width / 2, height / 2);
		scale(sf + (sin(xmotion / 64)) * 4, sf + (sin(xmotion / 64)) * 4);
		// slow
		rotate(sf * 16 * inp + xmotion / 64);
		for (let y = 0; y <= h; y += sw) {
			for (let x = 0; x <= w; x += sh) {
				let nx = abs(0.5 - x / w) * 2;
				let ny = abs(0.5 - y / h) * 2;
				if (nx * ny < 0.1) { // checkerboard pattern					
					let no = noise(nx * 8, ny * 8) * noise(ainp * 32 + xmotion / 128);
					let no2 = noise(ainp / 2);
					
					let ss = sin(nx * ny * PI * 2 * inp * PI * 2 + xmotion / 32) + no * 1.25;
					
					//stroke(0, 0, 255, 1);
					//strokeWeight(0.25);
					noStroke();
					fill((240 + (1 - np) * 64 * sf + noise(np * 8 + xmotion / 32) * 48 + xmotion) % 360, 255 * np, 255 * np, sf / 6);
					ellipse(-width / 2 + (x /* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
							 	  -height / 2 + (y /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
									sw * ss * inp,
									sh * ss * inp);
				}
			}
		}
		pop();
	}
	
	xmotion += 1;
	ymotion += 1;
}"
"885748","Paper work","mySketch","// same as parallax checkerboard with static render goal

function setup() {
	createCanvas(900, 900);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseDetail(6, 0.7);
	
	noStroke();
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	//background(0);
	noStroke();
	//fill(0, 0, 0, 0.05);
	//rect(0, 0, width, height);
	
	let planes = 32;
	
	let sw = 100;
	let sh = 100;
	
	let xp_offset = 0;
	let yp_offset = 0;
	
	let w = width;
	let h = height;
	
	for (let p = 1; p <= planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let ainp = abs(0.5 - np) * 2;
		
		let sf = pow(0.15, inp) * 2.25;
		
		push();
		translate(width / 2, height / 2);
		scale(sf, sf);
		// slow
		rotate(sf * 8 * ainp);
		for (let y = 0; y <= h; y += sw) {
			for (let x = 0; x <= w; x += sh) {
				if ((x % (sw * 2)) ^ (y % (sh * 2))) { // checkerboard pattern
					let nx = abs(0.5 - x / w) * 2;
					let ny = abs(0.5 - y / h) * 2;
					
					let no = noise(nx * 8, ny * 8) * noise(ainp * 32 + xmotion / 32);
					
					let ss = sin(nx * ny * PI * 2 + inp * PI * 2 + xmotion / 32) + no * 0.75;
					
					stroke(0, 0, 0, 1);
					strokeWeight(0.25);
					fill((240 + (1 - np) * 180 * sf + noise(np * 64) * 100) % 360, 255 * np, 255 * np, sf / 3);
					
					let vw = sw * ss * np - frameCount;
					let vh = sh * ss * np - frameCount;
					
					if (vw > 0 && vh > 0)
						rect(-width / 2 + (x + cos(sf + xmotion / 16) * 8 * no/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
										-height / 2 + (y + sin(sf + ymotion / 16) * 8 * no /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
										vw,
										vh);
				}
			}
		}
		pop();
	}
	
	xmotion += 1;
	ymotion += 1;
}"
"885740","Sea2","mySketch","// same as parallax checkerboard but everything depart from center with variable shape size based on distance
// white stroke is used to give some sort of shading
// with many shapes this give a 3d look (but slower)
// more distorsion and noise !

function setup() {
	createCanvas(900, 900);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseDetail(6, 0.7);
	
	noStroke();
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	//background(0);
	noStroke();
	fill(0, 0, 0, 0.2);
	rect(0, 0, width, height);
	
	let planes = 64;
	
	let sw = 100;
	let sh = 100;
	
	let xp_offset = 0;
	let yp_offset = 0;
	
	let w = width;
	let h = height;
	
	for (let p = 1; p <= planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let ainp = abs(0.5 - np) * 2;
		
		let sf = pow(0.15, inp) * 1.25;
		
		push();
		translate(width / 2, height / 2);
		scale(sf, sf);
		// slow
		rotate(sf * 3 * inp + xmotion / 64);
		for (let y = 0; y <= h; y += sw) {
			for (let x = 0; x <= w; x += sh) {
				if ((x % (sw * 2)) ^ (y % (sh * 2))) { // checkerboard pattern
					let nx = abs(0.5 - x / w) * 2;
					let ny = abs(0.5 - y / h) * 2;
					
					let no = noise(nx * 8, ny * 8) * noise(ainp * 32 + xmotion / 32);
					
					let ss = sin(nx * ny * PI * 2 + inp * PI * 2 + xmotion / 32) + no * 1.25;
					
					stroke(0, 0, 255, 1);
					strokeWeight(0.25);
					fill((240 + (1 - np) * 260 * sf + noise(np * 8 + xmotion / 32) * 48 + xmotion) % 360, 255 * np, 255 * np, sf / 4);
					ellipse(-width / 2 + (x + cos(sf + xmotion / 28) * 42/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
							 	  -height / 2 + (y + sin(sf + ymotion / 28) * 42 /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
									sw * ss * inp,
									sh * ss * inp);
				}
			}
		}
		pop();
	}
	
	xmotion += 1;
	ymotion += 1;
}"
"885733","Sea","mySketch","// same as parallax checkerboard but everything depart from center with variable shape size based on distance
// white stroke is used to give some sort of shading
// with many shapes this give a 3d look (but slower)

function setup() {
	createCanvas(900, 900);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noiseDetail(6, 0.7);
	
	noStroke();
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	background(0);
	
	let planes = 128;
	
	let sw = 100;
	let sh = 100;
	
	let xp_offset = 0;
	let yp_offset = 0;
	
	let w = width;
	let h = height;
	
	for (let p = 1; p <= planes; p += 2) {
		let np = p / planes;
		let inp = 1 - np;
		
		let ainp = abs(0.5 - np) * 2;
		
		let sf = pow(0.15, inp) * 1.75;
		
		push();
		translate(width / 2, height / 2);
		scale(sf, sf);
		// slow
		rotate(sf / 2);
		for (let y = 0; y <= h; y += sw) {
			for (let x = 0; x <= w; x += sh) {
				if ((x % (sw * 2)) ^ (y % (sh * 2))) { // checkerboard pattern
					let nx = abs(0.5 - x / w) * 2;
					let ny = abs(0.5 - y / h) * 2;
					
					let no = noise(nx, ny);
					
					let ss = sin(nx * ny * PI * 2 + inp * PI * 2 + xmotion / 32) + no * 1.5;
					
					stroke(0, 0, 255, 1);
					strokeWeight(0.25);
					fill((240 + (1 - np) * 260 * sf + noise(np * 24) * xmotion) % 360, 255 * np, 255 * np, sf / 4);
					ellipse(-width / 2 + (x + cos(sf + xmotion / 28) * 92/* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
							 	  -height / 2 + (y + sin(sf + ymotion / 28) * 92 /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
									sw * ss * inp,
									sh * ss * inp);
				}
			}
		}
		pop();
	}
	
	xmotion += 1;
	ymotion += 1;
}"
"885681","Configuration","mySketch","// same as parallax checkerboard but everything depart from center with variable shape size based on distance
// white stroke is used to give some sort of shading
// with many shapes this give a 3d look (but slower)

function setup() {
	createCanvas(900, 900);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noStroke();
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	background(0);
	
	let planes = 48;
	
	let sw = 100;
	let sh = 100;
	
	let xp_offset = 0;
	let yp_offset = 0;
	
	let w = width;
	let h = height;
	
	for (let p = 1; p <= planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let ainp = abs(0.5 - np) * 2;
		
		let sf = pow(0.15, inp) * 4.25;
		
		push();
		translate(width / 2, height / 2);
		scale(sf, sf);
		// slow
		rotate(sf + xmotion / 64 * np);
		for (let y = 0; y <= h; y += sw) {
			for (let x = 0; x <= w; x += sh) {
				if ((x % (sw * 2)) ^ (y % (sh * 2))) { // checkerboard pattern
					let nx = abs(0.5 - x / w) * 2;
					let ny = abs(0.5 - y / h) * 2;
					
					let ss = sin(nx * ny * PI * 2 + ainp * PI * 2 + xmotion / 48);
					
					stroke(0, 0, 255, 1 * ss);
					strokeWeight(0.25);
					fill((260 + (1 - np) * 160), 255 * np, 255 * inp, 1);

					rect(-width / 2 + (x /* * np*/ /*+ p * xp_offset * np*/+ xmotion * nx) % (w + sw),
							 -height / 2 + (y /* * np*/ /*+ p * yp_offset * np*/+ ymotion * ny) % (h + sh),
								sw * np,
								sh * np);
				}
			}
		}
		pop();
	}
	
	xmotion += 1;
	ymotion += 1;
}"
"885610","fake solids","mySketch","// same as parallax checkerboard but everything depart from center with variable shape size based on distance
// white stroke is used to give some sort of shading
// with many shapes this give a 3d look (but slower)

function setup() {
	createCanvas(900, 900);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
	
	noStroke();
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	background(0);
	
	let planes = 128;
	
	let sw = 100;
	let sh = 100;
	
	let xp_offset = 0;
	let yp_offset = 0;
	
	let w = width;
	let h = height;
	
	for (let p = 1; p <= planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let ainp = abs(0.5 - np) * 2;
		
		let sf = pow(0.15, inp) * 2.25;
		
		push();
		translate(width / 2, height / 2);
		scale(sf, sf);
		// slow
		//rotate(sf, sf);
		for (let y = 0; y <= h; y += sw) {
			for (let x = 0; x <= w; x += sh) {
				if ((x % (sw * 2)) ^ (y % (sh * 2))) { // checkerboard pattern
					let nx = abs(0.5 - x / w) * 2;
					let ny = abs(0.5 - y / h) * 2;
					
					let ss = sin(nx * ny * PI * 2 + inp * PI * 2 + xmotion / 32);
					
					stroke(0, 0, 255, 1);
					strokeWeight(0.25);
					fill(360 - (260 + (1 - np) * 160) % 360, 255 * np, 255 * np, 1);
					rect(-width / 2 + (x /* * np*/ /*+ p * xp_offset * np*/) % (w + sw),
							 	  -height / 2 + (y /* * np*/ /*+ p * yp_offset * np*/) % (h + sh),
									sw * ss * inp,
									sh * ss * inp);
				}
			}
		}
		pop();
	}
	
	xmotion += 1;
	ymotion += 1;
}"
"884161","Parallax checkerboard","mySketch","function setup() {
	createCanvas(750, 750);
	background(100);
	
	colorMode(HSL, 360, 255, 255);
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	background(0);
	
	stroke(0, 0, 0, 255);
	
	let planes = 4;
	
	let sw = 50;
	let sh = 50;
	
	let xp_offset = 8;
	let yp_offset = 8;
	
	for (let p = planes; p > 0; p -= 1) {
		let np = p / planes;
		
		for (let y = 0; y <= height; y += sw) {
			for (let x = 0; x <= width; x += sh) {
				if ((x % (sw * 2)) ^ (y % (sh * 2))) {
					fill(0, 0, 255, 255);
					rect(-sw + (x + xmotion + p * xp_offset) % (width + sw), -sh + (y + ymotion + p * yp_offset) % (height + sh), sw, sh);
				}
			}
		}
	}
	
	xmotion += 1;
	ymotion += 1;
}"
"884161","Parallax checkerboard","mySketch","function setup() {
	createCanvas(750, 750);
	background(100);
	
	colorMode(HSL, 360, 255, 255);
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	background(0);
	
	stroke(0, 0, 0, 255);
	
	let planes = 12;
	
	let sw = 50;
	let sh = 50;
	
	let xp_offset = 8;
	let yp_offset = 8;
	
	for (let p = 0; p < planes; p += 1) {
		let np = p / planes;
		
		
		
		for (let y = 0; y <= height; y += sw) {
			for (let x = 0; x <= width; x += sh) {
				if ((x % (sw * 2)) ^ (y % (sh * 2))) {
					fill(0, 0, 255 * np, 255);
					rect(-sw + (x + xmotion + p * xp_offset) % (width + sw), -sh + (y + ymotion + p * yp_offset) % (height + sh), sw, sh);
				}
			}
		}
	}
	
	xmotion += 1;
	ymotion += 1;
}"
"884161","Parallax checkerboard","mySketch","function setup() {
	createCanvas(750, 750);
	background(100);
	
	colorMode(HSL, 360, 255, 255);
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	background(0);
	
	stroke(0, 0, 0, 255);
	
	let planes = 2;
	
	let sw = 50;
	let sh = 50;
	
	let xp_offset = 8;
	let yp_offset = 8;
	
	for (let p = 1; p <= planes; p += 1) {
		let np = p / planes;
		
		
		
		for (let y = 0; y <= height; y += sw) {
			for (let x = 0; x <= width; x += sh) {
				if ((x % (sw * 2)) ^ (y % (sh * 2))) {
					fill(0, 0, 255 * np, 255);
					rect(-sw + (x + xmotion + p * xp_offset) % (width + sw), -sh + (y + ymotion + p * yp_offset) % (height + sh), sw, sh);
				}
			}
		}
	}
	
	xmotion += 1;
	ymotion += 1;
}"
"884161","Parallax checkerboard","mySketch","function setup() {
	createCanvas(750, 750);
	background(100);
	
	colorMode(HSL, 360, 255, 255);
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	background(0);
	
	stroke(0, 0, 0, 255);
	
	let planes = 2;
	
	let sw = 50;
	let sh = 50;
	
	let xp_offset = 8;
	let yp_offset = 8;
	
	for (let p = 1; p <= planes; p += 1) {
		let np = p / planes;
		
		for (let y = 0; y <= height; y += sw) {
			for (let x = 0; x <= width; x += sh) {
				if ((x % (sw * 2)) ^ (y % (sh * 2))) {
					fill(0, 0, 255 * np, 255);
					rect(-sw + (x + xmotion + p * xp_offset) % (width + sw), -sh + (y + ymotion + p * yp_offset) % (height + sh), sw, sh);
				}
			}
		}
	}
	
	xmotion += 1;
	ymotion += 1;
}"
"884161","Parallax checkerboard","mySketch","function setup() {
	createCanvas(850, 850);
	background(100);
	
	colorMode(HSL, 360, 255, 255);
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	background(0);
	
	stroke(0, 0, 0, 255);
	
	let planes = 12;
	
	let sw = 50;
	let sh = 50;
	
	let xp_offset = 40;
	let yp_offset = 40;
	
	for (let p = 1; p <= planes; p += 1) {
		let np = p / planes;
		let anp = abs(0.5 - np) * 2;
		
		for (let y = 0; y <= height; y += sw) {
			for (let x = 0; x <= width; x += sh) {
				if ((x % (sw * 2)) ^ (y % (sh * 2))) { // checkerboard pattern
					fill(0, 0, 255 * np, 255);
					rect(-sw + (x + xmotion * np + p * xp_offset * anp) % (width + sw),
							 -sh + (y + ymotion * np + p * yp_offset * anp) % (height + sh), sw, sh);
				}
			}
			sw *= 2;
		}
	}
	
	xmotion += 1;
	ymotion += 1;
}"
"884161","Parallax checkerboard","mySketch","function setup() {
	createCanvas(850, 850);
	background(100);
	
	colorMode(HSL, 360, 255, 255);
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	background(0);
	
	stroke(0, 0, 0, 255);
	
	let planes = 12;
	
	let sw = 50;
	let sh = 50;
	
	let xp_offset = 40;
	let yp_offset = 40;
	
	for (let p = 1; p <= planes; p += 1) {
		let np = p / planes;
		let anp = abs(0.5 - np) * 2;
		
		for (let y = 0; y <= height; y += sw) {
			for (let x = 0; x <= width; x += sh) {
				if ((x % (sw * 2)) ^ (y % (sh * 2))) { // checkerboard pattern
					fill(0, 0, 255 * np, 255);
					rect(-sw + (x + xmotion * np + p * xp_offset * anp) % (width + sw),
							 -sh + (y + ymotion * np + p * yp_offset * anp) % (height + sh), sw, sh);
				}
			}
		}
	}
	
	xmotion += 1;
	ymotion += 1;
}"
"884161","Parallax checkerboard","mySketch","function setup() {
	createCanvas(850, 850);
	background(100);
	
	colorMode(HSL, 360, 255, 255);
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	background(0);
	
	stroke(0, 0, 0, 255);
	
	let planes = 12;
	
	let sw = 50;
	let sh = 50;
	
	let xp_offset = 40;
	let yp_offset = 40;
	
	for (let p = 1; p <= planes; p += 1) {
		let np = p / planes;
		let anp = abs(0.5 - np) * 2;
		
		for (let y = 0; y <= height; y += sw) {
			for (let x = 0; x <= width; x += sh) {
				if ((x % (sw * 2)) ^ (y % (sh * 2))) { // checkerboard pattern
					fill(0, 0, 255 * np, 255);
					rect(-sw + (x + xmotion * np + p * xp_offset * anp) % (width + sw),
							 -sh + (y + ymotion * np + p * yp_offset * anp) % (height + sh), sw, sh);
				}
			}
		}
	}
	
	xmotion += 1;
	ymotion += 0.5;
}"
"884161","Parallax checkerboard","mySketch","function setup() {
	createCanvas(850, 850);
	background(100);
	
	colorMode(HSL, 360, 255, 255);
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	background(0);
	
	stroke(0, 0, 0, 255);
	
	let planes = 12;
	
	let sw = 50;
	let sh = 50;
	
	let xp_offset = 40;
	let yp_offset = 40;
	
	for (let p = 1; p <= planes; p += 1) {
		let np = p / planes;
		let anp = abs(0.5 - np) * 2;
		
		for (let y = 0; y <= height; y += sw) {
			for (let x = 0; x <= width; x += sh) {
				if ((x % (sw * 2)) ^ (y % (sh * 2))) { // checkerboard pattern
					fill(0, 0, 255 * np, 255);
					rect(-sw + (x + xmotion * np + p * xp_offset * anp) % (width + sw),
							 -sh + (y + ymotion * np + p * yp_offset * anp) % (height + sh), sw, sh);
				}
			}
		}
	}
	
	xmotion += 1;
	ymotion += 1;
}"
"884161","Parallax checkerboard","mySketch","function setup() {
	createCanvas(850, 850);
	background(100);
	
	colorMode(HSL, 360, 255, 255);
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	background(0);
	
	stroke(0, 0, 0, 255);
	
	let planes = 12;
	
	let sw = 50;
	let sh = 50;
	
	let xp_offset = 40;
	let yp_offset = 40;
	
	for (let p = 1; p <= planes; p += 1) {
		let np = p / planes;
		let anp = abs(0.5 - np) * 2;
		
		for (let y = 0; y <= height; y += sw) {
			for (let x = 0; x <= width; x += sh) {
				if ((x % (sw * 2)) ^ (y % (sh * 2))) { // checkerboard pattern
					fill(0, 0, 255 * np, 255);
					rect(-sw + (x + xmotion * np + p * xp_offset * anp) % (width + sw),
							 -sh + (y + ymotion * np + p * yp_offset * anp) % (height + sh), sw, sh);
				}
			}
		}
	}
	
	xmotion += 1;
	ymotion += 1;
}"
"884161","Parallax checkerboard","mySketch","// parallax checkerboard
// note : rect size should decrease as depth increase for the classical effect

function setup() {
	createCanvas(850, 850);
	background(100);
	
	colorMode(HSL, 360, 255, 255);
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	background(0);
	
	stroke(0, 0, 0, 255);
	
	let planes = 12;
	
	let sw = 50;
	let sh = 50;
	
	let xp_offset = 40;
	let yp_offset = 40;
	
	for (let p = 1; p <= planes; p += 1) {
		let np = p / planes;
		let anp = abs(0.5 - np) * 2;
		
		for (let y = 0; y <= height; y += sw) {
			for (let x = 0; x <= width; x += sh) {
				if ((x % (sw * 2)) ^ (y % (sh * 2))) { // checkerboard pattern
					fill(0, 0, 255 * np, 255);
					rect(-sw + (x + xmotion * np + p * xp_offset * anp) % (width + sw),
							 -sh + (y + ymotion * np + p * yp_offset * anp) % (height + sh), sw, sh);
				}
			}
		}
	}
	
	xmotion += 1;
	ymotion += 1;
}"
"884161","Parallax checkerboard","mySketch","// parallax checkerboard
// note : rect size should decrease as depth increase for the classical effect

function setup() {
	createCanvas(900, 900);
	background(100);
	
	colorMode(HSL, 360, 255, 255);
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	background(0);
	
	stroke(0, 0, 0, 255);
	
	let planes = 12;
	
	let sw = 100;
	let sh = 100;
	
	let xp_offset = 40;
	let yp_offset = 40;
	
	for (let p = 1; p <= planes; p += 1) {
		let np = p / planes;
		let anp = abs(0.5 - np) * 2;
		
		for (let y = 0; y <= height; y += sw) {
			for (let x = 0; x <= width; x += sh) {
				if ((x % (sw * 2)) ^ (y % (sh * 2))) { // checkerboard pattern
					fill(0, 0, 255 * np, 255);
					rect(-sw + (x + xmotion * np + p * xp_offset * anp) % (width + sw),
							 -sh + (y + ymotion * np + p * yp_offset * anp) % (height + sh), sw, sh);
				}
			}
		}
	}
	
	xmotion += 1;
	ymotion += 1;
}"
"884161","Parallax checkerboard","mySketch","// parallax checkerboard

function setup() {
	createCanvas(750, 750);

	colorMode(HSL, 360, 255, 255);
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	background(0);
	
	stroke(0, 0, 64, 255);
	
	let planes = 8;
	
	let sw = 50;
	let sh = 50;
	
	let xp_offset = 0;
	let yp_offset = 0;
	
	let w = width;
	let h = height;
	
	for (let p = 1; p <= planes; p += 1) {
		let np = p / planes;
		
		let sf = pow(0.25, 1-np);
		
		push();
		scale(sf * 2, sf * 2);
		for (let y = 0; y <= h; y += sw) {
			for (let x = 0; x <= w; x += sh) {
				if ((x % (sw * 2)) ^ (y % (sh * 2))) { // checkerboard pattern
					fill(0, 0, 255 * np, 255);
					rect(-sw + (x + xmotion * np + p * xp_offset * np) % (w + sw),
							 -sh + (y + ymotion * np + p * yp_offset * np) % (h + sh), sw, sh);
				}
			}
		}
		pop();
	}
	
	xmotion += 1;
	ymotion += 1;
}"
"884161","Parallax checkerboard","mySketch","// parallax checkerboard

function setup() {
	createCanvas(750, 750);

	colorMode(HSL, 360, 255, 255);
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	background(0);
	
	stroke(0, 0, 0, 255);
	
	let planes = 8;
	
	let sw = 50;
	let sh = 50;
	
	let xp_offset = 0;
	let yp_offset = 0;
	
	let w = width;
	let h = height;
	
	for (let p = 1; p <= planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let sf = pow(0.25, inp) * 2;
		
		push();
		scale(sf, sf);
		for (let y = 0; y <= h; y += sw) {
			for (let x = 0; x <= w; x += sh) {
				if ((x % (sw * 2)) ^ (y % (sh * 2))) { // checkerboard pattern
					fill(0, 0, 255 * np, 255);
					rect(-sw + (x + xmotion * np + p * xp_offset * np) % (w + sw),
							 -sh + (y + ymotion * np + p * yp_offset * np) % (h + sh), sw, sh);
				}
			}
		}
		pop();
	}
	
	xmotion += 1;
	ymotion += 1;
}"
"884161","Parallax checkerboard","mySketch","// parallax checkerboard

function setup() {
	createCanvas(750, 750);

	colorMode(HSL, 360, 255, 255);
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	background(0);
	
	stroke(0, 0, 0, 255);
	strokeWeight(0.25);
	
	let planes = 8;
	
	let sw = 50;
	let sh = 50;
	
	let xp_offset = 0;
	let yp_offset = 0;
	
	let w = width;
	let h = height;
	
	for (let p = 1; p <= planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let sf = pow(0.25, inp) * 2;
		
		push();
		scale(sf, sf);
		for (let y = 0; y <= h; y += sw) {
			for (let x = 0; x <= w; x += sh) {
				if ((x % (sw * 2)) ^ (y % (sh * 2))) { // checkerboard pattern
					fill(0, 0, 255 * np, 255);
					rect(-sw + (x + xmotion * np + p * xp_offset * np) % (w + sw),
							 -sh + (y + ymotion * np + p * yp_offset * np) % (h + sh), sw, sh);
				}
			}
		}
		pop();
	}
	
	xmotion += 1;
	ymotion += 1;
}"
"884161","Parallax checkerboard","mySketch","// parallax checkerboard

function setup() {
	createCanvas(750, 750);

	colorMode(HSL, 360, 255, 255);
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	background(0);
	
	stroke(0, 0, 0, 255);
	strokeWeight(0.25);
	
	let planes = 8;
	
	let sw = 50;
	let sh = 50;
	
	let xp_offset = 0;
	let yp_offset = 0;
	
	let w = width;
	let h = height;
	
	for (let p = 1; p <= planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let sf = pow(0.25, inp) * 2;
		
		push();
		scale(sf, sf);
		for (let y = 0; y <= h; y += sw) {
			for (let x = 0; x <= w; x += sh) {
				if ((x % (sw * 2)) ^ (y % (sh * 2))) { // checkerboard pattern
					fill(0, 0, 255 * np, 255);
					rect(-sw + (x + xmotion * np + p * xp_offset * np) % (w + sw),
							 -sh + (y + ymotion * np + p * yp_offset * np) % (h + sh), sw, sh);
				}
			}
		}
		pop();
	}
	
	xmotion += 1;
	ymotion += 1;
}"
"884161","Parallax checkerboard","mySketch","// parallax checkerboard

function setup() {
	createCanvas(750, 750);

	colorMode(HSL, 360, 255, 255);
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	background(0);
	
	stroke(0, 0, 0, 1);
	strokeWeight(0.25);
	
	let planes = 8;
	
	let sw = 50;
	let sh = 50;
	
	let xp_offset = 0;
	let yp_offset = 0;
	
	let w = width;
	let h = height;
	
	for (let p = 1; p <= planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let sf = pow(0.25, inp) * 2;
		
		push();
		scale(sf, sf);
		for (let y = 0; y <= h; y += sw) {
			for (let x = 0; x <= w; x += sh) {
				if ((x % (sw * 2)) ^ (y % (sh * 2))) { // checkerboard pattern
					let nx = abs(0.5 - x / w) * 2;
					let ny = y / h;
					
					fill(300 + (1 - nx) * 120, 128, 255 * np, 1 * np);
					rect(-sw + (x + xmotion * np + p * xp_offset * np) % (w + sw),
							 -sh + (y + ymotion * np + p * yp_offset * np) % (h + sh), sw, sh);
				}
			}
		}
		pop();
	}
	
	xmotion += 1;
	ymotion += 1;
}"
"884161","Parallax checkerboard","mySketch","// parallax checkerboard

function setup() {
	createCanvas(750, 750);

	colorMode(HSL, 360, 255, 255);
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	background(0);
	
	stroke(0, 0, 0, 1);
	strokeWeight(0.25);
	
	let planes = 8;
	
	let sw = 50;
	let sh = 50;
	
	let xp_offset = 0;
	let yp_offset = 0;
	
	let w = width;
	let h = height;
	
	for (let p = 1; p <= planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let sf = pow(0.25, inp) * 2;
		
		push();
		scale(sf, sf);
		for (let y = 0; y <= h; y += sw) {
			for (let x = 0; x <= w; x += sh) {
				if ((x % (sw * 2)) ^ (y % (sh * 2))) { // checkerboard pattern
					let nx = abs(0.5 - x / w) * 2;
					let ny = y / h;
					
					fill(230 + (1 - nx) * 70, 128, 255 * np, 1 * np);
					rect(-sw + (x + xmotion * np + p * xp_offset * np) % (w + sw),
							 -sh + (y + ymotion * np + p * yp_offset * np) % (h + sh), sw, sh);
				}
			}
		}
		pop();
	}
	
	xmotion += 1;
	ymotion += 1;
}"
"884161","Parallax checkerboard","mySketch","// parallax checkerboard

function setup() {
	createCanvas(750, 750);

	colorMode(HSL, 360, 255, 255);
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	background(0);
	
	stroke(0, 0, 0, 1);
	strokeWeight(0.25);
	
	let planes = 16;
	
	let sw = 50;
	let sh = 50;
	
	let xp_offset = 40;
	let yp_offset = 40;
	
	let w = width;
	let h = height;
	
	for (let p = 1; p <= planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let sf = pow(0.25, inp) * 1.75;
		
		push();
		scale(sf, sf);
		for (let y = 0; y <= h; y += sw) {
			for (let x = 0; x <= w; x += sh) {
				if ((x % (sw * 2)) ^ (y % (sh * 2))) { // checkerboard pattern
					let nx = abs(0.5 - x / w) * 2;
					let ny = y / h;
					
					fill(230 + (1 - nx) * 70, 128, 255 * np, 1 * np);
					rect(-sw + (x + xmotion * np + p * xp_offset * np) % (w + sw),
							 -sh + (y + ymotion * np + p * yp_offset * np) % (h + sh), sw, sh);
				}
			}
		}
		pop();
	}
	
	xmotion += 1;
	ymotion += 1;
}"
"884161","Parallax checkerboard","mySketch","// parallax checkerboard

function setup() {
	createCanvas(750, 750);

	colorMode(HSL, 360, 255, 255);
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	background(0);
	
	stroke(0, 0, 0, 1);
	strokeWeight(0.25);
	
	let planes = 16;
	
	let sw = 50;
	let sh = 50;
	
	let xp_offset = 40;
	let yp_offset = 40;
	
	let w = width;
	let h = height;
	
	for (let p = 1; p <= planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let sf = pow(0.25, inp) * 1.75;
		
		push();
		scale(sf, sf);
		for (let y = 0; y <= h; y += sw) {
			for (let x = 0; x <= w; x += sh) {
				if ((x % (sw * 2)) ^ (y % (sh * 2))) { // checkerboard pattern
					let nx = abs(0.5 - x / w) * 2;
					let ny = y / h;
					
					fill(200 + (1 - nx) * 70, 128 * np, 255 * np, 1 * np);
					rect(-sw + (x + xmotion * np + p * xp_offset * np) % (w + sw),
							 -sh + (y + ymotion * np + p * yp_offset * np) % (h + sh), sw, sh);
				}
			}
		}
		pop();
	}
	
	xmotion += 1;
	ymotion += 1;
}"
"884161","Parallax checkerboard","mySketch","// parallax checkerboard

function setup() {
	createCanvas(750, 750);

	colorMode(HSL, 360, 255, 255);
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	background(0);
	
	stroke(0, 0, 0, 1);
	strokeWeight(0.25);
	
	let planes = 16;
	
	let sw = 50;
	let sh = 50;
	
	let xp_offset = 40;
	let yp_offset = 40;
	
	let w = width;
	let h = height;
	
	for (let p = 1; p <= planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let sf = pow(0.25, inp) * 1.75;
		
		push();
		scale(sf, sf);
		for (let y = 0; y <= h; y += sw) {
			for (let x = 0; x <= w; x += sh) {
				if ((x % (sw * 2)) ^ (y % (sh * 2))) { // checkerboard pattern
					let nx = abs(0.5 - x / w) * 2;
					let ny = y / h;
					
					fill(220 + (1 - nx) * 70, 128 * np, 255 * np, 1 * np);
					rect(-sw + (x + xmotion * np + p * xp_offset * np) % (w + sw),
							 -sh + (y + ymotion * np + p * yp_offset * np) % (h + sh), sw, sh);
				}
			}
		}
		pop();
	}
	
	xmotion += 1;
	ymotion += 1;
}"
"884161","Parallax checkerboard","mySketch","// parallax checkerboard

function setup() {
	createCanvas(750, 750);

	colorMode(HSL, 360, 255, 255);
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	background(0);
	
	stroke(0, 0, 0, 1);
	strokeWeight(0.25);
	
	let planes = 16;
	
	let sw = 50;
	let sh = 50;
	
	let xp_offset = 40;
	let yp_offset = 40;
	
	let w = width;
	let h = height;
	
	for (let p = 1; p <= planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let sf = pow(0.25, inp) * 1.75;
		
		push();
		scale(sf, sf);
		for (let y = 0; y <= h; y += sw) {
			for (let x = 0; x <= w; x += sh) {
				if ((x % (sw * 2)) ^ (y % (sh * 2))) { // checkerboard pattern
					let nx = x / w;
					let ny = y / h;
					
					fill(220 + (1 - nx) * 70, 128 * np, 255 * np, 1 * np);
					rect(-sw + (x + xmotion * np + p * xp_offset * np) % (w + sw),
							 -sh + (y + ymotion * np + p * yp_offset * np) % (h + sh), sw, sh);
				}
			}
		}
		pop();
	}
	
	xmotion += 1;
	ymotion += 1;
}"
"884161","Parallax checkerboard","mySketch","// parallax checkerboard

function setup() {
	createCanvas(750, 750);

	colorMode(HSL, 360, 255, 255);
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	background(0);
	
	stroke(0, 0, 0, 1);
	strokeWeight(0.25);
	
	let planes = 16;
	
	let sw = 50;
	let sh = 50;
	
	let xp_offset = 40;
	let yp_offset = 40;
	
	let w = width;
	let h = height;
	
	for (let p = 1; p <= planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let sf = pow(0.25, inp) * 1.75;
		
		push();
		scale(sf, sf);
		for (let y = 0; y <= h; y += sw) {
			for (let x = 0; x <= w; x += sh) {
				if ((x % (sw * 2)) ^ (y % (sh * 2))) { // checkerboard pattern
					let nx = x / w;
					let ny = y / h;
					
					fill(200 + (1 - nx) * 100, 128 * np, 255 * np, 1 * np);
					rect(-sw + (x + xmotion * np + p * xp_offset * np) % (w + sw),
							 -sh + (y + ymotion * np + p * yp_offset * np) % (h + sh), sw, sh);
				}
			}
		}
		pop();
	}
	
	xmotion += 1;
	ymotion += 1;
}"
"884161","Parallax checkerboard","mySketch","// parallax checkerboard

function setup() {
	createCanvas(750, 750);

	colorMode(HSL, 360, 255, 255);
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	background(0);
	
	stroke(0, 0, 0, 1);
	strokeWeight(0.25);
	
	let planes = 16;
	
	let sw = 50;
	let sh = 50;
	
	let xp_offset = 40;
	let yp_offset = 40;
	
	let w = width;
	let h = height;
	
	for (let p = 1; p <= planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let sf = pow(0.25, inp) * 1.75;
		
		push();
		scale(sf, sf);
		for (let y = 0; y <= h; y += sw) {
			for (let x = 0; x <= w; x += sh) {
				if ((x % (sw * 2)) ^ (y % (sh * 2))) { // checkerboard pattern
					let nx = x / w;
					let ny = y / h;
					
					fill(200 + (1 - nx) * 100, 255 * np, 255 * np, 1 * np);
					rect(-sw + (x + xmotion * np + p * xp_offset * np) % (w + sw),
							 -sh + (y + ymotion * np + p * yp_offset * np) % (h + sh), sw, sh);
				}
			}
		}
		pop();
	}
	
	xmotion += 1;
	ymotion += 1;
}"
"884161","Parallax checkerboard","mySketch","// parallax checkerboard

function setup() {
	createCanvas(750, 750);

	colorMode(HSL, 360, 255, 255);
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	background(0);
	
	stroke(0, 0, 0, 1);
	strokeWeight(0.25);
	
	let planes = 16;
	
	let sw = 50;
	let sh = 50;
	
	let xp_offset = 40;
	let yp_offset = 40;
	
	let w = width;
	let h = height;
	
	for (let p = 1; p <= planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let sf = pow(0.25, inp) * 1.75;
		
		push();
		scale(sf, sf);
		for (let y = 0; y <= h; y += sw) {
			for (let x = 0; x <= w; x += sh) {
				if ((x % (sw * 2)) ^ (y % (sh * 2))) { // checkerboard pattern
					let nx = x / w;
					let ny = y / h;
					
					fill(200 + (1 - nx) * 100, 255 * np, 255 * np, 1 * np);
					rect(-sw + (x + xmotion * np + p * xp_offset * np) % (w + sw),
							 -sh + (y + ymotion * np + p * yp_offset * np) % (h + sh), sw, sh);
				}
			}
		}
		pop();
	}
	
	xmotion += 1;
	ymotion += 1;
}"
"884161","Parallax checkerboard","mySketch","// parallax checkerboard

function setup() {
	createCanvas(750, 750);

	colorMode(HSL, 360, 255, 255);
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	background(0);
	
	stroke(0, 0, 0, 1);
	strokeWeight(0.25);
	
	let planes = 16;
	
	let sw = 50;
	let sh = 50;
	
	let xp_offset = 40;
	let yp_offset = 40;
	
	let w = width;
	let h = height;
	
	for (let p = 1; p <= planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let sf = pow(0.25, inp) * 1.75;
		
		push();
		scale(sf, sf);
		for (let y = 0; y <= h; y += sw) {
			for (let x = 0; x <= w; x += sh) {
				if ((x % (sw * 2)) ^ (y % (sh * 2))) { // checkerboard pattern
					let nx = x / w;
					let ny = y / h;
					
					fill(180 + (1 - np) * 160, 255 * np, 255 * np, 1 * np);
					rect(-sw + (x + xmotion * np + p * xp_offset * np) % (w + sw),
							 -sh + (y + ymotion * np + p * yp_offset * np) % (h + sh), sw, sh);
				}
			}
		}
		pop();
	}
	
	xmotion += 1;
	ymotion += 1;
}"
"884161","Parallax checkerboard","mySketch","// parallax checkerboard

function setup() {
	createCanvas(750, 750);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	background(0);
	
	stroke(0, 0, 0, 1);
	strokeWeight(0.25);
	
	let planes = 16;
	
	let sw = 50;
	let sh = 50;
	
	let xp_offset = 40;
	let yp_offset = 40;
	
	let w = width;
	let h = height;
	
	for (let p = 1; p <= planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let sf = pow(0.25, inp) * 1.75;
		
		push();
		scale(sf, sf);
		for (let y = 0; y <= h; y += sw) {
			for (let x = 0; x <= w; x += sh) {
				if ((x % (sw * 2)) ^ (y % (sh * 2))) { // checkerboard pattern
					let nx = abs(0.5 - x / w) * 2;
					let ny = abs(0.5 - y / h) * 2;
					
					fill(180 + (1 - np) * 160, 255 * np, 255 * np, 1 * np);
					rect(-sw + (x + xmotion * np + p * xp_offset * np) % (w + sw),
							 -sh + (y + ymotion * np + p * yp_offset * np) % (h + sh), sw, sh);
				}
			}
		}
		pop();
	}
	
	xmotion += 1;
	ymotion += 1;
}"
"884161","Parallax checkerboard","mySketch","// parallax checkerboard

function setup() {
	createCanvas(750, 750);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	background(0);
	
	stroke(0, 0, 0, 1);
	strokeWeight(0.25);
	
	let planes = 16;
	
	let sw = 50;
	let sh = 50;
	
	let xp_offset = 40;
	let yp_offset = 40;
	
	let w = width;
	let h = height;
	
	for (let p = 1; p <= planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let sf = pow(0.25, inp) * 1.75;
		
		push();
		scale(sf, sf);
		for (let y = 0; y <= h; y += sw) {
			for (let x = 0; x <= w; x += sh) {
				if ((x % (sw * 2)) ^ (y % (sh * 2))) { // checkerboard pattern
					let nx = abs(0.5 - x / w) * 2;
					let ny = abs(0.5 - y / h) * 2;
					
					fill(180 + (1 - np) * 160, 255 * np, 255 * np, 1 * np);
					rect(-sw + (x + xmotion * np + p * xp_offset * np) % (w + sw),
							 -sh + (y + ymotion * np + p * yp_offset * np) % (h + sh), sw, sh);
				}
			}
		}
		pop();
	}
	
	xmotion += 1;
	ymotion += 1;
}"
"884161","Parallax checkerboard","mySketch","// parallax checkerboard

function setup() {
	createCanvas(750, 750);
	
	background(0);

	colorMode(HSL, 360, 255, 255);
}

let xmotion = 0;
let ymotion = 0;

function draw() {
	background(0);
	
	stroke(0, 0, 0, 1);
	strokeWeight(0.25);
	
	let planes = 16;
	
	let sw = 50;
	let sh = 50;
	
	let xp_offset = 40;
	let yp_offset = 40;
	
	let w = width;
	let h = height;
	
	for (let p = 1; p <= planes; p += 1) {
		let np = p / planes;
		let inp = 1 - np;
		
		let sf = pow(0.25, inp) * 1.75;
		
		push();
		scale(sf, sf);
		for (let y = 0; y <= h; y += sw) {
			for (let x = 0; x <= w; x += sh) {
				if ((x % (sw * 2)) ^ (y % (sh * 2))) { // checkerboard pattern
					let nx = abs(0.5 - x / w) * 2;
					let ny = abs(0.5 - y / h) * 2;
					
					fill(180 + (1 - np) * 160, 255 * np, 255 * np, 1 * np);
					rect(-sw + (x + xmotion * np + p * xp_offset * np) % (w + sw),
							 -sh + (y + ymotion * np + p * yp_offset * np) % (h + sh), sw, sh);
				}
			}
		}
		pop();
	}
	
	xmotion += 1;
	ymotion += 1;
}"
"877240","My Sketch","mySketch","var sources = [];
var nbpxy = 32;
var nbpy = 32;
var nbp = nbpxy * nbpy; // because sphere

function getPointIndex(xy, z) {
	return xy + z * nbpxy;
}

function resetPoint(source) {
	let i = 0, j = 0;
	
	for (j = 0; j < nbpy; j += 1) {
		for (i = 0; i < nbpxy; i += 1) {
			let ni = i / nbpxy;
			
			let index = getPointIndex(i, j);

			source.points[index] = { x: source.x, y: source.y, vx: sin(ni * PI * 2), vy: cos(ni * PI * 2), out: 0 };
		}
	}
}

function setup() {
	createCanvas(512, 512);
	background(0);
	
	sources[0] = { x: width / 6, y: height / 2, points: [], xy_points_out: 0};
	sources[1] = { x: width - width / 6, y: height / 2, points: [], xy_points_out: 0};
	
	for (let k = 0; k < sources.length; k += 1) {
		let source = sources[k];
		
		resetPoint(source);
	}
}

var xmotion = 0;

function draw() {
	noStroke();
	fill(0, 0, 0, 16);
	rect(0, 0, width, height);
	
	noFill();
	stroke(255, 255, 255, 255);
	strokeWeight(1);
	
	let i = 0, k = 0, j = 0;
	for (k = 0; k < sources.length; k += 1) {
		let source = sources[k];
		for (j = 0; j < nbpy; j += 1) {
			for (i = 0; i < nbpxy; i += 1) {
				let index = getPointIndex(i, j);
				let p = source.points[index];

				p.x += p.vx;
				p.y += p.vy;

				if (((p.x >= width || p.x < 0) || (p.y >= height || p.y < 0)) &&
						k == sources.length / 2 && // only xy plane
						p.out == 0) {
					source.xy_points_out += 1;
					p.out = 1;
				}

				point(p.x, p.y);
			}
		}
	}
	
	for (k = 0; k < sources.length; k += 1) {
		let source = sources[k];

		if (source.xy_points_out == nbpy) {
			source.xy_points_out = 0;
			
			resetPoint(source);
		}
	}
	
	xmotion += 0.01;
}"
"877240","My Sketch","mySketch","var sources = [];
var nbpxy = 32;
var nbpz = 32;
var nbp = nbpxy * nbpz; // because sphere

function getPointIndex(xy, z) {
	return xy + z * nbpxy;
}

function resetPoint(source) {
	let i = 0, j = 0;
	
	for (j = 0; j < nbpz; j += 1) {
		let nz = j / nbpz;
		let nza = abs(0.5 - nz) * 2.;
		
		let z_angle_offset = nz * PI; // this help visualize Z on low points count
		
		for (i = 0; i < nbpxy; i += 1) {
			let ni = i / nbpxy;
			
			let index = getPointIndex(i, j);

			source.points[index] = { x: source.x, y: source.y, vx: sin(ni * PI * 2 + z_angle_offset) * nza, vy: cos(ni * PI * 2 + z_angle_offset) * nza, out: 0 };
		}
	}
}

function setup() {
	createCanvas(512, 512);
	background(0);
	
	sources[0] = { x: width / 6, y: height / 2, points: [], xy_points_out: 0};
	sources[1] = { x: width - width / 6, y: height / 2, points: [], xy_points_out: 0};
	
	for (let k = 0; k < sources.length; k += 1) {
		let source = sources[k];
		
		resetPoint(source);
	}
}

var xmotion = 0;

function draw() {
	noStroke();
	fill(0, 0, 0, 16);
	rect(0, 0, width, height);
	
	noFill();
	strokeWeight(1);
	
	let i = 0, k = 0, j = 0;
	for (k = 0; k < sources.length; k += 1) {
		let source = sources[k];
		for (j = 0; j < nbpz; j += 1) {
			let nz = j / nbpz;
			let nza = abs(0.5 - nz) * 2.0;
			
			let b = nza * 255;
			
			stroke(b, b, b, 255); // brightness of photons trace is based on depth (so only see XY plane most of the time)
			
			for (i = 0; i < nbpxy; i += 1) {
				let index = getPointIndex(i, j);
				let p = source.points[index];

				p.x += p.vx;
				p.y += p.vy;

				if (((p.x >= width || p.x < 0) || (p.y >= height || p.y < 0)) &&
						j == nbpz.length / 2 && // only xy plane
						p.out == 0) {
					source.xy_points_out += 1;
					p.out = 1;
				}

				point(p.x, p.y);
			}
		}
	}
	
	for (k = 0; k < sources.length; k += 1) {
		let source = sources[k];

		if (source.xy_points_out == nbpz) {
			source.xy_points_out = 0;
			
			resetPoint(source);
		}
	}
	
	xmotion += 0.01;
}"
"877240","My Sketch","mySketch","var sources = [];
var nbpxy = 32;
var nbpz = 32;
var nbp = nbpxy * nbpz; // because sphere

function getPointIndex(xy, z) {
	return xy + z * nbpxy;
}

function resetPoint(source) {
	let i = 0, j = 0;
	
	for (j = 0; j < nbpz; j += 1) {
		let nz = j / nbpz;
		let nza = abs(0.5 - nz) * 2.;
		
		let z_angle_offset = nz * PI; // this help visualize Z on low points count
		
		for (i = 0; i < nbpxy; i += 1) {
			let ni = i / nbpxy;
			
			let index = getPointIndex(i, j);

			source.points[index] = { x: source.x, y: source.y, vx: sin(ni * PI * 2 + z_angle_offset) * nza, vy: cos(ni * PI * 2 + z_angle_offset) * nza, out: 0 };
		}
	}
}

function setup() {
	createCanvas(512, 512);
	background(0);
	
	sources[0] = { x: width / 6, y: height / 2, points: [], xy_points_out: 0};
	sources[1] = { x: width - width / 6, y: height / 2, points: [], xy_points_out: 0};
	
	for (let k = 0; k < sources.length; k += 1) {
		let source = sources[k];
		
		resetPoint(source);
	}
}

var xmotion = 0;

function draw() {
	noStroke();
	fill(0, 0, 0, 16);
	rect(0, 0, width, height);
	
	noFill();
	strokeWeight(1);
	
	let i = 0, k = 0, j = 0;
	for (k = 0; k < sources.length; k += 1) {
		let source = sources[k];
		for (j = 0; j < nbpz; j += 1) {
			let nz = j / nbpz;
			let nza = abs(0.5 - nz) * 2.0;
			
			let b = nza * 255;
			
			stroke(b, b, b, 255); // brightness of photons trace is based on depth (so only see XY plane most of the time)
			
			for (i = 0; i < nbpxy; i += 1) {
				let index = getPointIndex(i, j);
				let p = source.points[index];

				p.x += p.vx;
				p.y += p.vy;

				if (((p.x >= width || p.x < 0) || (p.y >= height || p.y < 0)) &&
						j == nbpz / 2 && // only xy plane
						p.out == 0) {
					source.xy_points_out += 1;
					p.out = 1;
				}

				point(p.x, p.y);
			}
		}
	}
	
	for (k = 0; k < sources.length; k += 1) {
		let source = sources[k];

		if (source.xy_points_out == nbpz) {
			source.xy_points_out = 0;
			
			resetPoint(source);
		}
	}
	
	xmotion += 0.01;
}"
"877240","My Sketch","mySketch","var sources = [];
var nbpxy = 32;
var nbpz = 32;
var nbp = nbpxy * nbpz; // because sphere

function getPointIndex(xy, z) {
	return xy + z * nbpxy;
}

function resetPoint(source) {
	let i = 0, j = 0;
	
	for (j = 0; j < nbpz; j += 1) {
		let nz = j / nbpz;
		let nza = abs(0.5 - nz) * 2.;
		
		let z_angle_offset = nz * PI; // this help visualize Z on low points count
		
		for (i = 0; i < nbpxy; i += 1) {
			let ni = i / nbpxy;
			
			let index = getPointIndex(i, j);

			source.points[index] = { x: source.x, y: source.y, vx: sin(ni * PI * 2 + z_angle_offset) * nza, vy: cos(ni * PI * 2 + z_angle_offset) * nza, out: 0 };
		}
	}
}

function setup() {
	createCanvas(512, 512);
	background(0);
	
	sources[0] = { x: width / 6, y: height / 2, points: [], xy_points_out: 0};
	sources[1] = { x: width - width / 6, y: height / 2, points: [], xy_points_out: 0};
	
	for (let k = 0; k < sources.length; k += 1) {
		let source = sources[k];
		
		resetPoint(source);
	}
}

var xmotion = 0;

function draw() {
	noStroke();
	fill(0, 0, 0, 16);
	rect(0, 0, width, height);
	
	noFill();
	strokeWeight(1);
	
	let i = 0, k = 0, j = 0;
	for (k = 0; k < sources.length; k += 1) {
		let source = sources[k];
		for (j = 0; j < nbpz; j += 1) {
			let nz = j / nbpz;
			let nza = abs(0.5 - nz) * 2.0;
			
			let b = nza * 255;
			
			stroke(b, b, b, 255); // brightness of photons trace is based on depth (so only see XY plane most of the time)
			
			for (i = 0; i < nbpxy; i += 1) {
				let index = getPointIndex(i, j);
				let p = source.points[index];

				p.x += p.vx;
				p.y += p.vy;

				if (((p.x >= width || p.x < 0) || (p.y >= height || p.y < 0)) &&
						j == nbpz / 2 && // only xy plane
						p.out == 0) {
					source.xy_points_out += 1;
					p.out = 1;
				}

				point(p.x, p.y);
			}
		}
	}
	
	for (k = 0; k < sources.length; k += 1) {
		let source = sources[k];

		if (source.xy_points_out == nbpxy) {
			source.xy_points_out = 0;
			
			resetPoint(source);
		}
	}
	
	xmotion += 0.01;
}"
"877240","My Sketch","mySketch","var sources = [];
var nbpxy = 32;
var nbpz = 32;
var nbp = nbpxy * nbpz; // because sphere

function getPointIndex(xy, z) {
	return xy + z * nbpxy;
}

function resetPoint(source) {
	let i = 0, j = 0;
	
	for (j = 0; j < nbpz; j += 1) {
		let nz = j / nbpz;
		let nza = 1 - abs(0.5 - nz) * 2;

		let z_angle_offset = nz * PI; // this help visualize Z on low points count
		
		for (i = 0; i < nbpxy; i += 1) {
			let ni = i / nbpxy;
			
			let index = getPointIndex(i, j);

			source.points[index] = { x: source.x, y: source.y, vx: sin(ni * PI * 2 + z_angle_offset) * nza, vy: cos(ni * PI * 2 + z_angle_offset) * nza, out: 0 };
		}
	}
}

function setup() {
	createCanvas(512, 512);
	background(0);
	
	sources[0] = { x: width / 6, y: height / 2, points: [], xy_points_out: 0};
	//sources[1] = { x: width - width / 6, y: height / 2, points: [], xy_points_out: 0};
	
	for (let k = 0; k < sources.length; k += 1) {
		let source = sources[k];
		
		resetPoint(source);
	}
}

var xmotion = 0;

function draw() {
	noStroke();
	fill(0, 0, 0, 16);
	rect(0, 0, width, height);
	
	noFill();
	strokeWeight(1);
	
	let i = 0, k = 0, j = 0;
	for (k = 0; k < sources.length; k += 1) {
		let source = sources[k];
		for (j = 0; j < nbpz; j += 1) {
			let nz = j / nbpz;
			let nza = 1 - abs(0.5 - nz) * 2;
			
			let b = nza * 255;
			
			stroke(b, b, b, 255); // brightness of photons trace is based on depth (so only see XY plane most of the time)
			
			for (i = 0; i < nbpxy; i += 1) {
				let index = getPointIndex(i, j);
				let p = source.points[index];

				p.x += p.vx;
				p.y += p.vy;

				if (((p.x >= width || p.x < 0) || (p.y >= height || p.y < 0)) &&
						j == nbpz / 2 && // only xy plane
						p.out == 0) {
					source.xy_points_out += 1;
					p.out = 1;
				}

				point(p.x, p.y);
			}
		}
	}
	
	for (k = 0; k < sources.length; k += 1) {
		let source = sources[k];

		if (source.xy_points_out == nbpxy) {
			source.xy_points_out = 0;
			
			resetPoint(source);
		}
	}
	
	xmotion += 0.01;
}"
"877240","My Sketch","mySketch","var sources = [];
var nbpxy = 32;
var nbpz = 32;
var nbp = nbpxy * nbpz; // because sphere

function getPointIndex(xy, z) {
	return xy + z * nbpxy;
}

function resetPoint(source) {
	let i = 0, j = 0;
	
	for (j = 0; j < nbpz; j += 1) {
		let nz = j / nbpz;
		let nza = 1 - abs(0.5 - nz) * 2;

		let z_angle_offset = nza; // this help visualize Z on low points count
		
		for (i = 0; i < nbpxy; i += 1) {
			let ni = i / nbpxy;
			
			let index = getPointIndex(i, j);

			source.points[index] = { x: source.x, y: source.y, vx: sin(ni * PI * 2 + z_angle_offset) * nza, vy: cos(ni * PI * 2 + z_angle_offset) * nza, out: 0 };
		}
	}
}

function setup() {
	createCanvas(512, 512);
	background(0);
	
	sources[0] = { x: width / 6, y: height / 2, points: [], xy_points_out: 0, frequency: 1 };
	sources[1] = { x: width - width / 6, y: height / 2, points: [], xy_points_out: 0, frequency: 1 };
	
	for (let k = 0; k < sources.length; k += 1) {
		let source = sources[k];
		
		resetPoint(source);
	}
	
	colorMode(HSL, 360, 100, 100, 255);
}

var xmotion = 0;

function draw() {
	noStroke();
	fill(0, 0, 0, 16);
	rect(0, 0, width, height);
	
	noFill();
	strokeWeight(1);
	
	let i = 0, k = 0, j = 0;
	for (k = 0; k < sources.length; k += 1) {
		let source = sources[k];
		for (j = 0; j < nbpz; j += 1) {
			let nz = j / nbpz;
			let nza = 1 - abs(0.5 - nz) * 2;
			
			let b = nz * 100;
			
			let h = source.frequency; // color is based on wavelength / frequency with base reference of ~770hz
			
			stroke(h * 360, 100, b * nza, 255); // brightness of photons trace is based on depth (so only see XY plane most of the time)
			
			for (i = 0; i < nbpxy; i += 1) {
				let index = getPointIndex(i, j);
				let p = source.points[index];

				p.x += p.vx;
				p.y += p.vy;

				if (((p.x >= width || p.x < 0) || (p.y >= height || p.y < 0)) &&
						j == nbpz / 2 && // only xy plane
						p.out == 0) {
					source.xy_points_out += 1;
					p.out = 1;
				}

				// photon trace
				point(p.x, p.y);
			}
		}
	}
	
	for (k = 0; k < sources.length; k += 1) {
		let source = sources[k];

		if (source.xy_points_out == nbpxy) {
			source.xy_points_out = 0;
			
			resetPoint(source);
		}
	}
	
	xmotion += 0.01;
}"
"877240","My Sketch","mySketch","var sources = [];
var nbpxy = 32;
var nbpz = 32;
var nbp = nbpxy * nbpz; // because sphere

function getPointIndex(xy, z) {
	return xy + z * nbpxy;
}

function resetPoints(source, packet) {
	let i = 0, j = 0;
	
	for (j = 0; j < nbpz; j += 1) {
		let nz = j / nbpz;
		let nza = 1 - abs(0.5 - nz) * 2;

		let z_angle_offset = nza; // this help visualize Z on low points count
		
		for (i = 0; i < nbpxy; i += 1) {
			let ni = i / nbpxy;
			
			let index = getPointIndex(i, j);

			packet.points[index] = {
				x: source.x,
				y: source.y, 
				vx: sin(ni * PI * 2 + z_angle_offset) * nza * packet.frequency, 
				vy: cos(ni * PI * 2 + z_angle_offset) * nza * packet.frequency, out: 0 };
		}
	}
}

function setup() {
	createCanvas(512, 512);
	background(0);
	
	sources[0] = { x: width / 6, y: height / 2, packets: [{ points: [], xy_points_out: 0, frequency: 1 }, { points: [], xy_points_out: 0, frequency: 2 }] };
	sources[1] = { x: width - width / 6, y: height / 2, packets: [{ points: [], xy_points_out: 0, frequency: 1 }, { points: [], xy_points_out: 0, frequency: 2 }] };
	
	for (let k = 0; k < sources.length; k += 1) {
		let source = sources[k];
		
		for (let p = 0; p < source.packets.length; p += 1) {
			let packet = source.packets[p];
			resetPoints(source, packet);
		}
	}
	
	colorMode(HSL, 360, 100, 100, 255);
}

var xmotion = 0;

function draw() {
	noStroke();
	fill(0, 0, 0, 16);
	rect(0, 0, width, height);
	
	noFill();
	strokeWeight(1);
	
	let i = 0, k = 0, j = 0, u = 0;
	for (k = 0; k < sources.length; k += 1) {
		let source = sources[k];
		for (u = 0; u < source.packets.length; u += 1) {
			let packet = source.packets[u];
			for (j = 0; j < nbpz; j += 1) {
				let nz = j / nbpz;
				let nza = 1 - abs(0.5 - nz) * 2;

				let b = nz * 100;

				let h = packet.frequency; // color is based on wavelength / frequency with base reference of ~770hz

				stroke(h * 360, 100, b * nza, 255); // brightness of photons trace is based on depth (so only see XY plane most of the time)

				for (i = 0; i < nbpxy; i += 1) {
					let index = getPointIndex(i, j);
					let p = packet.points[index];

					p.x += p.vx;
					p.y += p.vy;

					if (((p.x >= width || p.x < 0) || (p.y >= height || p.y < 0)) &&
							j == nbpz / 2 && // only xy plane
							p.out == 0) {
						packet.xy_points_out += 1;
						p.out = 1;
					}

					// photon trace
					point(p.x, p.y);
				}
			}
		}
	}
	
	for (k = 0; k < sources.length; k += 1) {
		let source = sources[k];
		for (u = 0; u < source.packets.length; u += 1) {
			let packet = source.packets[u];
			
			if (packet.xy_points_out == nbpxy) {
				packet.xy_points_out = 0;

				resetPoints(source, packet);
			}
		}
	}
	
	xmotion += 0.01;
}"
"877240","My Sketch","mySketch","var sources = [];
var nbpxy = 32;
var nbpz = 32;
var nbp = nbpxy * nbpz; // because sphere

function getPointIndex(xy, z) {
	return xy + z * nbpxy;
}

function resetPoints(source, packet) {
	let i = 0, j = 0;
	
	for (j = 0; j < nbpz; j += 1) {
		let nz = j / nbpz;
		let nza = 1 - abs(0.5 - nz) * 2;

		let z_angle_offset = nza; // this help visualize Z on low points count
		
		for (i = 0; i < nbpxy; i += 1) {
			let ni = i / nbpxy;
			
			let index = getPointIndex(i, j);

			packet.points[index] = {
				x: source.x,
				y: source.y, 
				vx: sin(ni * PI * 2 + z_angle_offset) * nza * packet.frequency, 
				vy: cos(ni * PI * 2 + z_angle_offset) * nza * packet.frequency, out: 0 };
		}
	}
}

function setup() {
	createCanvas(512, 512);
	background(0);
	
	// frequency basis is based on visible spectrum and the visible spectrum is normalized in to [1, 2] range
	sources[0] = { x: width / 6, y: height / 2, packets: [{ points: [], xy_points_out: 0, frequency: 1 }, { points: [], xy_points_out: 0, frequency: 2 }] };
	sources[1] = { x: width - width / 6, y: height / 2, packets: [{ points: [], xy_points_out: 0, frequency: 1 }, { points: [], xy_points_out: 0, frequency: 2 }] };
	
	for (let k = 0; k < sources.length; k += 1) {
		let source = sources[k];
		
		for (let p = 0; p < source.packets.length; p += 1) {
			let packet = source.packets[p];
			resetPoints(source, packet);
		}
	}
	
	colorMode(HSL, 360, 100, 100, 255);
}

var xmotion = 0;

function draw() {
	noStroke();
	fill(0, 0, 0, 16);
	rect(0, 0, width, height);
	
	noFill();
	strokeWeight(1);
	
	let i = 0, k = 0, j = 0, u = 0;
	for (k = 0; k < sources.length; k += 1) {
		let source = sources[k];
		for (u = 0; u < source.packets.length; u += 1) {
			let packet = source.packets[u];
			for (j = 0; j < nbpz; j += 1) {
				let nz = j / nbpz;
				let nza = 1 - abs(0.5 - nz) * 2;

				let b = nz * 100;

				let h = (1.0 - (packet.frequency - 0.75)); // color is based on wavelength / frequency with base reference of ~770hz

				stroke(h * 360, 100, b * nza, 255); // brightness of photons trace is based on depth (so only see XY plane most of the time)

				for (i = 0; i < nbpxy; i += 1) {
					let index = getPointIndex(i, j);
					let p = packet.points[index];

					p.x += p.vx;
					p.y += p.vy;

					if (((p.x >= width || p.x < 0) || (p.y >= height || p.y < 0)) &&
							j == nbpz / 2 && // only xy plane
							p.out == 0) {
						packet.xy_points_out += 1;
						p.out = 1;
					}

					// photon trace
					point(p.x, p.y);
				}
			}
		}
	}
	
	for (k = 0; k < sources.length; k += 1) {
		let source = sources[k];
		for (u = 0; u < source.packets.length; u += 1) {
			let packet = source.packets[u];
			
			if (packet.xy_points_out == nbpxy) {
				packet.xy_points_out = 0;

				resetPoints(source, packet);
			}
		}
	}
	
	xmotion += 0.01;
}"
"877240","My Sketch","mySketch","var sources = [];
var nbpxy = 32;
var nbpz = 32;
var nbp = nbpxy * nbpz; // because sphere

function getPointIndex(xy, z) {
	return xy + z * nbpxy;
}

function resetPoints(source, packet) {
	let j = 0;
	for (j = 0; j < nbpz; j += 1) {
		let nz = j / nbpz;
		let nza = 1 - abs(0.5 - nz) * 2;

		let z_angle_offset = nza; // this help visualize Z on low points count
		
		let i = 0;
		for (i = 0; i < nbpxy; i += 1) {
			let ni = i / nbpxy;
			
			let index = getPointIndex(i, j);

			packet.points[index] = {
				x: source.x,
				y: source.y, 
				vx: sin(ni * PI * 2 + z_angle_offset) * nza * packet.frequency, 
				vy: cos(ni * PI * 2 + z_angle_offset) * nza * packet.frequency, out: 0 };
		}
	}
}

function setup() {
	createCanvas(512, 512);
	background(0);
	
	// frequency basis is based on visible spectrum and the visible spectrum is normalized in to [1, 2] range
	sources[0] = { x: width / 6, y: height / 2, packets: [{ points: [], xy_points_out: 0, frequency: 1 }, { points: [], xy_points_out: 0, frequency: 2 }] };
	sources[1] = { x: width - width / 6, y: height / 2, packets: [{ points: [], xy_points_out: 0, frequency: 1 }, { points: [], xy_points_out: 0, frequency: 2 }] };
	
	for (let k = 0; k < sources.length; k += 1) {
		let source = sources[k];
		
		for (let p = 0; p < source.packets.length; p += 1) {
			let packet = source.packets[p];
			resetPoints(source, packet);
		}
	}
	
	colorMode(HSL, 360, 100, 100, 255);
}

var xmotion = 0;

function draw() {
	noStroke();
	fill(0, 0, 0, 16);
	rect(0, 0, width, height);
	
	noFill();
	strokeWeight(1);
	
	let i = 0, k = 0, j = 0, u = 0;
	for (k = 0; k < sources.length; k += 1) {
		let source = sources[k];
		for (u = 0; u < source.packets.length; u += 1) {
			let packet = source.packets[u];
			for (j = 0; j < nbpz; j += 1) {
				let nz = j / nbpz;
				let nza = 1 - abs(0.5 - nz) * 2;

				let b = nz * 100;

				let h = (1.0 - (packet.frequency - 0.75)); // color is based on wavelength / frequency with base reference of ~770THz

				stroke(h * 360, 100, b * nza, 255); // brightness of photons trace is based on depth (so only see XY plane most of the time)

				for (i = 0; i < nbpxy; i += 1) {
					let index = getPointIndex(i, j);
					let p = packet.points[index];

					p.x += p.vx;
					p.y += p.vy;

					if (((p.x >= width || p.x < 0) || (p.y >= height || p.y < 0)) &&
							j == nbpz / 2 && // only xy plane
							p.out == 0) {
						packet.xy_points_out += 1;
						p.out = 1;
					}

					// photon trace
					// point(p.x, p.y);
				}
			}
		}
	}
	
	for (k = 0; k < sources.length; k += 1) {
		let source = sources[k];
		for (u = 0; u < source.packets.length; u += 1) {
			let packet = source.packets[u];
			
			if (packet.xy_points_out == nbpxy) {
				packet.xy_points_out = 0;

				resetPoints(source, packet);
			}
		}
	}
	
	xmotion += 0.01;
}"
"877240","My Sketch","mySketch","var sources = [];
var nbpxy = 32;
var nbpz = 32;
var nbp = nbpxy * nbpz; // because sphere

function getPointIndex(xy, z) {
	return xy + z * nbpxy;
}

function resetPoints(source, packet) {
	let j = 0;
	for (j = 0; j < nbpz; j += 1) {
		let nz = j / nbpz;
		let nza = 1 - abs(0.5 - nz) * 2;

		let z_angle_offset = nza; // this help visualize Z on low points count
		
		let i = 0;
		for (i = 0; i < nbpxy; i += 1) {
			let ni = i / nbpxy;
			
			let index = getPointIndex(i, j);

			packet.points[index] = {
				x: source.x,
				y: source.y, 
				vx: sin(ni * PI * 2 + z_angle_offset) * nza * packet.frequency, 
				vy: cos(ni * PI * 2 + z_angle_offset) * nza * packet.frequency, out: 0 };
		}
	}
}

function setup() {
	createCanvas(512, 512);
	background(0);
	
	// frequency basis is based on visible spectrum and the visible spectrum is normalized in to [1, 2] range
	sources[0] = { 
		x: width / 6,
		y: height / 2,
		packets: [
			{
				points: [],
				xy_points_out: 0,
				frequency: 1 
			},
			{ 
				points: [],
				xy_points_out: 0,
				frequency: 2
			}
		]
	};
	sources[1] = {
		x: width - width / 6,
		y: height / 2,
		packets: [
			{
				points: [],
				xy_points_out: 0,
				frequency: 1
			},
			{
				points: [],
				xy_points_out: 0,
				frequency: 2
			}
		]
	};
	
	for (let k = 0; k < sources.length; k += 1) {
		let source = sources[k];
		
		for (let p = 0; p < source.packets.length; p += 1) {
			let packet = source.packets[p];
			resetPoints(source, packet);
		}
	}
	
	colorMode(HSL, 360, 100, 100, 255);
}

var xmotion = 0;

function draw() {
	noStroke();
	fill(0, 0, 0, 16);
	rect(0, 0, width, height);
	
	noFill();
	strokeWeight(1);
	
	let i = 0, k = 0, j = 0, u = 0;
	for (k = 0; k < sources.length; k += 1) {
		let source = sources[k];
		for (u = 0; u < source.packets.length; u += 1) {
			let packet = source.packets[u];
			for (j = 0; j < nbpz; j += 1) {
				let nz = j / nbpz;
				let nza = 1 - abs(0.5 - nz) * 2;

				let b = nz * 100;

				let h = (1.0 - (packet.frequency - 0.75)); // color is based on wavelength / frequency with base reference of ~770THz

				stroke(h * 360, 100, b * nza, 255); // brightness of photons trace is based on depth (so only see XY plane most of the time)

				for (i = 0; i < nbpxy; i += 1) {
					let index = getPointIndex(i, j);
					let p = packet.points[index];

					p.x += p.vx;
					p.y += p.vy;

					if (((p.x >= width || p.x < 0) || (p.y >= height || p.y < 0)) &&
							j == nbpz / 2 && // only xy plane
							p.out == 0) {
						packet.xy_points_out += 1;
						p.out = 1;
					}

					// photon trace
					// point(p.x, p.y);
				}
			}
		}
	}
	
	for (k = 0; k < sources.length; k += 1) {
		let source = sources[k];
		for (u = 0; u < source.packets.length; u += 1) {
			let packet = source.packets[u];
			
			if (packet.xy_points_out == nbpxy) {
				packet.xy_points_out = 0;

				resetPoints(source, packet);
			}
		}
	}
	
	xmotion += 0.01;
}"
"862762","ifs5","mySketch","// ifs
// https://flam3.com/flame_draves.pdf
// stacked with symmetry
// and colors
// some great patterns can be made with that algorithm and stacking / compositing, it is also awesome as frame generator...

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];

let ifs = 4;

function setup() {
  createCanvas(windowHeight - 1, windowHeight - 1);
  background(0);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 100, 100, 255);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
	}
}

function f1(x, y, j) {
	return { x: x / (2.85 - abs(cos(y / width * PI * abs(0.5 - j / ifs) * (y / (width / 128)))) * 1), y: abs(width / 2 - x - y / 2) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 1 * x) / 1.5, y: abs(height / 2 - y) / (3 - abs(cos(x / width * PI * abs(0.5 - j / ifs) * (y / (width / 2))))) };
}

function f3(x, y, j) {
	return { x: abs(width * 1.5 - (x % (y / 32))), y: y / 1.5 };
}

var f = [f1, f2, f3];

var iter = 0;

function draw() {
	//fill(0, 0, 0, 1);
	//rect(0, 0, width, height);
	
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 0; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;

				fill(100 - 64 * ((j + 1) / ifs), 50 * (j / ifs), 100, 255 * (i / 1000) / 6);

				let e = 1;

				if (iter > 20) {
					ellipse(x[j], y[j], e, e);	
					ellipse(y[j], x[j], e, e);	
					ellipse(x[j], height - y[j], e, e);	
					ellipse(height - y[j], x[j], e, e);	
					ellipse(height - y[j], width - x[j], e, e);	
					ellipse(height - x[j], width - y[j], e, e);	
				}
			}

			iter += 1;
		}
	}
	
	xmotion += 1;
	ymotion += 1;
}"
"853260","ifs4","mySketch","// ifs
// https://flam3.com/flame_draves.pdf
// stacked with symmetry
// and colors
// some great patterns can be made with that algorithm and stacking / compositing, it is also awesome as frame generator...

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];

let ifs = 4;

function setup() {
  createCanvas(windowHeight - 1, windowHeight - 1);
  background(0);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 100, 100, 255);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
	}
}

function f1(x, y, j) {
	return { x: x / (2.85 - abs(cos(y / width * PI * abs(0.5 - j / ifs) * (y / (width / 128)))) * 1), y: abs(width / 1.75 - x - y / 1.15) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 2 * x) / 1.035, y: abs(height / 1.1 - y) / (3 - abs(cos(x / width * PI * abs(0.5 - j / ifs) * (y / (width / 2))))) };
}

function f3(x, y, j) {
	return { x: abs(width * 0.5 - (x % y + 0.5)), y: y / 1.5 };
}

var f = [f1, f2, f3];

var iter = 0;

function draw() {
	//fill(0, 0, 0, 1);
	//rect(0, 0, width, height);
	
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 0; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;

				fill(100 - 64 * ((j + 1) / ifs), 100 * (j / ifs), 100, 255 * (i / 1000) / 6);

				let e = 1;

				if (iter > 20) {
					ellipse(x[j], y[j], e, e);	
					ellipse(y[j], x[j], e, e);	
					ellipse(x[j], height - y[j], e, e);	
					ellipse(height - y[j], x[j], e, e);	
					ellipse(height - y[j], width - x[j], e, e);	
					ellipse(height - x[j], width - y[j], e, e);	
				}
			}

			iter += 1;
		}
	}
	
	xmotion += 1;
	ymotion += 1;
}"
"851408","ifs3","mySketch","// ifs
// https://flam3.com/flame_draves.pdf
// stacked with symmetry
// would need some normalization...

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];

let ifs = 4;

function setup() {
  createCanvas(windowHeight - 1, windowHeight - 1);
  background(0);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 100, 100, 255);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
	}
}

function f1(x, y, j) {
	return { x: x / (3.85 - abs(cos(y / width * PI * (j / ifs * 2))) * 2.75), y: abs(width - x - y / 2.05) };
}

function f2(x, y, j) {
	return { x: (abs(0.5 - j / ifs) * 1 * x) / 1.25, y: abs(height - y) / (4.5 - abs(cos(x / width * PI * abs(0.5 - j / ifs) * 2))*3) };
}

function f3(x, y, j) {
	return { x: abs(width * 1.45 - x) / 3.45, y: y / 1.75 };
}

var f = [f1, f2, f3];

var iter = 0;

function draw() {
	//fill(0, 0, 0, 1);
	//rect(0, 0, width, height);
	
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 0; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;

				fill(167 + 64 * ((j + 1) / ifs), 24 * (j / ifs), 100 * ((j + 1) / ifs), 255 * (i / 1000) / 6);

				let e = 1;

				if (iter > 20) {
					ellipse(x[j], y[j], e, e);	
					ellipse(y[j], x[j], e, e);	
					ellipse(x[j], height - y[j], e, e);	
					ellipse(height - y[j], x[j], e, e);	
					ellipse(height - y[j], width - x[j], e, e);	
					ellipse(height - x[j], width - y[j], e, e);	
				}
			}

			iter += 1;
		}
	}
	
	xmotion += 1;
	ymotion += 1;
}"
"842689","ifs²","mySketch","// ifs
// https://flam3.com/flame_draves.pdf
// stacked with symmetry
// would need some normalization...

var xmotion = 0;
var ymotion = 0;

let x = [];
let y = [];

let ifs = 6;

function setup() {
  createCanvas(windowHeight - 1, windowHeight - 1);
  background(0);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 100, 100, 255);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	for (var i = 0; i < ifs; i += 1) {
		x[i] = random(0, width);
		y[i] = random(0, height);
	}
}

function f1(x, y, j) {
	return { x: x / (3 - abs(cos(y / width * PI * 1.5) / 3)), y: abs(x - y / 4) };
}

function f2(x, y, j) {
	return { x: sin(abs(0.5 - x / width) * 2 * PI * 2) * (j / ifs * (x / 16)) + (width / 1.25 + x) / 1.5, y: (height + y) / (1.5 - abs(cos(x / width * PI * 1) / 2.)) };
}

function f3(x, y, j) {
	return { x: (width + x) / 1.1, y: cos(abs(0.5 - y / height) * 2 * PI * 2) * (j / ifs * (y / 16)) + y / 1. };
}

var f = [f1, f2, f3];

var iter = 0;

function draw() {
	//fill(0, 0, 0, 1);
	//rect(0, 0, width, height);
	
	if (iter < 500000) {
		for (let i = 0; i < 1000; i += 1) {
			for (let j = 0; j < ifs; j += 1) {
				let index = floor(random(0, f.length));
				let r = f[index](x[j], y[j], j);

				x[j] = r.x; y[j] = r.y;

				fill(167 + 64 * ((j + 1) / ifs), 24 * (j / ifs), 100 * ((j + 1) / ifs), 255 * (i / 1000) / 4);

				let e = 2;

				if (iter > 20) {
					ellipse(x[j], y[j], e, e);	
					ellipse(y[j], x[j], e, e);	
					ellipse(x[j], height - y[j], e, e);	
					ellipse(height - y[j], x[j], e, e);	
				}
			}

			iter += 1;
		}
	}
	
	xmotion += 1;
	ymotion += 1;
}"
"840927","Sand Sketch","mySketch","float xmotion = 8.8;
float ymotion = 0;

void draw_func() {
	/*if ((frameCount % 200) == 0) {
		background(0);
	}*/
	
	noStroke();
	
	loadPixels();
	for (int y = 0; y < height; y += 1) {
		int yy = y * width;
		for (int x = 0; x < width; x += 1) {
			color p = pixels[yy + x];
			
			if (brightness(p) > 0 && brightness(p) < 164 - abs(frameCount * 1.5)) {
				float n = (0.5-noise((float)x/width*40+xmotion,(float)y/height*400+ymotion))*2;
				float n2 = (0.5-noise((float)y/height*40+ymotion,(float)x/width*400+xmotion))*2;
				
				fill(hue(p) + abs(n)*2., 148 - (xmotion % 24), 255, 24 + xmotion % 2);
				
				rect(x + n, y + n, 2, 2);
				rect(width - x  - n2, y - n2, 2, 2);
			}
		}
	}
	
	noFill();
	noStroke();
  strokeWeight(32);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
if (frameCount < 30) {
	for (int i = 1; i < 48; i += 1) {
		float norm_i = 1-((float)(i - 1) / 48);
		
		stroke(16+random(0, 92), 128 * norm_i, 255 * norm_i, 1);

		//int sw = (float)width/2 / (i * 1) + abs(cos(ymotion/2) * 256);
		//int sh = height/2 / (i * 1)+ abs(sin(xmotion/2) * 64);
		
		float n = random(0, 1);
		//line(width/64*i, 0, width/64*i, height);
		line(16, height/32*i - 48, -16 + width/i*pow(i, 0.05 + n * 0.3), height/32*i - 64);
		line(16, height - height/32*i - 12, -16 + width/i*pow(i, 0.05 + n * 0.01), height - height/32*i - 32);
	}
	rectMode(CORNER);
	
	
for (int i = 1; i < 64; i += 1) {
		float ni = abs(0.5 - i / 64) * 2;

		fill(92 + random(-32, 32), 255, 255, 2);
		ellipse(width / 2 + xmotion * 0.85 * sin(ni * PI * 0.9), height / 2.25 + 521 * ni, 8 * ni, 8 * ni);
	}
	//arc(width / 2, height / 1.25, 200, 12, 0, PI, CHORD);
}
	xmotion += 100.1;
	ymotion += 0.5;
}

void setup() {
  size(800, 800);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	noiseDetail(7,0.65);
	
	frameRate(30);
	
	//smooth();
}

void draw() {
  draw_func();
}"
"820804","Random Convolution","mySketch","let img;
let w = 120;

let matrix = [ [ -1, -1, -1 ],
               [ -1,  9, -1 ],
               [ -1, -1, -1 ] ]; 

function preload() {
    img = loadImage('beach.png');
}

function setup() {
	createCanvas(windowWidth, windowHeight);
	
	background(0);
}

function draw() {
  image(img, 0, 0);

  let xstart = constrain(mouseX - w/2, 0, img.width);
  let ystart = constrain(mouseY - w/2, 0, img.height);
  let xend = constrain(mouseX + w/2, 0, img.width);
  let yend = constrain(mouseY + w/2, 0, img.height);
  let matrixsize = 3;
  
	loadPixels();
  // Begin our loop for every pixel in the smaller image
  for (let x = xstart; x < xend; x++) {
    for (let y = ystart; y < yend; y++ ) {
      let c = convolution(x, y, matrix, matrixsize, img);
      let loc = (x + y*img.width) * 4;
      pixels[loc] = c[0];
			pixels[loc+1] = c[1];
			pixels[loc+2] = c[2];
    }
  }
  updatePixels();
}

function convolution(x, y, matrix, matrixsize, img) {
  let rtotal = 0.0;
  let gtotal = 0.0;
  let btotal = 0.0;
  let offset = matrixsize / 2;
  for (let i = 0; i < matrixsize; i++){
    for (let j= 0; j < matrixsize; j++){
      // What pixel are we testing
      let xloc = x+i-offset;
      let yloc = y+j-offset;
      let loc = (xloc + img.width*yloc)*4;
      // Make sure we haven't walked off our image, we could do better here
      loc = constrain(loc,0,img.pixels.length-1);
      // Calculate the convolution
      rtotal += (img.pixels[loc+0] * matrix[i][j]);
      gtotal += (img.pixels[loc+1] * matrix[i][j]);
      btotal += (img.pixels[loc+2] * matrix[i][j]);
    }
  }
  // Make sure RGB is within range
  rtotal = constrain(rtotal, 0, 255);
  gtotal = constrain(gtotal, 0, 255);
  btotal = constrain(btotal, 0, 255);
  // Return the resulting color
  return [rtotal, gtotal, btotal];
}
"
"820804","Random Convolution","mySketch","let img;
let w = 100;

let xmotion = 0;
let ymotion = 0;

let matrix = [ [ -1, -1, -1 ],
               [ -1,  9, -1 ],
               [ -1, -1, -1 ] ]; 

function preload() {
    img = loadImage('16288566478868753032.jpeg');
}

function setup() {
	createCanvas(450, 550);
	
	background(0);
	
	img.loadPixels();
	
	noiseDetail(7, 0.7)
}

function draw() {
  image(img, 0, 0);

  let xstart = constrain(mouseX - w/2, 0, img.width);
  let ystart = constrain(mouseY - w/2, 0, img.height);
  let xend = constrain(mouseX + w/2, 0, img.width);
  let yend = constrain(mouseY + w/2, 0, img.height);
  let matrixsize = 3;
  
			for (let i = 0; i < matrixsize; i++) {
				for (let j = 0; j < matrixsize; j++ ) {
					matrix[i][j] = noise(i * 80+xmotion,j * 80+ymotion)
				}
			}
				
	loadPixels();
  // Begin our loop for every pixel in the smaller image
  for (let x = xstart; x < xend; x++) {
    for (let y = ystart; y < yend; y++ ) {
      let c = convolution(x, y, matrixsize);
      let loc = parseInt((x + y*img.width) * 4, 10);
      pixels[loc] = c[0];
			pixels[loc+1] = c[1];
			pixels[loc+2] = c[2];
    }
  }
  updatePixels();
	
	xmotion += 0.01;
	ymotion += 0.05;
}

function convolution(x, y, matrixsize) {
  let rtotal = 0.0;
  let gtotal = 0.0;
  let btotal = 0.0;
  let offset = matrixsize / 2;
  for (let i = 0; i < matrixsize; i++){
    for (let j= 0; j < matrixsize; j++){
      // What pixel are we testing
      let xloc = x+(i-offset)*4;
      let yloc = y+(j-offset)*4;
      let loc = parseInt((xloc + img.width*yloc)*4, 10);
      // Make sure we haven't walked off our image, we could do better here
      //loc = constrain(loc,0,img.pixels.length-1);
      // Calculate the convolution
      rtotal += (img.pixels[loc+0] * matrix[i][j]);
      gtotal += (img.pixels[loc+1] * matrix[i][j]);
      btotal += (img.pixels[loc+2] * matrix[i][j]);
    }
  }
  // Make sure RGB is within range
  rtotal = constrain(rtotal, 0, 255);
  gtotal = constrain(gtotal, 0, 255);
  btotal = constrain(btotal, 0, 255);
  // Return the resulting color
  return [rtotal, gtotal, btotal];
}
"
"818016","REYES² / volumetric rendering","mySketch","let texture = null;
function preload() {
    texture = loadImage('texture_512.png');
}

/**
  * A tentative to do a 3D renderer using REYES like algorithms (a type of rendering invented / developed by Lucasfilm / Pixar in the mid-80s and still used to late 2000s)
	* Actually REYES is more like a collection of classical computer graphics algorithms packed into a single solution with a well defined pipeline process.
	*
	* Actually it is more like a standard rasterizer than REYES... :)
	*
	* REYES algorithm is simple and powerful, it is between rasterization and state of art algorithms like raytracing / pathtracing
	* in term of power and it have some speed advantages over that last one but it is most importantly very flexible and parallelization friendly.
	* 
	* So how does it work ? It is pretty similar to a standard rasterizer and work mainly with polygons but... with a process of massive surfaces subdivision (preferably adaptive)
	* which produce ""micropolygons"", polygons that are the size of a pixel or so and which allow easy / fast shading computations, there is also some important optimization steps.
	*
	* ""All objects are reduced to common world-space geometric entities called micropolygons, and all of the shading and visibility calculations operate on these micropolygons.
	*  Each type of calculation is performed in a coordinate system that is natural for that type of calculation.
	*  Micropolygons are created and textured in the local coordinate system of the object, with the result that texture filtering is simplified and improved.
	*  Visibility is calculated in screen space using stochastic point sampling with a z buffer.
	*  There are no clipping or perspective calculations. Geometric and texture locality are exploited to minimize paging and to support models that contain arbitrarily many primitives.""
  *
	* Surfaces may be defined through NURBS for example but i chose a parametric object for this demonstration.
	*
	* https://en.wikipedia.org/wiki/Reyes_rendering
	* 
	* How it was made :
	*  - first we want to define a geometric object (a cube) programmatically, i chose to do it as a parametric surface by simply stepping
	*    in normalized space through points for X,Y,Z then converting to screen space and centering the object. Doing it by stepping on the surface
	*    allow us to control as wanted the stepping factor (which will be our subdivision factor for our polygons)
	*  - since we also stepped through Z we are already rendering a kind of volumetric cube data (which is cool because you could even do volumetric effects later on !)
	*  - since we are only interested by the cube surface, we filter the volumetric data and retain the points on the surface
	*  - we do projection + rotation of our object at the same time with simple matrix / vector operation
	*  - once we have the object points rendered we can do a simple shading that will give us some depth by computing
  *    the length then normalizing the point position vector and assigning the Z value scaled by the max. RGB value to the point color
	*  - at this point we have several ways to render our object :
	*   - by simply rendering the dots
	*   - by detecting the surfaces of the cube we are on (by looking to points position), computing next value for X/Y or X/Z or Y/Z
	*     using those values to draw lines to form two triangles (a quad), this is wireframe mode, we can also compute points value in different order for different wireframe mode
	*   - same step as above but then fill the triangles with barycentric algorithm (find bounding box of triangle, step through X/Y and check wether we are in or out)
	*     we will have flat shading at low resolution but... it also pave the road to the easy application of more complex shading algorithms or texturing!! an important step is also to
	*     check shaded point distance against a Z buffer to remove hidden surfaces
	*
	* Note : When filling polygon we give a step of more than 1 and increase the size of the ""rect"" primitive, this allow fast rendering at the price of huge quality lost
	*        but if you are doing it non-realtime you would increase subdivision to the point of each triangles being 1px, the flat shading would suddenly be smooth shading! :)
	*
	* How can this be improved ?
	*  - add texturing
	*  - fill quads instead of triangles
	*  - add more parametric surfaces and especially more generic surfaces
	*  - add shading algorithms (phong etc.)
	*  - play with volumetric data :)
	*  - adaptative subdivision ?
	*  - parallelization
	*  - cleanup of the sides checking
	*  - non-realtime render to obtain high quality images (when subdivision is low)
	*/

let frame = 0;

let cs = 580; // also scale :P
let inc = 0.5; // control surface subdivision, lower = higher quality (but too slow for realtime)
let csi = 1.0 / inc; // how much points our surface will have along a specific axis
let scale = 1.0 / 8.0; // cube scale

let depthbuffer;

function setup() {
  createCanvas(1024, 768);

  background(0);
	
	noStroke();
	
	depthbuffer = createGraphics(width, height);
	depthbuffer.noStroke();
}

function fillTriangle(x1, y1, x2, y2, x3, y3, shading) {
	let maxX = max(x1, max(x2, x3));
	let minX = min(x1, min(x2, x3));
	let maxY = max(y1, max(y2, y3));
	let minY = min(y1, min(y2, y3));
	
	let vs1x = x2 - x1;
	let vs1y = y2 - y1;
	let vs2x = x3 - x1;
	let vs2y = y3 - y1;

	for (let x = minX; x <= maxX; x += 4) {
  	for (let y = minY; y <= maxY; y += 4) {
			let qx = x - x1;
			let qy = y - y1;
			
			let s = (qx * vs2y - vs2x * qy) / (vs1x * vs2y - vs2x * vs1y);
			let t = (vs1x * qy - qx * vs1y) / (vs1x * vs2y - vs2x * vs1y);

			if ( (s >= 0) && (t >= 0) && (s + t <= 1)) {
				// check against Z buffer!
				if (shading >= depthbuffer.get(x, y)[0]) {
					// depth value go into depth buffer
					//depthbuffer.beginDraw();
					depthbuffer.fill(shading, shading, shading);
					depthbuffer.rect(x, y, 4, 4);
					//depthbuffer.endDraw();
					
					rect(x, y, 4, 4);
				}
			}
		}
	}
}

function draw() {
	// clear z-buffer
	//depthbuffer.beginDraw();
	depthbuffer.background(0);
	//depthbuffer.endDraw();
	
  background(0);
	//fill(0, 0, 0, 48);
	//rect(0, 0, width, height);
	
	let rxa = 0.03 * frame;
	let rya = 0.04 * frame;

	// rotation values
	let crx = cos(rxa);
	let cry = cos(rya);
	let srx = sin(rxa);
	let sry = sin(rya);
	
	// rm = rotation matrix
	let rm = [0,0,0,0,0,0,0,0,0];

	rm[0] = cry;     /*rm[1] = 0.0f;*/ rm[2] = -sry;
	rm[3] = sry * srx; rm[4] = crx;    rm[5] = cry * srx;
	rm[6] = sry * crx; rm[7] = -srx;   rm[8] = cry * crx;
	
	let x2 = width / 2;
	let y2 = height / 2;
	
	// step cube volume along X,Y,Z in normalized space
	let x, y, z;
	for (z = 0.0; z <= 1.0; z += inc) {
		let vr = [0,0,0];

		let pz = 2.0 * z - 1.0; // normalize screen space

		vr[2] = pz * scale;
		for (y = 0.0; y <= 1.0; y += inc) {
			let py = 2.0 * y - 1.0;

			vr[1] = py * scale;
			for (x = 0.0; x <= 1.0; x += inc) {
				// filter volumetric data (eg. we only want the points on the surface)
				if (x > 0.0 && x < (1.0 - inc) && y > 0.0 && y < (1.0 - inc) && z > 0.0 && z < (1.0 - inc)) continue;
				
				let px = (2.0 * x - 1.0);
				
				vr[0] = px * scale;

				// rotate/transform our points
				let vrr = [
						rm[0] * vr[0] + rm[3] * vr[1] + rm[6] * vr[2],
						rm[1] * vr[0] + rm[4] * vr[1] + rm[7] * vr[2],
						rm[2] * vr[0] + rm[5] * vr[1] + rm[8] * vr[2]
				];
			
				// compute length & normalize
				let le = sqrt((vrr[0] * vrr[0]) + (vrr[1] * vrr[1]) + (vrr[2] * vrr[2]));
			  let vrn = [ vrr[0] / le, vrr[1] / le, vrr[2] / le ];

				// point shade based on normalized Z value
			  let shading = vrn[2] * 255;
				//fill(shading, shading, shading);

				// since we were in normalized space we scale it to screen space and translate it at the center of the screen
				let posx = x2 - (int)(vrr[0] * cs);
				let posy = y2 - (int)(vrr[1] * cs);
		
				// draw cube surface
				let px2 = (2.0 * (x + inc) - 1.0);
				let pxs = px2 * scale;
				let py2 = (2.0 * (y + inc) - 1.0);
				let pys = py2 * scale;
				let pz2 = (2.0 * (z + inc) - 1.0);
				let pzs = pz2 * scale;
		
				let posx2; let posy2;
				let posx3; let posy3;
				let posx4; let posy4;
				
				// cube side detection & polygons drawing
				// note : could be optimized into much shorted code...
				if (y >= 0.0 && y <= (1.0 - inc) &&
						z >= 0.0 && z <= (1.0 - inc) &&
					  (x >= 0.99 || x <= 0.0)) {
					let vrr2 = [
							rm[0] * vr[0] + rm[3] * vr[1] + rm[6] * pzs,
							rm[1] * vr[0] + rm[4] * vr[1] + rm[7] * pzs,
							rm[2] * vr[0] + rm[5] * vr[1] + rm[8] * pzs
					];
		
					let vrr3 = [
							rm[0] * vr[0] + rm[3] * pys + rm[6] * pzs,
							rm[1] * vr[0] + rm[4] * pys + rm[7] * pzs,
							rm[2] * vr[0] + rm[5] * pys + rm[8] * pzs
					];
	
					let vrr4 = [
							rm[0] * vr[0] + rm[3] * pys + rm[6] * vr[2],
							rm[1] * vr[0] + rm[4] * pys + rm[7] * vr[2],
							rm[2] * vr[0] + rm[5] * pys + rm[8] * vr[2]
					];
		
					posx2 = x2 - round(vrr2[0] * cs);
					posy2 = y2 - round(vrr2[1] * cs);
					posx3 = x2 - round(vrr3[0] * cs);
					posy3 = y2 - round(vrr3[1] * cs);
					posx4 = x2 - round(vrr4[0] * cs);
					posy4 = y2 - round(vrr4[1] * cs);
/*
					// wireframe
					stroke(shading, shading, shading);
					line(posx, posy, posx2, posy2);
					line(posx2, posy2, posx3, posy3);
					line(posx3, posy3, posx, posy);

					stroke(shading, 0, 0);
					line(posx, posy, posx4, posy4);
					line(posx4, posy4, posx3, posy3);
					line(posx3, posy3, posx, posy);
*/
					noStroke();
					fill(shading, shading, shading);
					fillTriangle(posx, posy, posx2, posy2, posx3, posy3, shading);
					fillTriangle(posx, posy, posx4, posy4, posx3, posy3, shading);
					noFill();
				}
				
				if (x >= 0.0 && x <= (1.0 - inc) &&
									 y >= 0.0 && y <= (1.0 - inc) &&
									 (z >= 0.99 || z <= 0.0)) {
					let vrr2 = [
							rm[0] * pxs + rm[3] * vr[1] + rm[6] * vr[2],
							rm[1] * pxs + rm[4] * vr[1] + rm[7] * vr[2],
							rm[2] * pxs + rm[5] * vr[1] + rm[8] * vr[2]
					];
		
					let vrr3 = [
							rm[0] * pxs + rm[3] * pys + rm[6] * vr[2],
							rm[1] * pxs + rm[4] * pys + rm[7] * vr[2],
							rm[2] * pxs + rm[5] * pys + rm[8] * vr[2]
					];
	
					let vrr4 = [
							rm[0] * vr[0] + rm[3] * pys + rm[6] * vr[2],
							rm[1] * vr[0] + rm[4] * pys + rm[7] * vr[2],
							rm[2] * vr[0] + rm[5] * pys + rm[8] * vr[2]
					];
		
					posx2 = x2 - round(vrr2[0] * cs);
					posy2 = y2 - round(vrr2[1] * cs);
					posx3 = x2 - round(vrr3[0] * cs);
					posy3 = y2 - round(vrr3[1] * cs);
					posx4 = x2 - round(vrr4[0] * cs);
					posy4 = y2 - round(vrr4[1] * cs);
/*
					// wireframe
					stroke(shading, shading, shading);
					line(posx, posy, posx2, posy2);
					line(posx2, posy2, posx3, posy3);
					line(posx3, posy3, posx, posy);

					stroke(shading, 0, 0);
					line(posx, posy, posx4, posy4);
					line(posx4, posy4, posx3, posy3);
					line(posx3, posy3, posx, posy);
*/
					noStroke();
					fill(shading, shading, shading);
					fillTriangle(posx, posy, posx2, posy2, posx3, posy3, shading);
					fillTriangle(posx, posy, posx4, posy4, posx3, posy3, shading);
					noFill();
				}
				
				if (x >= 0.0 && x <= (1.0 - inc) &&
									 z >= 0.0 && z <= (1.0 - inc) &&
									 (y >= 0.99 || y <= 0.0)) {
					let vrr2 = [
							rm[0] * pxs + rm[3] * vr[1] + rm[6] * vr[2],
							rm[1] * pxs + rm[4] * vr[1] + rm[7] * vr[2],
							rm[2] * pxs + rm[5] * vr[1] + rm[8] * vr[2]
					];
		
					let vrr3 = [
							rm[0] * pxs + rm[3] * vr[1] + rm[6] * pzs,
							rm[1] * pxs + rm[4] * vr[1] + rm[7] * pzs,
							rm[2] * pxs + rm[5] * vr[1] + rm[8] * pzs
					];
	
					let vrr4 = [
							rm[0] * vr[0] + rm[3] * vr[1] + rm[6] * pzs,
							rm[1] * vr[0] + rm[4] * vr[1] + rm[7] * pzs,
							rm[2] * vr[0] + rm[5] * vr[1] + rm[8] * pzs
					];
		
					posx2 = x2 - round(vrr2[0] * cs);
					posy2 = y2 - round(vrr2[1] * cs);
					posx3 = x2 - round(vrr3[0] * cs);
					posy3 = y2 - round(vrr3[1] * cs);
					posx4 = x2 - round(vrr4[0] * cs);
					posy4 = y2 - round(vrr4[1] * cs);
/*
					// wireframe
					stroke(shading, shading, shading);
					line(posx, posy, posx2, posy2);
					line(posx2, posy2, posx3, posy3);
					line(posx3, posy3, posx, posy);

					stroke(shading, 0, 0);
					line(posx, posy, posx4, posy4);
					line(posx4, posy4, posx3, posy3);
					line(posx3, posy3, posx, posy);
*/
					noStroke();
					fill(shading, shading, shading);
					fillTriangle(posx, posy, posx2, posy2, posx3, posy3, shading);
					fillTriangle(posx, posy, posx4, posy4, posx3, posy3, shading);
					noFill();
				}
				
				// no z-buffer, optimized filling
				//quad(posx, posy, posx2, posy2, posx3, posy3, posx4, posy4);

				// points only
				//fill(255, 0, 0);
				//ellipse(posx, posy, 2, 2);
			}
		}
	}
	
	// display z buffer
	//image(depthbuffer, 0, 0);

	frame += 1;
}"
"818016","REYES² / volumetric rendering","mySketch","let texture = null;
function preload() {
    texture = loadImage('texture_512.png');
}

/**
  * A tentative to do a 3D renderer using REYES like algorithms (a type of rendering invented / developed by Lucasfilm / Pixar in the mid-80s and still used to late 2000s)
	* Actually REYES is more like a collection of classical computer graphics algorithms packed into a single solution with a well defined pipeline process.
	*
	* Actually it is more like a standard rasterizer than REYES... :)
	*
	* REYES algorithm is simple and powerful, it is between rasterization and state of art algorithms like raytracing / pathtracing
	* in term of power and it have some speed advantages over that last one but it is most importantly very flexible and parallelization friendly.
	* 
	* So how does it work ? It is pretty similar to a standard rasterizer and work mainly with polygons but... with a process of massive surfaces subdivision (preferably adaptive)
	* which produce ""micropolygons"", polygons that are the size of a pixel or so and which allow easy / fast shading computations, there is also some important optimization steps.
	*
	* ""All objects are reduced to common world-space geometric entities called micropolygons, and all of the shading and visibility calculations operate on these micropolygons.
	*  Each type of calculation is performed in a coordinate system that is natural for that type of calculation.
	*  Micropolygons are created and textured in the local coordinate system of the object, with the result that texture filtering is simplified and improved.
	*  Visibility is calculated in screen space using stochastic point sampling with a z buffer.
	*  There are no clipping or perspective calculations. Geometric and texture locality are exploited to minimize paging and to support models that contain arbitrarily many primitives.""
  *
	* Surfaces may be defined through NURBS for example but i chose a parametric object for this demonstration.
	*
	* https://en.wikipedia.org/wiki/Reyes_rendering
	* 
	* How it was made :
	*  - first we want to define a geometric object (a cube) programmatically, i chose to do it as a parametric surface by simply stepping
	*    in normalized space through points for X,Y,Z then converting to screen space and centering the object. Doing it by stepping on the surface
	*    allow us to control as wanted the stepping factor (which will be our subdivision factor for our polygons)
	*  - since we also stepped through Z we are already rendering a kind of volumetric cube data (which is cool because you could even do volumetric effects later on !)
	*  - since we are only interested by the cube surface, we filter the volumetric data and retain the points on the surface
	*  - we do projection + rotation of our object at the same time with simple matrix / vector operation
	*  - once we have the object points rendered we can do a simple shading that will give us some depth by computing
  *    the length then normalizing the point position vector and assigning the Z value scaled by the max. RGB value to the point color
	*  - at this point we have several ways to render our object :
	*   - by simply rendering the dots
	*   - by detecting the surfaces of the cube we are on (by looking to points position), computing next value for X/Y or X/Z or Y/Z
	*     using those values to draw lines to form two triangles (a quad), this is wireframe mode, we can also compute points value in different order for different wireframe mode
	*   - same step as above but then fill the triangles with barycentric algorithm (find bounding box of triangle, step through X/Y and check wether we are in or out)
	*     we will have flat shading at low resolution but... it also pave the road to the easy application of more complex shading algorithms or texturing!! an important step is also to
	*     check shaded point distance against a Z buffer to remove hidden surfaces
	*
	* Note : When filling polygon we give a step of more than 1 and increase the size of the ""rect"" primitive, this allow fast rendering at the price of huge quality lost
	*        but if you are doing it non-realtime you would increase subdivision to the point of each triangles being 1px, the flat shading would suddenly be smooth shading! :)
	*
	* How can this be improved ?
	*  - add texturing
	*  - fill quads instead of triangles
	*  - add more parametric surfaces and especially more generic surfaces
	*  - add shading algorithms (phong etc.)
	*  - play with volumetric data :)
	*  - adaptative subdivision ?
	*  - parallelization
	*  - cleanup of the sides checking
	*  - non-realtime render to obtain high quality images (when subdivision is low)
	*/

let frame = 0;

let cs = 580; // also scale :P
let inc = 0.5; // control surface subdivision, lower = higher quality (but too slow for realtime)
let csi = 1.0 / inc; // how much points our surface will have along a specific axis
let scale = 1.0 / 8.0; // cube scale

let depthbuffer;

function setup() {
  createCanvas(1024, 768);

  background(0);
	
	noStroke();
	
	depthbuffer = createGraphics(width, height);
	depthbuffer.noStroke();
}

function fillTriangle(x1, y1, x2, y2, x3, y3, shading) {
	let maxX = max(x1, max(x2, x3));
	let minX = min(x1, min(x2, x3));
	let maxY = max(y1, max(y2, y3));
	let minY = min(y1, min(y2, y3));
	
	let vs1x = x2 - x1;
	let vs1y = y2 - y1;
	let vs2x = x3 - x1;
	let vs2y = y3 - y1;

	for (let x = minX; x <= maxX; x += 4) {
  	for (let y = minY; y <= maxY; y += 4) {
			let qx = x - x1;
			let qy = y - y1;
			
			let s = (qx * vs2y - vs2x * qy) / (vs1x * vs2y - vs2x * vs1y);
			let t = (vs1x * qy - qx * vs1y) / (vs1x * vs2y - vs2x * vs1y);

			if ( (s >= 0) && (t >= 0) && (s + t <= 1)) {
				// check against Z buffer!
				if (shading >= depthbuffer.get(x, y)[0]) {
					// depth value go into depth buffer
					//depthbuffer.beginDraw();
					depthbuffer.fill(shading, shading, shading);
					depthbuffer.rect(x, y, 4, 4);
					//depthbuffer.endDraw();
					
					rect(x, y, 4, 4);
				}
			}
		}
	}
}

function draw() {
	// clear z-buffer
	//depthbuffer.beginDraw();
	depthbuffer.background(0);
	//depthbuffer.endDraw();
	
  background(0);
	//fill(0, 0, 0, 48);
	//rect(0, 0, width, height);
	
	let rxa = 0.03 * frame;
	let rya = 0.04 * frame;

	// rotation values
	let crx = cos(rxa);
	let cry = cos(rya);
	let srx = sin(rxa);
	let sry = sin(rya);
	
	// rm = rotation matrix
	let rm = [0,0,0,0,0,0,0,0,0];

	rm[0] = cry;     /*rm[1] = 0.0f;*/ rm[2] = -sry;
	rm[3] = sry * srx; rm[4] = crx;    rm[5] = cry * srx;
	rm[6] = sry * crx; rm[7] = -srx;   rm[8] = cry * crx;
	
	let x2 = width / 2;
	let y2 = height / 2;
	
	// step cube volume along X,Y,Z in normalized space
	let x, y, z;
	for (z = 0.0; z <= 1.0; z += inc) {
		let vr = [0,0,0];

		let pz = 2.0 * z - 1.0; // normalize screen space

		vr[2] = pz * scale;
		for (y = 0.0; y <= 1.0; y += inc) {
			let py = 2.0 * y - 1.0;

			vr[1] = py * scale;
			for (x = 0.0; x <= 1.0; x += inc) {
				// filter volumetric data (eg. we only want the points on the surface)
				if (x > 0.0 && x < (1.0 - inc) && y > 0.0 && y < (1.0 - inc) && z > 0.0 && z < (1.0 - inc)) continue;
				
				let px = (2.0 * x - 1.0);
				
				vr[0] = px * scale;

				// rotate/transform our points
				let vrr = [
						rm[0] * vr[0] + rm[3] * vr[1] + rm[6] * vr[2],
						rm[1] * vr[0] + rm[4] * vr[1] + rm[7] * vr[2],
						rm[2] * vr[0] + rm[5] * vr[1] + rm[8] * vr[2]
				];
			
				// compute length & normalize
				let le = sqrt((vrr[0] * vrr[0]) + (vrr[1] * vrr[1]) + (vrr[2] * vrr[2]));
			  let vrn = [ vrr[0] / le, vrr[1] / le, vrr[2] / le ];

				// point shade based on normalized Z value
			  let shading = vrn[2] * 255;
				//fill(shading, shading, shading);

				// since we were in normalized space we scale it to screen space and translate it at the center of the screen
				let posx = x2 - (int)(vrr[0] * cs);
				let posy = y2 - (int)(vrr[1] * cs);
		
				// draw cube surface
				let px2 = (2.0 * (x + inc) - 1.0);
				let pxs = px2 * scale;
				let py2 = (2.0 * (y + inc) - 1.0);
				let pys = py2 * scale;
				let pz2 = (2.0 * (z + inc) - 1.0);
				let pzs = pz2 * scale;
		
				let posx2; let posy2;
				let posx3; let posy3;
				let posx4; let posy4;
				
				// cube side detection & polygons drawing
				// note : could be optimized into much shorted code...
				/*
				if (y >= 0.0 && y <= (1.0 - inc) &&
						z >= 0.0 && z <= (1.0 - inc) &&
					  (x >= 0.99 || x <= 0.0)) {
					let vrr2 = [
							rm[0] * vr[0] + rm[3] * vr[1] + rm[6] * pzs,
							rm[1] * vr[0] + rm[4] * vr[1] + rm[7] * pzs,
							rm[2] * vr[0] + rm[5] * vr[1] + rm[8] * pzs
					];
		
					let vrr3 = [
							rm[0] * vr[0] + rm[3] * pys + rm[6] * pzs,
							rm[1] * vr[0] + rm[4] * pys + rm[7] * pzs,
							rm[2] * vr[0] + rm[5] * pys + rm[8] * pzs
					];
	
					let vrr4 = [
							rm[0] * vr[0] + rm[3] * pys + rm[6] * vr[2],
							rm[1] * vr[0] + rm[4] * pys + rm[7] * vr[2],
							rm[2] * vr[0] + rm[5] * pys + rm[8] * vr[2]
					];
		
					posx2 = x2 - round(vrr2[0] * cs);
					posy2 = y2 - round(vrr2[1] * cs);
					posx3 = x2 - round(vrr3[0] * cs);
					posy3 = y2 - round(vrr3[1] * cs);
					posx4 = x2 - round(vrr4[0] * cs);
					posy4 = y2 - round(vrr4[1] * cs);

					// wireframe
					//stroke(shading, shading, shading);
					//line(posx, posy, posx2, posy2);
					//line(posx2, posy2, posx3, posy3);
					//line(posx3, posy3, posx, posy);

					//stroke(shading, 0, 0);
					//line(posx, posy, posx4, posy4);
					//line(posx4, posy4, posx3, posy3);
					//line(posx3, posy3, posx, posy);
					
					noStroke();
					fill(shading, shading, shading);
					fillTriangle(posx, posy, posx2, posy2, posx3, posy3, shading);
					fillTriangle(posx, posy, posx4, posy4, posx3, posy3, shading);
					noFill();
				}
				*/
				if (x >= 0.0 && x <= (1.0 - inc) &&
									 y >= 0.0 && y <= (1.0 - inc) &&
									 (z >= 0.99 /*|| z <= 0.0*/)) {
					let vrr2 = [
							rm[0] * pxs + rm[3] * vr[1] + rm[6] * vr[2],
							rm[1] * pxs + rm[4] * vr[1] + rm[7] * vr[2],
							rm[2] * pxs + rm[5] * vr[1] + rm[8] * vr[2]
					];
		
					let vrr3 = [
							rm[0] * pxs + rm[3] * pys + rm[6] * vr[2],
							rm[1] * pxs + rm[4] * pys + rm[7] * vr[2],
							rm[2] * pxs + rm[5] * pys + rm[8] * vr[2]
					];
	
					let vrr4 = [
							rm[0] * vr[0] + rm[3] * pys + rm[6] * vr[2],
							rm[1] * vr[0] + rm[4] * pys + rm[7] * vr[2],
							rm[2] * vr[0] + rm[5] * pys + rm[8] * vr[2]
					];
		
					posx2 = x2 - round(vrr2[0] * cs);
					posy2 = y2 - round(vrr2[1] * cs);
					posx3 = x2 - round(vrr3[0] * cs);
					posy3 = y2 - round(vrr3[1] * cs);
					posx4 = x2 - round(vrr4[0] * cs);
					posy4 = y2 - round(vrr4[1] * cs);
/*
					// wireframe
					stroke(shading, shading, shading);
					line(posx, posy, posx2, posy2);
					line(posx2, posy2, posx3, posy3);
					line(posx3, posy3, posx, posy);

					stroke(shading, 0, 0);
					line(posx, posy, posx4, posy4);
					line(posx4, posy4, posx3, posy3);
					line(posx3, posy3, posx, posy);
*/
					noStroke();
					fill(shading, shading, shading);
					fillTriangle(posx, posy, posx2, posy2, posx3, posy3, shading);
					fillTriangle(posx, posy, posx4, posy4, posx3, posy3, shading);
					noFill();
				}
				/*
				if (x >= 0.0 && x <= (1.0 - inc) &&
									 z >= 0.0 && z <= (1.0 - inc) &&
									 (y >= 0.99 || y <= 0.0)) {
					let vrr2 = [
							rm[0] * pxs + rm[3] * vr[1] + rm[6] * vr[2],
							rm[1] * pxs + rm[4] * vr[1] + rm[7] * vr[2],
							rm[2] * pxs + rm[5] * vr[1] + rm[8] * vr[2]
					];
		
					let vrr3 = [
							rm[0] * pxs + rm[3] * vr[1] + rm[6] * pzs,
							rm[1] * pxs + rm[4] * vr[1] + rm[7] * pzs,
							rm[2] * pxs + rm[5] * vr[1] + rm[8] * pzs
					];
	
					let vrr4 = [
							rm[0] * vr[0] + rm[3] * vr[1] + rm[6] * pzs,
							rm[1] * vr[0] + rm[4] * vr[1] + rm[7] * pzs,
							rm[2] * vr[0] + rm[5] * vr[1] + rm[8] * pzs
					];
		
					posx2 = x2 - round(vrr2[0] * cs);
					posy2 = y2 - round(vrr2[1] * cs);
					posx3 = x2 - round(vrr3[0] * cs);
					posy3 = y2 - round(vrr3[1] * cs);
					posx4 = x2 - round(vrr4[0] * cs);
					posy4 = y2 - round(vrr4[1] * cs);

					// wireframe
					//stroke(shading, shading, shading);
					//line(posx, posy, posx2, posy2);
					//line(posx2, posy2, posx3, posy3);
					//line(posx3, posy3, posx, posy);

					//stroke(shading, 0, 0);
					//line(posx, posy, posx4, posy4);
					//line(posx4, posy4, posx3, posy3);
					//line(posx3, posy3, posx, posy);

					noStroke();
					fill(shading, shading, shading);
					fillTriangle(posx, posy, posx2, posy2, posx3, posy3, shading);
					fillTriangle(posx, posy, posx4, posy4, posx3, posy3, shading);
					noFill();
				}
				*/
				// no z-buffer, optimized filling
				//quad(posx, posy, posx2, posy2, posx3, posy3, posx4, posy4);

				// points only
				//fill(255, 0, 0);
				//ellipse(posx, posy, 2, 2);
			}
		}
	}
	
	// display z buffer
	//image(depthbuffer, 0, 0);

	frame += 1;
}"
"818016","REYES² / volumetric rendering","mySketch","let texture = null;
function preload() {
    texture = loadImage('texture_512.png');
}

/**
  * A tentative to do a 3D renderer using REYES like algorithms (a type of rendering invented / developed by Lucasfilm / Pixar in the mid-80s and still used to late 2000s)
	* Actually REYES is more like a collection of classical computer graphics algorithms packed into a single solution with a well defined pipeline process.
	*
	* Actually it is more like a standard rasterizer than REYES... :)
	*
	* REYES algorithm is simple and powerful, it is between rasterization and state of art algorithms like raytracing / pathtracing
	* in term of power and it have some speed advantages over that last one but it is most importantly very flexible and parallelization friendly.
	* 
	* So how does it work ? It is pretty similar to a standard rasterizer and work mainly with polygons but... with a process of massive surfaces subdivision (preferably adaptive)
	* which produce ""micropolygons"", polygons that are the size of a pixel or so and which allow easy / fast shading computations, there is also some important optimization steps.
	*
	* ""All objects are reduced to common world-space geometric entities called micropolygons, and all of the shading and visibility calculations operate on these micropolygons.
	*  Each type of calculation is performed in a coordinate system that is natural for that type of calculation.
	*  Micropolygons are created and textured in the local coordinate system of the object, with the result that texture filtering is simplified and improved.
	*  Visibility is calculated in screen space using stochastic point sampling with a z buffer.
	*  There are no clipping or perspective calculations. Geometric and texture locality are exploited to minimize paging and to support models that contain arbitrarily many primitives.""
  *
	* Surfaces may be defined through NURBS for example but i chose a parametric object for this demonstration.
	*
	* https://en.wikipedia.org/wiki/Reyes_rendering
	* 
	* How it was made :
	*  - first we want to define a geometric object (a cube) programmatically, i chose to do it as a parametric surface by simply stepping
	*    in normalized space through points for X,Y,Z then converting to screen space and centering the object. Doing it by stepping on the surface
	*    allow us to control as wanted the stepping factor (which will be our subdivision factor for our polygons)
	*  - since we also stepped through Z we are already rendering a kind of volumetric cube data (which is cool because you could even do volumetric effects later on !)
	*  - since we are only interested by the cube surface, we filter the volumetric data and retain the points on the surface
	*  - we do projection + rotation of our object at the same time with simple matrix / vector operation
	*  - once we have the object points rendered we can do a simple shading that will give us some depth by computing
  *    the length then normalizing the point position vector and assigning the Z value scaled by the max. RGB value to the point color
	*  - at this point we have several ways to render our object :
	*   - by simply rendering the dots
	*   - by detecting the surfaces of the cube we are on (by looking to points position), computing next value for X/Y or X/Z or Y/Z
	*     using those values to draw lines to form two triangles (a quad), this is wireframe mode, we can also compute points value in different order for different wireframe mode
	*   - same step as above but then fill the triangles with barycentric algorithm (find bounding box of triangle, step through X/Y and check wether we are in or out)
	*     we will have flat shading at low resolution but... it also pave the road to the easy application of more complex shading algorithms or texturing!! an important step is also to
	*     check shaded point distance against a Z buffer to remove hidden surfaces
	*
	* Note : When filling polygon we give a step of more than 1 and increase the size of the ""rect"" primitive, this allow fast rendering at the price of huge quality lost
	*        but if you are doing it non-realtime you would increase subdivision to the point of each triangles being 1px, the flat shading would suddenly be smooth shading! :)
	*
	* How can this be improved ?
	*  - add texturing
	*  - fill quads instead of triangles
	*  - add more parametric surfaces and especially more generic surfaces
	*  - add shading algorithms (phong etc.)
	*  - play with volumetric data :)
	*  - adaptative subdivision ?
	*  - parallelization
	*  - cleanup of the sides checking
	*  - non-realtime render to obtain high quality images (when subdivision is low)
	*/

let frame = 0;

let cs = 580; // also scale :P
let inc = 0.5; // control surface subdivision, lower = higher quality (but too slow for realtime)
let csi = 1.0 / inc; // how much points our surface will have along a specific axis
let scale = 1.0 / 8.0; // cube scale

let depthbuffer;

function setup() {
  createCanvas(1024, 768);

  background(0);
	
	noStroke();
	
	depthbuffer = createGraphics(width, height);
	depthbuffer.noStroke();
}

function fillTriangle(x1, y1, x2, y2, x3, y3, shading) {
	let maxX = max(x1, max(x2, x3));
	let minX = min(x1, min(x2, x3));
	let maxY = max(y1, max(y2, y3));
	let minY = min(y1, min(y2, y3));
	
	let vs1x = x2 - x1;
	let vs1y = y2 - y1;
	let vs2x = x3 - x1;
	let vs2y = y3 - y1;

	for (let x = minX; x <= maxX; x += 4) {
  	for (let y = minY; y <= maxY; y += 4) {
			let qx = x - x1;
			let qy = y - y1;
			
			let s = (qx * vs2y - vs2x * qy) / (vs1x * vs2y - vs2x * vs1y);
			let t = (vs1x * qy - qx * vs1y) / (vs1x * vs2y - vs2x * vs1y);

			if ( (s >= 0) && (t >= 0) && (s + t <= 1)) {
				// check against Z buffer!
				if (shading >= depthbuffer.get(x, y)[0]) {
					// depth value go into depth buffer
					//depthbuffer.beginDraw();
					depthbuffer.fill(shading, shading, shading);
					depthbuffer.rect(x, y, 4, 4);
					//depthbuffer.endDraw();
					
					rect(x, y, 4, 4);
				}
			}
		}
	}
}

function draw() {
	texture.loadPixels();
	
	// clear z-buffer
	//depthbuffer.beginDraw();
	depthbuffer.background(0);
	//depthbuffer.endDraw();
	
  background(0);
	//fill(0, 0, 0, 48);
	//rect(0, 0, width, height);
	
	let rxa = 0.03 * frame;
	let rya = 0.04 * frame;

	// rotation values
	let crx = cos(rxa);
	let cry = cos(rya);
	let srx = sin(rxa);
	let sry = sin(rya);
	
	// rm = rotation matrix
	let rm = [0,0,0,0,0,0,0,0,0];

	rm[0] = cry;     /*rm[1] = 0.0f;*/ rm[2] = -sry;
	rm[3] = sry * srx; rm[4] = crx;    rm[5] = cry * srx;
	rm[6] = sry * crx; rm[7] = -srx;   rm[8] = cry * crx;
	
	let x2 = width / 2;
	let y2 = height / 2;
	
	// step cube volume along X,Y,Z in normalized space
	let x, y, z;
	for (z = 0.0; z <= 1.0; z += inc) {
		let vr = [0,0,0];

		let pz = 2.0 * z - 1.0; // normalize screen space

		vr[2] = pz * scale;
		for (y = 0.0; y <= 1.0; y += inc) {
			let py = 2.0 * y - 1.0;

			vr[1] = py * scale;
			for (x = 0.0; x <= 1.0; x += inc) {
				// filter volumetric data (eg. we only want the points on the surface)
				if (x > 0.0 && x < (1.0 - inc) && y > 0.0 && y < (1.0 - inc) && z > 0.0 && z < (1.0 - inc)) continue;
				
				let px = (2.0 * x - 1.0);
				
				vr[0] = px * scale;

				// rotate/transform our points
				let vrr = [
						rm[0] * vr[0] + rm[3] * vr[1] + rm[6] * vr[2],
						rm[1] * vr[0] + rm[4] * vr[1] + rm[7] * vr[2],
						rm[2] * vr[0] + rm[5] * vr[1] + rm[8] * vr[2]
				];
			
				// compute length & normalize
				let le = sqrt((vrr[0] * vrr[0]) + (vrr[1] * vrr[1]) + (vrr[2] * vrr[2]));
			  let vrn = [ vrr[0] / le, vrr[1] / le, vrr[2] / le ];

				// point shade based on normalized Z value
			  let shading = vrn[2] * texture.pixels[(round(x * texture.width) + round(y * texture.height) * texture.width) * 4];
				
				
				//fill(shading, shading, shading);

				// since we were in normalized space we scale it to screen space and translate it at the center of the screen
				let posx = x2 - (int)(vrr[0] * cs);
				let posy = y2 - (int)(vrr[1] * cs);
		
				// draw cube surface
				let px2 = (2.0 * (x + inc) - 1.0);
				let pxs = px2 * scale;
				let py2 = (2.0 * (y + inc) - 1.0);
				let pys = py2 * scale;
				let pz2 = (2.0 * (z + inc) - 1.0);
				let pzs = pz2 * scale;
		
				let posx2; let posy2;
				let posx3; let posy3;
				let posx4; let posy4;
				
				// cube side detection & polygons drawing
				// note : could be optimized into much shorted code...
				/*
				if (y >= 0.0 && y <= (1.0 - inc) &&
						z >= 0.0 && z <= (1.0 - inc) &&
					  (x >= 0.99 || x <= 0.0)) {
					let vrr2 = [
							rm[0] * vr[0] + rm[3] * vr[1] + rm[6] * pzs,
							rm[1] * vr[0] + rm[4] * vr[1] + rm[7] * pzs,
							rm[2] * vr[0] + rm[5] * vr[1] + rm[8] * pzs
					];
		
					let vrr3 = [
							rm[0] * vr[0] + rm[3] * pys + rm[6] * pzs,
							rm[1] * vr[0] + rm[4] * pys + rm[7] * pzs,
							rm[2] * vr[0] + rm[5] * pys + rm[8] * pzs
					];
	
					let vrr4 = [
							rm[0] * vr[0] + rm[3] * pys + rm[6] * vr[2],
							rm[1] * vr[0] + rm[4] * pys + rm[7] * vr[2],
							rm[2] * vr[0] + rm[5] * pys + rm[8] * vr[2]
					];
		
					posx2 = x2 - round(vrr2[0] * cs);
					posy2 = y2 - round(vrr2[1] * cs);
					posx3 = x2 - round(vrr3[0] * cs);
					posy3 = y2 - round(vrr3[1] * cs);
					posx4 = x2 - round(vrr4[0] * cs);
					posy4 = y2 - round(vrr4[1] * cs);

					// wireframe
					//stroke(shading, shading, shading);
					//line(posx, posy, posx2, posy2);
					//line(posx2, posy2, posx3, posy3);
					//line(posx3, posy3, posx, posy);

					//stroke(shading, 0, 0);
					//line(posx, posy, posx4, posy4);
					//line(posx4, posy4, posx3, posy3);
					//line(posx3, posy3, posx, posy);
					
					noStroke();
					fill(shading, shading, shading);
					fillTriangle(posx, posy, posx2, posy2, posx3, posy3, shading);
					fillTriangle(posx, posy, posx4, posy4, posx3, posy3, shading);
					noFill();
				}
				*/
				if (x >= 0.0 && x <= (1.0 - inc) &&
									 y >= 0.0 && y <= (1.0 - inc) &&
									 (z >= 0.99 /*|| z <= 0.0*/)) {
					let vrr2 = [
							rm[0] * pxs + rm[3] * vr[1] + rm[6] * vr[2],
							rm[1] * pxs + rm[4] * vr[1] + rm[7] * vr[2],
							rm[2] * pxs + rm[5] * vr[1] + rm[8] * vr[2]
					];
		
					let vrr3 = [
							rm[0] * pxs + rm[3] * pys + rm[6] * vr[2],
							rm[1] * pxs + rm[4] * pys + rm[7] * vr[2],
							rm[2] * pxs + rm[5] * pys + rm[8] * vr[2]
					];
	
					let vrr4 = [
							rm[0] * vr[0] + rm[3] * pys + rm[6] * vr[2],
							rm[1] * vr[0] + rm[4] * pys + rm[7] * vr[2],
							rm[2] * vr[0] + rm[5] * pys + rm[8] * vr[2]
					];
		
					posx2 = x2 - round(vrr2[0] * cs);
					posy2 = y2 - round(vrr2[1] * cs);
					posx3 = x2 - round(vrr3[0] * cs);
					posy3 = y2 - round(vrr3[1] * cs);
					posx4 = x2 - round(vrr4[0] * cs);
					posy4 = y2 - round(vrr4[1] * cs);
/*
					// wireframe
					stroke(shading, shading, shading);
					line(posx, posy, posx2, posy2);
					line(posx2, posy2, posx3, posy3);
					line(posx3, posy3, posx, posy);

					stroke(shading, 0, 0);
					line(posx, posy, posx4, posy4);
					line(posx4, posy4, posx3, posy3);
					line(posx3, posy3, posx, posy);
*/

					noStroke();
					fill(shading, shading, shading);
					fillTriangle(posx, posy, posx2, posy2, posx3, posy3, shading);
					fillTriangle(posx, posy, posx4, posy4, posx3, posy3, shading);
					noFill();
				}
				/*
				if (x >= 0.0 && x <= (1.0 - inc) &&
									 z >= 0.0 && z <= (1.0 - inc) &&
									 (y >= 0.99 || y <= 0.0)) {
					let vrr2 = [
							rm[0] * pxs + rm[3] * vr[1] + rm[6] * vr[2],
							rm[1] * pxs + rm[4] * vr[1] + rm[7] * vr[2],
							rm[2] * pxs + rm[5] * vr[1] + rm[8] * vr[2]
					];
		
					let vrr3 = [
							rm[0] * pxs + rm[3] * vr[1] + rm[6] * pzs,
							rm[1] * pxs + rm[4] * vr[1] + rm[7] * pzs,
							rm[2] * pxs + rm[5] * vr[1] + rm[8] * pzs
					];
	
					let vrr4 = [
							rm[0] * vr[0] + rm[3] * vr[1] + rm[6] * pzs,
							rm[1] * vr[0] + rm[4] * vr[1] + rm[7] * pzs,
							rm[2] * vr[0] + rm[5] * vr[1] + rm[8] * pzs
					];
		
					posx2 = x2 - round(vrr2[0] * cs);
					posy2 = y2 - round(vrr2[1] * cs);
					posx3 = x2 - round(vrr3[0] * cs);
					posy3 = y2 - round(vrr3[1] * cs);
					posx4 = x2 - round(vrr4[0] * cs);
					posy4 = y2 - round(vrr4[1] * cs);

					// wireframe
					//stroke(shading, shading, shading);
					//line(posx, posy, posx2, posy2);
					//line(posx2, posy2, posx3, posy3);
					//line(posx3, posy3, posx, posy);

					//stroke(shading, 0, 0);
					//line(posx, posy, posx4, posy4);
					//line(posx4, posy4, posx3, posy3);
					//line(posx3, posy3, posx, posy);

					noStroke();
					fill(shading, shading, shading);
					fillTriangle(posx, posy, posx2, posy2, posx3, posy3, shading);
					fillTriangle(posx, posy, posx4, posy4, posx3, posy3, shading);
					noFill();
				}
				*/
				// no z-buffer, optimized filling
				//quad(posx, posy, posx2, posy2, posx3, posy3, posx4, posy4);

				// points only
				//fill(255, 0, 0);
				//ellipse(posx, posy, 2, 2);
			}
		}
	}
	
	// display z buffer
	//image(depthbuffer, 0, 0);

	frame += 1;
}"
"818016","REYES² / volumetric rendering","mySketch","/**
	* A tentative to do a 3D renderer using REYES like algorithms (a type of rendering invented / developed by Lucasfilm / Pixar in the mid-80s and still used to late 2000s)
	* Actually REYES is more like a collection of classical computer graphics algorithms packed leto a single solution with a well defined pipeline process.
	*
  * This use a similar algorithm as my REYES sketch but this time experimenting with the volumetric nature of the approach, it is much simpler as well...
	* ...in the first sketch the cube surfaces were computed and polygon filled / checked against a z-buffer at each frames, the final step was more akin to a standard rasterizer.
	*
	* I don't know what to call this anymore, point-based rendering ? voxel rendering ? REYES (without dicing / splitting) ?
	*
  * Anyway this use a point-based approach with floating point z-buffer :
	*   - the cube geometry is still defined as before using a volumetric / parametric approach (by stepping through x,y,z; parametric space is thus uniformly subdivided)
	*   - rendering is done progressively through multiple frames
	*   - use a point-based rendering approach; for quality rendering chose a low step value so that all surface is filled; arbitrary step value may be used for artistic effects like here where i am using stroke and a bigger point to amplify depth / ambient lighting / puzzle like
	*   - texturing; this rendering approach allow ultra simple and high quality texturing (just use 1px points / low step / no outline)
	*
	* note : in a REYES pipeline the step value may be chosen optimally instead of using a fixed value
	*/

let frame = 0;

let step = 0.003; // control surface stepping, lower = higher quality (but too slow for realtime)
let scale = 0.3; // cube scale

let beach;

let depthbuffer = [];

function preload() {
    beach = loadImage('beach.png');
}

function setup() {
	createCanvas(windowWidth, windowHeight);

	background(0);

	noStroke();

	beach.loadPixels();
	
	noiseDetail(7, 0.7);

	// initialize depth buffer
	for (let i = 0.0; i <= width; i += 1) {
		for (let j = 0.0; j <= height; j += 1) {
			depthbuffer[i + j * width] = -Infinity;
		}
	}
}

function draw() {
	// progressive rendering
	for (let i = 0.0; i <= 100000; i += 1) {
		draw3d();
	}
}

let x = 0, y = 0, z = 0;
let offset = 0;

function draw3d() {
	//background(0);
	//fill(0, 0, 0, 48);
	//rect(0, 0, width, height);
	
	let rxa = 0.3 + 0.03 * frame;
	let rya = 0.5 + 0.04 * frame;

	// rotation values
	let crx = cos(rxa);
	let cry = cos(rya);
	let srx = sin(rxa);
	let sry = sin(rya);
	
	// rm = rotation matrix
	let rm = [0,0,0,0,0,0,0,0,0];

	rm[0] = cry;     /*rm[1] = 0.0f;*/ rm[2] = -sry;
	rm[3] = sry * srx; rm[4] = crx;    rm[5] = cry * srx;
	rm[6] = sry * crx; rm[7] = -srx;   rm[8] = cry * crx;
	
	let x2 = width / 2;
	let y2 = height / 2;
	
	// step cube volume along X,Y,Z in normalized space
	//let offset = frameCount / 512;
	
	// we can also do stochastic rendering
	//x = random();
	//y = random();
	//z = random();
	
	// progessive rendering part (offset is unused; this was to speedup rendering)
	x += step + offset;
	if (x >= 1.0) {
		x = 0;
		y += step;
		if (y >= 1.0) {
			x = 0;
			y = 0;
			z += step;
		}
	}

	// idle once rendered
	if (z >= 1) {
		return;
	}
	//
	
	//for (z = 0.0; z <= 1.0; z += inc) {
		let vr = [0,0,0];

		let pz = 2.0 * z - 1.0; // normalize screen space

		vr[2] = pz * scale;
		//for (y = 0.0; y <= 1.0; y += inc) {
			let py = 2.0 * y - 1.0;

			vr[1] = py * scale;
			//for (x = 0.0; x <= 1.0; x += inc) {
				// volumetric data filter (eg. we only want the surface)
				if (x > 0.0 && x < (1.0 - step) && y > 0.0 && y < (1.0 - step) && z > 0.0 && z < (1.0 - step)) return;
				// fun filter to carve holes on the surface
				if (noise(x, y, z) > 0.9) return;
				
				let px = (2.0 * x - 1.0);
				vr[0] = px * scale;

				// rotate/transform our points
				let vrr = [
						rm[0] * vr[0] + rm[3] * vr[1] + rm[6] * vr[2],
						rm[1] * vr[0] + rm[4] * vr[1] + rm[7] * vr[2],
						rm[2] * vr[0] + rm[5] * vr[1] + rm[8] * vr[2]
                ];
	
				// doing good texturing is simple with this rendering method...
				let u = x;
				let v = 1 - y;
				let texture_index = (parseInt(u * (beach.width - 1), 10) + parseInt(v * (beach.height - 1), 10) * beach.width) * 4;
				let texture_red = beach.pixels[texture_index];
				let texture_green = beach.pixels[texture_index + 1];
				let texture_blue = beach.pixels[texture_index + 2];
			
				// compute length & normalize
				let le = sqrt((vrr[0] * vrr[0]) + (vrr[1] * vrr[1]) + (vrr[2] * vrr[2]));
			  let vrn = [ vrr[0] / le, vrr[1] / le, vrr[2] / le ];
	
				// since we were in normalized space we scale it to screen space and translate it at the center of the screen
				let posx = x2 - round(vrr[0] * height);
				let posy = y2 - round(vrr[1] * height);
	
				let depth = vrn[2];
	
				// z-buffer (do nothing if farther; replace if nearest)
				let zbuffer_index = posx + posy * width;
				let zb_depth = depthbuffer[zbuffer_index];
				if (zb_depth > depth) {
					return;
				}
	
				depthbuffer[zbuffer_index] = depth;
	
				// compute normal from depth buffer using derivatives
/*
				let dzdx = (depthbuffer[zbuffer_index + 1] - depthbuffer[zbuffer_index - 1]) / 2.0;
				let dzdy = (depthbuffer[zbuffer_index + width] - depthbuffer[zbuffer_index - width]) / 2.0;
	
				let normal = createVector(-dzdx, -dzdy, 1.0);
				normal.normalize();
*/
	
				// point shade based on normalized Z value
				let brightness_fix = 2 - max(max(texture_red, texture_green), texture_blue) / 255;
				depth *= brightness_fix; //  * noise(x, y, z) // for fun

				fill(100*depth+155, 100*depth+155, 100*depth+155);
				stroke(texture_red * depth, texture_green * depth, texture_blue * depth);
				
				//point(posx, posy);
				rect(posx, posy, 2, 2);
			//}
		//}
	//}
}"
"817839","Heightmap","mySketch","/**
	* Same method as REYES² / volumetric rendering, the cube is replaced by a plane with a heightmap
	* for fast rendering 2px rect is used, height is also not iterated, quality is view / step dependent
	* 
	* unicode icons are fun :)
	*/

let frame = 0;

let step = 0.00075; // control surface stepping, lower = higher quality (but too slow for realtime)
let scale = 0.75; // scale

let pg;

let depthbuffer = [];

function setup() {
	createCanvas(windowWidth, windowHeight);

	background(0);

	noStroke();
	
	let wt = width;
	let ht = height;

	// heightmap
	pg = createGraphics(wt, ht);
	pg.background(0);
	pg.textSize(ht / 2.75);
	pg.textAlign(CENTER);
	pg.fill(255, 255, 255);
	//pg.stroke(0, 255, 255);
	//pg.strokeWeight(8);
	pg.text(""Processing\n☕♞⚔"", wt / 2 , ht / 2);
	pg.filter(BLUR, 2);
	pg.loadPixels();
	
	noiseDetail(6, 0.65);

	// initialize depth buffer
	for (let i = 0.0; i <= width; i += 1) {
		for (let j = 0.0; j <= height; j += 1) {
			depthbuffer[i + j * width] = -Infinity;
		}
	}
}

function draw() {
	// progressive rendering
	for (let i = 0.0; i <= 20000; i += 1) {
		draw3d();
	}
}

let x = 0, y = 0, z = 0;
let offset = 0;

function draw3d() {
	//background(0);
	//fill(0, 0, 0, 48);
	//rect(0, 0, width, height);
	
	let rxa = PI / 6 + 0.03 * frame;
	let rya = PI / 8 + 0.04 * frame;

	// rotation values
	let crx = cos(rxa);
	let cry = cos(rya);
	let srx = sin(rxa);
	let sry = sin(rya);
	
	// rm = rotation matrix
	let rm = [0,0,0,0,0,0,0,0,0];

	rm[0] = cry;     /*rm[1] = 0.0f;*/ rm[2] = -sry;
	rm[3] = sry * srx; rm[4] = crx;    rm[5] = cry * srx;
	rm[6] = sry * crx; rm[7] = -srx;   rm[8] = cry * crx;
	
	let x2 = width / 2;
	let y2 = height / 2;
	
	// step cube volume along X,Y,Z in normalized space
	//let offset = frameCount / 512;
	
	// we can also do stochastic rendering
	//x = random();
	//y = random();
	//z = random();
	
	// progessive rendering part (offset is unused; this was to speedup rendering)
	x += step + offset;
	if (x >= 1.0) {
		x = 0;
		z += step;
	}

	// idle once rendered
	if (z >= 1) {
		return;
	}
	//
	
	// doing good texturing is simple with this rendering method...
	let u = 1 - x;
	let v = z;
	let texture_index = (parseInt(u * (pg.width - 1), 10) + parseInt(v * (pg.height - 1), 10) * pg.width) * 4;
	let texture_red = pg.pixels[texture_index];
	let texture_green = pg.pixels[texture_index + 1];
	let texture_blue = pg.pixels[texture_index + 2];
	let texture_brightness = (texture_red + texture_green + texture_blue) / 3;
	
	if (texture_brightness <= 0) {
			return;
	}
	
	//for (z = 0.0; z <= 1.0; z += inc) {
		let vr = [0,0,0];

		let pz = 2.0 * z - 1.0; // normalize screen space

		vr[2] = pz * scale;
		//for (y = 0.0; y <= 1.0; y += inc) {
			let py = 2.0 * y - 1.0;
	
			let nv = noise(x, z);

			vr[1] = ((texture_brightness / 255) * 0.05 + nv * 0.15);
			//for (x = 0.0; x <= 1.0; x += inc) {
				// volumetric data filter (eg. we only want the surface)
				//if (x > 0.0 && x < (1.0 - step) && y > 0.0 && y < (1.0 - step) && z > 0.0 && z < (1.0 - step)) return;
				// fun filter to carve holes on the surface
				//if (noise(x, y, z) > 0.9) return;
				
				let px = (2.0 * x - 1.0);
				vr[0] = px * scale;

				// rotate/transform our points
				let vrr = [
						rm[0] * vr[0] + rm[3] * vr[1] + rm[6] * vr[2],
						rm[1] * vr[0] + rm[4] * vr[1] + rm[7] * vr[2],
						rm[2] * vr[0] + rm[5] * vr[1] + rm[8] * vr[2]
                ];
			
				// compute length & normalize
				let le = sqrt((vrr[0] * vrr[0]) + (vrr[1] * vrr[1]) + (vrr[2] * vrr[2]));
			  let vrn = [ vrr[0] / le, vrr[1] / le, vrr[2] / le ];
	
				// since we were in normalized space we scale it to screen space and translate it at the center of the screen
				let posx = x2 - round(vrr[0] * height);
				let posy = y2 - round(vrr[1] * height);
	/*
				// don't need a zbuffer
				let depth = vrn[2];
	
				// z-buffer (do nothing if farther; replace if nearest)
				let zbuffer_index = posx + posy * width;
				let zb_depth = depthbuffer[zbuffer_index];
				if (zb_depth > depth) {
					return;
				}
	
				depthbuffer[zbuffer_index] = depth;
	*/
				// point shade based on normalized Z value
				//let brightness_fix = 2 - max(max(texture_red, texture_green), texture_blue) / 255;
				//depth *= brightness_fix; //  * noise(x, y, z) // for fun

				//fill(abs(texture_red - nv * 255), abs(texture_green - nv * 255), abs(texture_blue - nv * 255));
				//noFill();
				fill(texture_red, texture_green, texture_blue);
				
				//point(posx, posy);
				rect(posx, posy, 2, 2);
			//}
		//}
	//}
}"
"817606","REYES² / volumetric rendering","mySketch","/**
	* A tentative to do a 3D renderer using REYES like algorithms (a type of rendering invented / developed by Lucasfilm / Pixar in the mid-80s and still used to late 2000s)
	* Actually REYES is more like a collection of classical computer graphics algorithms packed leto a single solution with a well defined pipeline process.
	*
  * This use a similar algorithm as my REYES sketch but this time more REYES i guess and much simpler...
	* ...in the first sketch the cube surfaces were computed and polygon filled / checked against a z-buffer at each frames, this final step was more akin to a standard rasterizer.
	*
  * This is simpler and use a point-based approach :
	*   - the cube geometry is still defined as before using a volumetric / parametric approach (by stepping through x,y,z; parametric space is thus uniformly subdivided)
	*   - rendering is done progressively through multiple frames (not realtime altough ""fast"" realtime could be done with temporal projection)
	*   - use a point-based rendering approach; for quality rendering we just have to chose a low step value so that all surface is filled; arbitrary step value may be used for artistic effects
	*
	* note : in a REYES pipeline the step value may be chosen optimally instead of using a fixed value
	*/

let frame = 0;

let step = 0.01; // control surface subdivision, lower = higher quality (but too slow for realtime)
let scale = 0.1; // cube scale

function setup() {
    createCanvas(windowWidth, windowHeight);

    background(0);
	
    noStroke();
}

function draw() {
	for (let i = 0.0; i <= 1000; i += 1) {
		draw3d();
	}
}

let x = 0, y = 0, z = 0;
let offset = 0;

function draw3d() {
    //background(0);
	//fill(0, 0, 0, 48);
	//rect(0, 0, width, height);
	
	let rxa = 0.5 + 0.03 * frame;
	let rya = 0.5 + 0.04 * frame;

	// rotation values
	let crx = cos(rxa);
	let cry = cos(rya);
	let srx = sin(rxa);
	let sry = sin(rya);
	
	// rm = rotation matrix
	let rm = [0,0,0,0,0,0,0,0,0];

	rm[0] = cry;     /*rm[1] = 0.0f;*/ rm[2] = -sry;
	rm[3] = sry * srx; rm[4] = crx;    rm[5] = cry * srx;
	rm[6] = sry * crx; rm[7] = -srx;   rm[8] = cry * crx;
	
	let x2 = width / 2;
	let y2 = height / 2;
	
	// step cube volume along X,Y,Z in normalized space
	//let offset = frameCount / 512;
	
	// progessive rendering part
	x += step + offset;
	if (x >= 1.0) {
		x = 0;
		y += step;
		if (y >= 1.0) {
			x = 0;
			y = 0;
			z += step;
		}
	}
	
	if (z >= 1) {
		return;
/*
		x = 0;
		y = 0;
		z = 0;
		
		offset += 0.001;
*/
	}
	//
	
	//for (z = 0.0; z <= 1.0; z += inc) {
		let vr = [0,0,0];

		let pz = 2.0 * z - 1.0; // normalize screen space

		vr[2] = pz * scale;
		//for (y = 0.0; y <= 1.0; y += inc) {
			let py = 2.0 * y - 1.0;

			vr[1] = py * scale;
			//for (x = 0.0; x <= 1.0; x += inc) {
				// filter volumetric data (eg. we only want the polets on the surface)
				//if (x > 0.0 && x < (1.0 - inc) && y > 0.0 && y < (1.0 - inc) && z > 0.0 && z < (1.0 - inc)) return;
				
				let px = (2.0 * x - 1.0);
				
				vr[0] = px * scale;

				// rotate/transform our polets
				let vrr = [
						rm[0] * vr[0] + rm[3] * vr[1] + rm[6] * vr[2],
						rm[1] * vr[0] + rm[4] * vr[1] + rm[7] * vr[2],
						rm[2] * vr[0] + rm[5] * vr[1] + rm[8] * vr[2]
                ];
			
				// compute length & normalize
				let le = sqrt((vrr[0] * vrr[0]) + (vrr[1] * vrr[1]) + (vrr[2] * vrr[2]));
			  let vrn = [ vrr[0] / le, vrr[1] / le, vrr[2] / le ];
	
				// since we were in normalized space we scale it to screen space and translate it at the center of the screen
				let posx = x2 - round(vrr[0] * height);
				let posy = y2 - round(vrr[1] * height);
	
				let depth = vrn[2] * 255;
	
				let c = get(posx, posy);
				if (c[0] > depth) {
						return;
				}
	
				// point shade based on normalized Z value
				stroke(depth, depth, depth);
				
				point(posx, posy);
			//}
		//}
	//}
}"
"817606","REYES² / volumetric rendering","mySketch","/**
	* A tentative to do a 3D renderer using REYES like algorithms (a type of rendering invented / developed by Lucasfilm / Pixar in the mid-80s and still used to late 2000s)
	* Actually REYES is more like a collection of classical computer graphics algorithms packed leto a single solution with a well defined pipeline process.
	*
  * This use a similar algorithm as my REYES sketch but this time more REYES i guess and much simpler...
	* ...in the first sketch the cube surfaces were computed and polygon filled / checked against a z-buffer at each frames, the final step was more akin to a standard rasterizer.
	*
  * This is simpler and use a point-based approach with floating point z-buffer :
	*   - the cube geometry is still defined as before using a volumetric / parametric approach (by stepping through x,y,z; parametric space is thus uniformly subdivided)
	*   - rendering is done progressively through multiple frames (not realtime altough ""fast"" realtime could be done with temporal projection)
	*   - use a point-based rendering approach; for quality rendering we just have to chose a low step value so that all surface is filled; arbitrary step value may be used for artistic effects
	*
	* note : in a REYES pipeline the step value may be chosen optimally instead of using a fixed value
	*/

let frame = 0;

let step = 0.001; // control surface subdivision, lower = higher quality (but too slow for realtime)
let scale = 0.1; // cube scale

let beach;

let depthbuffer = [];

function preload() {
  beach = loadImage('beach.png');
}

function setup() {
	createCanvas(windowWidth, windowHeight);

	background(0);

	noStroke();

	beach.loadPixels();

	// initialize depth buffer
	for (let i = 0.0; i <= width; i += 1) {
		for (let j = 0.0; j <= height; j += 1) {
			depthbuffer[i + j * width] = 0;
		}
	}
}

function draw() {
	for (let i = 0.0; i <= 50000; i += 1) {
		draw3d();
	}
}

let x = 0, y = 0, z = 0;
let offset = 0;

function draw3d() {
    //background(0);
	//fill(0, 0, 0, 48);
	//rect(0, 0, width, height);
	
	let rxa = 0.45 + 0.03 * frame;
	let rya = 0.5 + 0.04 * frame;

	// rotation values
	let crx = cos(rxa);
	let cry = cos(rya);
	let srx = sin(rxa);
	let sry = sin(rya);
	
	// rm = rotation matrix
	let rm = [0,0,0,0,0,0,0,0,0];

	rm[0] = cry;     /*rm[1] = 0.0f;*/ rm[2] = -sry;
	rm[3] = sry * srx; rm[4] = crx;    rm[5] = cry * srx;
	rm[6] = sry * crx; rm[7] = -srx;   rm[8] = cry * crx;
	
	let x2 = width / 2;
	let y2 = height / 2;
	
	// step cube volume along X,Y,Z in normalized space
	//let offset = frameCount / 512;
	
	// we can also do stochastic rendering
	//x = random();
	//y = random();
	//z = random();
	
	// progessive rendering part
	x += step + offset;
	if (x >= 1.0) {
		x = 0;
		y += step;
		if (y >= 1.0) {
			x = 0;
			y = 0;
			z += step;
		}
	}
	
	if (z >= 1) {
		return;
/*
		x = 0;
		y = 0;
		z = 0;
		
		offset += 0.01;
*/
	}
	//
	
	//for (z = 0.0; z <= 1.0; z += inc) {
		let vr = [0,0,0];

		let pz = 2.0 * z - 1.0; // normalize screen space

		vr[2] = pz * scale;
		//for (y = 0.0; y <= 1.0; y += inc) {
			let py = 2.0 * y - 1.0;

			vr[1] = py * scale;
			//for (x = 0.0; x <= 1.0; x += inc) {
				// filter volumetric data (eg. we only want the polets on the surface)
				if (x > 0.0 && x < (1.0 - step) && y > 0.0 && y < (1.0 - step) && z > 0.0 && z < (1.0 - step)) return;
				
				let px = (2.0 * x - 1.0);
				
				vr[0] = px * scale;

				// rotate/transform our points
				let vrr = [
						rm[0] * vr[0] + rm[3] * vr[1] + rm[6] * vr[2],
						rm[1] * vr[0] + rm[4] * vr[1] + rm[7] * vr[2],
						rm[2] * vr[0] + rm[5] * vr[1] + rm[8] * vr[2]
                ];
	
				// texture! with this method texture rendering is simple
				let u = x;
				let v = 1 - y;
				let texture_index = (parseInt(u * (beach.width - 1), 10) + parseInt(v * (beach.height - 1), 10) * beach.width) * 4;
				let texture_red = beach.pixels[texture_index];
				let texture_green = beach.pixels[texture_index + 1];
				let texture_blue = beach.pixels[texture_index + 2];
			
				// compute length & normalize
				let le = sqrt((vrr[0] * vrr[0]) + (vrr[1] * vrr[1]) + (vrr[2] * vrr[2]));
			  let vrn = [ vrr[0] / le, vrr[1] / le, vrr[2] / le ];
	
				// since we were in normalized space we scale it to screen space and translate it at the center of the screen
				let posx = x2 - round(vrr[0] * height);
				let posy = y2 - round(vrr[1] * height);
	
				let depth = vrn[2];
	
				// z-buffer (do nothing if farther; replace if nearest)
				let zbuffer_index = posx + posy * width;
				let zb_depth = depthbuffer[zbuffer_index] 
				if (zb_depth[0] > depth) {
						return;
				}
	
				depthbuffer[zbuffer_index] = depth;
	
				// point shade based on normalized Z value
				let brightness_fix = 2 - max(max(texture_red, texture_green), texture_blue) / 255;
				depth *= brightness_fix;
				stroke(texture_red * depth, texture_green * depth, texture_blue * depth);
				
				point(posx, posy);
			//}
		//}
	//}
}"
"817606","REYES² / volumetric rendering","mySketch","/**
	* A tentative to do a 3D renderer using REYES like algorithms (a type of rendering invented / developed by Lucasfilm / Pixar in the mid-80s and still used to late 2000s)
	* Actually REYES is more like a collection of classical computer graphics algorithms packed leto a single solution with a well defined pipeline process.
	*
  * This use a similar algorithm as my REYES sketch but this time more REYES i guess and much simpler...
	* ...in the first sketch the cube surfaces were computed and polygon filled / checked against a z-buffer at each frames, the final step was more akin to a standard rasterizer.
	*
  * This is simpler and use a point-based approach with floating point z-buffer :
	*   - the cube geometry is still defined as before using a volumetric / parametric approach (by stepping through x,y,z; parametric space is thus uniformly subdivided)
	*   - rendering is done progressively through multiple frames
	*   - use a point-based rendering approach; for quality rendering chose a low step value so that all surface is filled; arbitrary step value may be used for artistic effects
	*   - normal is computed using derivatives : http://www.aclockworkberry.com/shader-derivative-functions/
	*
	* note : in a REYES pipeline the step value may be chosen optimally instead of using a fixed value
	*/

let frame = 0;

let step = 0.01; // control surface subdivision, lower = higher quality (but too slow for realtime)
let scale = 0.1; // cube scale

let beach;

let depthbuffer = [];

function preload() {
  beach = loadImage('beach.png');
}

function setup() {
	createCanvas(windowWidth, windowHeight);

	background(0);

	noStroke();

	beach.loadPixels();

	// initialize depth buffer
	for (let i = 0.0; i <= width; i += 1) {
		for (let j = 0.0; j <= height; j += 1) {
			depthbuffer[i + j * width] = 0;
		}
	}
}

function draw() {
	for (let i = 0.0; i <= 50000; i += 1) {
		draw3d();
	}
}

let x = 0, y = 0, z = 0;
let offset = 0;

function draw3d() {
    //background(0);
	//fill(0, 0, 0, 48);
	//rect(0, 0, width, height);
	
	let rxa = 0.45 + 0.03 * frame;
	let rya = 0.5 + 0.04 * frame;

	// rotation values
	let crx = cos(rxa);
	let cry = cos(rya);
	let srx = sin(rxa);
	let sry = sin(rya);
	
	// rm = rotation matrix
	let rm = [0,0,0,0,0,0,0,0,0];

	rm[0] = cry;     /*rm[1] = 0.0f;*/ rm[2] = -sry;
	rm[3] = sry * srx; rm[4] = crx;    rm[5] = cry * srx;
	rm[6] = sry * crx; rm[7] = -srx;   rm[8] = cry * crx;
	
	let x2 = width / 2;
	let y2 = height / 2;
	
	// step cube volume along X,Y,Z in normalized space
	//let offset = frameCount / 512;
	
	// we can also do stochastic rendering
	//x = random();
	//y = random();
	//z = random();
	
	// progessive rendering part
	x += step + offset;
	if (x >= 1.0) {
		x = 0;
		y += step;
		if (y >= 1.0) {
			x = 0;
			y = 0;
			z += step;
		}
	}
	
	if (z >= 1) {
		return;
/*
		x = 0;
		y = 0;
		z = 0;
		
		offset += 0.01;
*/
	}
	//
	
	//for (z = 0.0; z <= 1.0; z += inc) {
		let vr = [0,0,0];

		let pz = 2.0 * z - 1.0; // normalize screen space

		vr[2] = pz * scale;
		//for (y = 0.0; y <= 1.0; y += inc) {
			let py = 2.0 * y - 1.0;

			vr[1] = py * scale;
			//for (x = 0.0; x <= 1.0; x += inc) {
				// filter volumetric data (eg. we only want the polets on the surface)
				if (x > 0.0 && x < (1.0 - step) && y > 0.0 && y < (1.0 - step) && z > 0.0 && z < (1.0 - step)) return;
				
				let px = (2.0 * x - 1.0);
				
				vr[0] = px * scale;

				// rotate/transform our points
				let vrr = [
						rm[0] * vr[0] + rm[3] * vr[1] + rm[6] * vr[2],
						rm[1] * vr[0] + rm[4] * vr[1] + rm[7] * vr[2],
						rm[2] * vr[0] + rm[5] * vr[1] + rm[8] * vr[2]
                ];
	
				// doing texturing is simple with this rendering method
				let u = x;
				let v = 1 - y;
				let texture_index = (parseInt(u * (beach.width - 1), 10) + parseInt(v * (beach.height - 1), 10) * beach.width) * 4;
				let texture_red = beach.pixels[texture_index];
				let texture_green = beach.pixels[texture_index + 1];
				let texture_blue = beach.pixels[texture_index + 2];
			
				// compute length & normalize
				let le = sqrt((vrr[0] * vrr[0]) + (vrr[1] * vrr[1]) + (vrr[2] * vrr[2]));
			  let vrn = [ vrr[0] / le, vrr[1] / le, vrr[2] / le ];
	
				// since we were in normalized space we scale it to screen space and translate it at the center of the screen
				let posx = x2 - round(vrr[0] * height);
				let posy = y2 - round(vrr[1] * height);
	
				let depth = vrn[2];
	
				// z-buffer (do nothing if farther; replace if nearest)
				let zbuffer_index = posx + posy * width;
				let zb_depth = depthbuffer[zbuffer_index] 
				if (zb_depth[0] > depth) {
						return;
				}
	
				depthbuffer[zbuffer_index] = depth;
	
				// compute normal from depth buffer using derivatives
				let dzdx = (depthbuffer[zbuffer_index + 1] - depthbuffer[zbuffer_index - 1]) / 2.0;
				let dzdy = (depthbuffer[zbuffer_index + width] - depthbuffer[zbuffer_index - width]) / 2.0;
	
				let normal = createVector(-dzdx, -dzdy, 1.0);
				normal.normalize();
	
				// point shade based on normalized Z value
				let brightness_fix = 2 - max(max(texture_red, texture_green), texture_blue) / 255;
				depth *= brightness_fix;
				stroke(texture_red * depth, texture_green * depth, texture_blue * depth);
				
				point(posx, posy);
			//}
		//}
	//}
}"
"817606","REYES² / volumetric rendering","mySketch","/**
	* A tentative to do a 3D renderer using REYES like algorithms (a type of rendering invented / developed by Lucasfilm / Pixar in the mid-80s and still used to late 2000s)
	* Actually REYES is more like a collection of classical computer graphics algorithms packed leto a single solution with a well defined pipeline process.
	*
  * This use a similar algorithm as my REYES sketch but this time more REYES i guess and much simpler...
	* ...in the first sketch the cube surfaces were computed and polygon filled / checked against a z-buffer at each frames, the final step was more akin to a standard rasterizer.
	*
  * This is simpler and use a point-based approach with floating point z-buffer :
	*   - the cube geometry is still defined as before using a volumetric / parametric approach (by stepping through x,y,z; parametric space is thus uniformly subdivided)
	*   - rendering is done progressively through multiple frames
	*   - use a point-based rendering approach; for quality rendering chose a low step value so that all surface is filled; arbitrary step value may be used for artistic effects
	*   - normal is computed using derivatives : http://www.aclockworkberry.com/shader-derivative-functions/
	*
	* note : in a REYES pipeline the step value may be chosen optimally instead of using a fixed value
	*/

let frame = 0;

let step = 0.01; // control surface subdivision, lower = higher quality (but too slow for realtime)
let scale = 0.1; // cube scale

let beach;

let depthbuffer = [];

function preload() {
  beach = loadImage('beach.png');
}

function setup() {
	createCanvas(windowWidth, windowHeight);

	background(0);

	noStroke();

	beach.loadPixels();

	// initialize depth buffer
	for (let i = 0.0; i <= width; i += 1) {
		for (let j = 0.0; j <= height; j += 1) {
			depthbuffer[i + j * width] = 0;
		}
	}
}

function draw() {
	for (let i = 0.0; i <= 50000; i += 1) {
		draw3d();
	}
}

let x = 0, y = 0, z = 0;
let offset = 0;

function draw3d() {
    //background(0);
	//fill(0, 0, 0, 48);
	//rect(0, 0, width, height);
	
	let rxa = 0.45 + 0.03 * frame;
	let rya = 0.5 + 0.04 * frame;

	// rotation values
	let crx = cos(rxa);
	let cry = cos(rya);
	let srx = sin(rxa);
	let sry = sin(rya);
	
	// rm = rotation matrix
	let rm = [0,0,0,0,0,0,0,0,0];

	rm[0] = cry;     /*rm[1] = 0.0f;*/ rm[2] = -sry;
	rm[3] = sry * srx; rm[4] = crx;    rm[5] = cry * srx;
	rm[6] = sry * crx; rm[7] = -srx;   rm[8] = cry * crx;
	
	let x2 = width / 2;
	let y2 = height / 2;
	
	// step cube volume along X,Y,Z in normalized space
	//let offset = frameCount / 512;
	
	// we can also do stochastic rendering
	//x = random();
	//y = random();
	//z = random();
	
	// progessive rendering part
	x += step + offset;
	if (x >= 1.0) {
		x = 0;
		y += step;
		if (y >= 1.0) {
			x = 0;
			y = 0;
			z += step;
		}
	}
	
	if (z >= 1) {
		return;
/*
		x = 0;
		y = 0;
		z = 0;
		
		offset += 0.01;
*/
	}
	//
	
	//for (z = 0.0; z <= 1.0; z += inc) {
		let vr = [0,0,0];

		let pz = 2.0 * z - 1.0; // normalize screen space

		vr[2] = pz * scale;
		//for (y = 0.0; y <= 1.0; y += inc) {
			let py = 2.0 * y - 1.0;

			vr[1] = py * scale;
			//for (x = 0.0; x <= 1.0; x += inc) {
				// filter volumetric data (eg. we only want the surface)
				if (x > 0.0 && x < (1.0 - step) && y > 0.0 && y < (1.0 - step) && z > 0.0 && z < (1.0 - step)) return;
				
				let px = (2.0 * x - 1.0);
				
				vr[0] = px * scale;

				// rotate/transform our points
				let vrr = [
						rm[0] * vr[0] + rm[3] * vr[1] + rm[6] * vr[2],
						rm[1] * vr[0] + rm[4] * vr[1] + rm[7] * vr[2],
						rm[2] * vr[0] + rm[5] * vr[1] + rm[8] * vr[2]
                ];
	
				// doing texturing is simple with this rendering method
				let u = x;
				let v = 1 - y;
				let texture_index = (parseInt(u * (beach.width - 1), 10) + parseInt(v * (beach.height - 1), 10) * beach.width) * 4;
				let texture_red = beach.pixels[texture_index];
				let texture_green = beach.pixels[texture_index + 1];
				let texture_blue = beach.pixels[texture_index + 2];
			
				// compute length & normalize
				let le = sqrt((vrr[0] * vrr[0]) + (vrr[1] * vrr[1]) + (vrr[2] * vrr[2]));
			  let vrn = [ vrr[0] / le, vrr[1] / le, vrr[2] / le ];
	
				// since we were in normalized space we scale it to screen space and translate it at the center of the screen
				let posx = x2 - round(vrr[0] * height);
				let posy = y2 - round(vrr[1] * height);
	
				let depth = vrn[2];
	
				// z-buffer (do nothing if farther; replace if nearest)
				let zbuffer_index = posx + posy * width;
				let zb_depth = depthbuffer[zbuffer_index] 
				if (zb_depth[0] > depth) {
						return;
				}
	
				depthbuffer[zbuffer_index] = depth;
	
				// compute normal from depth buffer using derivatives
				let dzdx = (depthbuffer[zbuffer_index + 1] - depthbuffer[zbuffer_index - 1]) / 2.0;
				let dzdy = (depthbuffer[zbuffer_index + width] - depthbuffer[zbuffer_index - width]) / 2.0;
	
				let normal = createVector(-dzdx, -dzdy, 1.0);
				normal.normalize();
	
				// point shade based on normalized Z value
				let brightness_fix = 2 - max(max(texture_red, texture_green), texture_blue) / 255;
				depth *= brightness_fix;
				stroke(texture_red * depth, texture_green * depth, texture_blue * depth);
				
				point(posx, posy);
			//}
		//}
	//}
}"
"817606","REYES² / volumetric rendering","mySketch","/**
	* A tentative to do a 3D renderer using REYES like algorithms (a type of rendering invented / developed by Lucasfilm / Pixar in the mid-80s and still used to late 2000s)
	* Actually REYES is more like a collection of classical computer graphics algorithms packed leto a single solution with a well defined pipeline process.
	*
  * This use a similar algorithm as my REYES sketch but this time more REYES i guess and much simpler...
	* ...in the first sketch the cube surfaces were computed and polygon filled / checked against a z-buffer at each frames, the final step was more akin to a standard rasterizer.
	*
  * This is simpler and use a point-based approach with floating point z-buffer :
	*   - the cube geometry is still defined as before using a volumetric / parametric approach (by stepping through x,y,z; parametric space is thus uniformly subdivided)
	*   - rendering is done progressively through multiple frames
	*   - use a point-based rendering approach; for quality rendering chose a low step value so that all surface is filled; arbitrary step value may be used for artistic effects
	*   - normal is computed using derivatives : http://www.aclockworkberry.com/shader-derivative-functions/
	*
	* note : in a REYES pipeline the step value may be chosen optimally instead of using a fixed value
	*/

let frame = 0;

let step = 0.004; // control surface subdivision, lower = higher quality (but too slow for realtime)
let scale = 0.1; // cube scale

let beach;

let depthbuffer = [];

function preload() {
  beach = loadImage('beach.png');
}

function setup() {
	createCanvas(windowWidth, windowHeight);

	background(0);

	noStroke();

	beach.loadPixels();

	// initialize depth buffer
	for (let i = 0.0; i <= width; i += 1) {
		for (let j = 0.0; j <= height; j += 1) {
			depthbuffer[i + j * width] = 0;
		}
	}
}

function draw() {
	for (let i = 0.0; i <= 50000; i += 1) {
		draw3d();
	}
}

let x = 0, y = 0, z = 0;
let offset = 0;

function draw3d() {
    //background(0);
	//fill(0, 0, 0, 48);
	//rect(0, 0, width, height);
	
	let rxa = 0.45 + 0.03 * frame;
	let rya = 0.5 + 0.04 * frame;

	// rotation values
	let crx = cos(rxa);
	let cry = cos(rya);
	let srx = sin(rxa);
	let sry = sin(rya);
	
	// rm = rotation matrix
	let rm = [0,0,0,0,0,0,0,0,0];

	rm[0] = cry;     /*rm[1] = 0.0f;*/ rm[2] = -sry;
	rm[3] = sry * srx; rm[4] = crx;    rm[5] = cry * srx;
	rm[6] = sry * crx; rm[7] = -srx;   rm[8] = cry * crx;
	
	let x2 = width / 2;
	let y2 = height / 2;
	
	// step cube volume along X,Y,Z in normalized space
	//let offset = frameCount / 512;
	
	// we can also do stochastic rendering
	//x = random();
	//y = random();
	//z = random();
	
	// progessive rendering part
	x += step + offset;
	if (x >= 1.0) {
		x = 0;
		y += step;
		if (y >= 1.0) {
			x = 0;
			y = 0;
			z += step;
		}
	}
	
	if (z >= 1) {
		return;
/*
		x = 0;
		y = 0;
		z = 0;
		
		offset += 0.01;
*/
	}
	//
	
	//for (z = 0.0; z <= 1.0; z += inc) {
		let vr = [0,0,0];

		let pz = 2.0 * z - 1.0; // normalize screen space

		vr[2] = pz * scale;
		//for (y = 0.0; y <= 1.0; y += inc) {
			let py = 2.0 * y - 1.0;

			vr[1] = py * scale;
			//for (x = 0.0; x <= 1.0; x += inc) {
				// filter volumetric data (eg. we only want the surface)
				if (x > 0.0 && x < (1.0 - step) && y > 0.0 && y < (1.0 - step) && z > 0.0 && z < (1.0 - step)) return;
				
				let px = (2.0 * x - 1.0);
				
				vr[0] = px * scale;

				// rotate/transform our points
				let vrr = [
						rm[0] * vr[0] + rm[3] * vr[1] + rm[6] * vr[2],
						rm[1] * vr[0] + rm[4] * vr[1] + rm[7] * vr[2],
						rm[2] * vr[0] + rm[5] * vr[1] + rm[8] * vr[2]
                ];
	
				// doing texturing is simple with this rendering method
				let u = x;
				let v = 1 - y;
				let texture_index = (parseInt(u * (beach.width - 1), 10) + parseInt(v * (beach.height - 1), 10) * beach.width) * 4;
				let texture_red = beach.pixels[texture_index];
				let texture_green = beach.pixels[texture_index + 1];
				let texture_blue = beach.pixels[texture_index + 2];
			
				// compute length & normalize
				let le = sqrt((vrr[0] * vrr[0]) + (vrr[1] * vrr[1]) + (vrr[2] * vrr[2]));
			  let vrn = [ vrr[0] / le, vrr[1] / le, vrr[2] / le ];
	
				// since we were in normalized space we scale it to screen space and translate it at the center of the screen
				let posx = x2 - round(vrr[0] * height);
				let posy = y2 - round(vrr[1] * height);
	
				let depth = vrn[2];
	
				// z-buffer (do nothing if farther; replace if nearest)
				let zbuffer_index = posx + posy * width;
				let zb_depth = depthbuffer[zbuffer_index] 
				if (zb_depth[0] > depth) {
						return;
				}
	
				depthbuffer[zbuffer_index] = depth;
	
				// compute normal from depth buffer using derivatives
				let dzdx = (depthbuffer[zbuffer_index + 1] - depthbuffer[zbuffer_index - 1]) / 2.0;
				let dzdy = (depthbuffer[zbuffer_index + width] - depthbuffer[zbuffer_index - width]) / 2.0;
	
				let normal = createVector(-dzdx, -dzdy, 1.0);
				normal.normalize();
	
				// point shade based on normalized Z value
				let brightness_fix = 2 - max(max(texture_red, texture_green), texture_blue) / 255;
				depth *= brightness_fix;
				stroke(texture_red * depth, texture_green * depth, texture_blue * depth);
				
				point(posx, posy);
			//}
		//}
	//}
}"
"817606","REYES² / volumetric rendering","mySketch","/**
	* A tentative to do a 3D renderer using REYES like algorithms (a type of rendering invented / developed by Lucasfilm / Pixar in the mid-80s and still used to late 2000s)
	* Actually REYES is more like a collection of classical computer graphics algorithms packed leto a single solution with a well defined pipeline process.
	*
  * This use a similar algorithm as my REYES sketch but this time experimenting with the volumetric nature of the approach, it is much simpler as well...
	* ...in the first sketch the cube surfaces were computed and polygon filled / checked against a z-buffer at each frames, the final step was more akin to a standard rasterizer.
	*
	* I don't know what to call this anymore, point-based rendering ? voxel rendering ? REYES (without dicing / splitting) ?
	*
  * Anyway this use a point-based approach with floating point z-buffer :
	*   - the cube geometry is still defined as before using a volumetric / parametric approach (by stepping through x,y,z; parametric space is thus uniformly subdivided)
	*   - rendering is done progressively through multiple frames
	*   - use a point-based rendering approach; for quality rendering chose a low step value so that all surface is filled; arbitrary step value may be used for artistic effects like here where i am using stroke and a bigger point to amplify depth
	*   - texturing; this rendering approach allow ultra simple and high quality texturing (just use 1px points / low step / no outline)
	*
	* note : in a REYES pipeline the step value may be chosen optimally instead of using a fixed value
	*/

let frame = 0;

let step = 0.004; // control surface subdivision, lower = higher quality (but too slow for realtime)
let scale = 0.2; // cube scale

let beach;

let depthbuffer = [];

function preload() {
  beach = loadImage('beach.png');
}

function setup() {
	createCanvas(windowWidth, windowHeight);

	background(0);

	noStroke();

	beach.loadPixels();
	
	noiseDetail(8, 0.7);

	// initialize depth buffer
	for (let i = 0.0; i <= width; i += 1) {
		for (let j = 0.0; j <= height; j += 1) {
			depthbuffer[i + j * width] = 0;
		}
	}
}

function draw() {
	// progressive rendering
	for (let i = 0.0; i <= 100000; i += 1) {
		draw3d();
	}
}

let x = 0, y = 0, z = 0;
let offset = 0;

function draw3d() {
	//background(0);
	//fill(0, 0, 0, 48);
	//rect(0, 0, width, height);
	
	let rxa = 0.3 + 0.03 * frame;
	let rya = 0.5 + 0.04 * frame;

	// rotation values
	let crx = cos(rxa);
	let cry = cos(rya);
	let srx = sin(rxa);
	let sry = sin(rya);
	
	// rm = rotation matrix
	let rm = [0,0,0,0,0,0,0,0,0];

	rm[0] = cry;     /*rm[1] = 0.0f;*/ rm[2] = -sry;
	rm[3] = sry * srx; rm[4] = crx;    rm[5] = cry * srx;
	rm[6] = sry * crx; rm[7] = -srx;   rm[8] = cry * crx;
	
	let x2 = width / 2;
	let y2 = height / 2;
	
	// step cube volume along X,Y,Z in normalized space
	//let offset = frameCount / 512;
	
	// we can also do stochastic rendering
	//x = random();
	//y = random();
	//z = random();
	
	// progessive rendering part (offset is unused; this was to speedup rendering)
	x += step + offset;
	if (x >= 1.0) {
		x = 0;
		y += step;
		if (y >= 1.0) {
			x = 0;
			y = 0;
			z += step;
		}
	}

	// idle once rendered
	if (z >= 1) {
		return;
	}
	//
	
	//for (z = 0.0; z <= 1.0; z += inc) {
		let vr = [0,0,0];

		let pz = 2.0 * z - 1.0; // normalize screen space

		vr[2] = pz * scale;
		//for (y = 0.0; y <= 1.0; y += inc) {
			let py = 2.0 * y - 1.0;

			vr[1] = py * scale;
			//for (x = 0.0; x <= 1.0; x += inc) {
				// volumetric data filter (eg. we only want the surface)
				if (x > 0.0 && x < (1.0 - step) && y > 0.0 && y < (1.0 - step) && z > 0.0 && z < (1.0 - step)) return;
				// fun filter to carve holes on the surface
				if (noise(x, y, z) > 0.9) return;
				
				let px = (2.0 * x - 1.0);
				vr[0] = px * scale;

				// rotate/transform our points
				let vrr = [
						rm[0] * vr[0] + rm[3] * vr[1] + rm[6] * vr[2],
						rm[1] * vr[0] + rm[4] * vr[1] + rm[7] * vr[2],
						rm[2] * vr[0] + rm[5] * vr[1] + rm[8] * vr[2]
                ];
	
				// doing good texturing is simple with this rendering method...
				let u = x;
				let v = 1 - y;
				let texture_index = (parseInt(u * (beach.width - 1), 10) + parseInt(v * (beach.height - 1), 10) * beach.width) * 4;
				let texture_red = beach.pixels[texture_index];
				let texture_green = beach.pixels[texture_index + 1];
				let texture_blue = beach.pixels[texture_index + 2];
			
				// compute length & normalize
				let le = sqrt((vrr[0] * vrr[0]) + (vrr[1] * vrr[1]) + (vrr[2] * vrr[2]));
			  let vrn = [ vrr[0] / le, vrr[1] / le, vrr[2] / le ];
	
				// since we were in normalized space we scale it to screen space and translate it at the center of the screen
				let posx = x2 - round(vrr[0] * height);
				let posy = y2 - round(vrr[1] * height);
	
				let depth = vrn[2];
	
				// z-buffer (do nothing if farther; replace if nearest)
				let zbuffer_index = posx + posy * width;
				let zb_depth = depthbuffer[zbuffer_index] 
				if (zb_depth[0] > depth) {
						return;
				}
	
				depthbuffer[zbuffer_index] = depth;
	
				// compute normal from depth buffer using derivatives
/*
				let dzdx = (depthbuffer[zbuffer_index + 1] - depthbuffer[zbuffer_index - 1]) / 2.0;
				let dzdy = (depthbuffer[zbuffer_index + width] - depthbuffer[zbuffer_index - width]) / 2.0;
	
				let normal = createVector(-dzdx, -dzdy, 1.0);
				normal.normalize();
	*/
	
				// point shade based on normalized Z value
				let brightness_fix = 2 - max(max(texture_red, texture_green), texture_blue) / 255;
				depth *= brightness_fix; //  * noise(x, y, z) // for fun
				stroke(texture_red * depth, texture_green * depth, texture_blue * depth);
				
				//point(posx, posy);
				rect(posx, posy, 2, 2);
			//}
		//}
	//}
}"
"817606","REYES² / volumetric rendering","mySketch","/**
	* A tentative to do a 3D renderer using REYES like algorithms (a type of rendering invented / developed by Lucasfilm / Pixar in the mid-80s and still used to late 2000s)
	* Actually REYES is more like a collection of classical computer graphics algorithms packed leto a single solution with a well defined pipeline process.
	*
  * This use a similar algorithm as my REYES sketch but this time experimenting with the volumetric nature of the approach, it is much simpler as well...
	* ...in the first sketch the cube surfaces were computed and polygon filled / checked against a z-buffer at each frames, the final step was more akin to a standard rasterizer.
	*
	* I don't know what to call this anymore, point-based rendering ? voxel rendering ? REYES (without dicing / splitting) ?
	*
  * Anyway this use a point-based approach with floating point z-buffer :
	*   - the cube geometry is still defined as before using a volumetric / parametric approach (by stepping through x,y,z; parametric space is thus uniformly subdivided)
	*   - rendering is done progressively through multiple frames
	*   - use a point-based rendering approach; for quality rendering chose a low step value so that all surface is filled; arbitrary step value may be used for artistic effects like here where i am using stroke and a bigger point to amplify depth / ambient lighting / puzzle like
	*   - texturing; this rendering approach allow ultra simple and high quality texturing (just use 1px points / low step / no outline)
	*
	* note : in a REYES pipeline the step value may be chosen optimally instead of using a fixed value
	*/

let frame = 0;

let step = 0.003; // control surface stepping, lower = higher quality (but too slow for realtime)
let scale = 0.3; // cube scale

let beach;

let depthbuffer = [];

function preload() {
  beach = loadImage('beach.png');
}

function setup() {
	createCanvas(windowWidth, windowHeight);

	background(0);

	noStroke();

	beach.loadPixels();
	
	noiseDetail(7, 0.7);

	// initialize depth buffer
	for (let i = 0.0; i <= width; i += 1) {
		for (let j = 0.0; j <= height; j += 1) {
			depthbuffer[i + j * width] = 0;
		}
	}
}

function draw() {
	// progressive rendering
	for (let i = 0.0; i <= 100000; i += 1) {
		draw3d();
	}
}

let x = 0, y = 0, z = 0;
let offset = 0;

function draw3d() {
	//background(0);
	//fill(0, 0, 0, 48);
	//rect(0, 0, width, height);
	
	let rxa = 0.3 + 0.03 * frame;
	let rya = 0.5 + 0.04 * frame;

	// rotation values
	let crx = cos(rxa);
	let cry = cos(rya);
	let srx = sin(rxa);
	let sry = sin(rya);
	
	// rm = rotation matrix
	let rm = [0,0,0,0,0,0,0,0,0];

	rm[0] = cry;     /*rm[1] = 0.0f;*/ rm[2] = -sry;
	rm[3] = sry * srx; rm[4] = crx;    rm[5] = cry * srx;
	rm[6] = sry * crx; rm[7] = -srx;   rm[8] = cry * crx;
	
	let x2 = width / 2;
	let y2 = height / 2;
	
	// step cube volume along X,Y,Z in normalized space
	//let offset = frameCount / 512;
	
	// we can also do stochastic rendering
	//x = random();
	//y = random();
	//z = random();
	
	// progessive rendering part (offset is unused; this was to speedup rendering)
	x += step + offset;
	if (x >= 1.0) {
		x = 0;
		y += step;
		if (y >= 1.0) {
			x = 0;
			y = 0;
			z += step;
		}
	}

	// idle once rendered
	if (z >= 1) {
		return;
	}
	//
	
	//for (z = 0.0; z <= 1.0; z += inc) {
		let vr = [0,0,0];

		let pz = 2.0 * z - 1.0; // normalize screen space

		vr[2] = pz * scale;
		//for (y = 0.0; y <= 1.0; y += inc) {
			let py = 2.0 * y - 1.0;

			vr[1] = py * scale;
			//for (x = 0.0; x <= 1.0; x += inc) {
				// volumetric data filter (eg. we only want the surface)
				if (x > 0.0 && x < (1.0 - step) && y > 0.0 && y < (1.0 - step) && z > 0.0 && z < (1.0 - step)) return;
				// fun filter to carve holes on the surface
				if (noise(x, y, z) > 0.9) return;
				
				let px = (2.0 * x - 1.0);
				vr[0] = px * scale;

				// rotate/transform our points
				let vrr = [
						rm[0] * vr[0] + rm[3] * vr[1] + rm[6] * vr[2],
						rm[1] * vr[0] + rm[4] * vr[1] + rm[7] * vr[2],
						rm[2] * vr[0] + rm[5] * vr[1] + rm[8] * vr[2]
                ];
	
				// doing good texturing is simple with this rendering method...
				let u = x;
				let v = 1 - y;
				let texture_index = (parseInt(u * (beach.width - 1), 10) + parseInt(v * (beach.height - 1), 10) * beach.width) * 4;
				let texture_red = beach.pixels[texture_index];
				let texture_green = beach.pixels[texture_index + 1];
				let texture_blue = beach.pixels[texture_index + 2];
			
				// compute length & normalize
				let le = sqrt((vrr[0] * vrr[0]) + (vrr[1] * vrr[1]) + (vrr[2] * vrr[2]));
			  let vrn = [ vrr[0] / le, vrr[1] / le, vrr[2] / le ];
	
				// since we were in normalized space we scale it to screen space and translate it at the center of the screen
				let posx = x2 - round(vrr[0] * height);
				let posy = y2 - round(vrr[1] * height);
	
				let depth = vrn[2];
	
				// z-buffer (do nothing if farther; replace if nearest)
				let zbuffer_index = posx + posy * width;
				let zb_depth = depthbuffer[zbuffer_index] 
				if (zb_depth[0] > depth) {
						return;
				}
	
				depthbuffer[zbuffer_index] = depth;
	
				// compute normal from depth buffer using derivatives
/*
				let dzdx = (depthbuffer[zbuffer_index + 1] - depthbuffer[zbuffer_index - 1]) / 2.0;
				let dzdy = (depthbuffer[zbuffer_index + width] - depthbuffer[zbuffer_index - width]) / 2.0;
	
				let normal = createVector(-dzdx, -dzdy, 1.0);
				normal.normalize();
	*/
	
				// point shade based on normalized Z value
				let brightness_fix = 2 - max(max(texture_red, texture_green), texture_blue) / 255;
				depth *= brightness_fix; //  * noise(x, y, z) // for fun

				fill(100*depth+155, 100*depth+155, 100*depth+155);
				stroke(texture_red * depth, texture_green * depth, texture_blue * depth);
				
				//point(posx, posy);
				rect(posx, posy, 2, 2);
			//}
		//}
	//}
}"
"817606","REYES² / volumetric rendering","mySketch","/**
	* A tentative to do a 3D renderer using REYES like algorithms (a type of rendering invented / developed by Lucasfilm / Pixar in the mid-80s and still used to late 2000s)
	* Actually REYES is more like a collection of classical computer graphics algorithms packed leto a single solution with a well defined pipeline process.
	*
  * This use a similar algorithm as my REYES sketch but this time experimenting with the volumetric nature of the approach, it is much simpler as well...
	* ...in the first sketch the cube surfaces were computed and polygon filled / checked against a z-buffer at each frames, the final step was more akin to a standard rasterizer.
	*
	* I don't know what to call this anymore, point-based rendering ? voxel rendering ? REYES (without dicing / splitting) ?
	*
  * Anyway this use a point-based approach with floating point z-buffer :
	*   - the cube geometry is still defined as before using a volumetric / parametric approach (by stepping through x,y,z; parametric space is thus uniformly subdivided)
	*   - rendering is done progressively through multiple frames
	*   - use a point-based rendering approach; for quality rendering chose a low step value so that all surface is filled; arbitrary step value may be used for artistic effects like here where i am using stroke and a bigger point to amplify depth / ambient lighting / puzzle like
	*   - texturing; this rendering approach allow ultra simple and high quality texturing (just use 1px points / low step / no outline)
	*
	* note : in a REYES pipeline the step value may be chosen optimally instead of using a fixed value
	*/

let frame = 0;

let step = 0.003; // control surface stepping, lower = higher quality (but too slow for realtime)
let scale = 0.3; // cube scale

let beach;

let depthbuffer = [];

function preload() {
    beach = loadImage('beach.png');
}

function setup() {
	createCanvas(windowWidth, windowHeight);

	background(0);

	noStroke();

	beach.loadPixels();
	
	noiseDetail(7, 0.7);

	// initialize depth buffer
	for (let i = 0.0; i <= width; i += 1) {
		for (let j = 0.0; j <= height; j += 1) {
			depthbuffer[i + j * width] = -Infinity;
		}
	}
}

function draw() {
	// progressive rendering
	for (let i = 0.0; i <= 100000; i += 1) {
		draw3d();
	}
}

let x = 0, y = 0, z = 0;
let offset = 0;

function draw3d() {
	//background(0);
	//fill(0, 0, 0, 48);
	//rect(0, 0, width, height);
	
	let rxa = 0.3 + 0.03 * frame;
	let rya = 0.5 + 0.04 * frame;

	// rotation values
	let crx = cos(rxa);
	let cry = cos(rya);
	let srx = sin(rxa);
	let sry = sin(rya);
	
	// rm = rotation matrix
	let rm = [0,0,0,0,0,0,0,0,0];

	rm[0] = cry;     /*rm[1] = 0.0f;*/ rm[2] = -sry;
	rm[3] = sry * srx; rm[4] = crx;    rm[5] = cry * srx;
	rm[6] = sry * crx; rm[7] = -srx;   rm[8] = cry * crx;
	
	let x2 = width / 2;
	let y2 = height / 2;
	
	// step cube volume along X,Y,Z in normalized space
	//let offset = frameCount / 512;
	
	// we can also do stochastic rendering
	//x = random();
	//y = random();
	//z = random();
	
	// progessive rendering part (offset is unused; this was to speedup rendering)
	x += step + offset;
	if (x >= 1.0) {
		x = 0;
		y += step;
		if (y >= 1.0) {
			x = 0;
			y = 0;
			z += step;
		}
	}

	// idle once rendered
	if (z >= 1) {
		return;
	}
	//
	
	//for (z = 0.0; z <= 1.0; z += inc) {
		let vr = [0,0,0];

		let pz = 2.0 * z - 1.0; // normalize screen space

		vr[2] = pz * scale;
		//for (y = 0.0; y <= 1.0; y += inc) {
			let py = 2.0 * y - 1.0;

			vr[1] = py * scale;
			//for (x = 0.0; x <= 1.0; x += inc) {
				// volumetric data filter (eg. we only want the surface)
				if (x > 0.0 && x < (1.0 - step) && y > 0.0 && y < (1.0 - step) && z > 0.0 && z < (1.0 - step)) return;
				// fun filter to carve holes on the surface
				if (noise(x, y, z) > 0.9) return;
				
				let px = (2.0 * x - 1.0);
				vr[0] = px * scale;

				// rotate/transform our points
				let vrr = [
						rm[0] * vr[0] + rm[3] * vr[1] + rm[6] * vr[2],
						rm[1] * vr[0] + rm[4] * vr[1] + rm[7] * vr[2],
						rm[2] * vr[0] + rm[5] * vr[1] + rm[8] * vr[2]
                ];
	
				// doing good texturing is simple with this rendering method...
				let u = x;
				let v = 1 - y;
				let texture_index = (parseInt(u * (beach.width - 1), 10) + parseInt(v * (beach.height - 1), 10) * beach.width) * 4;
				let texture_red = beach.pixels[texture_index];
				let texture_green = beach.pixels[texture_index + 1];
				let texture_blue = beach.pixels[texture_index + 2];
			
				// compute length & normalize
				let le = sqrt((vrr[0] * vrr[0]) + (vrr[1] * vrr[1]) + (vrr[2] * vrr[2]));
			  let vrn = [ vrr[0] / le, vrr[1] / le, vrr[2] / le ];
	
				// since we were in normalized space we scale it to screen space and translate it at the center of the screen
				let posx = x2 - round(vrr[0] * height);
				let posy = y2 - round(vrr[1] * height);
	
				let depth = vrn[2];
	
				// z-buffer (do nothing if farther; replace if nearest)
				let zbuffer_index = posx + posy * width;
				let zb_depth = depthbuffer[zbuffer_index];
				if (zb_depth > depth) {
					return;
				}
	
				depthbuffer[zbuffer_index] = depth;
	
				// compute normal from depth buffer using derivatives
/*
				let dzdx = (depthbuffer[zbuffer_index + 1] - depthbuffer[zbuffer_index - 1]) / 2.0;
				let dzdy = (depthbuffer[zbuffer_index + width] - depthbuffer[zbuffer_index - width]) / 2.0;
	
				let normal = createVector(-dzdx, -dzdy, 1.0);
				normal.normalize();
*/
	
				// point shade based on normalized Z value
				let brightness_fix = 2 - max(max(texture_red, texture_green), texture_blue) / 255;
				depth *= brightness_fix; //  * noise(x, y, z) // for fun

				fill(100*depth+155, 100*depth+155, 100*depth+155);
				stroke(texture_red * depth, texture_green * depth, texture_blue * depth);
				
				//point(posx, posy);
				rect(posx, posy, 2, 2);
			//}
		//}
	//}
}"
"814056","ifs","mySketch","// ifs
// https://flam3.com/flame_draves.pdf

var xmotion = 0;
var ymotion = 0;

let x = 0;
let y = 0;

function setup() {
  createCanvas(windowWidth, windowHeight);
  background(0);
	
	noiseDetail(7, 0.7);
	
	colorMode(HSB, 360, 100, 100, 255);
	
	noStroke();
	fill(0, 0, 100, 255);
	//stroke(0, 0, 100, 255);
	
	x = random(0, width);
	y = random(0, height);
}

function f1(x, y) {
	return { x: x / 2, y: y / 2 };
}

function f2(x, y) {
	return { x: (width / 2 + x) / 2, y: (height + y) / 2 };
}

function f3(x, y) {
	return { x: (width + x) / 2, y: y / 2 };
}

var f = [f1, f2, f3];

var iter = 0;

function draw() {
	fill(0, 0, 0, 1);
	rect(0, 0, width, height);
	
	for (let i = 0; i < 10000; i += 1) {
		let index = floor(random(0, 3));
		let r = f[index](x, y);

		x = r.x; y = r.y;

		fill(0, 0, 100, 255 * (i / 10000));

		if (iter > 20) {
			rect(x, y, 1, 1);	
		}
		
		iter += 1;
	}
	
	xmotion += 1;
	ymotion += 1;
}"
"813445","X","mySketch","// same as ""slime mold simulation""
// some cool figures can be made by tweaking lx / ly parameters

var xmotion = 0;
var ymotion = 0;

var objs = [];
var trail_map = [];

var nnx = 500;
var nny = 16;

function setup() {
	createCanvas(800, 800);
	
	colorMode(HSB, 360, 255, 255);
	
	background(0);
	
	noiseDetail(7, 0.7);
	
	var inc = 0;
	for (var nx = 0; nx < nnx; nx += 1) {
	 var nmx = nx / nnx;
	 for (var ny = 0; ny < nny; ny += 1) {
		var n = parseInt(nx + ny * nnx);
		 
		var nmy = ny / nny;
		
		var no = noise(nmx * nmy);
		 
		var ni = inc / (nnx * nny);
		
		objs[n] = {
			lx: width / 2 + (sin(nmx * PI * 0.25) * cos(nmy * PI * 1)) * (width / 2),
			ly: height / 2 + (cos(nmy * PI * 2) * sin(nmx * PI * 1)) * (height / 2.25),
			// paper
			//la: random(-PI * 2, PI * 2),
			la: nmx * PI * 16, // modify this for more shapes
			// paper : 1
			lv: 1,
			d: 1,
			n: no,
			so: 3, // agent sensor offset,
			sa: 45// agent sensor angle (degree)
		};
		 
		inc += 1;
	 }
	}
	
	for (var i = 0; i < width * height; i += 1) {
		trail_map[i] = 0;//i / (width * height);
	}
	
	ellipseMode(CENTER);
	rectMode(CENTER);
}

function compute() {
	fill(0);
	
	strokeWeight(2);

	for (var nx = 0; nx < nnx; nx += 1) {
	 for (var ny = 0; ny < nny; ny += 1) {
		var n = parseInt(nx + ny * nnx);
		 
		var obj = objs[n];
		
		var sensor_offset = obj.so;
		var sensor_angle = radians(obj.sa);
		
		// agent sensors
		var lhx = round(sin(obj.la - sensor_angle) * sensor_offset);
		var lhy = round(cos(obj.la - sensor_angle) * sensor_offset);
		var fhx = round(sin(obj.la) * sensor_offset);
		var fhy = round(cos(obj.la) * sensor_offset);
		var rhx = round(sin(obj.la + sensor_angle) * sensor_offset);
		var rhy = round(cos(obj.la + sensor_angle) * sensor_offset);
		
		var ailx = parseInt(obj.lx + lhx);
		var aily = parseInt(obj.ly + lhy);
		var aifx = parseInt(obj.lx + fhx);
		var aify = parseInt(obj.ly + fhy);
		var airx = parseInt(obj.lx + rhx);
		var airy = parseInt(obj.ly + rhy);
		
		ailx = ailx < 0 ? ailx + width : ailx;
		aily = aily < 0 ? aily + height : aily;
		aifx = aifx < 0 ? aifx + width : aifx;
		aify = aify < 0 ? aify + height : aify;
		airx = airx < 0 ? airx + width : airx;
		airy = airy < 0 ? airy + height : airy;
		
		ailx %= width;
		aily %= height;
		aifx %= width;
		aify %= height;
		airx %= width;
		airy %= height;
		
		// sensor sample
		var s1 = trail_map[ailx + aily * width]; // left
		var s2 = trail_map[aifx + aify * width]; // forward
		var s3 = trail_map[airx + airy * width]; // right
		
/*
		// debug sensor
		fill(255, 0, 0, 255);
		rect(ailx, aily, 1, 1);
		rect(aifx, aify, 1, 1);
		rect(airx, airy, 1, 1);
*/	
/*
		if (frameCount % 60 == 0) {
			obj.la += PI / 2;
		}
*/
	
		// agent behavior based on sampled sensor
		if (s2 < s1 && s2 < s3) {
			// turn left or right randomly
			//obj.la += random(PI / 2, -PI / 2);
			// paper
			//obj.la += (random() > 0.5 ? PI / 16 : -PI / 16);
		} else if (s1 < s3) {
			// turn left
			obj.la -= PI / 16 * (obj.ly / height);
		} else if (s3 < s1) {
			// turn right
			obj.la += PI / 16 * (obj.ly / height);
		}
		
		obj.lx += obj.lv * sin(obj.la);
		obj.ly += obj.lv * cos(-obj.la);
		 
		 if (obj.lx < 0 || obj.lx > width) {
				continue; 
		 }
		 
		 if (obj.ly < 0 || obj.ly > height) {
				continue; 
		 }
		
		// boundary checks
		/*obj.lx = obj.lx < 0 ? obj.lx + width - 1 : obj.lx;
		obj.lx %= width;
		obj.ly = obj.ly < 0 ? obj.ly + height - 1 : obj.ly;
		obj.ly %= height;*/
		
		// deposit diffusion (3x3 mean kernel)
		// should probably go after deposit step though
		var i = parseInt(obj.lx + obj.ly * width);
		var b = trail_map[i] / 2;

		var lx = parseInt(obj.lx);
		var ly = parseInt(obj.ly);

		var xb = (lx - 1);
		var yb = (ly - 1);
		var xbl = xb < 0 ? width - 1 : xb;
		var ybl = yb < 0 ? height - 1 : yb;
		var xbu = (lx + 1) % width;
		var ybu = (ly + 1) % height;
		/*
		var v1 = trail_map[xbl + ly * width];
		var v2 = trail_map[xbu + ly * width];
		var v3 = trail_map[xbl + ybl * width];
		var v4 = trail_map[xbl + ybu * width];
		var v5 = trail_map[xbu + ybl * width];
		var v6 = trail_map[xbu + ybu * width];
		var v7 = trail_map[lx + ybl * width];
		var v8 = trail_map[lx + ybu * width];
		
		var vm = (v1 + v2 + v3 + v4 + v5 + v6 + v7 + v8) / 8 / 5;
		*/
		trail_map[xbl + ly * width] = b;
		trail_map[xbu + ly * width] = b;
		trail_map[xbl + ybl * width] = b;
		trail_map[xbl + ybu * width] = b;
		trail_map[xbu + ybl * width] = b;
		trail_map[xbu + ybu * width] = b;
		trail_map[lx + ybl * width] = b;
		trail_map[lx + ybu * width] = b;
		
		// deposit
		trail_map[i] = obj.d;
		
		// agent display
		var ll = 400;
		var t = (noise(obj.n + xmotion * 4) * 2) * (pow((1 - min(ll, frameCount) / ll), 6.5 * ((((obj.ly / height)) * 6))));

		var sph = (1 - abs((0.5 - obj.lx / width) * 2));
		var color = 224 + noise(obj.n + xmotion * 2) * 32 * sph;
		fill(0, 0, color * (1 - (obj.ly / height)) * 8, t / 3);
		 noStroke();
		//stroke(0, 0, color, t);
		rect(obj.lx, obj.ly, 1, 1);
		
/*
		if (trail_map[parseInt(i)] > 1) {
			trail_map[parseInt(i)] = 1;
		}
*/
	 }
	}
	
	// deposit decay
	for (var y = 0; y < height; y += 1) {
		for (var x = 0; x < width; x += 1) {
			var v = trail_map[x + y * width];
			trail_map[x + y * width] -= 0.1;
			if (trail_map[x + y * width] < 0) {
				trail_map[x + y * width] = 0;
			}
		}
	}
/*
	if (frameCount % 60 == 0) {
		var st = 1 + parseInt(random() * (nn / 8));
		for (var y = 0; y < nn; y += st) {
			objs[y].lx = random() * width;
			objs[y].ly = random() * height;
		}
	}
*/
}

function draw() {
	noStroke();
	
	rectMode(CORNER);
/*
	fill(0, 0, 0, 8);
	rect(0, 0, width, height);
*/
	rectMode(CENTER);
	
	compute();
	
	xmotion += 0.05;
	ymotion += 0.0002;
}"
"813439","Ronde","mySketch","// same as ""slime mold simulation""

var xmotion = 0;
var ymotion = 0;

var objs = [];
var trail_map = [];

var nnx = 500;
var nny = 16;

function setup() {
	createCanvas(800, 800);
	
	colorMode(HSB, 360, 255, 255);
	
	background(0);
	
	noiseDetail(7, 0.7);
	
	var inc = 0;
	for (var nx = 0; nx < nnx; nx += 1) {
	 var nmx = nx / nnx;
	 for (var ny = 0; ny < nny; ny += 1) {
		var n = parseInt(nx + ny * nnx);
		 
		var nmy = ny / nny;
		
		var no = noise(nmx * nmy);
		 
		var ni = inc / (nnx * nny);
		
		objs[n] = {
			lx: width / 2 + (sin(nmx * PI * 2) * cos(nmy * PI * 0.65)) * (width / 3),
			ly: height / 2 + cos(nmy * PI * 1) * (height / 2),
			// paper
			//la: random(-PI * 2, PI * 2),
			la: nmx * PI * 5.55, // modify this for more shapes
			// paper : 1
			lv: 1,
			d: 1,
			n: no,
			so: 3, // agent sensor offset,
			sa: 45// agent sensor angle (degree)
		};
		 
		inc += 1;
	 }
	}
	
	for (var i = 0; i < width * height; i += 1) {
		trail_map[i] = 0;//i / (width * height);
	}
	
	ellipseMode(CENTER);
	rectMode(CENTER);
}

function compute() {
	fill(0);
	
	strokeWeight(2);

	for (var nx = 0; nx < nnx; nx += 1) {
	 for (var ny = 0; ny < nny; ny += 1) {
		var n = parseInt(nx + ny * nnx);
		 
		var obj = objs[n];
		
		var sensor_offset = obj.so;
		var sensor_angle = radians(obj.sa);
		
		// agent sensors
		var lhx = round(sin(obj.la - sensor_angle) * sensor_offset);
		var lhy = round(cos(obj.la - sensor_angle) * sensor_offset);
		var fhx = round(sin(obj.la) * sensor_offset);
		var fhy = round(cos(obj.la) * sensor_offset);
		var rhx = round(sin(obj.la + sensor_angle) * sensor_offset);
		var rhy = round(cos(obj.la + sensor_angle) * sensor_offset);
		
		var ailx = parseInt(obj.lx + lhx);
		var aily = parseInt(obj.ly + lhy);
		var aifx = parseInt(obj.lx + fhx);
		var aify = parseInt(obj.ly + fhy);
		var airx = parseInt(obj.lx + rhx);
		var airy = parseInt(obj.ly + rhy);
		
		ailx = ailx < 0 ? ailx + width : ailx;
		aily = aily < 0 ? aily + height : aily;
		aifx = aifx < 0 ? aifx + width : aifx;
		aify = aify < 0 ? aify + height : aify;
		airx = airx < 0 ? airx + width : airx;
		airy = airy < 0 ? airy + height : airy;
		
		ailx %= width;
		aily %= height;
		aifx %= width;
		aify %= height;
		airx %= width;
		airy %= height;
		
		// sensor sample
		var s1 = trail_map[ailx + aily * width]; // left
		var s2 = trail_map[aifx + aify * width]; // forward
		var s3 = trail_map[airx + airy * width]; // right
		
/*
		// debug sensor
		fill(255, 0, 0, 255);
		rect(ailx, aily, 1, 1);
		rect(aifx, aify, 1, 1);
		rect(airx, airy, 1, 1);
*/	
/*
		if (frameCount % 60 == 0) {
			obj.la += PI / 2;
		}
*/
	
		// agent behavior based on sampled sensor
		if (s2 < s1 && s2 < s3) {
			// turn left or right randomly
			//obj.la += random(PI / 2, -PI / 2);
			// paper
			//obj.la += (random() > 0.5 ? PI / 16 : -PI / 16);
		} else if (s1 < s3) {
			// turn left
			obj.la -= PI / 8;
		} else if (s3 < s1) {
			// turn right
			obj.la += PI / 8;
		}
		
		obj.lx += obj.lv * sin(obj.la);
		obj.ly += obj.lv * cos(-obj.la);
		 
		 if (obj.lx < 0 || obj.lx > width) {
				continue; 
		 }
		 
		 if (obj.ly < 0 || obj.ly > height) {
				continue; 
		 }
		
		// boundary checks
		/*obj.lx = obj.lx < 0 ? obj.lx + width - 1 : obj.lx;
		obj.lx %= width;
		obj.ly = obj.ly < 0 ? obj.ly + height - 1 : obj.ly;
		obj.ly %= height;*/
		
		// deposit diffusion (3x3 mean kernel)
		// should probably go after deposit step though
		var i = parseInt(obj.lx + obj.ly * width);
		var b = trail_map[i] / 2;

		var lx = parseInt(obj.lx);
		var ly = parseInt(obj.ly);

		var xb = (lx - 1);
		var yb = (ly - 1);
		var xbl = xb < 0 ? width - 1 : xb;
		var ybl = yb < 0 ? height - 1 : yb;
		var xbu = (lx + 1) % width;
		var ybu = (ly + 1) % height;
		/*
		var v1 = trail_map[xbl + ly * width];
		var v2 = trail_map[xbu + ly * width];
		var v3 = trail_map[xbl + ybl * width];
		var v4 = trail_map[xbl + ybu * width];
		var v5 = trail_map[xbu + ybl * width];
		var v6 = trail_map[xbu + ybu * width];
		var v7 = trail_map[lx + ybl * width];
		var v8 = trail_map[lx + ybu * width];
		
		var vm = (v1 + v2 + v3 + v4 + v5 + v6 + v7 + v8) / 8 / 5;
		*/
		trail_map[xbl + ly * width] = b;
		trail_map[xbu + ly * width] = b;
		trail_map[xbl + ybl * width] = b;
		trail_map[xbl + ybu * width] = b;
		trail_map[xbu + ybl * width] = b;
		trail_map[xbu + ybu * width] = b;
		trail_map[lx + ybl * width] = b;
		trail_map[lx + ybu * width] = b;
		
		// deposit
		trail_map[i] = obj.d;
		
		// agent display
		var ll = 400;
		var t = (noise(obj.n + xmotion * 4) * 2) * (pow((1 - min(ll, frameCount) / ll), 6.5 * ((((obj.ly / height)) * 6))));

		var sph = (1 - abs((0.5 - obj.lx / width) * 2));
		var color = 224 + noise(obj.n + xmotion * 2) * 32 * sph;
		fill(0, 0, color * (1 - (obj.ly / height)) * 8, t / 3);
		 noStroke();
		//stroke(0, 0, color, t);
		rect(obj.lx, obj.ly, 1, 1);
		
/*
		if (trail_map[parseInt(i)] > 1) {
			trail_map[parseInt(i)] = 1;
		}
*/
	 }
	}
	
	// deposit decay
	for (var y = 0; y < height; y += 1) {
		for (var x = 0; x < width; x += 1) {
			var v = trail_map[x + y * width];
			trail_map[x + y * width] -= 0.1;
			if (trail_map[x + y * width] < 0) {
				trail_map[x + y * width] = 0;
			}
		}
	}
/*
	if (frameCount % 60 == 0) {
		var st = 1 + parseInt(random() * (nn / 8));
		for (var y = 0; y < nn; y += st) {
			objs[y].lx = random() * width;
			objs[y].ly = random() * height;
		}
	}
*/
}

function draw() {
	noStroke();
	
	rectMode(CORNER);
/*
	fill(0, 0, 0, 8);
	rect(0, 0, width, height);
*/
	rectMode(CENTER);
	
	compute();
	
	xmotion += 0.05;
	ymotion += 0.0002;
}"
"813428","Eclipse","mySketch","// same as ""slime mold simulation""

var xmotion = 0;
var ymotion = 0;

var objs = [];
var trail_map = [];

var nnx = 500;
var nny = 8;

function setup() {
	createCanvas(800, 800);
	
	colorMode(HSB, 360, 255, 255);
	
	background(0);
	
	noiseDetail(7, 0.7);
	
	var inc = 0;
	for (var nx = 0; nx < nnx; nx += 1) {
	 var nmx = nx / nnx;
	 for (var ny = 0; ny < nny; ny += 1) {
		var n = parseInt(nx + ny * nnx);
		 
		var nmy = ny / nny;
		
		var no = noise(nmx * nmy);
		 
		var ni = inc / (nnx * nny);
		
		objs[n] = {
			lx: width / 2 + sin(nmx * PI * 2) * (width / 3.5),
			ly: height / 2 + cos(nmx * PI * 2) * (height / 3.5),
			// paper
			//la: random(-PI * 2, PI * 2),
			la: nmx * PI * 2, // modify this for more shapes
			// paper : 1
			lv: 1,
			d: 1,
			n: no,
			so: 3, // agent sensor offset,
			sa: 45// agent sensor angle (degree)
		};
		 
		inc += 1;
	 }
	}
	
	for (var i = 0; i < width * height; i += 1) {
		trail_map[i] = 0;//i / (width * height);
	}
	
	ellipseMode(CENTER);
	rectMode(CENTER);
}

function compute() {
	fill(0);
	
	strokeWeight(2);

	for (var nx = 0; nx < nnx; nx += 1) {
	 for (var ny = 0; ny < nny; ny += 1) {
		var n = parseInt(nx + ny * nnx);
		 
		var obj = objs[n];
		
		var sensor_offset = obj.so;
		var sensor_angle = radians(obj.sa);
		
		// agent sensors
		var lhx = round(sin(obj.la - sensor_angle) * sensor_offset);
		var lhy = round(cos(obj.la - sensor_angle) * sensor_offset);
		var fhx = round(sin(obj.la) * sensor_offset);
		var fhy = round(cos(obj.la) * sensor_offset);
		var rhx = round(sin(obj.la + sensor_angle) * sensor_offset);
		var rhy = round(cos(obj.la + sensor_angle) * sensor_offset);
		
		var ailx = parseInt(obj.lx + lhx);
		var aily = parseInt(obj.ly + lhy);
		var aifx = parseInt(obj.lx + fhx);
		var aify = parseInt(obj.ly + fhy);
		var airx = parseInt(obj.lx + rhx);
		var airy = parseInt(obj.ly + rhy);
		
		ailx = ailx < 0 ? ailx + width : ailx;
		aily = aily < 0 ? aily + height : aily;
		aifx = aifx < 0 ? aifx + width : aifx;
		aify = aify < 0 ? aify + height : aify;
		airx = airx < 0 ? airx + width : airx;
		airy = airy < 0 ? airy + height : airy;
		
		ailx %= width;
		aily %= height;
		aifx %= width;
		aify %= height;
		airx %= width;
		airy %= height;
		
		// sensor sample
		var s1 = trail_map[ailx + aily * width]; // left
		var s2 = trail_map[aifx + aify * width]; // forward
		var s3 = trail_map[airx + airy * width]; // right
		
/*
		// debug sensor
		fill(255, 0, 0, 255);
		rect(ailx, aily, 1, 1);
		rect(aifx, aify, 1, 1);
		rect(airx, airy, 1, 1);
*/	
/*
		if (frameCount % 60 == 0) {
			obj.la += PI / 2;
		}
*/
	
		// agent behavior based on sampled sensor
		if (s2 < s1 && s2 < s3) {
			// turn left or right randomly
			//obj.la += random(PI / 2, -PI / 2);
			// paper
			//obj.la += (random() > 0.5 ? PI / 16 : -PI / 16);
		} else if (s1 < s3) {
			// turn left
			obj.la -= PI / 8;
		} else if (s3 < s1) {
			// turn right
			obj.la += PI / 8;
		}
		
		obj.lx += obj.lv * sin(obj.la);
		obj.ly += obj.lv * cos(obj.la);
		 
		 if (obj.lx < 0 || obj.lx > width) {
				continue; 
		 }
		 
		 if (obj.ly < 0 || obj.ly > height) {
				continue; 
		 }
		
		// boundary checks
		/*obj.lx = obj.lx < 0 ? obj.lx + width - 1 : obj.lx;
		obj.lx %= width;
		obj.ly = obj.ly < 0 ? obj.ly + height - 1 : obj.ly;
		obj.ly %= height;*/
		
		// deposit diffusion (3x3 mean kernel)
		// should probably go after deposit step though
		var i = parseInt(obj.lx + obj.ly * width);
		var b = trail_map[i] / 2;

		var lx = parseInt(obj.lx);
		var ly = parseInt(obj.ly);

		var xb = (lx - 1);
		var yb = (ly - 1);
		var xbl = xb < 0 ? width - 1 : xb;
		var ybl = yb < 0 ? height - 1 : yb;
		var xbu = (lx + 1) % width;
		var ybu = (ly + 1) % height;
		/*
		var v1 = trail_map[xbl + ly * width];
		var v2 = trail_map[xbu + ly * width];
		var v3 = trail_map[xbl + ybl * width];
		var v4 = trail_map[xbl + ybu * width];
		var v5 = trail_map[xbu + ybl * width];
		var v6 = trail_map[xbu + ybu * width];
		var v7 = trail_map[lx + ybl * width];
		var v8 = trail_map[lx + ybu * width];
		
		var vm = (v1 + v2 + v3 + v4 + v5 + v6 + v7 + v8) / 8 / 5;
		*/
		trail_map[xbl + ly * width] = b;
		trail_map[xbu + ly * width] = b;
		trail_map[xbl + ybl * width] = b;
		trail_map[xbl + ybu * width] = b;
		trail_map[xbu + ybl * width] = b;
		trail_map[xbu + ybu * width] = b;
		trail_map[lx + ybl * width] = b;
		trail_map[lx + ybu * width] = b;
		
		// deposit
		trail_map[i] = obj.d;
		
		// agent display
		var ll = 400;
		var t = (noise(obj.n + xmotion * 4) * 2) * (pow((1 - min(ll, frameCount) / ll), 5.5 * (0.5 + (1 - (obj.ly / height)) / 2)));

		var sph = (1 - abs((0.5 - obj.lx / width) * 2));
		var color = 224 + noise(obj.n + xmotion * 2) * 32 * sph;
		fill(0, 0, color, t / 3);
		 noStroke();
		//stroke(0, 0, color, t);
		rect(obj.lx, obj.ly, 1, 1);
		
/*
		if (trail_map[parseInt(i)] > 1) {
			trail_map[parseInt(i)] = 1;
		}
*/
	 }
	}
	
	// deposit decay
	for (var y = 0; y < height; y += 1) {
		for (var x = 0; x < width; x += 1) {
			var v = trail_map[x + y * width];
			trail_map[x + y * width] -= 0.1;
			if (trail_map[x + y * width] < 0) {
				trail_map[x + y * width] = 0;
			}
		}
	}
/*
	if (frameCount % 60 == 0) {
		var st = 1 + parseInt(random() * (nn / 8));
		for (var y = 0; y < nn; y += st) {
			objs[y].lx = random() * width;
			objs[y].ly = random() * height;
		}
	}
*/
}

function draw() {
	noStroke();
	
	rectMode(CORNER);
/*
	fill(0, 0, 0, 8);
	rect(0, 0, width, height);
*/
	rectMode(CENTER);
	
	compute();
	
	xmotion += 0.05;
	ymotion += 0.0002;
}"
"812372","E","mySketch","function setup() {
	createCanvas(800, 800);
	background(0);
	
	colorMode(HSB, 100, 100, 100);

	draw2();
}

function draw() {

}

function draw2() {
	let nbx = 8;
	let nby = 8;
	let w = width / nbx;
	let h = height / nby;
	
	for (let i = 0; i < nbx; i += 1) {
		let px = i * w;
		for (let j = 0; j < nby; j += 1) {
			let py = j * h;
			
			stroke(0, 0, 0, 1);
			fill(0, 0, random(0, 20), 1);
			rect(px, py, w, h);
		}
	}
	
	for (let i = 0; i < nbx; i += 1) {
		let px = i * w;
		let normi = i / nbx;
		for (let j = 0; j < nby; j += 1) {
			let py = j * h;
			let normj = j / nby;
			
			stroke(0, 0, 0, 1);
			
			push();
			translate(px + w / 2 + random(-75, 75) * (normi * normj), py + h / 2 + random(-75, 75) * (normi * normj));
			
			let angle = random() * PI * 2;
			rotate(angle);
			
			//fill(0, 0, 50 + random(0, 25), 1);
			//triangle(-w / 2, -h / 2, 0, -h / 2, -w / 2, 0);
			
			fill(0, 0, 10 + random(0, 75), 1);
			triangle(0, 0, 0, -h / 2, -w / 2, 0);
			fill(0, 0, 10 + random(0, 75), 1);
			triangle(0, 0, 0, -h / 2, w / 2, 0);
			fill(0, 0, 10 + random(0, 75), 1);
			triangle(0, 0, 0, h / 2, -w / 2, 0);
			fill(0, 0, 10 + random(0, 75), 1);
			triangle(0, 0, 0, h / 2, w / 2, 0);
			pop();
		}
	}
	
	noFill();
	for (let i = 0; i < width; i += 1) {
		let normi = i / width;
		for (let j = 0; j < height; j += 1) {
			let normj = j / height;
			if (random() > (1 - (normi * normj))) {
				stroke(0, 0, random(0, 50), 1);
				point(i, j);
			}
		}
	}
}"
"809699","L-systems twist²","mySketch","/*
	fun with multiple Lindenmayer systems
	angle change at each custom cycles along several parameters
	
	this support stochastic and parametric rules
	
	good source for L-systems : http://algorithmicbotany.org/papers/abop/abop.pdf
*/

function weightedRandom(prob) {
  let i, sum=0, r=Math.random();
  for (i in prob) {
    sum += prob[i];
    if (r <= sum) return i;
  }
}

class lm {
	constructor(axiom, rules, angle, step) {
		this.ax = width / 2;
		this.ay = height / 2;
		this.px = this.ax;
		this.py = this.ay;
		this.ta = angle;
		this.ca = PI;
		this.fs = step;
		
		this.stack = [];
		
		this.axiom = axiom;
		this.rules = rules;
		this.itera = 2;
		
		this.rule = 0;
		
		this.cycles = 0;
		
		this.b = false;
		
		this.where = 1;
		
		this.initialize();
	}
	
	initialize() {
		let rule = this.axiom;
		for (let i = 0; i < this.itera; i++) {
			rule = this.lindenmayer(rule);
		}
		
		this.rule = rule;
	}
	
	lindenmayer(s) {
		let outputstring = '';

		for (let i = 0; i < s.length; i++) {
			let ismatch = 0;
			for (let j = 0; j < this.rules.length; j++) {
				if (s[i] == this.rules[j][0])  {
					let rule_index = 1;
					if (this.rules[j].length > 2) { // stochastic
						let probs = {};
						for (let k = 1; k < this.rules[j].length; k+=2) {
							probs[k+1] = this.rules[j][k];
						}
						rule_index = weightedRandom(probs);
					}
					outputstring += this.rules[j][rule_index];
					ismatch = 1;
					break;
				}
			}

			if (ismatch == 0) outputstring+= s[i];
		}

		return outputstring;
	}
	
	compute(cb_trigger) {
		let k = this.rule[this.where];
		if (k == 'F' || k == 'f') {
			var polx = this.fs * sin(this.ca);
			var poly = this.fs * cos(this.ca);
			let x1 = this.b ? this.px - polx : this.px + polx;
			let y1 = this.b ? this.py - poly : this.py + poly;

			if (x1 < 0 || y1 < 0 || x1 > width || y1 > height) {
				this.b = !this.b;
				this.ta = random() * PI * 2;
			}

			this.ax = this.px;
			this.ay = this.py;
			this.px = x1;
			this.py = y1;
		} else if (k == '[') {
			this.stack.push(this.px);
			this.stack.push(this.py);
			this.stack.push(this.ca);
		} else if (k == ']') {
			this.ca = this.stack.pop();
			this.py = this.stack.pop();
			this.px = this.stack.pop();
		} else if (k == '+') {
			this.ca += this.ta;
		} else if (k == '-') {
			this.ca -= this.ta;
		}
		
		this.where++;
  	if (this.where > this.rule.length-1) {
			this.where = 0;
			this.cycles += 1;
			
			cb_trigger(this);
		}
		
		if (k == 'F') {
			return true;
		} else {
			return false;
		}
	}
}

var xmotion = 0;
var ymotion = 0;

let lms = [];

function setup() {
  createCanvas(windowWidth, windowHeight);
  background(0);
	
	noiseDetail(7, 0.7);

  lms[0] = new lm('X', [['X', 0.2, 'F[+X]F[-X]+X', 0.7, 'F[+X]F[-F]-X'], ['F', 'FF']], radians(20), 8);
	lms[1] = new lm('X', [['X', 'F-[[X]+X]+F[+FX]-X'], ['F', 'FF']], radians(20), 8);
	
	colorMode(HSB, 360, 100, 100, 255);
}

function change(lm) {
	let max_cycles = 128;
	
	if (lm.cycles % max_cycles == 0) {
		lm.ta = random() * PI;
	}
	
	let nc = (lm.cycles % 64) / 64;
	stroke(0, 0, 100 * round(nc), random(0, 200));
	
	if (random() > 0.25) {
		lm.iter = 1;
		lm.initialize();
	} else {
		lm.iter = 2;
		lm.initialize();
	}
}

function draw() {
	for (let k = 0; k < 240; k += 1) {
		for (let i = 0; i < lms.length; i += 1) {
			let lm = lms[i];
			
			let result = lm.compute(change);
			
			if (result) {
				line(lm.px, lm.py, lm.ax, lm.ay);
			}
		}
	}
	
	xmotion += 0.5;
	ymotion += 0.25;
}"
"809699","L-systems twist²","mySketch","/*
	fun with multiple Lindenmayer systems
	angle change at each custom cycles along several parameters
	
	this support stochastic and parametric rules
	
	good source for L-systems : http://algorithmicbotany.org/papers/abop/abop.pdf
*/

function weightedRandom(prob) {
  let i, sum=0, r=Math.random();
  for (i in prob) {
    sum += prob[i];
    if (r <= sum) return i;
  }
}

class lm {
	constructor(axiom, rules, angle, step) {
		this.ax = width / 2;
		this.ay = height / 2;
		this.px = this.ax;
		this.py = this.ay;
		this.ta = angle;
		this.ca = PI;
		this.fs = step;
		
		this.stack = [];
		
		this.axiom = axiom;
		this.rules = rules;
		this.itera = 5;
		
		this.rule = 0;
		
		this.cycles = 0;
		
		this.b = false;
		
		this.where = 1;
		
		this.initialize();
	}
	
	initialize() {
		let rule = this.axiom;
		for (let i = 0; i < this.itera; i++) {
			rule = this.lindenmayer(rule);
		}
		
		this.rule = rule;
	}
	
	lindenmayer(s) {
		let outputstring = '';

		for (let i = 0; i < s.length; i++) {
			let ismatch = 0;
			for (let j = 0; j < this.rules.length; j++) {
				if (s[i] == this.rules[j][0])  {
					let rule_index = 1;
					if (this.rules[j].length > 2) { // stochastic
						let probs = {};
						for (let k = 1; k < this.rules[j].length; k+=2) {
							probs[k+1] = this.rules[j][k];
						}
						rule_index = weightedRandom(probs);
					}
					outputstring += this.rules[j][rule_index];
					ismatch = 1;
					break;
				}
			}

			if (ismatch == 0) outputstring+= s[i];
		}
		
		return outputstring;
	}
	
	computeParameters(w) {
		
	}
	
	compute(cb_trigger) {
		let k = this.rule[this.where];
		if (k == 'F' || k == 'f') {
			var polx = this.fs * sin(this.ca);
			var poly = this.fs * cos(this.ca);
			let x1 = this.b ? this.px - polx : this.px + polx;
			let y1 = this.b ? this.py - poly : this.py + poly;

			if (x1 < 0 || y1 < 0 || x1 > width || y1 > height) {
				this.b = !this.b;
				this.ta = random() * PI * 2;
				
				if (x1 < 0) x1 = 0;
				if (y1 < 0) y1 = 0;
				if (x1 > width) x1 = width;
				if (y1 > height) y1 = height;
			}

			this.ax = this.px;
			this.ay = this.py;
			this.px = x1;
			this.py = y1;
		} else if (k == '[') {
			this.stack.push(this.px);
			this.stack.push(this.py);
			this.stack.push(this.ca);
		} else if (k == ']') {
			this.ca = this.stack.pop();
			this.py = this.stack.pop();
			this.px = this.stack.pop();
		} else if (k == '+') {
			this.ca += this.ta;
		} else if (k == '-') {
			this.ca -= this.ta;
		}
		
		this.where++;
  	if (this.where > this.rule.length-1) {
			this.where = 0;
			this.cycles += 1;
			
			cb_trigger(this);
		}
		
		if (k == 'F') {
			return true;
		} else {
			return false;
		}
	}
}

var xmotion = 0;
var ymotion = 0;

let lms = [];

function setup() {
  createCanvas(windowWidth, windowHeight);
  background(0);
	
	noiseDetail(7, 0.7);

  lms[0] = new lm('X', [['X', 0.5, 'XFFFFFFFFFF-[F-X+]FX+', 0.5, 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF[f+F]------------F'], ['F', '+F-----F+']], radians(20), 8);
	//lms[1] = new lm('X', [['X', 'F-[[X]+X]+F[+FX]-X'], ['F', 'FF']], radians(20), 8);
	
	colorMode(HSB, 360, 100, 100, 255);
	
	stroke(0, 0, 100, 255);
}

function change(lm) {
	let max_cycles = 32;
	
	if (lm.cycles % max_cycles == 0) {
		lm.ta = random(0, PI / 2);
	}
	
	let nc = (lm.cycles % 8) / 8;
	stroke(0, 0, 100 * round(nc), random(0, 200));
	
	if (random() > 0.25) {
		lm.iter = 1;
		lm.initialize();
	} else {
		lm.iter = 2;
		lm.initialize();
	}
}

function draw() {
	for (let k = 0; k < 240; k += 1) {
		for (let i = 0; i < lms.length; i += 1) {
			let lm = lms[i];
			
			let result = lm.compute(change);
			
			if (result) {
				line(lm.px, lm.py, lm.ax, lm.ay);
			}
		}
	}
	
	xmotion += 0.5;
	ymotion += 0.25;
}"
"808945","L-systems twist","mySketch","// TURTLE STUFF:
let x, y; // the current position of the turtle
let currentangle = -90; // which way the turtle is pointing
let step = 10; // how much the turtle moves with each 'F'
let angle = 20; // how much the turtle turns with a '-' or '+'

// LINDENMAYER STUFF (L-SYSTEMS)
let thestring = 'F'; // ""axiom"" or start of the string
let numloops = 5; // how many iterations to pre-compute
let therules = []; // array for rules
therules[0] = ['F', 'F[+F]F[-F][F]']; // first rule
//therules[1] = []; // second rule

let whereinstring = 1; // where in the L-system are we?

function setup() {
  createCanvas(710, 800);
  background(255);
  stroke(0, 0, 0, 255);

  // start the x and y position at lower-left corner
  x = width / 2;
  y = height-1;

  // COMPUTE THE L-SYSTEM
  for (let i = 0; i < numloops; i++) {
    thestring = lindenmayer(thestring);
  }
}

function draw() {

  // draw the current character in the string:
  drawIt(thestring[whereinstring]);

  // increment the point for where we're reading the string.
  // wrap around at the end.
  whereinstring++;
  if (whereinstring > thestring.length-1) whereinstring = 0;

}

// interpret an L-system
function lindenmayer(s) {
  let outputstring = ''; // start a blank output string

  // iterate through 'therules' looking for symbol matches:
  for (let i = 0; i < s.length; i++) {
    let ismatch = 0; // by default, no match
    for (let j = 0; j < therules.length; j++) {
      if (s[i] == therules[j][0])  {
        outputstring += therules[j][1]; // write substitution
        ismatch = 1; // we have a match, so don't copy over symbol
        break; // get outta this for() loop
      }
    }
    // if nothing matches, just copy the symbol over.
    if (ismatch == 0) outputstring+= s[i];
  }

  return outputstring; // send out the modified string
}

var stack = [];

// this is a custom function that draws turtle commands
function drawIt(k) {

  if (k=='F') { // draw forward
    // polar to cartesian based on step and currentangle:
    let x1 = x + step*cos(radians(currentangle));
    let y1 = y + step*sin(radians(currentangle));
    line(x, y, x1, y1); // connect the old and the new

    // update the turtle's position:
    x = x1;
    y = y1;
	} else if (k == '[') {
		stack.push(x);
		stack.push(y);
		stack.push(currentangle);
		return;
	} else if (k == ']') {
		currentangle = stack.pop();
		y = stack.pop();
		x = stack.pop();
		return;
  } else if (k == '+') {
    currentangle += angle; // turn left
  } else if (k == '-') {
    currentangle -= angle; // turn right
  }

  // give me some random color values:
  let r = random(128, 255);
  let g = random(0, 192);
  let b = random(0, 50);
  let a = random(50, 100);

  // pick a gaussian (D&D) distribution for the radius:
  let radius = 0;
  radius += random(0, 15);
  radius += random(0, 15);
  radius += random(0, 15);
  radius = radius / 3;

  // draw the stuff:
  //fill(r, g, b, a);
  //ellipse(x, y, 1,1);
}"
"808945","L-systems twist","mySketch","// TURTLE STUFF:
let x, y; // the current position of the turtle
let currentangle = -90; // which way the turtle is pointing
let step = 10; // how much the turtle moves with each 'F'
let angle = 20; // how much the turtle turns with a '-' or '+'

// LINDENMAYER STUFF (L-SYSTEMS)
let thestring = 'F'; // ""axiom"" or start of the string
let numloops = 7; // how many iterations to pre-compute
let therules = []; // array for rules
therules[0] = ['F', 'F[+F]F[-F][F]']; // first rule
//therules[1] = []; // second rule

let whereinstring = 1; // where in the L-system are we?

function setup() {
  createCanvas(710, 800);
  background(255);
  stroke(0, 0, 0, 255);

  // start the x and y position at lower-left corner
  x = width / 2;
  y = height-1;

  // COMPUTE THE L-SYSTEM
  for (let i = 0; i < numloops; i++) {
    thestring = lindenmayer(thestring);
  }
}

function draw() {

  // draw the current character in the string:
  drawIt(thestring[whereinstring]);

  // increment the point for where we're reading the string.
  // wrap around at the end.
  whereinstring++;
  if (whereinstring > thestring.length-1) whereinstring = 0;

}

// interpret an L-system
function lindenmayer(s) {
  let outputstring = ''; // start a blank output string

  // iterate through 'therules' looking for symbol matches:
  for (let i = 0; i < s.length; i++) {
    let ismatch = 0; // by default, no match
    for (let j = 0; j < therules.length; j++) {
      if (s[i] == therules[j][0])  {
        outputstring += therules[j][1]; // write substitution
        ismatch = 1; // we have a match, so don't copy over symbol
        break; // get outta this for() loop
      }
    }
    // if nothing matches, just copy the symbol over.
    if (ismatch == 0) outputstring+= s[i];
  }

  return outputstring; // send out the modified string
}

var stack = [];

// this is a custom function that draws turtle commands
function drawIt(k) {

  if (k=='F') { // draw forward
    // polar to cartesian based on step and currentangle:
    let x1 = x + step*cos(radians(currentangle));
    let y1 = y + step*sin(radians(currentangle));
    line(x, y, x1, y1); // connect the old and the new
		line(width - x, y, width - x1, y1);

    // update the turtle's position:
    x = x1;
    y = y1;
	} else if (k == '[') {
		stack.push(x);
		stack.push(y);
		stack.push(currentangle);
		return;
	} else if (k == ']') {
		currentangle = stack.pop();
		y = stack.pop();
		x = stack.pop();
		return;
  } else if (k == '+') {
    currentangle += angle; // turn left
  } else if (k == '-') {
    currentangle -= angle; // turn right
  }

  // give me some random color values:
  let r = random(128, 255);
  let g = random(0, 192);
  let b = random(0, 50);
  let a = random(50, 100);

  // pick a gaussian (D&D) distribution for the radius:
  let radius = 0;
  radius += random(0, 15);
  radius += random(0, 15);
  radius += random(0, 15);
  radius = radius / 3;

  // draw the stuff:
  //fill(r, g, b, a);
  //ellipse(x, y, 1,1);
}"
"808945","L-systems twist","mySketch","/*
	fun with multiple Lindenmayer systems
	angle change at each custom cycles along several parameters
	
	good source for L-systems : http://algorithmicbotany.org/papers/abop/abop.pdf
*/

class lm {
	constructor(axiom, rules, angle, step) {
		this.ax = width / 2;
		this.ay = height / 2;
		this.px = this.ax;
		this.py = this.ay;
		this.ta = angle;
		this.ca = PI;
		this.fs = step;
		
		this.stack = [];
		
		this.axiom = axiom;
		this.rules = rules;
		this.itera = 2;
		
		this.rule = 0;
		
		this.cycles = 0;
		
		this.b = false;
		
		this.where = 1;
		
		this.initialize();
	}
	
	initialize() {
		let rule = this.axiom;
		for (let i = 0; i < this.itera; i++) {
			rule = this.lindenmayer(rule);
		}
		
		this.rule = rule;
	}
	
	lindenmayer(s) {
		let outputstring = '';

		for (let i = 0; i < s.length; i++) {
			let ismatch = 0;
			for (let j = 0; j < this.rules.length; j++) {
				if (s[i] == this.rules[j][0])  {
					outputstring += this.rules[j][1];
					ismatch = 1;
					break;
				}
			}

			if (ismatch == 0) outputstring+= s[i];
		}

		return outputstring;
	}
	
	compute(cb_trigger) {
		let k = this.rule[this.where];
		if (k == 'F') {
			var polx = this.fs * sin(this.ca);
			var poly = this.fs * cos(this.ca);
			let x1 = this.b ? this.px - polx : this.px + polx;
			let y1 = this.b ? this.py - poly : this.py + poly;

			if (x1 < 0 || y1 < 0 || x1 > width || y1 > height) {
				this.b = !this.b;
				this.ta = random() * PI * 2;
			}

			this.ax = this.px;
			this.ay = this.py;
			this.px = x1;
			this.py = y1;
		} else if (k == '[') {
			this.stack.push(this.px);
			this.stack.push(this.py);
			this.stack.push(this.ca);
		} else if (k == ']') {
			this.ca = this.stack.pop();
			this.py = this.stack.pop();
			this.px = this.stack.pop();
		} else if (k == '+') {
			this.ca += this.ta;
		} else if (k == '-') {
			this.ca -= this.ta;
		}
		
		this.where++;
  	if (this.where > this.rule.length-1) {
			this.where = 0;
			this.cycles += 1;
			
			cb_trigger(this);
		}
	}
}

var xmotion = 0;
var ymotion = 0;

let lms = [];

function setup() {
  createCanvas(windowWidth, windowHeight);
  background(0);
	
	noiseDetail(7, 0.7);

  lms[0] = new lm('X', [['X', 'F[+X]F[-X]+X'], ['F', 'FF']], radians(20), 8);
	lms[1] = new lm('X', [['X', 'F-[[X]+X]+F[+FX]-X'], ['F', 'FF']], radians(20), 8);
	
	colorMode(HSB, 360, 100, 100, 255);
}

function change(lm) {
	let max_cycles = 32;
	
	if (lm.cycles % max_cycles == 0) {
		lm.ta = random() * PI;
	}
	
	let nc = (lm.cycles % 64) / 64;
	stroke(0, 0, 100 * round(nc), random(0, 100));
	
	if (random() > 0.25) {
		lm.iter = 1;
		lm.initialize();
	} else {
		lm.iter = 2;
		lm.initialize();
	}
}

function draw() {
	for (let k = 0; k < 240; k += 1) {
		for (let i = 0; i < lms.length; i += 1) {
			let lm = lms[i];
			
			lm.compute(change);
			
			line(lm.px, lm.py, lm.ax, lm.ay);
		}
	}
	
	xmotion += 0.5;
	ymotion += 0.25;
}"
"808945","L-systems twist","mySketch","class lm {
	constructor() {
		
	}
	
	
};

let x, y; // the current position of the turtle
let currentangle = -90; // which way the turtle is pointing
let step = 20; // how much the turtle moves with each 'F'
let angle = 90; // how much the turtle turns with a '-' or '+'

// LINDENMAYER STUFF (L-SYSTEMS)
let thestring = '-L'; // ""axiom"" or start of the string
let numloops = 3; // how many iterations to pre-compute
let therules = []; // array for rules
therules[0] = ['L', 'LFRFL-[F-RF]LFR+F+LFRFL']; // first rule
therules[1] = ['R', 'RFLFR+F+LFRFL-F-RFLFR']; // second rule

let whereinstring = 1; // where in the L-system are we?

function setup() {
  createCanvas(800, 800);
  background(0);
  stroke(255, 255, 255, 255);

  x = width / 2;
  y = height / 2;//height-1;

  // COMPUTE THE L-SYSTEM
  for (let i = 0; i < numloops; i++) {
    thestring = lindenmayer(thestring);
  }
}

function draw() {

  // draw the current character in the string:
  drawIt(thestring[whereinstring]);

  // increment the point for where we're reading the string.
  // wrap around at the end.
  whereinstring++;
  if (whereinstring > thestring.length-1) whereinstring = 0;

}

// interpret an L-system
function lindenmayer(s) {
  let outputstring = ''; // start a blank output string

  // iterate through 'therules' looking for symbol matches:
  for (let i = 0; i < s.length; i++) {
    let ismatch = 0; // by default, no match
    for (let j = 0; j < therules.length; j++) {
      if (s[i] == therules[j][0])  {
        outputstring += therules[j][1]; // write substitution
        ismatch = 1; // we have a match, so don't copy over symbol
        break; // get outta this for() loop
      }
    }
    // if nothing matches, just copy the symbol over.
    if (ismatch == 0) outputstring+= s[i];
  }

  return outputstring; // send out the modified string
}

var stack = [];
var xmotion = 0;
var ymotion = 0;

// this is a custom function that draws turtle commands
function drawIt(k) {

  if (k=='F') { // draw forward
    // polar to cartesian based on step and currentangle:
		var t = radians(currentangle);
    let x1 = x + step*(abs(cos(t)) * cos(t) + abs(sin(t)) * sin(t));
    let y1 = y + step*(abs(cos(t)) * cos(t) - abs(sin(t)) * sin(t));
		
		if (x < 0) x = -x;	
		if (y < 0) y = -y;	
		if (x > width) x -= x - width;
		if (y > height) y -= y - height;
		if (x1 < 0) x1 = -x1;	
		if (y1 < 0) y1 = -y1;	
		if (x1 > width) x1 -= x1 - width;
		if (y1 > height) y1 -= y1 - height;
		/*
    line(x, y, x1, y1); // connect the old and the new
		line(width - x, y, width - x1, y1);
		line(x, height - y, x1, height - y1);
		line(width - x, height - y, width - x1, height - y1);
		*/
		stroke(255, 255, 255, noise(x/width+xmotion, y/height+ymotion) * 255);
		fill(255, 255, 255, noise(x/width+xmotion, y/height+ymotion) * 32);
		quad(x, y, x1, y1, width - x1, width - y1, width - x, width - y);
		//line((x + x1) / 2, (y + y1) / 2, (x + x1) / 2 + 8*cos(radians(currentangle+Math.PI / 2)), (y + y1) / 2 + 8*cos(radians(currentangle+Math.PI / 2)));

    // update the turtle's position:
    x = x1;
    y = y1;
	} else if (k == '[') {
		stack.push(x);
		stack.push(y);
		stack.push(currentangle);
		return;
	} else if (k == ']') {
		currentangle = stack.pop();
		y = stack.pop();
		x = stack.pop();
		return;
  } else if (k == '+') {
    currentangle += angle; // turn left
  } else if (k == '-') {
    currentangle -= angle; // turn right
  }

  // give me some random color values:
  let r = random(128, 255);
  let g = random(0, 192);
  let b = random(0, 50);
  let a = random(50, 100);

  // pick a gaussian (D&D) distribution for the radius:
  let radius = 0;
  radius += random(0, 15);
  radius += random(0, 15);
  radius += random(0, 15);
  radius = radius / 3;

  // draw the stuff:
  //fill(r, g, b, a);
  //ellipse(x, y, 8,8);
	
	xmotion += 0.5;
	ymotion += 0.25;
}"
"808945","L-systems twist","mySketch","class lm {
	constructor(axiom, rules) {
		this.px = width / 2;
		this.py = height / 2;
		this.ta = PI / 2;
		this.ca = PI;
		this.fs = 20;
		
		this.axiom = axiom;
		this.rules = rules;
		this.itera = 3;
		
		this.where = 1;
		
		for (let i = 0; i < this.itera; i++) {
			this.axiom = this.lindenmayer(this.axiom);
		}
	}
	
	lindenmayer(s) {
		let outputstring = '';

		for (let i = 0; i < s.length; i++) {
			let ismatch = 0;
			for (let j = 0; j < this.rules.length; j++) {
				if (s[i] == this.rules[j][0])  {
					outputstring += this.rules[j][1];
					ismatch = 1;
					break;
				}
			}

			if (ismatch == 0) outputstring+= s[i];
		}

		return outputstring; // send out the modified string
	}
	
	step() {
		this.where++;
  	if (this.where > this.axiom.length-1) this.where = 0;
	}
}
/*
let x, y; // the current position of the turtle
let currentangle = -90; // which way the turtle is pointing
let step = 20; // how much the turtle moves with each 'F'
let angle = 90; // how much the turtle turns with a '-' or '+'

// LINDENMAYER STUFF (L-SYSTEMS)
let thestring = '-L'; // ""axiom"" or start of the string
let numloops = 3; // how many iterations to pre-compute
let therules = []; // array for rules
therules[0] = ['L', 'LFRFL-[F-RF]LFR+F+LFRFL']; // first rule
therules[1] = ['R', 'RFLFR+F+LFRFL-F-RFLFR']; // second rule

let whereinstring = 1; // where in the L-system are we?
*/
let lms = [];

function setup() {
  createCanvas(800, 800);
  background(0);
  stroke(255, 255, 255, 255);

  lms[0] = new lm('-L', [['L', 'LFRFL-[F-RF]LFR+F+LFRFL'], ['R', 'RFLFR+F+LFRFL-F-RFLFR']]);
	lms[1] = new lm('-L', [['L', 'LFRFL-F-RFFR+F+LRFL'], ['R', 'RFR+F+LFRFL-F-RLFR']]);
}

function draw() {

  // draw the current character in the string:
  drawIt(thestring[whereinstring]);

	for (let i = 0; i < lms.length; i += 1) {
		lms[i].step();
	}
}

var stack = [];
var xmotion = 0;
var ymotion = 0;

// this is a custom function that draws turtle commands
function drawIt(k) {

  if (k=='F') { // draw forward
    // polar to cartesian based on step and currentangle:
		var t = radians(currentangle);
    let x1 = x + step*(abs(cos(t)) * cos(t) + abs(sin(t)) * sin(t));
    let y1 = y + step*(abs(cos(t)) * cos(t) - abs(sin(t)) * sin(t));
		
		if (x < 0) x = -x;	
		if (y < 0) y = -y;	
		if (x > width) x -= x - width;
		if (y > height) y -= y - height;
		if (x1 < 0) x1 = -x1;	
		if (y1 < 0) y1 = -y1;	
		if (x1 > width) x1 -= x1 - width;
		if (y1 > height) y1 -= y1 - height;
		/*
    line(x, y, x1, y1); // connect the old and the new
		line(width - x, y, width - x1, y1);
		line(x, height - y, x1, height - y1);
		line(width - x, height - y, width - x1, height - y1);
		*/
		stroke(255, 255, 255, noise(x/width+xmotion, y/height+ymotion) * 255);
		fill(255, 255, 255, noise(x/width+xmotion, y/height+ymotion) * 32);
		quad(x, y, x1, y1, width - x1, width - y1, width - x, width - y);
		//line((x + x1) / 2, (y + y1) / 2, (x + x1) / 2 + 8*cos(radians(currentangle+Math.PI / 2)), (y + y1) / 2 + 8*cos(radians(currentangle+Math.PI / 2)));

    // update the turtle's position:
    x = x1;
    y = y1;
	} else if (k == '[') {
		stack.push(x);
		stack.push(y);
		stack.push(currentangle);
		return;
	} else if (k == ']') {
		currentangle = stack.pop();
		y = stack.pop();
		x = stack.pop();
		return;
  } else if (k == '+') {
    currentangle += angle; // turn left
  } else if (k == '-') {
    currentangle -= angle; // turn right
  }

  // give me some random color values:
  let r = random(128, 255);
  let g = random(0, 192);
  let b = random(0, 50);
  let a = random(50, 100);

  // pick a gaussian (D&D) distribution for the radius:
  let radius = 0;
  radius += random(0, 15);
  radius += random(0, 15);
  radius += random(0, 15);
  radius = radius / 3;

  // draw the stuff:
  //fill(r, g, b, a);
  //ellipse(x, y, 8,8);
	
	xmotion += 0.5;
	ymotion += 0.25;
}"
"802128","Pathway","mySketch","var xmotion = 0;
var ymotion = 0;

var objs = [];

var nnx = 92;
var nny = 12;
var nnf = 2;

function setup() {
	createCanvas(800, 800);
	
	smooth();
	
	colorMode(HSB, 360, 255, 255);
	
	background(0);
	
	noiseDetail(7, 0.7);
	
	for (var nx = 1; nx < nnx; nx += 1) {
	 var nmx = nx / nnx;
	 for (var ny = 0; ny < nny; ny += 1) {
		var n = parseInt(nx + ny * nnx);
		 
		var nmy = ny / nny;
		
		var no = noise(nmx * nmy);
		 
		var t = nmy * PI * 2;

		var dstx = abs(nx - width / 2) / (width / 2);
		var dsty = abs(ny - height / 2) / (width / 2);
		var dst = (dstx + dsty) / 2;
		 
		objs[n] = {
			x: width / 2 + (abs(cos(t)) * cos(t) + abs(sin(t)) * sin(t)) * (width / 2 * nmx) + ((0.5 - noise(nx, ny)) * 2 * 4),
			y: height / 2 + (abs(cos(t)) * cos(t) - abs(sin(t)) * sin(t)) * (height / 2 * nmx) + ((0.5 - noise(nx, ny)) * 2 * 4),
			tx: (abs(cos(t)) * cos(t) + abs(sin(t)) * sin(t)),
			ty: (abs(cos(t)) * cos(t) - abs(sin(t)) * sin(t)),
			t: t
		};
	 }
	}
	
	ellipseMode(CENTER);
	rectMode(CENTER);
}

function compute() {
	noFill();
	
	strokeWeight(1);

	for (var nx = 16; nx < nnx; nx += 1) {
		var nmx = nx / nnx;
	 	for (var ny = 0; ny < nny; ny += 1) {
			var n = parseInt(nx + ny * nnx);
			var obj = objs[n];
			
			var im1 = ny - 1;
			if (im1 < 0) { im1 = nny - 1; }
			var nm1 = parseInt(nx + im1 * nnx);
			var pobj = objs[nm1];

			if (noise(nx, ny) > 0.05) {
				var dst = 1 - dist(obj.x, obj.y, width / 2, height / 2) / (width / 2 + height / 2);

				if (obj.t > PI && pobj.t < PI * 1.5 || obj.t > 0 && pobj.t < PI) {
					stroke(0, 0, 255 * pow(dst * 1.5, 8), 255);
				} else {
					stroke(0, 0, 255 * pow(dst * 1.75, 2), 255);
				}

		 		line(obj.x, obj.y, pobj.x, pobj.y);
				
				if (nx > 1) {
					var n2 = parseInt((nx - 1) + ny * nnx);
					var obj2 = objs[n2];
				
					var n3 = parseInt((nx - 1) + im1 * nnx);
					var obj3 = objs[n3];
					
					//noStroke();
					//fill(0, 0, 255 * pow(dst * 2.5, 3), 255);
					var ld = parseInt(width / 2 * (1 / nnx), 10);
					for (var f = 1; f < ld; f += 1) {
						var ff = f;
						var nf = 1 - (f / ld);
					
						stroke(0, 0, 255 * pow(dst, 4) * nf, 255);
						/*fill(0, 128, 255, 255);
						rect(obj.x, obj.y, 4, 4);
						fill(64, 128, 255, 255);
						rect(pobj.x, pobj.y, 4, 4);
						fill(128, 128, 255, 255);
						rect(obj3.x, obj3.y, 4, 4);
						fill(192, 128, 255, 255);
						rect(obj2.x, obj2.y, 4, 4);*/
						if (obj.t > PI && pobj.t < PI * 1.5 || obj.t > 0 && pobj.t < PI * 0.5) {
							quad(obj.x + obj.tx * ff, obj.y + obj.ty * ff,// * 2, 
									 pobj.x + pobj.tx * ff, pobj.y + pobj.ty * ff,// * 2, 
									 obj3.x - obj3.tx * ff, obj3.y - obj3.ty * ff, 
									 obj2.x - obj2.tx * ff, obj2.y - obj2.ty * ff);
						} else {
							quad(obj.x + obj.tx * ff, obj.y + obj.ty * ff, 
									 pobj.x + pobj.tx * ff, pobj.y + pobj.ty * ff, 
									 obj3.x - obj3.tx * ff, obj3.y - obj3.ty * ff, 
									 obj2.x - obj2.tx * ff, obj2.y - obj2.ty * ff);
						}
					}
				}

				if (nx > 1) {
					var n2 = parseInt((nx - 1) + ny * nnx);
					var obj2 = objs[n2];
					line(obj.x, obj.y, obj2.x, obj2.y);
					
					var n3 = parseInt((nx - 1) + im1 * nnx);
					var obj3 = objs[n3];
					line(pobj.x, pobj.y, obj3.x, obj3.y);
				}

/*
				var ld = parseInt(width / 2 * (1 / nnx), 10);

				for (var f = 1; f < ld; f += 1) {
					var ff = 1 - f;
					var nf = 1 - (f / ld);
					
					stroke(0, 0, 255 * pow((nx * 2) / nny, 3) * nf, 255);
					
					if (obj.t > PI && pobj.t < PI * 1.5 || obj.t > 0 && pobj.t < PI * 0.5) {
						line(obj.x + obj.tx * ff, obj.y, pobj.x + pobj.tx * ff, pobj.y);
					} else {
						line(obj.x, obj.y + obj.ty * ff, pobj.x, pobj.y + pobj.ty * ff);
					}
				}
*/
			}
			//noStroke();
			//stroke(0, 0, color, t);
			//ellipse(obj.lx, obj.ly, 1, 1);
	 	}
	}
}

function draw() {
	noStroke();
	
	rectMode(CORNER);

	fill(0, 0, 0, 24);
	rect(0, 0, width, height);

	rectMode(CENTER);
	
	compute();
	
	xmotion += 0.05;
	ymotion += 0.0002;
}"
"802128","Pathway","mySketch","var xmotion = 0;
var ymotion = 0;

var objs = [];

var nnx = 148;
var nny = 24;
var nnf = 2;

function setup() {
	createCanvas(800, 800);
	
	smooth();
	
	colorMode(HSB, 360, 255, 255);
	
	background(0);
	
	noiseDetail(7, 0.7);
	
	for (var nx = 1; nx < nnx; nx += 1) {
	 var nmx = nx / nnx;
	 for (var ny = 0; ny < nny; ny += 1) {
		var n = parseInt(nx + ny * nnx);
		 
		var nmy = ny / nny;
		
		var no = noise(nmx * nmy);
		 
		var t = nmy * PI * 2;

		var dstx = abs(nx - width / 2) / (width / 2);
		var dsty = abs(ny - height / 2) / (width / 2);
		var dst = (dstx + dsty) / 2;
		 
		objs[n] = {
			x: width / 2 + (abs(cos(t)) * cos(t) + abs(sin(t)) * sin(t)) * (width / 2 * nmx) + ((0.5 - noise(nx, ny)) * 2 * 4),
			y: height / 2 + (abs(cos(t)) * cos(t) - abs(sin(t)) * sin(t)) * (height / 2 * nmx) + ((0.5 - noise(nx, ny)) * 2 * 4),
			tx: (abs(cos(t)) * cos(t) + abs(sin(t)) * sin(t)),
			ty: (abs(cos(t)) * cos(t) - abs(sin(t)) * sin(t)),
			t: t
		};
	 }
	}
	
	ellipseMode(CENTER);
	rectMode(CENTER);
}

function compute() {
	noFill();
	
	strokeWeight(1);

	for (var nx = 16; nx < nnx; nx += 1) {
		var nmx = nx / nnx;
	 	for (var ny = 0; ny < nny; ny += 1) {
			var n = parseInt(nx + ny * nnx);
			var obj = objs[n];
			
			var im1 = ny - 1;
			if (im1 < 0) { im1 = nny - 1; }
			var nm1 = parseInt(nx + im1 * nnx);
			var pobj = objs[nm1];

			if (noise(nx, ny) > 0.5) {
				var dst = 1 - dist(obj.x, obj.y, width / 2, height / 2) / (width / 2 + height / 2);

				if (obj.t > PI && pobj.t < PI * 1.5 || obj.t > 0 && pobj.t < PI) {
					stroke(0, 0, 255 * pow(dst * 1.5, 8), 255);
				} else {
					stroke(0, 0, 255 * pow(dst * 1.75, 2), 255);
				}

		 		line(obj.x, obj.y, pobj.x, pobj.y);
				
				if (nx > 1) {
					var n2 = parseInt((nx - 1) + ny * nnx);
					var obj2 = objs[n2];
				
					var n3 = parseInt((nx - 1) + im1 * nnx);
					var obj3 = objs[n3];
					
					//noStroke();
					//fill(0, 0, 255 * pow(dst * 2.5, 3), 255);
					var ld = parseInt(width / 2 * (1 / nnx), 10);
					for (var f = 1; f < ld; f += 1) {
						var ff = f;
						var nf = (1 - (f / ld));
					
						stroke(0, 0, 255 * pow(dst, 4) * nf, 255);
						/*fill(0, 128, 255, 255);
						rect(obj.x, obj.y, 4, 4);
						fill(64, 128, 255, 255);
						rect(pobj.x, pobj.y, 4, 4);
						fill(128, 128, 255, 255);
						rect(obj3.x, obj3.y, 4, 4);
						fill(192, 128, 255, 255);
						rect(obj2.x, obj2.y, 4, 4);*/
						if (obj.t > PI && pobj.t < PI * 1.5 || obj.t > 0 && pobj.t < PI * 0.5) {
							quad(obj.x + obj.tx * ff, obj.y + obj.ty * ff,// * 2, 
									 pobj.x + pobj.tx * ff, pobj.y + pobj.ty * ff,// * 2, 
									 obj3.x - obj3.tx * ff, obj3.y - obj3.ty * ff, 
									 obj2.x - obj2.tx * ff, obj2.y - obj2.ty * ff);
						} else {
							quad(obj.x + obj.tx * ff, obj.y + obj.ty * ff, 
									 pobj.x + pobj.tx * ff, pobj.y + pobj.ty * ff, 
									 obj3.x - obj3.tx * ff, obj3.y - obj3.ty * ff, 
									 obj2.x - obj2.tx * ff, obj2.y - obj2.ty * ff);
						}
					}
				}

				if (nx > 1) {
					var n2 = parseInt((nx - 1) + ny * nnx);
					var obj2 = objs[n2];
					line(obj.x, obj.y, obj2.x, obj2.y);
					
					var n3 = parseInt((nx - 1) + im1 * nnx);
					var obj3 = objs[n3];
					line(pobj.x, pobj.y, obj3.x, obj3.y);
				}

/*
				var ld = parseInt(width / 2 * (1 / nnx), 10);

				for (var f = 1; f < ld; f += 1) {
					var ff = 1 - f;
					var nf = 1 - (f / ld);
					
					stroke(0, 0, 255 * pow((nx * 2) / nny, 3) * nf, 255);
					
					if (obj.t > PI && pobj.t < PI * 1.5 || obj.t > 0 && pobj.t < PI * 0.5) {
						line(obj.x + obj.tx * ff, obj.y, pobj.x + pobj.tx * ff, pobj.y);
					} else {
						line(obj.x, obj.y + obj.ty * ff, pobj.x, pobj.y + pobj.ty * ff);
					}
				}
*/
			}
			//noStroke();
			//stroke(0, 0, color, t);
			//ellipse(obj.lx, obj.ly, 1, 1);
	 	}
	}
}

function draw() {
	noStroke();
	
	rectMode(CORNER);

	fill(0, 0, 0, 24);
	rect(0, 0, width, height);

	rectMode(CENTER);
	
	compute();
	
	xmotion += 0.05;
	ymotion += 0.0002;
}"
"802128","Pathway","mySketch","var xmotion = 0;
var ymotion = 0;

var objs = [];

var nnx = 148;
var nny = 24;
var nnf = 2;

function setup() {
	createCanvas(800, 800);
	
	smooth();
	
	colorMode(HSB, 360, 255, 255);
	
	background(0);
	
	noiseDetail(7, 0.7);
	
	for (var nx = 1; nx < nnx; nx += 1) {
	 var nmx = nx / nnx;
	 for (var ny = 0; ny < nny; ny += 1) {
		var n = parseInt(nx + ny * nnx);
		 
		var nmy = ny / nny;
		
		var no = noise(nmx * nmy);
		 
		var t = nmy * PI * 2;

		var dstx = abs(nx - width / 2) / (width / 2);
		var dsty = abs(ny - height / 2) / (width / 2);
		var dst = (dstx + dsty) / 2;
		 
		objs[n] = {
			x: width / 2 + (abs(cos(t)) * cos(t) + abs(sin(t)) * sin(t)) * (width / 2 * nmx) + ((0.5 - noise(nx, ny)) * 2 * 4),
			y: height / 2 + (abs(cos(t)) * cos(t) - abs(sin(t)) * sin(t)) * (height / 2 * nmx) + ((0.5 - noise(nx, ny)) * 2 * 4),
			tx: (abs(cos(t)) * cos(t) + abs(sin(t)) * sin(t)),
			ty: (abs(cos(t)) * cos(t) - abs(sin(t)) * sin(t)),
			t: t
		};
	 }
	}
	
	ellipseMode(CENTER);
	rectMode(CENTER);
}

function compute() {
	noFill();
	
	strokeWeight(1);

	for (var nx = 16; nx < nnx; nx += 1) {
		var nmx = nx / nnx;
	 	for (var ny = 0; ny < nny; ny += 1) {
			var n = parseInt(nx + ny * nnx);
			var obj = objs[n];
			
			var im1 = ny - 1;
			if (im1 < 0) { im1 = nny - 1; }
			var nm1 = parseInt(nx + im1 * nnx);
			var pobj = objs[nm1];

			if (noise(nx, ny) > 0.5) {
				var dst = 1 - dist(obj.x, obj.y, width / 2, height / 2) / (width / 2 + height / 2);

				if (obj.t > PI && pobj.t < PI * 1.5 || obj.t > 0 && pobj.t < PI) {
					stroke(0, 0, 255 * pow(dst * 1.5, 8), 255);
				} else {
					stroke(0, 0, 255 * pow(dst * 1.75, 2), 255);
				}

		 		line(obj.x, obj.y, pobj.x, pobj.y);
				
				if (nx > 1) {
					var n2 = parseInt((nx - 1) + ny * nnx);
					var obj2 = objs[n2];
				
					var n3 = parseInt((nx - 1) + im1 * nnx);
					var obj3 = objs[n3];
					
					//noStroke();
					//fill(0, 0, 255 * pow(dst * 2.5, 3), 255);
					var ld = parseInt(width / 2 * (1 / nnx), 10);
					for (var f = 1; f < ld; f += 1) {
						var ff = f;
						var nf = (1 - (f / ld));
					
						stroke(0, 0, 255 * pow(dst, 4) * nf, 255);
						/*fill(0, 128, 255, 255);
						rect(obj.x, obj.y, 4, 4);
						fill(64, 128, 255, 255);
						rect(pobj.x, pobj.y, 4, 4);
						fill(128, 128, 255, 255);
						rect(obj3.x, obj3.y, 4, 4);
						fill(192, 128, 255, 255);
						rect(obj2.x, obj2.y, 4, 4);*/
						if (obj.t > PI && pobj.t < PI * 1.5 || obj.t > 0 && pobj.t < PI * 0.5) {
							quad(obj.x + obj.tx * ff, obj.y + obj.ty * ff,// * 2, 
									 pobj.x + pobj.tx * ff, pobj.y + pobj.ty * ff,// * 2, 
									 obj3.x - obj3.tx * ff, obj3.y - obj3.ty * ff, 
									 obj2.x - obj2.tx * ff, obj2.y - obj2.ty * ff);
						} else {
							quad(obj.x + obj.tx * ff, obj.y + obj.ty * ff, 
									 pobj.x + pobj.tx * ff, pobj.y + pobj.ty * ff, 
									 obj3.x - obj3.tx * ff, obj3.y - obj3.ty * ff, 
									 obj2.x - obj2.tx * ff, obj2.y - obj2.ty * ff);
						}
					}
				}

				if (nx > 1) {
					var n2 = parseInt((nx - 1) + ny * nnx);
					var obj2 = objs[n2];
					line(obj.x, obj.y, obj2.x, obj2.y);
					
					var n3 = parseInt((nx - 1) + im1 * nnx);
					var obj3 = objs[n3];
					line(pobj.x, pobj.y, obj3.x, obj3.y);
				}

/*
				var ld = parseInt(width / 2 * (1 / nnx), 10);

				for (var f = 1; f < ld; f += 1) {
					var ff = 1 - f;
					var nf = 1 - (f / ld);
					
					stroke(0, 0, 255 * pow((nx * 2) / nny, 3) * nf, 255);
					
					if (obj.t > PI && pobj.t < PI * 1.5 || obj.t > 0 && pobj.t < PI * 0.5) {
						line(obj.x + obj.tx * ff, obj.y, pobj.x + pobj.tx * ff, pobj.y);
					} else {
						line(obj.x, obj.y + obj.ty * ff, pobj.x, pobj.y + pobj.ty * ff);
					}
				}
*/
			}
			//noStroke();
			//stroke(0, 0, color, t);
			//ellipse(obj.lx, obj.ly, 1, 1);
	 	}
	}
}

function draw() {
	noStroke();
	
	rectMode(CORNER);

	fill(0, 0, 0, 24);
	rect(0, 0, width, height);

	rectMode(CENTER);
	
	compute();
	
	xmotion += 0.05;
	ymotion += 0.0002;
}"
"802128","Pathway","mySketch","var xmotion = 0;
var ymotion = 0;

var objs = [];

var nnx = 148;
var nny = 4;
var nnf = 2;

function setup() {
	createCanvas(800, 800);
	
	smooth();
	
	colorMode(HSB, 360, 255, 255);
	
	background(0);
	
	noiseDetail(7, 0.7);
	
	for (var nx = 1; nx < nnx; nx += 1) {
	 var nmx = nx / nnx;
	 for (var ny = 0; ny < nny; ny += 1) {
		var n = parseInt(nx + ny * nnx);
		 
		var nmy = ny / nny;
		
		var no = noise(nmx * nmy);
		 
		var t = nmy * PI * 2;

		var dstx = abs(nx - width / 2) / (width / 2);
		var dsty = abs(ny - height / 2) / (width / 2);
		var dst = (dstx + dsty) / 2;
		 
		objs[n] = {
			x: width / 2 + (abs(cos(t)) * cos(t) + abs(sin(t)) * sin(t)) * (width / 2 * nmx) + ((0.5 - noise(nx, ny)) * 2 * 4),
			y: height / 2 + (abs(cos(t)) * cos(t) - abs(sin(t)) * sin(t)) * (height / 2 * nmx) + ((0.5 - noise(nx, ny)) * 2 * 4),
			tx: (abs(cos(t)) * cos(t) + abs(sin(t)) * sin(t)),
			ty: (abs(cos(t)) * cos(t) - abs(sin(t)) * sin(t)),
			t: t
		};
	 }
	}
	
	ellipseMode(CENTER);
	rectMode(CENTER);
}

function compute() {
	noFill();
	
	strokeWeight(1);

	for (var nx = 16; nx < nnx; nx += 1) {
		var nmx = nx / nnx;
	 	for (var ny = 0; ny < nny; ny += 1) {
			var n = parseInt(nx + ny * nnx);
			var obj = objs[n];
			
			var im1 = ny - 1;
			if (im1 < 0) { im1 = nny - 1; }
			var nm1 = parseInt(nx + im1 * nnx);
			var pobj = objs[nm1];

			if (noise(nx, ny) > 0.5) {
				var dst = 1 - dist(obj.x, obj.y, width / 2, height / 2) / (width / 2 + height / 2);

				if (obj.t > PI && pobj.t < PI * 1.5 || obj.t > 0 && pobj.t < PI) {
					stroke(0, 0, 255 * pow(dst * 1.5, 8), 255);
				} else {
					stroke(0, 0, 255 * pow(dst * 1.75, 2), 255);
				}

		 		line(obj.x, obj.y, pobj.x, pobj.y);
				
				if (nx > 1) {
					var n2 = parseInt((nx - 1) + ny * nnx);
					var obj2 = objs[n2];
				
					var n3 = parseInt((nx - 1) + im1 * nnx);
					var obj3 = objs[n3];
					
					//noStroke();
					//fill(0, 0, 255 * pow(dst * 2.5, 3), 255);
					var ld = parseInt(width / 2 * (1 / nnx), 10);
					for (var f = 1; f < ld; f += 1) {
						var ff = f;
						var nf = (1 - (f / ld));
					
						stroke(0, 0, 255 * pow(dst, 4) * nf, 255);
						/*fill(0, 128, 255, 255);
						rect(obj.x, obj.y, 4, 4);
						fill(64, 128, 255, 255);
						rect(pobj.x, pobj.y, 4, 4);
						fill(128, 128, 255, 255);
						rect(obj3.x, obj3.y, 4, 4);
						fill(192, 128, 255, 255);
						rect(obj2.x, obj2.y, 4, 4);*/
						if (obj.t > PI && pobj.t < PI * 1.5 || obj.t > 0 && pobj.t < PI * 0.5) {
							quad(obj.x + obj.tx * ff, obj.y + obj.ty * ff,// * 2, 
									 pobj.x + pobj.tx * ff, pobj.y + pobj.ty * ff,// * 2, 
									 obj3.x - obj3.tx * ff, obj3.y - obj3.ty * ff, 
									 obj2.x - obj2.tx * ff, obj2.y - obj2.ty * ff);
						} else {
							quad(obj.x + obj.tx * ff, obj.y + obj.ty * ff, 
									 pobj.x + pobj.tx * ff, pobj.y + pobj.ty * ff, 
									 obj3.x - obj3.tx * ff, obj3.y - obj3.ty * ff, 
									 obj2.x - obj2.tx * ff, obj2.y - obj2.ty * ff);
						}
					}
				}

				if (nx > 1) {
					var n2 = parseInt((nx - 1) + ny * nnx);
					var obj2 = objs[n2];
					line(obj.x, obj.y, obj2.x, obj2.y);
					
					var n3 = parseInt((nx - 1) + im1 * nnx);
					var obj3 = objs[n3];
					line(pobj.x, pobj.y, obj3.x, obj3.y);
				}

/*
				var ld = parseInt(width / 2 * (1 / nnx), 10);

				for (var f = 1; f < ld; f += 1) {
					var ff = 1 - f;
					var nf = 1 - (f / ld);
					
					stroke(0, 0, 255 * pow((nx * 2) / nny, 3) * nf, 255);
					
					if (obj.t > PI && pobj.t < PI * 1.5 || obj.t > 0 && pobj.t < PI * 0.5) {
						line(obj.x + obj.tx * ff, obj.y, pobj.x + pobj.tx * ff, pobj.y);
					} else {
						line(obj.x, obj.y + obj.ty * ff, pobj.x, pobj.y + pobj.ty * ff);
					}
				}
*/
			}
			//noStroke();
			//stroke(0, 0, color, t);
			//ellipse(obj.lx, obj.ly, 1, 1);
	 	}
	}
}

function draw() {
	noStroke();
	
	rectMode(CORNER);

	fill(0, 0, 0, 24);
	rect(0, 0, width, height);

	rectMode(CENTER);
	
	compute();
	
	xmotion += 0.05;
	ymotion += 0.0002;
}"
"795309","Monolithe","mySketch","// going further with a bit of composition

var xmotion = 0;
var ymotion = 0;

var objs = [];
var trail_map = [];

var nnx = 1000;
var nny = 5;

function setup() {
	createCanvas(800, 800);
	
	colorMode(HSB, 360, 255, 255);
	
	background(0);
	
	noiseDetail(7, 0.7);
	
	var inc = 0;
	for (var nx = 0; nx < nnx; nx += 1) {
	 var nmx = nx / nnx;
	 for (var ny = 0; ny < nny; ny += 1) {
		var n = parseInt(nx + ny * nnx);
		 
		var nmy = ny / nny;
		
		var no = noise(nmx * 2, nmy * 2);
		 
		var ni = inc / (nnx * nny);
		
		var t = nmx * PI * 2;
		var t2 = nmy * PI;
		 
		var dstx = abs(nx - width / 2) / (width / 2);
		var dsty = abs(ny - height / 2) / (width / 2);
		var dst = (dstx + dsty) / 2;
		 
		objs[n] = {
			// paper
			//lx: width * nmx,
			//ly: height * nmy,
			lx: width / 2 + (abs(cos(t)) * cos(t) + abs(sin(t)) * sin(t)) * (width / 2.5 - width / 8 * t2),//sin(nmx * PI * 2 + no / 2) * (width / 3.5),
			ly: height / 2 + (abs(cos(t)) * cos(t) - abs(sin(t)) * sin(t)) * (height / 1.7 - height / 8 * t2),//cos(nmx * PI * 2 + no / 2) * (height / 3.5),
			// paper
			//la: random(-PI * 2, PI * 2),
			la: t, // modify this for more shapes
			// paper : 1
			lv: 1,
			d: 1,
			n: no,
			so: 8, // agent sensor offset,
			sa: 45,// agent sensor angle (degree),
			t: t2
		};
		 
		if (t2 > PI/1.5) {
			objs[n].lx = width / 2 + cos(t) * (width / 2.5 - width / 8 * t2);
			objs[n].ly = height / 2 + sin(t) * (height / 2.5 - height / 8 * t2);
		}
		 
		inc += 1;
	 }
	}
	
	for (var nx = 0; nx < nnx; nx += 1) {
	 for (var ny = 0; ny < nny; ny += 1) {
		var dstx = abs(nx - width / 2) / (width / 2);
		var dsty = abs(ny - height / 2) / (width / 2);
		var dst = (dstx + dsty) / 2;
		 
		trail_map[nx + ny * width] = dst * 5;//i / (width * height);
	 }
	}
	
	ellipseMode(CENTER);
	rectMode(CENTER);
}

function compute() {
	fill(0);
	
	strokeWeight(2);

	for (var nx = 0; nx < nnx; nx += 1) {
	 for (var ny = 0; ny < nny; ny += 1) {
		var n = parseInt(nx + ny * nnx);
		 
		var obj = objs[n];
		
		var sensor_offset = obj.so;
		var sensor_angle = radians(obj.sa);
		
		// agent sensors
		var lhx = round(sin(obj.la - sensor_angle) * sensor_offset);
		var lhy = round(cos(obj.la - sensor_angle) * sensor_offset);
		var fhx = round(sin(obj.la) * sensor_offset);
		var fhy = round(cos(obj.la) * sensor_offset);
		var rhx = round(sin(obj.la + sensor_angle) * sensor_offset);
		var rhy = round(cos(obj.la + sensor_angle) * sensor_offset);
		
		var ailx = parseInt(obj.lx + lhx);
		var aily = parseInt(obj.ly + lhy);
		var aifx = parseInt(obj.lx + fhx);
		var aify = parseInt(obj.ly + fhy);
		var airx = parseInt(obj.lx + rhx);
		var airy = parseInt(obj.ly + rhy);
		
		ailx = ailx < 0 ? ailx + width : ailx;
		aily = aily < 0 ? aily + height : aily;
		aifx = aifx < 0 ? aifx + width : aifx;
		aify = aify < 0 ? aify + height : aify;
		airx = airx < 0 ? airx + width : airx;
		airy = airy < 0 ? airy + height : airy;
		
		ailx %= width;
		aily %= height;
		aifx %= width;
		aify %= height;
		airx %= width;
		airy %= height;
		
		// sensor sample
		var s1 = trail_map[ailx + aily * width]; // left
		var s2 = trail_map[aifx + aify * width]; // forward
		var s3 = trail_map[airx + airy * width]; // right
		
/*
		// debug sensor
		fill(255, 0, 0, 255);
		rect(ailx, aily, 1, 1);
		rect(aifx, aify, 1, 1);
		rect(airx, airy, 1, 1);
*/	
/*
		if (frameCount % 60 == 0) {
			obj.la += PI / 2;
		}
*/
	
		// agent behavior based on sampled sensor
		if (s2 < s1 && s2 < s3) {
			// turn left or right randomly
			//obj.la += random(PI / 2, -PI / 2);
			// paper
			//obj.la += (random() > 0.5 ? PI / 16 : -PI / 16);
		} else if (s1 < s3) {
			// turn left
			obj.la -= PI / 1.1 * ((obj.t > PI*1.5) ? 1 : obj.t);
		} else if (s3 < s1) {
			// turn right
			obj.la += PI / 1.1 * ((obj.t > PI*1.5) ? 1 : obj.t);
		}
		
		if (obj.t> PI/1.5) {
			obj.lx += obj.lv * sin(obj.la);
			obj.ly += obj.lv * cos(obj.la);
		} else {
			obj.lx += obj.lv * ((abs(cos(obj.la)) * cos(obj.la) + abs(sin(obj.la)) * sin(obj.la)));
			obj.ly += obj.lv * ((abs(cos(obj.la)) * cos(obj.la) - abs(sin(obj.la)) * sin(obj.la)));	
		}
		 
		 if (obj.lx < 0 || obj.lx > width) {
				continue; 
		 }
		 
		 if (obj.ly < 0 || obj.ly > height) {
				continue; 
		 }
		
		// boundary checks
		/*obj.lx = obj.lx < 0 ? obj.lx + width - 1 : obj.lx;
		obj.lx %= width;
		obj.ly = obj.ly < 0 ? obj.ly + height - 1 : obj.ly;
		obj.ly %= height;*/
		
		// deposit diffusion (3x3 mean kernel)
		// should probably go after deposit step though
		var i = parseInt(obj.lx + obj.ly * width);
		var b = trail_map[i] / 2;

		var lx = parseInt(obj.lx);
		var ly = parseInt(obj.ly);

		var xb = (lx - 1);
		var yb = (ly - 1);
		var xbl = xb < 0 ? width - 1 : xb;
		var ybl = yb < 0 ? height - 1 : yb;
		var xbu = (lx + 1) % width;
		var ybu = (ly + 1) % height;
		/*
		var v1 = trail_map[xbl + ly * width];
		var v2 = trail_map[xbu + ly * width];
		var v3 = trail_map[xbl + ybl * width];
		var v4 = trail_map[xbl + ybu * width];
		var v5 = trail_map[xbu + ybl * width];
		var v6 = trail_map[xbu + ybu * width];
		var v7 = trail_map[lx + ybl * width];
		var v8 = trail_map[lx + ybu * width];
		
		var vm = (v1 + v2 + v3 + v4 + v5 + v6 + v7 + v8) / 8 / 5;
		*/
		trail_map[xbl + ly * width] = b;
		trail_map[xbu + ly * width] = b;
		trail_map[xbl + ybl * width] = b;
		trail_map[xbl + ybu * width] = b;
		trail_map[xbu + ybl * width] = b;
		trail_map[xbu + ybu * width] = b;
		trail_map[lx + ybl * width] = b;
		trail_map[lx + ybu * width] = b;
		
		// deposit
		trail_map[i] = obj.d;
		
		// agent display
		var ll = 380;
		var t = (noise(obj.lx / width + obj.ly / height + obj.n + xmotion * 4)) * (pow((1 - min(ll, frameCount) / ll), 2.5));
		 
		var dstx = abs(obj.lx - width / 2) / (width / 2);
		var dsty = abs(obj.ly - height / 2) / (width / 2);
		var dst = (dstx + dsty) / 2;

		var sph = (1 - abs((0.5 - obj.lx / width) * 2));
		var color = 160 + noise(obj.lx / width + obj.ly / height + obj.la + xmotion * 2) * 96;
		 
		fill(0, 0, color, t/* * dst*/);
		noStroke();
		//stroke(0, 0, color, t);
		ellipse(obj.lx, obj.ly, 1, 1);
		
/*
		if (trail_map[parseInt(i)] > 1) {
			trail_map[parseInt(i)] = 1;
		}
*/
	 }
	}
	
	// deposit decay
	for (var y = 0; y < height; y += 1) {
		for (var x = 0; x < width; x += 1) {
			var v = trail_map[x + y * width];
			trail_map[x + y * width] -= 0.1;
			if (trail_map[x + y * width] < 0) {
				trail_map[x + y * width] = 0;
			}
		}
	}
/*
	if (frameCount % 60 == 0) {
		var st = 1 + parseInt(random() * (nn / 8));
		for (var y = 0; y < nn; y += st) {
			objs[y].lx = random() * width;
			objs[y].ly = random() * height;
		}
	}
*/
}

function draw() {
	noStroke();
	
	rectMode(CORNER);
/*
	fill(0, 0, 0, 8);
	rect(0, 0, width, height);
*/
	rectMode(CENTER);
	
	compute();
	
	xmotion += 0.05;
	ymotion += 0.0002;
}"
"794367","Scribble","mySketch","// same as ""slime mold simulation""

var xmotion = 0;
var ymotion = 0;

var objs = [];
var trail_map = [];

var nnx = 500;
var nny = 8;

function setup() {
	createCanvas(800, 800);
	
	colorMode(HSB, 360, 255, 255);
	
	background(0);
	
	noiseDetail(7, 0.7);
	
	var inc = 0;
	for (var nx = 0; nx < nnx; nx += 1) {
	 var nmx = nx / nnx;
	 for (var ny = 0; ny < nny; ny += 1) {
		var n = parseInt(nx + ny * nnx);
		 
		var nmy = ny / nny;
		
		var no = noise(nmx * nmy);
		 
		var ni = inc / (nnx * nny);
		
		objs[n] = {
			lx: width / 2 + sin(nmx * PI * 2 * round(abs(0.5-n)*2)) * (width / 1.5 * ni - (width / 640) * nmy),
			ly: height / 2 + cos(nmx * PI * 2 * round(abs(0.5-n)*2)) * (height / 1.5 * ni - (height / 640) * nmy),
			// paper
			//la: random(-PI * 2, PI * 2),
			la: ni * PI * 2, // modify this for more shapes
			// paper : 1
			lv: 1,
			d: 1,
			n: no,
			so: 9, // agent sensor offset,
			sa: 45// agent sensor angle (degree)
		};
		 
		inc += 1;
	 }
	}
	
	for (var i = 0; i < width * height; i += 1) {
		trail_map[i] = 0;//i / (width * height);
	}
	
	ellipseMode(CENTER);
	rectMode(CENTER);
}

function compute() {
	fill(0);
	
	strokeWeight(1);

	for (var nx = 0; nx < nnx; nx += 1) {
	 for (var ny = 0; ny < nny; ny += 1) {
		var n = parseInt(nx + ny * nnx);
		 
		var obj = objs[n];
		
		var sensor_offset = obj.so;
		var sensor_angle = radians(obj.sa);
		
		// agent sensors
		var lhx = round(sin(obj.la - sensor_angle) * sensor_offset);
		var lhy = round(cos(obj.la - sensor_angle) * sensor_offset);
		var fhx = round(sin(obj.la) * sensor_offset);
		var fhy = round(cos(obj.la) * sensor_offset);
		var rhx = round(sin(obj.la + sensor_angle) * sensor_offset);
		var rhy = round(cos(obj.la + sensor_angle) * sensor_offset);
		
		var ailx = parseInt(obj.lx + lhx);
		var aily = parseInt(obj.ly + lhy);
		var aifx = parseInt(obj.lx + fhx);
		var aify = parseInt(obj.ly + fhy);
		var airx = parseInt(obj.lx + rhx);
		var airy = parseInt(obj.ly + rhy);
		
		ailx = ailx < 0 ? ailx + width : ailx;
		aily = aily < 0 ? aily + height : aily;
		aifx = aifx < 0 ? aifx + width : aifx;
		aify = aify < 0 ? aify + height : aify;
		airx = airx < 0 ? airx + width : airx;
		airy = airy < 0 ? airy + height : airy;
		
		ailx %= width;
		aily %= height;
		aifx %= width;
		aify %= height;
		airx %= width;
		airy %= height;
		
		// sensor sample
		var s1 = trail_map[ailx + aily * width]; // left
		var s2 = trail_map[aifx + aify * width]; // forward
		var s3 = trail_map[airx + airy * width]; // right
		
/*
		// debug sensor
		fill(255, 0, 0, 255);
		rect(ailx, aily, 1, 1);
		rect(aifx, aify, 1, 1);
		rect(airx, airy, 1, 1);
*/	
/*
		if (frameCount % 60 == 0) {
			obj.la += PI / 2;
		}
*/
		var dstx = abs(obj.lx - width / 2) / (width / 2);
		var dsty = abs(obj.ly - height / 2) / (width / 2);
		var dst = (dstx + dsty) / 2;
		 
		// agent behavior based on sampled sensor
		if (s2 < s1 && s2 < s3) {
			// turn left or right randomly
			//obj.la += random(PI / 2, -PI / 2);
			// paper
			obj.la += (random() > 0.5 ? PI / 16 : -PI / 16);
		} else if (s1 < s3) {
			// turn left
			obj.la -= PI / 1.05 - round(PI*8 * dst);
		} else if (s3 < s1) {
			// turn right
			obj.la += PI / 1.05 + round(PI *8* dst);
		}
		
		obj.lx += obj.lv * sin(obj.la);
		obj.ly += obj.lv * cos(obj.la);
		 
		 if (obj.lx < 0 || obj.lx > width) {
				continue; 
		 }
		 
		 if (obj.ly < 0 || obj.ly > height) {
				continue; 
		 }
		
		// boundary checks
		/*obj.lx = obj.lx < 0 ? obj.lx + width - 1 : obj.lx;
		obj.lx %= width;
		obj.ly = obj.ly < 0 ? obj.ly + height - 1 : obj.ly;
		obj.ly %= height;*/
		
		// deposit diffusion (3x3 mean kernel)
		// should probably go after deposit step though
		var i = parseInt(obj.lx + obj.ly * width);
		var b = trail_map[i] / 2;

		var lx = parseInt(obj.lx);
		var ly = parseInt(obj.ly);

		var xb = (lx - 1);
		var yb = (ly - 1);
		var xbl = xb < 0 ? width - 1 : xb;
		var ybl = yb < 0 ? height - 1 : yb;
		var xbu = (lx + 1) % width;
		var ybu = (ly + 1) % height;
		/*
		var v1 = trail_map[xbl + ly * width];
		var v2 = trail_map[xbu + ly * width];
		var v3 = trail_map[xbl + ybl * width];
		var v4 = trail_map[xbl + ybu * width];
		var v5 = trail_map[xbu + ybl * width];
		var v6 = trail_map[xbu + ybu * width];
		var v7 = trail_map[lx + ybl * width];
		var v8 = trail_map[lx + ybu * width];
		
		var vm = (v1 + v2 + v3 + v4 + v5 + v6 + v7 + v8) / 8 / 5;
		*/
		trail_map[xbl + ly * width] = b;
		trail_map[xbu + ly * width] = b;
		trail_map[xbl + ybl * width] = b;
		trail_map[xbl + ybu * width] = b;
		trail_map[xbu + ybl * width] = b;
		trail_map[xbu + ybu * width] = b;
		trail_map[lx + ybl * width] = b;
		trail_map[lx + ybu * width] = b;
		
		// deposit
		trail_map[i] = obj.d;
		
		// agent display
		var ll = 600;
		var t = (noise(obj.n + xmotion * 4) * 2) * (pow((1 - min(ll, frameCount) / ll), 5.5));

		var sph = (1 - abs((0.5 - obj.lx / width) * 2));
		var color = 224 + noise(obj.n + xmotion * 2) * 32 * sph;
		fill(132 + dst * 148 * noise(obj.n + xmotion * 8), 24 * noise(obj.n + xmotion / 32), color, t * dst);
		noStroke();
		rect(obj.lx, obj.ly, 1, 1);
		
/*
		if (trail_map[parseInt(i)] > 1) {
			trail_map[parseInt(i)] = 1;
		}
*/
	 }
	}
	
	// deposit decay
	for (var y = 0; y < height; y += 1) {
		for (var x = 0; x < width; x += 1) {
			var v = trail_map[x + y * width];
			trail_map[x + y * width] -= 0.1;
			if (trail_map[x + y * width] < 0) {
				trail_map[x + y * width] = 0;
			}
		}
	}
/*
	if (frameCount % 60 == 0) {
		var st = 1 + parseInt(random() * (nn / 8));
		for (var y = 0; y < nn; y += st) {
			objs[y].lx = random() * width;
			objs[y].ly = random() * height;
		}
	}
*/
}

function draw() {
	noStroke();
	
	rectMode(CORNER);
/*
	fill(0, 0, 0, 8);
	rect(0, 0, width, height);
*/
	rectMode(CENTER);
	
	compute();
	
	xmotion += 0.05;
	ymotion += 0.0002;
}"
"794317","City","mySketch","// same as ""slime mold simulation""

var xmotion = 0;
var ymotion = 0;

var objs = [];
var trail_map = [];

var nnx = 500;
var nny = 8;

function setup() {
	createCanvas(800, 800);
	
	colorMode(HSB, 360, 255, 255);
	
	background(0);
	
	noiseDetail(7, 0.7);
	
	var inc = 0;
	for (var nx = 0; nx < nnx; nx += 1) {
	 var nmx = nx / nnx;
	 for (var ny = 0; ny < nny; ny += 1) {
		var n = parseInt(nx + ny * nnx);
		 
		var nmy = ny / nny;
		
		var no = noise(nmx * nmy);
		 
		var ni = inc / (nnx * nny);
		
		objs[n] = {
			lx: width / 2 + sin(nmx * PI * 2) * (width / 3.5),
			ly: height / 2 + cos(nmx * PI * 2) * (height / 3.5),
			// paper
			//la: random(-PI * 2, PI * 2),
			la: PI + nmx * PI * 2, // modify this for more shapes
			// paper : 1
			lv: 1,
			d: 1,
			n: no,
			so: 2, // agent sensor offset,
			sa: 8// agent sensor angle (degree)
		};
		 
		inc += 1;
	 }
	}
	
	for (var i = 0; i < width * height; i += 1) {
		trail_map[i] = 0;//i / (width * height);
	}
	
	ellipseMode(CENTER);
	rectMode(CENTER);
}

function compute() {
	fill(0);
	
	strokeWeight(2);

	for (var nx = 0; nx < nnx; nx += 1) {
	 for (var ny = 0; ny < nny; ny += 1) {
		var n = parseInt(nx + ny * nnx);
		 
		var obj = objs[n];
		
		var sensor_offset = obj.so;
		var sensor_angle = radians(obj.sa);
		
		// agent sensors
		var lhx = round(sin(obj.la - sensor_angle) * sensor_offset);
		var lhy = round(cos(obj.la - sensor_angle) * sensor_offset);
		var fhx = round(sin(obj.la) * sensor_offset);
		var fhy = round(cos(obj.la) * sensor_offset);
		var rhx = round(sin(obj.la + sensor_angle) * sensor_offset);
		var rhy = round(cos(obj.la + sensor_angle) * sensor_offset);
		
		var ailx = parseInt(obj.lx + lhx);
		var aily = parseInt(obj.ly + lhy);
		var aifx = parseInt(obj.lx + fhx);
		var aify = parseInt(obj.ly + fhy);
		var airx = parseInt(obj.lx + rhx);
		var airy = parseInt(obj.ly + rhy);
		
		ailx = ailx < 0 ? ailx + width : ailx;
		aily = aily < 0 ? aily + height : aily;
		aifx = aifx < 0 ? aifx + width : aifx;
		aify = aify < 0 ? aify + height : aify;
		airx = airx < 0 ? airx + width : airx;
		airy = airy < 0 ? airy + height : airy;
		
		ailx %= width;
		aily %= height;
		aifx %= width;
		aify %= height;
		airx %= width;
		airy %= height;
		
		// sensor sample
		var s1 = trail_map[ailx + aily * width]; // left
		var s2 = trail_map[aifx + aify * width]; // forward
		var s3 = trail_map[airx + airy * width]; // right
		
/*
		// debug sensor
		fill(255, 0, 0, 255);
		rect(ailx, aily, 1, 1);
		rect(aifx, aify, 1, 1);
		rect(airx, airy, 1, 1);
*/	
/*
		if (frameCount % 60 == 0) {
			obj.la += PI / 2;
		}
*/
	
		// agent behavior based on sampled sensor
		if (s2 < s1 && s2 < s3) {
			// turn left or right randomly
			//obj.la += random(PI / 2, -PI / 2);
			// paper
			//obj.la += (random() > 0.5 ? PI / 16 : -PI / 16);
		} else if (s1 < s3) {
			// turn left
			obj.la -= PI / 2;
		} else if (s3 < s1) {
			// turn right
			obj.la += PI / 2;
		}
		
		obj.lx += obj.lv * sin(obj.la);
		obj.ly += obj.lv * cos(obj.la);
		 
		 if (obj.lx < 0 || obj.lx > width) {
				continue; 
		 }
		 
		 if (obj.ly < 0 || obj.ly > height) {
				continue; 
		 }
		
		// boundary checks
		/*obj.lx = obj.lx < 0 ? obj.lx + width - 1 : obj.lx;
		obj.lx %= width;
		obj.ly = obj.ly < 0 ? obj.ly + height - 1 : obj.ly;
		obj.ly %= height;*/
		
		// deposit diffusion (3x3 mean kernel)
		// should probably go after deposit step though
		var i = parseInt(obj.lx + obj.ly * width);
		var b = trail_map[i] / 2;

		var lx = parseInt(obj.lx);
		var ly = parseInt(obj.ly);

		var xb = (lx - 1);
		var yb = (ly - 1);
		var xbl = xb < 0 ? width - 1 : xb;
		var ybl = yb < 0 ? height - 1 : yb;
		var xbu = (lx + 1) % width;
		var ybu = (ly + 1) % height;
		/*
		var v1 = trail_map[xbl + ly * width];
		var v2 = trail_map[xbu + ly * width];
		var v3 = trail_map[xbl + ybl * width];
		var v4 = trail_map[xbl + ybu * width];
		var v5 = trail_map[xbu + ybl * width];
		var v6 = trail_map[xbu + ybu * width];
		var v7 = trail_map[lx + ybl * width];
		var v8 = trail_map[lx + ybu * width];
		
		var vm = (v1 + v2 + v3 + v4 + v5 + v6 + v7 + v8) / 8 / 5;
		*/
		trail_map[xbl + ly * width] = b;
		trail_map[xbu + ly * width] = b;
		trail_map[xbl + ybl * width] = b;
		trail_map[xbl + ybu * width] = b;
		trail_map[xbu + ybl * width] = b;
		trail_map[xbu + ybu * width] = b;
		trail_map[lx + ybl * width] = b;
		trail_map[lx + ybu * width] = b;
		
		// deposit
		trail_map[i] = obj.d;
		
		// agent display
		var ll = 400;
		var t = (noise(obj.n + xmotion * 4) * 2) * (pow((1 - min(ll, frameCount) / ll), 5.5));

		var sph = (1 - abs((0.5 - obj.lx / width) * 2));
		var color = 224 + noise(obj.n + xmotion * 2) * 32 * sph;
		fill(0, 0, color, t / 3);
		 noStroke();
		//stroke(0, 0, color, t);
		rect(obj.lx, obj.ly, 1, 1);
		
/*
		if (trail_map[parseInt(i)] > 1) {
			trail_map[parseInt(i)] = 1;
		}
*/
	 }
	}
	
	// deposit decay
	for (var y = 0; y < height; y += 1) {
		for (var x = 0; x < width; x += 1) {
			var v = trail_map[x + y * width];
			trail_map[x + y * width] -= 0.1;
			if (trail_map[x + y * width] < 0) {
				trail_map[x + y * width] = 0;
			}
		}
	}
/*
	if (frameCount % 60 == 0) {
		var st = 1 + parseInt(random() * (nn / 8));
		for (var y = 0; y < nn; y += st) {
			objs[y].lx = random() * width;
			objs[y].ly = random() * height;
		}
	}
*/
}

function draw() {
	noStroke();
	
	rectMode(CORNER);
/*
	fill(0, 0, 0, 8);
	rect(0, 0, width, height);
*/
	rectMode(CENTER);
	
	compute();
	
	xmotion += 0.05;
	ymotion += 0.0002;
}"
"794250","Continuum","mySketch","// same as ""slime mold simulation"" without particles

var xmotion = 0;
var ymotion = 0;

var objs = [];
var trail_map = [];

var nnx = 1000;
var nny = 5;

function setup() {
	createCanvas(800, 800);
	
	colorMode(HSB, 360, 255, 255);
	
	background(0);
	
	noiseDetail(7, 0.7);
	
	var inc = 0;
	for (var nx = 0; nx < nnx; nx += 1) {
	 var nmx = nx / nnx;
	 for (var ny = 0; ny < nny; ny += 1) {
		var n = parseInt(nx + ny * nnx);
		 
		var nmy = ny / nny;
		
		var no = noise(nmx * nmy);
		 
		var ni = inc / (nnx * nny);
		
		var t = nmx * PI * 4;
		var t2 = nmy * PI * 2;
		 
		var dstx = abs(nx - width / 2) / (width / 2);
		var dsty = abs(ny - height / 2) / (width / 2);
		var dst = (dstx + dsty) / 2;
		 
		objs[n] = {
			// paper
			//lx: width * nmx,
			//ly: height * nmy,
			lx: width / 2 + (abs(cos(t)) * cos(t) + abs(sin(t)) * sin(t)) * (width / 4.5 - width / 3 * t2),//sin(nmx * PI * 2 + no / 2) * (width / 3.5),
			ly: height / 2 + (abs(cos(t)) * cos(t) - abs(sin(t)) * sin(t)) * (height / 4.5 - height / 3 * t2),//cos(nmx * PI * 2 + no / 2) * (height / 3.5),
			// paper
			//la: random(-PI * 2, PI * 2),
			la: t, // modify this for more shapes
			// paper : 1
			lv: 1,
			d: 10,
			n: no,
			so: 64, // agent sensor offset,
			sa: 45// agent sensor angle (degree)
		};
		 
		inc += 1;
	 }
	}
	
	for (var nx = 0; nx < nnx; nx += 1) {
	 for (var ny = 0; ny < nny; ny += 1) {
		var dstx = abs(nx - width / 2) / (width / 2);
		var dsty = abs(ny - height / 2) / (width / 2);
		var dst = (dstx + dsty) / 2;
		 
		trail_map[nx + ny * width] = dst * 5;//i / (width * height);
	 }
	}
	
	ellipseMode(CENTER);
	rectMode(CENTER);
}

function compute() {
	fill(0);
	
	strokeWeight(2);

	for (var nx = 0; nx < nnx; nx += 1) {
	 for (var ny = 0; ny < nny; ny += 1) {
		var n = parseInt(nx + ny * nnx);
		 
		var obj = objs[n];
		
		var sensor_offset = obj.so;
		var sensor_angle = radians(obj.sa);
		
		// agent sensors
		var lhx = round(sin(obj.la - sensor_angle) * sensor_offset);
		var lhy = round(cos(obj.la - sensor_angle) * sensor_offset);
		var fhx = round(sin(obj.la) * sensor_offset);
		var fhy = round(cos(obj.la) * sensor_offset);
		var rhx = round(sin(obj.la + sensor_angle) * sensor_offset);
		var rhy = round(cos(obj.la + sensor_angle) * sensor_offset);
		
		var ailx = parseInt(obj.lx + lhx);
		var aily = parseInt(obj.ly + lhy);
		var aifx = parseInt(obj.lx + fhx);
		var aify = parseInt(obj.ly + fhy);
		var airx = parseInt(obj.lx + rhx);
		var airy = parseInt(obj.ly + rhy);
		
		ailx = ailx < 0 ? ailx + width : ailx;
		aily = aily < 0 ? aily + height : aily;
		aifx = aifx < 0 ? aifx + width : aifx;
		aify = aify < 0 ? aify + height : aify;
		airx = airx < 0 ? airx + width : airx;
		airy = airy < 0 ? airy + height : airy;
		
		ailx %= width;
		aily %= height;
		aifx %= width;
		aify %= height;
		airx %= width;
		airy %= height;
		
		// sensor sample
		var s1 = trail_map[ailx + aily * width]; // left
		var s2 = trail_map[aifx + aify * width]; // forward
		var s3 = trail_map[airx + airy * width]; // right
		
/*
		// debug sensor
		fill(255, 0, 0, 255);
		rect(ailx, aily, 1, 1);
		rect(aifx, aify, 1, 1);
		rect(airx, airy, 1, 1);
*/	
/*
		if (frameCount % 60 == 0) {
			obj.la += PI / 2;
		}
*/
	
		// agent behavior based on sampled sensor
		if (s2 < s1 && s2 < s3) {
			// turn left or right randomly
			//obj.la += random(PI / 2, -PI / 2);
			// paper
			//obj.la += (random() > 0.5 ? PI / 16 : -PI / 16);
		} else if (s1 < s3) {
			// turn left
			obj.la -= PI / 2;
		} else if (s3 < s1) {
			// turn right
			obj.la += PI / 2;
		}
		
		obj.lx += obj.lv * ((abs(cos(obj.la)) * cos(obj.la) + abs(sin(obj.la)) * sin(obj.la)));
		obj.ly += obj.lv * ((abs(cos(obj.la)) * cos(obj.la) - abs(sin(obj.la)) * sin(obj.la)));
		 
		 if (obj.lx < 0 || obj.lx > width) {
				continue; 
		 }
		 
		 if (obj.ly < 0 || obj.ly > height) {
				continue; 
		 }
		
		// boundary checks
		/*obj.lx = obj.lx < 0 ? obj.lx + width - 1 : obj.lx;
		obj.lx %= width;
		obj.ly = obj.ly < 0 ? obj.ly + height - 1 : obj.ly;
		obj.ly %= height;*/
		
		// deposit diffusion (3x3 mean kernel)
		// should probably go after deposit step though
		var i = parseInt(obj.lx + obj.ly * width);
		var b = trail_map[i] / 2;

		var lx = parseInt(obj.lx);
		var ly = parseInt(obj.ly);

		var xb = (lx - 1);
		var yb = (ly - 1);
		var xbl = xb < 0 ? width - 1 : xb;
		var ybl = yb < 0 ? height - 1 : yb;
		var xbu = (lx + 1) % width;
		var ybu = (ly + 1) % height;
		/*
		var v1 = trail_map[xbl + ly * width];
		var v2 = trail_map[xbu + ly * width];
		var v3 = trail_map[xbl + ybl * width];
		var v4 = trail_map[xbl + ybu * width];
		var v5 = trail_map[xbu + ybl * width];
		var v6 = trail_map[xbu + ybu * width];
		var v7 = trail_map[lx + ybl * width];
		var v8 = trail_map[lx + ybu * width];
		
		var vm = (v1 + v2 + v3 + v4 + v5 + v6 + v7 + v8) / 8 / 5;
		*/
		trail_map[xbl + ly * width] = b;
		trail_map[xbu + ly * width] = b;
		trail_map[xbl + ybl * width] = b;
		trail_map[xbl + ybu * width] = b;
		trail_map[xbu + ybl * width] = b;
		trail_map[xbu + ybu * width] = b;
		trail_map[lx + ybl * width] = b;
		trail_map[lx + ybu * width] = b;
		
		// deposit
		trail_map[i] = obj.d;
		
		// agent display
		var ll = 380;
		var t = (noise(obj.lx / width + obj.ly / height + obj.n + xmotion * 4)) * (pow((1 - min(ll, frameCount) / ll), 2.5));
		 
		var dstx = abs(obj.lx - width / 2) / (width / 2);
		var dsty = abs(obj.ly - height / 2) / (width / 2);
		var dst = (dstx + dsty) / 2;

		var sph = (1 - abs((0.5 - obj.lx / width) * 2));
		var color = 160 + noise(obj.lx / width + obj.ly / height + obj.la + xmotion * 2) * 96;
		fill(0, 0, color, t);
		 noStroke();
		//stroke(0, 0, color, t);
		ellipse(obj.lx, obj.ly, 1, 1);
		
/*
		if (trail_map[parseInt(i)] > 1) {
			trail_map[parseInt(i)] = 1;
		}
*/
	 }
	}
	
	// deposit decay
	for (var y = 0; y < height; y += 1) {
		for (var x = 0; x < width; x += 1) {
			var v = trail_map[x + y * width];
			trail_map[x + y * width] -= 0.1;
			if (trail_map[x + y * width] < 0) {
				trail_map[x + y * width] = 0;
			}
		}
	}
/*
	if (frameCount % 60 == 0) {
		var st = 1 + parseInt(random() * (nn / 8));
		for (var y = 0; y < nn; y += st) {
			objs[y].lx = random() * width;
			objs[y].ly = random() * height;
		}
	}
*/
}

function draw() {
	noStroke();
	
	rectMode(CORNER);
/*
	fill(0, 0, 0, 8);
	rect(0, 0, width, height);
*/
	rectMode(CENTER);
	
	compute();
	
	xmotion += 0.05;
	ymotion += 0.0002;
}"
"794130","Ball 2","mySketch","// same as ""slime mold simulation"" without particles

var xmotion = 0;
var ymotion = 0;

var objs = [];
var trail_map = [];

var nnx = 50;
var nny = 50;

function setup() {
	createCanvas(800, 800);
	
	colorMode(HSB, 360, 255, 255);
	
	background(0);
	
	noiseDetail(7, 0.7);
	
	var inc = 0;
	for (var nx = 0; nx < nnx; nx += 1) {
	 var nmx = nx / nnx;
	 for (var ny = 0; ny < nny; ny += 1) {
		var n = parseInt(nx + ny * nnx);
		 
		var nmy = ny / nny;
		
		var no = noise(nmx * nmy);
		 
		var ni = inc / (nnx * nny);
		
		objs[n] = {
			// paper
			//lx: width * nmx,
			//ly: height * nmy,
			lx: width / 2 + sin(nmx * PI * 2 + no / 2) * (width / 3.5),
			ly: height / 2 + cos(nmx * PI * 2 + no / 2) * (height / 3.5),
			// paper
			//la: random(-PI * 2, PI * 2),
			la: sin(nmx * PI * 2.5) * 12 , // modify this for more shapes
			// paper : 1
			lv: 1,
			d: 1.25,
			n: no,
			so: 128 + 128 * ni, // agent sensor offset,
			sa: 8 + 8 * nmx// agent sensor angle (degree)
		};
		 
		inc += 1;
	 }
	}
	
	for (var i = 0; i < width * height; i += 1) {
		trail_map[i] = 0;//i / (width * height);
	}
	
	ellipseMode(CENTER);
	rectMode(CENTER);
}

function compute() {
	fill(0);
	
	strokeWeight(2);

	for (var nx = 0; nx < nnx; nx += 1) {
	 for (var ny = 0; ny < nny; ny += 1) {
		var n = parseInt(nx + ny * nnx);
		 
		var obj = objs[n];
		
		var sensor_offset = obj.so;
		var sensor_angle = radians(obj.sa);
		
		// agent sensors
		var lhx = round(sin(obj.la - sensor_angle) * sensor_offset);
		var lhy = round(cos(obj.la - sensor_angle) * sensor_offset);
		var fhx = round(sin(obj.la) * sensor_offset);
		var fhy = round(cos(obj.la) * sensor_offset);
		var rhx = round(sin(obj.la + sensor_angle) * sensor_offset);
		var rhy = round(cos(obj.la + sensor_angle) * sensor_offset);
		
		var ailx = parseInt(obj.lx + lhx);
		var aily = parseInt(obj.ly + lhy);
		var aifx = parseInt(obj.lx + fhx);
		var aify = parseInt(obj.ly + fhy);
		var airx = parseInt(obj.lx + rhx);
		var airy = parseInt(obj.ly + rhy);
		
		ailx = ailx < 0 ? ailx + width : ailx;
		aily = aily < 0 ? aily + height : aily;
		aifx = aifx < 0 ? aifx + width : aifx;
		aify = aify < 0 ? aify + height : aify;
		airx = airx < 0 ? airx + width : airx;
		airy = airy < 0 ? airy + height : airy;
		
		ailx %= width;
		aily %= height;
		aifx %= width;
		aify %= height;
		airx %= width;
		airy %= height;
		
		// sensor sample
		var s1 = trail_map[ailx + aily * width]; // left
		var s2 = trail_map[aifx + aify * width]; // forward
		var s3 = trail_map[airx + airy * width]; // right
		
/*
		// debug sensor
		fill(255, 0, 0, 255);
		rect(ailx, aily, 1, 1);
		rect(aifx, aify, 1, 1);
		rect(airx, airy, 1, 1);
*/	
/*
		if (frameCount % 60 == 0) {
			obj.la += PI / 2;
		}
*/
	
		// agent behavior based on sampled sensor
		if (s2 < s1 && s2 < s3) {
			// turn left or right randomly
			//obj.la += random(PI / 2, -PI / 2);
			// paper
			//obj.la += (random() > 0.5 ? PI / 16 : -PI / 16);
		} else if (s1 < s3) {
			// turn left
			obj.la -= PI / 8;
		} else if (s3 < s1) {
			// turn right
			obj.la += PI / 8;
		}
		
		obj.lx += obj.lv * sin(obj.la);
		obj.ly += obj.lv * cos(obj.la);
		 
		 if (obj.lx < 0 || obj.lx > width) {
				continue; 
		 }
		 
		 if (obj.ly < 0 || obj.ly > height) {
				continue; 
		 }
		
		// boundary checks
		/*obj.lx = obj.lx < 0 ? obj.lx + width - 1 : obj.lx;
		obj.lx %= width;
		obj.ly = obj.ly < 0 ? obj.ly + height - 1 : obj.ly;
		obj.ly %= height;*/
		
		// deposit diffusion (3x3 mean kernel)
		// should probably go after deposit step though
		var i = parseInt(obj.lx + obj.ly * width);
		var b = trail_map[i] / 2;

		var lx = parseInt(obj.lx);
		var ly = parseInt(obj.ly);

		var xb = (lx - 1);
		var yb = (ly - 1);
		var xbl = xb < 0 ? width - 1 : xb;
		var ybl = yb < 0 ? height - 1 : yb;
		var xbu = (lx + 1) % width;
		var ybu = (ly + 1) % height;
		/*
		var v1 = trail_map[xbl + ly * width];
		var v2 = trail_map[xbu + ly * width];
		var v3 = trail_map[xbl + ybl * width];
		var v4 = trail_map[xbl + ybu * width];
		var v5 = trail_map[xbu + ybl * width];
		var v6 = trail_map[xbu + ybu * width];
		var v7 = trail_map[lx + ybl * width];
		var v8 = trail_map[lx + ybu * width];
		
		var vm = (v1 + v2 + v3 + v4 + v5 + v6 + v7 + v8) / 8 / 5;
		*/
		trail_map[xbl + ly * width] = b;
		trail_map[xbu + ly * width] = b;
		trail_map[xbl + ybl * width] = b;
		trail_map[xbl + ybu * width] = b;
		trail_map[xbu + ybl * width] = b;
		trail_map[xbu + ybu * width] = b;
		trail_map[lx + ybl * width] = b;
		trail_map[lx + ybu * width] = b;
		
		// deposit
		trail_map[i] = obj.d;
		
		// agent display
		var ll = 400;
		var t = (noise(obj.lx / width + obj.ly / height + obj.n + xmotion * 4)) * (pow((1 - min(ll, frameCount) / ll), 2.5));

		var sph = (1 - abs((0.5 - obj.lx / width) * 2));
		var color = 160 + noise(obj.lx / width + obj.ly / height + obj.la + xmotion * 2) * 96 * sph;
		fill(0, 0, color, t);
		 noStroke();
		//stroke(0, 0, color, t);
		ellipse(obj.lx, obj.ly, 1, 1);
		
/*
		if (trail_map[parseInt(i)] > 1) {
			trail_map[parseInt(i)] = 1;
		}
*/
	 }
	}
	
	// deposit decay
	for (var y = 0; y < height; y += 1) {
		for (var x = 0; x < width; x += 1) {
			var v = trail_map[x + y * width];
			trail_map[x + y * width] -= 0.1;
			if (trail_map[x + y * width] < 0) {
				trail_map[x + y * width] = 0;
			}
		}
	}
/*
	if (frameCount % 60 == 0) {
		var st = 1 + parseInt(random() * (nn / 8));
		for (var y = 0; y < nn; y += st) {
			objs[y].lx = random() * width;
			objs[y].ly = random() * height;
		}
	}
*/
}

function draw() {
	noStroke();
	
	rectMode(CORNER);
/*
	fill(0, 0, 0, 8);
	rect(0, 0, width, height);
*/
	rectMode(CENTER);
	
	compute();
	
	xmotion += 0.05;
	ymotion += 0.0002;
}"
"794119","Ball","mySketch","// same as ""slime mold simulation""

var xmotion = 0;
var ymotion = 0;

var objs = [];
var trail_map = [];

var nnx = 50;
var nny = 50;

function setup() {
	createCanvas(800, 800);
	
	colorMode(HSB, 360, 255, 255);
	
	background(0);
	
	noiseDetail(7, 0.7);
	
	var inc = 0;
	for (var nx = 0; nx < nnx; nx += 1) {
	 var nmx = nx / nnx;
	 for (var ny = 0; ny < nny; ny += 1) {
		var n = parseInt(nx + ny * nnx);
		 
		var nmy = ny / nny;
		
		var no = noise(nmx * nmy);
		 
		var ni = inc / (nnx * nny);
		
		objs[n] = {
			lx: width / 2 + sin(nmx * PI * 2 + no * (PI * 2)) * (width / 3),
			ly: height / 2 + cos(nmx * PI * 2 + no * (PI * 2)) * (height / 3),
			// paper
			//la: random(-PI * 2, PI * 2),
			la: sin(nmx * PI * 2) * cos(nmy * PI * 2), // modify this for more shapes
			// paper : 1
			lv: 1,
			d: 5,
			n: no,
			so: 3, // agent sensor offset,
			sa: 45// agent sensor angle (degree)
		};
		 
		inc += 1;
	 }
	}
	
	for (var i = 0; i < width * height; i += 1) {
		trail_map[i] = 0;//i / (width * height);
	}
	
	ellipseMode(CENTER);
	rectMode(CENTER);
}

function compute() {
	fill(0);
	
	strokeWeight(2);

	for (var nx = 0; nx < nnx; nx += 1) {
	 for (var ny = 0; ny < nny; ny += 1) {
		var n = parseInt(nx + ny * nnx);
		 
		var obj = objs[n];
		
		var sensor_offset = obj.so;
		var sensor_angle = radians(obj.sa);
		
		// agent sensors
		var lhx = round(sin(obj.la - sensor_angle) * sensor_offset);
		var lhy = round(cos(obj.la - sensor_angle) * sensor_offset);
		var fhx = round(sin(obj.la) * sensor_offset);
		var fhy = round(cos(obj.la) * sensor_offset);
		var rhx = round(sin(obj.la + sensor_angle) * sensor_offset);
		var rhy = round(cos(obj.la + sensor_angle) * sensor_offset);
		
		var ailx = parseInt(obj.lx + lhx);
		var aily = parseInt(obj.ly + lhy);
		var aifx = parseInt(obj.lx + fhx);
		var aify = parseInt(obj.ly + fhy);
		var airx = parseInt(obj.lx + rhx);
		var airy = parseInt(obj.ly + rhy);
		
		ailx = ailx < 0 ? ailx + width : ailx;
		aily = aily < 0 ? aily + height : aily;
		aifx = aifx < 0 ? aifx + width : aifx;
		aify = aify < 0 ? aify + height : aify;
		airx = airx < 0 ? airx + width : airx;
		airy = airy < 0 ? airy + height : airy;
		
		ailx %= width;
		aily %= height;
		aifx %= width;
		aify %= height;
		airx %= width;
		airy %= height;
		
		// sensor sample
		var s1 = trail_map[ailx + aily * width]; // left
		var s2 = trail_map[aifx + aify * width]; // forward
		var s3 = trail_map[airx + airy * width]; // right
		
/*
		// debug sensor
		fill(255, 0, 0, 255);
		rect(ailx, aily, 1, 1);
		rect(aifx, aify, 1, 1);
		rect(airx, airy, 1, 1);
*/	
/*
		if (frameCount % 60 == 0) {
			obj.la += PI / 2;
		}
*/
	
		// agent behavior based on sampled sensor
		if (s2 < s1 && s2 < s3) {
			// turn left or right randomly
			//obj.la += random(PI / 2, -PI / 2);
			// paper
			//obj.la += (random() > 0.5 ? PI / 16 : -PI / 16);
		} else if (s1 < s3) {
			// turn left
			obj.la -= PI / 10;
		} else if (s3 < s1) {
			// turn right
			obj.la += PI / 10;
		}
		
		obj.lx += obj.lv * sin(obj.la);
		obj.ly += obj.lv * cos(obj.la);
		 
		 if (obj.lx < 0 || obj.lx > width) {
				continue; 
		 }
		 
		 if (obj.ly < 0 || obj.ly > height) {
				continue; 
		 }
		
		// boundary checks
		/*obj.lx = obj.lx < 0 ? obj.lx + width - 1 : obj.lx;
		obj.lx %= width;
		obj.ly = obj.ly < 0 ? obj.ly + height - 1 : obj.ly;
		obj.ly %= height;*/
		
		// deposit diffusion (3x3 mean kernel)
		// should probably go after deposit step though
		var i = parseInt(obj.lx + obj.ly * width);
		var b = trail_map[i] / 2;

		var lx = parseInt(obj.lx);
		var ly = parseInt(obj.ly);

		var xb = (lx - 1);
		var yb = (ly - 1);
		var xbl = xb < 0 ? width - 1 : xb;
		var ybl = yb < 0 ? height - 1 : yb;
		var xbu = (lx + 1) % width;
		var ybu = (ly + 1) % height;
		/*
		var v1 = trail_map[xbl + ly * width];
		var v2 = trail_map[xbu + ly * width];
		var v3 = trail_map[xbl + ybl * width];
		var v4 = trail_map[xbl + ybu * width];
		var v5 = trail_map[xbu + ybl * width];
		var v6 = trail_map[xbu + ybu * width];
		var v7 = trail_map[lx + ybl * width];
		var v8 = trail_map[lx + ybu * width];
		
		var vm = (v1 + v2 + v3 + v4 + v5 + v6 + v7 + v8) / 8 / 5;
		*/
		trail_map[xbl + ly * width] = b;
		trail_map[xbu + ly * width] = b;
		trail_map[xbl + ybl * width] = b;
		trail_map[xbl + ybu * width] = b;
		trail_map[xbu + ybl * width] = b;
		trail_map[xbu + ybu * width] = b;
		trail_map[lx + ybl * width] = b;
		trail_map[lx + ybu * width] = b;
		
		// deposit
		trail_map[i] = obj.d;
		
		// agent display
		var ll = 500;
		var t = (noise(obj.lx / width + obj.ly / height + obj.n + xmotion * 4) * 2) * (pow((1 - min(ll, frameCount) / ll), 5.5));

		var sph = (1 - abs((0.5 - obj.lx / width) * 2));
		var color = 160 + noise(obj.lx / width + obj.ly / height + obj.la + xmotion * 2) * 96 * sph;
		fill(0, 0, color, t);
		 noStroke();
		//stroke(0, 0, color, t);
		ellipse(obj.lx, obj.ly, 1, 1);
		
/*
		if (trail_map[parseInt(i)] > 1) {
			trail_map[parseInt(i)] = 1;
		}
*/
	 }
	}
	
	// deposit decay
	for (var y = 0; y < height; y += 1) {
		for (var x = 0; x < width; x += 1) {
			var v = trail_map[x + y * width];
			trail_map[x + y * width] -= 0.1;
			if (trail_map[x + y * width] < 0) {
				trail_map[x + y * width] = 0;
			}
		}
	}
/*
	if (frameCount % 60 == 0) {
		var st = 1 + parseInt(random() * (nn / 8));
		for (var y = 0; y < nn; y += st) {
			objs[y].lx = random() * width;
			objs[y].ly = random() * height;
		}
	}
*/
}

function draw() {
	noStroke();
	
	rectMode(CORNER);
/*
	fill(0, 0, 0, 8);
	rect(0, 0, width, height);
*/
	rectMode(CENTER);
	
	compute();
	
	xmotion += 0.05;
	ymotion += 0.0002;
}"
"794117","Triage","mySketch","// same as ""slime mold simulation"" without particles

var xmotion = 0;
var ymotion = 0;

var objs = [];
var trail_map = [];

var nnx = 50;
var nny = 50;

function setup() {
	createCanvas(800, 800);
	
	colorMode(HSB, 360, 255, 255);
	
	background(0);
	
	noiseDetail(7, 0.7);
	
	var inc = 0;
	for (var nx = 0; nx < nnx; nx += 1) {
	 var nmx = nx / nnx;
	 for (var ny = 0; ny < nny; ny += 1) {
		var n = parseInt(nx + ny * nnx);
		 
		var nmy = ny / nny;
		
		var no = noise(nmx * nmy);
		 
		var ni = inc / (nnx * nny);
		
		objs[n] = {
			// paper
			//lx: width * nmx,
			//ly: height * nmy,
			lx: width / 2 + sin(nmx * PI * 2) * (width / 4),
			ly: height / 2 + cos(nmx * PI * 2) * (height / 4),
			// paper
			//la: random(-PI * 2, PI * 2),
			la: sin(nmx * PI * 2 + no / 2) * 2, // modify this for more shapes
			// paper : 1
			lv: 1,
			d: 5,
			n: no,
			so: width / 64, // agent sensor offset,
			sa: 1 // agent sensor angle (degree)
		};
		 
		inc += 1;
	 }
	}
	
	for (var i = 0; i < width * height; i += 1) {
		trail_map[i] = 0;//i / (width * height);
	}
	
	ellipseMode(CENTER);
	rectMode(CENTER);
}

function compute() {
	fill(0);
	
	strokeWeight(2);

	for (var nx = 0; nx < nnx; nx += 1) {
	 for (var ny = 0; ny < nny; ny += 1) {
		var n = parseInt(nx + ny * nnx);
		 
		var obj = objs[n];
		
		var sensor_offset = obj.so;
		var sensor_angle = radians(obj.sa);
		
		// agent sensors
		var lhx = round(sin(obj.la - sensor_angle) * sensor_offset);
		var lhy = round(cos(obj.la - sensor_angle) * sensor_offset);
		var fhx = round(sin(obj.la) * sensor_offset);
		var fhy = round(cos(obj.la) * sensor_offset);
		var rhx = round(sin(obj.la + sensor_angle) * sensor_offset);
		var rhy = round(cos(obj.la + sensor_angle) * sensor_offset);
		
		var ailx = parseInt(obj.lx + lhx);
		var aily = parseInt(obj.ly + lhy);
		var aifx = parseInt(obj.lx + fhx);
		var aify = parseInt(obj.ly + fhy);
		var airx = parseInt(obj.lx + rhx);
		var airy = parseInt(obj.ly + rhy);
		
		ailx = ailx < 0 ? ailx + width : ailx;
		aily = aily < 0 ? aily + height : aily;
		aifx = aifx < 0 ? aifx + width : aifx;
		aify = aify < 0 ? aify + height : aify;
		airx = airx < 0 ? airx + width : airx;
		airy = airy < 0 ? airy + height : airy;
		
		ailx %= width;
		aily %= height;
		aifx %= width;
		aify %= height;
		airx %= width;
		airy %= height;
		
		// sensor sample
		var s1 = trail_map[ailx + aily * width]; // left
		var s2 = trail_map[aifx + aify * width]; // forward
		var s3 = trail_map[airx + airy * width]; // right
		
/*
		// debug sensor
		fill(255, 0, 0, 255);
		rect(ailx, aily, 1, 1);
		rect(aifx, aify, 1, 1);
		rect(airx, airy, 1, 1);
*/	
/*
		if (frameCount % 60 == 0) {
			obj.la += PI / 2;
		}
*/
	
		// agent behavior based on sampled sensor
		if (s2 < s1 && s2 < s3) {
			// turn left or right randomly
			obj.la += random(PI / 2, -PI / 2);
			// paper
			//obj.la += (random() > 0.5 ? PI / 16 : -PI / 16);
		} else if (s1 < s3) {
			// turn left
			obj.la -= PI / 2;
		} else if (s3 < s1) {
			// turn right
			obj.la += PI / 2;
		}
		
		obj.lx += obj.lv * sin(obj.la);
		obj.ly += obj.lv * cos(obj.la);
		 
		 if (obj.lx < 0 || obj.lx > width) {
				continue; 
		 }
		 
		 if (obj.ly < 0 || obj.ly > height) {
				continue; 
		 }
		
		// boundary checks
		/*obj.lx = obj.lx < 0 ? obj.lx + width - 1 : obj.lx;
		obj.lx %= width;
		obj.ly = obj.ly < 0 ? obj.ly + height - 1 : obj.ly;
		obj.ly %= height;*/
		
		// deposit diffusion (3x3 mean kernel)
		// should probably go after deposit step though
		var i = parseInt(obj.lx + obj.ly * width);
		var b = trail_map[i] / 2;

		var lx = parseInt(obj.lx);
		var ly = parseInt(obj.ly);

		var xb = (lx - 1);
		var yb = (ly - 1);
		var xbl = xb < 0 ? width - 1 : xb;
		var ybl = yb < 0 ? height - 1 : yb;
		var xbu = (lx + 1) % width;
		var ybu = (ly + 1) % height;
		/*
		var v1 = trail_map[xbl + ly * width];
		var v2 = trail_map[xbu + ly * width];
		var v3 = trail_map[xbl + ybl * width];
		var v4 = trail_map[xbl + ybu * width];
		var v5 = trail_map[xbu + ybl * width];
		var v6 = trail_map[xbu + ybu * width];
		var v7 = trail_map[lx + ybl * width];
		var v8 = trail_map[lx + ybu * width];
		
		var vm = (v1 + v2 + v3 + v4 + v5 + v6 + v7 + v8) / 8 / 5;
		*/
		trail_map[xbl + ly * width] = b;
		trail_map[xbu + ly * width] = b;
		trail_map[xbl + ybl * width] = b;
		trail_map[xbl + ybu * width] = b;
		trail_map[xbu + ybl * width] = b;
		trail_map[xbu + ybu * width] = b;
		trail_map[lx + ybl * width] = b;
		trail_map[lx + ybu * width] = b;
		
		// deposit
		trail_map[i] = obj.d;
		
		// agent display
		var ll = 400;
		var t = (noise(obj.lx / width + obj.ly / height + obj.n + xmotion * 4) * 2) * (pow((1 - min(ll, frameCount) / ll), 2.5));

		var sph = (1 - abs((0.5 - obj.lx / width) * 2));
		var color = 160 + noise(obj.lx / width + obj.ly / height + obj.la + xmotion * 2) * 96 * sph;
		fill(0, 0, color, t);
		 noStroke();
		//stroke(0, 0, color, t);
		ellipse(obj.lx, obj.ly, 1, 1);
		
/*
		if (trail_map[parseInt(i)] > 1) {
			trail_map[parseInt(i)] = 1;
		}
*/
	 }
	}
	
	// deposit decay
	for (var y = 0; y < height; y += 1) {
		for (var x = 0; x < width; x += 1) {
			var v = trail_map[x + y * width];
			trail_map[x + y * width] -= 0.1;
			if (trail_map[x + y * width] < 0) {
				trail_map[x + y * width] = 0;
			}
		}
	}
/*
	if (frameCount % 60 == 0) {
		var st = 1 + parseInt(random() * (nn / 8));
		for (var y = 0; y < nn; y += st) {
			objs[y].lx = random() * width;
			objs[y].ly = random() * height;
		}
	}
*/
}

function draw() {
	noStroke();
	
	rectMode(CORNER);
/*
	fill(0, 0, 0, 8);
	rect(0, 0, width, height);
*/
	rectMode(CENTER);
	
	compute();
	
	xmotion += 0.05;
	ymotion += 0.0002;
}"
"785993","Curves","mySketch","// same basis as ""Pieces"" sketch but with big number of components which blend into each others to give drawing like result
// there is a simulation pass which get the boundary of the drawing to center it later on, code is bit rushy :)
// distance is also forced to be within certain limit

var xmotion = 0;
var ymotion = 0;

var objs = [];
var nx = 20;
var ny = 20;
var st = 1;
var sto = 100;

var lbx = Infinity;
var lux = 0;
var offx = 0;
var offy = 0;

// https://iquilezles.org/www/articles/palettes/palettes.htm
function pal(t, a, b, c, d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

function setup() {
	createCanvas(840, 840);
	
	background(0);
	
	noiseDetail(7, 0.65);
	
	for (var k = 0; k < st; k += 1) {
		for (var x = 0; x < nx; x += 1) {
			for (var y = 0; y < ny; y += 1) {
				objs[parseInt(x + y * nx + k * nx * ny)] = {
					x: 0,
					y: -y,
					vx: random(-1, 1) / 80000 / (k + 1),
					vy: 1,
					n: noise((x / nx + y / ny)) * 8,
					bx: x,
					by: -y,
					bn: noise((x / nx + y / ny)) * 8,
				};
			}
		}
	}
	
	// get boundary
	for (var s = 0; s < 4000; s += 1)
	for (var k = 0; k < st; k += 1) {
		for (var x = 0; x < nx; x += 1) {
			for (var y = 0; y < ny; y += 1) {
				var n = parseInt(x + y * nx + k * nx * ny);
				objs[n].bn += objs[n].vx;
				objs[n].by += objs[n].vy;
				objs[n].bx = (noise(objs[n].bn, objs[n].by / height / 2)) * width - k * sto;
				
				if (objs[n].bx < lbx) {
					lbx = objs[n].bx;
				}

				if (objs[n].bx > lux) {
					lux = objs[n].bx;
				}
			}
		}
	}
	
	offx = -lbx + width / 2 - (lux - lbx) / 2;
	
	//ellipseMode(CENTER);
	//rectMode(CENTER);
}

function compute() {
	fill(0);
	
	strokeWeight(1);

	for (var k = 0; k < st; k += 1) {
		for (var x = 0; x < nx; x += 1) {
			for (var y = 0; y < ny; y += 1) {

				var n = parseInt(x + y * nx + k * nx * ny);
			objs[n].n += objs[n].vx;
			objs[n].y += objs[n].vy;
			objs[n].x = noise(objs[n].n, objs[n].y / height / 2) * width;

			//objs[n].y %= height;
			/*if (objs[n].y == 0) {
				objs[n].n = random(-1, 1) * width
			}*/

			var dd = Infinity;
			var did = n;

			for (var i = 0; i < nx * ny; i += 1) {
				var ii = parseInt(i + k * nx * ny);
				var d = (abs((objs[n].x - objs[ii].x) * (objs[n].x - objs[ii].x)) + abs((objs[n].y - objs[ii].y) * (objs[n].y - objs[ii].y))); // sqrt
				if (i !== n && d < dd && d > 100) {
					did = i;
					dd = d;
				}
			}

			if (did !== n) {
				objs[did].vx = -objs[did].vx;
			}

			var pa1 = 0.75, pa2 = 0.75, pa3 = 0.5;
			var pb1 = 0.5, pb2 = 0.5, pb3 = 0.5;
			var pc1 = 1, pc2 = 1, pc3 = 0.5;

			var pdr = 0.7;
			var pdg = 0.8;
			var pdb = 0.3;

			var pt = noise(objs[n].n * 8 + xmotion);

			var rf = pal(pt, pa1, pb1, pc1, pdr) * 255;
			var gf = pal(pt, pa2, pb2, pc2, pdg) * 255;
			var bf = pal(pt, pa3, pb3, pc3, pdb) * 255;

			stroke(rf, gf, bf, 16);
				
			var dx1 = offx + (objs[n].x - k * sto);
			var dx2 = offx + (objs[did].x - k * sto);
			line(dx1, objs[n].y, dx2, objs[did].y);
			//line(width - objs[n].x, objs[n].y, width - objs[did].x, objs[did].y);
/*
			stroke(0, 0, 0, 32);
			fill(0, 0, 0, 32);
			rect(objs[n].x, objs[n].y, 1, 1);
			//rect(objs[did].x, objs[did].y, 1, 1);
			*/
		}
		}
	}
}

function draw() {
	noStroke();
/*
	fill(0, 0, 0, 1);
	rect(0, 0, windowWidth, windowHeight);
*/
	compute();
	
	xmotion += 0.0008;
	ymotion += 0.0002;
}"
"785993","Curves","mySketch","// same basis as ""Pieces"" sketch but with big number of components which blend into each others to give drawing like result
// there is a simulation pass which get the boundary of the drawing to center it later on, code is bit rushy :)
// distance is also forced to be within certain limit

var xmotion = 0;
var ymotion = 0;

var objs = [];
var nx = 20;
var ny = 20;
var st = 1;
var sto = 100;

var lbx = Infinity;
var lux = 0;
var offx = 0;
var offy = 0;

// https://iquilezles.org/www/articles/palettes/palettes.htm
function pal(t, a, b, c, d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

function setup() {
	createCanvas(840, 840);
	
	background(0);
	
	noiseDetail(7, 0.65);
	
	for (var k = 0; k < st; k += 1) {
		for (var x = 0; x < nx; x += 1) {
			for (var y = 0; y < ny; y += 1) {
				objs[parseInt(x + y * nx + k * nx * ny)] = {
					x: 0,
					y: -y,
					vx: random(-1, 1) / 8000 / (k + 1),
					vy: 1,
					n: noise((x / nx + y / ny)) * 8,
					bx: x,
					by: -y,
					bn: noise((x / nx + y / ny)) * 8,
				};
			}
		}
	}
	
	// get boundary
	for (var s = 0; s < 4000; s += 1)
	for (var k = 0; k < st; k += 1) {
		for (var x = 0; x < nx; x += 1) {
			for (var y = 0; y < ny; y += 1) {
				var n = parseInt(x + y * nx + k * nx * ny);
				objs[n].bn += objs[n].vx;
				objs[n].by += objs[n].vy;
				objs[n].bx = (noise(objs[n].bn, objs[n].by / height / 2)) * width - k * sto;
				
				if (objs[n].bx < lbx) {
					lbx = objs[n].bx;
				}

				if (objs[n].bx > lux) {
					lux = objs[n].bx;
				}
			}
		}
	}
	
	offx = -lbx + width / 2 - (lux - lbx) / 2;
	
	//ellipseMode(CENTER);
	//rectMode(CENTER);
}

function compute() {
	fill(0);
	
	strokeWeight(1);

	for (var k = 0; k < st; k += 1) {
		for (var x = 0; x < nx; x += 1) {
			for (var y = 0; y < ny; y += 1) {

				var n = parseInt(x + y * nx + k * nx * ny);
			objs[n].n += objs[n].vx;
			objs[n].y += objs[n].vy;
			objs[n].x = noise(objs[n].n, objs[n].y / height / 2) * width;

			//objs[n].y %= height;
			/*if (objs[n].y == 0) {
				objs[n].n = random(-1, 1) * width
			}*/

			var dd = Infinity;
			var did = n;

			for (var i = 0; i < nx * ny; i += 1) {
				var ii = parseInt(i + k * nx * ny);
				var d = (abs((objs[n].x - objs[ii].x) * (objs[n].x - objs[ii].x)) + abs((objs[n].y - objs[ii].y) * (objs[n].y - objs[ii].y))); // sqrt
				if (i !== n && d < dd && d > 100) {
					did = i;
					dd = d;
				}
			}

			if (did !== n) {
				objs[did].vx = -objs[did].vx;
			}

			var pa1 = 0.75, pa2 = 0.75, pa3 = 0.5;
			var pb1 = 0.5, pb2 = 0.5, pb3 = 0.5;
			var pc1 = 1, pc2 = 1, pc3 = 0.5;

			var pdr = 0.7;
			var pdg = 0.8;
			var pdb = 0.3;

			var pt = noise(objs[n].n * 8 + xmotion);

			var rf = pal(pt, pa1, pb1, pc1, pdr) * 255;
			var gf = pal(pt, pa2, pb2, pc2, pdg) * 255;
			var bf = pal(pt, pa3, pb3, pc3, pdb) * 255;

			stroke(rf, gf, bf, 16);
				
			var dx1 = offx + (objs[n].x - k * sto);
			var dx2 = offx + (objs[did].x - k * sto);
			line(dx1, objs[n].y, dx2, objs[did].y);
			//line(width - objs[n].x, objs[n].y, width - objs[did].x, objs[did].y);
/*
			stroke(0, 0, 0, 32);
			fill(0, 0, 0, 32);
			rect(objs[n].x, objs[n].y, 1, 1);
			//rect(objs[did].x, objs[did].y, 1, 1);
			*/
		}
		}
	}
}

function draw() {
	noStroke();
/*
	fill(0, 0, 0, 1);
	rect(0, 0, windowWidth, windowHeight);
*/
	compute();
	
	xmotion += 0.0008;
	ymotion += 0.0002;
}"
"785993","Curves","mySketch","// same basis as ""Pieces"" sketch but with big number of components which blend into each others to give drawing like result
// there is a simulation pass which get the boundary of the drawing to center it later on, code is bit rushy :)
// distance is also forced to be within certain limit

var xmotion = 0;
var ymotion = 0;

var objs = [];
var nx = 20;
var ny = 20;
var st = 1;
var sto = 200;

var lbx = Infinity;
var lux = 0;
var offx = 0;
var offy = 0;

// https://iquilezles.org/www/articles/palettes/palettes.htm
function pal(t, a, b, c, d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

function setup() {
	createCanvas(840, 840);
	
	background(0);
	
	noiseDetail(7, 0.7);
	
	for (var k = 0; k < st; k += 1) {
		for (var x = 0; x < nx; x += 1) {
			for (var y = 0; y < ny; y += 1) {
				objs[parseInt(x + y * nx + k * nx * ny)] = {
					x: 0,
					y: -y,
					vx: random(-1, 1) / 80000 / (k + 1),
					vy: 1,
					n: noise((x / nx + y / ny)) * 800,
					bx: x,
					by: -y,
					bn: noise((x / nx + y / ny)) * 800,
				};
			}
		}
	}
	
	// get boundary
	for (var s = 0; s < 4000; s += 1)
	for (var k = 0; k < st; k += 1) {
		for (var x = 0; x < nx; x += 1) {
			for (var y = 0; y < ny; y += 1) {
				var n = parseInt(x + y * nx + k * nx * ny);
				objs[n].bn += objs[n].vx;
				objs[n].by += objs[n].vy;
				objs[n].bx = (noise(objs[n].bn / width * 128, objs[n].by / height / 32 * (objs[n].y / height))) * width - k * sto;
				
				if (objs[n].bx < lbx) {
					lbx = objs[n].bx;
				}

				if (objs[n].bx > lux) {
					lux = objs[n].bx;
				}
			}
		}
	}
	
	offx = -lbx + width / 2 - (lux - lbx) / 2;
	
	//ellipseMode(CENTER);
	//rectMode(CENTER);
}

function compute() {
	fill(0);
	
	strokeWeight(1);

	for (var k = 0; k < st; k += 1) {
		for (var x = 0; x < nx; x += 1) {
			for (var y = 0; y < ny; y += 1) {

				var n = parseInt(x + y * nx + k * nx * ny);
			objs[n].n += objs[n].vx;
			objs[n].y += objs[n].vy;
			objs[n].x = noise(objs[n].n / width * 128, objs[n].y / height / 32 * (objs[n].y / height)) * width;

			//objs[n].y %= height;
			/*if (objs[n].y == 0) {
				objs[n].n = random(-1, 1) * width
			}*/

			var dd = Infinity;
			var did = n;

			for (var i = 0; i < nx * ny; i += 1) {
				var ii = parseInt(i + k * nx * ny);
				var d = (abs((objs[n].x - objs[ii].x) * (objs[n].x - objs[ii].x)) + abs((objs[n].y - objs[ii].y) * (objs[n].y - objs[ii].y))); // sqrt
				if (i !== n && d < dd && d > 800 * noise(objs[n].n * 64)) {
					did = i;
					dd = d;
				}
			}

			if (did !== n) {
				objs[did].vx = -objs[did].vx;
			}

			var pa1 = 0.75, pa2 = 0.75, pa3 = 0.5;
			var pb1 = 0.5, pb2 = 0.5, pb3 = 0.5;
			var pc1 = 1, pc2 = 1, pc3 = 0.5;

			var pdr = 0.7;
			var pdg = 0.8;
			var pdb = 0.3;

			var pt = noise(objs[n].n * 8 + xmotion);

			var rf = pal(pt, pa1, pb1, pc1, pdr) * 255;
			var gf = pal(pt, pa2, pb2, pc2, pdg) * 255;
			var bf = pal(pt, pa3, pb3, pc3, pdb) * 255;

			stroke(rf, gf, bf, 16);
				
			var dx1 = offx + (objs[n].x - k * sto);
			var dx2 = offx + (objs[did].x - k * sto);
			line(dx1, objs[n].y, dx2, objs[did].y);
			//line(width - objs[n].x, objs[n].y, width - objs[did].x, objs[did].y);
/*
			stroke(0, 0, 0, 32);
			fill(0, 0, 0, 32);
			rect(objs[n].x, objs[n].y, 1, 1);
			//rect(objs[did].x, objs[did].y, 1, 1);
			*/
		}
		}
	}
}

function draw() {
	noStroke();
/*
	fill(0, 0, 0, 1);
	rect(0, 0, windowWidth, windowHeight);
*/
	compute();
	
	xmotion += 0.0008;
	ymotion += 0.0002;
}"
"785993","Curves","mySketch","// same basis as ""Pieces"" sketch but with big number of components which blend into each others to give drawing like result
// there is a simulation pass which get the boundary of the drawing to center it later on, code is bit rushy :)
// distance is also forced to be within certain limit

var xmotion = 0;
var ymotion = 0;

var objs = [];
var nx = 20;
var ny = 20;
var st = 1;
var sto = 200;

var lbx = Infinity;
var lux = 0;
var offx = 0;
var offy = 0;

// https://iquilezles.org/www/articles/palettes/palettes.htm
function pal(t, a, b, c, d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

function setup() {
	createCanvas(840, 840);
	
	background(0);
	
	noiseDetail(7, 0.7);
	
	for (var k = 0; k < st; k += 1) {
		for (var x = 0; x < nx; x += 1) {
			for (var y = 0; y < ny; y += 1) {
				objs[parseInt(x + y * nx + k * nx * ny)] = {
					x: 0,
					y: -y,
					vx: random(-1, 1) / 80000 / (k + 1),
					vy: 1,
					n: noise((x / nx + y / ny)) * 800,
					bx: x,
					by: -y,
					bn: noise((x / nx + y / ny)) * 800,
				};
			}
		}
	}
	
	// get boundary
	for (var s = 0; s < 4000; s += 1)
	for (var k = 0; k < st; k += 1) {
		for (var x = 0; x < nx; x += 1) {
			for (var y = 0; y < ny; y += 1) {
				var n = parseInt(x + y * nx + k * nx * ny);
				objs[n].bn += objs[n].vx;
				objs[n].by += objs[n].vy;
				objs[n].bx = (noise(objs[n].bn / width * 128, objs[n].by / height / 32 * (objs[n].y / height))) * width - k * sto;
				
				if (objs[n].bx < lbx) {
					lbx = objs[n].bx;
				}

				if (objs[n].bx > lux) {
					lux = objs[n].bx;
				}
			}
		}
	}
	
	offx = -lbx + width / 2 - (lux - lbx) / 2;
	
	//ellipseMode(CENTER);
	//rectMode(CENTER);
}

function compute() {
	fill(0);
	
	strokeWeight(1);

	for (var k = 0; k < st; k += 1) {
		for (var x = 0; x < nx; x += 1) {
			for (var y = 0; y < ny; y += 1) {

				var n = parseInt(x + y * nx + k * nx * ny);
			objs[n].n += objs[n].vx;
			objs[n].y += objs[n].vy;
			objs[n].x = noise(objs[n].n / width * 128, objs[n].y / height / 32 * (objs[n].y / height)) * width;

			//objs[n].y %= height;
			/*if (objs[n].y == 0) {
				objs[n].n = random(-1, 1) * width
			}*/

			var dd = Infinity;
			var did = n;

			for (var i = 0; i < nx * ny; i += 1) {
				var ii = parseInt(i + k * nx * ny);
				var d = (abs((objs[n].x - objs[ii].x) * (objs[n].x - objs[ii].x)) + abs((objs[n].y - objs[ii].y) * (objs[n].y - objs[ii].y))); // sqrt
				if (i !== n && d < dd && d > 800 * noise(objs[n].n * 64)) {
					did = i;
					dd = d;
				}
			}

			if (did !== n) {
				objs[did].vx = -objs[did].vx;
			}

			var pa1 = 0.75, pa2 = 0.75, pa3 = 0.5;
			var pb1 = 0.5, pb2 = 0.5, pb3 = 0.5;
			var pc1 = 1, pc2 = 1, pc3 = 0.5;

			var pdr = 0.7;
			var pdg = 0.8;
			var pdb = 0.3;

			var pt = noise(objs[n].n * 8 + xmotion);

			var rf = pal(pt, pa1, pb1, pc1, pdr) * 255;
			var gf = pal(pt, pa2, pb2, pc2, pdg) * 255;
			var bf = pal(pt, pa3, pb3, pc3, pdb) * 255;

			stroke(rf, gf, bf, 16);
				
			var dx1 = offx + (objs[n].x - k * sto);
			var dx2 = offx + (objs[did].x - k * sto);
			line(dx1, objs[n].y, dx2, objs[did].y);
			//line(width - objs[n].x, objs[n].y, width - objs[did].x, objs[did].y);
/*
			stroke(0, 0, 0, 32);
			fill(0, 0, 0, 32);
			rect(objs[n].x, objs[n].y, 1, 1);
			//rect(objs[did].x, objs[did].y, 1, 1);
			*/
		}
		}
	}
}

function draw() {
	noStroke();
/*
	fill(0, 0, 0, 1);
	rect(0, 0, windowWidth, windowHeight);
*/
	compute();
	
	xmotion += 0.0008;
	ymotion += 0.0002;
}"
"785993","Curves","mySketch","// same basis as ""Pieces"" sketch but with big number of components which blend into each others to give drawing like result
// there is a simulation pass which get the boundary of the drawing to center it later on, code is bit rushy :)
// distance is also forced to be within certain limit

var xmotion = 0;
var ymotion = 0;

var objs = [];
var nx = 20;
var ny = 20;
var st = 1;
var sto = 2000;

var lbx = Infinity;
var lux = 0;
var offx = 0;
var offy = 0;

// https://iquilezles.org/www/articles/palettes/palettes.htm
function pal(t, a, b, c, d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

function setup() {
	createCanvas(840, 840);
	
	background(0);
	
	noiseDetail(7, 0.7);
	
	for (var k = 0; k < st; k += 1) {
		for (var x = 0; x < nx; x += 1) {
			for (var y = 0; y < ny; y += 1) {
				objs[parseInt(x + y * nx + k * nx * ny)] = {
					x: 0,
					y: -y,
					vx: random(-1, 1) / 80000 / (k + 1),
					vy: 1,
					n: noise((x / nx + y / ny)) * 800,
					bx: x,
					by: -y,
					bn: noise((x / nx + y / ny)) * 800,
				};
			}
		}
	}
	
	// get boundary
	for (var s = 0; s < 4000; s += 1)
	for (var k = 0; k < st; k += 1) {
		for (var x = 0; x < nx; x += 1) {
			for (var y = 0; y < ny; y += 1) {
				var n = parseInt(x + y * nx + k * nx * ny);
				objs[n].bn += objs[n].vx;
				objs[n].by += objs[n].vy;
				objs[n].bx = (noise(objs[n].bn / width * 128, objs[n].by / height / 32 * (objs[n].y / height))) * width - k * sto;
				
				if (objs[n].bx < lbx) {
					lbx = objs[n].bx;
				}

				if (objs[n].bx > lux) {
					lux = objs[n].bx;
				}
			}
		}
	}
	
	offx = -lbx + width / 2 - (lux - lbx) / 2;
	
	//ellipseMode(CENTER);
	//rectMode(CENTER);
}

function compute() {
	fill(0);
	
	strokeWeight(1);

	for (var k = 0; k < st; k += 1) {
		for (var x = 0; x < nx; x += 1) {
			for (var y = 0; y < ny; y += 1) {

				var n = parseInt(x + y * nx + k * nx * ny);
			objs[n].n += objs[n].vx;
			objs[n].y += objs[n].vy;
			objs[n].x = noise(objs[n].n / width * 128, objs[n].y / height / 32 * (objs[n].y / height)) * width;

			//objs[n].y %= height;
			/*if (objs[n].y == 0) {
				objs[n].n = random(-1, 1) * width
			}*/

			var dd = Infinity;
			var did = n;

			for (var i = 0; i < nx * ny; i += 1) {
				var ii = parseInt(i + k * nx * ny);
				var d = (abs((objs[n].x - objs[ii].x) * (objs[n].x - objs[ii].x)) + abs((objs[n].y - objs[ii].y) * (objs[n].y - objs[ii].y))); // sqrt
				if (i !== n && d < dd && d > 800 * noise(objs[n].n * 64)) {
					did = i;
					dd = d;
				}
			}

			if (did !== n) {
				objs[did].vx = -objs[did].vx;
			}

			var pa1 = 0.75, pa2 = 0.75, pa3 = 0.5;
			var pb1 = 0.5, pb2 = 0.5, pb3 = 0.5;
			var pc1 = 1, pc2 = 1, pc3 = 0.5;

			var pdr = 0.7;
			var pdg = 0.8;
			var pdb = 0.3;

			var pt = noise(objs[n].n * 8 + xmotion);

			var rf = pal(pt, pa1, pb1, pc1, pdr) * 255;
			var gf = pal(pt, pa2, pb2, pc2, pdg) * 255;
			var bf = pal(pt, pa3, pb3, pc3, pdb) * 255;

			stroke(rf, gf, bf, 16);
				
			var dx1 = offx + (objs[n].x - k * sto);
			var dx2 = offx + (objs[did].x - k * sto);
			line(dx1, objs[n].y, dx2, objs[did].y);
			//line(width - objs[n].x, objs[n].y, width - objs[did].x, objs[did].y);
/*
			stroke(0, 0, 0, 32);
			fill(0, 0, 0, 32);
			rect(objs[n].x, objs[n].y, 1, 1);
			//rect(objs[did].x, objs[did].y, 1, 1);
			*/
		}
		}
	}
}

function draw() {
	noStroke();
/*
	fill(0, 0, 0, 1);
	rect(0, 0, windowWidth, windowHeight);
*/
	compute();
	
	xmotion += 0.0008;
	ymotion += 0.0002;
}"
"783521","45²","mySketch","// same as ""slime mold simulation"" but with greatly reduced agents

var xmotion = 0;
var ymotion = 0;

var objs = [];
var trail_map = [];

var nnx = 10;
var nny = 10;

// https://iquilezles.org/www/articles/palettes/palettes.htm
function pal(t, a, b, c, d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

function setup() {
	createCanvas(800, 800);
	
	background(0);
	
	noiseDetail(7, 0.7);
	
	var inc = 0;
	for (var nx = 0; nx < nnx; nx += 1) {
	 var nmx = nx / nnx;
	 for (var ny = 0; ny < nny; ny += 1) {
		var n = parseInt(nx + ny * nnx);
		 
		var nmy = ny / nny;
		
		var no = noise(nmx * nmy);
		 
		var ni = inc / (nnx * nny);
		
		objs[n] = {
			// paper
			//lx: width * nmx,
			//ly: height * nmy,
			lx: 0,//width / 2 + sin(ni * PI * 2) * (width / 2 * nx),
			ly: 0,//height / 2 + cos(ni * PI * 2) * (height / 16 * nx),
			// paper
			//la: random(-PI * 2, PI * 2),
			la: random() * PI * 2,
			// paper : 1
			lv: 0.9 + random(0.1),
			d: 5,
			so: 3, // agent sensor offset,
			sa: 45 // agent sensor angle (degree)
		};
		 
		if (random() > 0.5) {
			objs[n].lx = width / 2 + sin(ni * PI * 2) * (width / 2 * nx);
		} else {
			objs[n].ly = height / 2 + cos(ni * PI * 2) * (height / 16 * nx);
		}
		 
		inc += 1;
	 }
	}
	
	for (var i = 0; i < width * height; i += 1) {
		trail_map[i] = 0;
	}
	
	ellipseMode(CENTER);
	rectMode(CENTER);
}

function compute() {
	fill(0);
	
	strokeWeight(16);

	for (var nx = 0; nx < nnx; nx += 1) {
	 for (var ny = 0; ny < nny; ny += 1) {
		var n = parseInt(nx + ny * nnx);
		 
		var obj = objs[n];
		
		var sensor_offset = obj.so;
		var sensor_angle = radians(obj.sa);
		
		// agent sensors
		var lhx = round(sin(obj.la - sensor_angle) * sensor_offset);
		var lhy = round(cos(obj.la - sensor_angle) * sensor_offset);
		var fhx = round(sin(obj.la) * sensor_offset);
		var fhy = round(cos(obj.la) * sensor_offset);
		var rhx = round(sin(obj.la + sensor_angle) * sensor_offset);
		var rhy = round(cos(obj.la + sensor_angle) * sensor_offset);
		
		var ailx = parseInt(obj.lx + lhx);
		var aily = parseInt(obj.ly + lhy);
		var aifx = parseInt(obj.lx + fhx);
		var aify = parseInt(obj.ly + fhy);
		var airx = parseInt(obj.lx + rhx);
		var airy = parseInt(obj.ly + rhy);
		
		ailx = ailx < 0 ? ailx + width : ailx;
		aily = aily < 0 ? aily + height : aily;
		aifx = aifx < 0 ? aifx + width : aifx;
		aify = aify < 0 ? aify + height : aify;
		airx = airx < 0 ? airx + width : airx;
		airy = airy < 0 ? airy + height : airy;
		
		ailx %= width;
		aily %= height;
		aifx %= width;
		aify %= height;
		airx %= width;
		airy %= height;
		
		// sensor sample
		var s1 = trail_map[ailx + aily * width]; // left
		var s2 = trail_map[aifx + aify * width]; // forward
		var s3 = trail_map[airx + airy * width]; // right
		
/*
		// debug sensor
		fill(255, 0, 0, 255);
		rect(ailx, aily, 1, 1);
		rect(aifx, aify, 1, 1);
		rect(airx, airy, 1, 1);
*/	
/*
		if (frameCount % 60 == 0) {
			obj.la += PI / 2;
		}
*/
	
		// agent behavior based on sampled sensor
		if (s2 < s1 && s2 < s3) {
			// turn left or right randomly
			//obj.la += random(PI / 2, -PI / 2);
			// paper
			obj.la += (random() > 0.5 ? PI / 2 : -PI / 2);
		} else if (s1 < s3) {
			// turn left
			obj.la -= PI / 2;
		} else if (s3 < s1) {
			// turn right
			obj.la += PI / 2;
		}
		
		obj.lx += obj.lv * sin(obj.la);
		obj.ly += obj.lv * cos(obj.la);
		
		// boundary checks
		obj.lx = obj.lx < 0 ? obj.lx + width - 1 : obj.lx;
		obj.lx %= width;
		obj.ly = obj.ly < 0 ? obj.ly + height - 1 : obj.ly;
		obj.ly %= height;
		
		// deposit diffusion (3x3 mean kernel)
		// should probably go after deposit step though
		var i = parseInt(obj.lx + obj.ly * width);
		var b = trail_map[i] / 2;

		var lx = parseInt(obj.lx);
		var ly = parseInt(obj.ly);

		var xb = (lx - 1);
		var yb = (ly - 1);
		var xbl = xb < 0 ? width - 1 : xb;
		var ybl = yb < 0 ? height - 1 : yb;
		var xbu = (lx + 1) % width;
		var ybu = (ly + 1) % height;
		/*
		var v1 = trail_map[xbl + ly * width];
		var v2 = trail_map[xbu + ly * width];
		var v3 = trail_map[xbl + ybl * width];
		var v4 = trail_map[xbl + ybu * width];
		var v5 = trail_map[xbu + ybl * width];
		var v6 = trail_map[xbu + ybu * width];
		var v7 = trail_map[lx + ybl * width];
		var v8 = trail_map[lx + ybu * width];
		
		var vm = (v1 + v2 + v3 + v4 + v5 + v6 + v7 + v8) / 8 / 5;
		*/
		trail_map[xbl + ly * width] = b;
		trail_map[xbu + ly * width] = b;
		trail_map[xbl + ybl * width] = b;
		trail_map[xbl + ybu * width] = b;
		trail_map[xbu + ybl * width] = b;
		trail_map[xbu + ybu * width] = b;
		trail_map[lx + ybl * width] = b;
		trail_map[lx + ybu * width] = b;
		
		// deposit
		trail_map[i] = obj.d;
		
		// agent display
		var pa1 = 1, pa2 = 1, pa3 = 0.5;
		var pb1 = 0.5, pb2 = 0.5, pb3 = 0.5;
		var pc1 = 0.5, pc2 = 0.5, pc3 = 0.5;

		var pdr = 0.8;
		var pdg = 0.4;
		var pdb = 0.5;

		var pt = noise(obj.la / 8 + xmotion + n);
		 
		var ll = 1000;

		var rf = pal(pt, pa1, pb1, pc1, pdr) * 255;
		var gf = pal(pt, pa2, pb2, pc2, pdg) * 255;
		var bf = pal(pt, pa3, pb3, pc3, pdb) * 255;
		
		fill(rf, gf, bf, 255);
		stroke(0, 0, 0, 16/** * (min(ll, frameCount) / ll)*/);
		ellipse(obj.lx, obj.ly, 1 + pt * 3, 1 + pt * 3);
		
/*
		if (trail_map[parseInt(i)] > 1) {
			trail_map[parseInt(i)] = 1;
		}
*/
	 }
	}
	
	// deposit decay
	for (var y = 0; y < height; y += 1) {
		for (var x = 0; x < width; x += 1) {
			var v = trail_map[x + y * width];
			trail_map[x + y * width] -= 0.1;
			if (trail_map[x + y * width] < 0) {
				trail_map[x + y * width] = 0;
			}
		}
	}
/*
	if (frameCount % 60 == 0) {
		var st = 1 + parseInt(random() * (nn / 8));
		for (var y = 0; y < nn; y += st) {
			objs[y].lx = random() * width;
			objs[y].ly = random() * height;
		}
	}
*/
}

function draw() {
	noStroke();
	
	rectMode(CORNER);
/*
	fill(0, 0, 0, 8);
	rect(0, 0, width, height);
*/
	rectMode(CENTER);
	
	compute();
	
	xmotion += 0.005;
	ymotion += 0.0002;
}"
"783462","45","mySketch","// same as ""slime mold simulation"" but with greatly reduced agents, probably overkill for what it is

var xmotion = 0;
var ymotion = 0;

var objs = [];
var trail_map = [];

var nnx = 5;
var nny = 5;

// https://iquilezles.org/www/articles/palettes/palettes.htm
function pal(t, a, b, c, d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

function setup() {
	createCanvas(800, 800);
	
	background(0);
	
	noiseDetail(7, 0.7);
	
	var inc = 0;
	for (var nx = 0; nx < nnx; nx += 1) {
	 var nmx = nx / nnx;
	 for (var ny = 0; ny < nny; ny += 1) {
		var n = parseInt(nx + ny * nnx);
		 
		var nmy = ny / nny;
		
		var no = noise(nmx * nmy);
		 
		var ni = inc / (nnx * nny);
		
		objs[n] = {
			// paper
			//lx: width * nmx,
			//ly: height * nmy,
			lx: width / 2 + sin(ni * PI * 2) * (width / 16 * nx),
			ly: height / 2 + cos(ni * PI * 2) * (height / 16 * nx),
			// paper
			//la: random(-PI * 2, PI * 2),
			la: random() * PI * 2,
			// paper : 1
			lv: 0.9 + random(0.1),
			d: 5,
			so: 3, // agent sensor offset,
			sa: 45 // agent sensor angle (degree)
		};
		 
		inc += 1;
	 }
	}
	
	for (var i = 0; i < width * height; i += 1) {
		trail_map[i] = 0;//i / (width * height);
	}
	
	ellipseMode(CENTER);
	rectMode(CENTER);
}

function compute() {
	fill(0);
	
	strokeWeight(3);

	for (var nx = 0; nx < nnx; nx += 1) {
	 for (var ny = 0; ny < nny; ny += 1) {
		var n = parseInt(nx + ny * nnx);
		 
		var obj = objs[n];
		
		var sensor_offset = obj.so;
		var sensor_angle = radians(obj.sa);
		
		// agent sensors
		var lhx = round(sin(obj.la - sensor_angle) * sensor_offset);
		var lhy = round(cos(obj.la - sensor_angle) * sensor_offset);
		var fhx = round(sin(obj.la) * sensor_offset);
		var fhy = round(cos(obj.la) * sensor_offset);
		var rhx = round(sin(obj.la + sensor_angle) * sensor_offset);
		var rhy = round(cos(obj.la + sensor_angle) * sensor_offset);
		
		var ailx = parseInt(obj.lx + lhx);
		var aily = parseInt(obj.ly + lhy);
		var aifx = parseInt(obj.lx + fhx);
		var aify = parseInt(obj.ly + fhy);
		var airx = parseInt(obj.lx + rhx);
		var airy = parseInt(obj.ly + rhy);
		
		ailx = ailx < 0 ? ailx + width : ailx;
		aily = aily < 0 ? aily + height : aily;
		aifx = aifx < 0 ? aifx + width : aifx;
		aify = aify < 0 ? aify + height : aify;
		airx = airx < 0 ? airx + width : airx;
		airy = airy < 0 ? airy + height : airy;
		
		ailx %= width;
		aily %= height;
		aifx %= width;
		aify %= height;
		airx %= width;
		airy %= height;
		
		// sensor sample
		var s1 = trail_map[ailx + aily * width]; // left
		var s2 = trail_map[aifx + aify * width]; // forward
		var s3 = trail_map[airx + airy * width]; // right
		
/*
		// debug sensor
		fill(255, 0, 0, 255);
		rect(ailx, aily, 1, 1);
		rect(aifx, aify, 1, 1);
		rect(airx, airy, 1, 1);
*/	
/*
		if (frameCount % 60 == 0) {
			obj.la += PI / 2;
		}
*/
	
		// agent behavior based on sampled sensor
		if (s2 < s1 && s2 < s3) {
			// turn left or right randomly
			//obj.la += random(PI / 2, -PI / 2);
			// paper
			obj.la += (random() > 0.5 ? PI / 2 : -PI / 2);
		} else if (s1 < s3) {
			// turn left
			obj.la -= PI / 2;
		} else if (s3 < s1) {
			// turn right
			obj.la += PI / 2;
		}
		
		obj.lx += obj.lv * sin(obj.la);
		obj.ly += obj.lv * cos(obj.la);
		
		// boundary checks
		obj.lx = obj.lx < 0 ? obj.lx + width - 1 : obj.lx;
		obj.lx %= width;
		obj.ly = obj.ly < 0 ? obj.ly + height - 1 : obj.ly;
		obj.ly %= height;
		
		// deposit diffusion (3x3 mean kernel)
		// should probably go after deposit step though
		var i = parseInt(obj.lx + obj.ly * width);
		var b = trail_map[i] / 2;

		var lx = parseInt(obj.lx);
		var ly = parseInt(obj.ly);

		var xb = (lx - 1);
		var yb = (ly - 1);
		var xbl = xb < 0 ? width - 1 : xb;
		var ybl = yb < 0 ? height - 1 : yb;
		var xbu = (lx + 1) % width;
		var ybu = (ly + 1) % height;
		/*
		var v1 = trail_map[xbl + ly * width];
		var v2 = trail_map[xbu + ly * width];
		var v3 = trail_map[xbl + ybl * width];
		var v4 = trail_map[xbl + ybu * width];
		var v5 = trail_map[xbu + ybl * width];
		var v6 = trail_map[xbu + ybu * width];
		var v7 = trail_map[lx + ybl * width];
		var v8 = trail_map[lx + ybu * width];
		
		var vm = (v1 + v2 + v3 + v4 + v5 + v6 + v7 + v8) / 8 / 5;
		*/
		trail_map[xbl + ly * width] = b;
		trail_map[xbu + ly * width] = b;
		trail_map[xbl + ybl * width] = b;
		trail_map[xbl + ybu * width] = b;
		trail_map[xbu + ybl * width] = b;
		trail_map[xbu + ybu * width] = b;
		trail_map[lx + ybl * width] = b;
		trail_map[lx + ybu * width] = b;
		
		// deposit
		trail_map[i] = obj.d;
		
		// agent display
		var pa1 = 0.75, pa2 = 0.75, pa3 = 0.75;
		var pb1 = 0.5, pb2 = 0.5, pb3 = 0.5;
		var pc1 = 1, pc2 = 1, pc3 = 0.5;

		var pdr = 0.7;
		var pdg = 0.8;
		var pdb = 0.3;

		var pt = noise(obj.la / 2 + xmotion + n);
		 
		var ll = 1000;

		var rf = pal(pt, pa1, pb1, pc1, pdr) * 255;
		var gf = pal(pt, pa2, pb2, pc2, pdg) * 255;
		var bf = pal(pt, pa3, pb3, pc3, pdb) * 255;
		
		fill(rf, gf, bf, 255 * (1 - min(ll, frameCount) / ll));
		stroke(rf, gf, bf, 255 * (min(ll, frameCount) / ll));
		ellipse(obj.lx, obj.ly, 1, 1);
		
/*
		if (trail_map[parseInt(i)] > 1) {
			trail_map[parseInt(i)] = 1;
		}
*/
	 }
	}
	
	// deposit decay
	for (var y = 0; y < height; y += 1) {
		for (var x = 0; x < width; x += 1) {
			var v = trail_map[x + y * width];
			trail_map[x + y * width] -= 0.1;
			if (trail_map[x + y * width] < 0) {
				trail_map[x + y * width] = 0;
			}
		}
	}
/*
	if (frameCount % 60 == 0) {
		var st = 1 + parseInt(random() * (nn / 8));
		for (var y = 0; y < nn; y += st) {
			objs[y].lx = random() * width;
			objs[y].ly = random() * height;
		}
	}
*/
}

function draw() {
	noStroke();
	
	rectMode(CORNER);
/*
	fill(0, 0, 0, 8);
	rect(0, 0, width, height);
*/
	rectMode(CENTER);
	
	compute();
	
	xmotion += 0.005;
	ymotion += 0.0002;
}"
"781586","Slime mold simulation","mySketch","var xmotion = 0;
var ymotion = 0;

var objs = [];
var trail_map = [];
var nn = 8000;

// https://iquilezles.org/www/articles/palettes/palettes.htm
function pal(t, a, b, c, d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

function setup() {
	createCanvas(1400, 800);
	
	background(0);
	
	noiseDetail(7, 0.7);
	
	for (var n = 0; n < nn; n += 1) {
		var nm = n / nn;
		
		var no = noise(nm * 2);
		
		objs[n] = {
			lx: width / 2 + sin(nm * PI * 2) * (width / 3),
			ly: height / 2 + cos(nm * PI * 2) * (height / 3),
			la: no * PI * 8,//random(-PI * 2, PI * 2),
			lv: 1
		};
	}
	
	for (var i = 0; i < width * height; i += 1) {
		trail_map[i] = i / (width * height);
	}
	
	ellipseMode(CENTER);
	rectMode(CENTER);
}

function compute() {
	fill(0);
	
	strokeWeight(1);

	for (var n = 0; n < nn; n += 1) {
		var obj = objs[n];
		var i = obj.lx + obj.ly * width;
		
		var lhx = /*Math.sign*/round(sin(obj.la - Math.PI / 4));
		var lhy = /*Math.sign*/round(cos(obj.la - Math.PI / 4));
		var fhx = /*Math.sign*/round(sin(obj.la));
		var fhy = /*Math.sign*/round(cos(obj.la));
		var rhx = /*Math.sign*/round(sin(obj.la + Math.PI / 4));
		var rhy = /*Math.sign*/round(cos(obj.la + Math.PI / 4));
		
		var s1 = trail_map[parseInt(obj.lx + lhx) + parseInt(obj.ly + lhy) * width];
		var s2 = trail_map[parseInt(obj.lx + fhx) + parseInt(obj.ly + fhy) * width];
		var s3 = trail_map[parseInt(obj.lx + rhx) + parseInt(obj.ly + rhy) * width];
		
		var na = obj.la;
		if (s1 <= 0.25 && s2 > (0.25 && s2 <= 0.75) && s3 >= 0.75) {
			na += PI / 4;
		} else if (s1 >= 0.75 && (s2 > 0.25 && s2 <= 0.75) && s3 <= 0.25) {
			na -= PI / 4;
		} else if (s1 >= 0 && s2 <= 1 && s3 >= 0) {
			na += random() > 0.5 ? PI / 4 : -PI / 4;
		}
		
		obj.lx += obj.lv * sin(na);
		obj.ly += obj.lv * cos(na);
		
		if (obj.lx < 0) {
			obj.lx = width - obj.lx - 1;
			//obj.lv = -1;
		}
		obj.lx %= width;
		
		if (obj.ly < 0) {
			obj.ly = height - obj.ly - 1;
			//obj.lv = -1;
		}
		obj.ly %= height;
		
		var c = 255 * noise(obj.la * 8 + xmotion * 32);
		
		fill(c, c, c, 255);
		rect(obj.lx, obj.ly, 1, 1);
		/*
		fill(trail_map[parseInt(i)] * 255, 0, 0, 255);
		rect(obj.lx, obj.ly, 1, 1);
		*/
		trail_map[parseInt(i)] += 0.1;
		if (trail_map[parseInt(i)] > 1) {
			trail_map[parseInt(i)] = 1;
		}
	}
	
	for (var y = 1; y < height - 1; y += 2) {
		for (var x = 1; x < width - 1; x += 2) {
			var v = trail_map[x + y * width];
			trail_map[x + y * width] -= 0.008;
			if (trail_map[x + y * width] < 0) {
				trail_map[x + y * width] = 0;
			}
			
			var b = v / 2;
			
			trail_map[x - 1 + y * width] = b;
			trail_map[x + 1 + y * width] = b;
			trail_map[x - 1 + (y - 1) * width] = b;
			trail_map[x - 1 + (y + 1) * width] = b;
			trail_map[x + 1 + (y - 1) * width] = b;
			trail_map[x + 1 + (y + 1) * width] = b;
			trail_map[x + (y - 1) * width] = b;
			trail_map[x + (y + 1) * width] = b;
		}
	}
}

function draw() {
	noStroke();
	
	rectMode(CORNER);
/*
	fill(0, 0, 0, 24);
	rect(0, 0, width, height);
*/
	rectMode(CENTER);
	
	compute();
	
	xmotion += 0.0008;
	ymotion += 0.0002;
}"
"781586","Slime mold simulation","mySketch","var xmotion = 0;
var ymotion = 0;

var objs = [];
var trail_map = [];
var nn = 4000;

// https://iquilezles.org/www/articles/palettes/palettes.htm
function pal(t, a, b, c, d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

function setup() {
	createCanvas(200, 200);
	
	background(0);
	
	noiseDetail(7, 0.7);
	
	for (var n = 0; n < nn; n += 1) {
		var nm = n / nn;
		
		var no = noise(nm * 2);
		
		objs[n] = {
			lx: random(0, width),//width / 2 + sin(nm * PI * 2) * (width / 3),
			ly: random(0, height),//height / 2 + cos(nm * PI * 2) * (height / 3),
			la: random(-PI * 2, PI * 2),//no * PI * 2,//random(-PI * 2, PI * 2),
			lv: random(1, 1),
			d: 5
		};
	}
	
	for (var i = 0; i < width * height; i += 1) {
		trail_map[i] = 0;//random();//i / (width * height);
	}
	
	ellipseMode(CENTER);
	rectMode(CENTER);
}

function compute() {
	fill(0);
	
	strokeWeight(1);

	for (var n = 0; n < nn; n += 1) {
		var obj = objs[n];
		var i = obj.lx + obj.ly * width;
		
		var sensor_offset = 9;
		var sensor_angle = radians(22.5);//radians(45);
		
		var lhx = /*Math.sign*/round(sin(obj.la - sensor_angle) * sensor_offset);
		var lhy = /*Math.sign*/round(cos(obj.la - sensor_angle) * sensor_offset);
		var fhx = /*Math.sign*/round(sin(obj.la) * sensor_offset);
		var fhy = /*Math.sign*/round(cos(obj.la) * sensor_offset);
		var rhx = /*Math.sign*/round(sin(obj.la + sensor_angle) * sensor_offset);
		var rhy = /*Math.sign*/round(cos(obj.la + sensor_angle) * sensor_offset);
		
		var ailx = parseInt(obj.lx + lhx);
		var aily = parseInt(obj.ly + lhy);
		var aifx = parseInt(obj.lx + fhx);
		var aify = parseInt(obj.ly + fhy);
		var airx = parseInt(obj.lx + rhx);
		var airy = parseInt(obj.ly + rhy);
		
		ailx = ailx < 0 ? ailx + width : ailx;
		aily = aily < 0 ? aily + height : aily;
		aifx = aifx < 0 ? aifx + width : aifx;
		aify = aify < 0 ? aify + height : aify;
		airx = airx < 0 ? airx + width : airx;
		airy = airy < 0 ? airy + height : airy;
		
		ailx %= width;
		aily %= height;
		aifx %= width;
		aify %= height;
		airx %= width;
		airy %= height;
		
		// agent sensors
		var s1 = trail_map[ailx + aily * width]; // left
		var s2 = trail_map[aifx + aify * width]; // forward
		var s3 = trail_map[airx + airy * width]; // right
		
/*
		fill(255, 0, 0, 255);
		rect(ailx, aily, 1, 1);
		rect(aifx, aify, 1, 1);
		rect(airx, airy, 1, 1);
*/	
/*
		if (frameCount % 60 == 0) {
			obj.la += PI / 2;
		}
*/
	
		if (s2 < s1 && s2 < s3) {
			// turn left or right randomly
			obj.la += random() > 0.5 ? PI / 2 : -PI / 2;
		} else if (s1 < s3) {
			// turn left
			obj.la -= PI / 2;
		} else if (s3 < s1) {
			// turn right
			obj.la += PI / 2;
		}
		
		obj.lx += obj.lv * sin(obj.la);
		obj.ly += obj.lv * cos(obj.la);
		
		if (obj.lx < 0) {
			obj.lx = obj.lx + width - 1;
			//obj.lv = -1;
		}
		obj.lx %= width;
		
		if (obj.ly < 0) {
			obj.ly = obj.ly + height - 1;
			//obj.lv = -1;
		}
		obj.ly %= height;
		
		var c = 255;// * noise(obj.la * 8 + xmotion * 32);
		
		fill(c, c, c, 255);
		rect(obj.lx, obj.ly, 1, 1);
		/*
		fill(trail_map[parseInt(i)] * 255, 0, 0, 255);
		rect(obj.lx, obj.ly, 1, 1);
		*/
		
		trail_map[parseInt(i)] += obj.d;
		
		/*if (trail_map[parseInt(i)] > 1) {
			trail_map[parseInt(i)] = 1;
		}*/
	}
	
	for (var y = 0; y < height; y += 1) {
		for (var x = 0; x < width; x += 1) {
			var v = trail_map[x + y * width];
			trail_map[x + y * width] -= 0.1;
			if (trail_map[x + y * width] < 0) {
				trail_map[x + y * width] = 0;
			}
			
			var b = v / 2;
			
			var xb = (x - 1);
			var yb = (y - 1);
			var xbl = xb < 0 ? width - 1 : xb;
			var ybl = yb < 0 ? height - 1 : yb;
			var xbu = (x + 1) % width;
			var ybu = (y + 1) % height;
			
			trail_map[xbl + y * width] = b;
			trail_map[xbu + y * width] = b;
			trail_map[xbl + ybl * width] = b;
			trail_map[xbl + ybu * width] = b;
			trail_map[xbu + ybl * width] = b;
			trail_map[xbu + ybu * width] = b;
			trail_map[x + ybl * width] = b;
			trail_map[x + ybu * width] = b;
		}
	}
}

function draw() {
	noStroke();
	
	rectMode(CORNER);

	fill(0, 0, 0, 24);
	rect(0, 0, width, height);

	rectMode(CENTER);
	
	compute();
	
	xmotion += 0.0008;
	ymotion += 0.0002;
}"
"781586","Slime mold simulation","mySketch","var xmotion = 0;
var ymotion = 0;

var objs = [];
var trail_map = [];
var nn = 4000;

// https://iquilezles.org/www/articles/palettes/palettes.htm
function pal(t, a, b, c, d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

function setup() {
	createCanvas(200, 200);
	
	background(0);
	
	noiseDetail(7, 0.7);
	
	for (var n = 0; n < nn; n += 1) {
		var nm = n / nn;
		
		var no = noise(nm * 2);
		
		objs[n] = {
			lx: random(0, width),//width / 2 + sin(nm * PI * 2) * (width / 3),
			ly: random(0, height),//height / 2 + cos(nm * PI * 2) * (height / 3),
			la: random(-PI * 2, PI * 2),//no * PI * 2,//random(-PI * 2, PI * 2),
			lv: random(1, 1),
			d: 5
		};
	}
	
	for (var i = 0; i < width * height; i += 1) {
		trail_map[i] = 0;//random();//i / (width * height);
	}
	
	ellipseMode(CENTER);
	rectMode(CENTER);
}

function compute() {
	fill(0);
	
	strokeWeight(1);

	for (var n = 0; n < nn; n += 1) {
		var obj = objs[n];
		var i = obj.lx + obj.ly * width;
		
		var sensor_offset = 9;
		var sensor_angle = radians(45);
		
		var lhx = /*Math.sign*/round(sin(obj.la - sensor_angle) * sensor_offset);
		var lhy = /*Math.sign*/round(cos(obj.la - sensor_angle) * sensor_offset);
		var fhx = /*Math.sign*/round(sin(obj.la) * sensor_offset);
		var fhy = /*Math.sign*/round(cos(obj.la) * sensor_offset);
		var rhx = /*Math.sign*/round(sin(obj.la + sensor_angle) * sensor_offset);
		var rhy = /*Math.sign*/round(cos(obj.la + sensor_angle) * sensor_offset);
		
		var ailx = parseInt(obj.lx + lhx);
		var aily = parseInt(obj.ly + lhy);
		var aifx = parseInt(obj.lx + fhx);
		var aify = parseInt(obj.ly + fhy);
		var airx = parseInt(obj.lx + rhx);
		var airy = parseInt(obj.ly + rhy);
		
		ailx = ailx < 0 ? ailx + width : ailx;
		aily = aily < 0 ? aily + height : aily;
		aifx = aifx < 0 ? aifx + width : aifx;
		aify = aify < 0 ? aify + height : aify;
		airx = airx < 0 ? airx + width : airx;
		airy = airy < 0 ? airy + height : airy;
		
		ailx %= width;
		aily %= height;
		aifx %= width;
		aify %= height;
		airx %= width;
		airy %= height;
		
		// agent sensors
		var s1 = trail_map[ailx + aily * width]; // left
		var s2 = trail_map[aifx + aify * width]; // forward
		var s3 = trail_map[airx + airy * width]; // right
		
/*
		fill(255, 0, 0, 255);
		rect(ailx, aily, 1, 1);
		rect(aifx, aify, 1, 1);
		rect(airx, airy, 1, 1);
*/	
/*
		if (frameCount % 60 == 0) {
			obj.la += PI / 2;
		}
*/
	
		if (s2 < s1 && s2 < s3) {
			// turn left or right randomly
			obj.la += random() > 0.5 ? PI / 2 : -PI / 2;
		} else if (s1 < s3) {
			// turn left
			obj.la -= PI / 2;
		} else if (s3 < s1) {
			// turn right
			obj.la += PI / 2;
		}
		
		obj.lx += obj.lv * sin(obj.la);
		obj.ly += obj.lv * cos(obj.la);
		
		if (obj.lx < 0) {
			obj.lx = obj.lx + width - 1;
			//obj.lv = -1;
		}
		obj.lx %= width;
		
		if (obj.ly < 0) {
			obj.ly = obj.ly + height - 1;
			//obj.lv = -1;
		}
		obj.ly %= height;
		
		var c = 255;// * noise(obj.la * 8 + xmotion * 32);
		
		fill(c, c, c, 255);
		rect(obj.lx, obj.ly, 1, 1);
		/*
		fill(trail_map[parseInt(i)] * 255, 0, 0, 255);
		rect(obj.lx, obj.ly, 1, 1);
		*/
		
		trail_map[parseInt(i)] += obj.d;
		
		/*if (trail_map[parseInt(i)] > 1) {
			trail_map[parseInt(i)] = 1;
		}*/
	}
	
	for (var y = 0; y < height; y += 1) {
		for (var x = 0; x < width; x += 1) {
			var v = trail_map[x + y * width];
			trail_map[x + y * width] -= 0.1;
			if (trail_map[x + y * width] < 0) {
				trail_map[x + y * width] = 0;
			}
			
			var b = v / 2;
			
			var xb = (x - 1);
			var yb = (y - 1);
			var xbl = xb < 0 ? width - 1 : xb;
			var ybl = yb < 0 ? height - 1 : yb;
			var xbu = (x + 1) % width;
			var ybu = (y + 1) % height;
			
			trail_map[xbl + y * width] = b;
			trail_map[xbu + y * width] = b;
			trail_map[xbl + ybl * width] = b;
			trail_map[xbl + ybu * width] = b;
			trail_map[xbu + ybl * width] = b;
			trail_map[xbu + ybu * width] = b;
			trail_map[x + ybl * width] = b;
			trail_map[x + ybu * width] = b;
		}
	}
}

function draw() {
	noStroke();
	
	rectMode(CORNER);

	fill(0, 0, 0, 24);
	rect(0, 0, width, height);

	rectMode(CENTER);
	
	compute();
	
	xmotion += 0.0008;
	ymotion += 0.0002;
}"
"781586","Slime mold simulation","mySketch","// slime mold simulation (Physarum polycephalum)
// based on 2010 paper by Jeff Jones, “Characteristics of pattern formation and evolution in approximations of Physarum transport networks.”
// http://eprints.uwe.ac.uk/15260/1/artl.2010.16.2.pdf

var xmotion = 0;
var ymotion = 0;

var objs = [];
var trail_map = [];
var nn = 8000;

// https://iquilezles.org/www/articles/palettes/palettes.htm
function pal(t, a, b, c, d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

function setup() {
	createCanvas(300, 300);
	
	background(0);
	
	noiseDetail(7, 0.7);
	
	for (var n = 0; n < nn; n += 1) {
		var nm = n / nn;
		
		var no = noise(nm);
		
		objs[n] = {
			// paper
			lx: random(0, width),
			ly: random(0, height),
			//lx: width / 2 + sin(nm * PI * 2) * (width / 4 * no),
			//ly: height / 2 + cos(nm * PI * 2) * (height / 4 * no),
			// paper
			//la: random(-PI * 2, PI * 2),
			la: no * PI * 2,
			// paper : 1
			lv: 1,
			d: 5
		};
	}
	
	for (var i = 0; i < width * height; i += 1) {
		trail_map[i] = 0;//random();//i / (width * height);
	}
	
	ellipseMode(CENTER);
	rectMode(CENTER);
}

function compute() {
	fill(0);
	
	strokeWeight(1);

	for (var n = 0; n < nn; n += 1) {
		var obj = objs[n];
		
		var sensor_offset = 9;
		var sensor_angle = radians(45);
		
		// agent sensors
		var lhx = round(sin(obj.la - sensor_angle) * sensor_offset);
		var lhy = round(cos(obj.la - sensor_angle) * sensor_offset);
		var fhx = round(sin(obj.la) * sensor_offset);
		var fhy = round(cos(obj.la) * sensor_offset);
		var rhx = round(sin(obj.la + sensor_angle) * sensor_offset);
		var rhy = round(cos(obj.la + sensor_angle) * sensor_offset);
		
		var ailx = parseInt(obj.lx + lhx);
		var aily = parseInt(obj.ly + lhy);
		var aifx = parseInt(obj.lx + fhx);
		var aify = parseInt(obj.ly + fhy);
		var airx = parseInt(obj.lx + rhx);
		var airy = parseInt(obj.ly + rhy);
		
		ailx = ailx < 0 ? ailx + width : ailx;
		aily = aily < 0 ? aily + height : aily;
		aifx = aifx < 0 ? aifx + width : aifx;
		aify = aify < 0 ? aify + height : aify;
		airx = airx < 0 ? airx + width : airx;
		airy = airy < 0 ? airy + height : airy;
		
		ailx %= width;
		aily %= height;
		aifx %= width;
		aify %= height;
		airx %= width;
		airy %= height;
		
		// sensor sample
		var s1 = trail_map[ailx + aily * width]; // left
		var s2 = trail_map[aifx + aify * width]; // forward
		var s3 = trail_map[airx + airy * width]; // right
		
/*
		// debug sensor
		fill(255, 0, 0, 255);
		rect(ailx, aily, 1, 1);
		rect(aifx, aify, 1, 1);
		rect(airx, airy, 1, 1);
*/	
/*
		if (frameCount % 60 == 0) {
			obj.la += PI / 2;
		}
*/
	
		// agent behavior based on sampled sensor
		if (s2 < s1 && s2 < s3) {
			// turn left or right randomly
			obj.la += random() > 0.5 ? PI / 2 : -PI / 2;
		} else if (s1 < s3) {
			// turn left
			obj.la -= PI / 2;
		} else if (s3 < s1) {
			// turn right
			obj.la += PI / 2;
		}
		
		obj.lx += obj.lv * sin(obj.la);
		obj.ly += obj.lv * cos(obj.la);
		
		// boundary checks
		if (obj.lx < 0) {
			obj.lx = obj.lx + width - 1;
			//obj.lv = -1;
		}
		obj.lx %= width;
		
		if (obj.ly < 0) {
			obj.ly = obj.ly + height - 1;
			//obj.lv = -1;
		}
		obj.ly %= height;
		
		// agent display
		var c = 255;
		fill(c, c, c, 255);
		rect(obj.lx, obj.ly, 1, 1);
		
		// deposit diffusion (3x3 mean kernel)
		// should probably go after deposit step though
		var i = parseInt(obj.lx + obj.ly * width);
		var b = trail_map[i] / 2;

		var lx = parseInt(obj.lx);
		var ly = parseInt(obj.ly);

		var xb = (lx - 1);
		var yb = (ly - 1);
		var xbl = xb < 0 ? width - 1 : xb;
		var ybl = yb < 0 ? height - 1 : yb;
		var xbu = (lx + 1) % width;
		var ybu = (ly + 1) % height;

		trail_map[xbl + ly * width] = b;
		trail_map[xbu + ly * width] = b;
		trail_map[xbl + ybl * width] = b;
		trail_map[xbl + ybu * width] = b;
		trail_map[xbu + ybl * width] = b;
		trail_map[xbu + ybu * width] = b;
		trail_map[lx + ybl * width] = b;
		trail_map[lx + ybu * width] = b;
		
		// deposit
		trail_map[i] = obj.d;
		
/*
		if (trail_map[parseInt(i)] > 1) {
			trail_map[parseInt(i)] = 1;
		}
*/
	}
	
	// deposit decay
	for (var y = 0; y < height; y += 1) {
		for (var x = 0; x < width; x += 1) {
			var v = trail_map[x + y * width];
			trail_map[x + y * width] -= 0.1;
			if (trail_map[x + y * width] < 0) {
				trail_map[x + y * width] = 0;
			}
		}
	}
}

function draw() {
	noStroke();
	
	rectMode(CORNER);

	fill(0, 0, 0, 24);
	rect(0, 0, width, height);

	rectMode(CENTER);
	
	compute();
	
	xmotion += 0.0008;
	ymotion += 0.0002;
}"
"781586","Slime mold simulation","mySketch","// slime mold simulation (Physarum polycephalum)
// based on 2010 paper by Jeff Jones, “Characteristics of pattern formation and evolution in approximations of Physarum transport networks.”
// http://eprints.uwe.ac.uk/15260/1/artl.2010.16.2.pdf

var xmotion = 0;
var ymotion = 0;

var objs = [];
var trail_map = [];
var nn = 8000;

// https://iquilezles.org/www/articles/palettes/palettes.htm
function pal(t, a, b, c, d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

function setup() {
	createCanvas(300, 300);
	
	background(0);
	
	noiseDetail(7, 0.7);
	
	for (var n = 0; n < nn; n += 1) {
		var nm = n / nn;
		
		var no = noise(nm);
		
		objs[n] = {
			// paper
			lx: random(0, width),
			ly: random(0, height),
			//lx: width / 2 + sin(nm * PI * 2) * (width / 4 * no),
			//ly: height / 2 + cos(nm * PI * 2) * (height / 4 * no),
			// paper
			//la: random(-PI * 2, PI * 2),
			la: no * PI * 2,
			// paper : 1
			lv: 1,
			d: 5
		};
	}
	
	for (var i = 0; i < width * height; i += 1) {
		trail_map[i] = 0;//random();//i / (width * height);
	}
	
	ellipseMode(CENTER);
	rectMode(CENTER);
}

function compute() {
	fill(0);
	
	strokeWeight(1);

	for (var n = 0; n < nn; n += 1) {
		var obj = objs[n];
		
		var sensor_offset = 9;
		var sensor_angle = radians(45);
		
		// agent sensors
		var lhx = round(sin(obj.la - sensor_angle) * sensor_offset);
		var lhy = round(cos(obj.la - sensor_angle) * sensor_offset);
		var fhx = round(sin(obj.la) * sensor_offset);
		var fhy = round(cos(obj.la) * sensor_offset);
		var rhx = round(sin(obj.la + sensor_angle) * sensor_offset);
		var rhy = round(cos(obj.la + sensor_angle) * sensor_offset);
		
		var ailx = parseInt(obj.lx + lhx);
		var aily = parseInt(obj.ly + lhy);
		var aifx = parseInt(obj.lx + fhx);
		var aify = parseInt(obj.ly + fhy);
		var airx = parseInt(obj.lx + rhx);
		var airy = parseInt(obj.ly + rhy);
		
		ailx = ailx < 0 ? ailx + width : ailx;
		aily = aily < 0 ? aily + height : aily;
		aifx = aifx < 0 ? aifx + width : aifx;
		aify = aify < 0 ? aify + height : aify;
		airx = airx < 0 ? airx + width : airx;
		airy = airy < 0 ? airy + height : airy;
		
		ailx %= width;
		aily %= height;
		aifx %= width;
		aify %= height;
		airx %= width;
		airy %= height;
		
		// sensor sample
		var s1 = trail_map[ailx + aily * width]; // left
		var s2 = trail_map[aifx + aify * width]; // forward
		var s3 = trail_map[airx + airy * width]; // right
		
/*
		// debug sensor
		fill(255, 0, 0, 255);
		rect(ailx, aily, 1, 1);
		rect(aifx, aify, 1, 1);
		rect(airx, airy, 1, 1);
*/	
/*
		if (frameCount % 60 == 0) {
			obj.la += PI / 2;
		}
*/
	
		// agent behavior based on sampled sensor
		if (s2 < s1 && s2 < s3) {
			// turn left or right randomly
			obj.la += random() > 0.5 ? PI / 2 : -PI / 2;
		} else if (s1 < s3) {
			// turn left
			obj.la -= PI / 2;
		} else if (s3 < s1) {
			// turn right
			obj.la += PI / 2;
		}
		
		obj.lx += obj.lv * sin(obj.la);
		obj.ly += obj.lv * cos(obj.la);
		
		// boundary checks
		obj.lx = obj.lx < 0 ? obj.lx + width - 1 : obj.lx;
		obj.lx %= width;
		obj.ly = obj.ly < 0 ? obj.ly + height - 1 : obj.ly;
		obj.ly %= height;
		
		// agent display
		var c = 255;
		fill(c, c, c, 255);
		rect(obj.lx, obj.ly, 1, 1);
		
		// deposit diffusion (3x3 mean kernel)
		// should probably go after deposit step though
		var i = parseInt(obj.lx + obj.ly * width);
		var b = trail_map[i] / 2;

		var lx = parseInt(obj.lx);
		var ly = parseInt(obj.ly);

		var xb = (lx - 1);
		var yb = (ly - 1);
		var xbl = xb < 0 ? width - 1 : xb;
		var ybl = yb < 0 ? height - 1 : yb;
		var xbu = (lx + 1) % width;
		var ybu = (ly + 1) % height;

		trail_map[xbl + ly * width] = b;
		trail_map[xbu + ly * width] = b;
		trail_map[xbl + ybl * width] = b;
		trail_map[xbl + ybu * width] = b;
		trail_map[xbu + ybl * width] = b;
		trail_map[xbu + ybu * width] = b;
		trail_map[lx + ybl * width] = b;
		trail_map[lx + ybu * width] = b;
		
		// deposit
		trail_map[i] = obj.d;
		
/*
		if (trail_map[parseInt(i)] > 1) {
			trail_map[parseInt(i)] = 1;
		}
*/
	}
	
	// deposit decay
	for (var y = 0; y < height; y += 1) {
		for (var x = 0; x < width; x += 1) {
			var v = trail_map[x + y * width];
			trail_map[x + y * width] -= 0.1;
			if (trail_map[x + y * width] < 0) {
				trail_map[x + y * width] = 0;
			}
		}
	}
}

function draw() {
	noStroke();
	
	rectMode(CORNER);

	fill(0, 0, 0, 24);
	rect(0, 0, width, height);

	rectMode(CENTER);
	
	compute();
	
	xmotion += 0.0008;
	ymotion += 0.0002;
}"
"781586","Slime mold simulation","mySketch","// slime mold simulation (Physarum polycephalum)
// based on 2010 paper by Jeff Jones, “Characteristics of pattern formation and evolution in approximations of Physarum transport networks.”
// http://eprints.uwe.ac.uk/15260/1/artl.2010.16.2.pdf

var xmotion = 0;
var ymotion = 0;

var objs = [];
var trail_map = [];
var nn = 8000;

// https://iquilezles.org/www/articles/palettes/palettes.htm
function pal(t, a, b, c, d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

function setup() {
	createCanvas(300, 300);
	
	background(0);
	
	noiseDetail(7, 0.7);
	
	for (var n = 0; n < nn; n += 1) {
		var nm = n / nn;
		
		var no = noise(nm);
		
		objs[n] = {
			// paper
			lx: random(0, width),
			ly: random(0, height),
			//lx: width / 2 + sin(nm * PI * 2) * (width / 4 * no),
			//ly: height / 2 + cos(nm * PI * 2) * (height / 4 * no),
			// paper
			//la: random(-PI * 2, PI * 2),
			la: no * PI * 2,
			// paper : 1
			lv: 1,
			d: 5,
			so: 3 + 6 * no, // agent sensor offset,
			sa: 22.5 + 22.5 * no // agent sensor angle (degree)
		};
	}
	
	for (var i = 0; i < width * height; i += 1) {
		trail_map[i] = 0;//random();//i / (width * height);
	}
	
	ellipseMode(CENTER);
	rectMode(CENTER);
}

function compute() {
	fill(0);
	
	strokeWeight(1);

	for (var n = 0; n < nn; n += 1) {
		var obj = objs[n];
		
		var sensor_offset = obj.so;
		var sensor_angle = radians(obj.sa);
		
		// agent sensors
		var lhx = round(sin(obj.la - sensor_angle) * sensor_offset);
		var lhy = round(cos(obj.la - sensor_angle) * sensor_offset);
		var fhx = round(sin(obj.la) * sensor_offset);
		var fhy = round(cos(obj.la) * sensor_offset);
		var rhx = round(sin(obj.la + sensor_angle) * sensor_offset);
		var rhy = round(cos(obj.la + sensor_angle) * sensor_offset);
		
		var ailx = parseInt(obj.lx + lhx);
		var aily = parseInt(obj.ly + lhy);
		var aifx = parseInt(obj.lx + fhx);
		var aify = parseInt(obj.ly + fhy);
		var airx = parseInt(obj.lx + rhx);
		var airy = parseInt(obj.ly + rhy);
		
		ailx = ailx < 0 ? ailx + width : ailx;
		aily = aily < 0 ? aily + height : aily;
		aifx = aifx < 0 ? aifx + width : aifx;
		aify = aify < 0 ? aify + height : aify;
		airx = airx < 0 ? airx + width : airx;
		airy = airy < 0 ? airy + height : airy;
		
		ailx %= width;
		aily %= height;
		aifx %= width;
		aify %= height;
		airx %= width;
		airy %= height;
		
		// sensor sample
		var s1 = trail_map[ailx + aily * width]; // left
		var s2 = trail_map[aifx + aify * width]; // forward
		var s3 = trail_map[airx + airy * width]; // right
		
/*
		// debug sensor
		fill(255, 0, 0, 255);
		rect(ailx, aily, 1, 1);
		rect(aifx, aify, 1, 1);
		rect(airx, airy, 1, 1);
*/	
/*
		if (frameCount % 60 == 0) {
			obj.la += PI / 2;
		}
*/
	
		// agent behavior based on sampled sensor
		if (s2 < s1 && s2 < s3) {
			// turn left or right randomly
			obj.la += random(PI / 2, -PI / 2);
			// paper
			//obj.la += random() > 0.5 ? PI / 2 : -PI / 2;
		} else if (s1 < s3) {
			// turn left
			obj.la -= PI / 2;
		} else if (s3 < s1) {
			// turn right
			obj.la += PI / 2;
		}
		
		obj.lx += obj.lv * sin(obj.la);
		obj.ly += obj.lv * cos(obj.la);
		
		// boundary checks
		obj.lx = obj.lx < 0 ? obj.lx + width - 1 : obj.lx;
		obj.lx %= width;
		obj.ly = obj.ly < 0 ? obj.ly + height - 1 : obj.ly;
		obj.ly %= height;
		
		// deposit diffusion (3x3 mean kernel)
		// should probably go after deposit step though
		var i = parseInt(obj.lx + obj.ly * width);
		var b = trail_map[i] / 2;

		var lx = parseInt(obj.lx);
		var ly = parseInt(obj.ly);

		var xb = (lx - 1);
		var yb = (ly - 1);
		var xbl = xb < 0 ? width - 1 : xb;
		var ybl = yb < 0 ? height - 1 : yb;
		var xbu = (lx + 1) % width;
		var ybu = (ly + 1) % height;
		/*
		var v1 = trail_map[xbl + ly * width];
		var v2 = trail_map[xbu + ly * width];
		var v3 = trail_map[xbl + ybl * width];
		var v4 = trail_map[xbl + ybu * width];
		var v5 = trail_map[xbu + ybl * width];
		var v6 = trail_map[xbu + ybu * width];
		var v7 = trail_map[lx + ybl * width];
		var v8 = trail_map[lx + ybu * width];
		
		var vm = (v1 + v2 + v3 + v4 + v5 + v6 + v7 + v8) / 8 / 5;
		*/
		trail_map[xbl + ly * width] = b;
		trail_map[xbu + ly * width] = b;
		trail_map[xbl + ybl * width] = b;
		trail_map[xbl + ybu * width] = b;
		trail_map[xbu + ybl * width] = b;
		trail_map[xbu + ybu * width] = b;
		trail_map[lx + ybl * width] = b;
		trail_map[lx + ybu * width] = b;
		
		// deposit
		trail_map[i] = obj.d;
		
		// agent display
		var c = 255;
		fill(c, c, c, 255);
		rect(obj.lx, obj.ly, 1, 1);
		
/*
		if (trail_map[parseInt(i)] > 1) {
			trail_map[parseInt(i)] = 1;
		}
*/
	}
	
	// deposit decay
	for (var y = 0; y < height; y += 1) {
		for (var x = 0; x < width; x += 1) {
			var v = trail_map[x + y * width];
			trail_map[x + y * width] -= 0.1;
			if (trail_map[x + y * width] < 0) {
				trail_map[x + y * width] = 0;
			}
		}
	}
}

function draw() {
	noStroke();
	
	rectMode(CORNER);

	fill(0, 0, 0, 24);
	rect(0, 0, width, height);

	rectMode(CENTER);
	
	compute();
	
	xmotion += 0.0008;
	ymotion += 0.0002;
}"
"781586","Slime mold simulation","mySketch","// slime mold simulation (Physarum polycephalum)
// based on 2010 paper by Jeff Jones, “Characteristics of pattern formation and evolution in approximations of Physarum transport networks.”
// http://eprints.uwe.ac.uk/15260/1/artl.2010.16.2.pdf

var xmotion = 0;
var ymotion = 0;

var objs = [];
var trail_map = [];
var nn = 8000;

// https://iquilezles.org/www/articles/palettes/palettes.htm
function pal(t, a, b, c, d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

function setup() {
	createCanvas(400, 400);
	
	background(0);
	
	noiseDetail(7, 0.7);
	
	for (var n = 0; n < nn; n += 1) {
		var nm = n / nn;
		
		var no = noise(nm);
		
		objs[n] = {
			// paper
			lx: random(0, width),
			ly: random(0, height),
			//lx: width / 2 + sin(nm * PI * 2) * (width / 4 * no),
			//ly: height / 2 + cos(nm * PI * 2) * (height / 4 * no),
			// paper
			//la: random(-PI * 2, PI * 2),
			la: no * PI * 2,
			// paper : 1
			lv: 1,
			d: 5,
			so: 3 + 6 * no, // agent sensor offset,
			sa: 22.5 + 22.5 * no // agent sensor angle (degree)
		};
	}
	
	for (var i = 0; i < width * height; i += 1) {
		trail_map[i] = 0;//random();//i / (width * height);
	}
	
	ellipseMode(CENTER);
	rectMode(CENTER);
}

function compute() {
	fill(0);
	
	strokeWeight(1);

	for (var n = 0; n < nn; n += 1) {
		var obj = objs[n];
		
		var sensor_offset = obj.so;
		var sensor_angle = radians(obj.sa);
		
		// agent sensors
		var lhx = round(sin(obj.la - sensor_angle) * sensor_offset);
		var lhy = round(cos(obj.la - sensor_angle) * sensor_offset);
		var fhx = round(sin(obj.la) * sensor_offset);
		var fhy = round(cos(obj.la) * sensor_offset);
		var rhx = round(sin(obj.la + sensor_angle) * sensor_offset);
		var rhy = round(cos(obj.la + sensor_angle) * sensor_offset);
		
		var ailx = parseInt(obj.lx + lhx);
		var aily = parseInt(obj.ly + lhy);
		var aifx = parseInt(obj.lx + fhx);
		var aify = parseInt(obj.ly + fhy);
		var airx = parseInt(obj.lx + rhx);
		var airy = parseInt(obj.ly + rhy);
		
		ailx = ailx < 0 ? ailx + width : ailx;
		aily = aily < 0 ? aily + height : aily;
		aifx = aifx < 0 ? aifx + width : aifx;
		aify = aify < 0 ? aify + height : aify;
		airx = airx < 0 ? airx + width : airx;
		airy = airy < 0 ? airy + height : airy;
		
		ailx %= width;
		aily %= height;
		aifx %= width;
		aify %= height;
		airx %= width;
		airy %= height;
		
		// sensor sample
		var s1 = trail_map[ailx + aily * width]; // left
		var s2 = trail_map[aifx + aify * width]; // forward
		var s3 = trail_map[airx + airy * width]; // right
		
/*
		// debug sensor
		fill(255, 0, 0, 255);
		rect(ailx, aily, 1, 1);
		rect(aifx, aify, 1, 1);
		rect(airx, airy, 1, 1);
*/	
/*
		if (frameCount % 60 == 0) {
			obj.la += PI / 2;
		}
*/
	
		// agent behavior based on sampled sensor
		if (s2 < s1 && s2 < s3) {
			// turn left or right randomly
			obj.la += random(PI / 2, -PI / 2);
			// paper
			//obj.la += random() > 0.5 ? PI / 2 : -PI / 2;
		} else if (s1 < s3) {
			// turn left
			obj.la -= PI / 2;
		} else if (s3 < s1) {
			// turn right
			obj.la += PI / 2;
		}
		
		obj.lx += obj.lv * sin(obj.la);
		obj.ly += obj.lv * cos(obj.la);
		
		// boundary checks
		obj.lx = obj.lx < 0 ? obj.lx + width - 1 : obj.lx;
		obj.lx %= width;
		obj.ly = obj.ly < 0 ? obj.ly + height - 1 : obj.ly;
		obj.ly %= height;
		
		// deposit diffusion (3x3 mean kernel)
		// should probably go after deposit step though
		var i = parseInt(obj.lx + obj.ly * width);
		var b = trail_map[i] / 2;

		var lx = parseInt(obj.lx);
		var ly = parseInt(obj.ly);

		var xb = (lx - 1);
		var yb = (ly - 1);
		var xbl = xb < 0 ? width - 1 : xb;
		var ybl = yb < 0 ? height - 1 : yb;
		var xbu = (lx + 1) % width;
		var ybu = (ly + 1) % height;
		/*
		var v1 = trail_map[xbl + ly * width];
		var v2 = trail_map[xbu + ly * width];
		var v3 = trail_map[xbl + ybl * width];
		var v4 = trail_map[xbl + ybu * width];
		var v5 = trail_map[xbu + ybl * width];
		var v6 = trail_map[xbu + ybu * width];
		var v7 = trail_map[lx + ybl * width];
		var v8 = trail_map[lx + ybu * width];
		
		var vm = (v1 + v2 + v3 + v4 + v5 + v6 + v7 + v8) / 8 / 5;
		*/
		trail_map[xbl + ly * width] = b;
		trail_map[xbu + ly * width] = b;
		trail_map[xbl + ybl * width] = b;
		trail_map[xbl + ybu * width] = b;
		trail_map[xbu + ybl * width] = b;
		trail_map[xbu + ybu * width] = b;
		trail_map[lx + ybl * width] = b;
		trail_map[lx + ybu * width] = b;
		
		// deposit
		trail_map[i] = obj.d;
		
		// agent display
		var c = 255;
		fill(c, c, c, 255);
		rect(obj.lx, obj.ly, 1, 1);
		
/*
		if (trail_map[parseInt(i)] > 1) {
			trail_map[parseInt(i)] = 1;
		}
*/
	}
	
	// deposit decay
	for (var y = 0; y < height; y += 1) {
		for (var x = 0; x < width; x += 1) {
			var v = trail_map[x + y * width];
			trail_map[x + y * width] -= 0.1;
			if (trail_map[x + y * width] < 0) {
				trail_map[x + y * width] = 0;
			}
		}
	}
}

function draw() {
	noStroke();
	
	rectMode(CORNER);

	fill(0, 0, 0, 24);
	rect(0, 0, width, height);

	rectMode(CENTER);
	
	compute();
	
	xmotion += 0.0008;
	ymotion += 0.0002;
}"
"781586","Slime mold simulation","mySketch","// slime mold simulation (Physarum polycephalum)
// based on 2010 paper by Jeff Jones, “Characteristics of pattern formation and evolution in approximations of Physarum transport networks.”
// http://eprints.uwe.ac.uk/15260/1/artl.2010.16.2.pdf

var xmotion = 0;
var ymotion = 0;

var objs = [];
var trail_map = [];
var nn = 8000;

// https://iquilezles.org/www/articles/palettes/palettes.htm
function pal(t, a, b, c, d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

function setup() {
	createCanvas(400, 400);
	
	background(0);
	
	noiseDetail(7, 0.7);
	
	for (var n = 0; n < nn; n += 1) {
		var nm = n / nn;
		
		var no = noise(nm);
		
		objs[n] = {
			// paper
			lx: random(0, width),
			ly: random(0, height),
			//lx: width / 2 + sin(nm * PI * 2) * (width / 4 * no),
			//ly: height / 2 + cos(nm * PI * 2) * (height / 4 * no),
			// paper
			//la: random(-PI * 2, PI * 2),
			la: no * PI * 2,
			// paper : 1
			lv: 1,
			d: 5,
			so: 3 + 6 * no, // agent sensor offset,
			sa: 22.5 + 22.5 * no // agent sensor angle (degree)
		};
	}
	
	for (var i = 0; i < width * height; i += 1) {
		trail_map[i] = 0;//random();//i / (width * height);
	}
	
	ellipseMode(CENTER);
	rectMode(CENTER);
}

function compute() {
	fill(0);
	
	strokeWeight(1);

	for (var n = 0; n < nn; n += 1) {
		var obj = objs[n];
		
		var sensor_offset = obj.so;
		var sensor_angle = radians(obj.sa);
		
		// agent sensors
		var lhx = round(sin(obj.la - sensor_angle) * sensor_offset);
		var lhy = round(cos(obj.la - sensor_angle) * sensor_offset);
		var fhx = round(sin(obj.la) * sensor_offset);
		var fhy = round(cos(obj.la) * sensor_offset);
		var rhx = round(sin(obj.la + sensor_angle) * sensor_offset);
		var rhy = round(cos(obj.la + sensor_angle) * sensor_offset);
		
		var ailx = parseInt(obj.lx + lhx);
		var aily = parseInt(obj.ly + lhy);
		var aifx = parseInt(obj.lx + fhx);
		var aify = parseInt(obj.ly + fhy);
		var airx = parseInt(obj.lx + rhx);
		var airy = parseInt(obj.ly + rhy);
		
		ailx = ailx < 0 ? ailx + width : ailx;
		aily = aily < 0 ? aily + height : aily;
		aifx = aifx < 0 ? aifx + width : aifx;
		aify = aify < 0 ? aify + height : aify;
		airx = airx < 0 ? airx + width : airx;
		airy = airy < 0 ? airy + height : airy;
		
		ailx %= width;
		aily %= height;
		aifx %= width;
		aify %= height;
		airx %= width;
		airy %= height;
		
		// sensor sample
		var s1 = trail_map[ailx + aily * width]; // left
		var s2 = trail_map[aifx + aify * width]; // forward
		var s3 = trail_map[airx + airy * width]; // right
		
/*
		// debug sensor
		fill(255, 0, 0, 255);
		rect(ailx, aily, 1, 1);
		rect(aifx, aify, 1, 1);
		rect(airx, airy, 1, 1);
*/	
/*
		if (frameCount % 60 == 0) {
			obj.la += PI / 2;
		}
*/
	
		// agent behavior based on sampled sensor
		if (s2 < s1 && s2 < s3) {
			// turn left or right randomly
			obj.la += random(PI / 2, -PI / 2);
			// paper
			//obj.la += random() > 0.5 ? PI / 2 : -PI / 2;
		} else if (s1 < s3) {
			// turn left
			obj.la -= PI / 2;
		} else if (s3 < s1) {
			// turn right
			obj.la += PI / 2;
		}
		
		obj.lx += obj.lv * sin(obj.la);
		obj.ly += obj.lv * cos(obj.la);
		
		// boundary checks
		obj.lx = obj.lx < 0 ? obj.lx + width - 1 : obj.lx;
		obj.lx %= width;
		obj.ly = obj.ly < 0 ? obj.ly + height - 1 : obj.ly;
		obj.ly %= height;
		
		// deposit diffusion (3x3 mean kernel)
		// should probably go after deposit step though
		var i = parseInt(obj.lx + obj.ly * width);
		var b = trail_map[i] / 2;

		var lx = parseInt(obj.lx);
		var ly = parseInt(obj.ly);

		var xb = (lx - 1);
		var yb = (ly - 1);
		var xbl = xb < 0 ? width - 1 : xb;
		var ybl = yb < 0 ? height - 1 : yb;
		var xbu = (lx + 1) % width;
		var ybu = (ly + 1) % height;
		/*
		var v1 = trail_map[xbl + ly * width];
		var v2 = trail_map[xbu + ly * width];
		var v3 = trail_map[xbl + ybl * width];
		var v4 = trail_map[xbl + ybu * width];
		var v5 = trail_map[xbu + ybl * width];
		var v6 = trail_map[xbu + ybu * width];
		var v7 = trail_map[lx + ybl * width];
		var v8 = trail_map[lx + ybu * width];
		
		var vm = (v1 + v2 + v3 + v4 + v5 + v6 + v7 + v8) / 8 / 5;
		*/
		trail_map[xbl + ly * width] = b;
		trail_map[xbu + ly * width] = b;
		trail_map[xbl + ybl * width] = b;
		trail_map[xbl + ybu * width] = b;
		trail_map[xbu + ybl * width] = b;
		trail_map[xbu + ybu * width] = b;
		trail_map[lx + ybl * width] = b;
		trail_map[lx + ybu * width] = b;
		
		// deposit
		trail_map[i] = obj.d;
		
		// agent display
		var c = 255;
		fill(c, c, c, 255);
		rect(obj.lx, obj.ly, 1, 1);
		
/*
		if (trail_map[parseInt(i)] > 1) {
			trail_map[parseInt(i)] = 1;
		}
*/
	}
	
	// deposit decay
	for (var y = 0; y < height; y += 1) {
		for (var x = 0; x < width; x += 1) {
			var v = trail_map[x + y * width];
			trail_map[x + y * width] -= 0.1;
			if (trail_map[x + y * width] < 0) {
				trail_map[x + y * width] = 0;
			}
		}
	}
	/*
	if (frameCount % (60 * 1) == 0) {
		for (var j = 0; j < width * height; j += 1) {
			trail_map[j] = random(0, 5);
		}
	}
	*/
}

function draw() {
	noStroke();
	
	rectMode(CORNER);

	fill(0, 0, 0, 24);
	rect(0, 0, width, height);

	rectMode(CENTER);
	
	compute();
	
	xmotion += 0.0008;
	ymotion += 0.0002;
}"
"781586","Slime mold simulation","mySketch","// slime mold simulation (Physarum polycephalum)
// based on 2010 paper by Jeff Jones, “Characteristics of pattern formation and evolution in approximations of Physarum transport networks.”
// http://eprints.uwe.ac.uk/15260/1/artl.2010.16.2.pdf

var xmotion = 0;
var ymotion = 0;

var objs = [];
var trail_map = [];
var nn = 18000;

// https://iquilezles.org/www/articles/palettes/palettes.htm
function pal(t, a, b, c, d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

function setup() {
	createCanvas(400, 400);
	
	background(0);
	
	noiseDetail(7, 0.7);
	
	for (var n = 0; n < nn; n += 1) {
		var nm = n / nn;
		
		var no = noise(nm);
		
		objs[n] = {
			// paper
			lx: random(0, width),
			ly: random(0, height),
			//lx: width / 2 + sin(nm * PI * 2) * (width / 4 * no),
			//ly: height / 2 + cos(nm * PI * 2) * (height / 4 * no),
			// paper
			//la: random(-PI * 2, PI * 2),
			la: no * PI * 2,
			// paper : 1
			lv: 1,
			d: 5,
			so: 3 + 6 * no, // agent sensor offset,
			sa: 22.5 + 22.5 * no // agent sensor angle (degree)
		};
	}
	
	for (var i = 0; i < width * height; i += 1) {
		trail_map[i] = 0;//random();//i / (width * height);
	}
	
	ellipseMode(CENTER);
	rectMode(CENTER);
}

function compute() {
	fill(0);
	
	strokeWeight(1);

	for (var n = 0; n < nn; n += 1) {
		var obj = objs[n];
		
		var sensor_offset = obj.so;
		var sensor_angle = radians(obj.sa);
		
		// agent sensors
		var lhx = round(sin(obj.la - sensor_angle) * sensor_offset);
		var lhy = round(cos(obj.la - sensor_angle) * sensor_offset);
		var fhx = round(sin(obj.la) * sensor_offset);
		var fhy = round(cos(obj.la) * sensor_offset);
		var rhx = round(sin(obj.la + sensor_angle) * sensor_offset);
		var rhy = round(cos(obj.la + sensor_angle) * sensor_offset);
		
		var ailx = parseInt(obj.lx + lhx);
		var aily = parseInt(obj.ly + lhy);
		var aifx = parseInt(obj.lx + fhx);
		var aify = parseInt(obj.ly + fhy);
		var airx = parseInt(obj.lx + rhx);
		var airy = parseInt(obj.ly + rhy);
		
		ailx = ailx < 0 ? ailx + width : ailx;
		aily = aily < 0 ? aily + height : aily;
		aifx = aifx < 0 ? aifx + width : aifx;
		aify = aify < 0 ? aify + height : aify;
		airx = airx < 0 ? airx + width : airx;
		airy = airy < 0 ? airy + height : airy;
		
		ailx %= width;
		aily %= height;
		aifx %= width;
		aify %= height;
		airx %= width;
		airy %= height;
		
		// sensor sample
		var s1 = trail_map[ailx + aily * width]; // left
		var s2 = trail_map[aifx + aify * width]; // forward
		var s3 = trail_map[airx + airy * width]; // right
		
/*
		// debug sensor
		fill(255, 0, 0, 255);
		rect(ailx, aily, 1, 1);
		rect(aifx, aify, 1, 1);
		rect(airx, airy, 1, 1);
*/	
/*
		if (frameCount % 60 == 0) {
			obj.la += PI / 2;
		}
*/
	
		// agent behavior based on sampled sensor
		if (s2 < s1 && s2 < s3) {
			// turn left or right randomly
			obj.la += random(PI / 2, -PI / 2);
			// paper
			//obj.la += random() > 0.5 ? PI / 2 : -PI / 2;
		} else if (s1 < s3) {
			// turn left
			obj.la -= PI / 2;
		} else if (s3 < s1) {
			// turn right
			obj.la += PI / 2;
		}
		
		obj.lx += obj.lv * sin(obj.la);
		obj.ly += obj.lv * cos(obj.la);
		
		// boundary checks
		obj.lx = obj.lx < 0 ? obj.lx + width - 1 : obj.lx;
		obj.lx %= width;
		obj.ly = obj.ly < 0 ? obj.ly + height - 1 : obj.ly;
		obj.ly %= height;
		
		// deposit diffusion (3x3 mean kernel)
		// should probably go after deposit step though
		var i = parseInt(obj.lx + obj.ly * width);
		var b = trail_map[i] / 2;

		var lx = parseInt(obj.lx);
		var ly = parseInt(obj.ly);

		var xb = (lx - 1);
		var yb = (ly - 1);
		var xbl = xb < 0 ? width - 1 : xb;
		var ybl = yb < 0 ? height - 1 : yb;
		var xbu = (lx + 1) % width;
		var ybu = (ly + 1) % height;
		/*
		var v1 = trail_map[xbl + ly * width];
		var v2 = trail_map[xbu + ly * width];
		var v3 = trail_map[xbl + ybl * width];
		var v4 = trail_map[xbl + ybu * width];
		var v5 = trail_map[xbu + ybl * width];
		var v6 = trail_map[xbu + ybu * width];
		var v7 = trail_map[lx + ybl * width];
		var v8 = trail_map[lx + ybu * width];
		
		var vm = (v1 + v2 + v3 + v4 + v5 + v6 + v7 + v8) / 8 / 5;
		*/
		trail_map[xbl + ly * width] = b;
		trail_map[xbu + ly * width] = b;
		trail_map[xbl + ybl * width] = b;
		trail_map[xbl + ybu * width] = b;
		trail_map[xbu + ybl * width] = b;
		trail_map[xbu + ybu * width] = b;
		trail_map[lx + ybl * width] = b;
		trail_map[lx + ybu * width] = b;
		
		// deposit
		trail_map[i] = obj.d;
		
		// agent display
		var c = 255;
		fill(c, c, c, 255);
		rect(obj.lx, obj.ly, 1, 1);
		
/*
		if (trail_map[parseInt(i)] > 1) {
			trail_map[parseInt(i)] = 1;
		}
*/
	}
	
	// deposit decay
	for (var y = 0; y < height; y += 1) {
		for (var x = 0; x < width; x += 1) {
			var v = trail_map[x + y * width];
			trail_map[x + y * width] -= 0.1;
			if (trail_map[x + y * width] < 0) {
				trail_map[x + y * width] = 0;
			}
		}
	}
	/*
	if (frameCount % (60 * 1) == 0) {
		for (var j = 0; j < width * height; j += 1) {
			trail_map[j] = random(0, 5);
		}
	}
	*/
}

function draw() {
	noStroke();
	
	rectMode(CORNER);

	fill(0, 0, 0, 24);
	rect(0, 0, width, height);

	rectMode(CENTER);
	
	compute();
	
	xmotion += 0.0008;
	ymotion += 0.0002;
}"
"781586","Slime mold simulation","mySketch","// slime mold simulation (Physarum polycephalum)
// based on 2010 paper by Jeff Jones, “Characteristics of pattern formation and evolution in approximations of Physarum transport networks.”
// http://eprints.uwe.ac.uk/15260/1/artl.2010.16.2.pdf

var xmotion = 0;
var ymotion = 0;

var objs = [];
var trail_map = [];
var nn = 8000;

// https://iquilezles.org/www/articles/palettes/palettes.htm
function pal(t, a, b, c, d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

function setup() {
	createCanvas(400, 400);
	
	background(0);
	
	noiseDetail(7, 0.7);
	
	for (var n = 0; n < nn; n += 1) {
		var nm = n / nn;
		
		var no = noise(nm);
		
		objs[n] = {
			// paper
			lx: random(0, width),
			ly: random(0, height),
			//lx: width / 2 + sin(nm * PI * 2) * (width / 4 * no),
			//ly: height / 2 + cos(nm * PI * 2) * (height / 4 * no),
			// paper
			//la: random(-PI * 2, PI * 2),
			la: no * PI * 2,
			// paper : 1
			lv: 1,
			d: 5,
			so: 3 + 6 * no, // agent sensor offset,
			sa: 22.5 + 22.5 * no // agent sensor angle (degree)
		};
	}
	
	for (var i = 0; i < width * height; i += 1) {
		trail_map[i] = 0;//random();//i / (width * height);
	}
	
	ellipseMode(CENTER);
	rectMode(CENTER);
}

function compute() {
	fill(0);
	
	strokeWeight(1);

	for (var n = 0; n < nn; n += 1) {
		var obj = objs[n];
		
		var sensor_offset = obj.so;
		var sensor_angle = radians(obj.sa);
		
		// agent sensors
		var lhx = round(sin(obj.la - sensor_angle) * sensor_offset);
		var lhy = round(cos(obj.la - sensor_angle) * sensor_offset);
		var fhx = round(sin(obj.la) * sensor_offset);
		var fhy = round(cos(obj.la) * sensor_offset);
		var rhx = round(sin(obj.la + sensor_angle) * sensor_offset);
		var rhy = round(cos(obj.la + sensor_angle) * sensor_offset);
		
		var ailx = parseInt(obj.lx + lhx);
		var aily = parseInt(obj.ly + lhy);
		var aifx = parseInt(obj.lx + fhx);
		var aify = parseInt(obj.ly + fhy);
		var airx = parseInt(obj.lx + rhx);
		var airy = parseInt(obj.ly + rhy);
		
		ailx = ailx < 0 ? ailx + width : ailx;
		aily = aily < 0 ? aily + height : aily;
		aifx = aifx < 0 ? aifx + width : aifx;
		aify = aify < 0 ? aify + height : aify;
		airx = airx < 0 ? airx + width : airx;
		airy = airy < 0 ? airy + height : airy;
		
		ailx %= width;
		aily %= height;
		aifx %= width;
		aify %= height;
		airx %= width;
		airy %= height;
		
		// sensor sample
		var s1 = trail_map[ailx + aily * width]; // left
		var s2 = trail_map[aifx + aify * width]; // forward
		var s3 = trail_map[airx + airy * width]; // right
		
/*
		// debug sensor
		fill(255, 0, 0, 255);
		rect(ailx, aily, 1, 1);
		rect(aifx, aify, 1, 1);
		rect(airx, airy, 1, 1);
*/	
/*
		if (frameCount % 60 == 0) {
			obj.la += PI / 2;
		}
*/
	
		// agent behavior based on sampled sensor
		if (s2 < s1 && s2 < s3) {
			// turn left or right randomly
			obj.la += random(PI / 2, -PI / 2);
			// paper
			//obj.la += random() > 0.5 ? PI / 2 : -PI / 2;
		} else if (s1 < s3) {
			// turn left
			obj.la -= PI / 2;
		} else if (s3 < s1) {
			// turn right
			obj.la += PI / 2;
		}
		
		obj.lx += obj.lv * sin(obj.la);
		obj.ly += obj.lv * cos(obj.la);
		
		// boundary checks
		obj.lx = obj.lx < 0 ? obj.lx + width - 1 : obj.lx;
		obj.lx %= width;
		obj.ly = obj.ly < 0 ? obj.ly + height - 1 : obj.ly;
		obj.ly %= height;
		
		// deposit diffusion (3x3 mean kernel)
		// should probably go after deposit step though
		var i = parseInt(obj.lx + obj.ly * width);
		var b = trail_map[i] / 2;

		var lx = parseInt(obj.lx);
		var ly = parseInt(obj.ly);

		var xb = (lx - 1);
		var yb = (ly - 1);
		var xbl = xb < 0 ? width - 1 : xb;
		var ybl = yb < 0 ? height - 1 : yb;
		var xbu = (lx + 1) % width;
		var ybu = (ly + 1) % height;
		/*
		var v1 = trail_map[xbl + ly * width];
		var v2 = trail_map[xbu + ly * width];
		var v3 = trail_map[xbl + ybl * width];
		var v4 = trail_map[xbl + ybu * width];
		var v5 = trail_map[xbu + ybl * width];
		var v6 = trail_map[xbu + ybu * width];
		var v7 = trail_map[lx + ybl * width];
		var v8 = trail_map[lx + ybu * width];
		
		var vm = (v1 + v2 + v3 + v4 + v5 + v6 + v7 + v8) / 8 / 5;
		*/
		trail_map[xbl + ly * width] = b;
		trail_map[xbu + ly * width] = b;
		trail_map[xbl + ybl * width] = b;
		trail_map[xbl + ybu * width] = b;
		trail_map[xbu + ybl * width] = b;
		trail_map[xbu + ybu * width] = b;
		trail_map[lx + ybl * width] = b;
		trail_map[lx + ybu * width] = b;
		
		// deposit
		trail_map[i] = obj.d;
		
		// agent display
		var c = 255;
		fill(c, c, c, 255);
		rect(obj.lx, obj.ly, 1, 1);
		
/*
		if (trail_map[parseInt(i)] > 1) {
			trail_map[parseInt(i)] = 1;
		}
*/
	}
	
	// deposit decay
	for (var y = 0; y < height; y += 1) {
		for (var x = 0; x < width; x += 1) {
			var v = trail_map[x + y * width];
			trail_map[x + y * width] -= 0.1;
			if (trail_map[x + y * width] < 0) {
				trail_map[x + y * width] = 0;
			}
		}
	}
	/*
	if (frameCount % (60 * 1) == 0) {
		for (var j = 0; j < width * height; j += 1) {
			trail_map[j] = random(0, 5);
		}
	}
	*/
}

function draw() {
	noStroke();
	
	rectMode(CORNER);

	fill(0, 0, 0, 24);
	rect(0, 0, width, height);

	rectMode(CENTER);
	
	compute();
	
	xmotion += 0.0008;
	ymotion += 0.0002;
}"
"781586","Slime mold simulation","mySketch","// slime mold simulation (Physarum polycephalum)
// based on 2010 paper by Jeff Jones, “Characteristics of pattern formation and evolution in approximations of Physarum transport networks.”
// http://eprints.uwe.ac.uk/15260/1/artl.2010.16.2.pdf

var xmotion = 0;
var ymotion = 0;

var objs = [];
var trail_map = [];
var nn = 8000;

// https://iquilezles.org/www/articles/palettes/palettes.htm
function pal(t, a, b, c, d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

function setup() {
	createCanvas(400, 400);
	
	background(0);
	
	noiseDetail(7, 0.7);
	
	for (var n = 0; n < nn; n += 1) {
		var nm = n / nn;
		
		var no = noise(nm);
		
		objs[n] = {
			// paper
			lx: random(0, width),
			ly: random(0, height),
			//lx: width / 2 + sin(nm * PI * 2) * (width / 4 * no),
			//ly: height / 2 + cos(nm * PI * 2) * (height / 4 * no),
			// paper
			//la: random(-PI * 2, PI * 2),
			la: no * PI * 2,
			// paper : 1
			lv: 1,
			d: 5,
			so: 3 + 6 * no, // agent sensor offset,
			sa: 22.5 + 22.5 * no // agent sensor angle (degree)
		};
	}
	
	for (var i = 0; i < width * height; i += 1) {
		trail_map[i] = 0;//random();//i / (width * height);
	}
	
	ellipseMode(CENTER);
	rectMode(CENTER);
}

function compute() {
	fill(0);
	
	strokeWeight(1);

	for (var n = 0; n < nn; n += 1) {
		var obj = objs[n];
		
		var sensor_offset = obj.so;
		var sensor_angle = radians(obj.sa);
		
		// agent sensors
		var lhx = round(sin(obj.la - sensor_angle) * sensor_offset);
		var lhy = round(cos(obj.la - sensor_angle) * sensor_offset);
		var fhx = round(sin(obj.la) * sensor_offset);
		var fhy = round(cos(obj.la) * sensor_offset);
		var rhx = round(sin(obj.la + sensor_angle) * sensor_offset);
		var rhy = round(cos(obj.la + sensor_angle) * sensor_offset);
		
		var ailx = parseInt(obj.lx + lhx);
		var aily = parseInt(obj.ly + lhy);
		var aifx = parseInt(obj.lx + fhx);
		var aify = parseInt(obj.ly + fhy);
		var airx = parseInt(obj.lx + rhx);
		var airy = parseInt(obj.ly + rhy);
		
		ailx = ailx < 0 ? ailx + width : ailx;
		aily = aily < 0 ? aily + height : aily;
		aifx = aifx < 0 ? aifx + width : aifx;
		aify = aify < 0 ? aify + height : aify;
		airx = airx < 0 ? airx + width : airx;
		airy = airy < 0 ? airy + height : airy;
		
		ailx %= width;
		aily %= height;
		aifx %= width;
		aify %= height;
		airx %= width;
		airy %= height;
		
		// sensor sample
		var s1 = trail_map[ailx + aily * width]; // left
		var s2 = trail_map[aifx + aify * width]; // forward
		var s3 = trail_map[airx + airy * width]; // right
		
/*
		// debug sensor
		fill(255, 0, 0, 255);
		rect(ailx, aily, 1, 1);
		rect(aifx, aify, 1, 1);
		rect(airx, airy, 1, 1);
*/	
/*
		if (frameCount % 60 == 0) {
			obj.la += PI / 2;
		}
*/
	
		// agent behavior based on sampled sensor
		if (s2 < s1 && s2 < s3) {
			// turn left or right randomly
			obj.la += random(PI / 2, -PI / 2);
			// paper
			//obj.la += random() > 0.5 ? PI / 2 : -PI / 2;
		} else if (s1 < s3) {
			// turn left
			obj.la -= PI / 2;
		} else if (s3 < s1) {
			// turn right
			obj.la += PI / 2;
		}
		
		obj.lx += obj.lv * sin(obj.la);
		obj.ly += obj.lv * cos(obj.la);
		
		// boundary checks
		obj.lx = obj.lx < 0 ? obj.lx + width - 1 : obj.lx;
		obj.lx %= width;
		obj.ly = obj.ly < 0 ? obj.ly + height - 1 : obj.ly;
		obj.ly %= height;
		
		// deposit diffusion (3x3 mean kernel)
		// should probably go after deposit step though
		var i = parseInt(obj.lx + obj.ly * width);
		var b = trail_map[i] / 2;

		var lx = parseInt(obj.lx);
		var ly = parseInt(obj.ly);

		var xb = (lx - 1);
		var yb = (ly - 1);
		var xbl = xb < 0 ? width - 1 : xb;
		var ybl = yb < 0 ? height - 1 : yb;
		var xbu = (lx + 1) % width;
		var ybu = (ly + 1) % height;
		/*
		var v1 = trail_map[xbl + ly * width];
		var v2 = trail_map[xbu + ly * width];
		var v3 = trail_map[xbl + ybl * width];
		var v4 = trail_map[xbl + ybu * width];
		var v5 = trail_map[xbu + ybl * width];
		var v6 = trail_map[xbu + ybu * width];
		var v7 = trail_map[lx + ybl * width];
		var v8 = trail_map[lx + ybu * width];
		
		var vm = (v1 + v2 + v3 + v4 + v5 + v6 + v7 + v8) / 8 / 5;
		*/
		trail_map[xbl + ly * width] = b;
		trail_map[xbu + ly * width] = b;
		trail_map[xbl + ybl * width] = b;
		trail_map[xbl + ybu * width] = b;
		trail_map[xbu + ybl * width] = b;
		trail_map[xbu + ybu * width] = b;
		trail_map[lx + ybl * width] = b;
		trail_map[lx + ybu * width] = b;
		
		// deposit
		trail_map[i] = obj.d;
		
		// agent display
		var c = 255;
		fill(c, c, c, 128);
		//stroke(c, c, c, 64);
		rect(obj.lx, obj.ly, 1, 1);
		
/*
		if (trail_map[parseInt(i)] > 1) {
			trail_map[parseInt(i)] = 1;
		}
*/
	}
	
	// deposit decay
	for (var y = 0; y < height; y += 1) {
		for (var x = 0; x < width; x += 1) {
			var v = trail_map[x + y * width];
			trail_map[x + y * width] -= 0.1;
			if (trail_map[x + y * width] < 0) {
				trail_map[x + y * width] = 0;
			}
		}
	}
	/*
	if (frameCount % (60 * 1) == 0) {
		for (var j = 0; j < width * height; j += 1) {
			trail_map[j] = random(0, 5);
		}
	}
	*/
}

function draw() {
	noStroke();
	
	rectMode(CORNER);

	fill(0, 0, 0, 24);
	rect(0, 0, width, height);

	rectMode(CENTER);
	
	compute();
	
	xmotion += 0.0008;
	ymotion += 0.0002;
}"
"781586","Slime mold simulation","mySketch","// slime mold simulation (Physarum polycephalum)
// based on 2010 paper by Jeff Jones, “Characteristics of pattern formation and evolution in approximations of Physarum transport networks.”
// http://eprints.uwe.ac.uk/15260/1/artl.2010.16.2.pdf

var xmotion = 0;
var ymotion = 0;

var objs = [];
var trail_map = [];
var nn = 18000;

// https://iquilezles.org/www/articles/palettes/palettes.htm
function pal(t, a, b, c, d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

function setup() {
	createCanvas(400, 400);
	
	background(0);
	
	noiseDetail(7, 0.7);
	
	for (var n = 0; n < nn; n += 1) {
		var nm = n / nn;
		
		var no = noise(nm);
		
		objs[n] = {
			// paper
			lx: random(0, width),
			ly: random(0, height),
			//lx: width / 2 + sin(nm * PI * 2) * (width / 2 * no),
			//ly: height / 2 + cos(nm * PI * 2) * (height / 2 * no),
			// paper
			//la: random(-PI * 2, PI * 2),
			la: random() * PI * 2,
			// paper : 1
			lv: 1,
			d: 5,
			so: 9, // agent sensor offset,
			sa: 45 // agent sensor angle (degree)
		};
	}
	
	for (var i = 0; i < width * height; i += 1) {
		trail_map[i] = i / (width * height);
	}
	
	ellipseMode(CENTER);
	rectMode(CENTER);
}

function compute() {
	fill(0);
	
	strokeWeight(1);

	for (var n = 0; n < nn; n += 1) {
		var obj = objs[n];
		
		var sensor_offset = obj.so;
		var sensor_angle = radians(obj.sa);
		
		// agent sensors
		var lhx = round(sin(obj.la - sensor_angle) * sensor_offset);
		var lhy = round(cos(obj.la - sensor_angle) * sensor_offset);
		var fhx = round(sin(obj.la) * sensor_offset);
		var fhy = round(cos(obj.la) * sensor_offset);
		var rhx = round(sin(obj.la + sensor_angle) * sensor_offset);
		var rhy = round(cos(obj.la + sensor_angle) * sensor_offset);
		
		var ailx = parseInt(obj.lx + lhx);
		var aily = parseInt(obj.ly + lhy);
		var aifx = parseInt(obj.lx + fhx);
		var aify = parseInt(obj.ly + fhy);
		var airx = parseInt(obj.lx + rhx);
		var airy = parseInt(obj.ly + rhy);
		
		ailx = ailx < 0 ? ailx + width : ailx;
		aily = aily < 0 ? aily + height : aily;
		aifx = aifx < 0 ? aifx + width : aifx;
		aify = aify < 0 ? aify + height : aify;
		airx = airx < 0 ? airx + width : airx;
		airy = airy < 0 ? airy + height : airy;
		
		ailx %= width;
		aily %= height;
		aifx %= width;
		aify %= height;
		airx %= width;
		airy %= height;
		
		// sensor sample
		var s1 = trail_map[ailx + aily * width]; // left
		var s2 = trail_map[aifx + aify * width]; // forward
		var s3 = trail_map[airx + airy * width]; // right
		
/*
		// debug sensor
		fill(255, 0, 0, 255);
		rect(ailx, aily, 1, 1);
		rect(aifx, aify, 1, 1);
		rect(airx, airy, 1, 1);
*/	
/*
		if (frameCount % 60 == 0) {
			obj.la += PI / 2;
		}
*/
	
		// agent behavior based on sampled sensor
		if (s2 < s1 && s2 < s3) {
			// turn left or right randomly
			//obj.la += random(PI / 2, -PI / 2);
			// paper
			obj.la += random() > 0.5 ? PI / 2 : -PI / 2;
		} else if (s1 < s3) {
			// turn left
			obj.la -= PI / 2;
		} else if (s3 < s1) {
			// turn right
			obj.la += PI / 2;
		}
		
		obj.lx += obj.lv * sin(obj.la);
		obj.ly += obj.lv * cos(obj.la);
		
		// boundary checks
		obj.lx = obj.lx < 0 ? obj.lx + width - 1 : obj.lx;
		obj.lx %= width;
		obj.ly = obj.ly < 0 ? obj.ly + height - 1 : obj.ly;
		obj.ly %= height;
		
		// deposit diffusion (3x3 mean kernel)
		// should probably go after deposit step though
		var i = parseInt(obj.lx + obj.ly * width);
		var b = trail_map[i] / 2;

		var lx = parseInt(obj.lx);
		var ly = parseInt(obj.ly);

		var xb = (lx - 1);
		var yb = (ly - 1);
		var xbl = xb < 0 ? width - 1 : xb;
		var ybl = yb < 0 ? height - 1 : yb;
		var xbu = (lx + 1) % width;
		var ybu = (ly + 1) % height;
		/*
		var v1 = trail_map[xbl + ly * width];
		var v2 = trail_map[xbu + ly * width];
		var v3 = trail_map[xbl + ybl * width];
		var v4 = trail_map[xbl + ybu * width];
		var v5 = trail_map[xbu + ybl * width];
		var v6 = trail_map[xbu + ybu * width];
		var v7 = trail_map[lx + ybl * width];
		var v8 = trail_map[lx + ybu * width];
		
		var vm = (v1 + v2 + v3 + v4 + v5 + v6 + v7 + v8) / 8 / 5;
		*/
		trail_map[xbl + ly * width] = b;
		trail_map[xbu + ly * width] = b;
		trail_map[xbl + ybl * width] = b;
		trail_map[xbl + ybu * width] = b;
		trail_map[xbu + ybl * width] = b;
		trail_map[xbu + ybu * width] = b;
		trail_map[lx + ybl * width] = b;
		trail_map[lx + ybu * width] = b;
		
		// deposit
		trail_map[i] = obj.d;
		
		// agent display
		var c = 255;
		fill(c, c, c, 128);
		//stroke(c, c, c, 64);
		rect(obj.lx, obj.ly, 1, 1);
		
/*
		if (trail_map[parseInt(i)] > 1) {
			trail_map[parseInt(i)] = 1;
		}
*/
	}
	
	// deposit decay
	for (var y = 0; y < height; y += 1) {
		for (var x = 0; x < width; x += 1) {
			var v = trail_map[x + y * width];
			trail_map[x + y * width] -= 0.1;
			if (trail_map[x + y * width] < 0) {
				trail_map[x + y * width] = 0;
			}
		}
	}
	
	if (frameCount % 60 == 0) {
		var st = 1 + parseInt(random() * (nn / 8));
		for (var y = 0; y < nn; y += st) {
			objs[y].lx = random() * width;
			objs[y].ly = random() * height;
		}
	}
	
}

function draw() {
	noStroke();
	
	rectMode(CORNER);

	fill(0, 0, 0, 8);
	rect(0, 0, width, height);

	rectMode(CENTER);
	
	compute();
	
	xmotion += 0.0008;
	ymotion += 0.0002;
}"
"781586","Slime mold simulation","mySketch","// slime mold simulation (Physarum polycephalum)
// based on 2010 paper by Jeff Jones, “Characteristics of pattern formation and evolution in approximations of Physarum transport networks.”
// http://eprints.uwe.ac.uk/15260/1/artl.2010.16.2.pdf

var xmotion = 0;
var ymotion = 0;

var objs = [];
var trail_map = [];
var nn = 8000;

// https://iquilezles.org/www/articles/palettes/palettes.htm
function pal(t, a, b, c, d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

function setup() {
	createCanvas(400, 400);
	
	background(0);
	
	noiseDetail(7, 0.7);
	
	for (var n = 0; n < nn; n += 1) {
		var nm = n / nn;
		
		var no = noise(nm);
		
		objs[n] = {
			// paper
			lx: random(0, width),
			ly: random(0, height),
			//lx: width / 2 + sin(nm * PI * 2) * (width / 4 * no),
			//ly: height / 2 + cos(nm * PI * 2) * (height / 4 * no),
			// paper
			//la: random(-PI * 2, PI * 2),
			la: no * PI * 2,
			// paper : 1
			lv: 1,
			d: 5,
			so: 3 + 6 * no, // agent sensor offset,
			sa: 22.5 + 22.5 * no // agent sensor angle (degree)
		};
	}
	
	for (var i = 0; i < width * height; i += 1) {
		trail_map[i] = 0;//random();//i / (width * height);
	}
	
	ellipseMode(CENTER);
	rectMode(CENTER);
}

function compute() {
	fill(0);
	
	strokeWeight(1);

	for (var n = 0; n < nn; n += 1) {
		var obj = objs[n];
		
		var sensor_offset = obj.so;
		var sensor_angle = radians(obj.sa);
		
		// agent sensors
		var lhx = round(sin(obj.la - sensor_angle) * sensor_offset);
		var lhy = round(cos(obj.la - sensor_angle) * sensor_offset);
		var fhx = round(sin(obj.la) * sensor_offset);
		var fhy = round(cos(obj.la) * sensor_offset);
		var rhx = round(sin(obj.la + sensor_angle) * sensor_offset);
		var rhy = round(cos(obj.la + sensor_angle) * sensor_offset);
		
		var ailx = parseInt(obj.lx + lhx);
		var aily = parseInt(obj.ly + lhy);
		var aifx = parseInt(obj.lx + fhx);
		var aify = parseInt(obj.ly + fhy);
		var airx = parseInt(obj.lx + rhx);
		var airy = parseInt(obj.ly + rhy);
		
		ailx = ailx < 0 ? ailx + width : ailx;
		aily = aily < 0 ? aily + height : aily;
		aifx = aifx < 0 ? aifx + width : aifx;
		aify = aify < 0 ? aify + height : aify;
		airx = airx < 0 ? airx + width : airx;
		airy = airy < 0 ? airy + height : airy;
		
		ailx %= width;
		aily %= height;
		aifx %= width;
		aify %= height;
		airx %= width;
		airy %= height;
		
		// sensor sample
		var s1 = trail_map[ailx + aily * width]; // left
		var s2 = trail_map[aifx + aify * width]; // forward
		var s3 = trail_map[airx + airy * width]; // right
		
/*
		// debug sensor
		fill(255, 0, 0, 255);
		rect(ailx, aily, 1, 1);
		rect(aifx, aify, 1, 1);
		rect(airx, airy, 1, 1);
*/	
/*
		if (frameCount % 60 == 0) {
			obj.la += PI / 2;
		}
*/
	
		// agent behavior based on sampled sensor
		if (s2 < s1 && s2 < s3) {
			// turn left or right randomly
			obj.la += random(PI / 2, -PI / 2);
			// paper
			//obj.la += random() > 0.5 ? PI / 2 : -PI / 2;
		} else if (s1 < s3) {
			// turn left
			obj.la -= PI / 2;
		} else if (s3 < s1) {
			// turn right
			obj.la += PI / 2;
		}
		
		obj.lx += obj.lv * sin(obj.la);
		obj.ly += obj.lv * cos(obj.la);
		
		// boundary checks
		obj.lx = obj.lx < 0 ? obj.lx + width - 1 : obj.lx;
		obj.lx %= width;
		obj.ly = obj.ly < 0 ? obj.ly + height - 1 : obj.ly;
		obj.ly %= height;
		
		// deposit diffusion (3x3 mean kernel)
		// should probably go after deposit step though
		var i = parseInt(obj.lx + obj.ly * width);
		var b = trail_map[i] / 2;

		var lx = parseInt(obj.lx);
		var ly = parseInt(obj.ly);

		var xb = (lx - 1);
		var yb = (ly - 1);
		var xbl = xb < 0 ? width - 1 : xb;
		var ybl = yb < 0 ? height - 1 : yb;
		var xbu = (lx + 1) % width;
		var ybu = (ly + 1) % height;
		/*
		var v1 = trail_map[xbl + ly * width];
		var v2 = trail_map[xbu + ly * width];
		var v3 = trail_map[xbl + ybl * width];
		var v4 = trail_map[xbl + ybu * width];
		var v5 = trail_map[xbu + ybl * width];
		var v6 = trail_map[xbu + ybu * width];
		var v7 = trail_map[lx + ybl * width];
		var v8 = trail_map[lx + ybu * width];
		
		var vm = (v1 + v2 + v3 + v4 + v5 + v6 + v7 + v8) / 8 / 5;
		*/
		trail_map[xbl + ly * width] = b;
		trail_map[xbu + ly * width] = b;
		trail_map[xbl + ybl * width] = b;
		trail_map[xbl + ybu * width] = b;
		trail_map[xbu + ybl * width] = b;
		trail_map[xbu + ybu * width] = b;
		trail_map[lx + ybl * width] = b;
		trail_map[lx + ybu * width] = b;
		
		// deposit
		trail_map[i] = obj.d;
		
		// agent display
		var c = 255;
		fill(c, c, c, 128);
		//stroke(c, c, c, 64);
		rect(obj.lx, obj.ly, 1, 1);
		
/*
		if (trail_map[parseInt(i)] > 1) {
			trail_map[parseInt(i)] = 1;
		}
*/
	}
	
	// deposit decay
	for (var y = 0; y < height; y += 1) {
		for (var x = 0; x < width; x += 1) {
			var v = trail_map[x + y * width];
			trail_map[x + y * width] -= 0.1;
			if (trail_map[x + y * width] < 0) {
				trail_map[x + y * width] = 0;
			}
		}
	}
	/*
	if (frameCount % (60 * 1) == 0) {
		for (var j = 0; j < width * height; j += 1) {
			trail_map[j] = random(0, 5);
		}
	}
	*/
}

function draw() {
	noStroke();
	
	rectMode(CORNER);

	fill(0, 0, 0, 24);
	rect(0, 0, width, height);

	rectMode(CENTER);
	
	compute();
	
	xmotion += 0.0008;
	ymotion += 0.0002;
}"
"781494","States","mySketch","var xmotion = 0;
var ymotion = 0;

var objs = [];
var nn = 100;

// https://iquilezles.org/www/articles/palettes/palettes.htm
function pal(t, a, b, c, d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

function setup() {
	createCanvas(windowWidth, windowHeight);
	
	background(0);
	
	noiseDetail(7, 0.7);
	
	for (var n = 0; n < nn; n += 1) {
		objs[n] = { x: windowWidth * random(), y: 0, vx: random(-1, 1) / 6000, vy: 1, n: random(-1, 1) * windowWidth };
	}
	
	ellipseMode(CENTER);
	rectMode(CENTER);
}

function compute() {
	fill(0);
	
	strokeWeight(1);

	for (var n = 0; n < nn; n += 1) {
		objs[n].n += objs[n].vx;
		objs[n].y += objs[n].vy;
		objs[n].x = -windowWidth + noise(objs[n].n) * windowWidth * 2;
		
		//objs[n].y %= windowHeight;
		if (objs[n].y > windowHeight) {
			objs[n].y = 0;
			//objs[n].x += windowWidth * objs[n].n;
			//objs[n].x %= windowWidth;
			objs[n].n = random(-1, 1) * windowWidth
		}
		
		var dd = Infinity;
		var did = n;
		
		for (var i = 0; i < nn; i += 1) {
			var d = (abs((objs[n].x - objs[i].x) * (objs[n].x - objs[i].x)) + abs((objs[n].y - objs[i].y) * (objs[n].y - objs[i].y))); // sqrt
			if (i !== n && d < dd) {//1 * abs(objs[n].n)) {
				did = i;
				dd = d;
			}
		}
		
		if (did !== n) {
			objs[did].vx = -objs[did].vx;
		}
		
		var pa1 = 0.75, pa2 = 0.75, pa3 = 0.75;
		var pb1 = 0.5, pb2 = 0.5, pb3 = 0.5;
		var pc1 = 1, pc2 = 1, pc3 = 0.5;

		var pdr = 0.7;
		var pdg = 0.8;
		var pdb = 0.3;

		var pt = noise(objs[n].n / windowWidth * 32 + xmotion);

		var rf = pal(pt, pa1, pb1, pc1, pdr) * 255;
		var gf = pal(pt, pa2, pb2, pc2, pdg) * 255;
		var bf = pal(pt, pa3, pb3, pc3, pdb) * 255;
		
		noFill();
		stroke(rf, gf, bf, 255);
		//line(objs[n].x, objs[n].y, objs[did].x, objs[did].y);
		bezier(objs[n].x, objs[n].y, objs[n].x + objs[n].n, objs[n].y, objs[n].x, objs[n].y, objs[did].x, objs[did].y);
		noStroke();
		//noFill();
		stroke(0, 0, 0, 255);
		fill(0, 0, 0, 255);
		rect(objs[n].x, objs[n].y, 1 * pt, 1 * pt);
		//rect(objs[did].x, objs[did].y, 1, 1);
	}
}

function draw() {
	noStroke();
/*
	fill(0, 0, 0, 1);
	rect(0, 0, windowWidth, windowHeight);
*/
	compute();
	
	xmotion += 0.0008;
	ymotion += 0.0002;
}"
"779818","Pieces","mySketch","var xmotion = 0;
var ymotion = 0;

var objs = [];
var nn = 80;

// https://iquilezles.org/www/articles/palettes/palettes.htm
function pal(t, a, b, c, d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

function setup() {
	createCanvas(windowWidth, windowHeight);
	
	background(0);
	
	noiseDetail(7, 0.7);
	
	for (var n = 0; n < nn; n += 1) {
		objs[n] = { x: windowWidth * random(), y: 0, vx: random(-1, 1) / 6000, vy: 1, n: random(-1, 1) * windowWidth };
	}
	
	ellipseMode(CENTER);
	rectMode(CENTER);
}

function compute() {
	fill(0);
	
	strokeWeight(1);

	for (var n = 0; n < nn; n += 1) {
		objs[n].n += objs[n].vx;
		objs[n].y += objs[n].vy;
		objs[n].x = -windowWidth + noise(objs[n].n) * windowWidth * 2;
		
		objs[n].y %= windowHeight;
		if (objs[n].y == 0) {
			objs[n].n = random(-1, 1) * windowWidth
		}
		
		var dd = Infinity;
		var did = n;
		
		for (var i = 0; i < nn; i += 1) {
			var d = (abs((objs[n].x - objs[i].x) * (objs[n].x - objs[i].x)) + abs((objs[n].y - objs[i].y) * (objs[n].y - objs[i].y))); // sqrt
			if (i !== n && d < dd) {
				did = i;
				dd = d;
			}
		}
		
		if (did !== n) {
			objs[did].vx = -objs[did].vx;
		}
		
		var pa1 = 0.75, pa2 = 0.75, pa3 = 0.75;
		var pb1 = 0.5, pb2 = 0.5, pb3 = 0.5;
		var pc1 = 1, pc2 = 1, pc3 = 0.5;

		var pdr = 0.7;
		var pdg = 0.8;
		var pdb = 0.3;

		var pt = noise(objs[n].n * 30 + xmotion);

		var rf = pal(pt, pa1, pb1, pc1, pdr) * 255;
		var gf = pal(pt, pa2, pb2, pc2, pdg) * 255;
		var bf = pal(pt, pa3, pb3, pc3, pdb) * 255;
		
		stroke(rf, gf, bf, 255);
		line(objs[n].x, objs[n].y, objs[did].x, objs[did].y);
		noStroke();
		//noFill();
		stroke(0, 0, 0, 255);
		fill(0, 0, 0, 255);
		rect(objs[n].x, objs[n].y, 1, 1);
		rect(objs[did].x, objs[did].y, 1, 1);
	}
}

function draw() {
	noStroke();
/*
	fill(0, 0, 0, 1);
	rect(0, 0, windowWidth, windowHeight);
*/
	compute();
	
	xmotion += 0.0008;
	ymotion += 0.0002;
}"
"777660","Unstable 2","mySketch","var xmotion = 0;
var ymotion = 0;

var xx = [];
var yy = [];

// https://iquilezles.org/www/articles/palettes/palettes.htm
function pal(t, a, b, c, d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

function setup() {
	createCanvas(windowWidth, windowHeight);
	
	background(0);
	
	noiseDetail(7, 0.4);
	
	ellipseMode(CENTER);
	
	xmotion = random();
	ymotion = random();
}

function compute() {
	fill(0);
	
	noStroke();
	
	strokeWeight(2);
	
	var px = [];
	var py = [];
	var pxx = 0;
	var pyy = 0;
	
	var mi = 64;
	var mj = 8;
	
	for (var i = 0; i < mi; i += 1) {
		var ni = i / mi;
		var nic = 1.0 - abs(0.5 - ni) * 2;
		
		var co = 0;
		
		for (var j = 0; j < mj; j += 1) {
			var ji = j / mj;
			var jic = 1.0 - abs(0.5 - ji) * 2;
			
			var n = noise(nic * jic * 2 + xmotion);
			var nn = n / 12;
			
			var sj = pow(ji, 2);

			var cx = sin(ni * PI * 20 + mi * PI * 2 + co + xmotion * Math.sign(0.5 - n));
			var cy = cos(ni * PI * 20 + mi * PI * 2 + co + xmotion * Math.sign(0.5 - n));// - abs(cx);
			
			var cxx = cx * ((windowWidth / 4) * (sj + nn * (sin(xmotion * Math.sign(0.5 - n) * n + ji * PI * 2) * 8)));
			var cyy = cy * ((windowWidth / 4) * (sj + nn * (sin(xmotion * Math.sign(0.5 - n) * n + ji * PI * 2) * 8)));
			
			//fill(255, 255, 255, 255);
			//ellipse(windowWidth / 2 + cxx, windowHeight / 2 + cyy, 8, 8);

			px[j + i * mj] = cxx;
			py[j + i * mj] = cyy;
			
			co -= Math.PI * 4 * mj + xmotion;
		}
	}
	
	for (var i = 0; i < mi * mj; i += 1) {
		var nic = i / (mi * mj);
		
		var pa = 0.75;
		var pb = 0.5;
		var pc = 1;

		var pdr = 0.2;
		var pdg = 0.05;
		var pdb = 0.02;

		var n = 1.0 - abs(0.5 - noise(nic * 2 + xmotion / 32)) * 2;

		var b = 255 * abs(sin(xmotion * 4 * Math.sign(n) * n));

		var rf = pal(nic, pa, pb, pc, pdr) * b;
		var gf = pal(nic, pa, pb, pc, pdg) * b;
		var bf = pal(nic, pa, pb, pc, pdb) * b;

		fill(rf, gf, bf, 255);
		stroke(rf, gf, bf, 255);
		
		var did1 = i;
		var did2 = i;
		var did3 = i;
		var ddx = Infinity;
		var ddy = Infinity;
		
		for (var k = 0; k < mi * mj; k += 1) {
			var d = (abs((px[k] - px[i]) * (px[k] - px[i])) + abs((py[k] - py[i]) * (py[k] - py[i]))); // sqrt
			if (k !== i && ddx > d) {//abs(px[j] - px[i]) < ddx && abs(py[j] - py[i]) < ddy) {
				did1 = k;
				ddx = d;
				//ddx = abs(px[j] - px[i]);
				//ddy = abs(py[j] - py[i]);
			}
		}
		/*
		ddx = Infinity;
		for (var k = 0; k < mi * mj; k += 1) {
			var d = (abs((px[k] - px[i]) * (px[k] - px[i])) + abs((py[k] - py[i]) * (py[k] - py[i]))); // sqrt
			if (k !== i && k !== did1 && ddx > d) {//abs(px[j] - px[i]) < ddx && abs(py[j] - py[i]) < ddy) {
				did2 = k;
				ddx = d;
				//ddx = abs(px[j] - px[i]);
				//ddy = abs(py[j] - py[i]);
			}
		}
		
		ddx = Infinity;
		for (var k = 0; k < mi * mj; k += 1) {
			var d = (abs((px[k] - px[i]) * (px[k] - px[i])) + abs((py[k] - py[i]) * (py[k] - py[i]))); // sqrt
			if (k !== i && k !== did1 && k !== did2 && ddx > d) {//abs(px[j] - px[i]) < ddx && abs(py[j] - py[i]) < ddy) {
				did3 = k;
				ddx = d;
				//ddx = abs(px[j] - px[i]);
				//ddy = abs(py[j] - py[i]);
			}
		}*/
		
		line(windowWidth / 2 + px[i], windowHeight / 2 + py[i], windowWidth / 2 + px[did1], windowHeight / 2 + py[did1]);
		//quad(windowWidth / 2 + px[i], windowHeight / 2 + py[i], windowWidth / 2 + px[did1], windowHeight / 2 + py[did1],
		//		 windowWidth / 2 + px[did2], windowHeight / 2 + py[did2], windowWidth / 2 + px[did3], windowHeight / 2 + py[did3]);
	}
}

function draw() {
	noStroke();
	
	fill(0, 0, 0, 12);
	rect(0, 0, windowWidth, windowHeight);
	
	if ((frameCount % 60) == 0) {
			fill(0, 0, 0, 48);
			rect(0, 0, windowWidth, windowHeight);
	}
	
	compute();
	
	xmotion += 0.01;
	ymotion += 0.01;
}"
"777657","Unstable","mySketch","var xmotion = 0;
var ymotion = 0;

var xx = [];
var yy = [];

// https://iquilezles.org/www/articles/palettes/palettes.htm
function pal(t, a, b, c, d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

function setup() {
	createCanvas(windowWidth, windowHeight);
	
	background(0);
	
	noiseDetail(7, 0.64);
	
	ellipseMode(CENTER);
	
	xmotion = random();
	ymotion = random();
}

function compute() {
	fill(0);
	
	noStroke();
	
	strokeWeight(2);
	
	var px = [];
	var py = [];
	var pxx = 0;
	var pyy = 0;
	
	var mi = 48;
	var mj = 12;
	
	for (var i = 0; i < mi; i += 1) {
		var ni = i / mi;
		var nic = 1.0 - abs(0.5 - ni) * 2;
		
		var co = 0;
		
		for (var j = 0; j < mj; j += 1) {
			var ji = j / mj;
			var jic = 1.0 - abs(0.5 - ji) * 2;
			
			var n = noise(nic * jic * 2 + xmotion);
			var nn = n / 12;
			
			var sj = pow(ji, 2);

			var cx = sin(ni * PI * 2 + mi * PI * 2 + co + xmotion * Math.sign(0.5 - n));
			var cy = cos(ni * PI * 2 + mi * PI * 2 + co + xmotion * Math.sign(0.5 - n));// - abs(cx);
			
			var cxx = cx * ((windowWidth / 4) * (sj + nn * (sin(xmotion * Math.sign(0.5 - n) + ji * PI * 2) * 2)));
			var cyy = cy * ((windowWidth / 4) * (sj + nn * (sin(xmotion * Math.sign(0.5 - n) + ji * PI * 2) * 2)));
			
			//fill(255, 255, 255, 255);
			//ellipse(windowWidth / 2 + cxx, windowHeight / 2 + cyy, 8, 8);

			px[j + i * mj] = cxx;
			py[j + i * mj] = cyy;
			
			co -= Math.PI * 4 * mj + xmotion * n;
		}
	}
	
	for (var i = 0; i < mi * mj; i += 1) {
		var nic = i / (mi * mj);
		
		var pa = 0.75;
		var pb = 0.5;
		var pc = 1;

		var pdr = 0.3;
		var pdg = 0.15;
		var pdb = 0.1;

		var n = 1.0 - abs(0.5 - noise(nic * 2 + xmotion / 32)) * 2;

		var b = 255 * abs(sin(xmotion * 4 * Math.sign(n) * n));

		var rf = pal(nic, pa, pb, pc, pdr) * b;
		var gf = pal(nic, pa, pb, pc, pdg) * b;
		var bf = pal(nic, pa, pb, pc, pdb) * b;

		fill(rf, gf, bf, 255);
		stroke(rf, gf, bf, 255);
		
		var did1 = i;
		var did2 = i;
		var did3 = i;
		var ddx = Infinity;
		var ddy = Infinity;
		
		for (var k = 0; k < mi * mj; k += 1) {
			var d = (abs((px[k] - px[i]) * (px[k] - px[i])) + abs((py[k] - py[i]) * (py[k] - py[i]))); // sqrt
			if (k !== i && ddx > d) {//abs(px[j] - px[i]) < ddx && abs(py[j] - py[i]) < ddy) {
				did1 = k;
				ddx = d;
				//ddx = abs(px[j] - px[i]);
				//ddy = abs(py[j] - py[i]);
			}
		}
		/*
		ddx = Infinity;
		for (var k = 0; k < mi * mj; k += 1) {
			var d = (abs((px[k] - px[i]) * (px[k] - px[i])) + abs((py[k] - py[i]) * (py[k] - py[i]))); // sqrt
			if (k !== i && k !== did1 && ddx > d) {//abs(px[j] - px[i]) < ddx && abs(py[j] - py[i]) < ddy) {
				did2 = k;
				ddx = d;
				//ddx = abs(px[j] - px[i]);
				//ddy = abs(py[j] - py[i]);
			}
		}
		
		ddx = Infinity;
		for (var k = 0; k < mi * mj; k += 1) {
			var d = (abs((px[k] - px[i]) * (px[k] - px[i])) + abs((py[k] - py[i]) * (py[k] - py[i]))); // sqrt
			if (k !== i && k !== did1 && k !== did2 && ddx > d) {//abs(px[j] - px[i]) < ddx && abs(py[j] - py[i]) < ddy) {
				did3 = k;
				ddx = d;
				//ddx = abs(px[j] - px[i]);
				//ddy = abs(py[j] - py[i]);
			}
		}*/
		
		line(windowWidth / 2 + px[i], windowHeight / 2 + py[i], windowWidth / 2 + px[did1], windowHeight / 2 + py[did1]);
		//quad(windowWidth / 2 + px[i], windowHeight / 2 + py[i], windowWidth / 2 + px[did1], windowHeight / 2 + py[did1],
		//		 windowWidth / 2 + px[did2], windowHeight / 2 + py[did2], windowWidth / 2 + px[did3], windowHeight / 2 + py[did3]);
	}
}

function draw() {
	noStroke();
	
	fill(0, 0, 0, 14);
	rect(0, 0, windowWidth, windowHeight);
	
	if ((frameCount % 60) == 0) {
			fill(0, 0, 0, 48);
			rect(0, 0, windowWidth, windowHeight);
	}
	
	compute();
	
	xmotion += 0.01;
	ymotion += 0.01;
}"
"776043","Cocarde","mySketch","var xmotion = 0;
var ymotion = 0;

// https://iquilezles.org/www/articles/palettes/palettes.htm
function pal(t, a, b, c, d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

function setup() {
	createCanvas(windowWidth, windowHeight);
	
	background(0);
	
	noiseDetail(7, 0.6);
	
	ellipseMode(CENTER);
	
	xmotion = random();
	ymotion = random();
}

function compute() {
	fill(0);
	
	noStroke();
	
	var px = [];
	var py = [];
	var pxx = 0;
	var pyy = 0;
	
	for (var i = 0; i < 9; i += 1) {
		var ni = i / 8;
		var nic = 1.0 - abs(0.5 - ni) * 2;
		
		var co = 0;
		
		for (var j = 1; j < 8; j += 1) {
			var ji = j / 8;
			var jic = 1.0 - abs(0.5 - ji) * 2;
			
			var n = noise(nic * jic * 8 + xmotion * 2);
			
			var sj = pow(ji, 1.4);

			var cx = sin(/*n * xmotion + */ ni * PI * 2 + co + xmotion/* + xmotion * Math.sign(0.5 - jic)*/);
			var cy = cos(/*n * xmotion + */ ni * PI * 2 + co + xmotion/* + xmotion * Math.sign(0.5 - jic)*/);
			
			var cxx = cx * ((windowWidth / 4) * sj);//(sin(/*xmotion + */ji * PI * 2)));
			var cyy = cy * ((windowWidth / 4) * sj);//(sin(/*xmotion + */ji * PI * 2)));
			
			var cx2 = sin(/*n * xmotion + xmotion * */ni * PI * 2 + co + xmotion/* + xmotion * Math.sign(0.5 - jic)*/);
			var cy2 = cos(/*n * xmotion + xmotion * */ni * PI * 2 + co + xmotion/* + xmotion * Math.sign(0.5 - jic)*/);
			
			var cxx2 = cx2 * ((windowWidth / 4) * (sj * 1.05 + sin(xmotion * PI * 2 + nic * PI * 2 * n) / 8 * jic));//(sin(/*xmotion + */ji * PI * 2)));
			var cyy2 = cy2 * ((windowWidth / 4) * (sj * 1.05 + cos(xmotion * PI * 2 + nic * PI * 2 * n) / 8 * jic));//(sin(/*xmotion + */ji * PI * 2)));
			
			var pa = 0.5;
			var pb = 0.5;
			var pc = 1;

			var pdr = 0.3;
			var pdg = 0.15;
			var pdb = 0.1;
			
			var nicjic = jic;
			
			var b = 255 * abs(sin(xmotion * 4 * Math.sign(0.5 - n) * n));

			var rf = pal(nicjic, pa, pb, pc, pdr) * b;
			var gf = pal(nicjic, pa, pb, pc, pdg) * b;
			var bf = pal(nicjic, pa, pb, pc, pdb) * b;
		
			fill(rf, gf, bf, 255);
			stroke(rf, gf, bf, 255);
	
			//ellipse(windowWidth / 2 + cxx, windowHeight / 2 + cyy, 1 * n, 1 * n);
			//ellipse(windowWidth - windowWidth / 2 + cxx, windowHeight - windowHeight / 2 + cyy, 2, 2);
			
			line(windowWidth / 2 + cxx, windowHeight / 2 + cyy, windowWidth / 2 + cxx2, windowHeight / 2 + cyy2)
			//line(windowWidth / 2 + pxx, windowHeight / 2 + pyy, windowWidth / 2 + cx, windowHeight / 2 + cy)
			
			px[j] = cxx;
			py[j] = cyy;
			pxx = cxx;
			pyy = cyy;
			
			co += Math.PI / 32;
		}
	}
}

function draw() {
	noStroke();
	/*
	fill(0, 0, 0, 1);
	rect(0, 0, windowWidth, windowHeight);
	*/
	compute();
	
	xmotion += 0.01;
	ymotion += 0.01;
}"
"772723","Patterns","mySketch","var xmotion = 0;
var ymotion = 0;

// https://iquilezles.org/www/articles/palettes/palettes.htm
function pal(t, a, b, c, d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

function setup() {
	createCanvas(windowWidth, windowHeight);
	
	background(0);
	
	noiseDetail(7, 0.7);
	
	ellipseMode(CENTER);
	
	xmotion = random();
	ymotion = random();
}

function compute() {
	fill(0);
	
	noStroke();
	
	var px = [];
	var py = [];
	var pxx = 0;
	var pyy = 0;
	
	for (var i = 0; i < 32; i += 1) {
		var ni = i / 32;
		var nic = 1.0 - abs(0.5 - ni) * 2;
		
		for (var j = 0; j < 32; j += 1) {
			var ji = j / 32;
			var jic = 1.0 - abs(0.5 - ji) * 2;
			
			var n = noise(nic * jic + xmotion);

			var cx = sin(n * xmotion + xmotion * ni * PI * 2 + xmotion * Math.sign(0.5 - jic));
			var cy = cos(n * xmotion + xmotion * ni * PI * 2 + xmotion * Math.sign(0.5 - jic));
			
			var cxx = cx * ((windowWidth) * (sin(xmotion + ji * PI * 2)));
			var cyy = cy * ((windowWidth) * (sin(xmotion + ji * PI * 2)));
			
			var pa = 0.75;
			var pb = 0.5;
			var pc = 1;

			var pdr = 0.1;
			var pdg = 0.2;
			var pdb = 0.4;
			
			var nicjic = (nic * jic);
			
			var b = 255 * abs(sin(xmotion * 8 * Math.sign(0.5 - n) * n));

			var rf = pal(nicjic, pa, pb, pc, pdr) * b;
			var gf = pal(nicjic, pa, pb, pc, pdg) * b;
			var bf = pal(nicjic, pa, pb, pc, pdb) * b;
		
			fill(rf, gf, bf, 255);
			stroke(rf, gf, bf, 255);
	
			ellipse(windowWidth / 2 + cxx, windowHeight / 2 + cyy, 8 * n, 8 * n);
			//ellipse(windowWidth - windowWidth / 2 + cxx, windowHeight - windowHeight / 2 + cyy, 2, 2);
			line(windowWidth / 2 + px[j], windowHeight / 2 + py[j], windowWidth / 2 + cxx, windowHeight / 2 + cyy)
			//line(windowWidth / 2 + pxx, windowHeight / 2 + pyy, windowWidth / 2 + cx, windowHeight / 2 + cy)
			
			px[j] = cxx;
			py[j] = cyy;
			pxx = cxx;
			pyy = cyy;
		}
	}
}

function draw() {
	noStroke();
	
	fill(0, 0, 0, 1);
	rect(0, 0, windowWidth, windowHeight);
	
	compute();
	
	xmotion += 0.001;
	ymotion += 0.001;
}"
"771038","My Sketch","mySketch","var xmotion = 0;
var ymotion = 0;

// https://iquilezles.org/www/articles/palettes/palettes.htm
function pal(t, a, b, c, d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

function setup() {
	createCanvas(windowWidth, windowHeight);
	
	background(0);
	
	noiseDetail(7, 0.7);
	
	ellipseMode(CENTER);
	
	xmotion = random();
	ymotion = random();
}

function compute() {
	fill(0);
	
	noStroke();
	
	var px = [];
	var py = [];
	var pxx = 0;
	var pyy = 0;
	
	for (var i = 0; i < 40; i += 1) {
		var ni = i / 40;
		var nic = 1.0 - abs(0.5 - ni) * 2;
		
		for (var j = 0; j < 64; j += 1) {
			var ji = j / 64;
			var jic = 1.0 - abs(0.5 - ji) * 20;
			
			var n = noise(nic * jic + xmotion);

			var cx = sin(ni * PI * 2 + xmotion * Math.sign(0.5 - jic));
			var cy = cos(ni * PI * 2 + xmotion * Math.sign(0.5 - jic));
			
			var cxx = cx * ((windowWidth) * (sin(xmotion + ji * PI * 200)));
			var cyy = cy * ((windowWidth) * (cos(xmotion + ji * PI * 200)));
			
			var pa = 0.5;
			var pb = 0.5;
			var pc = 1;

			var pdr = 0.2;
			var pdg = 0.1;
			var pdb = 1;
			
			var nicjic = (nic * jic);
			
			var b = 255 * abs(sin(xmotion * 64 * Math.sign(0.5 - n) * n));

			var rf = pal(nicjic, pa, pb, pc, pdr) * b;
			var gf = pal(nicjic, pa, pb, pc, pdg) * b;
			var bf = pal(nicjic, pa, pb, pc, pdb) * b;
		
			fill(rf, gf, bf, 255);
			stroke(rf, gf, bf, 256);
			
			//ellipse(windowWidth / 2 + cxx, windowHeight / 2 + cyy, 1, 1);
			//ellipse(windowWidth - windowWidth / 2 + cxx, windowHeight - windowHeight / 2 + cyy, 2, 2);
			line(windowWidth / 2 + px[j], windowHeight / 2 + py[j], windowWidth / 2 + cxx, windowHeight / 2 + cyy)
			//line(windowWidth / 2 + pxx, windowHeight / 2 + pyy, windowWidth / 2 + cx, windowHeight / 2 + cy)
			
			px[j] = cxx;
			py[j] = cyy;
			pxx = cxx;
			pyy = cyy;
		}
	}
}

function draw() {
	noStroke();
	
	//fill(0, 0, 0, 8);
	//rect(0, 0, windowWidth, windowHeight);
	
	compute();
	
	xmotion += 0.001;
	ymotion += 0.001;
}"
"763921","Masque 2","mySketch","// trying to structure it

float xmotion = 8.8;
float ymotion = 2.2;

int reset = 0;
int perlin_amount = 8;

void draw_func() {
	noStroke();

	loadPixels();
	for (int y = 0; y < height; y += 1) {
		int yy = y * width;
		for (int x = 0; x < width; x += 1) {
			color p = pixels[yy + x];
				float normx = (float)x / width;
				float normy = (float)y / height;
				float anormx = 1.0 - abs(0.5 - normx) * 2;
				float anormy = 1.0 - abs(0.5 - normy) * 2;
				float anormxy = anormx * normy;
				float ianormxy = 1 - (anormx * anormy);
			float xm = 4;
			float fr = (frameCount - reset) * 8;
			float ym = 128 - pow(fr, 1.175) - pow(fr, 0.625) * anormxy;//(frameCount - reset) * 7;
			
			if ((brightness(p) > xm && brightness(p) < ym)) {
				float xk = xmotion / 128;
				float yk = ymotion / 128;
				
				float n = (0.5-noise(anormx*2+xk,anormy*2+yk)) * (perlin_amount + fr / 1.4);
				float nn = (0.5-noise(normx * 4 + xk, normy * 4 + yk));
				
				fill(224 + 58 * anormxy + 192 * abs(nn) + hue(p) * abs(nn), 128, 255, 2 + 128 * abs(nn));
				
				float nnx = n * pow(ianormxy, 1.2);
				float nny = n * ianormxy;
				float nsx = 3 * anormx;
				float nsy = 3 * anormy;

				
				float dst = n * ianormxy * 8;
				float idst = 1 - dst;
				
				ellipse(x + nnx * 2 * ianormxy * (fr / 8), y + (n / 2) + 1 * dst * (fr / 8), nsx, nsy);
				ellipse(width - x + nnx * 2 * ianormxy * (fr / 8), y + (n / 2) + 1 * dst * (fr / 8), nsx, nsy);
				
				xmotion += anormx / 128;
				ymotion += anormy / 128;
			}
		}
	}

}

void setup() {
  size(800, 800);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	noiseDetail(5,0.5);
	
	frameRate(60);
	
	
		noFill();
		noStroke();

		rectMode(CENTER);
		ellipseMode(CENTER);

		stroke(0, 0, 255, 12);
		strokeWeight(1);
		strokeCap(ROUND);
		noFill();
		int nx = random(width / 2);
		int ny = random(height / 2);
		
		int lx = nx + random(width - nx);
	
	for (int i = 0; i < height; i += height / 24) {
		float normi = (float)i / height;
		float offy = ((normi * (height / 1.25) - (height - (height / 1.25)) / 2) * (normi)) + height * 0.25 / 2;
		bezier(width / 2 - random(0, width / 1.5), offy,
					 width / 2 - abs(sin(normi * PI * 0.9)) * (width / 3.5), offy + random(-256, 256),
					 width / 2 - random(0, width / 1.5), offy,
					 width / 2 - abs(sin(normi * PI * 0.9)) * (width / 3.5), offy + random(-256, 256));
	}
	strokeWeight(2);
	for (int i = 0; i < 16; i += 1) {
		float normi = (float)i / 16;
		line(width / 2 - normi * 128, height / 1.35, width / 2 - normi * 128 + random(-28, 28), height / 1.1);
	}
	strokeWeight(1);
	for (int i = 0; i < 8; i += 1) {
		float normi = (float)i / 8;
		line(width / 2 - cos(normi * PI * 1) * width / 2, 0, width / 2 - cos(normi * PI * 1) * width / 4 + random(-28, 28), height * 0.2);
	}
	strokeWeight(4);
	fill(0, 0, 0, 12);
	ellipse(width / 2 - width / 7, height / 3, width / 7, height / 7);
	ellipse(width - width / 2 + width / 7, height / 3, width / 7, height / 7);
	rect(width / 2, height / 1.75, width / 5, height / 8);
	noFill();
	
		rectMode(CORNER);
	
	//smooth();
}

void mouseClicked() {
 background(0);
	
	reset = frameCount;
	
	perlin_amount = random(40, 80);
}

void draw() {
	noStroke();
 draw_func();
	
	float fr = (frameCount - reset) * 7;
	
	if (fr > 120 && fr < 360) {
		float w = width / 6 * random();
		float h = height / 6 * random();
		float w2 = width / 4 * random();
		float h2 = height / 7 * random();
		fill(0, 0, 0, 108 * random());
		noStroke();
		ellipse(width / 2 - width / 7, height / 3, w, h);
		ellipse(width - width / 2 + width / 7, height / 3, w, h);
		ellipse(width / 2, height / 1.75, w2, h2);
		noFill();
		/*
		for (int i = 0; i < 24; i += 1) {
			fill(0, 0, 255, 32 * random());
			ellipse(random(0, width), random(0, height), random(1, 10), random(1, 10));
		}*/
	}
}"
"763915","Masque","mySketch","// trying to structure it

float xmotion = 8.8;
float ymotion = 2.2;

int reset = 0;
int perlin_amount = 14;

void draw_func() {
	noStroke();

	loadPixels();
	for (int y = 0; y < height; y += 1) {
		int yy = y * width;
		for (int x = 0; x < width; x += 1) {
			color p = pixels[yy + x];
				float normx = (float)x / width;
				float normy = (float)y / height;
				float anormx = 1.0 - abs(0.5 - normx) * 2;
				float anormy = 1.0 - abs(0.5 - normy) * 2;
				float anormxy = anormx * normy;
				float ianormxy = 1 - (anormx * anormy);
			float xm = 4;
			float fr = (frameCount - reset) * 7;
			float ym = 128 - pow(fr, 1.125) - pow(fr, 0.625) * anormxy;//(frameCount - reset) * 7;
			
			if ((brightness(p) > xm && brightness(p) < ym)) {
				float xk = xmotion / 128;
				float yk = ymotion / 128;
				
				float n = (0.5-noise(anormx*2+xk,anormy*2+yk)) * (perlin_amount + fr / 1.4);
				float nn = (0.5-noise(normx * 4 + xk, normy * 4 + yk));
				
				fill(48 + 58 * anormxy + 192 * abs(nn) + hue(p) * abs(nn), 128, 255, 3 + 8 * abs(nn));
				
				float nnx = n * pow(ianormxy, 1.2);
				float nny = n * ianormxy;
				float nsx = 3 * anormx;
				float nsy = 3 * anormy;

				
				float dst = pow(normy, 1.425);
				float idst = 1 - dst;
				
				ellipse(x + nnx * 4, y + (n / 2) + 4 * dst * (fr / 32), nsx, nsy);
				ellipse(width - x + nnx * 4, y + (n / 2) + 4 * dst * (fr / 32), nsx, nsy);
				
				xmotion += anormx / 100;
				ymotion += anormy / 100;
			}
		}
	}

}

void setup() {
  size(800, 800);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	noiseDetail(5,0.5);
	
	frameRate(60);
	
	
		noFill();
		noStroke();

		rectMode(CENTER);
		ellipseMode(CENTER);

		stroke(0, 0, 255, 12);
		strokeWeight(1);
		strokeCap(ROUND);
		noFill();
		int nx = random(width / 2);
		int ny = random(height / 2);
		
		int lx = nx + random(width - nx);
	
	for (int i = 0; i < height; i += height / 24) {
		float normi = (float)i / height;
		float offy = ((normi * (height / 1.25) - (height - (height / 1.25)) / 2) * (normi)) + height * 0.25 / 2;
		bezier(width / 2 - random(0, 92), offy,
					 width / 2 - abs(sin(normi * PI * 0.9)) * (width / 3.5), offy + random(-192, 192),
					 width / 2 - random(0, 92), offy,
					 width / 2 - abs(sin(normi * PI * 0.9)) * (width / 3.5), offy + random(-192, 192));
	}
	strokeWeight(2);
	for (int i = 0; i < 8; i += 1) {
		float normi = (float)i / 8;
		line(width / 2 - normi * 128, height / 1.35, width / 2 - normi * 128 + random(-28, 28), height / 1.1);
	}
	strokeWeight(1);
	for (int i = 0; i < 16; i += 1) {
		float normi = (float)i / 16;
		line(width / 2 - cos(normi * PI * 1) * width / 2, 0, width / 2 - cos(normi * PI * 1) * width / 4 + random(-28, 28), height * 0.2);
	}
	
	fill(0, 0, 0, 24);
	ellipse(width / 2 - width / 7, height / 3, width / 7, height / 7);
	ellipse(width - width / 2 + width / 7, height / 3, width / 7, height / 7);
	rect(width / 2, height / 1.75, width / 5, height / 8);
	noFill();
	
		rectMode(CORNER);
	
	//smooth();
}

void mouseClicked() {
 background(0);
	
	reset = frameCount;
	
	perlin_amount = random(40, 80);
}

void draw() {
	noStroke();
 draw_func();
	
	float fr = (frameCount - reset) * 7;
	
	if (fr > 120 && fr < 360) {
		float w = width / 7 * random();
		float h = height / 7 * random();
		float w2 = width / 5 * random();
		float h2 = height / 8 * random();
		fill(0, 0, 0, 108 * random());
		noStroke();
		ellipse(width / 2 - width / 7, height / 3, w, h);
		ellipse(width - width / 2 + width / 7, height / 3, w, h);
		ellipse(width / 2, height / 1.75, w2, h2);
		noFill();
		
		for (int i = 0; i < 24; i += 1) {
			fill(0, 0, 255, 32 * random());
			ellipse(random(0, width), random(0, height), random(1, 10), random(1, 10));
		}
	}
}"
"763006","Spectre","mySketch","// failed recreation of a face part inspired by a painting by Zdzisław Beksiński

float xmotion = 8.8;
float ymotion = 2.2;

int reset = 0;
int perlin_amount = 64;

void draw_func() {
	noStroke();

	loadPixels();
	for (int y = 0; y < height; y += 1) {
		int yy = y * width;
		for (int x = 0; x < width; x += 1) {
			color p = pixels[yy + x];
			
			float xm = 4;
			float fr = (frameCount - reset) * 7;
			float ym = 128 - pow(fr, 1.07);//(frameCount - reset) * 7;
			
			if ((brightness(p) > xm && brightness(p) < ym)) {
				float normx = (float)x / width;
				float normy = (float)y / height;
				float anormx = 1.0 - abs(0.5 - normx) * 2;
				float anormy = 1.0 - abs(0.5 - normy) * 2;
				float anormxy = anormx * normy;
				float ianormxy = 1 - (anormx * anormy);
				
				float xk = xmotion / 128;
				float yk = ymotion / 128;
				
				float n = (0.5-noise(anormx*2+xk,anormy*2+yk)) * (perlin_amount + fr / 1.4);
				float nn = (0.5-noise(normx * 4 + xk, normy * 4 + yk));
				
				fill(74 + 92 * abs(nn) + hue(p) * abs(nn), 128, 255, 2 + 6 * abs(nn));
				
				float nnx = n * pow(ianormxy, 2.4);
				float nny = n * ianormxy;
				float nsx = 5 * anormx;
				float nsy = 5 * anormy;

				
				float dst = pow(normy, 1.5);
				float idst = 1 - dst;
				
				ellipse(x + nnx * 4, y + (n / 2) * idst + 8 * dst, nsx, nsy);
				ellipse(width - x + nnx * 4, y + (n / 2) * idst + 8 * dst, nsx, nsy);
				
				xmotion += anormx / 128;
				ymotion += anormy / 128;
			}
		}
	}

}

void setup() {
  size(800, 800);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	noiseDetail(4,0.5);
	
	frameRate(60);
	
	
		noFill();
		noStroke();

		rectMode(CENTER);
		ellipseMode(CENTER);

		stroke(0, 0, 255, 12);
		strokeWeight(1);
		strokeCap(ROUND);
		noFill();
		int nx = random(width / 2);
		int ny = random(height / 2);
		
		int lx = nx + random(width - nx);
	
	for (int i = 0; i < height; i += height / 48) {
		float normi = (float)i / height;
		float offy = ((normi * (height / 1.25) - (height - (height / 1.25)) / 2) * (normi)) + height * 0.25 / 2;
		bezier(width / 2 - random(0, 32), offy,
					 width / 2 - abs(sin(normi * PI * 0.9)) * (width / 3.5), offy + random(-64, 64),
					 width / 2 - random(0, 32), offy,
					 width / 2 - abs(sin(normi * PI * 0.9)) * (width / 3.5), offy + random(-64, 64));
	}
	
	for (int i = 0; i < 8; i += 1) {
		float normi = (float)i / 8;
		line(width / 2 - normi * 128, height / 1.35, width / 2 - normi * 128 + random(-28, 28), height / 1.1);
	}
	
	fill(0, 0, 0, 24);
	ellipse(width / 2 - width / 7, height / 3, width / 7, height / 7);
	ellipse(width - width / 2 + width / 7, height / 3, width / 7, height / 7);
	ellipse(width / 2, height / 1.75, width / 5, height / 8);
	noFill();
	

		
		//line(0, height - 192, width /2 , height - 192 - 48);
/*		
	for (int i = 0; i < 4; i += 1) {
		line(i * 92, height - 180, 64 + i * 92, height + (2 - i * 256));
		//line(64 + i * 92, 0, 64 + i * 92, (128 + i * 32));
		//line(64 + i * 92, 0, 256 + i * 92, (128 + i * 32));
	  //line(width / 3 - i * 128, height - 64, width / 3 - i * 128, height / 2 + height / 5);
	}
	stroke(0, 0, 255, 8);
	
	for (int i = 0; i < 8; i += 1) {
		ellipse(random(width / 8), random(height / 2, height / 1.6), 1, 1);
	}
	strokeWeight(2);
*/
	//line(300, 64, 300, height / 6);
		//triangle(nx + random(width - nx), ny + random(height - ny), nx + random(width - nx), ny + random(height - ny), nx + random(width - nx), ny + random(height - ny));
		//ellipse(width / 2, height / 2, height / 2, height / 2);
	  //rect(width / 3, height / 2, width / 5, height / 2);
	  //rect(width - width / 3, height / 2, width / 5, height / 2);
		//rect(nx + random(width - nx), ny + random(height - ny), nx, ny);
		//bezier(random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height));
		//strokeWeight(1 + random(8));
		//bezier(random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height));

		rectMode(CORNER);
	
	//smooth();
}

void mouseClicked() {
	background(0);
	
	reset = frameCount;
	
	perlin_amount = random(40, 80);
}

void draw() {
 draw_func();
	
	float fr = (frameCount - reset) * 7;
	
	if (fr > 120 && fr < 340) {
		float w = width / 7 * random();
		float h = height / 7 * random();
		float w2 = width / 5 * random();
		float h2 = height / 8 * random();
		fill(0, 0, 0, 108 * random());
		noStroke();
		ellipse(width / 2 - width / 7, height / 3, w, h);
		ellipse(width - width / 2 + width / 7, height / 3, w, h);
		ellipse(width / 2, height / 1.75, w2, h2);
		noFill();
		
		for (int i = 0; i < 32; i += 1) {
			fill(0, 0, 255, 24 * random());
			ellipse(random(0, width), random(0, height), random(1, 10), random(1, 10));
		}
	}
}"
"763006","Spectre","mySketch","// failed recreation of a face part inspired by a painting by Zdzisław Beksiński

float xmotion = 8.8;
float ymotion = 2.2;

int reset = 0;
int perlin_amount = 64;

void draw_func() {
	noStroke();

	loadPixels();
	for (int y = 0; y < height; y += 1) {
		int yy = y * width;
		for (int x = 0; x < width; x += 1) {
			color p = pixels[yy + x];
			
			float xm = 4;
			float fr = (frameCount - reset) * 7;
			float ym = 128 - pow(fr, 1.02);//(frameCount - reset) * 7;
			
			if ((brightness(p) > xm && brightness(p) < ym)) {
				float normx = (float)x / width;
				float normy = (float)y / height;
				float anormx = 1.0 - abs(0.5 - normx) * 2;
				float anormy = 1.0 - abs(0.5 - normy) * 2;
				float anormxy = anormx * normy;
				float ianormxy = 1 - (anormx * anormy);
				
				float xk = xmotion / 128;
				float yk = ymotion / 128;
				
				float n = (0.5-noise(anormx*2+xk,anormy*2+yk)) * (perlin_amount + fr / 1.4);
				float nn = (0.5-noise(normx * 4 + xk, normy * 4 + yk));
				
				fill(74 + 92 * abs(nn) + hue(p) * abs(nn), 128, 255, 2 + 6 * abs(nn));
				
				float nnx = n * pow(ianormxy, 1.24);
				float nny = n * ianormxy;
				float nsx = 3 * anormx;
				float nsy = 3 * anormy;

				
				float dst = pow(normy, 1.25);
				float idst = 1 - dst;
				
				ellipse(x + nnx * 4, y + (n / 2) * idst + 8 * dst, nsx, nsy);
				ellipse(width - x + nnx * 4, y + (n / 2) * idst + 8 * dst, nsx, nsy);
				
				xmotion += anormx / 128;
				ymotion += anormy / 128;
			}
		}
	}

}

void setup() {
  size(800, 800);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	noiseDetail(4,0.5);
	
	frameRate(60);
	
	
		noFill();
		noStroke();

		rectMode(CENTER);
		ellipseMode(CENTER);

		stroke(0, 0, 255, 12);
		strokeWeight(1);
		strokeCap(ROUND);
		noFill();
		int nx = random(width / 2);
		int ny = random(height / 2);
		
		int lx = nx + random(width - nx);
	
	for (int i = 0; i < height; i += height / 24) {
		float normi = (float)i / height;
		float offy = ((normi * (height / 1.25) - (height - (height / 1.25)) / 2) * (normi)) + height * 0.25 / 2;
		bezier(width / 2 - random(0, 32), offy,
					 width / 2 - abs(sin(normi * PI * 0.9)) * (width / 3.5), offy + random(-64, 64),
					 width / 2 - random(0, 32), offy,
					 width / 2 - abs(sin(normi * PI * 0.9)) * (width / 3.5), offy + random(-64, 64));
	}
	
	for (int i = 0; i < 8; i += 1) {
		float normi = (float)i / 8;
		line(width / 2 - normi * 128, height / 1.35, width / 2 - normi * 128 + random(-28, 28), height / 1.1);
	}
	
	fill(0, 0, 0, 24);
	ellipse(width / 2 - width / 7, height / 3, width / 7, height / 7);
	ellipse(width - width / 2 + width / 7, height / 3, width / 7, height / 7);
	ellipse(width / 2, height / 1.75, width / 5, height / 8);
	noFill();
	

		
		//line(0, height - 192, width /2 , height - 192 - 48);
/*		
	for (int i = 0; i < 4; i += 1) {
		line(i * 92, height - 180, 64 + i * 92, height + (2 - i * 256));
		//line(64 + i * 92, 0, 64 + i * 92, (128 + i * 32));
		//line(64 + i * 92, 0, 256 + i * 92, (128 + i * 32));
	  //line(width / 3 - i * 128, height - 64, width / 3 - i * 128, height / 2 + height / 5);
	}
	stroke(0, 0, 255, 8);
	
	for (int i = 0; i < 8; i += 1) {
		ellipse(random(width / 8), random(height / 2, height / 1.6), 1, 1);
	}
	strokeWeight(2);
*/
	//line(300, 64, 300, height / 6);
		//triangle(nx + random(width - nx), ny + random(height - ny), nx + random(width - nx), ny + random(height - ny), nx + random(width - nx), ny + random(height - ny));
		//ellipse(width / 2, height / 2, height / 2, height / 2);
	  //rect(width / 3, height / 2, width / 5, height / 2);
	  //rect(width - width / 3, height / 2, width / 5, height / 2);
		//rect(nx + random(width - nx), ny + random(height - ny), nx, ny);
		//bezier(random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height));
		//strokeWeight(1 + random(8));
		//bezier(random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height));

		rectMode(CORNER);
	
	//smooth();
}

void mouseClicked() {
	background(0);
	
	reset = frameCount;
	
	perlin_amount = random(40, 80);
}

void draw() {
	noStroke();
 draw_func();
	
	float fr = (frameCount - reset) * 7;
	
	if (fr > 120 && fr < 340) {
		float w = width / 7 * random();
		float h = height / 7 * random();
		float w2 = width / 5 * random();
		float h2 = height / 8 * random();
		fill(0, 0, 0, 108 * random());
		noStroke();
		ellipse(width / 2 - width / 7, height / 3, w, h);
		ellipse(width - width / 2 + width / 7, height / 3, w, h);
		ellipse(width / 2, height / 1.75, w2, h2);
		noFill();
		
		for (int i = 0; i < 32; i += 1) {
			fill(0, 0, 255, 24 * random());
			ellipse(random(0, width), random(0, height), random(1, 10), random(1, 10));
		}
	}
}"
"749011","Ocean","mySketch","// sky + ground

float xmotion = 8.8;
float ymotion = 2.2;

int reset = 0;
int perlin_amount = 80;

float[] ppx = new float[800 * 800];
float[] ppy = new float[800 * 800];

// https://iquilezles.org/www/articles/palettes/palettes.htm
float pal(float t, float a, float b, float c, float d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

void shapel(float x1, float y1, float x2, float y2, float dirx, float diry) {
	float dx = x2 - x1;
	float dy = y2 - y1;
	
	float xx1 = x1;
	float xx2 = x2;
	if (x1 > x2) {
		xx1 = x2;
		xx2 = x1;
	}
	//noStroke();
	strokeWeight(1);
	for (float x = xx1; x < xx2; x += 1) {
		float norm_dst = abs(x - xx2) / abs(xx2);
		float anorm_dst = 1.0 - abs(0.5 - norm_dst) * 2;
		
		float y = y1 + dy * (x - x1) / dx;
		
		float ynorm = (y + (ymotion * 1.5)) / (float)height;
		float anorm_y = 1.0 - abs(0.5 - ynorm) * 9;
		
		float anorm_y2 = 1.0 - abs(0.5 - ynorm) * 8;
		
		float n = (0.5-noise(x / (abs(x1 - x2)) + xmotion / 140 * anorm_y2, y / (abs(y1 - y2)) + ymotion / 240 * anorm_y2)) * 2 * anorm_y2;
		
		float pa = 0.95;
		float pb = 0.5;
		float pc = 0.95;
		
		float pdr = 0.05;
		float pdg = 0.15;
		float pdb = 0.2;
		
		float rf = pal(1-abs(anorm_y / 20 + n), pa, pb, pc, pdr) * 255;
		float gf = pal(1-abs(anorm_y / 20 + n), pa, pb, pc, pdg) * 255;
		float bf = pal(1-abs(anorm_y / 20 + n), pa, pb, pc, pdb) * 255;
		
		fill(rf, gf, bf, 12 + 4 * n);
		stroke(rf / 1.425, gf / 1.425, bf / 1.425, 12 + 4 * n);
		
		float s = 1 + 8 * anorm_dst;
		
		if (dirx < 0 && diry < 0) {
			ellipse(x - n * 32 - xmotion * 4 * ynorm, y - n * 120 * anorm_y2 - ymotion * 6 * ynorm, s * abs(n), s * abs(n));
		} else if (dirx > 0 && diry > 0) {
			ellipse(x + n * 32 + xmotion * 4 * ynorm, y + n * 120 * anorm_y2 + ymotion * 6 * ynorm, s * abs(n), s * abs(n));
		} else if (dirx < 0 && diry > 0) {
			ellipse(x - n * 32 - xmotion * 4 * ynorm, y + n * 120 * anorm_y2 + ymotion * 6 * ynorm, s * abs(n), s * abs(n));
		} else if (dirx > 0 && diry < 0) {
			ellipse(x + n * 32 + xmotion * 4 * ynorm, y - n * 120 * anorm_y2 - ymotion * 6 * ynorm, s * abs(n), s * abs(n));
		}
		
		//stroke(rf, gf, bf, 24 * abs(n));
		//line(x - n * 180 - xmotion * 4, y - n * 180 + ymotion * 4, x + n * 180 - xmotion * 4, y + n * 180 + ymotion * 4);
	}
	
	stroke(0, 0, 255, 1);
}

void draw_func() {
	noStroke();
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	float x1 = -100;
	float y1 = 0;
	float x2 = width + 100;
	float y2 = 0.1;
	
	stroke(0, 0, 255, 1);
	strokeWeight(1);
	//line(x1, y1, x2, y2);
	
	shapel(x1, y1, x2, y2, 1, 1);
	
	x1 = -100;
	y1 = height;
	x2 = width + 100;
	y2 = height-0.1;
	//line(x1, y1, x2, y2);

	//shapel(x1, y1, x2, y2, -1, -1);
	/*
	x1 = 0;
	y1 = height - height /1.99;
	x2 = width;
	y2 = height - height /2;
	//line(x1, y1, x2, y2);

	shapel(x1, y1, x2, y2, 1, -1);
	
	x1 = 0;
	y1 = height /1.99;
	x2 = width;
	y2 = height /2;
	//line(x1, y1, x2, y2);

	shapel(x1, y1, x2, y2, 1, -1);
			*/	
				xmotion -= 0.01;
				ymotion += 0.1;
}

void setup() {
  size(800, 800);

  background(0);
	
	//colorMode(HSB, 360, 256, 256);
	
	noiseDetail(6,0.65);
	
	frameRate(60);
	
	
		noFill();
		noStroke();

		rectMode(CENTER);
		ellipseMode(CENTER);

		stroke(0, 0, 255, 255);
		strokeWeight(2);
		strokeCap(ROUND);
		noFill();
		int nx = random(width / 2);
		int ny = random(height / 2);
		
		int lx = nx + random(width - nx);
		
		//line(0, height - 192, width, height - 192);
	  //line(0, height - 192 / 1.15, width, height - 192 / 1.15);
	  //line(0, height - 192 / 1.3, width, height - 192 / 1.3);
	  //line(2 * 92, height + (2 - 1.45 * 512), width / 2, height + (2 - 1.45 * 512));
	  //line(3 * 84, height - 512, width / 2 - 3 * 84, height - 512);
	  //bezier(3.1 * 84, height - 550, 400, 0, 0, 0, 0, height - 2 * 550);
	 // bezier(2.6 * 84, height - 512, 400, 0, 100, 0, -200, height - 2 * 512);
	 // bezier(2 * 84, height - 512, 400, 0, 100, 0, -200, height - 2 * 512);
	  //bezier(1.4 * 84, height - 512, 400, 0, 100, 0, -200, height - 2 * 512);
	  //line(4 * 92, height - 1.25 * 512, width / 2 - 4 * 92, height - 1.25 * 512);
	
	  
	  //rect(width / 2, height / 5, width / 5.5, width / 7);
	  //ellipse(width / 2, height / 5, width / 4, width / 7);
		
	  //line(2 * 92, height - 180, 64 + 2 * 148, height + (2 - 2 * 512));
	  //line(-92, height - 180, 64 + 48, height + (2 - 1 * 512));
	
	for (int i = 0; i < 3; i += 1) {
		//line(i * 92, height - 180, 64 + i * 148, height + (2 - i * 512));
		//line(64 + i * 92, 0, 64 + i * 92, (128 + i * 32));
		//line(64 + i * 92, 0, 256 + i * 92, (128 + i * 32));
	  //line(width / 3 - i * 128, height - 64, width / 3 - i * 128, height / 2 + height / 5);
	}
	//stroke(0, 0, 255, 92);
	
	//line(width / 2, height - 210, width / 2, height - 192);
	/*
	for (int i = 0; i < 8; i += 1) {
		ellipse(random(width / 8), random(height / 2, height / 1.6), 1, 1);
	}*/
	strokeWeight(2);
	//line(300, 64, 300, height / 6);
		//triangle(nx + random(width - nx), ny + random(height - ny), nx + random(width - nx), ny + random(height - ny), nx + random(width - nx), ny + random(height - ny));
		//ellipse(width / 2, height / 2, height / 2, height / 2);
	  //rect(width / 3, height / 2, width / 5, height / 2);
	  //rect(width - width / 3, height / 2, width / 5, height / 2);
		//rect(nx + random(width - nx), ny + random(height - ny), nx, ny);
		//bezier(random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height));
		//strokeWeight(1 + random(8));
		//bezier(random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height));

		rectMode(CORNER);
	
	//smooth();
}

void mouseClicked() {
	background(0);
	
	reset = frameCount;
	
	perlin_amount = random(40, 80);
}

void draw() {
  draw_func();
}"
"743086","Tissue","mySketch","// doing it by following lines instead of per pixels (note : mostly useless in that case but the result look nice)

float xmotion = 8.8;
float ymotion = 2.2;

int reset = 0;
int perlin_amount = 80;

float[] ppx = new float[800 * 800];
float[] ppy = new float[800 * 800];

// https://iquilezles.org/www/articles/palettes/palettes.htm
float pal(float t, float a, float b, float c, float d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

void shapel(float x1, float y1, float x2, float y2, float dirx, float diry) {
	float dx = x2 - x1;
	float dy = y2 - y1;
	
	float xx1 = x1;
	float xx2 = x2;
	if (x1 > x2) {
		xx1 = x2;
		xx2 = x1;
	}
	//noStroke();
	strokeWeight(1);
	for (float x = xx1; x < xx2; x += 1) {
		float norm_dst = abs(x - xx2) / abs(xx2);
		float anorm_dst = 1.0 - abs(0.5 - norm_dst) * 2;
		
		float y = y1 + dy * (x - x1) / dx;
		
		float ynorm = (y + ymotion * 1) / (float)height;
		
		float anorm_y = 1.0 - abs(0.5 - ynorm) * 2;
		
		float anorm_y2 = 1.0 - abs(0.5 - ynorm) * 2.5;
		
		//if (anorm_dst > -0.5 && anorm_dst < 0.5) anorm_dst = lerp(anorm_dst, anorm_dst * 2 * anorm_y, anorm_dst * 2);
		
		float n2 = (0.5-noise(anorm_dst + xmotion / 24, anorm_y2 + ymotion / 24)) * 2 / (1 + anorm_y * 64);
		
		float moda = cos(ynorm * PI * 1.5 + n2 * PI * 2);
		float modb = sin(norm_dst * PI * (12.5 * (1-anorm_y2)) + n2 * PI * 2);
		
		float mod = abs(moda * modb);
		
		if (ynorm > 0.75) mod = (lerp(mod - norm_dst, anorm_y, (ynorm - 0.75) * 0.5));
		else mod = (mod % (anorm_dst * 2 + ymotion / 16));
		
		float n = (0.5-noise(anorm_dst + xmotion / 28 * anorm_y, anorm_y + ymotion / 22)) * 2 * pow(ynorm, 1.17) * mod; //% (0.5-noise(anorm_dst + xmotion / 8 * anorm_y2, anorm_y2 + ymotion / 8)) * 2;
		
		float pa = 0.5 + abs(n / 2);
		float pb = 0.5 - abs(n / 2);
		float pc = 0.35;
		
		float pdr = 0.025;
		float pdg = 0.05;
		float pdb = 0.96;
		
		float rf = pal(ynorm, pa, pb, pc, pdr) * 255;
		float gf = pal(ynorm, pa, pb, pc, pdg) * 255;
		float bf = pal(ynorm, pa, pb, pc, pdb) * 255;
		
		fill(rf, gf, bf, 92 * abs(n) * 4);
		stroke(rf / 2.5, gf / 2.5, bf / 2.5, 22 * abs(n2) * 6);
		
		float s = 24 * abs(n * (0.75 + ynorm));
		
		if (dirx < 0 && diry < 0) {
			ellipse(x - n * 30 + cos(anorm_dst * PI * 3 + xmotion) * 4, y - n * 140 - ymotion * 4.5 + sin(anorm_dst * PI * 0.25 + xmotion) * 80 * anorm_dst * (1-ynorm), s, s);
		} else if (dirx > 0 && diry > 0) {
			ellipse(x + n * 30 + cos(anorm_dst * PI * 3 + xmotion) * 4, y + n * 140 + ymotion * 4.5 + sin(anorm_dst * PI * 0.25 + xmotion) * 80 * anorm_dst * (1-ynorm), s, s);
		} else if (dirx < 0 && diry > 0) {
			ellipse(x - n * 30 + cos(ynorm * PI * 3 + xmotion) * 8, y + n * 190 + ymotion * 3.5 + cos(norm_dst * PI * 3 + sin(ynorm * PI * 2) * PI * 2 + xmotion) * (40 + n * 30) * (1-ynorm) * sin(ynorm * PI * 3), s, s);
		} else if (dirx > 0 && diry < 0) {
			ellipse(x + n * 30 + cos(anorm_dst * PI * 3) * 4, y - n * 140 - ymotion * 4.5 + sin(anorm_dst * PI * 0.25 + xmotion) * 80 * anorm_dst * (1-ynorm), s, s);
		}
		
		//stroke(rf, gf, bf, 64 * abs(n));
		//line(x - n * 40 - xmotion * 8, y - n * 40 + ymotion * 8, x + n * 40 - xmotion * 8, y + n * 40 + ymotion * 8);
	}
	
	stroke(0, 0, 255, 1);
}

void draw_func() {
	noStroke();
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	float x1 = -200;
	float y1 = 4;
	float x2 = width;
	float y2 = -4.1 + ymotion * 1.5;
	
	stroke(0, 0, 255, 1);
	//line(x1, y1, x2, y2);
	
	
	//shapel(x1, y1, x2, y2, 1, 1);
	shapel(x1, y1, x2, y2, -1, 1);
	
	x1 = -200;
	y1 = height;
	x2 = width;
	y2 = (height-0.1);
	//line(x1, y1, x2, y2);

	//shapel(x1, y1, x2, y2, -1, -1);
	/*
	x1 = 0;
	y1 = height - height /1.99;
	x2 = width;
	y2 = height - height /2;
	//line(x1, y1, x2, y2);

	shapel(x1, y1, x2, y2, 1, -1);
	
	x1 = 0;
	y1 = height /1.99;
	x2 = width;
	y2 = height /2;
	//line(x1, y1, x2, y2);

	shapel(x1, y1, x2, y2, 1, -1);
			*/	
				xmotion += 0;
				ymotion += 0.25;
}

void setup() {
  size(700, 700);

  background(0);
	
	//colorMode(HSB, 360, 256, 256);
	
	noiseDetail(7,0.65);
	
	frameRate(60);
	
	
		noFill();
		noStroke();

		rectMode(CENTER);
		ellipseMode(CENTER);

		stroke(0, 0, 255, 255);
		strokeWeight(2);
		strokeCap(ROUND);
		noFill();
		int nx = random(width / 2);
		int ny = random(height / 2);
		
		int lx = nx + random(width - nx);
		
		//line(0, height - 192, width, height - 192);
	  //line(0, height - 192 / 1.15, width, height - 192 / 1.15);
	  //line(0, height - 192 / 1.3, width, height - 192 / 1.3);
	  //line(2 * 92, height + (2 - 1.45 * 512), width / 2, height + (2 - 1.45 * 512));
	  //line(3 * 84, height - 512, width / 2 - 3 * 84, height - 512);
	  //bezier(3.1 * 84, height - 550, 400, 0, 0, 0, 0, height - 2 * 550);
	 // bezier(2.6 * 84, height - 512, 400, 0, 100, 0, -200, height - 2 * 512);
	 // bezier(2 * 84, height - 512, 400, 0, 100, 0, -200, height - 2 * 512);
	  //bezier(1.4 * 84, height - 512, 400, 0, 100, 0, -200, height - 2 * 512);
	  //line(4 * 92, height - 1.25 * 512, width / 2 - 4 * 92, height - 1.25 * 512);
	
	  
	  //rect(width / 2, height / 5, width / 5.5, width / 7);
	  //ellipse(width / 2, height / 5, width / 4, width / 7);
		
	  //line(2 * 92, height - 180, 64 + 2 * 148, height + (2 - 2 * 512));
	  //line(-92, height - 180, 64 + 48, height + (2 - 1 * 512));
	
	for (int i = 0; i < 3; i += 1) {
		//line(i * 92, height - 180, 64 + i * 148, height + (2 - i * 512));
		//line(64 + i * 92, 0, 64 + i * 92, (128 + i * 32));
		//line(64 + i * 92, 0, 256 + i * 92, (128 + i * 32));
	  //line(width / 3 - i * 128, height - 64, width / 3 - i * 128, height / 2 + height / 5);
	}
	//stroke(0, 0, 255, 92);
	
	//line(width / 2, height - 210, width / 2, height - 192);
	/*
	for (int i = 0; i < 8; i += 1) {
		ellipse(random(width / 8), random(height / 2, height / 1.6), 1, 1);
	}*/
	strokeWeight(2);
	//line(300, 64, 300, height / 6);
		//triangle(nx + random(width - nx), ny + random(height - ny), nx + random(width - nx), ny + random(height - ny), nx + random(width - nx), ny + random(height - ny));
		//ellipse(width / 2, height / 2, height / 2, height / 2);
	  //rect(width / 3, height / 2, width / 5, height / 2);
	  //rect(width - width / 3, height / 2, width / 5, height / 2);
		//rect(nx + random(width - nx), ny + random(height - ny), nx, ny);
		//bezier(random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height));
		//strokeWeight(1 + random(8));
		//bezier(random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height));

		rectMode(CORNER);
	
	//smooth();
}

void mouseClicked() {
	background(0);
	
	reset = frameCount;
	
	xmotion = 8.8;
	ymotion = 2.2;
}

void draw() {
  draw_func();
}"
"743086","Tissue","mySketch","// doing it by following lines instead of per pixels (note : mostly useless in that case but the result look nice)

float xmotion = 8.8;
float ymotion = 2.2;

int reset = 0;
int perlin_amount = 80;

float[] ppx = new float[800 * 800];
float[] ppy = new float[800 * 800];

// https://iquilezles.org/www/articles/palettes/palettes.htm
float pal(float t, float a, float b, float c, float d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

void shapel(float x1, float y1, float x2, float y2, float dirx, float diry) {
	float dx = x2 - x1;
	float dy = y2 - y1;
	
	float xx1 = x1;
	float xx2 = x2;
	if (x1 > x2) {
		xx1 = x2;
		xx2 = x1;
	}
	//noStroke();
	strokeWeight(1);
	for (float x = xx1; x < xx2; x += 1) {
		float norm_dst = abs(x - xx2) / abs(xx2);
		float anorm_dst = 1.0 - abs(0.5 - norm_dst) * 2;
		
		float y = y1 + dy * (x - x1) / dx;
		
		float ynorm = (y + ymotion * anorm_dst) / (float)height;
		
		float anorm_y = 1.0 - abs(0.5 - ynorm) * 2;
		
		float anorm_y2 = 1.0 - abs(0.5 - ynorm) * 1.5;
		
		//if (anorm_dst > -0.5 && anorm_dst < 0.5) anorm_dst = lerp(anorm_dst, anorm_dst * 2 * anorm_y, anorm_dst * 2);
		
		float n2 = (0.5-noise(anorm_dst + xmotion / 24, anorm_y2 + ymotion / 24)) * 2 / (1 + anorm_y * 64);
		
		float moda = cos(ynorm * PI * 1.5 + n2 * PI * 2);
		float modb = (sin(norm_dst * PI * (22. * anorm_y2) + n2 * PI * 4));
		
		float mod = abs(moda * modb);
		
		if (ynorm > 0.75) mod = (lerp(mod - norm_dst, anorm_y, (ynorm - 0.75) * 0.5));
		else mod = mod;
		
		float n = (0.5-noise(anorm_dst + xmotion / 28 * anorm_y, anorm_y + ymotion / 22)) * 2 * pow(ynorm, 1.07) * mod; //% (0.5-noise(anorm_dst + xmotion / 8 * anorm_y2, anorm_y2 + ymotion / 8)) * 2;
		
		float pa = 0.5 + abs(n / 2);
		float pb = 0.5 - abs(n / 2);
		float pc = 0.35;
		
		float pdr = 0.025;
		float pdg = 0.05;
		float pdb = 0.92;
		
		float rf = pal(ynorm, pa, pb, pc, pdr) * 255;
		float gf = pal(ynorm, pa, pb, pc, pdg) * 255;
		float bf = pal(ynorm, pa, pb, pc, pdb) * 255;
		
		fill(rf, gf, bf, 92 * abs(n) * 4);
		stroke(rf / 2.5, gf / 2.5, bf / 2.5, 22 * abs(n2) * 6);
		
		float s = 24 * abs(n * (0.75 + ynorm));
		
		if (dirx < 0 && diry < 0) {
			ellipse(x - n * 30 + cos(anorm_dst * PI * 3 + xmotion) * 4, y - n * 140 - ymotion * 4.5 + sin(anorm_dst * PI * 0.25 + xmotion) * 80 * anorm_dst * (1-ynorm), s, s);
		} else if (dirx > 0 && diry > 0) {
			ellipse(x + n * 30 + cos(anorm_dst * PI * 3 + xmotion) * 4, y + n * 140 + ymotion * 4.5 + sin(anorm_dst * PI * 0.25 + xmotion) * 80 * anorm_dst * (1-ynorm), s, s);
		} else if (dirx < 0 && diry > 0) {
			ellipse(x - n * 30 + cos(ynorm * PI * 3 + xmotion) * 8, y + n * 190 + ymotion * 3.75 + cos(norm_dst * PI * 4 + sin(ynorm * PI * 3) * PI * 2 + xmotion) * (40 + n * 30) * (1-ynorm) * sin(ynorm * PI * 3), s, s);
		} else if (dirx > 0 && diry < 0) {
			ellipse(x + n * 30 + cos(anorm_dst * PI * 3) * 4, y - n * 140 - ymotion * 4.5 + sin(anorm_dst * PI * 0.25 + xmotion) * 80 * anorm_dst * (1-ynorm), s, s);
		}
		
		//stroke(rf, gf, bf, 64 * abs(n));
		//line(x - n * 40 - xmotion * 8, y - n * 40 + ymotion * 8, x + n * 40 - xmotion * 8, y + n * 40 + ymotion * 8);
	}
	
	stroke(0, 0, 255, 1);
}

void draw_func() {
	noStroke();
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	float x1 = -200;
	float y1 = 4;
	float x2 = width;
	float y2 = -4.1 + ymotion * 1.5;
	
	stroke(0, 0, 255, 1);
	//line(x1, y1, x2, y2);
	
	
	//shapel(x1, y1, x2, y2, 1, 1);
	shapel(x1, y1, x2, y2, -1, 1);
	
	x1 = -200;
	y1 = height;
	x2 = width;
	y2 = (height-0.1);
	//line(x1, y1, x2, y2);

	//shapel(x1, y1, x2, y2, -1, -1);
	/*
	x1 = 0;
	y1 = height - height /1.99;
	x2 = width;
	y2 = height - height /2;
	//line(x1, y1, x2, y2);

	shapel(x1, y1, x2, y2, 1, -1);
	
	x1 = 0;
	y1 = height /1.99;
	x2 = width;
	y2 = height /2;
	//line(x1, y1, x2, y2);

	shapel(x1, y1, x2, y2, 1, -1);
			*/	
				xmotion += 0;
				ymotion += 0.25;
}

void setup() {
  size(700, 700);

  background(0);
	
	//colorMode(HSB, 360, 256, 256);
	
	noiseDetail(7,0.65);
	
	frameRate(60);
	
	
		noFill();
		noStroke();

		rectMode(CENTER);
		ellipseMode(CENTER);

		stroke(0, 0, 255, 255);
		strokeWeight(2);
		strokeCap(ROUND);
		noFill();
		int nx = random(width / 2);
		int ny = random(height / 2);
		
		int lx = nx + random(width - nx);
		
		//line(0, height - 192, width, height - 192);
	  //line(0, height - 192 / 1.15, width, height - 192 / 1.15);
	  //line(0, height - 192 / 1.3, width, height - 192 / 1.3);
	  //line(2 * 92, height + (2 - 1.45 * 512), width / 2, height + (2 - 1.45 * 512));
	  //line(3 * 84, height - 512, width / 2 - 3 * 84, height - 512);
	  //bezier(3.1 * 84, height - 550, 400, 0, 0, 0, 0, height - 2 * 550);
	 // bezier(2.6 * 84, height - 512, 400, 0, 100, 0, -200, height - 2 * 512);
	 // bezier(2 * 84, height - 512, 400, 0, 100, 0, -200, height - 2 * 512);
	  //bezier(1.4 * 84, height - 512, 400, 0, 100, 0, -200, height - 2 * 512);
	  //line(4 * 92, height - 1.25 * 512, width / 2 - 4 * 92, height - 1.25 * 512);
	
	  
	  //rect(width / 2, height / 5, width / 5.5, width / 7);
	  //ellipse(width / 2, height / 5, width / 4, width / 7);
		
	  //line(2 * 92, height - 180, 64 + 2 * 148, height + (2 - 2 * 512));
	  //line(-92, height - 180, 64 + 48, height + (2 - 1 * 512));
	
	for (int i = 0; i < 3; i += 1) {
		//line(i * 92, height - 180, 64 + i * 148, height + (2 - i * 512));
		//line(64 + i * 92, 0, 64 + i * 92, (128 + i * 32));
		//line(64 + i * 92, 0, 256 + i * 92, (128 + i * 32));
	  //line(width / 3 - i * 128, height - 64, width / 3 - i * 128, height / 2 + height / 5);
	}
	//stroke(0, 0, 255, 92);
	
	//line(width / 2, height - 210, width / 2, height - 192);
	/*
	for (int i = 0; i < 8; i += 1) {
		ellipse(random(width / 8), random(height / 2, height / 1.6), 1, 1);
	}*/
	strokeWeight(2);
	//line(300, 64, 300, height / 6);
		//triangle(nx + random(width - nx), ny + random(height - ny), nx + random(width - nx), ny + random(height - ny), nx + random(width - nx), ny + random(height - ny));
		//ellipse(width / 2, height / 2, height / 2, height / 2);
	  //rect(width / 3, height / 2, width / 5, height / 2);
	  //rect(width - width / 3, height / 2, width / 5, height / 2);
		//rect(nx + random(width - nx), ny + random(height - ny), nx, ny);
		//bezier(random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height));
		//strokeWeight(1 + random(8));
		//bezier(random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height));

		rectMode(CORNER);
	
	//smooth();
}

void mouseClicked() {
	background(0);
	
	reset = frameCount;
	
	xmotion = 8.8;
	ymotion = 2.2;
}

void draw() {
  draw_func();
}"
"742694","Binarycoven","mySketch","// doing it by following lines instead of per pixels (note : mostly useless in that case but the result look nice)

float xmotion = 8.8;
float ymotion = 2.2;

int reset = 0;
int perlin_amount = 80;

float[] ppx = new float[800 * 800];
float[] ppy = new float[800 * 800];

// https://iquilezles.org/www/articles/palettes/palettes.htm
float pal(float t, float a, float b, float c, float d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

void shapel(float x1, float y1, float x2, float y2, float dirx, float diry) {
	float dx = x2 - x1;
	float dy = y2 - y1;
	
	float xx1 = x1;
	float xx2 = x2;
	if (x1 > x2) {
		xx1 = x2;
		xx2 = x1;
	}
	//noStroke();
	strokeWeight(1);
	for (float x = xx1; x < xx2; x += 1) {
		float norm_dst = abs(x - xx2) / abs(xx2);
		float anorm_dst = 1.0 - abs(0.5 - norm_dst) * 2;
		
		float y = y1 + dy * (x - x1) / dx;
		
		float ynorm = (y + ymotion * 1) / (float)height;
		
		float anorm_y = 1.0 - abs(0.5 - ynorm) * 2;
		
		float anorm_y2 = 1.0 - abs(0.5 - ynorm) * 2;
		
		float moda = cos(ynorm * PI * (anorm_dst * 64 + pow(ynorm, 4) * 320)) * (1 - ynorm);
		float modb = sin(anorm_dst * PI * 2 * ynorm + n2 * PI * 6) * (1 - ynorm);
		
		float mod = abs(moda % modb);
		
		//if (ynorm > 0.55) mod = (lerp(mod - anorm_dst, 0, (ynorm - 0.55) * 1.55));
		/*else*/ mod = (mod - anorm_dst) * (anorm_dst);
		
		float n2 = (0.5-noise(anorm_dst + xmotion / 16, anorm_y + ymotion / 16)) * 4 * anorm_y;
		float n = (0.5-noise(anorm_dst + xmotion / 64, anorm_y + ymotion / 64)) * 2 * ynorm * mod; //% (0.5-noise(anorm_dst + xmotion / 8 * anorm_y2, anorm_y2 + ymotion / 8)) * 2;
		
		float pa = 0.5 + abs(n * 2);
		float pb = 0.5 - abs(n / 2);
		float pc = 1;
		
		float pdr = 0.22;
		float pdg = 0.091;
		float pdb = 1;
		
		float rf = pal(anorm_y, pa, pb, pc, pdr) * 255;
		float gf = pal(anorm_y, pa, pb, pc, pdg) * 255;
		float bf = pal(anorm_y, pa, pb, pc, pdb) * 255;
		
		fill(rf, gf, bf, 92 * abs(n) * 48);
		stroke(rf / 2.5, gf / 2.5, bf / 2.5, 48 * abs(n) * 12);
		
		float s = 1.5 * abs(n2);
		
		if (dirx < 0 && diry < 0) {
			ellipse(x - n * 30 + cos(anorm_y * PI * 1) * 8, y - n * 80 - ymotion * 4 + cos(anorm_y * PI * 1) * 80 * ynorm, s, s);
		} else if (dirx > 0 && diry > 0) {
			ellipse(x + n * 30 + cos(anorm_y * PI * 1) * 8, y + n * 80 + ymotion * 4 + cos(anorm_y * PI * 1) * 80 * ynorm, s, s);
		} else if (dirx < 0 && diry > 0) {
			ellipse(x - n * 30 + cos(anorm_y * PI * 1) * 8, y + n * 80 + ymotion * 4 + cos(anorm_y * PI * 1) * 80 * ynorm, s, s);
		} else if (dirx > 0 && diry < 0) {
			ellipse(x + n * 30 + cos(anorm_y * PI * 1) * 8, y - n * 80 - ymotion * 4 + cos(anorm_y * PI * 1) * 80 * ynorm, s, s);
		}
		
		//stroke(rf, gf, bf, 16 * abs(n));
		//line(x - n * 40 - xmotion * 8, y - n * 40 + ymotion * 8, x + n * 40 - xmotion * 8, y + n * 40 + ymotion * 8);
	}
	
	stroke(0, 0, 255, 1);
}

void draw_func() {
	noStroke();
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	float x1 = -200;
	float y1 = -1;
	float x2 = width;
	float y2 = -1.1;
	
	stroke(0, 0, 255, 1);
	strokeWeight(1);
	//line(x1, y1, x2, y2);
	
	
	//shapel(x1, y1, x2, y2, 1, 1);
	shapel(x1, y1, x2, y2, -1, 1);
	
	x1 = -200;
	y1 = height;
	x2 = width;
	y2 = height-0.1;
	//line(x1, y1, x2, y2);

	//shapel(x1, y1, x2, y2, -1, -1);
	/*
	x1 = 0;
	y1 = height - height /1.99;
	x2 = width;
	y2 = height - height /2;
	//line(x1, y1, x2, y2);

	shapel(x1, y1, x2, y2, 1, -1);
	
	x1 = 0;
	y1 = height /1.99;
	x2 = width;
	y2 = height /2;
	//line(x1, y1, x2, y2);

	shapel(x1, y1, x2, y2, 1, -1);
			*/	
				xmotion += 0;
				ymotion += 0.25;
}

void setup() {
  size(800, 800);

  background(0);
	
	//colorMode(HSB, 360, 256, 256);
	
	noiseDetail(5,0.65);
	
	frameRate(60);
	
	
		noFill();
		noStroke();

		rectMode(CENTER);
		ellipseMode(CENTER);

		stroke(0, 0, 255, 255);
		strokeWeight(2);
		strokeCap(ROUND);
		noFill();
		int nx = random(width / 2);
		int ny = random(height / 2);
		
		int lx = nx + random(width - nx);
		
		//line(0, height - 192, width, height - 192);
	  //line(0, height - 192 / 1.15, width, height - 192 / 1.15);
	  //line(0, height - 192 / 1.3, width, height - 192 / 1.3);
	  //line(2 * 92, height + (2 - 1.45 * 512), width / 2, height + (2 - 1.45 * 512));
	  //line(3 * 84, height - 512, width / 2 - 3 * 84, height - 512);
	  //bezier(3.1 * 84, height - 550, 400, 0, 0, 0, 0, height - 2 * 550);
	 // bezier(2.6 * 84, height - 512, 400, 0, 100, 0, -200, height - 2 * 512);
	 // bezier(2 * 84, height - 512, 400, 0, 100, 0, -200, height - 2 * 512);
	  //bezier(1.4 * 84, height - 512, 400, 0, 100, 0, -200, height - 2 * 512);
	  //line(4 * 92, height - 1.25 * 512, width / 2 - 4 * 92, height - 1.25 * 512);
	
	  
	  //rect(width / 2, height / 5, width / 5.5, width / 7);
	  //ellipse(width / 2, height / 5, width / 4, width / 7);
		
	  //line(2 * 92, height - 180, 64 + 2 * 148, height + (2 - 2 * 512));
	  //line(-92, height - 180, 64 + 48, height + (2 - 1 * 512));
	
	for (int i = 0; i < 3; i += 1) {
		//line(i * 92, height - 180, 64 + i * 148, height + (2 - i * 512));
		//line(64 + i * 92, 0, 64 + i * 92, (128 + i * 32));
		//line(64 + i * 92, 0, 256 + i * 92, (128 + i * 32));
	  //line(width / 3 - i * 128, height - 64, width / 3 - i * 128, height / 2 + height / 5);
	}
	//stroke(0, 0, 255, 92);
	
	//line(width / 2, height - 210, width / 2, height - 192);
	/*
	for (int i = 0; i < 8; i += 1) {
		ellipse(random(width / 8), random(height / 2, height / 1.6), 1, 1);
	}*/
	strokeWeight(2);
	//line(300, 64, 300, height / 6);
		//triangle(nx + random(width - nx), ny + random(height - ny), nx + random(width - nx), ny + random(height - ny), nx + random(width - nx), ny + random(height - ny));
		//ellipse(width / 2, height / 2, height / 2, height / 2);
	  //rect(width / 3, height / 2, width / 5, height / 2);
	  //rect(width - width / 3, height / 2, width / 5, height / 2);
		//rect(nx + random(width - nx), ny + random(height - ny), nx, ny);
		//bezier(random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height));
		//strokeWeight(1 + random(8));
		//bezier(random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height));

		rectMode(CORNER);
	
	//smooth();
}

void mouseClicked() {
	background(0);
	
	reset = frameCount;
	
	xmotion = 8.8;
	ymotion = 2.2;
}

void draw() {
  draw_func();
}"
"742688","Foam","mySketch","// doing it by following lines instead of per pixels (note : mostly useless in that case but the result look nice)

float xmotion = 8.8;
float ymotion = 2.2;

int reset = 0;
int perlin_amount = 80;

float[] ppx = new float[800 * 800];
float[] ppy = new float[800 * 800];

// https://iquilezles.org/www/articles/palettes/palettes.htm
float pal(float t, float a, float b, float c, float d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

void shapel(float x1, float y1, float x2, float y2, float dirx, float diry) {
	float dx = x2 - x1;
	float dy = y2 - y1;
	
	float xx1 = x1;
	float xx2 = x2;
	if (x1 > x2) {
		xx1 = x2;
		xx2 = x1;
	}
	//noStroke();
	strokeWeight(1);
	for (float x = xx1; x < xx2; x += 1) {
		float norm_dst = abs(x - xx2) / abs(xx2);
		float anorm_dst = 1.0 - abs(0.5 - norm_dst) * 3;
		
		float y = y1 + dy * (x - x1) / dx;
		
		float ynorm = (y + ymotion * 2) / (float)height;
		
		float anorm_y = 1.0 - abs(0.5 - ynorm) * 2;
		
		float anorm_y2 = 1.0 - abs(0.5 - ynorm) * 8;
		
		//if (anorm_dst > -0.5 && anorm_dst < 0.5) anorm_dst = lerp(anorm_dst, anorm_dst * 2 * anorm_y, anorm_dst * 2);
		
		float moda = cos(ynorm * PI * 1.5 + n2 * PI * 8);
		float modb = sin(norm_dst * PI * 0.5 + n2 * PI * 4);
		
		float mod = abs(moda % modb);
		
		if (ynorm > 0.5) mod = (lerp(mod - norm_dst, anorm_y, (ynorm - 0.5) * 1.5));
		else mod = (mod - norm_dst);
		
		float n2 = (0.5-noise(anorm_dst + xmotion / 24 * anorm_y2, anorm_y2 + ymotion / 24)) * 2 / (1 + anorm_y * 32);
		float n = (0.5-noise(anorm_dst + xmotion / 32 * anorm_y2, anorm_y2 + ymotion / 32)) * 2 * ynorm * mod; //% (0.5-noise(anorm_dst + xmotion / 8 * anorm_y2, anorm_y2 + ymotion / 8)) * 2;
		
		float pa = 0.5 + abs(n / 2);
		float pb = 0.5 - abs(n / 2);
		float pc = 1;
		
		float pdr = 0.12;
		float pdg = 0.05;
		float pdb = 1;
		
		float rf = pal(ynorm, pa, pb, pc, pdr) * 255;
		float gf = pal(ynorm, pa, pb, pc, pdg) * 255;
		float bf = pal(ynorm, pa, pb, pc, pdb) * 255;
		
		fill(rf, gf, bf, 92 * abs(n) * 6);
		stroke(rf / 2.5, gf / 2.5, bf / 2.5, 48 * abs(n) * 6);
		
		float s = 34 * abs(n);
		
		if (dirx < 0 && diry < 0) {
			ellipse(x - n * 30 + cos(anorm_dst * PI * 3 + xmotion) * 4, y - n * 140 - ymotion * 4.5 + sin(anorm_dst * PI * 0.25 + xmotion) * 80 * anorm_dst * (1-ynorm), s, s);
		} else if (dirx > 0 && diry > 0) {
			ellipse(x + n * 30 + cos(anorm_dst * PI * 3 + xmotion) * 4, y + n * 140 + ymotion * 4.5 + sin(anorm_dst * PI * 0.25 + xmotion) * 80 * anorm_dst * (1-ynorm), s, s);
		} else if (dirx < 0 && diry > 0) {
			ellipse(x - n * 30 + cos(anorm_dst * PI * 3 + xmotion) * 4, y + n * 140 + ymotion * 4.5 + sin(anorm_dst * PI * 0.25 + xmotion) * 80 * anorm_dst * (1-ynorm), s, s);
		} else if (dirx > 0 && diry < 0) {
			ellipse(x + n * 30 + cos(anorm_dst * PI * 3 + xmotion) * 4, y - n * 140 - ymotion * 4.5 + sin(anorm_dst * PI * 0.25 + xmotion) * 80 * anorm_dst * (1-ynorm), s, s);
		}
		
		//stroke(rf, gf, bf, 16 * abs(n));
		//line(x - n * 40 - xmotion * 8, y - n * 40 + ymotion * 8, x + n * 40 - xmotion * 8, y + n * 40 + ymotion * 8);
	}
	
	stroke(0, 0, 255, 1);
}

void draw_func() {
	noStroke();
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	float x1 = -200;
	float y1 = 4;
	float x2 = width;
	float y2 = -4.1 + ymotion * 2;
	
	stroke(0, 0, 255, 1);
	//line(x1, y1, x2, y2);
	
	
	//shapel(x1, y1, x2, y2, 1, 1);
	shapel(x1, y1, x2, y2, -1, 1);
	
	x1 = -200;
	y1 = height;
	x2 = width;
	y2 = (height-0.1);
	//line(x1, y1, x2, y2);

	//shapel(x1, y1, x2, y2, -1, -1);
	/*
	x1 = 0;
	y1 = height - height /1.99;
	x2 = width;
	y2 = height - height /2;
	//line(x1, y1, x2, y2);

	shapel(x1, y1, x2, y2, 1, -1);
	
	x1 = 0;
	y1 = height /1.99;
	x2 = width;
	y2 = height /2;
	//line(x1, y1, x2, y2);

	shapel(x1, y1, x2, y2, 1, -1);
			*/	
				xmotion += 0;
				ymotion += 0.25;
}

void setup() {
  size(800, 800);

  background(0);
	
	//colorMode(HSB, 360, 256, 256);
	
	noiseDetail(7,0.65);
	
	frameRate(60);
	
	
		noFill();
		noStroke();

		rectMode(CENTER);
		ellipseMode(CENTER);

		stroke(0, 0, 255, 255);
		strokeWeight(2);
		strokeCap(ROUND);
		noFill();
		int nx = random(width / 2);
		int ny = random(height / 2);
		
		int lx = nx + random(width - nx);
		
		//line(0, height - 192, width, height - 192);
	  //line(0, height - 192 / 1.15, width, height - 192 / 1.15);
	  //line(0, height - 192 / 1.3, width, height - 192 / 1.3);
	  //line(2 * 92, height + (2 - 1.45 * 512), width / 2, height + (2 - 1.45 * 512));
	  //line(3 * 84, height - 512, width / 2 - 3 * 84, height - 512);
	  //bezier(3.1 * 84, height - 550, 400, 0, 0, 0, 0, height - 2 * 550);
	 // bezier(2.6 * 84, height - 512, 400, 0, 100, 0, -200, height - 2 * 512);
	 // bezier(2 * 84, height - 512, 400, 0, 100, 0, -200, height - 2 * 512);
	  //bezier(1.4 * 84, height - 512, 400, 0, 100, 0, -200, height - 2 * 512);
	  //line(4 * 92, height - 1.25 * 512, width / 2 - 4 * 92, height - 1.25 * 512);
	
	  
	  //rect(width / 2, height / 5, width / 5.5, width / 7);
	  //ellipse(width / 2, height / 5, width / 4, width / 7);
		
	  //line(2 * 92, height - 180, 64 + 2 * 148, height + (2 - 2 * 512));
	  //line(-92, height - 180, 64 + 48, height + (2 - 1 * 512));
	
	for (int i = 0; i < 3; i += 1) {
		//line(i * 92, height - 180, 64 + i * 148, height + (2 - i * 512));
		//line(64 + i * 92, 0, 64 + i * 92, (128 + i * 32));
		//line(64 + i * 92, 0, 256 + i * 92, (128 + i * 32));
	  //line(width / 3 - i * 128, height - 64, width / 3 - i * 128, height / 2 + height / 5);
	}
	//stroke(0, 0, 255, 92);
	
	//line(width / 2, height - 210, width / 2, height - 192);
	/*
	for (int i = 0; i < 8; i += 1) {
		ellipse(random(width / 8), random(height / 2, height / 1.6), 1, 1);
	}*/
	strokeWeight(2);
	//line(300, 64, 300, height / 6);
		//triangle(nx + random(width - nx), ny + random(height - ny), nx + random(width - nx), ny + random(height - ny), nx + random(width - nx), ny + random(height - ny));
		//ellipse(width / 2, height / 2, height / 2, height / 2);
	  //rect(width / 3, height / 2, width / 5, height / 2);
	  //rect(width - width / 3, height / 2, width / 5, height / 2);
		//rect(nx + random(width - nx), ny + random(height - ny), nx, ny);
		//bezier(random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height));
		//strokeWeight(1 + random(8));
		//bezier(random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height));

		rectMode(CORNER);
	
	//smooth();
}

void mouseClicked() {
	background(0);
	
	reset = frameCount;
	
	xmotion = 8.8;
	ymotion = 2.2;
}

void draw() {
  draw_func();
}"
"742669","On the edge","mySketch","// doing it by following lines instead of per pixels (note : mostly useless in that case but the result look nice)

float xmotion = 8.8;
float ymotion = 2.2;

int reset = 0;
int perlin_amount = 80;

float[] ppx = new float[800 * 800];
float[] ppy = new float[800 * 800];

// https://iquilezles.org/www/articles/palettes/palettes.htm
float pal(float t, float a, float b, float c, float d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

void shapel(float x1, float y1, float x2, float y2, float dirx, float diry) {
	float dx = x2 - x1;
	float dy = y2 - y1;
	
	float xx1 = x1;
	float xx2 = x2;
	if (x1 > x2) {
		xx1 = x2;
		xx2 = x1;
	}
	//noStroke();
	strokeWeight(1);
	for (float x = xx1; x < xx2; x += 1) {
		float norm_dst = abs(x - xx2) / abs(xx2);
		float anorm_dst = 1.0 - abs(0.5 - norm_dst) * 2;
		
		float y = y1 + dy * (x - x1) / dx;
		
		float ynorm = (y + ymotion * 2) / (float)height;
		
		float anorm_y = 1.0 - abs(0.5 - ynorm) * 2;
		
		float anorm_y2 = 1.0 - abs(0.5 - ynorm) * 8;
		
		float moda = cos(ynorm * PI * 1 + n2 * PI * 2);
		float modb = sin(n2 * PI * 0.1);
		
		float mod = abs(moda * modb);
		
		if (ynorm > 0.55) mod = (lerp(mod - anorm_dst, 4, (ynorm - 0.55) * 1.55));
		else mod = (mod - anorm_dst);
		
		float n2 = (0.5-noise(anorm_dst + xmotion / 128 * anorm_y2, anorm_y2 + ymotion / 128)) * 2 / (1 + anorm_y * 7);
		float n = (0.5-noise(anorm_dst + xmotion / 32 * anorm_y2, anorm_y2 + ymotion / 32)) * 2 * ynorm * mod; //% (0.5-noise(anorm_dst + xmotion / 8 * anorm_y2, anorm_y2 + ymotion / 8)) * 2;
		
		float pa = 0.5 + abs(n / 2);
		float pb = 0.5 - abs(n / 2);
		float pc = 0.75;
		
		float pdr = 0.2;
		float pdg = 0.1;
		float pdb = 1;
		
		float rf = pal(1 - ynorm, pa, pb, pc, pdr) * 255;
		float gf = pal((1 - ynorm) / 3, pa, pb, pc, pdg) * 255;
		float bf = pal((1 - ynorm) / 1.5, pa, pb, pc, pdb) * 255;
		
		fill(rf, gf, bf, 92 * abs(n) * 2);
		stroke(rf / 2.5, gf / 2.5, bf / 2.5, 48 * abs(n) * 4);
		
		float s = 18 * abs(n);
		
		if (dirx < 0 && diry < 0) {
			ellipse(x - n * 30 + cos(anorm_y * PI * 1) * 8, y - n * 100 - ymotion * 3.5, s, s);
		} else if (dirx > 0 && diry > 0) {
			ellipse(x + n * 30 + cos(anorm_y * PI * 1) * 8, y + n * 100 + ymotion * 3.5, s, s);
		} else if (dirx < 0 && diry > 0) {
			ellipse(x - n * 30 + cos(anorm_y * PI * 1) * 8, y + n * 100 + ymotion * 3.5, s, s);
		} else if (dirx > 0 && diry < 0) {
			ellipse(x + n * 30 + cos(anorm_y * PI * 1) * 8, y - n * 100 - ymotion * 3.5, s, s);
		}
		
		//stroke(rf, gf, bf, 16 * abs(n));
		//line(x - n * 40 - xmotion * 8, y - n * 40 + ymotion * 8, x + n * 40 - xmotion * 8, y + n * 40 + ymotion * 8);
	}
	
	stroke(0, 0, 255, 1);
}

void draw_func() {
	noStroke();
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	float x1 = -200;
	float y1 = -10;
	float x2 = width;
	float y2 = -10.1;
	
	stroke(0, 0, 255, 1);
	strokeWeight(1);
	//line(x1, y1, x2, y2);
	
	
	//shapel(x1, y1, x2, y2, 1, 1);
	shapel(x1, y1, x2, y2, -1, 1);
	
	x1 = -200;
	y1 = height / 8;
	x2 = width;
	y2 = (height-0.1) / 8;
	//line(x1, y1, x2, y2);

	//shapel(x1, y1, x2, y2, -1, -1);
	/*
	x1 = 0;
	y1 = height - height /1.99;
	x2 = width;
	y2 = height - height /2;
	//line(x1, y1, x2, y2);

	shapel(x1, y1, x2, y2, 1, -1);
	
	x1 = 0;
	y1 = height /1.99;
	x2 = width;
	y2 = height /2;
	//line(x1, y1, x2, y2);

	shapel(x1, y1, x2, y2, 1, -1);
			*/	
				xmotion += 0;
				ymotion += 0.25;
}

void setup() {
  size(800, 800);

  background(0);
	
	//colorMode(HSB, 360, 256, 256);
	
	noiseDetail(5,0.65);
	
	frameRate(60);
	
	
		noFill();
		noStroke();

		rectMode(CENTER);
		ellipseMode(CENTER);

		stroke(0, 0, 255, 255);
		strokeWeight(2);
		strokeCap(ROUND);
		noFill();
		int nx = random(width / 2);
		int ny = random(height / 2);
		
		int lx = nx + random(width - nx);
		
		//line(0, height - 192, width, height - 192);
	  //line(0, height - 192 / 1.15, width, height - 192 / 1.15);
	  //line(0, height - 192 / 1.3, width, height - 192 / 1.3);
	  //line(2 * 92, height + (2 - 1.45 * 512), width / 2, height + (2 - 1.45 * 512));
	  //line(3 * 84, height - 512, width / 2 - 3 * 84, height - 512);
	  //bezier(3.1 * 84, height - 550, 400, 0, 0, 0, 0, height - 2 * 550);
	 // bezier(2.6 * 84, height - 512, 400, 0, 100, 0, -200, height - 2 * 512);
	 // bezier(2 * 84, height - 512, 400, 0, 100, 0, -200, height - 2 * 512);
	  //bezier(1.4 * 84, height - 512, 400, 0, 100, 0, -200, height - 2 * 512);
	  //line(4 * 92, height - 1.25 * 512, width / 2 - 4 * 92, height - 1.25 * 512);
	
	  
	  //rect(width / 2, height / 5, width / 5.5, width / 7);
	  //ellipse(width / 2, height / 5, width / 4, width / 7);
		
	  //line(2 * 92, height - 180, 64 + 2 * 148, height + (2 - 2 * 512));
	  //line(-92, height - 180, 64 + 48, height + (2 - 1 * 512));
	
	for (int i = 0; i < 3; i += 1) {
		//line(i * 92, height - 180, 64 + i * 148, height + (2 - i * 512));
		//line(64 + i * 92, 0, 64 + i * 92, (128 + i * 32));
		//line(64 + i * 92, 0, 256 + i * 92, (128 + i * 32));
	  //line(width / 3 - i * 128, height - 64, width / 3 - i * 128, height / 2 + height / 5);
	}
	//stroke(0, 0, 255, 92);
	
	//line(width / 2, height - 210, width / 2, height - 192);
	/*
	for (int i = 0; i < 8; i += 1) {
		ellipse(random(width / 8), random(height / 2, height / 1.6), 1, 1);
	}*/
	strokeWeight(2);
	//line(300, 64, 300, height / 6);
		//triangle(nx + random(width - nx), ny + random(height - ny), nx + random(width - nx), ny + random(height - ny), nx + random(width - nx), ny + random(height - ny));
		//ellipse(width / 2, height / 2, height / 2, height / 2);
	  //rect(width / 3, height / 2, width / 5, height / 2);
	  //rect(width - width / 3, height / 2, width / 5, height / 2);
		//rect(nx + random(width - nx), ny + random(height - ny), nx, ny);
		//bezier(random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height));
		//strokeWeight(1 + random(8));
		//bezier(random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height));

		rectMode(CORNER);
	
	//smooth();
}

void mouseClicked() {
	background(0);
	
	reset = frameCount;
	
	xmotion = 8.8;
	ymotion = 2.2;
}

void draw() {
  draw_func();
}"
"742435","Jeux d'eau","mySketch","// doing it by following lines instead of per pixels (note : mostly useless in that case but the result look nice)

float xmotion = 8.8;
float ymotion = 2.2;

int reset = 0;
int perlin_amount = 80;

float[] ppx = new float[800 * 800];
float[] ppy = new float[800 * 800];

// https://iquilezles.org/www/articles/palettes/palettes.htm
float pal(float t, float a, float b, float c, float d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

void shapel(float x1, float y1, float x2, float y2, float dirx, float diry) {
	float dx = x2 - x1;
	float dy = y2 - y1;
	
	float xx1 = x1;
	float xx2 = x2;
	if (x1 > x2) {
		xx1 = x2;
		xx2 = x1;
	}
	//noStroke();
	strokeWeight(1);
	for (float x = xx1; x < xx2; x += 1) {
		float y = y1 + dy * (x - x1) / dx;
		
		float ynorm = (y + ymotion * 4.25) / (float)height;
		
		float norm_dst = abs(x - xx2) / abs(xx2);
		float anorm_dst = 1.0 - abs(0.5 - norm_dst) * 2;
		
		float anorm_y = 1.0 - abs(0.5 - ynorm) * 2;
		
		float anorm_y2 = 1.0 - abs(0.5 - ynorm) * 8;
		
		float n = (0.5-noise(anorm_dst + xmotion / (8 + anorm_y * 48), anorm_y2 + ymotion / 8)) * 2 * anorm_y;
		
		float pa = 0.5;
		float pb = 0.5;
		float pc = 0.75;
		
		float pdr = 0.4;
		float pdg = 0.1;
		float pdb = 0.1;
		
		float rf = pal(anorm_y * n, pa, pb, pc, pdr) * 255;
		float gf = pal(anorm_y / 2 * n, pa, pb, pc, pdg) * 255;
		float bf = pal(anorm_y / 1.5 * n, pa, pb, pc, pdb) * 255;
		
		fill(rf, gf, bf, 48 * abs(n) * anorm_y);
		stroke(rf / 1.5, gf / 1.5, bf / 1.5, 48 * abs(n));
		
		float s = 12 * (1+n);
		
		if (dirx < 0 && diry < 0) {
			ellipse(x - n * 100 + cos(anorm_y * PI * 1 + n) * 40 * anorm_y, y - n * 10 - ymotion * 4.5, s * abs(n), s * abs(n));
		} else if (dirx > 0 && diry > 0) {
			ellipse(x + n * 100 + cos(anorm_y * PI * 1 + n) * 40 * anorm_y, y + n * 10 + ymotion * 4.5, s * abs(n), s * abs(n));
		} else if (dirx < 0 && diry > 0) {
			ellipse(x - n * 100 + cos(anorm_y * PI * 1 + n) * 40 * anorm_y, y + n * 10 + ymotion * 4.5, s * abs(n), s * abs(n));
		} else if (dirx > 0 && diry < 0) {
			ellipse(x + n * 100 + cos(anorm_y * PI * 1 + n) * 40 * anorm_y, y - n * 10 - ymotion * 4.5, s * abs(n), s * abs(n));
		}
		
		//stroke(rf, gf, bf, 16 * abs(n));
		//line(x - n * 40 - xmotion * 8, y - n * 40 + ymotion * 8, x + n * 40 - xmotion * 8, y + n * 40 + ymotion * 8);
	}
	
	stroke(0, 0, 255, 1);
}

void draw_func() {
	noStroke();
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	float x1 = -100;
	float y1 = -100;
	float x2 = width;
	float y2 = -200.1;
	
	stroke(0, 0, 255, 1);
	strokeWeight(1);
	//line(x1, y1, x2, y2);
	
	
	//shapel(x1, y1, x2, y2, 1, 1);
	shapel(x1, y1, x2, y2, -1, 1);
	
	x1 = 0;
	y1 = height;
	x2 = width;
	y2 = height-0.1;
	//line(x1, y1, x2, y2);

	//shapel(x1, y1, x2, y2, -1, -1);
	/*
	x1 = 0;
	y1 = height - height /1.99;
	x2 = width;
	y2 = height - height /2;
	//line(x1, y1, x2, y2);

	shapel(x1, y1, x2, y2, 1, -1);
	
	x1 = 0;
	y1 = height /1.99;
	x2 = width;
	y2 = height /2;
	//line(x1, y1, x2, y2);

	shapel(x1, y1, x2, y2, 1, -1);
			*/	
				xmotion += 0;
				ymotion += 0.25;
}

void setup() {
  size(800, 800);

  background(0);
	
	//colorMode(HSB, 360, 256, 256);
	
	noiseDetail(5,0.65);
	
	frameRate(60);
	
	
		noFill();
		noStroke();

		rectMode(CENTER);
		ellipseMode(CENTER);

		stroke(0, 0, 255, 255);
		strokeWeight(2);
		strokeCap(ROUND);
		noFill();
		int nx = random(width / 2);
		int ny = random(height / 2);
		
		int lx = nx + random(width - nx);
		
		//line(0, height - 192, width, height - 192);
	  //line(0, height - 192 / 1.15, width, height - 192 / 1.15);
	  //line(0, height - 192 / 1.3, width, height - 192 / 1.3);
	  //line(2 * 92, height + (2 - 1.45 * 512), width / 2, height + (2 - 1.45 * 512));
	  //line(3 * 84, height - 512, width / 2 - 3 * 84, height - 512);
	  //bezier(3.1 * 84, height - 550, 400, 0, 0, 0, 0, height - 2 * 550);
	 // bezier(2.6 * 84, height - 512, 400, 0, 100, 0, -200, height - 2 * 512);
	 // bezier(2 * 84, height - 512, 400, 0, 100, 0, -200, height - 2 * 512);
	  //bezier(1.4 * 84, height - 512, 400, 0, 100, 0, -200, height - 2 * 512);
	  //line(4 * 92, height - 1.25 * 512, width / 2 - 4 * 92, height - 1.25 * 512);
	
	  
	  //rect(width / 2, height / 5, width / 5.5, width / 7);
	  //ellipse(width / 2, height / 5, width / 4, width / 7);
		
	  //line(2 * 92, height - 180, 64 + 2 * 148, height + (2 - 2 * 512));
	  //line(-92, height - 180, 64 + 48, height + (2 - 1 * 512));
	
	for (int i = 0; i < 3; i += 1) {
		//line(i * 92, height - 180, 64 + i * 148, height + (2 - i * 512));
		//line(64 + i * 92, 0, 64 + i * 92, (128 + i * 32));
		//line(64 + i * 92, 0, 256 + i * 92, (128 + i * 32));
	  //line(width / 3 - i * 128, height - 64, width / 3 - i * 128, height / 2 + height / 5);
	}
	//stroke(0, 0, 255, 92);
	
	//line(width / 2, height - 210, width / 2, height - 192);
	/*
	for (int i = 0; i < 8; i += 1) {
		ellipse(random(width / 8), random(height / 2, height / 1.6), 1, 1);
	}*/
	strokeWeight(2);
	//line(300, 64, 300, height / 6);
		//triangle(nx + random(width - nx), ny + random(height - ny), nx + random(width - nx), ny + random(height - ny), nx + random(width - nx), ny + random(height - ny));
		//ellipse(width / 2, height / 2, height / 2, height / 2);
	  //rect(width / 3, height / 2, width / 5, height / 2);
	  //rect(width - width / 3, height / 2, width / 5, height / 2);
		//rect(nx + random(width - nx), ny + random(height - ny), nx, ny);
		//bezier(random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height));
		//strokeWeight(1 + random(8));
		//bezier(random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height));

		rectMode(CORNER);
	
	//smooth();
}

void mouseClicked() {
	background(0);
	
	reset = frameCount;
	
	xmotion = 8.8;
	ymotion = 2.2;
}

void draw() {
  draw_func();
}"
"742434","Descent","mySketch","// doing it by following lines instead of per pixels (note : mostly useless in that case but the result look nice)

float xmotion = 8.8;
float ymotion = 2.2;

int reset = 0;
int perlin_amount = 80;

float[] ppx = new float[800 * 800];
float[] ppy = new float[800 * 800];

// https://iquilezles.org/www/articles/palettes/palettes.htm
float pal(float t, float a, float b, float c, float d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

void shapel(float x1, float y1, float x2, float y2, float dirx, float diry) {
	float dx = x2 - x1;
	float dy = y2 - y1;
	
	float xx1 = x1;
	float xx2 = x2;
	if (x1 > x2) {
		xx1 = x2;
		xx2 = x1;
	}
	//noStroke();
	strokeWeight(1);
	for (float x = xx1; x < xx2; x += 1) {
		float norm_dst = abs(x - xx2) / abs(xx2);
		float anorm_dst = 1.0 - abs(0.5 - norm_dst) * 2;
		
		float y = y1 + dy * (x - x1) / dx;
		
		float ynorm = (y + ymotion * 4) / (float)height;
		
		float anorm_y = 1.0 - abs(0.5 - ynorm) * 2;
		
		float anorm_y2 = 1.0 - abs(0.5 - ynorm) * 8;
		
		float n = (0.5-noise(anorm_dst + xmotion / 32 * anorm_y2, anorm_y2 + ymotion / 32)) * 2 * ynorm * anorm_dst;
		
		float pa = 0.5;
		float pb = 0.5;
		float pc = 0.75;
		
		float pdr = 0.2;
		float pdg = 0.1;
		float pdb = 1;
		
		float rf = pal(anorm_y, pa, pb, pc, pdr) * 255;
		float gf = pal(anorm_y / 3, pa, pb, pc, pdg) * 255;
		float bf = pal(anorm_y / 1.5, pa, pb, pc, pdb) * 255;
		
		fill(rf, gf, bf, 92 * abs(n) * anorm_y);
		stroke(rf / 2.5, gf / 2.5, bf / 2.5, 48 * abs(n));
		
		float s = 12 * (1+n);
		
		if (dirx < 0 && diry < 0) {
			ellipse(x - n * 100 + cos(anorm_y * PI * 1) * 8, y - n * 100 - ymotion * 3.5, s * abs(n), s * abs(n));
		} else if (dirx > 0 && diry > 0) {
			ellipse(x + n * 100 + cos(anorm_y * PI * 1) * 8, y + n * 100 + ymotion * 3.5, s * abs(n), s * abs(n));
		} else if (dirx < 0 && diry > 0) {
			ellipse(x - n * 100 + cos(anorm_y * PI * 1) * 8, y + n * 100 + ymotion * 3.5, s * abs(n), s * abs(n));
		} else if (dirx > 0 && diry < 0) {
			ellipse(x + n * 100 + cos(anorm_y * PI * 1) * 8, y - n * 100 - ymotion * 3.5, s * abs(n), s * abs(n));
		}
		
		//stroke(rf, gf, bf, 16 * abs(n));
		//line(x - n * 40 - xmotion * 8, y - n * 40 + ymotion * 8, x + n * 40 - xmotion * 8, y + n * 40 + ymotion * 8);
	}
	
	stroke(0, 0, 255, 1);
}

void draw_func() {
	noStroke();
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	float x1 = 0;
	float y1 = -100;
	float x2 = width;
	float y2 = -200.1;
	
	stroke(0, 0, 255, 1);
	strokeWeight(1);
	//line(x1, y1, x2, y2);
	
	
	//shapel(x1, y1, x2, y2, 1, 1);
	shapel(x1, y1, x2, y2, -1, 1);
	
	x1 = 0;
	y1 = height;
	x2 = width;
	y2 = height-0.1;
	//line(x1, y1, x2, y2);

	//shapel(x1, y1, x2, y2, -1, -1);
	/*
	x1 = 0;
	y1 = height - height /1.99;
	x2 = width;
	y2 = height - height /2;
	//line(x1, y1, x2, y2);

	shapel(x1, y1, x2, y2, 1, -1);
	
	x1 = 0;
	y1 = height /1.99;
	x2 = width;
	y2 = height /2;
	//line(x1, y1, x2, y2);

	shapel(x1, y1, x2, y2, 1, -1);
			*/	
				xmotion += 0;
				ymotion += 0.25;
}

void setup() {
  size(800, 800);

  background(0);
	
	//colorMode(HSB, 360, 256, 256);
	
	noiseDetail(5,0.65);
	
	frameRate(60);
	
	
		noFill();
		noStroke();

		rectMode(CENTER);
		ellipseMode(CENTER);

		stroke(0, 0, 255, 255);
		strokeWeight(2);
		strokeCap(ROUND);
		noFill();
		int nx = random(width / 2);
		int ny = random(height / 2);
		
		int lx = nx + random(width - nx);
		
		//line(0, height - 192, width, height - 192);
	  //line(0, height - 192 / 1.15, width, height - 192 / 1.15);
	  //line(0, height - 192 / 1.3, width, height - 192 / 1.3);
	  //line(2 * 92, height + (2 - 1.45 * 512), width / 2, height + (2 - 1.45 * 512));
	  //line(3 * 84, height - 512, width / 2 - 3 * 84, height - 512);
	  //bezier(3.1 * 84, height - 550, 400, 0, 0, 0, 0, height - 2 * 550);
	 // bezier(2.6 * 84, height - 512, 400, 0, 100, 0, -200, height - 2 * 512);
	 // bezier(2 * 84, height - 512, 400, 0, 100, 0, -200, height - 2 * 512);
	  //bezier(1.4 * 84, height - 512, 400, 0, 100, 0, -200, height - 2 * 512);
	  //line(4 * 92, height - 1.25 * 512, width / 2 - 4 * 92, height - 1.25 * 512);
	
	  
	  //rect(width / 2, height / 5, width / 5.5, width / 7);
	  //ellipse(width / 2, height / 5, width / 4, width / 7);
		
	  //line(2 * 92, height - 180, 64 + 2 * 148, height + (2 - 2 * 512));
	  //line(-92, height - 180, 64 + 48, height + (2 - 1 * 512));
	
	for (int i = 0; i < 3; i += 1) {
		//line(i * 92, height - 180, 64 + i * 148, height + (2 - i * 512));
		//line(64 + i * 92, 0, 64 + i * 92, (128 + i * 32));
		//line(64 + i * 92, 0, 256 + i * 92, (128 + i * 32));
	  //line(width / 3 - i * 128, height - 64, width / 3 - i * 128, height / 2 + height / 5);
	}
	//stroke(0, 0, 255, 92);
	
	//line(width / 2, height - 210, width / 2, height - 192);
	/*
	for (int i = 0; i < 8; i += 1) {
		ellipse(random(width / 8), random(height / 2, height / 1.6), 1, 1);
	}*/
	strokeWeight(2);
	//line(300, 64, 300, height / 6);
		//triangle(nx + random(width - nx), ny + random(height - ny), nx + random(width - nx), ny + random(height - ny), nx + random(width - nx), ny + random(height - ny));
		//ellipse(width / 2, height / 2, height / 2, height / 2);
	  //rect(width / 3, height / 2, width / 5, height / 2);
	  //rect(width - width / 3, height / 2, width / 5, height / 2);
		//rect(nx + random(width - nx), ny + random(height - ny), nx, ny);
		//bezier(random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height));
		//strokeWeight(1 + random(8));
		//bezier(random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height));

		rectMode(CORNER);
	
	//smooth();
}

void mouseClicked() {
	background(0);
	
	reset = frameCount;
	
	perlin_amount = random(40, 80);
}

void draw() {
  draw_func();
}"
"742434","Descent","mySketch","// doing it by following lines instead of per pixels (note : mostly useless in that case but the result look nice)

float xmotion = 8.8;
float ymotion = 2.2;

int reset = 0;
int perlin_amount = 80;

float[] ppx = new float[800 * 800];
float[] ppy = new float[800 * 800];

// https://iquilezles.org/www/articles/palettes/palettes.htm
float pal(float t, float a, float b, float c, float d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

void shapel(float x1, float y1, float x2, float y2, float dirx, float diry) {
	float dx = x2 - x1;
	float dy = y2 - y1;
	
	float xx1 = x1;
	float xx2 = x2;
	if (x1 > x2) {
		xx1 = x2;
		xx2 = x1;
	}
	//noStroke();
	strokeWeight(1);
	for (float x = xx1; x < xx2; x += 1) {
		float norm_dst = abs(x - xx2) / abs(xx2);
		float anorm_dst = 1.0 - abs(0.5 - norm_dst) * 2;
		
		float y = y1 + dy * (x - x1) / dx;
		
		float ynorm = (y + ymotion * 4) / (float)height;
		
		float anorm_y = 1.0 - abs(0.5 - ynorm) * 2;
		
		float anorm_y2 = 1.0 - abs(0.5 - ynorm) * 8;
		
		float n = (0.5-noise(anorm_dst + xmotion / 32 * anorm_y2, anorm_y2 + ymotion / 32)) * 2 * ynorm * anorm_dst;
		
		float pa = 0.5;
		float pb = 0.5;
		float pc = 0.75;
		
		float pdr = 0.2;
		float pdg = 0.1;
		float pdb = 1;
		
		float rf = pal(anorm_y, pa, pb, pc, pdr) * 255;
		float gf = pal(anorm_y / 3, pa, pb, pc, pdg) * 255;
		float bf = pal(anorm_y / 1.5, pa, pb, pc, pdb) * 255;
		
		fill(rf, gf, bf, 92 * abs(n) * anorm_y);
		stroke(rf / 2.5, gf / 2.5, bf / 2.5, 48 * abs(n));
		
		float s = 12 * (1+n);
		
		if (dirx < 0 && diry < 0) {
			ellipse(x - n * 100 + cos(anorm_y * PI * 1) * 8, y - n * 100 - ymotion * 3.5, s * abs(n), s * abs(n));
		} else if (dirx > 0 && diry > 0) {
			ellipse(x + n * 100 + cos(anorm_y * PI * 1) * 8, y + n * 100 + ymotion * 3.5, s * abs(n), s * abs(n));
		} else if (dirx < 0 && diry > 0) {
			ellipse(x - n * 100 + cos(anorm_y * PI * 1) * 8, y + n * 100 + ymotion * 3.5, s * abs(n), s * abs(n));
		} else if (dirx > 0 && diry < 0) {
			ellipse(x + n * 100 + cos(anorm_y * PI * 1) * 8, y - n * 100 - ymotion * 3.5, s * abs(n), s * abs(n));
		}
		
		//stroke(rf, gf, bf, 16 * abs(n));
		//line(x - n * 40 - xmotion * 8, y - n * 40 + ymotion * 8, x + n * 40 - xmotion * 8, y + n * 40 + ymotion * 8);
	}
	
	stroke(0, 0, 255, 1);
}

void draw_func() {
	noStroke();
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	float x1 = 0;
	float y1 = -100;
	float x2 = width;
	float y2 = -200.1;
	
	stroke(0, 0, 255, 1);
	strokeWeight(1);
	//line(x1, y1, x2, y2);
	
	
	//shapel(x1, y1, x2, y2, 1, 1);
	shapel(x1, y1, x2, y2, -1, 1);
	
	x1 = 0;
	y1 = height;
	x2 = width;
	y2 = height-0.1;
	//line(x1, y1, x2, y2);

	//shapel(x1, y1, x2, y2, -1, -1);
	/*
	x1 = 0;
	y1 = height - height /1.99;
	x2 = width;
	y2 = height - height /2;
	//line(x1, y1, x2, y2);

	shapel(x1, y1, x2, y2, 1, -1);
	
	x1 = 0;
	y1 = height /1.99;
	x2 = width;
	y2 = height /2;
	//line(x1, y1, x2, y2);

	shapel(x1, y1, x2, y2, 1, -1);
			*/	
				xmotion += 0;
				ymotion += 0.25;
}

void setup() {
  size(800, 800);

  background(0);
	
	//colorMode(HSB, 360, 256, 256);
	
	noiseDetail(5,0.65);
	
	frameRate(60);
	
	
		noFill();
		noStroke();

		rectMode(CENTER);
		ellipseMode(CENTER);

		stroke(0, 0, 255, 255);
		strokeWeight(2);
		strokeCap(ROUND);
		noFill();
		int nx = random(width / 2);
		int ny = random(height / 2);
		
		int lx = nx + random(width - nx);
		
		//line(0, height - 192, width, height - 192);
	  //line(0, height - 192 / 1.15, width, height - 192 / 1.15);
	  //line(0, height - 192 / 1.3, width, height - 192 / 1.3);
	  //line(2 * 92, height + (2 - 1.45 * 512), width / 2, height + (2 - 1.45 * 512));
	  //line(3 * 84, height - 512, width / 2 - 3 * 84, height - 512);
	  //bezier(3.1 * 84, height - 550, 400, 0, 0, 0, 0, height - 2 * 550);
	 // bezier(2.6 * 84, height - 512, 400, 0, 100, 0, -200, height - 2 * 512);
	 // bezier(2 * 84, height - 512, 400, 0, 100, 0, -200, height - 2 * 512);
	  //bezier(1.4 * 84, height - 512, 400, 0, 100, 0, -200, height - 2 * 512);
	  //line(4 * 92, height - 1.25 * 512, width / 2 - 4 * 92, height - 1.25 * 512);
	
	  
	  //rect(width / 2, height / 5, width / 5.5, width / 7);
	  //ellipse(width / 2, height / 5, width / 4, width / 7);
		
	  //line(2 * 92, height - 180, 64 + 2 * 148, height + (2 - 2 * 512));
	  //line(-92, height - 180, 64 + 48, height + (2 - 1 * 512));
	
	for (int i = 0; i < 3; i += 1) {
		//line(i * 92, height - 180, 64 + i * 148, height + (2 - i * 512));
		//line(64 + i * 92, 0, 64 + i * 92, (128 + i * 32));
		//line(64 + i * 92, 0, 256 + i * 92, (128 + i * 32));
	  //line(width / 3 - i * 128, height - 64, width / 3 - i * 128, height / 2 + height / 5);
	}
	//stroke(0, 0, 255, 92);
	
	//line(width / 2, height - 210, width / 2, height - 192);
	/*
	for (int i = 0; i < 8; i += 1) {
		ellipse(random(width / 8), random(height / 2, height / 1.6), 1, 1);
	}*/
	strokeWeight(2);
	//line(300, 64, 300, height / 6);
		//triangle(nx + random(width - nx), ny + random(height - ny), nx + random(width - nx), ny + random(height - ny), nx + random(width - nx), ny + random(height - ny));
		//ellipse(width / 2, height / 2, height / 2, height / 2);
	  //rect(width / 3, height / 2, width / 5, height / 2);
	  //rect(width - width / 3, height / 2, width / 5, height / 2);
		//rect(nx + random(width - nx), ny + random(height - ny), nx, ny);
		//bezier(random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height));
		//strokeWeight(1 + random(8));
		//bezier(random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height));

		rectMode(CORNER);
	
	//smooth();
}

void mouseClicked() {
	background(0);
	
	reset = frameCount;
	
	xmotion = 8.8;
	ymotion = 2.2;
}

void draw() {
  draw_func();
}"
"742434","Descent","mySketch","// doing it by following lines instead of per pixels (note : mostly useless in that case but the result look nice)

float xmotion = 8.8;
float ymotion = 2.2;

int reset = 0;
int perlin_amount = 80;

float[] ppx = new float[800 * 800];
float[] ppy = new float[800 * 800];

// https://iquilezles.org/www/articles/palettes/palettes.htm
float pal(float t, float a, float b, float c, float d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

void shapel(float x1, float y1, float x2, float y2, float dirx, float diry) {
	float dx = x2 - x1;
	float dy = y2 - y1;
	
	float xx1 = x1;
	float xx2 = x2;
	if (x1 > x2) {
		xx1 = x2;
		xx2 = x1;
	}
	//noStroke();
	strokeWeight(1);
	for (float x = xx1; x < xx2; x += 1) {
		float norm_dst = abs(x - xx2) / abs(xx2);
		float anorm_dst = 1.0 - abs(0.5 - norm_dst) * 2;
		
		float y = y1 + dy * (x - x1) / dx;
		
		float ynorm = (y + ymotion * 4) / (float)height;
		
		float anorm_y = 1.0 - abs(0.5 - ynorm) * 2;
		
		float anorm_y2 = 1.0 - abs(0.5 - ynorm) * 8;
		
		float n = (0.5-noise(anorm_dst + xmotion / 32 * anorm_y2, anorm_y2 + ymotion / 32)) * 2 * ynorm * anorm_dst;
		
		float pa = 0.5;
		float pb = 0.5;
		float pc = 0.75;
		
		float pdr = 0.2;
		float pdg = 0.1;
		float pdb = 1;
		
		float rf = pal(anorm_y, pa, pb, pc, pdr) * 255;
		float gf = pal(anorm_y / 3, pa, pb, pc, pdg) * 255;
		float bf = pal(anorm_y / 1.5, pa, pb, pc, pdb) * 255;
		
		fill(rf, gf, bf, 92 * abs(n) * anorm_y);
		stroke(rf / 2.5, gf / 2.5, bf / 2.5, 48 * abs(n));
		
		float s = 12 * (1+n);
		
		if (dirx < 0 && diry < 0) {
			ellipse(x - n * 100 + cos(anorm_y * PI * 1) * 8, y - n * 100 - ymotion * 3.5, s * abs(n), s * abs(n));
		} else if (dirx > 0 && diry > 0) {
			ellipse(x + n * 100 + cos(anorm_y * PI * 1) * 8, y + n * 100 + ymotion * 3.5, s * abs(n), s * abs(n));
		} else if (dirx < 0 && diry > 0) {
			ellipse(x - n * 100 + cos(anorm_y * PI * 1) * 8, y + n * 100 + ymotion * 3.5, s * abs(n), s * abs(n));
		} else if (dirx > 0 && diry < 0) {
			ellipse(x + n * 100 + cos(anorm_y * PI * 1) * 8, y - n * 100 - ymotion * 3.5, s * abs(n), s * abs(n));
		}
		
		//stroke(rf, gf, bf, 16 * abs(n));
		//line(x - n * 40 - xmotion * 8, y - n * 40 + ymotion * 8, x + n * 40 - xmotion * 8, y + n * 40 + ymotion * 8);
	}
	
	stroke(0, 0, 255, 1);
}

void draw_func() {
	noStroke();
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	float x1 = 0;
	float y1 = -100;
	float x2 = width;
	float y2 = -200.1;
	
	stroke(0, 0, 255, 1);
	strokeWeight(1);
	//line(x1, y1, x2, y2);
	
	
	//shapel(x1, y1, x2, y2, 1, 1);
	shapel(x1, y1, x2, y2, -1, 1);
	
	x1 = 0;
	y1 = height;
	x2 = width;
	y2 = height-0.1;
	//line(x1, y1, x2, y2);

	//shapel(x1, y1, x2, y2, -1, -1);
	/*
	x1 = 0;
	y1 = height - height /1.99;
	x2 = width;
	y2 = height - height /2;
	//line(x1, y1, x2, y2);

	shapel(x1, y1, x2, y2, 1, -1);
	
	x1 = 0;
	y1 = height /1.99;
	x2 = width;
	y2 = height /2;
	//line(x1, y1, x2, y2);

	shapel(x1, y1, x2, y2, 1, -1);
			*/	
				xmotion += 0;
				ymotion += 0.25;
}

void setup() {
  size(800, 800);

  background(0);
	
	//colorMode(HSB, 360, 256, 256);
	
	noiseDetail(5,0.65);
	
	frameRate(60);
	
	
		noFill();
		noStroke();

		rectMode(CENTER);
		ellipseMode(CENTER);

		stroke(0, 0, 255, 255);
		strokeWeight(2);
		strokeCap(ROUND);
		noFill();
		int nx = random(width / 2);
		int ny = random(height / 2);
		
		int lx = nx + random(width - nx);
		
		//line(0, height - 192, width, height - 192);
	  //line(0, height - 192 / 1.15, width, height - 192 / 1.15);
	  //line(0, height - 192 / 1.3, width, height - 192 / 1.3);
	  //line(2 * 92, height + (2 - 1.45 * 512), width / 2, height + (2 - 1.45 * 512));
	  //line(3 * 84, height - 512, width / 2 - 3 * 84, height - 512);
	  //bezier(3.1 * 84, height - 550, 400, 0, 0, 0, 0, height - 2 * 550);
	 // bezier(2.6 * 84, height - 512, 400, 0, 100, 0, -200, height - 2 * 512);
	 // bezier(2 * 84, height - 512, 400, 0, 100, 0, -200, height - 2 * 512);
	  //bezier(1.4 * 84, height - 512, 400, 0, 100, 0, -200, height - 2 * 512);
	  //line(4 * 92, height - 1.25 * 512, width / 2 - 4 * 92, height - 1.25 * 512);
	
	  
	  //rect(width / 2, height / 5, width / 5.5, width / 7);
	  //ellipse(width / 2, height / 5, width / 4, width / 7);
		
	  //line(2 * 92, height - 180, 64 + 2 * 148, height + (2 - 2 * 512));
	  //line(-92, height - 180, 64 + 48, height + (2 - 1 * 512));
	
	for (int i = 0; i < 3; i += 1) {
		//line(i * 92, height - 180, 64 + i * 148, height + (2 - i * 512));
		//line(64 + i * 92, 0, 64 + i * 92, (128 + i * 32));
		//line(64 + i * 92, 0, 256 + i * 92, (128 + i * 32));
	  //line(width / 3 - i * 128, height - 64, width / 3 - i * 128, height / 2 + height / 5);
	}
	//stroke(0, 0, 255, 92);
	
	//line(width / 2, height - 210, width / 2, height - 192);
	/*
	for (int i = 0; i < 8; i += 1) {
		ellipse(random(width / 8), random(height / 2, height / 1.6), 1, 1);
	}*/
	strokeWeight(2);
	//line(300, 64, 300, height / 6);
		//triangle(nx + random(width - nx), ny + random(height - ny), nx + random(width - nx), ny + random(height - ny), nx + random(width - nx), ny + random(height - ny));
		//ellipse(width / 2, height / 2, height / 2, height / 2);
	  //rect(width / 3, height / 2, width / 5, height / 2);
	  //rect(width - width / 3, height / 2, width / 5, height / 2);
		//rect(nx + random(width - nx), ny + random(height - ny), nx, ny);
		//bezier(random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height));
		//strokeWeight(1 + random(8));
		//bezier(random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height));

		rectMode(CORNER);
	
	//smooth();
}

void mouseClicked() {
	background(0);
	
	reset = frameCount;
	
	xmotion = 8.8;
	ymotion = 2.2;
}

void draw() {
  draw_func();
}"
"742142","Stones","mySketch","// doing it by following lines instead of per pixels (note : mostly useless in that case but the result look nice)

float xmotion = 8.8;
float ymotion = 2.2;

int reset = 0;
int perlin_amount = 80;

float[] ppx = new float[800 * 800];
float[] ppy = new float[800 * 800];

// https://iquilezles.org/www/articles/palettes/palettes.htm
float pal(float t, float a, float b, float c, float d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

void shapel(float x1, float y1, float x2, float y2, float dirx, float diry) {
	float dx = x2 - x1;
	float dy = y2 - y1;
	
	float xx1 = x1;
	float xx2 = x2;
	if (x1 > x2) {
		xx1 = x2;
		xx2 = x1;
	}
	//noStroke();
	strokeWeight(1);
	for (float x = xx1; x < xx2; x += 1) {
		float norm_dst = abs(x - xx2) / abs(xx2);
		float anorm_dst = 1.0 - abs(0.5 - norm_dst) * 2;
		
		float y = y1 + dy * (x - x1) / dx;
		
		float ynorm = (y + (ymotion * 2)) / (float)height;
		float anorm_y = 1.0 - abs(0.5 - ynorm) * 2;
		
		float anorm_y2 = 1.0 - abs(0.5 - ynorm % (0.025)) * 4;
		
		float n = (0.5-noise(x / (abs(x1 - x2)) + xmotion / 140 * anorm_y2, y / (abs(y1 - y2)) + ymotion / 140 * anorm_y2)) * 2 * anorm_y;
		
		float pa = 0.95;
		float pb = 0.5;
		float pc = 0.75;
		
		float pdr = 0.05;
		float pdg = 0.15;
		float pdb = 0.2;
		
		float rf = pal(anorm_y, pa, pb, pc, pdr) * 255;
		float gf = pal(anorm_y, pa, pb, pc, pdg) * 255;
		float bf = pal(anorm_y, pa, pb, pc, pdb) * 255;
		
		fill(rf, gf, bf, 12 + 12 * n);
		stroke(rf / 1.25, gf / 1.25, bf / 1.25, 12 + 12 * n);
		
		float s = 1 + 8 * anorm_dst;
		
		if (dirx < 0 && diry < 0) {
			ellipse(x - n * 32 - xmotion * 4 * ynorm, y - n * 90 * anorm_y2 - ymotion * 6 * ynorm, s * abs(n), s * abs(n));
		} else if (dirx > 0 && diry > 0) {
			ellipse(x + n * 32 + xmotion * 4 * ynorm, y + n * 90 * anorm_y2 + ymotion * 6 * ynorm, s * abs(n), s * abs(n));
		} else if (dirx < 0 && diry > 0) {
			ellipse(x - n * 32 - xmotion * 4 * ynorm, y + n * 90 * anorm_y2 + ymotion * 6 * ynorm, s * abs(n), s * abs(n));
		} else if (dirx > 0 && diry < 0) {
			ellipse(x + n * 32 + xmotion * 4 * ynorm, y - n * 90 * anorm_y2 - ymotion * 6 * ynorm, s * abs(n), s * abs(n));
		}
		
		//stroke(rf, gf, bf, 24 * abs(n));
		//line(x - n * 180 - xmotion * 4, y - n * 180 + ymotion * 4, x + n * 180 - xmotion * 4, y + n * 180 + ymotion * 4);
	}
	
	stroke(0, 0, 255, 1);
}

void draw_func() {
	noStroke();
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	float x1 = 0;
	float y1 = 0;
	float x2 = width;
	float y2 = 0.1;
	
	stroke(0, 0, 255, 1);
	strokeWeight(1);
	//line(x1, y1, x2, y2);
	
	shapel(x1, y1, x2, y2, 1, 1);
	
	x1 = 0;
	y1 = height;
	x2 = width;
	y2 = height-0.1;
	//line(x1, y1, x2, y2);

	//shapel(x1, y1, x2, y2, -1, -1);
	/*
	x1 = 0;
	y1 = height - height /1.99;
	x2 = width;
	y2 = height - height /2;
	//line(x1, y1, x2, y2);

	shapel(x1, y1, x2, y2, 1, -1);
	
	x1 = 0;
	y1 = height /1.99;
	x2 = width;
	y2 = height /2;
	//line(x1, y1, x2, y2);

	shapel(x1, y1, x2, y2, 1, -1);
			*/	
				xmotion += 0;
				ymotion += 0.25;
}

void setup() {
  size(900, 900);

  background(0);
	
	//colorMode(HSB, 360, 256, 256);
	
	noiseDetail(6,0.65);
	
	frameRate(60);
	
	
		noFill();
		noStroke();

		rectMode(CENTER);
		ellipseMode(CENTER);

		stroke(0, 0, 255, 255);
		strokeWeight(2);
		strokeCap(ROUND);
		noFill();
		int nx = random(width / 2);
		int ny = random(height / 2);
		
		int lx = nx + random(width - nx);
		
		//line(0, height - 192, width, height - 192);
	  //line(0, height - 192 / 1.15, width, height - 192 / 1.15);
	  //line(0, height - 192 / 1.3, width, height - 192 / 1.3);
	  //line(2 * 92, height + (2 - 1.45 * 512), width / 2, height + (2 - 1.45 * 512));
	  //line(3 * 84, height - 512, width / 2 - 3 * 84, height - 512);
	  //bezier(3.1 * 84, height - 550, 400, 0, 0, 0, 0, height - 2 * 550);
	 // bezier(2.6 * 84, height - 512, 400, 0, 100, 0, -200, height - 2 * 512);
	 // bezier(2 * 84, height - 512, 400, 0, 100, 0, -200, height - 2 * 512);
	  //bezier(1.4 * 84, height - 512, 400, 0, 100, 0, -200, height - 2 * 512);
	  //line(4 * 92, height - 1.25 * 512, width / 2 - 4 * 92, height - 1.25 * 512);
	
	  
	  //rect(width / 2, height / 5, width / 5.5, width / 7);
	  //ellipse(width / 2, height / 5, width / 4, width / 7);
		
	  //line(2 * 92, height - 180, 64 + 2 * 148, height + (2 - 2 * 512));
	  //line(-92, height - 180, 64 + 48, height + (2 - 1 * 512));
	
	for (int i = 0; i < 3; i += 1) {
		//line(i * 92, height - 180, 64 + i * 148, height + (2 - i * 512));
		//line(64 + i * 92, 0, 64 + i * 92, (128 + i * 32));
		//line(64 + i * 92, 0, 256 + i * 92, (128 + i * 32));
	  //line(width / 3 - i * 128, height - 64, width / 3 - i * 128, height / 2 + height / 5);
	}
	//stroke(0, 0, 255, 92);
	
	//line(width / 2, height - 210, width / 2, height - 192);
	/*
	for (int i = 0; i < 8; i += 1) {
		ellipse(random(width / 8), random(height / 2, height / 1.6), 1, 1);
	}*/
	strokeWeight(2);
	//line(300, 64, 300, height / 6);
		//triangle(nx + random(width - nx), ny + random(height - ny), nx + random(width - nx), ny + random(height - ny), nx + random(width - nx), ny + random(height - ny));
		//ellipse(width / 2, height / 2, height / 2, height / 2);
	  //rect(width / 3, height / 2, width / 5, height / 2);
	  //rect(width - width / 3, height / 2, width / 5, height / 2);
		//rect(nx + random(width - nx), ny + random(height - ny), nx, ny);
		//bezier(random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height));
		//strokeWeight(1 + random(8));
		//bezier(random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height));

		rectMode(CORNER);
	
	//smooth();
}

void mouseClicked() {
	background(0);
	
	reset = frameCount;
	
	perlin_amount = random(40, 80);
}

void draw() {
  draw_func();
}"
"741933","Draft","mySketch","// trying to shape things up

float xmotion = 8.8;
float ymotion = 2.2;

int reset = 0;
int perlin_amount = 80;

float[] ppx = new float[800 * 800];
float[] ppy = new float[800 * 800];

void shapel(float x1, float y1, float x2, float y2, float dirx, float diry) {
	float dx = x2 - x1;
	float dy = y2 - y1;
	
	float xx1 = x1;
	float xx2 = x2;
	if (x1 > x2) {
		xx1 = x2;
		xx2 = x1;
	}
	//noStroke();
	strokeWeight(1);
	for (float x = xx1; x < xx2; x += 1) {
		float norm_dst = abs(x - xx2) / abs(xx2);
		float anorm_dst = 1.0 - abs(0.5 - norm_dst) * 2;
		
		float y = y1 + dy * (x - x1) / dx;
		
		float ynorm = (y + ymotion * 8) / (float)height;
		float anorm_y = 1.0 - abs(0.5 - ynorm) * 2;
		
		float n = (0.5-noise(x / (abs(x1 - x2)) + xmotion / 200, y / (abs(y1 - y2)) + ymotion / 200)) * 2;
		
		fill((46 + abs(n / 2.75) * 360) % 360, 128, 255 - abs(n * 16), 8 * abs(n));
		stroke((8 + abs(n / 2.25) * 360) % 360, 128, 255 - abs(n * 128), 16 * abs(n));
		
		float s = 24 * anorm_dst;
		
		if (dirx < 0 && diry < 0) {
			ellipse(x - n - xmotion / 2 * n, y - n * 180 - ymotion * 8, s * abs(n), s * abs(n));
		} else if (dirx > 0 && diry > 0) {
			ellipse(x + n + xmotion / 2 * n, y + n * 180 + ymotion * 8, s * abs(n), s * abs(n));
		} else if (dirx < 0 && diry > 0) {
			ellipse(x - n - xmotion / 2 * n, y + n * 180 + ymotion * 8, s * abs(n), s * abs(n));
		} else if (dirx > 0 && diry < 0) {
			ellipse(x + n + xmotion / 2 * n, y - n * 180 - ymotion * 8, s * abs(n), s * abs(n));
		}
	}
	
	stroke(0, 0, 255, 1);
}

void draw_func() {
	noStroke();
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	float x1 = 0;
	float y1 = 0;
	float x2 = width;
	float y2 = 0.1;
	
	stroke(0, 0, 255, 1);
	strokeWeight(1);
	//line(x1, y1, x2, y2);
	
	shapel(x1, y1, x2, y2, 1, 1);
	
	x1 = 0;
	y1 = height;
	x2 = width;
	y2 = height-0.1;
	//line(x1, y1, x2, y2);

	//shapel(x1, y1, x2, y2, -1, -1);
	/*
	x1 = 0;
	y1 = height - height /1.99;
	x2 = width;
	y2 = height - height /2;
	//line(x1, y1, x2, y2);

	shapel(x1, y1, x2, y2, 1, -1);
	
	x1 = 0;
	y1 = height /1.99;
	x2 = width;
	y2 = height /2;
	//line(x1, y1, x2, y2);

	shapel(x1, y1, x2, y2, 1, -1);
			*/	
				xmotion += 0;
				ymotion += 0.25;
}

void setup() {
  size(800, 800);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	noiseDetail(5,0.65);
	
	frameRate(60);
	
	
		noFill();
		noStroke();

		rectMode(CENTER);
		ellipseMode(CENTER);

		stroke(0, 0, 255, 255);
		strokeWeight(2);
		strokeCap(ROUND);
		noFill();
		int nx = random(width / 2);
		int ny = random(height / 2);
		
		int lx = nx + random(width - nx);
		
		//line(0, height - 192, width, height - 192);
	  //line(0, height - 192 / 1.15, width, height - 192 / 1.15);
	  //line(0, height - 192 / 1.3, width, height - 192 / 1.3);
	  //line(2 * 92, height + (2 - 1.45 * 512), width / 2, height + (2 - 1.45 * 512));
	  //line(3 * 84, height - 512, width / 2 - 3 * 84, height - 512);
	  //bezier(3.1 * 84, height - 550, 400, 0, 0, 0, 0, height - 2 * 550);
	 // bezier(2.6 * 84, height - 512, 400, 0, 100, 0, -200, height - 2 * 512);
	 // bezier(2 * 84, height - 512, 400, 0, 100, 0, -200, height - 2 * 512);
	  //bezier(1.4 * 84, height - 512, 400, 0, 100, 0, -200, height - 2 * 512);
	  //line(4 * 92, height - 1.25 * 512, width / 2 - 4 * 92, height - 1.25 * 512);
	
	  
	  //rect(width / 2, height / 5, width / 5.5, width / 7);
	  //ellipse(width / 2, height / 5, width / 4, width / 7);
		
	  //line(2 * 92, height - 180, 64 + 2 * 148, height + (2 - 2 * 512));
	  //line(-92, height - 180, 64 + 48, height + (2 - 1 * 512));
	
	for (int i = 0; i < 3; i += 1) {
		//line(i * 92, height - 180, 64 + i * 148, height + (2 - i * 512));
		//line(64 + i * 92, 0, 64 + i * 92, (128 + i * 32));
		//line(64 + i * 92, 0, 256 + i * 92, (128 + i * 32));
	  //line(width / 3 - i * 128, height - 64, width / 3 - i * 128, height / 2 + height / 5);
	}
	//stroke(0, 0, 255, 92);
	
	//line(width / 2, height - 210, width / 2, height - 192);
	/*
	for (int i = 0; i < 8; i += 1) {
		ellipse(random(width / 8), random(height / 2, height / 1.6), 1, 1);
	}*/
	strokeWeight(2);
	//line(300, 64, 300, height / 6);
		//triangle(nx + random(width - nx), ny + random(height - ny), nx + random(width - nx), ny + random(height - ny), nx + random(width - nx), ny + random(height - ny));
		//ellipse(width / 2, height / 2, height / 2, height / 2);
	  //rect(width / 3, height / 2, width / 5, height / 2);
	  //rect(width - width / 3, height / 2, width / 5, height / 2);
		//rect(nx + random(width - nx), ny + random(height - ny), nx, ny);
		//bezier(random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height));
		//strokeWeight(1 + random(8));
		//bezier(random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height));

		rectMode(CORNER);
	
	//smooth();
}

void mouseClicked() {
	background(0);
	
	reset = frameCount;
	
	perlin_amount = random(40, 80);
}

void draw() {
  draw_func();
}"
"741933","Draft","mySketch","// doing it by following lines instead of per pixels (note : mostly useless in that case but the result look nice)

float xmotion = 8.8;
float ymotion = 2.2;

int reset = 0;
int perlin_amount = 80;

float[] ppx = new float[800 * 800];
float[] ppy = new float[800 * 800];

// https://iquilezles.org/www/articles/palettes/palettes.htm
float pal(float t, float a, float b, float c, float d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

void shapel(float x1, float y1, float x2, float y2, float dirx, float diry) {
	float dx = x2 - x1;
	float dy = y2 - y1;
	
	float xx1 = x1;
	float xx2 = x2;
	if (x1 > x2) {
		xx1 = x2;
		xx2 = x1;
	}
	//noStroke();
	strokeWeight(1);
	for (float x = xx1; x < xx2; x += 1) {
		float norm_dst = abs(x - xx2) / abs(xx2);
		float anorm_dst = 1.0 - abs(0.5 - norm_dst) * 2;
		
		float y = y1 + dy * (x - x1) / dx;
		
		float ynorm = (y + ymotion * 4) / (float)height;
		float anorm_y = 1.0 - abs(0.5 - ynorm) * 2;
		
		float anorm_y2 = 1.0 - abs(0.5 - ynorm) * 5;
		
		float n = (0.5-noise(x / (abs(x1 - x2)) + xmotion / 50 * anorm_y2, y / (abs(y1 - y2)) + ymotion / 50 * anorm_y2)) * 2 * anorm_y;
		
		float pa = 0.5;
		float pb = 0.5;
		float pc = 0.75;
		
		float pdr = 0.2;
		float pdg = 0.0;
		float pdb = 0.75;
		
		float rf = pal(anorm_y, pa, pb, pc, pdr) * 255;
		float gf = pal(anorm_y / 3, pa, pb, pc, pdg) * 255;
		float bf = pal(anorm_y / 1.5, pa, pb, pc, pdb) * 255;
		
		fill(rf, gf, bf, 16 * abs(n));
		stroke(rf / 1.5, gf / 1.5, bf / 1.5, 24 * abs(n));
		
		float s = 24 * anorm_dst;
		
		if (dirx < 0 && diry < 0) {
			ellipse(x - n - xmotion / 2 * n, y - n * 140 * ynorm - ymotion * 8 * ynorm, s * abs(n), s * abs(n));
		} else if (dirx > 0 && diry > 0) {
			ellipse(x + n + xmotion / 2 * n, y + n * 140 * ynorm + ymotion * 8 * ynorm, s * abs(n), s * abs(n));
		} else if (dirx < 0 && diry > 0) {
			ellipse(x - n - xmotion / 2 * n, y + n * 140 * ynorm + ymotion * 8 * ynorm, s * abs(n), s * abs(n));
		} else if (dirx > 0 && diry < 0) {
			ellipse(x + n + xmotion / 2 * n, y - n * 140 * ynorm - ymotion * 8 * ynorm, s * abs(n), s * abs(n));
		}
		
		//stroke(rf, gf, bf, 24 * abs(n));
		//line(x - n * 180 - xmotion * 4, y - n * 180 + ymotion * 4, x + n * 180 - xmotion * 4, y + n * 180 + ymotion * 4);
	}
	
	stroke(0, 0, 255, 1);
}

void draw_func() {
	noStroke();
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	float x1 = 0;
	float y1 = 0;
	float x2 = width;
	float y2 = 0.1;
	
	stroke(0, 0, 255, 1);
	strokeWeight(1);
	//line(x1, y1, x2, y2);
	
	shapel(x1, y1, x2, y2, 1, 1);
	
	x1 = 0;
	y1 = height;
	x2 = width;
	y2 = height-0.1;
	//line(x1, y1, x2, y2);

	//shapel(x1, y1, x2, y2, -1, -1);
	/*
	x1 = 0;
	y1 = height - height /1.99;
	x2 = width;
	y2 = height - height /2;
	//line(x1, y1, x2, y2);

	shapel(x1, y1, x2, y2, 1, -1);
	
	x1 = 0;
	y1 = height /1.99;
	x2 = width;
	y2 = height /2;
	//line(x1, y1, x2, y2);

	shapel(x1, y1, x2, y2, 1, -1);
			*/	
				xmotion += 0;
				ymotion += 0.25;
}

void setup() {
  size(800, 800);

  background(0);
	
	//colorMode(HSB, 360, 256, 256);
	
	noiseDetail(5,0.65);
	
	frameRate(60);
	
	
		noFill();
		noStroke();

		rectMode(CENTER);
		ellipseMode(CENTER);

		stroke(0, 0, 255, 255);
		strokeWeight(2);
		strokeCap(ROUND);
		noFill();
		int nx = random(width / 2);
		int ny = random(height / 2);
		
		int lx = nx + random(width - nx);
		
		//line(0, height - 192, width, height - 192);
	  //line(0, height - 192 / 1.15, width, height - 192 / 1.15);
	  //line(0, height - 192 / 1.3, width, height - 192 / 1.3);
	  //line(2 * 92, height + (2 - 1.45 * 512), width / 2, height + (2 - 1.45 * 512));
	  //line(3 * 84, height - 512, width / 2 - 3 * 84, height - 512);
	  //bezier(3.1 * 84, height - 550, 400, 0, 0, 0, 0, height - 2 * 550);
	 // bezier(2.6 * 84, height - 512, 400, 0, 100, 0, -200, height - 2 * 512);
	 // bezier(2 * 84, height - 512, 400, 0, 100, 0, -200, height - 2 * 512);
	  //bezier(1.4 * 84, height - 512, 400, 0, 100, 0, -200, height - 2 * 512);
	  //line(4 * 92, height - 1.25 * 512, width / 2 - 4 * 92, height - 1.25 * 512);
	
	  
	  //rect(width / 2, height / 5, width / 5.5, width / 7);
	  //ellipse(width / 2, height / 5, width / 4, width / 7);
		
	  //line(2 * 92, height - 180, 64 + 2 * 148, height + (2 - 2 * 512));
	  //line(-92, height - 180, 64 + 48, height + (2 - 1 * 512));
	
	for (int i = 0; i < 3; i += 1) {
		//line(i * 92, height - 180, 64 + i * 148, height + (2 - i * 512));
		//line(64 + i * 92, 0, 64 + i * 92, (128 + i * 32));
		//line(64 + i * 92, 0, 256 + i * 92, (128 + i * 32));
	  //line(width / 3 - i * 128, height - 64, width / 3 - i * 128, height / 2 + height / 5);
	}
	//stroke(0, 0, 255, 92);
	
	//line(width / 2, height - 210, width / 2, height - 192);
	/*
	for (int i = 0; i < 8; i += 1) {
		ellipse(random(width / 8), random(height / 2, height / 1.6), 1, 1);
	}*/
	strokeWeight(2);
	//line(300, 64, 300, height / 6);
		//triangle(nx + random(width - nx), ny + random(height - ny), nx + random(width - nx), ny + random(height - ny), nx + random(width - nx), ny + random(height - ny));
		//ellipse(width / 2, height / 2, height / 2, height / 2);
	  //rect(width / 3, height / 2, width / 5, height / 2);
	  //rect(width - width / 3, height / 2, width / 5, height / 2);
		//rect(nx + random(width - nx), ny + random(height - ny), nx, ny);
		//bezier(random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height));
		//strokeWeight(1 + random(8));
		//bezier(random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height));

		rectMode(CORNER);
	
	//smooth();
}

void mouseClicked() {
	background(0);
	
	reset = frameCount;
	
	perlin_amount = random(40, 80);
}

void draw() {
  draw_func();
}"
"741933","Draft","mySketch","// doing it by following lines instead of per pixels (note : mostly useless in that case but the result look nice)

float xmotion = 8.8;
float ymotion = 2.2;

int reset = 0;
int perlin_amount = 80;

float[] ppx = new float[800 * 800];
float[] ppy = new float[800 * 800];

// https://iquilezles.org/www/articles/palettes/palettes.htm
float pal(float t, float a, float b, float c, float d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

void shapel(float x1, float y1, float x2, float y2, float dirx, float diry) {
	float dx = x2 - x1;
	float dy = y2 - y1;
	
	float xx1 = x1;
	float xx2 = x2;
	if (x1 > x2) {
		xx1 = x2;
		xx2 = x1;
	}
	//noStroke();
	strokeWeight(1);
	for (float x = xx1; x < xx2; x += 1) {
		float norm_dst = abs(x - xx2) / abs(xx2);
		float anorm_dst = 1.0 - abs(0.5 - norm_dst) * 2;
		
		float y = y1 + dy * (x - x1) / dx;
		
		float ynorm = (y + ymotion * 4) / (float)height;
		float anorm_y = 1.0 - abs(0.5 - ynorm) * 2;
		
		float anorm_y2 = 1.0 - abs(0.5 - ynorm) * 5;
		
		float n = (0.5-noise(x / (abs(x1 - x2)) + xmotion / 50 * anorm_y2, y / (abs(y1 - y2)) + ymotion / 50 * anorm_y2)) * 2 * anorm_y;
		
		float pa = 0.5;
		float pb = 0.5;
		float pc = 0.75;
		
		float pdr = 0.2;
		float pdg = 0.0;
		float pdb = 0.75;
		
		float rf = pal(anorm_y, pa, pb, pc, pdr) * 255;
		float gf = pal(anorm_y / 3, pa, pb, pc, pdg) * 255;
		float bf = pal(anorm_y / 1.5, pa, pb, pc, pdb) * 255;
		
		fill(rf, gf, bf, 16 * abs(n));
		stroke(rf / 1.5, gf / 1.5, bf / 1.5, 24 * abs(n));
		
		float s = 24 * anorm_dst;
		
		if (dirx < 0 && diry < 0) {
			ellipse(x - n - xmotion / 2 * n, y - n * 140 * ynorm - ymotion * 8 * ynorm, s * abs(n), s * abs(n));
		} else if (dirx > 0 && diry > 0) {
			ellipse(x + n + xmotion / 2 * n, y + n * 140 * ynorm + ymotion * 8 * ynorm, s * abs(n), s * abs(n));
		} else if (dirx < 0 && diry > 0) {
			ellipse(x - n - xmotion / 2 * n, y + n * 140 * ynorm + ymotion * 8 * ynorm, s * abs(n), s * abs(n));
		} else if (dirx > 0 && diry < 0) {
			ellipse(x + n + xmotion / 2 * n, y - n * 140 * ynorm - ymotion * 8 * ynorm, s * abs(n), s * abs(n));
		}
		
		//stroke(rf, gf, bf, 24 * abs(n));
		//line(x - n * 180 - xmotion * 4, y - n * 180 + ymotion * 4, x + n * 180 - xmotion * 4, y + n * 180 + ymotion * 4);
	}
	
	stroke(0, 0, 255, 1);
}

void draw_func() {
	noStroke();
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	float x1 = 0;
	float y1 = 0;
	float x2 = width;
	float y2 = 0.1;
	
	stroke(0, 0, 255, 1);
	strokeWeight(1);
	//line(x1, y1, x2, y2);
	
	shapel(x1, y1, x2, y2, 1, 1);
	
	x1 = 0;
	y1 = height;
	x2 = width;
	y2 = height-0.1;
	//line(x1, y1, x2, y2);

	//shapel(x1, y1, x2, y2, -1, -1);
	/*
	x1 = 0;
	y1 = height - height /1.99;
	x2 = width;
	y2 = height - height /2;
	//line(x1, y1, x2, y2);

	shapel(x1, y1, x2, y2, 1, -1);
	
	x1 = 0;
	y1 = height /1.99;
	x2 = width;
	y2 = height /2;
	//line(x1, y1, x2, y2);

	shapel(x1, y1, x2, y2, 1, -1);
			*/	
				xmotion += 0;
				ymotion += 0.25;
}

void setup() {
  size(800, 800);

  background(0);
	
	//colorMode(HSB, 360, 256, 256);
	
	noiseDetail(5,0.65);
	
	frameRate(60);
	
	
		noFill();
		noStroke();

		rectMode(CENTER);
		ellipseMode(CENTER);

		stroke(0, 0, 255, 255);
		strokeWeight(2);
		strokeCap(ROUND);
		noFill();
		int nx = random(width / 2);
		int ny = random(height / 2);
		
		int lx = nx + random(width - nx);
		
		//line(0, height - 192, width, height - 192);
	  //line(0, height - 192 / 1.15, width, height - 192 / 1.15);
	  //line(0, height - 192 / 1.3, width, height - 192 / 1.3);
	  //line(2 * 92, height + (2 - 1.45 * 512), width / 2, height + (2 - 1.45 * 512));
	  //line(3 * 84, height - 512, width / 2 - 3 * 84, height - 512);
	  //bezier(3.1 * 84, height - 550, 400, 0, 0, 0, 0, height - 2 * 550);
	 // bezier(2.6 * 84, height - 512, 400, 0, 100, 0, -200, height - 2 * 512);
	 // bezier(2 * 84, height - 512, 400, 0, 100, 0, -200, height - 2 * 512);
	  //bezier(1.4 * 84, height - 512, 400, 0, 100, 0, -200, height - 2 * 512);
	  //line(4 * 92, height - 1.25 * 512, width / 2 - 4 * 92, height - 1.25 * 512);
	
	  
	  //rect(width / 2, height / 5, width / 5.5, width / 7);
	  //ellipse(width / 2, height / 5, width / 4, width / 7);
		
	  //line(2 * 92, height - 180, 64 + 2 * 148, height + (2 - 2 * 512));
	  //line(-92, height - 180, 64 + 48, height + (2 - 1 * 512));
	
	for (int i = 0; i < 3; i += 1) {
		//line(i * 92, height - 180, 64 + i * 148, height + (2 - i * 512));
		//line(64 + i * 92, 0, 64 + i * 92, (128 + i * 32));
		//line(64 + i * 92, 0, 256 + i * 92, (128 + i * 32));
	  //line(width / 3 - i * 128, height - 64, width / 3 - i * 128, height / 2 + height / 5);
	}
	//stroke(0, 0, 255, 92);
	
	//line(width / 2, height - 210, width / 2, height - 192);
	/*
	for (int i = 0; i < 8; i += 1) {
		ellipse(random(width / 8), random(height / 2, height / 1.6), 1, 1);
	}*/
	strokeWeight(2);
	//line(300, 64, 300, height / 6);
		//triangle(nx + random(width - nx), ny + random(height - ny), nx + random(width - nx), ny + random(height - ny), nx + random(width - nx), ny + random(height - ny));
		//ellipse(width / 2, height / 2, height / 2, height / 2);
	  //rect(width / 3, height / 2, width / 5, height / 2);
	  //rect(width - width / 3, height / 2, width / 5, height / 2);
		//rect(nx + random(width - nx), ny + random(height - ny), nx, ny);
		//bezier(random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height));
		//strokeWeight(1 + random(8));
		//bezier(random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height));

		rectMode(CORNER);
	
	//smooth();
}

void mouseClicked() {
	background(0);
	
	reset = frameCount;
	
	perlin_amount = random(40, 80);
}

void draw() {
  draw_func();
}"
"741889","Entrance","mySketch","// trying to shape things up

float xmotion = 8.8;
float ymotion = 2.2;

int reset = 0;
int perlin_amount = 80;

float[] ppx = new float[800 * 800];
float[] ppy = new float[800 * 800];

void draw_func() {
	noStroke();

	loadPixels();
	for (int y = 0; y < height; y += 1) {
		int yy = y * width;
		for (int x = 0; x < width; x += 1) {
			color p = pixels[yy + x];
			
			float xm = 4;
			float fr = (frameCount - reset) * 7;
			float ym = 128 - pow(fr, 1.05);//(frameCount - reset) * 7;
			
			if ((brightness(p) > xm && brightness(p) < ym)) {
				float normx = (float)x / width;
				float normy = (float)y / height;
				float anormx = 1.0 - abs(0.5 - normx) * 2;
				float anormy = 1.0 - abs(0.5 - normy) * 2;
				float anormxy = anormx * normy;
				float ianormxy = 1 - (anormx * anormy);
				
				float xk = xmotion / 128;
				float yk = ymotion / 128;
				
				float n = (0.5-noise(anormx*3+xk,anormy*3+yk)) * (perlin_amount + fr / 2);
				
				fill(abs(64 + n / 80 * 128 + pow(xmotion, 0.5) % 128) % 360, 32 + (n / 80) * 64, 256, 8);
				
				float nnx = n * ianormxy;
				float nny = n * ianormxy + 4;
				float nsx = 4 * anormx * (1+n / 80);
				float nsy = 4 * anormy * (1+n / 80);

				float dst = ((abs(x + nnx - width / 2) + abs(y + nny - width / 2)) / 512);
				
				ellipse(x + nnx * dst, y + nny * dst, nsx, nsy);
				ellipse(width - x + nnx * dst, y + nny * dst, nsx, nsy);
				
				xmotion += anormx / 24;
				ymotion += anormy / 32;
			}
		}
	}

}

void setup() {
  size(800, 800);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	noiseDetail(4,0.5);
	
	frameRate(60);
	
	
		noFill();
		noStroke();

		rectMode(CENTER);
		ellipseMode(CENTER);

		stroke(0, 0, 255, 12);
		strokeWeight(2);
		strokeCap(ROUND);
		noFill();
		int nx = random(width / 2);
		int ny = random(height / 2);
		
		int lx = nx + random(width - nx);
		
		line(0, height - 192, width, height - 192);
	  line(0, height - 192 / 1.15, width, height - 192 / 1.15);
	  line(0, height - 192 / 1.3, width, height - 192 / 1.3);
	  line(2 * 92, height + (2 - 1.45 * 512), width / 2, height + (2 - 1.45 * 512));
	  line(3 * 84, height - 512, width / 2 - 3 * 84, height - 512);
	  bezier(3.1 * 84, height - 550, 400, 0, 0, 0, 0, height - 2 * 550);
	  bezier(2.6 * 84, height - 512, 400, 0, 100, 0, -200, height - 2 * 512);
	  bezier(2 * 84, height - 512, 400, 0, 100, 0, -200, height - 2 * 512);
	  bezier(1.4 * 84, height - 512, 400, 0, 100, 0, -200, height - 2 * 512);
	  //line(4 * 92, height - 1.25 * 512, width / 2 - 4 * 92, height - 1.25 * 512);
	
	  
	  //rect(width / 2, height / 5, width / 5.5, width / 7);
	  ellipse(width / 2, height / 5, width / 4, width / 7);
		
	  line(18, height - 180, 64 + 108, height + (2 - 1 * 512));
	  line(-92, height - 180, 64 + 48, height + (2 - 1 * 512));
	
	for (int i = 0; i < 3; i += 1) {
		line(i * 92, height - 180, 64 + i * 148, height + (2 - i * 512));
		//line(64 + i * 92, 0, 64 + i * 92, (128 + i * 32));
		//line(64 + i * 92, 0, 256 + i * 92, (128 + i * 32));
	  //line(width / 3 - i * 128, height - 64, width / 3 - i * 128, height / 2 + height / 5);
	}
	stroke(0, 0, 255, 92);
	
	//line(width / 2, height - 210, width / 2, height - 192);
	/*
	for (int i = 0; i < 8; i += 1) {
		ellipse(random(width / 8), random(height / 2, height / 1.6), 1, 1);
	}*/
	strokeWeight(2);
	//line(300, 64, 300, height / 6);
		//triangle(nx + random(width - nx), ny + random(height - ny), nx + random(width - nx), ny + random(height - ny), nx + random(width - nx), ny + random(height - ny));
		//ellipse(width / 2, height / 2, height / 2, height / 2);
	  //rect(width / 3, height / 2, width / 5, height / 2);
	  //rect(width - width / 3, height / 2, width / 5, height / 2);
		//rect(nx + random(width - nx), ny + random(height - ny), nx, ny);
		//bezier(random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height));
		//strokeWeight(1 + random(8));
		//bezier(random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height));

		rectMode(CORNER);
	
	//smooth();
}

void mouseClicked() {
	background(0);
	
	reset = frameCount;
	
	perlin_amount = random(40, 80);
}

void draw() {
  draw_func();
}"
"741342","Onirism","mySketch","// varying noise level depending on display area so that ornament are around the display area and less in the center

float xmotion = 8.8;
float ymotion = 2.2;

int reset = 0;
int perlin_amount = 120;

float[] ppx = new float[800 * 800];
float[] ppy = new float[800 * 800];

void draw_func() {
	noStroke();

	loadPixels();
	for (int y = 0; y < height; y += 1) {
		int yy = y * width;
		for (int x = 0; x < width; x += 1) {
			color p = pixels[yy + x];
			
			float xm = 4;
			float fr = (frameCount - reset) * 7;
			float ym = 128 - pow(fr, 1.);//(frameCount - reset) * 7;
			
			if ((brightness(p) > xm && brightness(p) < ym)) {
				float normx = (float)x / width;
				float normy = (float)y / height;
				float anormx = 1.0 - abs(0.5 - normx) * 2;
				float anormy = 1.0 - abs(0.5 - normy) * 2;
				float anormxy = anormx * normy;
				float ianormxy = 1 - (anormx * anormy);
				
				float xk = xmotion / 128;
				float yk = ymotion / 128;
				
				float n = (0.5-noise(anormx*3+xk,anormy*3+yk)) * (perlin_amount + fr / 2);
				
				fill(abs(148 + n / 80 * 64 + pow(xmotion, 0.55) % 128) % 360, (n / 80 * 6) * 128, 256, 8);
				
				float nnx = n * ianormxy;
				float nny = n * ianormxy + 8;
				float nsx = 5 * anormx;
				float nsy = 5 * anormy;

				
				float dst = (abs(x + nnx - width / 2) + abs(y + nny - width / 2)) / 512;
				
				ellipse(x + nnx * dst, y + nny * dst, nsx, nsy);
				ellipse(width - x + nnx * dst, y + nny * dst, nsx, nsy);
				
				xmotion += anormx / 128;
				ymotion += anormy / 128;
			}
		}
	}

}

void setup() {
  size(800, 800);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	noiseDetail(4,0.5);
	
	frameRate(60);
	
	
		noFill();
		noStroke();

		rectMode(CENTER);
		ellipseMode(CENTER);

		stroke(0, 0, 255, 12);
		strokeWeight(2);
		strokeCap(ROUND);
		noFill();
		int nx = random(width / 2);
		int ny = random(height / 2);
		
		int lx = nx + random(width - nx);
		
		line(0, height - 192, width, height - 64);
		
	for (int i = 0; i < 4; i += 1) {
		line(i * 92, height - 180, 64 + i * 92, height + (2 - i * 256));
		//line(64 + i * 92, 0, 64 + i * 92, (128 + i * 32));
		//line(64 + i * 92, 0, 256 + i * 92, (128 + i * 32));
	  //line(width / 3 - i * 128, height - 64, width / 3 - i * 128, height / 2 + height / 5);
	}
	stroke(0, 0, 255, 8);
	
	for (int i = 0; i < 8; i += 1) {
		ellipse(random(width / 8), random(height / 2, height / 1.6), 1, 1);
	}
	strokeWeight(2);
	//line(300, 64, 300, height / 6);
		//triangle(nx + random(width - nx), ny + random(height - ny), nx + random(width - nx), ny + random(height - ny), nx + random(width - nx), ny + random(height - ny));
		//ellipse(width / 2, height / 2, height / 2, height / 2);
	  //rect(width / 3, height / 2, width / 5, height / 2);
	  //rect(width - width / 3, height / 2, width / 5, height / 2);
		//rect(nx + random(width - nx), ny + random(height - ny), nx, ny);
		//bezier(random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height));
		//strokeWeight(1 + random(8));
		//bezier(random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height));

		rectMode(CORNER);
	
	//smooth();
}

void mouseClicked() {
	background(0);
	
	reset = frameCount;
	
	perlin_amount = random(40, 80);
}

void draw() {
  draw_func();
}"
"741342","Onirism","mySketch","// same as ""Composition"" but bit more complex; introducing colors

float xmotion = 8.8;
float ymotion = 2.2;

int reset = 0;
int perlin_amount = 120;

float[] ppx = new float[800 * 800];
float[] ppy = new float[800 * 800];

void draw_func() {
	noStroke();

	loadPixels();
	for (int y = 0; y < height; y += 1) {
		int yy = y * width;
		for (int x = 0; x < width; x += 1) {
			color p = pixels[yy + x];
			
			float xm = 4;
			float fr = (frameCount - reset) * 7;
			float ym = 128 - pow(fr, 1.);//(frameCount - reset) * 7;
			
			if ((brightness(p) > xm && brightness(p) < ym)) {
				float normx = (float)x / width;
				float normy = (float)y / height;
				float anormx = 1.0 - abs(0.5 - normx) * 2;
				float anormy = 1.0 - abs(0.5 - normy) * 2;
				float anormxy = anormx * normy;
				float ianormxy = 1 - (anormx * anormy);
				
				float xk = xmotion / 128;
				float yk = ymotion / 128;
				
				float n = (0.5-noise(anormx*3+xk,anormy*3+yk)) * (perlin_amount + fr / 2);
				
				fill(abs(148 + n / 80 * 64 + pow(xmotion, 0.55) % 128) % 360, (n / 80 * 6) * 128, 256, 8);
				
				float nnx = n * ianormxy;
				float nny = n * ianormxy + 8;
				float nsx = 5 * anormx;
				float nsy = 5 * anormy;

				
				float dst = (abs(x + nnx - width / 2) + abs(y + nny - width / 2)) / 512;
				
				ellipse(x + nnx * dst, y + nny * dst, nsx, nsy);
				ellipse(width - x + nnx * dst, y + nny * dst, nsx, nsy);
				
				xmotion += anormx / 128;
				ymotion += anormy / 128;
			}
		}
	}

}

void setup() {
  size(800, 800);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	noiseDetail(4,0.5);
	
	frameRate(60);
	
	
		noFill();
		noStroke();

		rectMode(CENTER);
		ellipseMode(CENTER);

		stroke(0, 0, 255, 12);
		strokeWeight(2);
		strokeCap(ROUND);
		noFill();
		int nx = random(width / 2);
		int ny = random(height / 2);
		
		int lx = nx + random(width - nx);
		
		line(0, height - 192, width, height - 64);
		
	for (int i = 0; i < 4; i += 1) {
		line(i * 92, height - 180, 64 + i * 92, height + (2 - i * 256));
		//line(64 + i * 92, 0, 64 + i * 92, (128 + i * 32));
		//line(64 + i * 92, 0, 256 + i * 92, (128 + i * 32));
	  //line(width / 3 - i * 128, height - 64, width / 3 - i * 128, height / 2 + height / 5);
	}
	stroke(0, 0, 255, 8);
	
	for (int i = 0; i < 8; i += 1) {
		ellipse(random(width / 8), random(height / 2, height / 1.6), 1, 1);
	}
	strokeWeight(2);
	//line(300, 64, 300, height / 6);
		//triangle(nx + random(width - nx), ny + random(height - ny), nx + random(width - nx), ny + random(height - ny), nx + random(width - nx), ny + random(height - ny));
		//ellipse(width / 2, height / 2, height / 2, height / 2);
	  //rect(width / 3, height / 2, width / 5, height / 2);
	  //rect(width - width / 3, height / 2, width / 5, height / 2);
		//rect(nx + random(width - nx), ny + random(height - ny), nx, ny);
		//bezier(random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height));
		//strokeWeight(1 + random(8));
		//bezier(random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height));

		rectMode(CORNER);
	
	//smooth();
}

void mouseClicked() {
	background(0);
	
	reset = frameCount;
	
	perlin_amount = random(40, 80);
}

void draw() {
  draw_func();
}"
"741114","Composition","mySketch","// same as Structures 2 sketch with squares, stop behaviors and 'rusty' smooth look by playing with noise

float xmotion = 8.8;
float ymotion = 2.2;

int reset = 0;
int perlin_amount = 80;

void draw_func() {
	noStroke();
	
	loadPixels();
	for (int y = 0; y < height; y += 1) {
		int yy = y * width;
		for (int x = 0; x < width; x += 1) {
			color p = pixels[yy + x];
			
			float xm = 4;
			float ym = 192 - pow((frameCount - reset) * 7, 1.025);//(frameCount - reset) * 7;
			
			if ((brightness(p) > xm && brightness(p) < ym)) {
				float normx = (float)x / width;
				float normy = (float)y / height;
				float anormx = 1.0 - abs(0.5 - normx) * 2;
				float anormy = 1.0 - abs(0.5 - normy) * 2;
				float anormxy = anormx * normy;
				float ianormxy = 1 - (anormx * anormy);
				
				float xk = xmotion / 128;
				float yk = ymotion / 128;
				
				float n = (0.5-noise(anormx*3+xk,anormy*3+yk)) * perlin_amount;
				
				fill(0, 0, 256, 12);
				
				ellipse(x + n * ianormxy, y + n * ianormxy, 5 * anormx, 5 * anormy);
				ellipse(width - x + n * ianormxy, y + n * ianormxy, 5 * anormx, 5 * anormy);
			}
		}
	}
	
	if ((frameCount - reset) > 8) {
		noFill();
		noStroke();

		rectMode(CENTER);
		ellipseMode(CENTER);

		stroke(0, 0, 255 * random(), 16);
		strokeWeight(1 + random(4));
		strokeCap(ROUND);
		noFill();
		int nx = random(width / 2);
		int ny = random(height / 2);
		
		int lx = nx + random(width - nx);
		
		line(lx, 0, lx, height);
		line(0, lx, width, lx);
		//triangle(nx + random(width - nx), ny + random(height - ny), nx + random(width - nx), ny + random(height - ny), nx + random(width - nx), ny + random(height - ny));
		ellipse(nx + random(width - nx), ny + random(height - ny), nx, ny);
		//rect(nx + random(width - nx), ny + random(height - ny), nx, ny);
		bezier(random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height));
		//strokeWeight(1 + random(8));
		//bezier(random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height));

		rectMode(CORNER);
	}
	
	xmotion += 2.75;
	ymotion += 1.8;
}

void setup() {
  size(800, 800);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	noiseDetail(4,0.5);
	
	frameRate(60);
	
	//smooth();
}

void mouseClicked() {
	background(0);
	
	reset = frameCount;
	
	perlin_amount = random(2, 4);
}

void draw() {
  draw_func();
}"
"741114","Composition","mySketch","// varying noise level depending on display area so that ornament are around the display area and less in the center

float xmotion = 8.8;
float ymotion = 2.2;

int reset = 0;
int perlin_amount = 80;

void draw_func() {
	noStroke();
	
	loadPixels();
	for (int y = 0; y < height; y += 1) {
		int yy = y * width;
		for (int x = 0; x < width; x += 1) {
			color p = pixels[yy + x];
			
			float xm = 4;
			float ym = 192 - pow((frameCount - reset) * 7, 1.025);//(frameCount - reset) * 7;
			
			if ((brightness(p) > xm && brightness(p) < ym)) {
				float normx = (float)x / width;
				float normy = (float)y / height;
				float anormx = 1.0 - abs(0.5 - normx) * 2;
				float anormy = 1.0 - abs(0.5 - normy) * 2;
				float anormxy = anormx * normy;
				float ianormxy = 1 - (anormx * anormy);
				
				float xk = xmotion / 128;
				float yk = ymotion / 128;
				
				float n = (0.5-noise(anormx*3+xk,anormy*3+yk)) * perlin_amount;
				
				fill(0, 0, 256, 12);
				
				ellipse(x + n * ianormxy, y + n * ianormxy, 5 * anormx, 5 * anormy);
				ellipse(width - x + n * ianormxy, y + n * ianormxy, 5 * anormx, 5 * anormy);
			}
		}
	}
	
	if ((frameCount - reset) > 8) {
		noFill();
		noStroke();

		rectMode(CENTER);
		ellipseMode(CENTER);

		stroke(0, 0, 255 * random(), 16);
		strokeWeight(1 + random(4));
		strokeCap(ROUND);
		noFill();
		int nx = random(width / 2);
		int ny = random(height / 2);
		
		int lx = nx + random(width - nx);
		
		line(lx, 0, lx, height);
		line(0, lx, width, lx);
		//triangle(nx + random(width - nx), ny + random(height - ny), nx + random(width - nx), ny + random(height - ny), nx + random(width - nx), ny + random(height - ny));
		ellipse(nx + random(width - nx), ny + random(height - ny), nx, ny);
		//rect(nx + random(width - nx), ny + random(height - ny), nx, ny);
		bezier(random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height));
		//strokeWeight(1 + random(8));
		//bezier(random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height));

		rectMode(CORNER);
	}
	
	xmotion += 2.75;
	ymotion += 1.8;
}

void setup() {
  size(800, 800);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	noiseDetail(4,0.5);
	
	frameRate(60);
	
	//smooth();
}

void mouseClicked() {
	background(0);
	
	reset = frameCount;
	
	perlin_amount = random(2, 4);
}

void draw() {
  draw_func();
}"
"741114","Composition","mySketch","// varying noise level depending on display area so that ornament are around the display area and less in the center

float xmotion = 8.8;
float ymotion = 2.2;

int reset = 0;
int perlin_amount = 80;

void draw_func() {
	noStroke();
	
	loadPixels();
	for (int y = 0; y < height; y += 1) {
		int yy = y * width;
		for (int x = 0; x < width; x += 1) {
			color p = pixels[yy + x];
			
			float xm = 4;
			float ym = 192 - pow((frameCount - reset) * 7, 1.025);//(frameCount - reset) * 7;
			
			if ((brightness(p) > xm && brightness(p) < ym)) {
				float normx = (float)x / width;
				float normy = (float)y / height;
				float anormx = 1.0 - abs(0.5 - normx) * 2;
				float anormy = 1.0 - abs(0.5 - normy) * 2;
				float anormxy = anormx * normy;
				float ianormxy = 1 - (anormx * anormy);
				
				float xk = xmotion / 128;
				float yk = ymotion / 128;
				
				float n = (0.5-noise(anormx*3+xk,anormy*3+yk)) * perlin_amount;
				
				fill(0, 0, 256, 12);
				
				ellipse(x + n * ianormxy, y + n * ianormxy, 5 * anormx, 5 * anormy);
				ellipse(width - x + n * ianormxy, y + n * ianormxy, 5 * anormx, 5 * anormy);
			}
		}
	}
	
	if ((frameCount - reset) > 8) {
		noFill();
		noStroke();

		rectMode(CENTER);
		ellipseMode(CENTER);

		stroke(0, 0, 255 * random(), 16);
		strokeWeight(1 + random(4));
		strokeCap(ROUND);
		noFill();
		int nx = random(width / 2);
		int ny = random(height / 2);
		
		int lx = nx + random(width - nx);
		
		line(lx, 0, lx, height);
		line(0, lx, width, lx);
		//triangle(nx + random(width - nx), ny + random(height - ny), nx + random(width - nx), ny + random(height - ny), nx + random(width - nx), ny + random(height - ny));
		ellipse(nx + random(width - nx), ny + random(height - ny), nx, ny);
		//rect(nx + random(width - nx), ny + random(height - ny), nx, ny);
		bezier(random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height));
		//strokeWeight(1 + random(8));
		//bezier(random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height));

		rectMode(CORNER);
	}
	
	xmotion += 2.75;
	ymotion += 1.8;
}

void setup() {
  size(800, 800);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	noiseDetail(4,0.5);
	
	frameRate(60);
	
	//smooth();
}

void mouseClicked() {
	background(0);
	
	reset = frameCount;
	
	perlin_amount = random(40, 80);
}

void draw() {
  draw_func();
}"
"741110","Toile","mySketch","// same as Structures 2 sketch with squares, stop behaviors and 'rusty' smooth look by playing with noise

float xmotion = 8.8;
float ymotion = 2.2;

int reset = 0;
int perlin_amount = 80;

void draw_func() {
	noStroke();
	
	loadPixels();
	for (int y = 0; y < height; y += 1) {
		int yy = y * width;
		for (int x = 0; x < width; x += 1) {
			color p = pixels[yy + x];
			
			float xm = 4;
			float ym = 192 - pow((frameCount - reset) * 7, 1.025);//(frameCount - reset) * 7;
			
			if ((brightness(p) > xm && brightness(p) < ym)) {
				float normx = (float)x / width;
				float normy = (float)y / height;
				float anormx = 1.0 - abs(0.5 - normx) * 2;
				float anormy = 1.0 - abs(0.5 - normy) * 2;
				float anormxy = anormx * normy;
				
				float xk = xmotion / 128;
				float yk = ymotion / 128;
				
				float n = (0.5-noise(anormx*3+xk,anormy*3+yk)) * perlin_amount;
				
				fill(0, 0, 256, 12);
				
				ellipse(x + n, y + n, 5 * anormx, 5 * anormy);
				ellipse(width - x + n, y + n, 5 * anormx, 5 * anormy);
			}
		}
	}
	
	if ((frameCount - reset) > 6) {
		noFill();
		noStroke();

		rectMode(CENTER);
		ellipseMode(CENTER);

		stroke(0, 0, 255 * random(), 16);
		strokeWeight(1 + random(4));
		strokeCap(ROUND);
		noFill();
		int nx = random(width / 2);
		int ny = random(height / 2);
		
		int lx = nx + random(width - nx);
		
		line(lx, 0, lx, height);
		line(0, lx, width, lx);
		//quad(nx + random(width - nx), ny + random(height - ny), nx + random(width - nx), ny + random(height - ny), nx + random(width - nx), ny + random(height - ny), nx + random(width - nx), ny + random(height - ny));
		//ellipse(nx + random(width - nx), ny + random(height - ny), nx, ny);
		//ellipse(nx + random(width - nx), ny + random(height - ny), nx, ny);
		//bezier(random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height));
		//strokeWeight(1 + random(8));
		//bezier(random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height));

		rectMode(CORNER);
	}
	
	xmotion += 2.75;
	ymotion += 1.8;
}

void setup() {
  size(800, 800);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	noiseDetail(4,0.5);
	
	frameRate(60);
	
	//smooth();
}

void mouseClicked() {
	background(0);
	
	reset = frameCount;
	
	perlin_amount = random(2, 4);
}

void draw() {
  draw_func();
}"
"741107","Old structure","mySketch","// same as Structures 2 sketch with squares and stop behaviors

float xmotion = 8.8;
float ymotion = 2.2;

int reset = 0;
int perlin_amount = 4;

void draw_func() {
	noStroke();
	
	loadPixels();
	for (int y = 0; y < height; y += 1) {
		int yy = y * width;
		for (int x = 0; x < width; x += 1) {
			color p = pixels[yy + x];
			
			float xm = 4;
			float ym = 128 - pow((frameCount - reset) * 7, 1.04);//(frameCount - reset) * 7;
			
			if ((brightness(p) > xm && brightness(p) < ym)) {
				float normx = (float)x / width;
				float normy = (float)y / height;
				float anormx = 1.0 - abs(0.5 - normx) * 2;
				float anormy = 1.0 - abs(0.5 - normy) * 2;
				float anormxy = anormx * normy;
				
				float xk = xmotion / 128;
				float yk = ymotion / 128;
				
				float n = (0.5-noise(anormx*10+xk,anormy*10+yk)) * perlin_amount;
				
				fill(0, 0, 256, 12);
				
				ellipse(x + n, y + n + 4, 5 * anormx + n, 5 * anormy + n);
				ellipse(width - x + n, y + n + 4, 5 * anormx + n, 5 * anormy + n);
			}
		}
	}
	
	if ((frameCount - reset) > 0) {
		noFill();
		noStroke();

		rectMode(CENTER);
		ellipseMode(CENTER);

		stroke(0, 0, 255 * random(), 16);
		strokeWeight(1 + random(4));
		strokeCap(ROUND);
		noFill();
		int nx = random(width / 2);
		int ny = random(height / 2);
		rect(nx + random(width - nx), ny + random(height - ny), nx, ny);
		rect(nx + random(width - nx), ny + random(height - ny), nx, ny);
		rect(nx + random(width - nx), ny + random(height - ny), nx, ny);
		//bezier(random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height));
		//strokeWeight(1 + random(8));
		//bezier(random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height));

		rectMode(CORNER);
	}
	
	xmotion += 2.75;
	ymotion += 1.8;
}

void setup() {
  size(800, 800);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	noiseDetail(4,0.7);
	
	frameRate(60);
	
	//smooth();
}

void mouseClicked() {
	background(0);
	
	reset = frameCount;
	
	perlin_amount = random(2, 4);
}

void draw() {
  draw_func();
}"
"741107","Old structure","mySketch","// same as Structures 2 sketch with squares, stop behaviors and 'rusty' smooth look by playing with noise

float xmotion = 8.8;
float ymotion = 2.2;

int reset = 0;
int perlin_amount = 4;

void draw_func() {
	noStroke();
	
	loadPixels();
	for (int y = 0; y < height; y += 1) {
		int yy = y * width;
		for (int x = 0; x < width; x += 1) {
			color p = pixels[yy + x];
			
			float xm = 4;
			float ym = 128 - pow((frameCount - reset) * 7, 1.04);//(frameCount - reset) * 7;
			
			if ((brightness(p) > xm && brightness(p) < ym)) {
				float normx = (float)x / width;
				float normy = (float)y / height;
				float anormx = 1.0 - abs(0.5 - normx) * 2;
				float anormy = 1.0 - abs(0.5 - normy) * 2;
				float anormxy = anormx * normy;
				
				float xk = xmotion / 128;
				float yk = ymotion / 128;
				
				float n = (0.5-noise(anormx*10+xk,anormy*10+yk)) * perlin_amount;
				
				fill(0, 0, 256, 12);
				
				ellipse(x + n, y + n + 4, 5 * anormx + n, 5 * anormy + n);
				ellipse(width - x + n, y + n + 4, 5 * anormx + n, 5 * anormy + n);
			}
		}
	}
	
	if ((frameCount - reset) > 0) {
		noFill();
		noStroke();

		rectMode(CENTER);
		ellipseMode(CENTER);

		stroke(0, 0, 255 * random(), 16);
		strokeWeight(1 + random(4));
		strokeCap(ROUND);
		noFill();
		int nx = random(width / 2);
		int ny = random(height / 2);
		rect(nx + random(width - nx), ny + random(height - ny), nx, ny);
		rect(nx + random(width - nx), ny + random(height - ny), nx, ny);
		rect(nx + random(width - nx), ny + random(height - ny), nx, ny);
		//bezier(random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height));
		//strokeWeight(1 + random(8));
		//bezier(random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height));

		rectMode(CORNER);
	}
	
	xmotion += 2.75;
	ymotion += 1.8;
}

void setup() {
  size(800, 800);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	noiseDetail(4,0.7);
	
	frameRate(60);
	
	//smooth();
}

void mouseClicked() {
	background(0);
	
	reset = frameCount;
	
	perlin_amount = random(2, 4);
}

void draw() {
  draw_func();
}"
"732671","Portrait","mySketch","float xmotion = 8.8;
float ymotion = 2.2;

void draw_func() {
	/*if ((frameCount % 200) == 0) {
		background(0);
	}*/
	
	noStroke();
	
	loadPixels();
	for (int y = 0; y < height; y += 2) {
		int yy = y * width;
		float normy = abs(0.5 - (float)y / height) * 2;
		
		for (int x = 0; x < width; x += 2) {
			color p = pixels[yy + x];
			
			float normx = abs(0.5 - (float)x / width) * 2;
			
			if (brightness(p) > 0 && brightness(p) < 92 - (normy * normx) * 128) {
				float n = (0.5-noise((float)x/width*400+xmotion,(float)y/height*400+ymotion))*2;
				float n2 = (0.5-noise((float)y/height*400+ymotion,(float)x/width*400+xmotion))*2;
				
				fill(hue(p) + abs(n)/4, 128, 255, 64);
				
				ellipse(x + n, y + n, 3, 3);
				ellipse(width - x  - n2, y - n2, 3, 3);
			}
		}
	}
	
	noFill();
	noStroke();
  strokeWeight(1);
	
	rectMode(CENTER);
	ellipseMode(CENTER);

	for (int i = 1; i < 32; i += 1) {
		float norm_i = 1-((float)(i - 1) / 32);
		
		stroke(192, 128, 255 * norm_i, 2);

		//int sw = (float)width/2 / (i * 1) + abs(cos(ymotion/2) * 256);
		//int sh = height/2 / (i * 1)+ abs(sin(xmotion/2) * 64);
		
		float n = random(0, 1);
		//line(width/64*i, 0, width/64*i, height);
		line(0, height/32*i, width/i*pow(i, .2), height/32*i);
		//bezier(0, height/32*i, 0, height/2*i, 0, height/2*i, width/i*pow(i, 0.2), height/32*i);
	}
	rectMode(CORNER);
	
	fill(64 + abs(sin(xmotion)) * 64, 128, 255, 128);
	ellipse(width / 2, height / 5, 1, 1);
	fill(22, 128, 255, 255);
	ellipse(width / 4, height / 4, 1, 1);
	fill(22, 128, 255, 255);
	rect(width / 2 - 4, height / 3.5, 1, 2);
	
	fill(48, 128, 255, 255);
	ellipse(width / 2, height / 1.25, 1, 1);
	arc(width / 2, height / 1.25, 4, 1, 0, PI, CHORD);

	xmotion += 0.4;
	ymotion += 0.1;
}

void setup() {
  size(600, 600);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	noiseDetail(7,0.65);
	
	frameRate(30);
	
	rectMode(CENTER, CENTER);
	
	//smooth();
}

void draw() {
  draw_func();
}"
"719598","les motifs 3","mySketch","float xmotion = 0.0;
float ymotion = 0.0;

float[] pattern = {
1.0, 1.0, 1.0,
1.0, 0.0, 1.0,
1.0, 1.0, 1.0,
	
0.0, 0.0, 0.0,
0.0, 1.0, 0.0,
0.0, 0.0, 0.0,
	
0.1, 0.1, 0.1,
0.1, 0.0, 0.1,
0.1, 0.1, 0.1,
	
0.0, 0.0, 0.0,
0.0, 0.1, 0.0,
0.0, 0.0, 0.0,
};

int f = 0;
void poke(int h, int x, int y, int sign) {
	int stax = 0;
	int sizx = 4;
	int offx = x;
	for (int xx = 0; xx < sizx; xx += 1) {
		int stay = 0;
		int sizy = 4;
		int offy = y;
		for (int yy = 0; yy < sizy; yy += 1) {
			float px = pattern[(xx%3) + (yy%3) * 3 + 4 * f];
			
			if (px) {
				fill(h + abs(sin(PI * 2 + px * 8)) * 2, 0, 255, 128);

				rect(offx + xx + stax, offy + yy + stay, 1, 1);
				rect(width - offx + xx + stax, offy + yy + stay, 1, 1);
				rect(width - offx + xx + stax, height - offy + yy + stay, 1, 1);
				rect(width - offx + xx + stax, height - offy + yy + stay, 1, 1);
			}
		}
	}
}

void draw_func() {
	noStroke();
	noFill();
	
	loadPixels();
	for (int y = 0; y < height; y += 2) {
		int yy = y * width;
		for (int x = 0; x < width; x += 2) {
			color p = pixels[yy + x];
			
			if (brightness(p) > 1 && brightness(p) < 128) {
				int h = hue(p);
				
				poke(h, x, y, 0);
			}
		}
	}
	
	f += 1;
	f %= 8;
	
	xmotion += 0.01;
	ymotion += 0.1;
	/*
	noFill();
	strokeWeight(256);
	stroke(0, 0, 0, 256);
	
	int w = 256;
	int h = 256;
	
	ellipse(width / 2, height / 2, 256 * 3.25, 380 * 2.5);*/
}

void setup() {
  size(800, 800);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	frameRate(30);
	
	noiseDetail(9,0.65);
	
	mouseClicked();
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	for (int i = 0; i < 9 * 4; i += 1) {
		pattern[i] = round(random(0, 1));
	}
	
	//smooth();
}

void mouseClicked() {
	background(0);
	
	noStroke();
	fill(32, 128, 256, 1);
	
	int w = 256;
	int h = 256;
	
	//ellipse(width / 2, height / 2, 256, 380);
	
	noFill();
	strokeWeight(4);
	stroke(random(0, 360), 128, 256, 1);
	
	bezier(random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height));
	
	int r = random(8, width);
	ellipse(width / 2, height / 2, r, r);
	/*
	float r = random();
	if (r > 1.0 - 0.33) {
		line(0, random(0, height), width, random(0, height));
	} else if (r > 1.0 - 0.33*2) {
		line(random(0, width), 0, random(0, width), height);
	} else {
		line(0, random(0, height), width, random(0, height));
		line(random(0, width), 0, random(0, width), height);
	}*/
	
	//line(width / 2, height / 1.5, width / 16 - 28, height);
	//line(width / 16 - 28, height / 2.5, width, height);
	//line(width / 2, height / 8.5, width / 16 - 28, height);
}

void draw() {
  draw_func();
}"
"719598","les motifs 3","mySketch","// same as les motifs but the pattern is randomized and is shorter, more symmetry

float xmotion = 0.0;
float ymotion = 0.0;

float[] pattern = {
1.0, 1.0, 1.0,
1.0, 0.0, 1.0,
1.0, 1.0, 1.0,
	
0.0, 0.0, 0.0,
0.0, 1.0, 0.0,
0.0, 0.0, 0.0,
	
0.1, 0.1, 0.1,
0.1, 0.0, 0.1,
0.1, 0.1, 0.1,
	
0.0, 0.0, 0.0,
0.0, 0.1, 0.0,
0.0, 0.0, 0.0,
};

int f = 0;
void poke(int h, int x, int y, int sign) {
	int stax = 0;
	int sizx = 4;
	int offx = x;
	for (int xx = 0; xx < sizx; xx += 1) {
		int stay = 0;
		int sizy = 4;
		int offy = y;
		for (int yy = 0; yy < sizy; yy += 1) {
			float px = pattern[(xx%3) + (yy%3) * 3 + 4 * f];
			
			if (px) {
				fill(h + abs(sin(PI * 2 + px * 8)) * 2, 0, 255, 128);

				rect(offx + xx + stax, offy + yy + stay, 1, 1);
				rect(width - offx + xx + stax, offy + yy + stay, 1, 1);
				rect(width - offx + xx + stax, height - offy + yy + stay, 1, 1);
				rect(width - offx + xx + stax, height - offy + yy + stay, 1, 1);
			}
		}
	}
}

void draw_func() {
	noStroke();
	noFill();
	
	loadPixels();
	for (int y = 0; y < height; y += 2) {
		int yy = y * width;
		for (int x = 0; x < width; x += 2) {
			color p = pixels[yy + x];
			
			if (brightness(p) > 1 && brightness(p) < 128) {
				int h = hue(p);
				
				poke(h, x, y, 0);
			}
		}
	}
	
	f += 1;
	f %= 8;
	
	xmotion += 0.01;
	ymotion += 0.1;
	/*
	noFill();
	strokeWeight(256);
	stroke(0, 0, 0, 256);
	
	int w = 256;
	int h = 256;
	
	ellipse(width / 2, height / 2, 256 * 3.25, 380 * 2.5);*/
}

void setup() {
  size(800, 800);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	frameRate(30);
	
	noiseDetail(9,0.65);
	
	mouseClicked();
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	for (int i = 0; i < 9 * 4; i += 1) {
		pattern[i] = round(random(0, 1));
	}
	
	//smooth();
}

void mouseClicked() {
	background(0);
	
	noStroke();
	fill(32, 128, 256, 1);
	
	int w = 256;
	int h = 256;
	
	//ellipse(width / 2, height / 2, 256, 380);
	
	noFill();
	strokeWeight(4);
	stroke(random(0, 360), 128, 256, 1);
	
	bezier(random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height));
	
	int r = random(8, width);
	ellipse(width / 2, height / 2, r, r);
	/*
	float r = random();
	if (r > 1.0 - 0.33) {
		line(0, random(0, height), width, random(0, height));
	} else if (r > 1.0 - 0.33*2) {
		line(random(0, width), 0, random(0, width), height);
	} else {
		line(0, random(0, height), width, random(0, height));
		line(random(0, width), 0, random(0, width), height);
	}*/
	
	//line(width / 2, height / 1.5, width / 16 - 28, height);
	//line(width / 16 - 28, height / 2.5, width, height);
	//line(width / 2, height / 8.5, width / 16 - 28, height);
}

void draw() {
  draw_func();
}"
"719598","les motifs 3","mySketch","// same as les motifs but the pattern is randomized and is shorter, more symmetry

float xmotion = 0.0;
float ymotion = 0.0;

float[] pattern = {
1.0, 1.0, 1.0,
1.0, 0.0, 1.0,
1.0, 1.0, 1.0,
	
0.0, 0.0, 0.0,
0.0, 1.0, 0.0,
0.0, 0.0, 0.0,
	
0.1, 0.1, 0.1,
0.1, 0.0, 0.1,
0.1, 0.1, 0.1,
	
0.0, 0.0, 0.0,
0.0, 0.1, 0.0,
0.0, 0.0, 0.0,
};

int f = 0;
void poke(int h, int x, int y, int sign) {
	int stax = 0;
	int sizx = 4;
	int offx = x;
	for (int xx = 0; xx < sizx; xx += 1) {
		int stay = 0;
		int sizy = 4;
		int offy = y;
		for (int yy = 0; yy < sizy; yy += 1) {
			float px = pattern[(xx%3) + (yy%3) * 3 + 4 * f];
			
			if (px) {
				fill(h + abs(sin(PI * 2 + px * 8)) * 2, 0, 255, 128);

				rect(offx + xx + stax, offy + yy + stay, 1, 1);
				rect(width - offx + xx + stax, offy + yy + stay, 1, 1);
				rect(width - offx + xx + stax, height - offy + yy + stay, 1, 1);
				rect(width - offx + xx + stax, height - offy + yy + stay, 1, 1);
			}
		}
	}
}

void draw_func() {
	noStroke();
	noFill();
	
	loadPixels();
	for (int y = 0; y < height; y += 2) {
		int yy = y * width;
		for (int x = 0; x < width; x += 2) {
			color p = pixels[yy + x];
			
			if (brightness(p) > 1 && brightness(p) < 128) {
				int h = hue(p);
				
				poke(h, x, y, 0);
			}
		}
	}
	
	f += 1;
	f %= 8;
	
	xmotion += 0.01;
	ymotion += 0.1;
	/*
	noFill();
	strokeWeight(256);
	stroke(0, 0, 0, 256);
	
	int w = 256;
	int h = 256;
	
	ellipse(width / 2, height / 2, 256 * 3.25, 380 * 2.5);*/
}

void setup() {
  size(800, 800);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	frameRate(30);
	
	noiseDetail(9,0.65);
	
	mouseClicked();
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	//smooth();
}

void mouseClicked() {
	background(0);
	
	noStroke();
	fill(32, 128, 256, 1);
	
	int w = 256;
	int h = 256;
	
	//ellipse(width / 2, height / 2, 256, 380);
	
	noFill();
	strokeWeight(4);
	stroke(random(0, 360), 128, 256, 1);
	
	bezier(random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height));
	
	int r = random(8, width);
	ellipse(width / 2, height / 2, r, r);
	
	for (int i = 0; i < 9 * 4; i += 1) {
		pattern[i] = round(random(0, 1));
	}
	/*
	float r = random();
	if (r > 1.0 - 0.33) {
		line(0, random(0, height), width, random(0, height));
	} else if (r > 1.0 - 0.33*2) {
		line(random(0, width), 0, random(0, width), height);
	} else {
		line(0, random(0, height), width, random(0, height));
		line(random(0, width), 0, random(0, width), height);
	}*/
	
	//line(width / 2, height / 1.5, width / 16 - 28, height);
	//line(width / 16 - 28, height / 2.5, width, height);
	//line(width / 2, height / 8.5, width / 16 - 28, height);
}

void draw() {
  draw_func();
}"
"715407","Oriental","mySketch","/**
  * fun with Andres circle
	*/

// https://iquilezles.org/www/articles/palettes/palettes.htm
float pal(float t, float a, float b, float c, float d) {
    return a + b*cos( 6.28318*(c*t+d) );
}

float xmotion = 8.8;
float ymotion = 2.2;

void andres_circle(int x_centre, int y_centre, int r, float t) {
	int x = 0;
	int y = r;
	int d = r - 1;
	
	while (y >= x) {
		float pa = 0.5;
		float pb = 0.5;
		float pc = 8;
		
		float pdr = 0;
		float pdg = 0.1;
		float pdb = 0.2;
		
		float rf = pal((1.0 / 8 * 4 + t) % 1, pa, pb, pc, pdr);
		float gf = pal((1.0 / 8 * 4 + t) % 1, pa, pb, pc, pdg);
		float bf = pal((1.0 / 8 * 4 + t) % 1, pa, pb, pc, pdb);
		
		fill(rf * 256, gf * 256, bf * 256, 255);
		rect(x_centre + x, y_centre + y, 1, 1);
		
		float rf = pal((1.0 / 8 * 3 + t) % 1, pa, pb, pc, pdr);
		float gf = pal((1.0 / 8 * 3 + t) % 1, pa, pb, pc, pdg);
		float bf = pal((1.0 / 8 * 3 + t) % 1, pa, pb, pc, pdb);
		
		fill(rf * 256, gf * 256, bf * 256, 255);
		rect(x_centre + y, y_centre + x, 1, 1);
	
		float rf = pal((1.0 / 8 * 5 + t) % 1, pa, pb, pc, pdr);
		float gf = pal((1.0 / 8 * 5 + t) % 1, pa, pb, pc, pdg);
		float bf = pal((1.0 / 8 * 5 + t) % 1, pa, pb, pc, pdb);
		
		fill(rf * 256, gf * 256, bf * 256, 255);
		rect(x_centre - x, y_centre + y, 1, 1);
		
		float rf = pal((1.0 / 8 * 6 + t) % 1, pa, pb, pc, pdr);
		float gf = pal((1.0 / 8 * 6 + t) % 1, pa, pb, pc, pdg);
		float bf = pal((1.0 / 8 * 6 + t) % 1, pa, pb, pc, pdb);
		
		fill(rf * 256, gf * 256, bf * 256, 255);
		rect(x_centre - y, y_centre + x, 1, 1);
		
		float rf = pal((1.0 / 8 * 1 + t) % 1, pa, pb, pc, pdr);
		float gf = pal((1.0 / 8 * 1 + t) % 1, pa, pb, pc, pdg);
		float bf = pal((1.0 / 8 * 1 + t) % 1, pa, pb, pc, pdb);
		
		fill(rf * 256, gf * 256, bf * 256, 255);
		rect(x_centre + x, y_centre - y, 1, 1);
		
		float rf = pal((1.0 / 8 * 2 + t) % 1, pa, pb, pc, pdr);
		float gf = pal((1.0 / 8 * 2 + t) % 1, pa, pb, pc, pdg);
		float bf = pal((1.0 / 8 * 2 + t) % 1, pa, pb, pc, pdb);
		
		fill(rf * 256, gf * 256, bf * 256, 255);
		rect(x_centre + y, y_centre - x, 1, 1);
		
		float rf = pal((1.0 / 8 * 8 + t) % 1, pa, pb, pc, pdr);
		float gf = pal((1.0 / 8 * 8 + t) % 1, pa, pb, pc, pdg);
		float bf = pal((1.0 / 8 * 8 + t) % 1, pa, pb, pc, pdb);
		
		fill(rf * 256, gf * 256, bf * 256, 255);
		rect(x_centre - x, y_centre - y, 1, 1);
	
		float rf = pal((1.0 / 8 * 7 + t) % 1, pa, pb, pc, pdr);
		float gf = pal((1.0 / 8 * 7 + t) % 1, pa, pb, pc, pdg);
		float bf = pal((1.0 / 8 * 7 + t) % 1, pa, pb, pc, pdb);
		
		fill(rf * 256, gf * 256, bf * 256, 255);
		rect(x_centre - y, y_centre - x, 1, 1);
		
		float v = (r * t + 1);

		if (d >= 2 * x) { 
			d = d - v * x - v;
			x = x + v / 2;
		} else if (d < 2 * (r - y)) {
			d = d + v * y - v;
			y = y - v / 2;
		} else { 
			d = d + v * (y - x - v);
			y = y - v / 2;
			x = x + v / 2;
		}
	}
}

void draw_func() {
	noStroke();
	
  fill(0, 0, 0, 12);
  rect(0, 0, width, height);

	//stroke(255, 255, 255, 255);

	int centered_rect_size = 128;
	
	// circles
	int count = 64;
	
	for (int i = 0; i < count; i += 1) {
		float norm_i = i / count;
		
		andres_circle(width / 2, height / 2, norm_i * 100 * (cos(xmotion * 8 + norm_i * PI * 2)), norm_i * abs(cos(ymotion + norm_i * PI * 2)));
		andres_circle(width / 2, height / 2, 200 + norm_i * 100 * (cos(xmotion * 8 + norm_i * PI * 2)), norm_i * abs(cos(ymotion + norm_i * PI * 2)));
		andres_circle(width / 2, height / 2, 200 + norm_i * 100 * (1 - cos(xmotion * 8 + norm_i * PI * 2)), 1 - norm_i * abs(cos(ymotion + norm_i * PI * 2)));
	}
	
	xmotion += 0.005;
	ymotion += 0.0025;
}

void setup() {
  size(800, 800);

  frameRate(60); 

  background(0);
	
	smooth();
}

void draw() {
  //background(0);

  draw_func();
}"
"706032","Collines","mySketch","float xmotion = 8.8;
float ymotion = 2.2;

int reset = 0;

void draw_func() {	
	noStroke();
	noFill();
	
	strokeWeight(1);
	
	ellipseMode(CENTER);
	rectMode(CENTER);
	
	loadPixels();
	for (int y = 0; y < height; y += 2) {
		int yy = y * width;
		for (int x = 0; x < width; x += 2) {
			color p = pixels[yy + x];
			
			float br = 128 - (frameCount - reset) * 1.25;
			
			if (brightness(p) > 0 && brightness(p) < br) {
				float normx = (float)x / width;
				float normy = (float)y / height;
				float anormx = abs(0.5 - normx) * 2;
				float anormy = abs(0.5 - normy) * 2;
				
				float ianormi = (anormx * anormy) / 2;
				
				float ianorm = (anormx / 4 + (anormy)) / 2;
				float d = ianorm;
				
				//ianorm /= 2;
/*
				if ((x|y) % (width / 2) > (width / 3)) {
					d = ianorm / 1;
				}
*/

				float n = (0.5 - noise(anormx + xmotion, anormy + ymotion)) * 16;
				
				fill(192 + abs(n * 360 + d * 360) % 32, 8 + abs(n * 8), 128 + random(192, 255) * d, random(2, 24) * (0.4975 + d));
				stroke(192 + abs(n * 360 + d * 360) % 48, 128, 128, 1 + abs(cos(xmotion * PI * 2 + d * PI * 2) * 128) * ianorm);
				
				ellipse(x + n * 2 - 1, y + n * 2 - 1, 1 + abs(d * 48) * ianorm, 1 + abs(d * 48) * ianorm);
			}
		}
	}

	xmotion += 0.075;
	ymotion += 0.05;
}

void setup() {
  size(600, 600);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	mouseClicked();

	//smooth();
}

void mouseClicked() {
	background(0);
	
	strokeWeight(1);
	
	noFill();
	
	stroke(0, 0, 256, 1);
	
	for (float i = 0; i < 1; i += 0.25) {
		float x = width / (2 + random(0.05)) + width * sin(i * PI * 2);
		float y = height / (2 + random(0.05)) + height * cos(i * PI * 2);
		float x2 = width / (2 + random(0.05)) + width * sin(i * PI * 2 + PI);
		float y2 = height / (2 + random(0.05)) + height * cos(i * PI * 2 + PI);
		
		/*triangle(random(0, width), random(0, height),
						 random(0, width), random(0, height),
						 random(0, width), random(0, height));*/
		
		//line(x, y, x2, y2);
		bezier(random(0, width), random(0, height), random(0, width), random(0, height), random(0, width), random(0, height), random(0, width), random(0, height));
	}
	
	reset = frameCount;
}

void draw() {
  draw_func();
}"
"706032","Collines","mySketch","float xmotion = 8.8;
float ymotion = 2.2;

int reset = 0;

void draw_func() {	
	noStroke();
	noFill();
	
	strokeWeight(1);
	
	ellipseMode(CENTER);
	rectMode(CENTER);
	
	loadPixels();
	for (int y = 0; y < height; y += 2) {
		int yy = y * width;
		for (int x = 0; x < width; x += 2) {
			color p = pixels[yy + x];
			
			float br = 128 - (frameCount - reset) * 1.25;
			
			if (brightness(p) > 0 && brightness(p) < br) {
				float normx = (float)x / width;
				float normy = (float)y / height;
				float anormx = abs(0.5 - normx) * 2;
				float anormy = abs(0.5 - normy) * 2;
				
				float ianormi = (anormx * anormy) / 2;
				
				float ianorm = (anormx / 4 + (anormy)) / 2;
				float d = ianorm;
				
				//ianorm /= 2;
/*
				if ((x|y) % (width / 2) > (width / 3)) {
					d = ianorm / 1;
				}
*/

				float n = (0.5 - noise(anormx + xmotion, anormy + ymotion)) * 16;
				
				fill(192 + abs(n * 360 + d * 360) % 32, 8 + abs(n * 8), 128 + random(192, 255) * d, random(2, 24) * (0.4975 + d));
				stroke(192 + abs(n * 360 + d * 360) % 48, 128, 128, 1 + abs(cos(xmotion * PI * 2 + d * PI * 2) * 128) * ianorm);
				
				ellipse(x + n * 2 - 1, y + n * 2 - 1, 1 + abs(d * 48) * ianorm, 1 + abs(d * 48) * ianorm);
			}
		}
	}

	xmotion += 0.075;
	ymotion += 0.05;
}

void setup() {
  size(600, 600);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	mouseClicked();

	//smooth();
}

void mouseClicked() {
	background(0);
	
	strokeWeight(1);
	
	noFill();
	
	stroke(0, 0, 256, 1);
	
	for (float i = 0; i < 1; i += 0.25) {
		float x = width / (2 + random(0.05)) + width * sin(i * PI * 2);
		float y = height / (2 + random(0.05)) + height * cos(i * PI * 2);
		float x2 = width / (2 + random(0.05)) + width * sin(i * PI * 2 + PI);
		float y2 = height / (2 + random(0.05)) + height * cos(i * PI * 2 + PI);
		
		/*triangle(random(0, width), random(0, height),
						 random(0, width), random(0, height),
						 random(0, width), random(0, height));*/
		
		//line(x, y, x2, y2);
		bezier(random(0, width), random(0, height), random(0, width), random(0, height), random(0, width), random(0, height), random(0, width), random(0, height));
	}
	
	reset = frameCount;
}

void draw() {
  draw_func();
}"
"706027","Through","mySketch","float xmotion = 8.8;
float ymotion = 2.2;

int reset = 0;

void draw_func() {	
	noStroke();
	noFill();
	
	strokeWeight(1);
	
	ellipseMode(CENTER);
	rectMode(CENTER);
	
	loadPixels();
	for (int y = 0; y < height; y += 2) {
		int yy = y * width;
		for (int x = 0; x < width; x += 2) {
			color p = pixels[yy + x];
			
			float br = 128 - (frameCount - reset) * 1.05;
			
			if (brightness(p) > 0 && brightness(p) < br) {
				float normx = (float)x / width;
				float normy = (float)y / height;
				float anormx = abs(0.5 - normx) * 2;
				float anormy = abs(0.5 - normy) * 2;
				
				float ianormi = (anormx * anormy) / 2;
				
				float ianorm = (anormx + anormy) / 2 * (0.1+abs(sin(anormx * PI * 4 * (1-ianormi))) + (0.25 * ianormi) * anormy);
				float d = ianorm;
				
				ianorm /= 2;
/*
				if ((x|y) % (width / 2) > (width / 8)) {
					d = ianorm / 1;
				}
*/

				float n = (0.5 - noise(anormx + xmotion, anormy + ymotion)) * 8;
				
				fill(192 + abs(n * 360 + d * 360) % 32, 8 + abs(n * 8), 128 + random(192, 255) * d, random(2, 24) * (0.4975 + d));
				stroke(192 + abs(n * 360 + d * 360) % 48, 128, 128, 1 + abs(cos(xmotion * PI * 2 + d * PI * 2) * 128) * ianorm);
				
				ellipse(x + n * 2 - 1, y + n * 2 - 1, 1 + abs(d * 48) * ianorm, 1 + abs(d * 48) * ianorm);
			}
		}
	}
	
	strokeWeight(16);
	stroke(0, 0, 0, 255);
	for (int x = 0; x < 64; x += 1) {
		float n = (0.5 - noise((float)x / 64 * 8)) * 64;
		
		line(x * (width / 64), height / 2 + n, x * (width / 64) + width / 64, height / 2 + n);
	}

	xmotion += 0.075;
	ymotion += 0.05;
}

void setup() {
  size(600, 600);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	mouseClicked();

	//smooth();
}

void mouseClicked() {
	background(0);
	
	strokeWeight(2);
	
	noFill();
	
	stroke(0, 0, 256, 1);
	
	for (float i = 0; i < 1; i += 0.25) {
		float x = width / (2 + random(0.05)) + width * sin(i * PI * 2);
		float y = height / (2 + random(0.05)) + height * cos(i * PI * 2);
		float x2 = width / (2 + random(0.05)) + width * sin(i * PI * 2 + PI);
		float y2 = height / (2 + random(0.05)) + height * cos(i * PI * 2 + PI);
		
		/*triangle(random(0, width), random(0, height),
						 random(0, width), random(0, height),
						 random(0, width), random(0, height));*/
		
		//line(x, y, x2, y2);
		bezier(random(0, width), random(0, height), random(0, width), random(0, height), random(0, width), random(0, height), random(0, width), random(0, height));
	}
	
	reset = frameCount;
}

void draw() {
  draw_func();
}"
"705851","Dissolve","mySketch","
float xmotion = 8.8;
float ymotion = 2.2;

float f = 0;

float MIX_ALPHA(float F ,float B,float A) {
  return ((F * A + B * (1.f - A)));
}

void fake_antialiased_rect(float x, float y, float w, float h, float b, float a, float hu) {
  float w2 = w / 2;
  float h2 = h / 2;
  
  //float b1 = b * 1.5;//* 1.965;
  
  for (float yy = 0; yy < h; yy += 2) {
    int yw = (int)constrain(((yy + (y - h2)-0.5)), 0, height-1) * width;
    int yw2 = (int)constrain(((yy + (y - h2+1)-0.5)), 0, height-1) * width;
    //int yw1 = abs((yy + round(y - h2) - 1)%height) * width;
    //int yw2 = abs((yy + round(y - h2) + 1)%height) * width;
    //int yw3 = abs((yy + round(y - h2) + 2)%height) * width;
    //int yw4 = abs((yy + round(y - h2) - 2)%height) * width;
    float g = 0;
    for (float xx = 0; xx < w; xx += 2) {
      //float normx = (float)xx / w;
      //float anorm_x = abs(0.5 - normx) * 2;
      int pxi = (int)(yw + constrain(((x - w2) + xx), 0, width-1));
      int pxi2 = (int)(yw2 + constrain(((x - w2) + xx), 0, width-1));
      float pc = brightness(pixels[pxi]);
      float bb = MIX_ALPHA(b, pc*2, a*8);
      float pc2 = brightness(pixels[pxi2]);
      float bb2 = MIX_ALPHA(b /4, pc2, a*0.9475);
      //b = random(b - 1, b + 1);
      //pixels[yw1 + (abs(round(x - w2) + xx)%width)] = color(hu, 128,b1 ,1);//color(0, 0, 0,64);
      pixels[pxi] = color(hu, 128, bb);
      pixels[pxi2] = color(hu, 128, bb2);
      //pixels[yw2 + (abs(round(x - w2) + xx)%width)] = color(hu,128, b1 ,1);
      //pixels[yw3 + (abs(round(x - w2) + xx)%width)] = color(hu,128, b1, 1);
      //pixels[yw4 + (abs(round(x - w2) + xx)%width)] = color(hu, 128,b1 ,1);
      
      g += 2;
      g %= 4;
    }
  }
}

void draw_func() {
  /*if ((frameCount % 160) == 0) {
    background(0);
  }*/
  
  noStroke();
  
  noStroke();
  rectMode(CENTER);
  
  loadPixels();
  int ss = 2;
  for (int y = 0; y < height; y += 1) {
    int yy = y * width;
    for (int x = 0; x < width; x += 1) {
      color p = pixels[yy + x];
      
      float bright = brightness(p);
      
      if (bright > 0 && bright < 256 && random() > 0.5) {
        float v = (1-(pow(f, 1.1) / 360));
        
        
        float hh = /*0.5 + */hue(p) /*+ abs(cos(v * PI * 2 + xmotion)) / 2.05*/;
        float al = 28 / 255.0;
        fill(hh, 128, 256, 1);
        //float sss = sin((float)x/width+xmotion/8)*2;
        //float sss2 = cos((float)y/height+ymotion/8)*2;
        fake_antialiased_rect(x+1+random(-1, 1), y+1+random(-1, 1), 1, 1, 255, al*1.05, hh);//b/1.015, hue(p)+1);
//fake_antialiased_rect(width - (x+1+random(-1, 1)), height - y, 1, 3, 256, al, hh);
        //fake_antialiased_rect(x, height - y, ss, ss, b*1.25, hue(p));
        
        //rect(x+random(-1, 1), height - y, 2, 2);
        //rect(width - (x+random(-1, 1)),height - y, 1, 1);
        
//rect(width - x + random(-1, 1), y + random(-1, 1), 4, 4);
      }
    }
  }
  updatePixels();
  
  //fill(0, 0, 0, 255);
  //ellipse(random(0, width), random(0, height), 80, 80);
  
  noFill();
  noStroke();
  strokeWeight(1);
  
  rectMode(CENTER);
/*
  for (int i = 1; i < 8; i += 2) {
    float norm_i = 1-((float)(i - 1) / 8);
    
    stroke((frameCount % 2) * 192, 128 * norm_i, 255 * norm_i, 1);

    int sw = width/2 / (i*2) + (int)abs(cos(ymotion/2) * 92);
    int sh = height/2 / (i*2)+ (int)abs(sin(xmotion/2) * 92);
    
    if (i % 2 == 0) {
      //ellipse(width / 2, height / 2, sw, sh);
      ellipse(width / 2, height, sw, sh);
      ellipse(width / 2, 0, sw, sh);
      //ellipse(0, height, sw, sh);
      //ellipse(width, height, sw, sh);
    } else {
      rect(width / 2, height / 2, sw, sh);
      //rect(width / 2, height, sw/2, sh/2);
      //rect(width / 2, 0, sw/2, sh/2);
      //rect(width, height / 2, sw, sh);
      //rect(0, height / 2, sw, sh);
    }
  }
  rectMode(CORNER);
  */
  
  strokeWeight(32);
  stroke(64, 192, 255,32);
  //line(width /3, height/1.4, width - width /3, height/1.4);
  arc(width /2, height/1.4, width / 3.5, 8 + abs(sin(xmotion / 80) * 80), 0, PI);
  strokeWeight(1);
  stroke(64, 192, 255, 8);
  ellipse(width /2, height/2, width/1.25,height/1.25);
  stroke(128, 192, 255, 80);
  fill(0, 192, 255, random(1, 3));
  strokeWeight(2);
  ellipse(width /3, height/2.25, width/4.75,width/4.75);
  ellipse(width - width /3, height/2.25, width/4.5,width/4);
  noFill();
  noStroke();
  fill(0, 0, 0, 8);
  //ellipse(width /2, height*1.175, width/1.5,height/1.5);
  fill(254, 192, 256, 5);
  ellipse(width /2, height/2, width/1.25,height/1.25);
  noFill();
  f += 1;
  
  //tint(0,0, 255, 16);
  //image(img, 0, 0);

  xmotion +=0.4;
  ymotion += 0.1;
}

void setup() {
  size(400, 400);

  background(0);
  
  colorMode(HSB, 360, 256, 256, 255);
    fill(256, 128, 64, 10);
  textAlign(CENTER,CENTER);
  textSize(364);
  //text(""Hello World"", width /2, height / 2);
  rectMode(CENTER);
  fill(0, 0, 256, 120);
  noStroke();
  //noFill();
  //rect(width / 2, height /2, 64, 64);

  frameRate(30);
  
  noSmooth();
  //smooth(0);
}

void draw() {
  draw_func();
}"
"704336","Flower","mySketch","float xmotion = 8.8;
float ymotion = 2.2;

int reset = 0;

void draw_func() {	
	noStroke();
	noFill();
	
	strokeWeight(2);
	
	ellipseMode(CENTER);
	rectMode(CENTER);
	
	loadPixels();
	for (int y = 0; y < height; y += 2) {
		int yy = y * width;
		for (int x = 0; x < width; x += 2) {
			color p = pixels[yy + x];
			
			float br = 128 - (frameCount - reset) * 12;
			
			if (brightness(p) > 0 && brightness(p) < br) {
				float normx = (float)x / width;
				float normy = (float)y / height;
				float anormx = abs(0.5 - normx) * 2;
				float anormy = abs(0.5 - normy) * 2;
				
				float n = (0.5 - noise(anormx + xmotion, anormy + ymotion)) * 9;
				float n2 = (0.5 - noise(anormy + xmotion, anormx + ymotion)) * 4;
				
				float ianorm = ((abs(1 - (cos(anormx * PI * (PI / 2)) * abs(cos(anormy * PI * (PI / (2 - sin(anormx * PI * 1.5)))))))) % (0.4+abs(sin(anormx * anormy * PI * 2)))) * 2;
				float d = ianorm;
				
				ianorm *= 0.25;
				
				fill(24 + abs(n * 16 + d * 8) % 128, 8 + abs(n * 64), 128 + random(192, 255) * d, random(8, 24) * (0.15 + d));
				stroke(264+abs(n * 8 + d * 128), 128, 128, 1 + abs(cos(xmotion * PI * 2 + d * PI * 2) * 48 * ianorm));
				
				ellipse(x + (n * 8) * ianorm - 1, y + (n2 * 8) * ianorm - 1, 1 + abs(d * 8), 1 + abs(d * 8));
			}
		}
	}

	xmotion += 1.7;
	ymotion += 1.05;
}

void setup() {
  size(600, 600);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	mouseClicked();

	//smooth();
}

void mouseClicked() {
	background(0);
	
	strokeWeight(2);
	
	noFill();
	
	stroke(0, 0, 255, 16);
	
	for (float i = 0; i < 1; i += 0.025) {
		bezier(random(0, width), random(0, height), random(0, width), random(0, height), random(0, width), random(0, height), random(0, width), random(0, height));
	}
	
	reset = frameCount;
}

void draw() {
  draw_func();
}"
"704254","Column","mySketch","float xmotion = 8.8;
float ymotion = 2.2;

int reset = 0;

void draw_func() {	
	noStroke();
	noFill();
	
	strokeWeight(1);
	
	ellipseMode(CENTER);
	rectMode(CENTER);
	
	loadPixels();
	for (int y = 0; y < height; y += 2) {
		int yy = y * width;
		for (int x = 0; x < width; x += 2) {
			color p = pixels[yy + x];
			
			float br = 192 - (frameCount - reset) * 12;
			
			if (brightness(p) > 0 && brightness(p) < br) {
				float normx = (float)x / width;
				float normy = (float)y / height;
				float anormx = abs(0.5 - normx) * 1;
				float anormy = abs(0.5 - normy) * 1;
				
				float n = (0.5 - noise(anormx + xmotion, anormy + ymotion)) * 9;
				float n2 = (0.5 - noise(anormy + xmotion, anormx + ymotion)) * 5;
				
				float ianorm = ((abs(((0.5-(anormx * PI % (PI / 1.5))) % abs(0.5-(cos(anormy * PI * 1.5) * anormy * PI % (PI / 1.5))/(1.01 + cos(anormx * anormy * PI * 8)))))) % 0.5) * 2;
				float d = ianorm;
				
				ianorm *= 1.25;
				
				fill(abs(n * 64 + d * 128) % 64, 8 + abs(n * 92), 128 + random(192, 255) * d, random(8, 24) * (0.5 + d));
				stroke(128+abs(n * 8 + d * 128 + ianorm * 360), 128, 128, 1 + abs(cos(xmotion * PI * 2 + d * PI * 2) * 32 * ianorm));
				
				ellipse(x + (n * 8) * ianorm - 1, y + (n2 * 8) * ianorm - 1, 1 + abs(d * 8), 1 + abs(d * 8));
			}
		}
	}

	xmotion += 0.07;
	ymotion += 0.05;
}

void setup() {
  size(600, 600);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	mouseClicked();

	//smooth();
}

void mouseClicked() {
	background(0);
	
	strokeWeight(1);
	
	noFill();
	
	stroke(0, 0, 255, 1);
	
	for (float i = 0; i < 1; i += 0.001) {
		bezier(random(0, width), random(0, height), random(0, width), random(0, height), random(0, width), random(0, height), random(0, width), random(0, height));
	}
	
	reset = frameCount;
}

void draw() {
  draw_func();
}"
"703066","Glass","mySketch","float xmotion = 8.8;
float ymotion = 2.2;

int reset = 0;

void draw_func() {	
	noStroke();
	noFill();
	
	strokeWeight(1);
	
	ellipseMode(CENTER);
	rectMode(CENTER);
	
	loadPixels();
	for (int y = 0; y < height; y += 2) {
		int yy = y * width;
		for (int x = 0; x < width; x += 2) {
			color p = pixels[yy + x];
			
			float br = 192 - (frameCount - reset) * 12;
			
			if (brightness(p) > 0 && brightness(p) < br) {
				float normx = (float)x / width;
				float normy = (float)y / height;
				float anormx = abs(0.5 - normx) * 2;
				float anormy = abs(0.5 - normy) * 2;
				
				float n = (0.5 - noise(anormx + xmotion, anormy + ymotion)) * 9;
				float n2 = (0.5 - noise(anormy + xmotion, anormx + ymotion)) * 5;
				
				float ianorm = ((abs(((1-(anormx * PI * 1 % (PI / 2.0125))) * (1-(anormy * PI * 1 % (PI / 2.0125)))))) % 0.25) * 4;
				float d = ianorm;
				
				ianorm *= 1.25;
				
				fill(abs(n * 360 + d * 360) % 64, 8 + abs(n * 92), 128 + random(192, 255) * d, random(8, 24) * (0.25 + d));
				stroke(128+abs(n * 8 + d * 32 + ianorm * 360), 128, 128, 1 + abs(cos(xmotion * PI * 2 + d * PI * 2) * 32 * ianorm));
				
				ellipse(x + (n * 4 - 8) * ianorm, y + (n2 * 4 - 8) * ianorm, 1 + abs(d * 8), 1 + abs(d * 8));
			}
		}
	}

	xmotion += 1.7;
	ymotion += 1.05;
}

void setup() {
  size(600, 600);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	mouseClicked();

	//smooth();
}

void mouseClicked() {
	background(0);
	
	strokeWeight(1);
	
	noFill();
	
	stroke(0, 0, 255, 32);
	
	for (float i = 0; i < 1; i += 0.025) {
		bezier(random(0, width), random(0, height), random(0, width), random(0, height), random(0, width), random(0, height), random(0, width), random(0, height));
	}
	
	reset = frameCount;
}

void draw() {
  draw_func();
}"
"703009","Donut","mySketch","float xmotion = 8.8;
float ymotion = 2.2;

int reset = 0;

void draw_func() {	
	noStroke();
	noFill();
	
	strokeWeight(1);
	
	ellipseMode(CENTER);
	rectMode(CENTER);
	
	loadPixels();
	for (int y = 0; y < height; y += 2) {
		int yy = y * width;
		for (int x = 0; x < width; x += 2) {
			color p = pixels[yy + x];
			
			float br = 192 - (frameCount - reset) * 12;
			
			if (brightness(p) > 0 && brightness(p) < br) {
				float normx = (float)x / width;
				float normy = (float)y / height;
				float anormx = abs(0.5 - normx) * 2;
				float anormy = abs(0.5 - normy) * 2;
				
				float n = (0.5 - noise(anormx + xmotion, anormy + ymotion)) * 9;
				float n2 = (0.5 - noise(anormy + xmotion, anormx + ymotion)) * 4;
				
				float ianorm = ((abs((cos(anormx * PI * 1 % (PI / 2.25)) * cos(anormy * PI * 1 % (PI / 2.25))))) % 0.75) * 2;
				float d = ianorm;
				
				ianorm *= 0.25;
				
				fill(24 + abs(n * 360 + d * 360) % 48, 8 + abs(n * 64), 128 + random(192, 255) * d, random(8, 24) * (0.25 + d));
				stroke(abs(n * 8 + d * 128), 128, 128, 1 + abs(cos(xmotion * PI * 2 + d * PI * 2) * 24 * ianorm));
				
				ellipse(x + (n * 8 - 8) * ianorm, y + (n2 * 8 - 8) * ianorm, 1 + abs(d * 8), 1 + abs(d * 8));
			}
		}
	}

	xmotion += 1.7;
	ymotion += 1.05;
}

void setup() {
  size(600, 600);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	mouseClicked();

	//smooth();
}

void mouseClicked() {
	background(0);
	
	strokeWeight(2);
	
	noFill();
	
	stroke(0, 0, 255, 32);
	
	for (float i = 0; i < 1; i += 0.025) {
		bezier(random(0, width), random(0, height), random(0, width), random(0, height), random(0, width), random(0, height), random(0, width), random(0, height));
	}
	
	reset = frameCount;
}

void draw() {
  draw_func();
}"
"702994","Ancient","mySketch","float xmotion = 8.8;
float ymotion = 2.2;

int reset = 0;

void draw_func() {	
	noStroke();
	noFill();
	
	strokeWeight(1);
	
	ellipseMode(CENTER);
	rectMode(CENTER);
	
	loadPixels();
	for (int y = 0; y < height; y += 2) {
		int yy = y * width;
		for (int x = 0; x < width; x += 2) {
			color p = pixels[yy + x];
			
			float br = 192 - (frameCount - reset) * 16;
			
			if (brightness(p) > 0 && brightness(p) < br) {
				float normx = (float)x / width;
				float normy = (float)y / height;
				float anormx = abs(0.5 - normx) * 2;
				float anormy = abs(0.5 - normy) * 2;
				
				float ianorm = ((abs(1-(cos(anormx * PI * 2) * sin(anormy * PI * 2)))) % 0.25) * 4;
				float d = ianorm;
				
				ianorm *= 0.25;
				
				float n = (0.5 - noise(anormx + xmotion, anormy + ymotion)) * 8;
				float n2 = (0.5 - noise(anormy + xmotion, anormx + ymotion)) * 4;
				
				fill(192 + abs(n * 360 + d * 360) % 48, 8 + abs(n * 64), 128 + random(192, 255) * d, random(8, 24) * (0.25 + d));
				stroke(abs(n * 8 + d * 128), 128, 128, 1 + abs(cos(xmotion * PI * 2 + d * PI * 2) * 32 * ianorm));
				
				ellipse(x + (n * 8 - 8) * ianorm, y + (n2 * 8 - 8) * ianorm, 1 + abs(d * 8), 1 + abs(d * 8));
			}
		}
	}

	xmotion += 1.7;
	ymotion += 1.05;
}

void setup() {
  size(600, 600);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	mouseClicked();

	//smooth();
}

void mouseClicked() {
	background(0);
	
	strokeWeight(2);
	
	noFill();
	
	stroke(0, 0, 255, 32);
	
	for (float i = 0; i < 1; i += 0.025) {
		bezier(random(0, width), random(0, height), random(0, width), random(0, height), random(0, width), random(0, height), random(0, width), random(0, height));
	}
	
	reset = frameCount;
}

void draw() {
  draw_func();
}"
"702989","Prisme","mySketch","float xmotion = 8.8;
float ymotion = 2.2;

int reset = 0;

void draw_func() {	
	noStroke();
	noFill();
	
	strokeWeight(1);
	
	ellipseMode(CENTER);
	rectMode(CENTER);
	
	loadPixels();
	for (int y = 0; y < height; y += 2) {
		int yy = y * width;
		for (int x = 0; x < width; x += 2) {
			color p = pixels[yy + x];
			
			float br = 192 - (frameCount - reset) * 12;
			
			if (brightness(p) > 0 && brightness(p) < br) {
				float normx = (float)x / width;
				float normy = (float)y / height;
				float anormx = abs(0.5 - normx) * 2;
				float anormy = abs(0.5 - normy) * 2;
				
				float ianorm = (((1-(anormx + anormy))) % 0.5) * 3;
				float d = ianorm;
				
				ianorm *= 1.25;
				
				float n = (0.5 - noise(anormx + xmotion, anormy + ymotion)) * 6;
				float n2 = (0.5 - noise(anormy + xmotion, anormx + ymotion)) * 6;
				
				fill(224 + abs(n * 360 + d * 360) % 32, 8 + abs(n * 128), 128 + random(192, 255) * d, random(8, 24) * (0.25 + d));
				stroke(abs(n * 8 + d * 128), 128, 128, 1 + abs(cos(xmotion * PI * 2 + d * PI * 2) * 32));
				
				ellipse(x + (n * 8 - 8) * ianorm, y + (n2 * 8 - 8) * ianorm, 1 + abs(d * 8), 1 + abs(d * 8));
			}
		}
	}

	xmotion += 1.7;
	ymotion += 1.05;
}

void setup() {
  size(600, 600);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	mouseClicked();

	//smooth();
}

void mouseClicked() {
	background(0);
	
	strokeWeight(1);
	
	noFill();
	
	stroke(0, 0, 255, 8);
	
	for (float i = 0; i < 1; i += 0.09) {
		bezier(random(0, width), random(0, height), random(0, width), random(0, height), random(0, width), random(0, height), random(0, width), random(0, height));
	}
	
	reset = frameCount;
}

void draw() {
  draw_func();
}"
"702971","Flesh","mySketch","float xmotion = 8.8;
float ymotion = 2.2;

int reset = 0;

void draw_func() {	
	noStroke();
	noFill();
	
	strokeWeight(1);
	
	ellipseMode(CENTER);
	rectMode(CENTER);
	
	loadPixels();
	for (int y = 0; y < height; y += 2) {
		int yy = y * width;
		for (int x = 0; x < width; x += 2) {
			color p = pixels[yy + x];
			
			float br = 192 - (frameCount - reset) * 8;
			
			if (brightness(p) > 0 && brightness(p) < br) {
				float normx = (float)x / width;
				float normy = (float)y / height;
				float anormx = abs(0.5 - normx) * 2;
				float anormy = abs(0.5 - normy) * 2;
				
				float ianorm = (((1-(anormx - anormy)) * 1.25) % 0.25) * 4;
				float d = ianorm;
				
				ianorm *= 2;
				
				float n = (0.5 - noise(anormx + xmotion, anormy + ymotion)) * 8;
				float n2 = (0.5 - noise(anormy + xmotion, anormx + ymotion)) * 8;
				
				fill(16 + abs(n * 360 + d * 360) % 32, 8 + abs(n * 128), 128 + random(192, 255) * d, random(8, 24) * (0.45 + d));
				stroke(abs(n * 8 + d * 32), 128, 128, 1 + abs(cos(xmotion * PI * 2 + d * PI * 2) * 64));
				
				ellipse(x + (n * 64 - 4) * normy, y + (n2 * 32 - 4) * normx, 1 + abs(d * 12), 1 + abs(d * 12));
			}
		}
	}

	xmotion += 1.7;
	ymotion += 1.05;
}

void setup() {
  size(600, 600);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	mouseClicked();

	//smooth();
}

void mouseClicked() {
	background(0);
	
	strokeWeight(1);
	
	noFill();
	
	stroke(0, 0, 255, 8);
	
	for (float i = 0; i < 1; i += 0.0025) {
		bezier(random(0, width), random(0, height), random(0, width), random(0, height), random(0, width), random(0, height), random(0, width), random(0, height));
	}
	
	reset = frameCount;
}

void draw() {
  draw_func();
}"
"702867","Silk 2","mySketch","float xmotion = 8.8;
float ymotion = 2.2;

int reset = 0;

void draw_func() {	
	noStroke();
	noFill();
	
	strokeWeight(1);
	
	ellipseMode(CENTER);
	rectMode(CENTER);
	
	loadPixels();
	for (int y = 0; y < height; y += 2) {
		int yy = y * width;
		for (int x = 0; x < width; x += 2) {
			color p = pixels[yy + x];
			
			float br = 128 - (frameCount - reset) * 32;
			
			if (brightness(p) > 0 && brightness(p) < br) {
				float normx = (float)x / width;
				float normy = (float)y / height;
				float anormx = abs(0.5 - normx) * 3;
				float anormy = abs(0.5 - normy) * 3;
				
				float ianorm = abs(sin(anormx * PI * 1 + xmotion)) * abs(cos(anormy * PI * 1 + ymotion));
				float d = ianorm;
				
				ianorm /= 5;
				
				float n = (0.5 - noise(anormx + xmotion, anormy + ymotion)) * 8;
				float n2 = (0.5 - noise(anormy + xmotion, anormx + ymotion)) * 8;
				
				fill(24 + abs(n * 360 + d * 360) % 32, 8 + abs(n * 128), 128 + random(192, 255) * d, random(8, 24) * (0.45 + d));
				stroke(0, 0, 128, 1 + abs(cos(xmotion * PI * 2 + d * PI * 2) * 24));
				
				ellipse(x + n * 32 - 4, y + n2 * 32 - 4, 1 + abs(d * 48) * ianorm, 1 + abs(d * 48) * ianorm);
			}
		}
	}

	xmotion += 1.7;
	ymotion += 1.05;
}

void setup() {
  size(600, 600);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	mouseClicked();

	//smooth();
}

void mouseClicked() {
	background(0);
	
	strokeWeight(2);
	
	noFill();
	
	stroke(0, 0, 255, 8);
	
	for (float i = 0; i < 1; i += 0.0025) {
		bezier(random(0, width), random(0, height), random(0, width), random(0, height), random(0, width), random(0, height), random(0, width), random(0, height));
	}
	
	reset = frameCount;
}

void draw() {
  draw_func();
}"
"702857","Silk","mySketch","float xmotion = 8.8;
float ymotion = 2.2;

int reset = 0;

void draw_func() {	
	noStroke();
	noFill();
	
	strokeWeight(1);
	
	ellipseMode(CENTER);
	rectMode(CENTER);
	
	loadPixels();
	for (int y = 0; y < height; y += 2) {
		int yy = y * width;
		for (int x = 0; x < width; x += 2) {
			color p = pixels[yy + x];
			
			float br = 128 - (frameCount - reset) * 32;
			
			if (brightness(p) > 0 && brightness(p) < br) {
				float normx = (float)x / width;
				float normy = (float)y / height;
				float anormx = abs(0.5 - normx) * 2;
				float anormy = abs(0.5 - normy) * 2;
				
				float ianorm = abs(sin(anormx * PI * 0.75 + xmotion) + (cos(anormy * PI * 0.9 + ymotion))) * (1 - anormx * anormy) / 2;
				float d = ianorm;
				
				ianorm /= 2;
				
				if ((x|y) % (width / 2) > (width / 3)) {
					d = ianorm / 4;
				}
				
				float n = (0.5 - noise(anormx + xmotion, anormy + ymotion)) * 8;
				
				fill(192 + abs(n * 360 + d * 360) % 32, 8 + abs(n * 92), 128 + random(192, 255) * d, random(8, 24) * (0.5 + d));
				stroke(0, 0, 128, 1 + abs(cos(xmotion * PI * 2 + d * PI * 2) * 24));
				
				ellipse(x + n * 32, y + n * 32, 1 + abs(d * 64) * ianorm, 1 + abs(d * 64) * ianorm);
			}
		}
	}

	xmotion += 0.075;
	ymotion += 0.05;
}

void setup() {
  size(600, 600);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	mouseClicked();

	//smooth();
}

void mouseClicked() {
	background(0);
	
	strokeWeight(1);
	
	noFill();
	
	stroke(0, 0, 255, 4);
	
	for (float i = 0; i < 1; i += 0.00025) {
		float x = width / (2 + random(0.05)) + width * sin(i * PI * 2);
		float y = height / (2 + random(0.05)) + height * cos(i * PI * 2);
		float x2 = width / (2 + random(0.05)) + width * sin(i * PI * 2 + PI);
		float y2 = height / (2 + random(0.05)) + height * cos(i * PI * 2 + PI);
		
		//line(x, y, x2, y2);
		bezier(random(0, width), random(0, height), random(0, width), random(0, height), random(0, width), random(0, height), random(0, width), random(0, height));
	}
	
	reset = frameCount;
}

void draw() {
  draw_func();
}"
"702850","Glimpse","mySketch","float xmotion = 8.8;
float ymotion = 2.2;

int reset = 0;

void draw_func() {	
	noStroke();
	noFill();
	
	strokeWeight(1);
	
	ellipseMode(CENTER);
	rectMode(CENTER);
	
	loadPixels();
	for (int y = 0; y < height; y += 2) {
		int yy = y * width;
		for (int x = 0; x < width; x += 2) {
			color p = pixels[yy + x];
			
			float br = 128 - (frameCount - reset) * 32;
			
			if (brightness(p) > 0 && brightness(p) < br) {
				float normx = (float)x / width;
				float normy = (float)y / height;
				float anormx = abs(0.5 - normx) * 2;
				float anormy = abs(0.5 - normy) * 2;
				
				float ianorm = abs(sin(anormx * PI * 1.25 + xmotion) + (cos(anormy * PI * 1.25 + ymotion))) * (1 - anormx * anormy) / 2;
				float d = ianorm;
				
				ianorm /= 2;
				
				if ((x+y) % (width / 2) > (width / 3)) {
					d = ianorm / 4;
				}
				
				float n = (0.5 - noise(anormx + xmotion, anormy + ymotion)) * 8;
				
				fill(192 + abs(n * 360 + d * 360) % 32, 8 + abs(n * 128), 128 + random(192, 255) * d, random(8, 24) * (0.75 + d));
				stroke(0, 0, 128, 1 + abs(cos(xmotion * PI * 2 + d * PI * 2) * 24));
				
				ellipse(x + n * 32 - 4, y + n * 32 - 4, 1 + abs(d * 48) * ianorm, 1 + abs(d * 48) * ianorm);
			}
		}
	}

	xmotion += 0.075;
	ymotion += 0.05;
}

void setup() {
  size(600, 600);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	mouseClicked();

	//smooth();
}

void mouseClicked() {
	background(0);
	
	strokeWeight(2);
	
	noFill();
	
	stroke(0, 0, 255, 8);
	
	for (float i = 0; i < 1; i += 0.0025) {
		float x = width / (2 + random(0.05)) + width * sin(i * PI * 2);
		float y = height / (2 + random(0.05)) + height * cos(i * PI * 2);
		float x2 = width / (2 + random(0.05)) + width * sin(i * PI * 2 + PI);
		float y2 = height / (2 + random(0.05)) + height * cos(i * PI * 2 + PI);
		
		line(x, y, x2, y2);
		bezier(random(0, width), random(0, height), random(0, width), random(0, height), random(0, width), random(0, height), random(0, width), random(0, height));
	}
	
	reset = frameCount;
}

void draw() {
  draw_func();
}"
"702036","Core","mySketch","float xmotion = 8.8;
float ymotion = 2.2;

void draw_func() {
	noStroke();
	
	loadPixels();
	for (int y = 0; y < height; y += 4) {
		int yy = y * width;
		for (int x = 0; x < width; x += 4) {
			color p = pixels[yy + x];
			
			if (brightness(p) > 0 && brightness(p) < 32) {
				fill(hue(p) * 1.0525, 128, 256, 24);
				
				float n = noise(x / width + xmotion, y / height + ymotion) * 2;
				
				ellipse(x + random(-64, 64) * n, y + random(-64, 64) * n, 92, 92);
			}
		}
	}
	
	noFill();
	noStroke();
  strokeWeight(1);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	for (int i = 1; i < 32; i += 1) {
		float norm_i = 1-((float)(i - 1) / 32);
		
		stroke(32+norm_i * 128, 128, 8 + 64 * norm_i, 32 * norm_i);

		int sw = (float)width/2 / (i / 20) + abs(cos(xmotion + i) * 64);
		int sh = height/2 / (i / 20)+ abs(cos(xmotion + i) * 64);
		
		if (random() > 0.95) {
			rect(width / 2, height / 2, sw, sh);
		} else {
			ellipse(width / 2, height / 2, sw, sh);
		}
	}
	rectMode(CORNERS);

	xmotion += 0.25;
	ymotion += 0.35;
}

void setup() {
  size(800, 800);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	noFill();
	strokeWeight(16);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	frameRate(24);

	rectMode(CORNER);
	ellipseMode(CORNER);
	
	//smooth();
}

void draw() {
  draw_func();
}"
"702033","Path","mySketch","float xmotion = 8.8;
float ymotion = 2.2;

void draw_func() {
	noStroke();
	
	loadPixels();
	for (int y = 0; y < height; y += 4) {
		int yy = y * width;
		for (int x = 0; x < width; x += 4) {
			color p = pixels[yy + x];
			
			if (brightness(p) > 0 && brightness(p) < 32) {
				fill(hue(p) * 1.2525, 128, 255, 48);
				
				float n = noise(x / width, y / height) * 2;
				
				ellipse(x + random(-64, 64) * n, y + random(-64, 64) * n, 128, 128);
			}
		}
	}
	
	noFill();
	noStroke();
  strokeWeight(1);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	for (int i = 1; i < 16; i += 1) {
		float norm_i = 1-((float)(i - 1) / 256);
		
		stroke(8+frameCount % 3 * 64, 128, 8 + 64 * norm_i, 32 * norm_i);

		int sw = (float)width/2 / (i / 8) + abs(cos(xmotion + i) * 128);
		int sh = height/2 / (i / 8)+ abs(cos(xmotion + i) * 128);
		
		if (random() > 0.05) {
			rect(width / 2, height / 2, sw, sh);
		} else {
			ellipse(width / 2, height / 2, sw, sh);
		}
	}
	rectMode(CORNERS);

	xmotion += 0.25;
	ymotion += 0.35;
}

void setup() {
  size(600, 600);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	noFill();
	strokeWeight(16);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	frameRate(24);

	rectMode(CORNER);
	ellipseMode(CORNER);
	
	//smooth();
}

void draw() {
  draw_func();
}"
"701914","Skin","mySketch","float xmotion = 8.8;
float ymotion = 2.2;

int fmod(int x, int y) { return x % y; }
int fxor(int x, int y) { return x ^ y; }
int fand(int x, int y) { return x & y; }
int foor(int x, int y) { return x | y; }

int reset = 0;

void draw_func() {	
	noStroke();
	noFill();
	
	strokeWeight(1);
	
	ellipseMode(CENTER);
	rectMode(CENTER);
	
	loadPixels();
	for (int y = 0; y < height; y += 2) {
		int yy = y * width;
		for (int x = 0; x < width; x += 2) {
			color p = pixels[yy + x];
			
			float br = 128 - (frameCount - reset) * 2;
			
			if (brightness(p) > 0 && brightness(p) < br) {
				float normx = (float)x / width;
				float normy = (float)y / height;
				float anormx = abs(0.5 - normx) * 2;
				float anormy = abs(0.5 - normy) * 2;
				
				float ianorm = abs(sin(anormx * PI * 4 + xmotion)) * abs(cos(anormy * PI * 4 + ymotion));
				float d = ianorm;
				
				ianorm /= 2;
				
				if ((x*y) % (width / 2) > (width / 4)) {
					d = ianorm;
				}
				
				float n = (0.5 - noise(anormx + xmotion, anormy + ymotion)) * 8;
				
				fill(abs(n * 360 + d * 360) % 48, 8 + abs(n * 128), 128 + random(192, 255) * d, random(8, 64) * (0.75 + d));
				stroke(0, 0, 128, 1 + abs(cos(xmotion * PI * 2 + d * PI * 8) * 16));
				
				ellipse(x + n * 4, y + n * 4 - 2, 8 + abs(d * 64) * ianorm, 8 + abs(d * 64) * ianorm);
			}
		}
	}

	xmotion += 0.4;
	ymotion += 0.3;
}

void setup() {
  size(600, 600);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	mouseClicked();

	//smooth();
}

void mouseClicked() {
	background(0);
	
	strokeWeight(2);
	
	noFill();
	
	stroke(0, 0, 255, 2);
	
	for (float i = 0; i < 1; i += 0.25) {
		float x = width / 2 + width * sin(i * PI * 2);
		float y = height / 2 + height * cos(i * PI * 2);
		float x2 = width / 2 + width * sin(i * PI * 2 + PI);
		float y2 = height / 2 + height * cos(i * PI * 2 + PI);
		
		//line(x, y, x2, y2);
		bezier(random(0, width), random(0, height), random(0, width), random(0, height), random(0, width), random(0, height), random(0, width), random(0, height));
	}
	
	reset = frameCount;
}

void draw() {
  draw_func();
}"
"701698","Sediments","mySketch","float xmotion = 8.8;
float ymotion = 2.2;

int fmod(int x, int y) { return x % y; }
int fxor(int x, int y) { return x ^ y; }
int fand(int x, int y) { return x & y; }
int foor(int x, int y) { return x | y; }

void draw_func() {	
	noStroke();
	noFill();
	
	strokeWeight(1);
	
	ellipseMode(CENTER);
	rectMode(CENTER);
	
	loadPixels();
	for (int y = 0; y < height; y += 2) {
		int yy = y * width;
		for (int x = 0; x < width; x += 2) {
			color p = pixels[yy + x];
			
			if (brightness(p) > 0 && brightness(p) < 64) {
				float normx = (float)x / width;
				float normy = (float)y / height;
				float anormx = abs(0.5 - normx) * 2;
				float anormy = abs(0.5 - normy) * 2;
				
				float ianorm = abs(sin(anormx * PI * 2 + xmotion)) * abs(cos(anormy * PI * 2 + ymotion));
				float d = (1 - ianorm);
				
				ianorm /= 2;
				
				if ((x/abs(1+sin(anormy * PI * 2.5))+y/abs(1+sin(anormx * PI / 1.5))) % (width / 2) > (width / 3)) {
					d = ianorm;
				}
				
				int stroke_hardness = 8;
				
				float n = (0.5 - noise(anormx + xmotion, anormy + ymotion)) * (d * 4);
				
				fill(abs(n * 8 + d * 16), 0, 128 + random(192, 255) / d, random(4, 32) * (0.005 + d));
				stroke(0, 0, brightness(p), stroke_hardness + abs(cos(xmotion * PI * 2 + d * PI * 2) * 8) + 192 * ianorm);
				
				ellipse(x + n * 4 + ianorm * 4, y + n * 4 + 2 + ianorm * 4, 8 + abs(n * 48) * d, 8 + abs(n * 48) * d);
			}
		}
	}

	xmotion += 0.4;
	ymotion += 0.3;
}

void setup() {
  size(600, 600);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	mouseClicked();

	//smooth();
}

void mouseClicked() {
	background(0);
	
	strokeWeight(2);
	
	noFill();
	
	stroke(0, 0, 255, 1);
	
	for (float i = 0; i < 1; i += 0.25) {
		float x = width * i;
		float y = 0;
		float x2 = width * i;
		float y2 = height * i;
		
		line(x, y, x2, y2);
		bezier(random(0, width), random(0, height), random(0, width), random(0, height), random(0, width), random(0, height), random(0, width), random(0, height));
	}

	rectMode(CENTER);
	ellipseMode(CENTER);
	//rect(width / 2, height / 2, 128, 128);
}

void draw() {
  draw_func();
}"
"701697","Biomechanics","mySketch","float xmotion = 8.8;
float ymotion = 2.2;

int fmod(int x, int y) { return x % y; }
int fxor(int x, int y) { return x ^ y; }
int fand(int x, int y) { return x & y; }
int foor(int x, int y) { return x | y; }

void draw_func() {	
	noStroke();
	noFill();
	
	strokeWeight(1);
	
	ellipseMode(CENTER);
	rectMode(CENTER);
	
	loadPixels();
	for (int y = 0; y < height; y += 2) {
		int yy = y * width;
		for (int x = 0; x < width; x += 2) {
			color p = pixels[yy + x];
			
			if (brightness(p) > 0 && brightness(p) < 64) {
				float normx = (float)x / width;
				float normy = (float)y / height;
				float anormx = abs(0.5 - normx) * 2;
				float anormy = abs(0.5 - normy) * 2;
				
				float ianorm = abs(sin(anormx * PI * 2 + xmotion)) * abs(cos(anormy * PI * 2 + ymotion));
				float d = (1 - ianorm);
				
				ianorm /= 2;
				
				if ((x+y/abs(1+sin(anormx * PI / 2))) % (width / 2) > (width / 3)) {
					d = ianorm;
				}
				
				int stroke_hardness = 1;
				
				float n = (0.5 - noise(anormx + xmotion, anormy + ymotion)) * (d * 4);
				
				fill(abs(n * 8 + d * 16), 0, 128 + random(192, 255) / d, random(4, 32) * (0.05 + d));
				stroke(0, 0, brightness(p), stroke_hardness + abs(cos(xmotion * PI * 2 + d * PI * 2) * 8) + 192 * ianorm);
				
				ellipse(x + n * 4, y + n * 4, 8 + abs(n * 48) * d, 8 + abs(n * 48) * d);
			}
		}
	}

	xmotion += 0.4;
	ymotion += 0.3;
}

void setup() {
  size(600, 600);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	mouseClicked();

	//smooth();
}

void mouseClicked() {
	background(0);
	
	strokeWeight(2);
	
	noFill();
	
	stroke(0, 0, 255, 1);
	
	for (float i = 0; i < 1; i += 0.1) {
		float x = width * i;
		float y = 0;
		float x2 = width * i;
		float y2 = height * i;
		
		line(x, y, x2, y2);
		bezier(random(0, width), random(0, height), random(0, width), random(0, height), random(0, width), random(0, height), random(0, width), random(0, height));
	}

	rectMode(CENTER);
	ellipseMode(CENTER);
	//rect(width / 2, height / 2, 128, 128);
}

void draw() {
  draw_func();
}"
"701663","Nest","mySketch","float xmotion = 8.8;
float ymotion = 2.2;

int fmod(int x, int y) { return x % y; }
int fxor(int x, int y) { return x ^ y; }
int fand(int x, int y) { return x & y; }
int foor(int x, int y) { return x | y; }

void draw_func() {	
	noStroke();
	noFill();
	
	strokeWeight(1);
	
	ellipseMode(CENTER);
	rectMode(CENTER);
	
	loadPixels();
	for (int y = 0; y < height; y += 2) {
		int yy = y * width;
		for (int x = 0; x < width; x += 2) {
			color p = pixels[yy + x];
			
			if (brightness(p) > 0 && brightness(p) < 64) {
				float normx = (float)x / width;
				float normy = (float)y / height;
				float anormx = abs(0.5 - normx) * 2;
				float anormy = abs(0.5 - normy) * 2;
				
				float ianorm = abs(sin(anormx * PI * 5 + xmotion)) * abs(cos(anormy * PI * 5 + ymotion));
				float d = (1 - ianorm);
				
				//ianorm = 1.25;
				
				if ((x^y) % (width / 2) > (width / 3)) {
					d = ianorm;
				}
				
				int stroke_hardness = 1;
				
				float n = (0.5 - noise(anormx + xmotion, anormy + ymotion)) * (d * 4);
				
				fill(32+abs(n * 8 + d * 16), 0, 128 + random(192, 255) / d, random(4, 32) * (0.25 + d));
				stroke(0, 0, brightness(p), stroke_hardness + abs(cos(xmotion * PI * 2 + d * PI * 2) * 8) + 192 * ianorm);
				
				ellipse(x + n * 4, y + n * 4, 8 + abs(n * 32) * d, 8 + abs(n * 32) * d);
			}
		}
	}

	xmotion += 0.15;
	ymotion += 0.1;
}

void setup() {
  size(600, 600);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	mouseClicked();

	//smooth();
}

void mouseClicked() {
	background(0);
	
	noFill();
	
	stroke(0, 0, 255, 1);
	
	for (float i = 0; i < 1; i += 0.1) {
		float x = width / 2 + width * sin(i * PI * 2);
		float y = height / 2 + height * cos(i * PI * 2);
		float x2 = width / 2 + width * sin(i * PI * 2 + PI);
		float y2 = height / 2 + height * cos(i * PI * 2 + PI);
		
		strokeWeight(random(1, 4));
		
		line(x, y, x2, y2);
		//bezier(random(0, width), random(0, height), random(0, width), random(0, height), random(0, width), random(0, height), random(0, width), random(0, height));
	}
}

void draw() {
  draw_func();
}"
"701662","Molten","mySketch","float xmotion = 8.8;
float ymotion = 2.2;

int fmod(int x, int y) { return x % y; }
int fxor(int x, int y) { return x ^ y; }
int fand(int x, int y) { return x & y; }
int foor(int x, int y) { return x | y; }

void draw_func() {	
	noStroke();
	noFill();
	
	strokeWeight(1);
	
	ellipseMode(CENTER);
	rectMode(CENTER);
	
	loadPixels();
	for (int y = 0; y < height; y += 2) {
		int yy = y * width;
		for (int x = 0; x < width; x += 2) {
			color p = pixels[yy + x];
			
			if (brightness(p) > 0 && brightness(p) < 64) {
				float normx = (float)x / width;
				float normy = (float)y / height;
				float anormx = abs(0.5 - normx) * 2;
				float anormy = abs(0.5 - normy) * 2;
				
				float ianorm = abs(sin(anormx * PI * 2 + xmotion)) * abs(cos(anormy * PI * 2 + ymotion));
				float d = (1 - ianorm);
				
				ianorm /= 2;
				
				if ((x*y) % (width / 2) > (width / 3)) {
					d = ianorm;
				}
				
				int stroke_hardness = 1;
				
				float n = (0.5 - noise(anormx + xmotion, anormy + ymotion)) * (d * 4);
				
				fill(abs(n * 8 + d * 16), 8 + abs(n * 128), 128 + random(192, 255) / d, random(4, 32) * (0.25 + d));
				stroke(0, 0, brightness(p), stroke_hardness + abs(cos(xmotion * PI * 2 + d * PI * 2) * 8) + 128 * ianorm);
				
				ellipse(x + n * 4, y + n * 4, 8 + abs(n * 48) * d, 8 + abs(n * 48) * d);
			}
		}
	}

	xmotion += 0.4;
	ymotion += 0.3;
}

void setup() {
  size(600, 600);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	mouseClicked();

	//smooth();
}

void mouseClicked() {
	background(0);
	
	strokeWeight(2);
	
	noFill();
	
	stroke(0, 0, 255, 1);
	
	for (float i = 0; i < 1; i += random(0.1, 0.5)) {
		float x = width / 2 + width * sin(i * PI * 2);
		float y = height / 2 + height * cos(i * PI * 2);
		float x2 = width / 2 + width * sin(i * PI * 2 + PI);
		float y2 = height / 2 + height * cos(i * PI * 2 + PI);
		
		line(x, y, x2, y2);
		//bezier(random(0, width), random(0, height), random(0, width), random(0, height), random(0, width), random(0, height), random(0, width), random(0, height));
	}

	rectMode(CENTER);
	ellipseMode(CENTER);
	ellipse(width / 2, height / 2, 600, 600);
}

void draw() {
  draw_func();
}"
"701508","Bois","mySketch","float xmotion = 8.8;
float ymotion = 2.2;

int fmod(int x, int y) { return x % y; }
int fxor(int x, int y) { return x ^ y; }
int fand(int x, int y) { return x & y; }
int foor(int x, int y) { return x | y; }

void draw_func() {	
	noStroke();
	noFill();
	
	strokeWeight(1);
	
	ellipseMode(CENTER);
	rectMode(CENTER);
	
	loadPixels();
	for (int y = 0; y < height; y += 2) {
		int yy = y * width;
		for (int x = 0; x < width; x += 2) {
			color p = pixels[yy + x];
			
			if (brightness(p) > 0 && brightness(p) < 64) {
				float normx = (float)x / width;
				float normy = (float)y / height;
				float anormx = abs(0.5 - normx) * 2;
				float anormy = abs(0.5 - normy) * 2;
				
				float ianorm = anormx * anormy;
				float d = (1 - ianorm);
				
				ianorm /= 4;
				
				if ((x^y) % (width / 2) > (width / 4)) {
					d = ianorm;
				}
				
				int stroke_hardness = 32;
				
				float n = (0.5 - noise(anormx + xmotion, anormy + ymotion)) * (d * 4);
				
				fill(8 + abs(n / 4), 8 + abs(n / 8), 128 + random(192, 255) / d, random(4, 32) * (0.25 + d));
				stroke(0, 0, brightness(p), stroke_hardness + abs(cos(xmotion * PI * 2 + d * PI * 2) * 16) + 128 * ianorm);
				
				ellipse(x + n * 4, y + n * 4, 8 + abs(n * 32) * d, 8 + abs(n * 32) * d);
			}
		}
	}
	
	noFill();
	noStroke();
  
	/*
	rectMode(CENTER);
	ellipseMode(CENTER);
	strokeWeight(64);
	stroke(0, 0, 0, 255);
	ellipse(width / 2, height / 2, width, height);
	ellipse(width / 2, height / 2, width, height);
	ellipse(width / 2, height / 2, width, height);
	strokeWeight(2);
	stroke(0, 0, 256, 255);
	ellipse(width / 2, height / 2, width-32, height-32);
	ellipse(width / 2, height / 2, width-64, height-64);
	rectMode(CORNER);
	*/

	xmotion += 0.4;
	ymotion += 0.1;
}

void setup() {
  size(600, 600);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	strokeWeight(4);
	
	noFill();
	
	stroke(0, 0, 255, 1);
	
	//line(0, 0, width, height);
	//line(width, 0, 0, height);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	ellipse(width / 2, height / 2, 128, 128);

	//smooth();
}

void draw() {
  draw_func();
}"
"701502","Marble","mySketch","float xmotion = 8.8;
float ymotion = 2.2;

int fmod(int x, int y) { return x % y; }
int fxor(int x, int y) { return x ^ y; }
int fand(int x, int y) { return x & y; }
int foor(int x, int y) { return x | y; }

void draw_func() {	
	noStroke();
	noFill();
	
	strokeWeight(2);
	
	ellipseMode(CENTER);
	rectMode(CENTER);
	
	loadPixels();
	for (int y = 0; y < height; y += 2) {
		int yy = y * width;
		for (int x = 0; x < width; x += 2) {
			color p = pixels[yy + x];
			
			if (brightness(p) > 0 && brightness(p) < 48) {
				float normx = (float)x / width;
				float normy = (float)y / height;
				float anormx = abs(0.5 - normx) * 2;
				float anormy = abs(0.5 - normy) * 2;
				
				float ianorm = anormx * anormy;
				
/*
				float v = 0;
				if (random() > 0.75) {
					v = fmod(x, y);
				} else if (random() > 0.5) {
					v = fxor(x, y);
				} else if (random() > 0.25) {
					v = fand(x, y);
				} else if (random() >= 0.0) {
					v = foor(x, y);
				}
*/
				float d = (1 - ianorm);
				if ((x % y & x | y) % (width / 2) > (width / 4)) {
					d = ianorm;
				}
				
				int stroke_hardness = 1;
				
				float n = (0.5 - noise(anormx + xmotion, anormy + ymotion)) * (d * 4);
				
				fill(224 + n * 64, 16 * d, 128 + random(192, 255) / d, random(4, 32) * (0.25 + d));
				stroke(0, 0, brightness(p), stroke_hardness + abs(cos(xmotion * PI * 2 + d * PI * 2) * 16) + 128 * ianorm);
				
				ellipse(x + n * 4, y + n * 4, 8 + abs(n * 32) * d, 8 + abs(n * 32) * d);
			}
		}
	}
	
	noFill();
	noStroke();
  
	/*
	rectMode(CENTER);
	ellipseMode(CENTER);
	strokeWeight(64);
	stroke(0, 0, 0, 255);
	ellipse(width / 2, height / 2, width, height);
	ellipse(width / 2, height / 2, width, height);
	ellipse(width / 2, height / 2, width, height);
	strokeWeight(2);
	stroke(0, 0, 256, 255);
	ellipse(width / 2, height / 2, width-32, height-32);
	ellipse(width / 2, height / 2, width-64, height-64);
	rectMode(CORNER);
	*/

	xmotion += 0.4;
	ymotion += 0.1;
}

void setup() {
  size(600, 600);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	strokeWeight(1);
	
	stroke(0, 0, 32, 255);
	
	line(0, 0, width, height);
	line(width, 0, 0, height);
	
	ellipseMode(CENTER);
	//ellipse(width / 2, height / 2, 64, 8);

	//smooth();
}

void draw() {
  draw_func();
}"
"701472","Vortex","mySketch","float xmotion = 0;
float ymotion = 0;
float zmotion = 0;

void setup() {
  size(840, 840);
  
  colorMode(HSB, 360, 255, 255);
  
  background(0);
  noStroke();
  
  strokeWeight(1);
  
  noiseDetail(7, 0.5);
}

float radius = 32;

void draw() {
 // background(0, 0, 0, 1);
  noStroke();
  
  fill(0, 0, 0, 48);
	rect(0, 0, width, height);
	
	noFill();
  
  float count = 9;
  
  float i = 0; float j = 0;
  
  float x =  width / 2 + (sin(xmotion * 0.5) * width / 16);
  float y = height / 2 + (cos(zmotion * 0.75) * height / 16);
	
  for (j = 0; j < 1; j += 0.002) {
		float jnorm_j = abs(0.5 - j) * 2;
  for (i = 0; i < count; i += 1) {
    float norm_i = i / count;
    float unit_i = 1 / count;
    
    float inorm_i = abs(0.5 - norm_i) * 2;
    
    float n = noise(inorm_i + xmotion, jnorm_j + ymotion) / 32;
		
		float rad1 = radius + cos(xmotion * PI * 4 + inorm_i * PI * 32 + jnorm_j * PI * 4) / (0.4 + abs(sin(xmotion) * 2));
		float rad2 = radius + sin(ymotion * PI * 4 + inorm_i * PI * 32 + jnorm_j * PI * 4) / (0.4 + abs(cos(zmotion) * 2));

    float cx = rad1 * sin(norm_i * PI * 2 + n * 4 + xmotion + (j * PI * 2)) + sin(xmotion*2) * 24;
    float cy = rad1 * cos(norm_i * PI * 2 + n * 4 + ymotion + (j * PI * 2)) + cos(ymotion*2) * 24;
    
    float cx2 = rad2 * sin((unit_i + norm_i) * PI * 2 + xmotion + (j * PI * 2)) + sin(xmotion*2) * 24;
    float cy2 = rad2 * cos((unit_i + norm_i) * PI * 2 + ymotion + (j * PI * 2)) + cos(ymotion*2) * 24;
    
    //stroke(0, 0, 0, 128);
    //line(x + cx, y + cy, x + cx2, y + cy2);
    //line(x + cx / 2, y + cy / 2, x + cx2 / 2, y + cy2 / 2);
		stroke(120 + inorm_i * 120 + jnorm_j * 90, 128 * (1-j), 256, 256 * (n * 32));

    line(x + cx / j, y + cy / j, x + cx2 / j, y + cy2 / j);

    noStroke();
  }
  }
  
  xmotion += 0.01;
  ymotion += 0.01;
	zmotion += 0.02;
}
"
"701472","Vortex","mySketch","float xmotion = 0;
float ymotion = 0;
float zmotion = 0;

void setup() {
  size(840, 840);
  
  colorMode(HSB, 360, 255, 255);
  
  background(0);
  noStroke();
  
  strokeWeight(1);
  
  noiseDetail(7, 0.5);
}

float radius = 32;

void draw() {
 // background(0, 0, 0, 1);
  noStroke();
  
  fill(0, 0, 0, 32);
	rect(0, 0, width, height);
	
	noFill();
  
  float count = 12;
  
  float i = 0; float j = 0;
  
  float x =  width / 2 + (sin(xmotion * 0.5) * width / 16);
  float y = height / 2 + (cos(zmotion * 0.75) * height / 16);
	
  for (j = 0; j < 1; j += 0.002) {
		float jnorm_j = abs(0.5 - j) * 2;
  for (i = 0; i < count; i += 1) {
    float norm_i = i / count;
    float unit_i = 1 / count;
    
    float inorm_i = abs(0.5 - norm_i) * 2;
    
    float n = noise(inorm_i + xmotion, jnorm_j + ymotion) / 128;
		
		float rad1 = radius + cos(xmotion * PI * 4 + inorm_i * PI * 32 + jnorm_j * PI * 8) / (0.4 + abs(sin(xmotion) * 2));
		float rad2 = radius + sin(ymotion * PI * 4 + inorm_i * PI * 32 + jnorm_j * PI * 8) / (0.4 + abs(cos(zmotion) * 2));

    float cx = rad1 * sin(norm_i * PI * 2 + n * 4 + xmotion + (j * PI * 2)) + sin(xmotion*2) * 24;
    float cy = rad1 * cos(norm_i * PI * 2 + n * 4 + ymotion + (j * PI * 2)) + cos(ymotion*2) * 24;
    
    float cx2 = rad2 * sin((unit_i + norm_i) * PI * 2 + xmotion + (j * PI * 2)) + sin(xmotion*2) * 24;
    float cy2 = rad2 * cos((unit_i + norm_i) * PI * 2 + ymotion + (j * PI * 2)) + cos(ymotion*2) * 24;
    
    //stroke(0, 0, 0, 128);
    //line(x + cx, y + cy, x + cx2, y + cy2);
    //line(x + cx / 2, y + cy / 2, x + cx2 / 2, y + cy2 / 2);
		stroke(192 + inorm_i * 128 + jnorm_j * 128, 128 * (1-j), 256, 256 * (n * 32));

    line(x + cx / j, y + cy / j, x + cx2 / j, y + cy2 / j);

    noStroke();
  }
  }
  
  xmotion += 0.01;
  ymotion += 0.01;
	zmotion += 0.02;
}
"
"700566","Colored","mySketch","float xmotion = 0;
float ymotion = 0;

void setup() {
  size(800, 640);
  
  colorMode(HSB, 360, 255, 255);
  
  background(0);
  noStroke();
  
  strokeWeight(1);
  
  noiseDetail(6, 0.5);
}

float radius = 500;
int lastmx = -1;

void draw() {
 // background(0, 0, 0, 1);
  noStroke();
	
	int mmx = round(mouseX / width * 16);
	
	if (mmx != lastmx) {
		lastmx = mmx;
		//background(0);
	}
  
  fill(0, 0, 0, 32);
	rect(0, 0, width, height);
  
  float count = 10;//4 + mmx;
  
  float i = 0; float j = 0;
  
  for (j = 0; j < 1; j += 0.002) {
		float jnorm_j = abs(0.5 - j) * 2;
  for (i = 0; i < count; i += 1) {
    float norm_i = i / count;
    float unit_i = 1 / count;
    
    float inorm_i = abs(0.5 - norm_i) * 2;
    
    float n = (0.5 - noise(inorm_i + xmotion, jnorm_j + ymotion)) * 2;

    float cx = radius * sin(norm_i * PI * 2 + n * 2 + xmotion);
    float cy = radius * cos(norm_i * PI * 2 + n * 2 + ymotion);
    
    float cx2 = radius * sin((unit_i + norm_i) * PI * 2 + xmotion);
    float cy2 = radius * cos((unit_i + norm_i) * PI * 2 + ymotion);
		
    float x =  width / 2;
    float y = height / 2;
    
    //fill(0, 0, 255, random(0, 2));
    //ellipse(x + cx, y + cy, 24, 24);
		//ellipse(x + cx2 / 32, y + cy2 / 32, 8, 8);
    
    stroke(inorm_i * 90 + abs(sin(xmotion * n / 8 * PI * 2 * j * PI * 2) * 180), 128, 256, 256 * (n * 32));
    //line(x + cx, y + cy, x + cx2, y + cy2);
    //line(x + cx / 2, y + cy / 2, x + cx2 / 2, y + cy2 / 2);
		
    line(x + cx * j, y + cy * j, x + cx2 * j, y + cy2 * j);
		//line(x + cx / 2, y + cy / 2, x + cx2 / 64, y + cy2 / 64);
    //line(width - x + cx, height - y + cy, width - x + cx2, height - y + cy2);
    noStroke();
  }
  }
  
  xmotion += 0.01;
  ymotion += 0.01;
}
"
"700566","Colored","mySketch","float xmotion = 0;
float ymotion = 0;

void setup() {
	size(800, 640);

	colorMode(HSB, 360, 255, 255);

	background(0);
	noStroke();

	strokeWeight(2);

	noiseDetail(6, 0.5);
}

float radius = 50;
int lastmx = -1;

void draw() {
	// background(0, 0, 0, 1);
	noStroke();

	int mmx = round(mouseX / width * 8);

	if (mmx != lastmx) {
		lastmx = mmx;
		//background(0);
	}

	fill(0, 0, 0, 16);
	rect(0, 0, width, height);

	float count = 4 + mmx;

	float i = 0;
	float j = 0;

	for (j = 0; j < 1; j += 0.002) {
		float jnorm_j = abs(0.5 - j) * 2;
		for (i = 0; i < count; i += 1) {
			float norm_i = i / count;
			float unit_i = 1 / count;

			float inorm_i = abs(0.5 - norm_i) * 4;

			float n = (0.5 - noise(inorm_i + xmotion, jnorm_j + ymotion)) * 2;

			float cx = radius * sin(norm_i * PI * 2 + n * 2 + xmotion);
			float cy = radius * cos(norm_i * PI * 2 + n * 2 + ymotion);

			float cx2 = radius * sin((unit_i + norm_i) * PI * 2 + xmotion);
			float cy2 = radius * cos((unit_i + norm_i) * PI * 2 + ymotion);

			float x = width / 2 + sin(xmotion / 2) * 8;
			float y = height / 2 + cos(ymotion / 2) * 8;

			//fill(0, 0, 255, random(0, 2));
			//ellipse(x + cx, y + cy, 24, 24);
			//ellipse(x + cx2 / 32, y + cy2 / 32, 8, 8);

			stroke(24 + inorm_i * 90 + abs(sin(xmotion + n * PI * 2 + norm_i * PI * 2) * 90), 128, 256, 256 * (n * 3));

			line(x + cx / j, y + cy / j, x + cx2 / j, y + cy2 / j);

			noStroke();
		}
	}

	xmotion += 0.01;
	ymotion += 0.01;
}"
"700524","Twisted","mySketch","float xmotion = 0;
float ymotion = 0;

void setup() {
  size(840, 840);
  
  colorMode(HSB, 360, 255, 255);
  
  background(0);
  noStroke();
  
  strokeWeight(1);
  
  noiseDetail(7, 0.55);
}

float radius = 600;

void draw() {
 // background(0, 0, 0, 1);
  noStroke();
  
  fill(0, 0, 0, 64);
	rect(0, 0, width, height);
  
  float count = 9;
  
  float i = 0; float j = 0;
  
  for (j = 0; j < 1; j += 0.002) {
		float jnorm_j = abs(0.5 - j) * 2;
  for (i = 0; i < count; i += 1) {
    float norm_i = i / count;
    float unit_i = 1 / count;
    
    float inorm_i = abs(0.5 - norm_i) * 2;
    
    float n = noise(inorm_i + xmotion, jnorm_j + ymotion) / 32;
		
		float rad1 = radius + cos(xmotion * PI * 4 + jnorm_j * PI * 2) * 128;
		float rad2 = radius + cos(ymotion * PI * 4 + jnorm_j * PI * 2) * 128;

    float cx = rad1 * sin(norm_i * PI * 2 + n * 64 + xmotion + (j * PI * 2) / 4);
    float cy = rad1 * cos(norm_i * PI * 2 + n * 64 + ymotion + (j * PI * 2) / 4);
    
    float cx2 = rad2 * sin((unit_i + norm_i) * PI * 2 + xmotion + (j * PI * 3) / 4);
    float cy2 = rad2 * cos((unit_i + norm_i) * PI * 2 + ymotion + (j * PI * 3) / 4);
		
    float x =  width / 2;
    float y = height / 2;
    
    stroke(inorm_i * 90 + abs(sin(xmotion + n * PI * 2) * 270), 128, 256, 256 * (n * 32));
    //line(x + cx, y + cy, x + cx2, y + cy2);
    //line(x + cx / 2, y + cy / 2, x + cx2 / 2, y + cy2 / 2);
		
    line(x + cx * j, y + cy * j, x + cx2 * j, y + cy2 * j);

    noStroke();
  }
  }
  
  xmotion += 0.01;
  ymotion += 0.01;
}
"
"699033","La carte","mySketch","// random bezier with feedback rules
// reducing shapes size uniformly has some interesting properties as well

float xmotion = 8.8;
float ymotion = 2.2;

int reset = 0;
int perlin_amount = 16;

void draw_func() {
	noStroke();
	
	rectMode(CENTER);
	
	loadPixels();
	for (int y = 0; y < height; y += 1) {
		int yy = y * width;
		for (int x = 0; x < width; x += 1) {
			color p = pixels[yy + x];
			
			float xm = 0;
			float ym = 128 - (frameCount - reset) * 3;
			
			if ((brightness(p) > xm && brightness(p) < ym)) {
				float normx = (float)x / width;
				float normy = (float)y / height;
				float anormx = 1.0 - abs(0.5 - normx) * 2;
				float anormy = 1.0 - abs(0.5 - normy) * 2;
				
				float xk = xmotion / 2;
				float yk = ymotion / 2;
				
				//float n = (0.5-noise(normx+xk,normy+yk)) * perlin_amount;
				
				fill(0, 0, 255, 48);
				
				rect(x, y, 5, 5);
				fill(0, 0, 0, 8);
				rect(width - x, height - y, 10, 5);
			}
		}
	}
	
	noFill();
	noStroke();

	stroke(0, 0, 255, 3);
	strokeWeight(1);
	noFill();
	bezier(random(width), random(height), random(width), random(height), random(width), random(height), random(width), random(height));
	
	xmotion += 0.75;
	ymotion += 0.8;
}

void setup() {
  size(600, 600);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	noiseDetail(6,0.65);
	
	frameRate(60);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	//smooth();
}

void mouseClicked() {
	background(0);
	
	reset = frameCount;
	
	perlin_amount = random(2, 4);
}

void draw() {
  draw_func();
}"
"699033","La carte","mySketch","// random bezier with feedback rules
// reducing shapes size uniformly has some interesting properties as well

float xmotion = 8.8;
float ymotion = 2.2;

int reset = 0;

void draw_func() {
	noStroke();
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	loadPixels();
	for (int y = 0; y < height; y += 1) {
		int yy = y * width;
		for (int x = 0; x < width; x += 1) {
			color p = pixels[yy + x];
			
			float xm = 0;
			float ym = 128 - (frameCount - reset) * 1.5;
			
			if ((brightness(p) > xm && brightness(p) < ym)) {
				float normx = (float)x / width;
				float normy = (float)y / height;
				float anormx = 1.0 - abs(0.5 - normx) * 2;
				float anormy = 1.0 - abs(0.5 - normy) * 2;

				fill(0, 0, 255, 48);
				
				rect(x, y, 3, 3);
				fill(0, 0, 0, 9);
				rect(width - x, height - y, 10, 3);
			}
		}
	}
	
	noFill();
	noStroke();

	stroke(0, 0, 255, 3);
	strokeWeight(1);
	noFill();
	bezier(random(width), random(height), random(width), random(height), random(width), random(height), random(width), random(height));
	
	xmotion += 0.75;
	ymotion += 0.8;
}

void setup() {
  size(600, 600);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	noiseDetail(6,0.65);
	
	frameRate(60);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	//smooth();
}

void mouseClicked() {
	background(0);
	
	reset = frameCount;
	
	perlin_amount = random(2, 4);
}

void draw() {
  draw_func();
}"
"699033","La carte","mySketch","// random bezier with feedback rules
// reducing shapes size uniformly has some interesting properties as well

float xmotion = 8.8;
float ymotion = 2.2;

int reset = 0;

void draw_func() {
	noStroke();
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	loadPixels();
	for (int y = 0; y < height; y += 1) {
		int yy = y * width;
		for (int x = 0; x < width; x += 1) {
			color p = pixels[yy + x];
			
			float xm = 0;
			float ym = 128 - (frameCount - reset) * 1.5;
			
			if ((brightness(p) > xm && brightness(p) < ym)) {
				float normx = (float)x / width;
				float normy = (float)y / height;
				float anormx = 1.0 - abs(0.5 - normx) * 2;
				float anormy = 1.0 - abs(0.5 - normy) * 2;

				fill(0, 0, 255, 48);
				
				rect(x, y, 3, 3);
				fill(0, 0, 0, 9);
				rect(width - x, height - y, 10, 3);
			}
		}
	}
	
	noFill();
	noStroke();

	stroke(0, 0, 255, 3);
	strokeWeight(1);
	noFill();
	bezier(random(width), random(height), random(width), random(height), random(width), random(height), random(width), random(height));
	
	xmotion += 0.75;
	ymotion += 0.8;
}

void setup() {
  size(600, 600);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	noiseDetail(6,0.65);
	
	frameRate(60);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	//smooth();
}

void mouseClicked() {
	background(0);
	
	reset = frameCount;
	
	perlin_amount = random(2, 4);
}

void draw() {
  draw_func();
}"
"699032","Structures 2","mySketch","// random bezier with feedback rules
// reducing shapes size uniformly has some interesting properties as well

float xmotion = 8.8;
float ymotion = 2.2;

int reset = 0;
int perlin_amount = 2;

void draw_func() {
	noStroke();
	
	loadPixels();
	for (int y = 0; y < height; y += 1) {
		int yy = y * width;
		for (int x = 0; x < width; x += 1) {
			color p = pixels[yy + x];
			
			float xm = 4;
			float ym = 128 - pow((frameCount - reset) * 7, 0.9);//(frameCount - reset) * 7;
			
			if ((brightness(p) > xm && brightness(p) < ym)) {
				float normx = (float)x / width;
				float normy = (float)y / height;
				float anormx = 1.0 - abs(0.5 - normx) * 2;
				float anormy = 1.0 - abs(0.5 - normy) * 2;
				float anormxy = anormx * normy;
				
				float xk = xmotion / 128;
				float yk = ymotion / 128;
				
				float n = (0.5-noise(anormx+xk,anormy+yk)) * perlin_amount;
				
				fill(0, 0, 256, 12);
				
				ellipse(x + n, y + n + 4, 5 * anormx, 5 * anormy);
				ellipse(width - x + n, y + n + 4, 5 * anormx, 5 * anormy);
			}
		}
	}
	
	noFill();
	noStroke();

	rectMode(CENTER);
	ellipseMode(CENTER);

	stroke(0, 0, 255 * random(), 16);
	strokeWeight(1 + random(8));
	noFill();
	int n = random(width / 2);
	//ellipse(random(width / 2), random(height / 2), n, n);
	bezier(random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height));
	strokeWeight(1 + random(8));
	bezier(random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height), random(width / 2), random(height));

	rectMode(CORNER);
	
	xmotion += 2.75;
	ymotion += 1.8;
}

void setup() {
  size(800, 800);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	noiseDetail(7,0.7);
	
	frameRate(60);
	
	//smooth();
}

void mouseClicked() {
	background(0);
	
	reset = frameCount;
	
	perlin_amount = random(2, 4);
}

void draw() {
  draw_func();
}"
"699011","Structures","mySketch","// random bezier with feedback rules
// reducing shapes size uniformly has some interesting properties as well

float xmotion = 8.8;
float ymotion = 2.2;

int reset = 0;
int perlin_amount = 2;

void draw_func() {
	noStroke();
	
	loadPixels();
	for (int y = 0; y < height; y += 2) {
		int yy = y * width;
		for (int x = 0; x < width; x += 2) {
			color p = pixels[yy + x];
			
			float xm = 0;
			float ym = 128 - (frameCount - reset) * 2;
			
			if ((brightness(p) > xm && brightness(p) < ym)) {
				float normx = (float)x / width;
				float normy = (float)y / height;
				float anormx = 1.0 - abs(0.5 - normx) * 2;
				float anormy = 1.0 - abs(0.5 - normy) * 2;
				
				float xk = xmotion / 128;
				float yk = ymotion / 128;
				
				float n = (0.5-noise(normx+xk,normy+yk)) * perlin_amount;
				
				fill(0, 0, 255, 16);
				
				ellipse(x + n, y + n+4, 8, 8);
				ellipse(width - x + n, y + n+4, 8, 8);
			}
		}
	}
	
	noFill();
	noStroke();

	rectMode(CENTER);
	ellipseMode(CENTER);

	stroke(0, 0, 255, 4);
	strokeWeight(1 + random(4));
	noFill();
	bezier(random(width), random(height), random(width), random(height), random(width), random(height), random(width), random(height));

	rectMode(CORNER);
	
	xmotion += 0.75;
	ymotion += 0.8;
}

void setup() {
  size(600, 600);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	noiseDetail(6,0.65);
	
	frameRate(60);
	
	//smooth();
}

void mouseClicked() {
	background(0);
	
	reset = frameCount;
	
	perlin_amount = random(2, 4);
}

void draw() {
  draw_func();
}"
"698999","Le masque","mySketch","float xmotion = 8.8;
float ymotion = 2.2;

void draw_func() {
	noStroke();
	
	loadPixels();
	for (int y = 0; y < height; y += 2) {
		int yy = y * width;
		for (int x = 0; x < width; x += 2) {
			color p = pixels[yy + x];
			
			float xm = 64;
			float ym = 128 + ymotion % 8;
			
			if ((brightness(p) > xm && brightness(p) < ym)) {
				float normx = (float)x / width;
				float normy = (float)y / height;
				float anormx = 1.0 - abs(0.5 - normx) * 2;
				float anormy = 1.0 - abs(0.5 - normy) * 2;
				
				float xk = xmotion / 128;
				float yk = ymotion / 128;
				
				float n = (0.5-noise(normx+xk,normy+yk))*2;
				
				fill(hue(p) + abs(n) + 1, 128 * pow(anormx * anormy, 0.25), 255, 32);
				
				ellipse(x + n, y + n, 4, 4);
				ellipse(width - x  - n, y - n * 2, 4, 4);
			}
		}
	}
	
	noFill();
	noStroke();
  strokeWeight(1);
	
	rectMode(CENTER);
	ellipseMode(CENTER);

	for (int i = 1; i < 4; i += 1) {
		float norm_i = 1-((float)(i - 1) / 4);

		stroke(92, 128, 256, 3);

		line(width/64*i*pow(i, 1.2), 0, width/32*i, height);
		line(0, height/64*i, width/i*pow(i, 0.002), height/8*i);
	}
	
	line(0, height - 64, width / 4, height - 2);
	
	stroke(128, 128, 255, 6);
	fill(192, 128, 255, 1);
	ellipse(width / 2.75, height / 2.75, 92, 72);
	ellipse(width - width / 2.75, height / 2.75, 92, 72);
  fill(192, 128, 255, 3);
	stroke(192, 128, 255, 4);
	strokeWeight(2);
	//noFill();
	triangle(width / 2, height / 2.25, width / 2.15, height / 1.9995, width - width / 2.15, height / 1.9995);
	noStroke();
	strokeWeight(8);
	//fill(300, 128, 255, 8);
	noFill();
	fill(64, 128, 255, 8);
	//stroke(64, 128, 255, 8);
	arc(width / 2, height / 1.6, 100, 34, 0, PI, CHORD);
	
	if (frameCount > 8) {
		noStroke();
		fill(0, 128, 0, 164);
		ellipse(width / 2.75, height / 2.75, 8 + abs(sin(xmotion / 24) * 92), 24 + abs(cos(xmotion / 16) * 32));
		ellipse(width - width / 2.75, height / 2.75, 8 + abs(cos(ymotion / 16) * 92), 24 + abs(sin(ymotion / 8) * 32));
		//arc(width / 2, height / 1.6, 100 + abs(cos(xmotion / 6) * 24), 24 + abs(sin(ymotion / 9) * 24), 0, PI, CHORD);
	}
	
	rectMode(CORNER);
	
	xmotion += 0.75;
	ymotion += 0.8;
}

void setup() {
  size(600, 600);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	noiseDetail(6,0.65);
	
	frameRate(30);
	
	//smooth();
}

void draw() {
  draw_func();
}"
"697090","Le poisson","mySketch","// lets try with some new shapes... ;)

float xmotion = 8.8;
float ymotion = 2.2;

void draw_func() {
	if ((frameCount % 160) == 0) {
		background(0);
	}
	
	noStroke();
	
	strokeWeight(2);
	
	loadPixels();
	for (int y = 0; y < height; y += 2) {
		int yy = y * width;
		for (int x = 0; x < width; x += 2) {
			color p = pixels[yy + x];
			
			if (brightness(p) > 0 && brightness(p) < 16) {
				noFill();
				float n = (0.5-noise((float)x/width+xmotion*2,(float)y/height+ymotion*2))*2;
				float n2 = (0.5-noise((float)y/height+ymotion*2,(float)x/width+xmotion*2))*2;
				
				stroke(abs(hue(p) + n) + 24, 128, 255, 48 + n * 16);
				
				int s = 6;
				
				line(x - s, y - s, x + s, y + s);
				line(x - s, y + s, x + s, y - s);
			  line(width - x - s, height - y - s, width - x + s, height - y + s);
				line(width - x - s, height - y + s, width - x + s, height - y - s);
				
				rect(x + n, y + n, random(1, 4), random(1, 4));
				rect(width - x  - n2, y - n2, random(1, 4), random(1, 4));
			}
		}
	}
	
	noFill();
	noStroke();
  strokeWeight(12);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	stroke(224, 128, 255, 1);
	ellipse(width / 2.5, height / 2, 32, 32);
	fill(0, 128, 255, 1);
	stroke(128, 128, 255, 1);
	strokeWeight(3);
	noFill();
	arc(width / 2, height / 1.5, 200, 32, 0, PI, CHORD);

	xmotion += 0.4;
	ymotion += 0.1;
}

void setup() {
  size(600, 600);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	noiseDetail(7,0.65);
	
	frameRate(30);
	
	//smooth();
}

void draw() {
  draw_func();
}"
"695475","Impact","mySketch","// feedback with triangles with sinc ? function & bloody colors

float xmotion = 8.8;
float ymotion = 2.2;

void draw_func() {
	noStroke();
	
	loadPixels();
	for (int x = 1; x < width; x += 4) {
		float norm_x = x / width;

		for (int y = 1; y < height; y += 4) {
			color p = pixels[y * width + x];
			
			if (brightness(p) > 0 && brightness(p) < 128) {
				float norm_y = y / height;
				
				color p2 = pixels[(y+ceil(random(-1, 1))) * width + (x+ceil(random(-1, 1)))];
				
				if (hue(p2) < 1) {
					fill(hue(p) + 8, 128, 256, 8);
				} else {
					fill(hue(p2) + 1, abs(sin(xmotion) * 128), 256, 24);
				}		
				
				int x1 = width - x + random(-2,2);
				int y1 = height - y + random(-2,2);
				int x2 = width - x + cos(norm_x * PI * 2 + xmotion) * 8;
				int y2 = y1 + (sin(norm_y * PI * 2 + ymotion)/(norm_y * PI * 2)) * 8;
				int x3 = x2 - (sin(norm_x * PI * 2 + xmotion)/(norm_x * PI * 2)) * 8;
				int y3 = y1 + (cos(norm_y * PI * 2 + ymotion)/(norm_y * PI * 2)) * 8;
				triangle(x1, y1, x2, y2, x3, y3)
			} else if (brightness(p) > 224) {
				float norm_y = y / height;
				
				fill(0, 0, 0, 32);
				
				int x1 = x;
				int y1 = y;
				int x2 = x + random(-2, 2);
				int y2 = y1 + random(-2,2);
				int x3 = x2 - random(-2,2);
				int y3 = y1 + random(-2,2);
				triangle(x1, y1, x2, y2, x3, y3)
				triangle(y1, x1, y2, x2, y3, x3)
			}
		}
	}
	
	xmotion += 0.02;
	ymotion -= 0.01;
	
/*
	ellipseMode(CENTER);
	fill(0, 0, 0, 8);
	ellipse(width /2, height /2, 450, 300);*/
}

void setup() {
  size(800, 800);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	noFill();
	strokeWeight(1);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	stroke(32, 128, 64, 256);
	ellipse(width /2, height /2, 400, 400);
	//stroke(128, 128, 256, 256);
	//ellipse(width /2, height /2, 500, 300);

	//line(0, 0, width, height);
	//line(width, 0, 0, height);
	//line(0, 0, width, height);
	//line(width, 0, 0, height);
	//line(0, height /2, width, height / 2);

	rectMode(CORNER);
	ellipseMode(CORNER);
	
	//smooth();
}

void draw() {
  draw_func();
}"
"695299","Strips","mySketch","float xmotion = 8.8;
float ymotion = 2.2;

float hitx = 0;
float hity = 0;

void draw_func() {	
	noStroke();
	noFill();
	
	strokeWeight(2);
	
	ellipseMode(CENTER);
	rectMode(CENTER);
	
	loadPixels();
	for (int y = 0; y < height; y += 2) {
		int yy = y * width;
		for (int x = 0; x < width; x += 2) {
			color p = pixels[yy + x];
			
			if (brightness(p) > 0 && brightness(p) < 128) {
				float d = 1;
				if (hitx == 0) {
					hitx = x;
					hity = y;
				} else {
					d = dist(hitx, hity, x, y) / 192;
				}
				
				float n = (0.5-noise((float)x / width + xmotion, (float)y / height + ymotion)) * 2. * 8 * (d * 2);
				
				fill(8 + abs(n / 4), 8 + abs(n / 4), 128 + random(192, 255) / d, random(1, 48));
				stroke(0, 0, 0, 4);
				
				ellipse(x + n, y + 2 + n, 32, 32);
			}
		}
	}
	
	noFill();
	noStroke();
  
	/*
	rectMode(CENTER);
	ellipseMode(CENTER);
	strokeWeight(64);
	stroke(0, 0, 0, 255);
	ellipse(width / 2, height / 2, width, height);
	ellipse(width / 2, height / 2, width, height);
	ellipse(width / 2, height / 2, width, height);
	strokeWeight(2);
	stroke(0, 0, 256, 255);
	ellipse(width / 2, height / 2, width-32, height-32);
	ellipse(width / 2, height / 2, width-64, height-64);
	rectMode(CORNER);
	*/

	xmotion += 1.4;
	ymotion += 1.1;
}

void setup() {
  size(600, 600);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	strokeWeight(1);
	
	stroke(0, 0, 32, 255);
	
	line(0, random(0, height), width, random(0, height));
	
	ellipseMode(CENTER);
	//ellipse(width / 2, height / 2, 64, 8);

	//smooth();
}

void draw() {
  draw_func();
}"
"695293","Latte","mySketch","float xmotion = 8.8;
float ymotion = 2.2;

void draw_func() {	
	noStroke();
	noFill();
	
	strokeWeight(2);
	
	ellipseMode(CENTER);
	rectMode(CENTER);
	
	loadPixels();
	for (int y = 0; y < height; y += 2) {
		int yy = y * width;
		for (int x = 0; x < width; x += 2) {
			color p = pixels[yy + x];
			
			if (brightness(p) > 8 && brightness(p) < 128) {
				float n = (0.5-noise((float)x / width + xmotion, (float)y / height + ymotion)) * 2. * 48;
				
				fill(8 + abs(n * 2), 8 + abs(n * 4), random(192, 255), random(1, 32));
				stroke(0, 0, 0, 2);
				
				ellipse(x + n + random(-1, 1), y + n + random(-1, 1), 32, 32);
			}
		}
	}
	
	noFill();
	noStroke();
  
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	strokeWeight(64);
	stroke(0, 0, 0, 255);
	ellipse(width / 2, height / 2, width, height);
	ellipse(width / 2, height / 2, width, height);
	ellipse(width / 2, height / 2, width, height);
	strokeWeight(2);
	stroke(0, 0, 256, 255);
	ellipse(width / 2, height / 2, width-32, height-32);
	ellipse(width / 2, height / 2, width-64, height-64);
	rectMode(CORNER);
	
	

	xmotion += 1.4;
	ymotion += 1.1;
}

void setup() {
  size(600, 600);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	strokeWeight(2);
	
	stroke(0, 0, 256, 255);
	
	//line(width / 3.7, height / 2.5, width / 1.7, height / 3.5);
	//line(width / 3.7, height / 1.25, width / 2.7, height / 2.5);
	
	//ellipseMode(CENTER);
	//ellipse(width / 2, height / 2, 64, 8);
	
	fill(0, 0, 92, 255);
	
	textSize(128);
	textAlign(CENTER, CENTER);
	text(""LATTE"", width / 2, height / 2);
	
	//smooth();
}

void draw() {
  draw_func();
}"
"693538","les motifs 2","mySketch","float xmotion = 0.0;
float ymotion = 0.0;

float[] pattern = {
1.0, 0.0, 0.0, 0.0,
0.0, 0.0, 0.0, 0.0,
0.0, 0.0, 0.0, 0.0,
0.0, 0.0, 0.0, 0.0,
	
0.0, 0.0, 0.0, 0.0,
0.0, 0.0, 0.0, 0.0,
0.0, 0.0, 0.0, 0.0,
1.0, 1.0, 1.0, 1.0,
	
0.1, 0.1, 0.1, 0.0,
0.0, 0.0, 0.0, 0.0,
0.0, 0.0, 0.0, 0.0,
0.0, 0.0, 0.0, 0.0,
	
0.0, 0.0, 0.0, 0.0,
0.0, 0.1, 0.1, 0.0,
0.0, 0.0, 0.0, 0.0,
0.0, 0.0, 0.0, 0.0,

0.0, 0.0, 0.0, 0.0,
0.0, 0.0, 0.0, 0.0,
0.0, 0.1, 0.1, 0.0,
0.0, 0.0, 0.0, 0.0,
	
0.0, 0.0, 0.0, 0.0,
0.1, 0.0, 1.0, 0.0,
0.0, 0.0, 0.0, 0.0,
0.0, 0.0, 0.1, 0.0,
	
0.0, 0.0, 0.0, 0.0,
0.0, 0.0, 0.0, 0.5,
0.0, 0.0, 0.0, 0.0,
0.0, 0.1, 0.0, 0.0,
	
1.0, 0.0, 0.0, 0.0,
0.0, 0.0, 0.0, 0.0,
0.0, 0.0, 0.0, 0.0,
0.0, 0.0, 0.0, 0.0,
};

int f = 0;
void poke(int h, int x, int y, int sign) {
	int stax = 0;
	int sizx = 5;
	int offx = x;
	for (int xx = 0; xx < sizx; xx += 1) {
		int stay = 0;
		int sizy = 5;
		int offy = y;
		for (int yy = 0; yy < sizy; yy += 1) {
			float px = pattern[(xx%4) + (yy%4) * 4 + 16 * f];
			
			if (px) {
				fill(h + 1 + abs(sin(PI * 2 + px / 8)) * 128, 0, 255, 148);

				//rect(offx + xx + stax, offy + yy + stay, 1, 1);
				rect(width - offx + xx + stax, offy + yy + stay, 1, 1);
				//rect(offx + xx + stax, height - offy + yy + stay, 1, 1);
				//rect(width - offx + xx + stax, height - offy + yy + stay, 1, 1);
			}
		}
	}
}

void draw_func() {
	noStroke();
	noFill();
	
	loadPixels();
	for (int y = 0; y < height; y += 2) {
		int yy = y * width;
		for (int x = 0; x < width; x += 2) {
			color p = pixels[yy + x];
			
			if (brightness(p) > 1 && brightness(p) < 128) {
				int h = hue(p);
				
				poke(h, x, y, 0);
				

			}
		}
	}
	
	f += 1;
	f %= 8;
	
	xmotion += 0.01;
	ymotion += 0.1;
	/*
	noFill();
	strokeWeight(256);
	stroke(0, 0, 0, 256);
	
	int w = 256;
	int h = 256;
	
	ellipse(width / 2, height / 2, 256 * 3.25, 380 * 2.5);*/
}

void setup() {
  size(400, 400);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	frameRate(30);
	
	noiseDetail(9,0.65);
	
	mouseClicked();
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	//smooth();
}

void mouseClicked() {
	background(0);
	
	noStroke();
	fill(32, 128, 256, 1);
	
	int w = 256;
	int h = 256;
	
	//ellipse(width / 2, height / 2, 256, 380);
	
	noFill();
	strokeWeight(8);
	stroke(random(0, 360), 128, 256, 1);
	
	//ellipse(width / 2, height / 2, 256 * 1.75, 380 * 1.5);
	
	float r = random();
	if (r > 1.0 - 0.33) {
		line(0, random(0, height), width, random(0, height));
	} else if (r > 1.0 - 0.33*2) {
		line(random(0, width), 0, random(0, width), height);
	} else {
		line(0, random(0, height), width, random(0, height));
		line(random(0, width), 0, random(0, width), height);
	}
	
	//line(width / 2, height / 1.5, width / 16 - 28, height);
	//line(width / 16 - 28, height / 2.5, width, height);
	//line(width / 2, height / 8.5, width / 16 - 28, height);
}

void draw() {
  draw_func();
}"
"693538","les motifs 2","mySketch","float xmotion = 0.0;
float ymotion = 0.0;

float[] pattern = {
1.0, 0.0, 0.0, 0.0,
0.0, 0.0, 0.0, 0.0,
0.0, 0.0, 0.0, 0.0,
0.0, 0.0, 0.0, 0.0,
	
0.0, 0.0, 0.0, 0.0,
0.0, 0.0, 0.0, 0.0,
0.0, 0.0, 0.0, 0.0,
1.0, 1.0, 1.0, 1.0,
	
0.1, 0.1, 0.1, 0.0,
0.0, 0.0, 0.0, 0.0,
0.0, 0.0, 0.0, 0.0,
0.0, 0.0, 0.0, 0.0,
	
0.0, 0.0, 0.0, 0.0,
0.0, 0.1, 0.1, 0.0,
0.0, 0.0, 0.0, 0.0,
0.0, 0.0, 0.0, 0.0,

0.0, 0.0, 0.0, 0.0,
0.0, 0.0, 0.0, 0.0,
0.0, 0.1, 0.1, 0.0,
0.0, 0.0, 0.0, 0.0,
	
0.0, 0.0, 0.0, 0.0,
0.1, 0.0, 1.0, 0.0,
0.0, 0.0, 0.0, 0.0,
0.0, 0.0, 0.1, 0.0,
	
0.0, 0.0, 0.0, 0.0,
0.0, 0.0, 0.0, 0.5,
0.0, 0.0, 0.0, 0.0,
0.0, 0.1, 0.0, 0.0,
	
1.0, 0.0, 0.0, 0.0,
0.0, 0.0, 0.0, 0.0,
0.0, 0.0, 0.0, 0.0,
0.0, 0.0, 0.0, 0.0,
};

int f = 0;
void poke(int h, int x, int y, int sign) {
	int stax = 0;
	int sizx = 5;
	int offx = x;
	for (int xx = 0; xx < sizx; xx += 1) {
		int stay = 0;
		int sizy = 5;
		int offy = y;
		for (int yy = 0; yy < sizy; yy += 1) {
			float px = pattern[(xx%4) + (yy%4) * 4 + 16 * f];
			
			if (px) {
				fill(h + 1 + abs(sin(PI * 2 + px / 8)) * 128, 0, 255, 92);

				//rect(offx + xx + stax, offy + yy + stay, 1, 1);
				rect(width - offx + xx + stax, offy + yy + stay, 1, 1);
				//rect(width - offx + xx + stax, height - offy + yy + stay, 1, 1);
				//rect(width - offx + xx + stax, height - offy + yy + stay, 1, 1);
			}
		}
	}
}

void draw_func() {
	noStroke();
	noFill();
	
	loadPixels();
	for (int y = 0; y < height; y += 2) {
		int yy = y * width;
		for (int x = 0; x < width; x += 2) {
			color p = pixels[yy + x];
			
			if (brightness(p) > 1 && brightness(p) < 128) {
				int h = hue(p);
				
				poke(h, x, y, 0);
				

			}
		}
	}
	
	f += 1;
	f %= 8;
	
	xmotion += 0.01;
	ymotion += 0.1;
	/*
	noFill();
	strokeWeight(256);
	stroke(0, 0, 0, 256);
	
	int w = 256;
	int h = 256;
	
	ellipse(width / 2, height / 2, 256 * 3.25, 380 * 2.5);*/
}

void setup() {
  size(400, 400);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	frameRate(30);
	
	noiseDetail(9,0.65);
	
	mouseClicked();
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	//smooth();
}

void mouseClicked() {
	background(0);
	
	noStroke();
	fill(32, 128, 256, 1);
	
	int w = 256;
	int h = 256;
	
	//ellipse(width / 2, height / 2, 256, 380);
	
	noFill();
	strokeWeight(8);
	stroke(random(0, 360), 128, 256, 1);
	
	//ellipse(width / 2, height / 2, 256 * 1.75, 380 * 1.5);
	
	float r = random();
	if (r > 1.0 - 0.33) {
		line(0, random(0, height), width, random(0, height));
	} else if (r > 1.0 - 0.33*2) {
		line(random(0, width), 0, random(0, width), height);
	} else {
		line(0, random(0, height), width, random(0, height));
		line(random(0, width), 0, random(0, width), height);
	}
	
	//line(width / 2, height / 1.5, width / 16 - 28, height);
	//line(width / 16 - 28, height / 2.5, width, height);
	//line(width / 2, height / 8.5, width / 16 - 28, height);
}

void draw() {
  draw_func();
}"
"692096","Mousse","mySketch","// fur-like feedback with triangles

float xmotion = 8.8;
float ymotion = 2.2;

void draw_func() {
	noStroke();
	
	loadPixels();
	for (int x = 1; x < width; x += 4) {
		float norm_x = x / width;

		for (int y = 1; y < height; y += 4) {
			color p = pixels[y * width + x];
			
			if (brightness(p) > 92 && brightness(p) < 128) {
				float norm_y = y / height;
				
				color p2 = pixels[(y+ceil(random(-4, 4))) * width + (x+ceil(random(-4, 4)))];
				
				fill(hue(p2) + 3, 128, 256, 24);
				
				int x1 = width - x + random(-2,2);
				int y1 = height - y + random(-2,2);
				int x2 = width - x + cos(norm_x * PI * 2 + xmotion) * 8;
				int y2 = y1 + sin(norm_y * PI * 2 + ymotion) * 16;
				int x3 = x2 - sin(norm_x * PI * 2 + xmotion) * 16;
				int y3 = y1 + cos(norm_y * PI * 2 + ymotion) * 16;
				triangle(x1, y1, x2, y2, x3, y3)
			} else if (brightness(p) > 224) {
				float norm_y = y / height;
				
				fill(0, 0, 0, 12);
				
				int x1 = x;
				int y1 = y;
				int x2 = x + random(-8, 8);
				int y2 = y1 + random(-8,8);
				int x3 = x2 - random(-8,8);
				int y3 = y1 + random(-8,8);
				triangle(x1, y1, x2, y2, x3, y3)
				triangle(y1, x1, y2, x2, y3, x3)
			}
		}
	}
	
	xmotion += 0.02;
	ymotion -= 0.01;
	
/*
	ellipseMode(CENTER);
	fill(0, 0, 0, 8);
	ellipse(width /2, height /2, 450, 300);*/
}

void setup() {
  size(800, 800);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	noFill();
	strokeWeight(32);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	stroke(48, 128, 256, 256);
	ellipse(width /2, height /2, 400, 400);
	//stroke(128, 128, 256, 256);
	//ellipse(width /2, height /2, 500, 300);

	//line(0, 0, width, height);
	//line(width, 0, 0, height);
	//line(0, 0, width, height);
	//line(width, 0, 0, height);
	//line(0, height /2, width, height / 2);

	rectMode(CORNER);
	ellipseMode(CORNER);
	
	//smooth();
}

void draw() {
  draw_func();
}"
"692039","L'oiseau","mySketch","float xmotion = 8.8;
float ymotion = 2.2;
float color_wheel = 2;
float start_colors1 = 224;

void draw_func() {
	if ((frameCount % 220) == 0) {
		frameCount = 0;
		background(0);
		color_wheel = random(0.5, 2);
		start_colors1 = random(210, 240);
	}
	
	noStroke();
	
	loadPixels();
	for (int y = 0; y < height; y += 2) {
		int yy = y * width;
		for (int x = 0; x < width; x += 2) {
			color p = pixels[yy + x];
			
			if (brightness(p) > 0 && brightness(p) < 92) {
				float n = (0.5-noise((float)x/width*400+xmotion,(float)y/height*400+ymotion))*2;
				float n2 = (0.5-noise((float)y/height*400+ymotion,(float)x/width*400+xmotion))*1;
				
				fill(hue(p) + abs(n)*color_wheel, 128, 255, 33);
				
				ellipse(x + n, y + n, 4, 4);
				ellipse(width - x  - n2, y - n2, 4, 4);
			}
		}
	}
	
	noFill();
	noStroke();
  strokeWeight(1);
	
	rectMode(CENTER);
	ellipseMode(CENTER);

	for (int i = 1; i < 32; i += 1) {
		float norm_i = 1-((float)(i - 1) / 32);
		
		stroke(16+random(0, 128), 128 * norm_i, 255 * norm_i, 1);

		//int sw = (float)width/2 / (i * 1) + abs(cos(ymotion/2) * 256);
		//int sh = height/2 / (i * 1)+ abs(sin(xmotion/2) * 64);
		
		float n = random(0, 1);
		//line(width/64*i, 0, width/64*i, height);
		line(0, height/32*i, width/i*pow(i, 0.01), height/32*i);
	}
	rectMode(CORNER);
	
	if (frameCount < 2) {
		fill(start_colors1, 128, 255, 8);
		ellipse(width / 3.25, height / 1.75, 64, 64);
		arc(width / 2, height / 1.25, 200, 12, 0, PI, CHORD);
	}

	xmotion += 0.4;
	ymotion += 0.8;
}

void setup() {
  size(600, 600);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	noiseDetail(7,0.65);
	
	frameRate(30);
	
	//smooth();
}

void draw() {
  draw_func();
}"
"692006","les motifs","mySketch","float xmotion = 0.0;
float ymotion = 0.0;

float[] pattern = {
1.0, 0.0, 0.0, 0.0,
0.0, 0.0, 0.0, 0.0,
0.0, 0.0, 0.0, 0.0,
0.0, 0.0, 0.0, 0.0,
	
0.0, 0.0, 0.0, 0.0,
0.0, 0.0, 0.0, 0.0,
0.0, 0.0, 0.0, 0.0,
1.0, 1.0, 1.0, 1.0,
	
0.1, 0.1, 0.1, 0.0,
0.0, 0.0, 0.0, 0.0,
0.0, 0.0, 0.0, 0.0,
0.0, 0.0, 0.0, 0.0,
	
0.0, 0.0, 0.0, 0.0,
0.0, 0.1, 0.1, 0.0,
0.0, 0.0, 0.0, 0.0,
0.0, 0.0, 0.0, 0.0,

0.0, 0.0, 0.0, 0.0,
0.0, 0.0, 0.0, 0.0,
0.0, 0.1, 0.1, 0.0,
0.0, 0.0, 0.0, 0.0,
	
0.0, 0.0, 0.0, 0.0,
0.1, 0.0, 1.0, 0.0,
0.0, 0.0, 0.0, 0.0,
0.0, 0.0, 0.1, 0.0,
	
0.0, 0.0, 0.0, 0.0,
0.0, 0.0, 0.0, 0.5,
0.0, 0.0, 0.0, 0.0,
0.0, 0.1, 0.0, 0.0,
	
1.0, 0.0, 0.0, 0.0,
0.0, 0.0, 0.0, 0.0,
0.0, 0.0, 0.0, 0.0,
0.0, 0.0, 0.0, 0.0,
};

int f = 0;
void poke(int h, int x, int y, int sign) {
	int stax = 0;
	int sizx = 5;
	int offx = x;
	for (int xx = 0; xx < sizx; xx += 1) {
		int stay = 0;
		int sizy = 5;
		int offy = y;
		for (int yy = 0; yy < sizy; yy += 1) {
			float px = pattern[(xx%4) + (yy%4) * 4 + 16 * f];
			
			if (px) {
				fill(h + 1 + abs(sin(PI * 2 + px / 8)) * 128, 0, 255, 148);

				//rect(offx + xx + stax, offy + yy + stay, 1, 1);
				rect(width - offx + xx + stax, offy + yy + stay, 1, 1);
				rect(offx + xx + stax, height - offy + yy + stay, 1, 1);
				//rect(width - offx + xx + stax, height - offy + yy + stay, 1, 1);
			}
		}
	}
}

void draw_func() {
	noStroke();
	noFill();
	
	loadPixels();
	for (int y = 0; y < height; y += 4) {
		int yy = y * width;
		for (int x = 0; x < width; x += 4) {
			color p = pixels[yy + x];
			
			if (brightness(p) > 1 && brightness(p) < 128) {
				int h = hue(p);
				
				poke(h, x, y, 0);
				

			}
		}
	}
	
	f += 1;
	f %= 8;
	
	xmotion += 0.01;
	ymotion += 0.1;
	/*
	noFill();
	strokeWeight(256);
	stroke(0, 0, 0, 256);
	
	int w = 256;
	int h = 256;
	
	ellipse(width / 2, height / 2, 256 * 3.25, 380 * 2.5);*/
}

void setup() {
  size(600, 600);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	frameRate(30);
	
	noiseDetail(9,0.65);
	
	mouseClicked();
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	//smooth();
}

void mouseClicked() {
	background(0);
	
	noStroke();
	fill(32, 128, 256, 1);
	
	int w = 256;
	int h = 256;
	
	//ellipse(width / 2, height / 2, 256, 380);
	
	noFill();
	strokeWeight(8);
	stroke(random(0, 360), 128, 256, 1);
	
	//ellipse(width / 2, height / 2, 256 * 1.75, 380 * 1.5);
	
	float r = random();
	if (r > 1.0 - 0.33) {
		line(0, random(0, height), width, random(0, height));
	} else if (r > 1.0 - 0.33*2) {
		line(random(0, width), 0, random(0, width), height);
	} else {
		line(0, random(0, height), width, random(0, height));
		line(random(0, width), 0, random(0, width), height);
	}
	
	//line(width / 2, height / 1.5, width / 16 - 28, height);
	//line(width / 16 - 28, height / 2.5, width, height);
	//line(width / 2, height / 8.5, width / 16 - 28, height);
}

void draw() {
  draw_func();
}"
"688253","Procedural painting","mySketch","// with a bit different feedback parameters, it look like sands with very subtle shading
// the shading is actually 
// many other 'shapes' can be done by modifying parameters
// interestingly by varying the pixels ellipse size / hue introduce drawing-like figures (Pareidolia ?)

float xmotion = 4;
float ymotion = 2;

float f = 0;

void draw_func() {
	if ((frameCount % 200) == 0) {
		background(0);
		
    f = 0;
	}
	
	noStroke();
	
	ellipseMode(CENTER);

	loadPixels();
	for (int y = 0; y < height; y += 2) {
		int yy = y * width;
		for (int x = 0; x < width; x += 2) {
			color p = pixels[yy + x];
			
			if (brightness(p) > 1 && brightness(p) < 192) {
				float v = (1-(pow(f, 1.1) / 360));
				fill(2 + hue(p) - abs(cos(v * PI * 2 + xmotion)) * 2, 128, 256, 92 * v);
				
				ellipse(x + random(-1, 1), y, 4, 4);
				ellipse(width - x + random(-1, 1), height - y, 1, 1);
			}
		}
	}
	
	noFill();
	noStroke();
  strokeWeight(1);
	
	rectMode(CENTER);

	for (int i = 1; i < 8; i += 2) {
		float norm_i = 1-((float)(i - 1) / 8);
		
		stroke((frameCount % 2) * 192, 128 * norm_i, 255 * norm_i, 1);

		int sw = (float)width/2 / (i*2) + abs(cos(ymotion/2) * 92);
		int sh = height/2 / (i*2)+ abs(sin(xmotion/2) * 92);
		
		if (i % 2) {
			//ellipse(width / 2, height / 2, sw, sh);
			ellipse(width / 2, height, sw, sh);
			ellipse(width / 2, 0, sw, sh);
			//ellipse(0, height, sw, sh);
			//ellipse(width, height, sw, sh);
		} else {
			rect(width / 2, height / 2, sw, sh);
			//rect(width / 2, height, sw/2, sh/2);
			//rect(width / 2, 0, sw/2, sh/2);
			//rect(width, height / 2, sw, sh);
			//rect(0, height / 2, sw, sh);
		}
	}
	rectMode(CORNER);

	f += 1;

	xmotion += 1.1;
	ymotion += 1.5;
}

void setup() {
  size(600, 600);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	frameRate(30);
	
	//smooth();
}

void draw() {
  draw_func();
}"
"688237","Le sable","mySketch","// with a bit different feedback parameters, it look like sands with very subtle shading
// the shading is actually 
// many other 'shapes' can be done by modifying parameters
// interestingly by varying the pixels ellipse size / hue introduce drawing-like figures (Pareidolia ?)

float xmotion = 8.8;
float ymotion = 2.2;

void draw_func() {
	if ((frameCount % 160) == 0) {
		background(0);
	}
	
	noStroke();
	
	loadPixels();
	for (int y = 0; y < height; y += 2) {
		int yy = y * width;
		for (int x = 0; x < width; x += 2) {
			color p = pixels[yy + x];
			
			if (brightness(p) > 0 && brightness(p) < 128) {
				fill(hue(p)*1.01, 128, 255, 48);
				
				ellipse(x + random(-1, 1), y + random(-1, 1), 4, 4);
				ellipse(width - x + random(-1, 1), y + random(-1, 1), 4, 4);
			}
		}
	}
	
	noFill();
	noStroke();
  strokeWeight(1);
	
	rectMode(CENTER);
	ellipseMode(CENTER);

	for (int i = 1; i < 4; i += 1) {
		float norm_i = 1-((float)(i - 1) / 4);
		
		stroke(64+(frameCount % 2) * 92, 128 * norm_i, 255 * norm_i, 1);

		int sw = (float)width/2 / (i * 2) + abs(cos(ymotion/2) * 256);
		int sh = height/2 / (i * 2)+ abs(sin(xmotion/2) * 64);
		
		if (i % 2) {
			ellipse(width / 2, height / 2, sw, sh);
			//ellipse(width / 2, height, sw, sh);
			//ellipse(width / 2, 0, sw, sh);
			//ellipse(0, height / 2, sw, sh);
			//ellipse(width, height / 2, sw, sh);
		} else {
			rect(width / 2, height /2, sw, sh);
			//rect(width / 2, height, sw, sh);
			//rect(width / 2, 0, sw, sh);
			//rect(width, height / 2, sw, sh);
			//rect(0, height / 2, sw, sh);
		}
	}
	rectMode(CORNERS);

	

	xmotion += 0.4;
	ymotion += 0.1;
}

void setup() {
  size(600, 600);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	frameRate(30);
	
	//smooth();
}

void draw() {
  draw_func();
}"
"688237","Le sable","mySketch","// with a bit different feedback parameters, it look like sands with very subtle shading
// the shading is actually 
// many other 'shapes' can be done by modifying parameters
// interestingly by varying the pixels ellipse size / hue introduce drawing-like figures (Pareidolia ?)

float xmotion = 8.8;
float ymotion = 2.2;

void draw_func() {
	if ((frameCount % 160) == 0) {
		background(0);
	}
	
	noStroke();
	
	loadPixels();
	for (int y = 0; y < height; y += 1) {
		int yy = y * width;
		for (int x = 0; x < width; x += 1) {
			color p = pixels[yy + x];
			
			if (brightness(p) > 0 && brightness(p) < 128) {
				fill(hue(p)*1.01, 0, 255, 48);
				
				int offx = random(-1, 1);
				for (int x = offx; x < 4 + -offx; x += 1) {
					
				}
				//ellipse(x + random(-1, 1), y + random(-1, 1), 4, 4);
				//ellipse(width - x + random(-1, 1), y + random(-1, 1), 4, 4);
			}
		}
	}
	
	noFill();
	noStroke();
  strokeWeight(1);
	
	rectMode(CENTER);
	ellipseMode(CENTER);

	for (int i = 1; i < 4; i += 1) {
		float norm_i = 1-((float)(i - 1) / 4);
		
		stroke(64+(frameCount % 2) * 92, 128 * norm_i, 255 * norm_i, 1);

		int sw = 256;//(float)width/2 / (i * 2) + abs(cos(ymotion/2) * 256);
		int sh = 64;//height/2 / (i * 2)+ abs(sin(xmotion/2) * 64);
		
		if (i % 2) {
			ellipse(width / 2, height / 2, sw, sh);
			//ellipse(width / 2, height, sw, sh);
			//ellipse(width / 2, 0, sw, sh);
			//ellipse(0, height / 2, sw, sh);
			//ellipse(width, height / 2, sw, sh);
		} else {
			rect(width / 2, height /2, sw, sh);
			//rect(width / 2, height, sw, sh);
			//rect(width / 2, 0, sw, sh);
			//rect(width, height / 2, sw, sh);
			//rect(0, height / 2, sw, sh);
		}
	}
	rectMode(CORNERS);

	

	xmotion += 0.4;
	ymotion += 0.1;
}

void setup() {
  size(600, 600);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	frameRate(30);
	
	//smooth();
}

void draw() {
  draw_func();
}"
"688237","Le sable","mySketch","// with a bit different feedback parameters, it look like sands with very subtle shading
// the shading is actually 
// many other 'shapes' can be done by modifying parameters
// interestingly by varying the pixels ellipse size / hue introduce drawing-like figures (Pareidolia ?)

float xmotion = 8.8;
float ymotion = 2.2;

void draw_func() {
	if ((frameCount % 160) == 0) {
		background(0);
	}
	
	noStroke();
	
	loadPixels();
	for (int y = 0; y < height; y += 2) {
		int yy = y * width;
		for (int x = 0; x < width; x += 2) {
			color p = pixels[yy + x];
			
			if (brightness(p) > 0 && brightness(p) < 128) {
				fill(hue(p)*1.01, 128, 255, 48);
				
				ellipse(x + random(-1, 1), y + random(-1, 1), 4, 4);
				ellipse(width - x + random(-1, 1), y + random(-1, 1), 4, 4);
			}
		}
	}
	
	noFill();
	noStroke();
  strokeWeight(1);
	
	rectMode(CENTER);
	ellipseMode(CENTER);

	for (int i = 1; i < 4; i += 1) {
		float norm_i = 1-((float)(i - 1) / 4);
		
		stroke(64+(frameCount % 2) * 92, 128 * norm_i, 255 * norm_i, 1);

		int sw = (float)width/2 / (i * 2) + abs(cos(ymotion/2) * 256);
		int sh = height/2 / (i * 2)+ abs(sin(xmotion/2) * 64);
		
		if (i % 2) {
			ellipse(width / 2, height / 2, sw, sh);
			//ellipse(width / 2, height, sw, sh);
			//ellipse(width / 2, 0, sw, sh);
			//ellipse(0, height / 2, sw, sh);
			//ellipse(width, height / 2, sw, sh);
		} else {
			rect(width / 2, height /2, sw, sh);
			//rect(width / 2, height, sw, sh);
			//rect(width / 2, 0, sw, sh);
			//rect(width, height / 2, sw, sh);
			//rect(0, height / 2, sw, sh);
		}
	}
	rectMode(CORNERS);

	

	xmotion += 0.4;
	ymotion += 0.1;
}

void setup() {
  size(600, 600);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	frameRate(30);
	
	//smooth();
}

void draw() {
  draw_func();
}"
"688187","Painting generator","mySketch","float xmotion = 8.8;
float ymotion = 2.2;

void draw_func() {
	noStroke();
	
	loadPixels();
	for (int y = 0; y < height; y += 2) {
		int yy = y * width;
		for (int x = 0; x < width; x += 2) {
			color p = pixels[yy + x];
			
			if (brightness(p) > 0 && brightness(p) < 24 && random() > 0.75) {
				fill(hue(p) * 1.2525, 128, 255, 48);
				
				float n = noise(x / width, y / height) * 2;
				
				ellipse(x + random(-64, 64) * n, y + random(-32, 32) * n, 64, 64);
			}
		}
	}
	
	noFill();
	noStroke();
  strokeWeight(32);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	for (int i = 2; i < 32; i += 1) {
		float norm_i = 1-((float)(i - 2) / 128);
		
		stroke(192+frameCount % 4 * 2 + sin(xmotion * norm_i) * 32, 128, 128 * (1-norm_i), random(64, 255) * norm_i);

		int sw = (float)width/2 / (i / 8) + abs(cos(xmotion) * 600);
		int sh = height/2 / (i / 8)+ abs(cos(xmotion) * 600);
		
		rect(width / 2, height / 2, sw, sh);
	}
	rectMode(CORNERS);

	xmotion += 0.25;
	ymotion += 0.35;
}

void setup() {
  size(600, 600);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	noFill();
	strokeWeight(16);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	fill(0, 0, 255, 255);
	
	//ellipse(width / 2, height / 2, 700, 700);

	rectMode(CORNER);
	ellipseMode(CORNER);
	
	//smooth();
}

void draw() {
  draw_func();
}"
"688181","Configuration","mySketch","float xmotion = 8.8;
float ymotion = 2.2;

void draw_func() {
	noStroke();
	
	loadPixels();
	for (int y = 0; y < height; y += 2) {
		int yy = y * width;
		for (int x = 0; x < width; x += 2) {
			color p = pixels[yy + x];
			
			if (brightness(p) > 0 && brightness(p) < 24) {
				fill(hue(p) * 1.2525, 128, 255, 48);
				
				float n = noise(x / width, y / height);
				
				ellipse(x + random(-64, 64) * n, y + random(-64, 64) * n, 64, 64);
			}
		}
	}
	
	noFill();
	noStroke();
  strokeWeight(24);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	for (int i = 2; i < 32; i += 1) {
		float norm_i = 1-((float)(i - 2) / 64);
		
		stroke(192+frameCount % 4 * 2, 128, 128 * (1-norm_i), random(64, 255) * norm_i);

		int sw = (float)width/2 / (i / 8) + abs(cos(ymotion/2) * 512);
		int sh = height/2 / (i / 8)+ abs(cos(ymotion/2) * 512);
		
		ellipse(width / 2, height / 2, sw, sh);
	}
	rectMode(CORNERS);

	xmotion += 0.1;
	ymotion += 0.4;
}

void setup() {
  size(600, 600);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	noFill();
	strokeWeight(16);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	fill(0, 0, 255, 255);
	
	//ellipse(width / 2, height / 2, 700, 700);

	rectMode(CORNER);
	ellipseMode(CORNER);
	
	//smooth();
}

void draw() {
  draw_func();
}"
"685164","Web","mySketch","// feedback again; stumbled on some interesting stuff to develop while doing this.

float xmotion = 8.8;
float ymotion = 2.2;

int maxe = 0;

void draw_func() {
	noStroke();
	
	int e = 0;

	ellipseMode(CENTER);
	
	loadPixels();
	if (frameCount % 2 == 0)
	for (int x = 0; x < width; x += 8) {
		float norm_x = x / width;
		float anorm_x = abs(0.5 - norm_x) * 2;
		
		for (int y = 0; y < height; y += 8) {
			color p = pixels[y * width + x];
			
			if (brightness(p) >= 0 && brightness(p) < 128) {
				fill(0, 0, 255, 24);
				
				ellipse(x, y, 12, 12);
				//ellipse(width - x + random(-1,1), height - y+ random(-1,1), 12, 12);
				//ellipse(width - x, height - y, 48, 48);
			} else if (brightness(p) >= 128) {
				float norm_y = y / height;
				float anorm_y = abs(0.5 - norm_y) * 2;
				
				float norm_e = (float)e / maxe;
				
				fill(0, 0, 0, 24);
				ellipse(x + sin(xmotion + norm_e * PI *2 ) * 128, y + cos(ymotion + norm_e * PI *2 ) * 128, 28, 28);
				//ellipse(width - x + random(-2,2), height - y + random(-2,2), 8, 8);
				//ellipse(y + random(-8,8), x + random(-8,8), r / 2, r / 2);
				
				e += 1;
			}
		}
	}
	maxe = e+1;
	
	rectMode(CENTER);
	//ellipseMode(CENTER);

	noFill();
	stroke(0, 0, 255, 255);
	for (int y = 0; y < 512; y += 128) {
		float norm_y = (float)y / 512;
		float anorm_y = 1-abs(0.5 - norm_y) * 2;
		strokeWeight(1 + 1 * anorm_y);
		line(0, height - y, width, y);
		line(width - y, 0, y, height);
	}
	
	// web
	for (int y = 0; y < 128 * 7; y += 128) {
		float norm_y = (float)y / 512;
		float anorm_y = 1-abs(0.5 - norm_y) * 2;
		strokeWeight(1 + 1 * norm_y);
		ellipse(width / 2, height / 2, 8 + norm_y * 300  + anorm_y * 62, 8 + norm_y * 310 + anorm_y * 64);
	}
	
	stroke(0, 0, 0, 255);
	fill(0, 0, 0, 255);
	ellipse(width / 2 + + random(-2, 2), height / 2+ random(-2, 2), width * (0.01 + random(0, 1) / 128), height * (0.009 + random(0, 1) / 128));

	rectMode(CORNER);
	//ellipseMode(CORNER);

	xmotion += 0.0025;
	ymotion += 0.002;
}

void setup() {
  size(600, 600);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	noFill();
	strokeWeight(16);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	fill(0, 0, 255, 255);
	
	//ellipse(width / 2, height / 2, 40, 40);

	rectMode(CORNER);
	ellipseMode(CORNER);
	
	smooth();
}

void draw() {
  draw_func();
}"
"684031","Visage","mySketch","// shading as feedback again with a try to do something with dynamic substractive shapes

float xmotion = 8.8;
float ymotion = 2.2;

void draw_func() {
	noStroke();
	
	loadPixels();
	for (int x = 8; x < width - 8; x += 8) {
		float norm_x = x / width;
		float anorm_x = abs(0.5 - norm_x) * 2;
		
		for (int y = 8; y < height - 8; y += 8) {
			color p = pixels[y * width + x];
			
			if (brightness(p) >= 0 && brightness(p) < 128) {
				int ppx = random(8);
				int ppy = random(8);
				color p2 = pixels[(y+ceil(random(-ppx, ppx))) * width + (x+ceil(random(-ppy, ppy)))];
				
				fill(hue(p2) * 0.75, 128, 255, 24);
				
				ellipse(x + random(-8, 8), y + random(-8, 8), 4, 4);
			} else if (brightness(p) >= 128) {
				float norm_y = y / height;
				float anorm_y = abs(0.5 - norm_y) * 2;
				
				float r = random(16, 32);
				
				fill(0, 0, 0, r);
				ellipse(x + random(-8,8), y + random(-8,8), r / 2, r / 2);
				ellipse(y + random(-8,8), x + random(-8,8), r / 2, r / 2);
			}
		}
	}
	
	noStroke();
  strokeWeight(4);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	fill(224, 0, 255, 255);
	ellipse(width / 4 + random(-24, 24), height / 4, 8, 4);
	ellipse(width - width / 4 + random(-24, 24), height / 4, 8 , 4);
	for (int i = 2; i < 16; i += 1) {
		float norm_i = (float)(i - 2) / 4;
		noFill();
		fill(170+(frameCount + 2) % 64, 128, 128 * (1-norm_i), random(2, 12) * norm_i);
		float w = (float)width/2 / (i / 5);
		float h = height/2 / (i / 5);
		ellipse(width / 2, height / 1.35 + random(-16, 16), w*2 + abs(sin(xmotion * 6)*140), h/2 - abs(sin(ymotion * 8)*160));
		ellipse(width / 4, height / 4, w, h - abs(cos(xmotion * 8)*160));
		ellipse(width - width / 4, height / 4, w, h - abs(sin(ymotion * 8)*160));
		//ellipse(width - width / 4, height - height / 4, w, h);
		//ellipse(width / 4, height - height / 4, w, h);
	}
	
	noFill();
	stroke(0, 0, 0, 64);
	strokeWeight(128);
	ellipse(width / 2, height / 2, width * 1.25 + random(128), height * 1.25 + random(-64, 64));
	
	rectMode(CORNERS);
	ellipseMode(CORNER);

	xmotion += 0.02;
	ymotion += 0.01;
}

void setup() {
  size(600, 600);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	noFill();
	strokeWeight(16);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	fill(0, 0, 255, 255);
	
	//ellipse(width / 2, height / 2, 700, 700);

	rectMode(CORNER);
	ellipseMode(CORNER);
	
	//smooth();
}

void draw() {
  draw_func();
}"
"683638","Tile-based checker","mySketch","/*
  This is an experiment with tile-based data, basically replicate old-school tiling hardware of the 80s 
	
	There is two tiles and a tilemap which define which tile will go onto the grid.
	
	The goal was to have a ground onto which i can experiment with tile-based data modification and replicate the moving checkerboard effect of the 80s.
	
	It only use 2 entries of the tilemap (instead of the entire screen) due to an optimization which copy the two first tile as needed to fill the screen.
	
	Can be extended easily (by removing copies and uncomment first loop mw/mh) to be like old-school tiling hardware but it is very slow...
*/

static int w = 400;
static int h = 400;
static int tw = 40;
static int th = 40;
static int mw = w / tw;
static int mh = h / th;
static int tiles_len = tw * th * 2;

int tiles[] = new int[tiles_len];
int tilemap[] = new int[mw * mh];

void setup() {
  size(400, 400);
  
  noStroke();
  
  background (0);
	
	colorMode(HSB, 360, 255, 255);
  
  int x = 0, y = 0;
  for (y = 0; y < th; y += 1) {
    for (x = 0; x < tw; x += 1) {
      int index = x + y * (tw * 2);
      tiles[index] = 255;
    }
  }
  
  int mx = 0, my = 0;
  for (my = 0; my < mh; my += 1) {
    for (mx = 0; mx < mw; mx += 1) {
      int index = mx + my * mw;
      tilemap[index] = (mx^my)%2;
    }
  }
	
	noFill();
}

float xmotion = 0;
float ymotion = 0;

int a = 0;

void draw() {
  //background (0);
  
  int mx = 0, my = 0;
  int tx = 0, ty = 0;
  
  for (my = 0; my < /*mh*/2; my += 1) {
    for (mx = 0; mx < /*mw*/2; mx += 1) {
      int index = mx + my * mw;
      int t = tilemap[index];
      
      for (ty = 0; ty < th; ty += 1) {
        for (tx = 0; tx < tw; tx += 1) {
          int tindex = tx + (t*tw) + (ty) * (tw * 2);
          int v = tiles[tindex];
          
					// pencil like shading
          //fill(0, 0, v, 24);
          //rect(mx * tw + tx, my * th + ty, 4, 4);
					
					// raw (pixels perfect)
          stroke(0, 0, v, 24);
          point(mx * tw + tx, my * th + ty);
        }
      }
    }
  }
	
	for (mx = 0; mx < mw - 2; mx += 1) {
		copy(0, 0, tw * 2, th * 2, tw * 2 + (tw * 2) * mx, 0, tw * 2, th * 2);
	}
	
	for (my = 0; my < mh - 2; my += 1) {
		copy(0, 0, w, th * 2, 0, th * 2 + (th * 2) * my, w, th * 2);
	}
	
		int x = 0, y = ((int)ymotion)%th;
		//for (y = 0; y < th; y += 1) {
			for (x = 0; x < tw*2; x += 1) {
				int index = (x + y * (tw*2) + ((x * y)%tw)) % tiles_len;
				tiles[index] = (int)((x / tw + a) % 2) * 255;
			}
		//}
	
	xmotion += 1;
	ymotion += 4;
	
	if (xmotion % tw == 0) {
		a += 1;
	}
}"
"683638","Tile-based checker","mySketch","/*
  This is an experiment with tile-based data, basically replicate old-school tiling hardware of the 80s 
	
	There is two tiles and a tilemap which define which tile will go onto the grid.
	
	The goal was to have a ground onto which i can experiment with tile-based data modification and replicate the moving checkerboard effect of the 80s.
	
	It only use 2 entries of the tilemap (instead of the entire screen) due to an optimization which copy the two first tile as needed to fill the screen.
	
	Can be extended easily (by removing copies and uncomment first loop mw/mh) to be like old-school tiling hardware but it is very slow...
*/

static int w = 400;
static int h = 400;
static int tw = 40;
static int th = 40;
static int mw = w / tw;
static int mh = h / th;
static int tiles_len = tw * th * 2;

int tiles[] = new int[tiles_len];
int tilemap[] = new int[mw * mh];

void setup() {
  size(400, 400);
  
  noStroke();
  
  background (0);
	
	colorMode(HSB, 360, 255, 255);
  
  int x = 0, y = 0;
  for (y = 0; y < th; y += 1) {
    for (x = 0; x < tw; x += 1) {
      int index = x + y * (tw * 2);
      tiles[index] = 255;
    }
  }
  
  int mx = 0, my = 0;
  for (my = 0; my < mh; my += 1) {
    for (mx = 0; mx < mw; mx += 1) {
      int index = mx + my * mw;
      tilemap[index] = (mx^my)%2;
    }
  }
	
	noFill();
}

float xmotion = 0;
float ymotion = 0;

int a = 0;

void draw() {
  //background(0);
  
  int mx = 0, my = 0;
  int tx = 0, ty = 0;
  
  for (my = 0; my < /*mh*/2; my += 1) {
    for (mx = 0; mx < /*mw*/2; mx += 1) {
      int index = mx + my * mw;
      int t = tilemap[index];
      
      for (ty = 0; ty < th; ty += 1) {
        for (tx = 0; tx < tw; tx += 1) {
          int tindex = tx + (t*tw) + (ty) * (tw * 2);
          int v = tiles[tindex];
          
					// pencil like shading
          //fill(0, 0, v, 24);
          //rect(mx * tw + tx, my * th + ty, 4, 4);
					
					// raw (pixels perfect)
          stroke(0, 0, v, 128);
          point(mx * tw + tx, my * th + ty);
        }
      }
    }
  }
	
	for (mx = 0; mx < mw - 2; mx += 1) {
		copy(0, 0, tw * 2, th * 2, tw * 2 + (tw * 2) * mx, 0, tw * 2, th * 2);
	}
	
	for (my = 0; my < mh - 2; my += 1) {
		copy(0, 0, w, th * 2, 0, th * 2 + (th * 2) * my, w, th * 2);
	}
	
		int x = 0, y = ((int)ymotion)%th;
		//for (y = 0; y < th; y += 1) {
			for (x = 0; x < tw*2; x += 1) {
				int index = (x + y * (tw*2) + ((x * y)%tw)) % tiles_len;
				tiles[index] = (int)((x / tw + a) % 2) * 255;
			}
		//}
	
	xmotion += 1;
	ymotion += 1;
	
	if (xmotion % tw == 0) {
		a += 1;
	}
}"
"683638","Tile-based checker","mySketch","/*
  This is an experiment with tile-based data, basically replicate old-school tiling hardware of the 80s 
	
	There is two tiles and a tilemap which define which tile will go onto the grid.
	
	The goal was to have a ground onto which i can experiment with tile-based data modification and replicate the moving checkerboard effect of the 80s.
	
	It only use 2 entries of the tilemap (instead of the entire screen) due to an optimization which copy the two first tile as needed to fill the screen.
	
	Can be extended easily (by removing copies and uncomment first loop mw/mh) to be like old-school tiling hardware but it is very slow...
*/

static int w = 400;
static int h = 400;
static int tw = 40;
static int th = 40;
static int mw = w / tw;
static int mh = h / th;
static int tiles_len = tw * th * 2;

int tiles[] = new int[tiles_len];
int tilemap[] = new int[mw * mh];

void setup() {
  size(400, 400);
  
  noStroke();
  
  background (0);
	
	colorMode(HSB, 360, 255, 255);
  
  int x = 0, y = 0;
  for (y = 0; y < th; y += 1) {
    for (x = 0; x < tw; x += 1) {
      int index = x + y * (tw * 2);
      tiles[index] = 255;
    }
  }
  
  int mx = 0, my = 0;
  for (my = 0; my < mh; my += 1) {
    for (mx = 0; mx < mw; mx += 1) {
      int index = mx + my * mw;
      tilemap[index] = (mx^my)%2;
    }
  }
	
	noFill();
}

float xmotion = 0;
float ymotion = 0;

int a = 0;

void draw() {
  //background(0);
  
  int mx = 0, my = 0;
  int tx = 0, ty = 0;
  
  for (my = 0; my < /*mh*/2; my += 1) {
    for (mx = 0; mx < /*mw*/2; mx += 1) {
      int index = mx + my * mw;
      int t = tilemap[index];
      
      for (ty = 0; ty < th; ty += 1) {
        for (tx = 0; tx < tw; tx += 1) {
          int tindex = tx + (t*tw) + (ty) * (tw * 2);
          int v = tiles[tindex];
          
					// pencil like shading
          //fill(0, 0, v, 24);
          //rect(mx * tw + tx, my * th + ty, 4, 4);
					
					// raw (pixels perfect)
          stroke(0, 0, v, 128);
          point(mx * tw + tx, my * th + ty);
        }
      }
    }
  }
	
	for (mx = 0; mx < mw - 2; mx += 1) {
		copy(0, 0, tw * 2, th * 2, tw * 2 + (tw * 2) * mx, 0, tw * 2, th * 2);
	}
	
	for (my = 0; my < mh - 2; my += 1) {
		copy(0, 0, w, th * 2, 0, th * 2 + (th * 2) * my, w, th * 2);
	}
	
		int x = 0, y = ((int)ymotion)%th;
		//for (y = 0; y < th; y += 1) {
			for (x = 0; x < tw*2; x += 1) {
				int index = (x + y * (tw*2) + ((x * y)%tw)) % tiles_len;
				tiles[index] = (int)((x / tw + a) % 2) * 255;
			}
		//}
	
	xmotion += 0.5;
	ymotion += 1;
	
	if (xmotion % tw == 0) {
		a += 1;
	}
}"
"683037","Gateway","mySketch","float xmotion = 8.8;
float ymotion = 2.2;

void draw_func() {
	noStroke();
	
	loadPixels();
	for (int x = 8; x < width - 8; x += 8) {
		float norm_x = x / width;
		float anorm_x = abs(0.5 - norm_x) * 2;
		
		for (int y = 8; y < height - 8; y += 8) {
			color p = pixels[y * width + x];
			
			if (brightness(p) >= 0 && brightness(p) < 128) {
				int ppx = random(8);
				int ppy = random(8);
				color p2 = pixels[(y+ceil(random(-ppx, ppx))) * width + (x+ceil(random(-ppy, ppy)))];
				
				fill(hue(p2) * 1.025, 128, 255, 24);
				
				ellipse(x + random(-8, 8), y + random(-8, 8), 4, 4);
			} else if (brightness(p) >= 128) {
				float norm_y = y / height;
				float anorm_y = abs(0.5 - norm_y) * 2;
				
				float r = random(8, 32);
				
				fill(0, 0, 0, r);
				ellipse(x + sin(anorm_x * PI * 2 + ymotion) * 4, y + cos(anorm_y * PI * 2 + xmotion) * 4, r / 2, r / 2);
				ellipse(y + cos(anorm_y * PI * 2 + xmotion) * 4, x + sin(anorm_x * PI * 2 + ymotion) * 4, r / 2, r / 2);
			}
		}
	}
	
	noStroke();
  strokeWeight(4);
	rectMode(CENTER);
	for (int i = 2; i < 16; i += 1) {
		float norm_i = (float)(i - 2) / 4;
		noFill();
		fill(128+(frameCount + 2) % 2 * 224, 128, 128 * (1-norm_i), random(2, 12) * norm_i);
		//triangle(width / 2, height / 2 - 300 + 64, width - (float)width / i, height / 2 + 256, (float)width / i, height / 2 + 256);
		rect(width / 2, height / 2, (float)width/2 / (i / 8), height/2 / (i / 8));
	}
	rectMode(CORNERS);

	fill(64+(frameCount + 4) % 8 * 8, 128, 255, 128);

	xmotion += 0.1;
	ymotion += 0.4;
}

void setup() {
  size(600, 600);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	noFill();
	strokeWeight(16);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	fill(0, 0, 255, 255);
	
	//ellipse(width / 2, height / 2, 700, 700);

	rectMode(CORNER);
	ellipseMode(CORNER);
	
	//smooth();
}

void draw() {
  draw_func();
}"
"683032","Cheshire","mySketch","void setup() {
	size(400, 400);
	colorMode(HSB, 360, 255, 255);
	
	noStroke();
	background(0);
}

float xmotion = 0;
float ymotion = 0;

void draw() {
	noStroke();
	fill(0, 0, 0, 8);
	rect(0, 0, width, height);
	
	int square_width = 100;
	int square_height = 100;
	
	int xx = 0;
	int yy = 0;
	for (int c = 0; c < 32; c += 1) {
		yy = 0;
		for (int y = 0; y <= height + square_height; y += square_height) {
			xx = 0;
			for (int x = 0; x <= width + square_width; x += square_width) {
				if ((xx^yy)%2 == 0) {
					noStroke();
					float norm_c = (float)c / 32;
					float anorm_c = abs(0.5 - norm_c) * 2.;
					fill(180+abs(sin(xmotion + x ^ y)) * 180, 128, 255 * (c % 2), 128);
					//noFill();
					stroke(0, 0, 0, 255 * anorm_c);

					float xx2 = -square_width + (x + xmotion * 32 * anorm_c) % (width + square_width * 2) + sin((float)c / 32 * PI * 2) * 32;
					float yy2 = -square_height + (y + ymotion * 32 * anorm_c) % (height + square_height * 2) + cos((float)c / 32 * PI * 2) * 32;
					ellipse(xx2, yy2, square_width * abs(sin((float)c / 32 * PI * 2 + xmotion)), square_height * abs(cos((float)c / 32 * PI * 2 + xmotion)));
				}

				xx += 1;
			}

			yy += 1;
		}
	}
	
  xmotion += 0.01;
	ymotion += 0.01;
}"
"682458","Checker","mySketch","void setup() {
	size(400, 400);
	colorMode(HSB, 360, 255, 255);
	
	noStroke();
	background(0);
}

float xmotion = 0;
float ymotion = 0;

void draw() {
	fill(0, 0, 0, 255);
	rect(0, 0, width, height);
	
	int square_width = 25;
	int square_height = 25;
	
	int yy = 0;
	for (int y = 0; y <= height + square_height; y += square_height) {
		int xx = 0;
		for (int x = 0; x <= width + square_width; x += square_width) {
			if ((xx^yy)%2 == 0) {
				noStroke();
				for (int c = 0; c < 8; c += 2) {
					float norm_c = (float)c / 32;
					float anorm_c = abs(0.5 - norm_c) * 2.;
					fill(anorm_c * 360, 128 * anorm_c, 255, 255 * anorm_c);
					rect(-square_width + (x + xmotion * 32 * anorm_c) % (width + square_width), -square_height + (y + ymotion * 32 * anorm_c) % (height + square_height), square_width, square_height);
				}
				
				stroke(0, 0, 0, 255);
				fill(0, 0, 255, 255);
				rect(-square_width + (x + xmotion * 24) % (width + square_width), -square_height + (y + ymotion * 24) % (height + square_height), square_width, square_height);
			}
			
			xx += 1;
		}
		
		yy += 1;
	}
	
	xmotion += 0.01;
	ymotion += 0.01;
}"
"682458","Checker","mySketch","// A modern take on the famous checkerboard effect of retro tiling hardware demos
// can be fun with ellipses as well and other shapes :)

void setup() {
	size(400, 400);
	colorMode(HSB, 360, 255, 255);
	
	noStroke();
	background(0);
}

float xmotion = 0;
float ymotion = 0;

void draw() {
	fill(0, 0, 0, 8);
	rect(0, 0, width, height);
	
	int square_width = 50;
	int square_height = 50;
	
	int xx = 0;
	int yy = 0;
	for (int c = 0; c < 8; c += 2) {
		yy = 0;
		for (int y = 0; y <= height + square_height; y += square_height) {
			xx = 0;
			for (int x = 0; x <= width + square_width; x += square_width) {
				if ((xx^yy)%2 == 0) {
					noStroke();
					for (int c = 0; c < 8; c += 1) {
						float norm_c = (float)c / 32;
						float anorm_c = abs(0.5 - norm_c) * 2.;
						fill(180+abs(sin(xmotion + x ^ y)) * 180, 128, 255 * (c % 2), 32);
						//noFill();
						stroke(180+abs(sin(xmotion + x ^ y)) * 180, 64, 255, 128);

						float xx2 = -square_width + (x + xmotion * 32 * anorm_c) % (width + square_width * 2);
						float yy2 = -square_height + (y + ymotion * 32 * anorm_c) % (height + square_height * 2);
						rect(xx2, yy2, square_width, square_height);
					}
				}

				xx += 1;
			}

			yy += 1;
		}
	}
	
	stroke(0, 0, 0, 255);
	fill(0, 0, 255, 255);
	yy = 0;
	for (int y = 0; y <= height + square_height; y += square_height) {
		xx = 0;
		for (int x = 0; x <= width + square_width; x += square_width) {
			if ((xx^yy)%2 == 0) {				
				rect(-square_width + (x + xmotion * 24) % (width + square_width * 2), -square_height + (y + ymotion * 24) % (height + square_height * 2), square_width, square_height);
			}
			
			xx += 1;
		}
		
		yy += 1;
	}
	
	xmotion += 0.01;
	ymotion += 0.01;
}"
"682458","Checker","mySketch","// A modern take on the famous checkerboard effect of retro tiling hardware demos
// can be fun with ellipses as well and other shapes :)

void setup() {
	size(400, 400);
	colorMode(HSB, 360, 255, 255);
	
	noStroke();
	background(0);
}

float xmotion = 0;
float ymotion = 0;

void draw() {
	fill(0, 0, 0, 8);
	rect(0, 0, width, height);
	
	int square_width = 50;
	int square_height = 50;
	
	int xx = 0;
	int yy = 0;
	for (int c = 0; c < 8; c += 2) {
		yy = 0;
		for (int y = 0; y <= height + square_height; y += square_height) {
			xx = 0;
			for (int x = 0; x <= width + square_width; x += square_width) {
				if ((xx^yy)%2 == 0) {
					noStroke();
					for (int c = 0; c < 8; c += 1) {
						float norm_c = (float)c / 32;
						float anorm_c = abs(0.5 - norm_c) * 2.;
						fill(180+abs(sin(xmotion + x ^ y)) * 180, 128, 255 * (c % 2), 32);
						//noFill();
						stroke(180+abs(sin(xmotion + x ^ y)) * 180, 64, 255, 128);

						float xx2 = -square_width + (x + xmotion * 32 * anorm_c) % (width + square_width * 2);
						float yy2 = -square_height + (y + ymotion * 32 * anorm_c) % (height + square_height * 2);
						rect(xx2, yy2, square_width, square_height);
					}
				}

				xx += 1;
			}

			yy += 1;
		}
	}
	
	stroke(0, 0, 0, 255);
	fill(0, 0, 255, 255);
	yy = 0;
	for (int y = 0; y <= height + square_height; y += square_height) {
		xx = 0;
		for (int x = 0; x <= width + square_width; x += square_width) {
			if ((xx^yy)%2 == 0) {				
				rect(-square_width + (x + xmotion * 24) % (width + square_width * 2), -square_height + (y + ymotion * 24) % (height + square_height * 2), square_width, square_height);
			}
			
			xx += 1;
		}
		
		yy += 1;
	}
	
	xmotion += 0.01;
	ymotion += 0.01;
}"
"682448","Retro","mySketch","
float[] pvalues;
int PTS = 80;
int OBJ = 80;

float xmotion = 0;
float ymotion = 0;
float smotion = 0;

void setup() {
	size(1280, 800);
	
  frameRate(30);
  colorMode(HSB,360,255,255,255);
  smooth();
	
	background(0, 0, 0, 255);
  
  pvalues = new float[PTS];
  
  noiseDetail(3,0.5);
}

void stars() {
	loadPixels();
	for (int x = 0; x < width; x += 92) {
		for (int y = 0; y < (height / 1.5); y += 92) {
			int h = 0;
			int s = 0;
			if (x * y % 2 == 0) {
				h = random() > 0.5 ? random(0, 60) : random(180, 270);
				s = 128;
			}
			fill(h,s,255,255);
			rect(x + random(-92,92), y + random(-92,92), random(1, 2), random(1, 2));
		}
	}
}

void draw() {
  //background(0);
  fill(0, 0, 0, 16);
  rect(0, 0, width, height);
  
  noStroke();
  
	// 'clouds'
	for (float g = 0; g < 1.0; g += 0.1) {
		fill(0, 0, 255, 6);
		rect(0, g * (height / 1.75) + random(-128, 128) * (1-g), width, height / 1.75 * 0.01 + random(32));
	}
	
  stars();
	
	// moon
	ellipseMode(CENTER);
	fill(0, 0, 255, 128);
	//if (frameCount == 1 || frameCount % 30 == 0) {
		ellipse(width / 1.25, height / 3.25, 150, 150);
		stroke(0, 0, 0, 192);
	  strokeWeight(4);
	  ellipse(width / 1.25, height / 3.25, 146, 146);
	  noStroke();
	
	ellipse(width / 1.25, height - height / 3.25 + 50, 300 + random(-4, 4), 300 + random(0, 2));
	//}
	
	for (float g = 0; g < 1.0; g += 0.01) {
		fill(0, 0, 0, random(0, 4));
		ellipse(width / 1.25 + random(-64, 64), height / 3.25 + random(-64, 64), 32, 32);
	}
	ellipseMode(CORNERS);
	
	// 'lake'
	for (float g = 0; g < 1.0; g += 0.025) {
		fill(180 + sin(g * PI * 2) * 20, 128, 255 * (1-g), 255 * g);
		rect(0, height / 2 + g * (height / 1.75)+ random(-2, 2), width, height / 1.75 * 0.25);
	}

 	for (float g = 0; g < 1.0; g += 1.0 / OBJ) {
		float gn = 1-abs(0.5 - g) * 2;
		fill(90 + (gn * 16 * xmotion * 16) % 270, 128, gn > 0.4 ? 255 * gn : 255, (1-gn) * 24);
		
		noStroke();
		
		if (gn <= 0.5) {
			strokeWeight(24 * (1-g));
			stroke(0, 0, 0, 255 * (g / 16));
		}
		/*
		// road
		if (g <= 0.01 || g >= 0.99) {
			fill(0, 0, 192, 255);
			strokeWeight(1);
			stroke(0, 0, 0, 255);
		}*/

		int i = 0;

		// the road / environment
		beginShape();
		for (float p = 0; p < 1.01; p += 1.0 / PTS) {
			float d = pow(3.25, (1-p) * 4);

			float y = p * width;
			float x = noise(p * 8 + sin(xmotion)) * (2 * d) * (gn * 8) + pow(2,gn);

			vertex(y, height / 2 - x + d);
		}

		for (float p = 0; p < 1.01; p += 1.0 / PTS) {
			float d = pow(3.25, p * 4);

			float y = (1.0 - p) * width;
			float x = noise(p * 8 + pow(2,cos(xmotion))) * d * (gn * 8) + gn * 100;

			vertex(y, 6 + height / 2 + x + d);
		}
		endShape(CLOSE);
		
		noStroke();
 	}
	
 	// marks
	/*for (float p = 0; p < 1.0; p += 2.0 / 64) {
		float pn = 1-abs(0.5 - p) * 2;

		fill(0, 0, 255 + abs(sin(xmotion * 16)), 255);
		rect((-0.25 + p * 1.25) * width, 1 + height / 2 + pow(3, (1-p) * 6.6), pow(4, (1-p) * 3) * 4, pow(8, (1-p) * 2.25));
	}*/
 
 xmotion += 0.008;
 ymotion += 0.008;
 smotion += 0.001;
}

"
"681020","Coil","mySketch","float xmotion = 8.8;
float ymotion = 2.2;

void draw_func() {
	noStroke();
	
	loadPixels();
	for (int x = 8; x < width - 8; x += 8) {
		float norm_x = x / width;
		float anorm_x = abs(0.5 - norm_x) * 2;
		
		for (int y = 8; y < height - 8; y += 8) {
			color p = pixels[y * width + x];
			
			if (brightness(p) >= 16) {
				int ppx = random(8);
				int ppy = random(8);
				color p2 = pixels[(y+ceil(random(-ppx, ppx))) * width + (x+ceil(random(-ppy, ppy)))];
				
				fill(abs(hue(p) + hue(p2)) / 2 % 360, 0, 255, 12);
				
				rect(width - x + random(-8, 8), height - y + random(-8, 8), 4, 4);
				//rect(x + random(-8, 8), y + random(-8, 8), 2, 2);
			} else if (brightness(p) <= 4) {
				float norm_y = y / height;
				float anorm_y = abs(0.5 - norm_y) * 2;
				
				float rx = 16;
				float ry = 16;
				
				if (random() > 0.5) {
					rx = 1;
				}
				if (random() > 0.5) {
					ry = 1;
				}
				
				fill(0, 0, 0, 1);
				ellipse(x + sin(PI * 2 + ymotion) * 8, y + cos(PI * 2 + xmotion) * 8, rx, ry);
			}
		}
	}
	
	noStroke();
	
	textAlign(CENTER);

	for (int i = 2; i < 49; i += 8) {
		fill(0, 92, 0, 32 * random())
		
		textSize(92 + random(-8, 8));
		text(""COIL"", (width / 2 + i * 8 + xmotion * 100) % width + random(-2, 2), (height / 2 + i * 256 + ymotion * 100) % height + 50 + random(-2, 2));
	}

	noStroke();
	fill(0, 0, 0, 8);
	triangle(width / 2, height / 2 - 364 + 64, width - width / 8 + 76, height / 2 + 90, width / 8, height / 2 + 300);
	
	xmotion += 0.0004;
	ymotion += 0.0004;
}

void setup() {
  size(600, 600);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	noFill();

	rectMode(CENTER);
	for (int i = 0; i < 64; i += 1) {
		fill(random(100, 360), 64, 255, 32);
		rect(width / 2, height / 2, 8+i * 16, 8+i * 16);
	}
	rectMode(CORNER);
	
	//smooth();
}

void draw() {
  draw_func();
}"
"680798","Māyā","mySketch","float xmotion = 0.8;
float ymotion = 2.2;

void draw_func() {
	noStroke();
	
	loadPixels();
	for (int x = 1; x < width; x += 2) {
		float norm_x = x / width;
		float norm_xa = abs(0.5 - norm_x) * 2;

		for (int y = 1; y < height; y += 2) {
			color p = pixels[y * width + x];
			
			float norm_y = y / height;
			float norm_ya = abs(0.5 - norm_y) * 2;
			
			if (brightness(p) > (random(0, 1) > 0.125 ? 64 : 0) && brightness(p) < 128) {
				color p2 = pixels[(y+ceil(random(-1, 1))) * width + (x+ceil(random(-1, 1)))];
				
				fill(0, 0, 255, 24);
				
				rect(width - x + random(8), height - y + random(8), 1, 1);
				rect(width - x + random(12), height - y + random(12), 1, 1);
			} else if (brightness(p) >= 224) {
				float r = (random(0, 1) > 0.125 ? 1 : 1);
				float r2 = (random(0, 1) > 0.125 ? 1 : 8);
				
				fill(0, 0, 0, 48);
				ellipse(x + sin(ymotion) * 16, y + cos(xmotion) * 16, r, r2);
				ellipse(y + cos(xmotion) * 16, x + sin(ymotion) * 16, r, r2);
				
				noStroke();
			}
		}
	}
		noFill();
	textSize(218);
	fill(0, 0, 255, 48);
	textAlign(CENTER);
	text(""माया"", width / 2, height / 2);
	
	xmotion += 0.05;
	ymotion += 0.08;
}

void setup() {
  size(400, 400);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	//smooth();
}

void draw() {
  draw_func();
}"
"680793","Moving shadows","mySketch","float xmotion = 8.8;
float ymotion = 2.2;

void draw_func() {
	noStroke();
	
	loadPixels();
	for (int x = 8; x < width - 8; x += 4) {
		float norm_x = x / width;
		float anorm_x = abs(0.5 - norm_x) * 2;
		
		for (int y = 8; y < height - 8; y += 4) {
			color p = pixels[y * width + x];
			
			if (brightness(p) > 1 && brightness(p) < 128) {
				int ppx = random(8);
				int ppy = random(8);
				color p2 = pixels[(y+ceil(random(-ppx, ppx))) * width + (x+ceil(random(-ppy, ppy)))];
				
				fill(abs(hue(p2) + random(-16, 16)) % 360, 128, 255, 12);
				
				ellipse(x + random(-8, 8), y + random(-8, 8), 4, 4);
			} else if (brightness(p) >= 128) {
				float norm_y = y / height;
				float anorm_y = abs(0.5 - norm_y) * 2;
				
				//float r = random(16, 48);
				
				fill(0, 0, 0, 24);
				ellipse(x + sin(PI * 2 + ymotion) * 24, y + cos(PI * 2 + xmotion) * 24, 24, 24);
				//ellipse(y + cos(anorm_y * PI * 2 + xmotion) * 8, x + sin(anorm_x * PI * 2 + ymotion) * 8, r, r);
			}
		}
	}
	
	noStroke();

	for (int i = 2; i < 49; i += 2) {
		float norm_i = (float)(i - 2) / 8;
		noFill();
		strokeWeight(3);
		stroke(28+random(64), 128, 255, random(8, 64) * norm_i);
		//triangle(width / 2, height / 2 - 200, width - (float)width / (i / 0.5), height / 2 + 256, (float)width / (i / 0.5), height / 2 + 256);
		triangle(width - width / 2, height / 2 - 224, width - width - (float)width / (i / 0.1) + 92, height / 2 + 192, width - (float)width / (i / 0.2) - 64, height / 2 + 12);
		stroke(0, 0, 0, 255);
		strokeWeight(1);
		line(0, i * 16.2 + sin(xmotion * 4) * 32, width, i * 16.2 + cos(ymotion * 4) * 32);
		//line(i * 16.2 + sin(xmotion + norm_i * PI * 2) * 32, 0, i * 16.2 + cos(ymotion + norm_i * PI * 2) * 32, height);
		//line(0, i / 64 + cos(ymotion) * 32, width, i / 64 + cos(ymotion) * 32);
		
		//strokeCap(PROJECT);
		//stroke(0, 0, 0, 255);
		//strokeWeight(12);
		//fill(128+(frameCount + 4) % 8 * 8, 128, 255, 16 * norm_i);
		//rect(width / 6, height / 12, 128, 128);
		//fill(128+(frameCount + 1) % 8 * 8, 128, 255, 16 * norm_i);
		//rect(width - width / 6 - 128, height / 12, 128, 128);
		//noStroke();
	}
	stroke(64+(frameCount + 4) % 8 * 8, 128, 255, 16);
	noFill();
	
	//triangle(width / 2, height / 2 - 800 + 64, 0, height / 2 + 256, width, height / 2 + 256);
	noStroke();
	fill(0, 0, 0, 64);
	//triangle(width / 2, height / 2 - 800 + 64, width - width / 8, height / 2 + 290, width / 8, height / 2 + 256);
	
	fill(64+(frameCount + 4) % 8 * 8, 128, 255, 128);
	
	// h : square pattern
	//triangle(0, 0, 64, 0, 64, 64);
	//triangle(0, 0, 0, 64, 64, 64);
	
	float size = 64;

	//triangle(width / 2 - 128, height / 2 - 22 + 32, width / 2 - 41, height / 2 - 22 + 32, width / 2 - 45, height / 2 + 22 + 32);
	//triangle(width / 2 - 128, height / 2 - 22 + 32, width / 2 - 138, height / 2 + 22 + 32, width / 2 - 46, height / 2 + 22 + 32);
	//triangle(width / 2 + 128, height / 2 - 22 + 32, width / 2 + 41, height / 2 - 22 + 32, width / 2 + 45, height / 2 + 22 + 32);
	//triangle(width / 2 + 128, height / 2 - 22 + 32, width / 2 + 138, height / 2 + 22 + 32, width / 2 + 46, height / 2 + 22 + 32);
	//triangle(width / 2 - 28, height / 2 - 128, width / 2 - 54, height / 2 + 128, width / 2 + 54, height / 2 + 128);
	//triangle(width / 2 - 27, height / 2 - 128, width / 2 + 28, height / 2 - 128, width / 2 + 54, height / 2 + 128);
	
	xmotion += 0.04;
	ymotion += 0.04;
}

void setup() {
  size(600, 600);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	noFill();
	strokeWeight(16);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	fill(0, 0, 255, 255);
	
	//ellipse(width / 2, height / 2, 700, 700);

	rectMode(CORNER);
	ellipseMode(CORNER);
	
	//smooth();
}

void draw() {
  draw_func();
}"
"680792","Panic","mySketch","float xmotion = 8.8;
float ymotion = 2.2;

void draw_func() {
	noStroke();
	
	loadPixels();
	for (int x = 8; x < width - 8; x += 4) {
		float norm_x = x / width;
		float anorm_x = abs(0.5 - norm_x) * 2;
		
		for (int y = 8; y < height - 8; y += 4) {
			color p = pixels[y * width + x];
			
			int b = brightness(p);
			
			if (b > 1 && b < 128) {
				int ppx = random(8);
				int ppy = random(8);
				color p2 = pixels[(y+ceil(random(-ppx, ppx))) * width + (x+ceil(random(-ppy, ppy)))];
				
				fill(abs(hue(p2) + random(-16, 16)) % 360, 128, 255, 12);
				
				ellipse(x + random(-8, 8), y + random(-8, 8), 4, 4);
			} else if (b >= 128) {
				float norm_y = y / height;
				float anorm_y = abs(0.5 - norm_y) * 2;
				
				//float r = random(16, 48);
				
				fill(0, 0, 0, 32);
				ellipse(x + sin(PI * 2 + ymotion) * 24, y + cos(PI * 2 + xmotion) * 24, 8, 8);
				//ellipse(y + cos(anorm_y * PI * 2 + xmotion) * 8, x + sin(anorm_x * PI * 2 + ymotion) * 8, r, r);
			}
		}
	}
	
	noStroke();
	ellipseMode(CENTER);
	rectMode(CENTER);
	strokeCap(ROUND);
	
	for (int i = 2; i < 49; i += 8) {
		float norm_i = (float)(i - 2) / 47;
		noFill();
		strokeWeight(4 + 4 * (1-norm_i));
		stroke(28+random(64) * (1-norm_i), 128, 255, 255 * (1-norm_i));
		//triangle(width / 2, height / 2 - 200, width - (float)width / (i / 0.5), height / 2 + 256, (float)width / (i / 0.5), height / 2 + 256);
		//triangle(width - width / 2, height / 2 - 224, width - width - (float)width / (i / 0.1) + 92, height / 2 + 192, width - (float)width / (i / 0.2) - 64, height / 2 + 12);
		//ellipse(width / 2, height / 2, i * 4, i * 4);
		
		float r = pow(i, 1.45);
		
		ellipse(width / 4+random(-2, 2), height / 2.5+random(-2, 2), r, r);
		ellipse(width - width / 4+random(-2, 2), height / 2.5+random(-2, 2), r, r);
	}

	strokeWeight(3);
	stroke(28+random(64), 128, 255, 255);
	line(width / 4 - 100, height / 8+random(-2, 2), width / 4 + 100, height / 10+random(-2, 2));
	line(width - width / 4 - 100, height / 10+random(-2, 2), width - width / 4 + 100, height / 8+random(-2, 2));
	strokeWeight(4);
	rect(width / 2, height / 1.25, width / 2 + random(0, 200),  random(64, 150));
	
	ellipseMode(CORNER);
	
	xmotion += 0.04;
	ymotion += 0.08;
}

void setup() {
  size(600, 600);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	noFill();
	strokeWeight(16);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	fill(0, 0, 255, 255);
	
	//ellipse(width / 2, height / 2, 700, 700);

	rectMode(CORNER);
	ellipseMode(CORNER);
	
	//smooth();
}

void draw() {
  draw_func();
}"
"680261","Fake3DStar","mySketch","float xmotion = 4;
float ymotion = 4;

void setup() {
  size(800, 800);
  
  colorMode(HSB, 360, 255, 255);
  
  background(0);
  noStroke();
  
  strokeWeight(1);
  
  noiseDetail(7, 0.5);
}

float radius = 192;
int lastmx = -1;

void draw() {
  //background(0, 0, 0, 2);
  noStroke();
	
  fill(0, 0, 0, 8);
	rect(0, 0, width, height);
  
  float count = 128;
  
  float i = 0; float j = 0;
	
	strokeWeight(3);
  
  for (j = 0; j < 1; j += 0.05) {
		float jnorm_j = abs(0.5 - j) * 2;
  for (i = 0; i < count; i += 1) {
    float norm_i = i / count;
    float unit_i = 1 / count;
    
    float inorm_i = abs(0.5 - norm_i) * 2;
    
    float n = noise(inorm_i, jnorm_j) / 8;
    float nn = n * 2;
    
    float cx = radius * sin(norm_i * PI * 2 + j / 8);
    float cy = radius * cos(norm_i * PI * 2 + j / 8);
    
    float cx2 = radius * sin((unit_i + norm_i) * PI * 32 + cos(xmotion)*2) * (radius / 350 + jnorm_j * 3);
    float cy2 = radius * cos((unit_i + norm_i) * PI * 32 + sin(ymotion)*1) * (radius / 350 + jnorm_j * 3);
		
    float x =  width / 2;
    float y = height / 2;

    stroke(60 + j * 128, 128, 255, 224 * (1-j));
    line(x + cx / 2, y + cy / 2, x + cx2 / 2, y + cy2 / 2);

    noStroke();
		
  }
  	fill(inorm_i * 360 * 2 % 360, 0, 0, 224 * (1-j));
		ellipse(width / 2, height / 2, height * j/(0.75 + cos(xmotion)/10), height * j/(0.75 + cos(xmotion)/10));
  }
	
  xmotion += 0.008;
  ymotion += 0.009;
}"
"680251","Tiles","mySketch","float xmotion = 8.8;
float ymotion = 2.2;

void draw_func() {
	noStroke();
	
	loadPixels();
	for (int x = 8; x < width - 8; x += 4) {
		float norm_x = x / width;
		float anorm_x = abs(0.5 - norm_x) * 2;
		
		for (int y = 8; y < height - 8; y += 4) {
			color p = pixels[y * width + x];
			
			if (brightness(p) > 64 && brightness(p) < 128) {
				int ppx = random(8);
				int ppy = random(8);
				color p2 = pixels[(y+ceil(random(-ppx, ppx))) * width + (x+ceil(random(-ppy, ppy)))];
				
				fill(hue(p2) * 1.25, 128, 255, 12);
				
				ellipse(x + random(-1, 1), y + random(-1, 1), 4, 4);
			} else if (brightness(p) <= 64 || brightness(p) >= 128) {
				float norm_y = y / height;
				float anorm_y = abs(0.5 - norm_y) * 2;
				
				fill(0, 0, 0, 64);
				rect(x + random(-8, 8), y + random(-8, 8), 2, 2);
				//ellipse(y + cos(anorm_y * PI * 2 + xmotion) * 8, x + sin(anorm_x * PI * 2 + ymotion) * 8, r, r);
			}
		}
	}
	
	noStroke();
	strokeWeight(4);
	float tile_size = 64;
	
	for (int y = 16; y < height - 16; y += tile_size) {
		for (int x = 16; x < width - 16; x += tile_size) {
			//float norm_i = (float)(i - 2) / 14;
			//noFill();
			stroke(0, 0, 0, 8);
			fill(abs(sin(xmotion+x*y)*128), 128, 255, 4);

			if (random() > 0.85) {
				triangle(x, y, x + tile_size, y, x + tile_size, y + tile_size);
				triangle(x, y, x, y + tile_size, x + tile_size, y + tile_size);
			} else {
				rect(x, y, tile_size, tile_size);
			}
		}
	}
	
	float size = 64;

	xmotion += 0.001;
	ymotion += 0.004;
}

void setup() {
  size(600, 600);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	noFill();
	strokeWeight(16);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	fill(0, 0, 255, 255);
	
	//ellipse(width / 2, height / 2, 700, 700);

	rectMode(CORNER);
	ellipseMode(CORNER);
	
	//smooth();
}

void draw() {
  draw_func();
}"
"679626","Tri","mySketch","float xmotion = 8.8;
float ymotion = 2.2;

void draw_func() {
	noStroke();
	
	loadPixels();
	for (int x = 8; x < width - 8; x += 4) {
		float norm_x = x / width;
		float anorm_x = abs(0.5 - norm_x) * 2;
		
		for (int y = 8; y < height - 8; y += 4) {
			color p = pixels[y * width + x];
			
			if (brightness(p) > 1 && brightness(p) < 128) {
				int ppx = random(8);
				int ppy = random(8);
				color p2 = pixels[(y+ceil(random(-ppx, ppx))) * width + (x+ceil(random(-ppy, ppy)))];
				
				fill(hue(p2) * 1.025, 128, 255, 12);
				
				ellipse(x + random(-8, 8), y + random(-8, 8), 4, 4);
			} else if (brightness(p) > 64) {
				float norm_y = y / height;
				float anorm_y = abs(0.5 - norm_y) * 2;
				
				float r = random(2, 48);
				
				fill(0, 0, 0, r);
				ellipse(x + sin(anorm_x * PI * 2 + ymotion) * 8, y + cos(anorm_y * PI * 2 + xmotion) * 8, r, r);
				ellipse(y + cos(anorm_y * PI * 2 + xmotion) * 8, x + sin(anorm_x * PI * 2 + ymotion) * 8, r, r);
			}
		}
	}
	
	noStroke();
  strokeWeight(4);
	for (int i = 2; i < 16; i += 1) {
		float norm_i = (float)(i - 2) / 8;
		noFill();
		fill(64+(frameCount + 4) % 8 * 8, 128, 255, random(2, 12) * norm_i);
		triangle(width / 2, height / 2 - 300 + 64, width - (float)width / i, height / 2 + 256, (float)width / i, height / 2 + 256);
	}

	fill(64+(frameCount + 4) % 8 * 8, 128, 255, 128);

	xmotion += 0.1;
	ymotion += 0.4;
}

void setup() {
  size(600, 600);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	noFill();
	strokeWeight(16);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	fill(0, 0, 255, 255);
	
	//ellipse(width / 2, height / 2, 700, 700);

	rectMode(CORNER);
	ellipseMode(CORNER);
	
	//smooth();
}

void draw() {
  draw_func();
}"
"679622","sHades","mySketch","float xmotion = 8.8;
float ymotion = 2.2;

void draw_func() {
	noStroke();
	
	loadPixels();
	for (int x = 8; x < width - 8; x += 4) {
		float norm_x = x / width;
		float anorm_x = abs(0.5 - norm_x) * 2;
		
		for (int y = 8; y < height - 8; y += 4) {
			color p = pixels[y * width + x];
			
			if (brightness(p) > 1 && brightness(p) < 128) {
				int ppx = random(8);
				int ppy = random(8);
				color p2 = pixels[(y+ceil(random(-ppx, ppx))) * width + (x+ceil(random(-ppy, ppy)))];
				
				fill(hue(p2) * 1.025, 128, 255, 12);
				
				ellipse(x + random(-8, 8), y + random(-8, 8), 4, 4);
			} else if (brightness(p) > 64) {
				float norm_y = y / height;
				float anorm_y = abs(0.5 - norm_y) * 2;
				
				float r = random(2, 48);
				
				fill(0, 0, 0, r);
				ellipse(x + sin(anorm_x * PI * 2 + ymotion) * 8, y + cos(anorm_y * PI * 2 + xmotion) * 8, r, r);
				ellipse(y + cos(anorm_y * PI * 2 + xmotion) * 8, x + sin(anorm_x * PI * 2 + ymotion) * 8, r, r);
			}
		}
	}
	
	noStroke();
strokeWeight(4);
	for (int i = 2; i < 256; i += 1) {
		float norm_i = (float)(i - 2) / 14;
		noFill();
		stroke(64+(frameCount + 4) % 8 * 8, 128, 255, random(8, 24) * norm_i);
		triangle(width / 2, height / 2 - 800 + 64, width - (float)width / i, height / 2 + 256, (float)width / i, height / 2 + 256);
		line(width / 3.5, i / 32, width - width / 3.5, i / 32);
		
		//strokeCap(PROJECT);
		//stroke(0, 0, 0, 255);
		//strokeWeight(12);
		//fill(128+(frameCount + 4) % 8 * 8, 128, 255, 16 * norm_i);
		//rect(width / 6, height / 12, 128, 128);
		//fill(128+(frameCount + 1) % 8 * 8, 128, 255, 16 * norm_i);
		//rect(width - width / 6 - 128, height / 12, 128, 128);
		//noStroke();
	}
	stroke(64+(frameCount + 4) % 8 * 8, 128, 255, 16);
	noFill();
	
	triangle(width / 2, height / 2 - 800 + 64, 0, height / 2 + 256, width, height / 2 + 256);
	noStroke();
	fill(0, 0, 0, 128);
	triangle(width / 2, height / 2 - 800 + 64, width - width / 8, height / 2 + 290, width / 8, height / 2 + 256);
	
	fill(64+(frameCount + 4) % 8 * 8, 128, 255, 128);
	/*
	float size = 64;
	triangle(width / 2 - 128, height / 2 - 22 + 24, width / 2 - (128 + 10), height / 2 + 22 + 24, width / 2 + 128, height / 2 + 22 + 24);
	triangle(width / 2 - 128, height / 2 - 22 + 24, width / 2 + 128, height / 2 - 22 + 24, width / 2 + (128 + 10), height / 2 + 22 + 24);
	triangle(width / 2 - 22, height / 2 - 128, width / 2 - 54, height / 2 + 128, width / 2 + 54, height / 2 + 128);
	triangle(width / 2 - 20, height / 2 - 128, width / 2 + 22, height / 2 - 128, width / 2 + 54, height / 2 + 128);*/
	
	xmotion += 0.1;
	ymotion += 0.4;
}

void setup() {
  size(600, 600);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	noFill();
	strokeWeight(16);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	fill(0, 0, 255, 255);
	
	//ellipse(width / 2, height / 2, 700, 700);

	rectMode(CORNER);
	ellipseMode(CORNER);
	
	//smooth();
}

void draw() {
  draw_func();
}"
"679622","sHades","mySketch","float xmotion = 8.8;
float ymotion = 2.2;

void draw_func() {
	noStroke();
	
	loadPixels();
	for (int x = 8; x < width - 8; x += 4) {
		float norm_x = x / width;
		float anorm_x = abs(0.5 - norm_x) * 2;
		
		for (int y = 8; y < height - 8; y += 4) {
			color p = pixels[y * width + x];
			
			if (brightness(p) > 1 && brightness(p) < 128) {
				int ppx = random(8);
				int ppy = random(8);
				color p2 = pixels[(y+ceil(random(-ppx, ppx))) * width + (x+ceil(random(-ppy, ppy)))];
				
				fill(hue(p2) * 1.025, 128, 255, 12);
				
				ellipse(x + random(-8, 8), y + random(-8, 8), 4, 4);
			} else if (brightness(p) > 64) {
				float norm_y = y / height;
				float anorm_y = abs(0.5 - norm_y) * 2;
				
				float r = random(2, 48);
				
				fill(0, 0, 0, r);
				ellipse(x + sin(anorm_x * PI * 2 + ymotion) * 8, y + cos(anorm_y * PI * 2 + xmotion) * 8, r, r);
				//ellipse(y + cos(anorm_y * PI * 2 + xmotion) * 8, x + sin(anorm_x * PI * 2 + ymotion) * 8, r, r);
			}
		}
	}
	
	noStroke();
strokeWeight(2);
	for (int i = 2; i < 92; i += 1) {
		float norm_i = (float)(i - 2) / 14;
		noFill();
		stroke(64+(frameCount + 4) % 8 * 8, 128, 255, random(8, 24) * norm_i);
		triangle(width / 2, height / 2 - 800 + 64, width - (float)width / (i / 1.5), height / 2 + 256, (float)width / (i / 1.5), height / 2 + 256);
		line(width / 3.5 - i * 1.7, i * 6.1, width - width / 3.5 + i * 1.7, i * 6.1);
		line(width / 3.5 + i / 8, i / 12, width - width / 3.5 - i / 8, i / 12);
		
		//strokeCap(PROJECT);
		//stroke(0, 0, 0, 255);
		//strokeWeight(12);
		//fill(128+(frameCount + 4) % 8 * 8, 128, 255, 16 * norm_i);
		//rect(width / 6, height / 12, 128, 128);
		//fill(128+(frameCount + 1) % 8 * 8, 128, 255, 16 * norm_i);
		//rect(width - width / 6 - 128, height / 12, 128, 128);
		//noStroke();
	}
	stroke(64+(frameCount + 4) % 8 * 8, 128, 255, 16);
	noFill();
	
	/*triangle(width / 2, height / 2 - 800 + 64, 0, height / 2 + 256, width, height / 2 + 256);
	noStroke();
	fill(0, 0, 0, 128);
	triangle(width / 2, height / 2 - 800 + 64, width - width / 8, height / 2 + 290, width / 8, height / 2 + 256);
	*/
	fill(64+(frameCount + 4) % 8 * 8, 128, 255, 128);
	
	// h : square pattern
	//triangle(0, 0, 64, 0, 64, 64);
	//triangle(0, 0, 0, 64, 64, 64);
	
	float size = 64;

	triangle(width / 2 - 128, height / 2 - 22 + 32, width / 2 - 41, height / 2 - 22 + 32, width / 2 - 45, height / 2 + 22 + 32);
	triangle(width / 2 - 128, height / 2 - 22 + 32, width / 2 - 138, height / 2 + 22 + 32, width / 2 - 46, height / 2 + 22 + 32);
	triangle(width / 2 + 128, height / 2 - 22 + 32, width / 2 + 41, height / 2 - 22 + 32, width / 2 + 45, height / 2 + 22 + 32);
	triangle(width / 2 + 128, height / 2 - 22 + 32, width / 2 + 138, height / 2 + 22 + 32, width / 2 + 46, height / 2 + 22 + 32);
	triangle(width / 2 - 28, height / 2 - 128, width / 2 - 54, height / 2 + 128, width / 2 + 54, height / 2 + 128);
	triangle(width / 2 - 27, height / 2 - 128, width / 2 + 28, height / 2 - 128, width / 2 + 54, height / 2 + 128);
	
	xmotion += 0.1;
	ymotion += 0.4;
}

void setup() {
  size(600, 600);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	noFill();
	strokeWeight(16);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	fill(0, 0, 255, 255);
	
	//ellipse(width / 2, height / 2, 700, 700);

	rectMode(CORNER);
	ellipseMode(CORNER);
	
	//smooth();
}

void draw() {
  draw_func();
}"
"679622","sHades","mySketch","float xmotion = 8.8;
float ymotion = 2.2;

void draw_func() {
	noStroke();
	
	loadPixels();
	for (int x = 8; x < width - 8; x += 4) {
		float norm_x = x / width;
		float anorm_x = abs(0.5 - norm_x) * 2;
		
		for (int y = 8; y < height - 8; y += 4) {
			color p = pixels[y * width + x];
			
			if (brightness(p) > 1 && brightness(p) < 128) {
				int ppx = random(8);
				int ppy = random(8);
				color p2 = pixels[(y+ceil(random(-ppx, ppx))) * width + (x+ceil(random(-ppy, ppy)))];
				
				fill(hue(p2) * 1.025, 128, 255, 12);
				
				ellipse(x + random(-8, 8), y + random(-8, 8), 4, 4);
			} else if (brightness(p) >= 128) {
				float norm_y = y / height;
				float anorm_y = abs(0.5 - norm_y) * 2;
				
				float r = random(2, 48);
				
				fill(0, 0, 0, r);
				ellipse(x + sin(anorm_x * PI * 2 + ymotion) * 4, y + cos(anorm_y * PI * 2 + xmotion) * 4, r, r);
				//ellipse(y + cos(anorm_y * PI * 2 + xmotion) * 8, x + sin(anorm_x * PI * 2 + ymotion) * 8, r, r);
			}
		}
	}
	
	noStroke();
strokeWeight(2);
	for (int i = 2; i < 92; i += 1) {
		float norm_i = (float)(i - 2) / 14;
		noFill();
		stroke(64+(frameCount + 4) % 8 * 8, 128, 255, random(8, 24) * norm_i);
		triangle(width / 2, height / 2 - 800 + 64, width - (float)width / (i / 1.5), height / 2 + 256, (float)width / (i / 1.5), height / 2 + 256);
		line(width / 3.5 - i * 1.7, i * 6.1, width - width / 3.5 + i * 1.7, i * 6.1);
		line(width / 3.5 + i / 8, i / 12, width - width / 3.5 - i / 8, i / 12);
		
		//strokeCap(PROJECT);
		//stroke(0, 0, 0, 255);
		//strokeWeight(12);
		//fill(128+(frameCount + 4) % 8 * 8, 128, 255, 16 * norm_i);
		//rect(width / 6, height / 12, 128, 128);
		//fill(128+(frameCount + 1) % 8 * 8, 128, 255, 16 * norm_i);
		//rect(width - width / 6 - 128, height / 12, 128, 128);
		//noStroke();
	}
	stroke(64+(frameCount + 4) % 8 * 8, 128, 255, 16);
	noFill();
	
	triangle(width / 2, height / 2 - 800 + 64, 0, height / 2 + 256, width, height / 2 + 256);
	noStroke();
	fill(0, 0, 0, 64);
	triangle(width / 2, height / 2 - 800 + 64, width - width / 8, height / 2 + 290, width / 8, height / 2 + 256);
	
	fill(64+(frameCount + 4) % 8 * 8, 128, 255, 128);
	
	// h : square pattern
	//triangle(0, 0, 64, 0, 64, 64);
	//triangle(0, 0, 0, 64, 64, 64);
	
	float size = 64;

	triangle(width / 2 - 128, height / 2 - 22 + 32, width / 2 - 41, height / 2 - 22 + 32, width / 2 - 45, height / 2 + 22 + 32);
	triangle(width / 2 - 128, height / 2 - 22 + 32, width / 2 - 138, height / 2 + 22 + 32, width / 2 - 46, height / 2 + 22 + 32);
	triangle(width / 2 + 128, height / 2 - 22 + 32, width / 2 + 41, height / 2 - 22 + 32, width / 2 + 45, height / 2 + 22 + 32);
	triangle(width / 2 + 128, height / 2 - 22 + 32, width / 2 + 138, height / 2 + 22 + 32, width / 2 + 46, height / 2 + 22 + 32);
	triangle(width / 2 - 28, height / 2 - 128, width / 2 - 54, height / 2 + 128, width / 2 + 54, height / 2 + 128);
	triangle(width / 2 - 27, height / 2 - 128, width / 2 + 28, height / 2 - 128, width / 2 + 54, height / 2 + 128);
	
	xmotion += 0.1;
	ymotion += 0.4;
}

void setup() {
  size(600, 600);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	noFill();
	strokeWeight(16);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	fill(0, 0, 255, 255);
	
	//ellipse(width / 2, height / 2, 700, 700);

	rectMode(CORNER);
	ellipseMode(CORNER);
	
	//smooth();
}

void draw() {
  draw_func();
}"
"679622","sHades","mySketch","float xmotion = 8.8;
float ymotion = 2.2;

void draw_func() {
	noStroke();
	
	loadPixels();
	for (int x = 8; x < width - 8; x += 4) {
		float norm_x = x / width;
		float anorm_x = abs(0.5 - norm_x) * 2;
		
		for (int y = 8; y < height - 8; y += 4) {
			color p = pixels[y * width + x];
			
			if (brightness(p) > 1 && brightness(p) < 128) {
				int ppx = random(8);
				int ppy = random(8);
				color p2 = pixels[(y+ceil(random(-ppx, ppx))) * width + (x+ceil(random(-ppy, ppy)))];
				
				fill(hue(p2) * 1.025, 128, 255, 12);
				
				ellipse(x + random(-8, 8), y + random(-8, 8), 4, 4);
			} else if (brightness(p) >= 128) {
				float norm_y = y / height;
				float anorm_y = abs(0.5 - norm_y) * 2;
				
				float r = random(2, 48);
				
				fill(0, 0, 0, r);
				ellipse(x + sin(anorm_x * PI * 2 + ymotion) * 4, y + cos(anorm_y * PI * 2 + xmotion) * 4, r, r);
				//ellipse(y + cos(anorm_y * PI * 2 + xmotion) * 8, x + sin(anorm_x * PI * 2 + ymotion) * 8, r, r);
			}
		}
	}
	
	noStroke();
strokeWeight(2);
	for (int i = 2; i < 92; i += 1) {
		float norm_i = (float)(i - 2) / 14;
		noFill();
		stroke(64+(frameCount + 4) % 8 * 8, 128, 255, random(8, 24) * norm_i);
		triangle(width / 2, height / 2 - 800 + 64, width - (float)width / (i / 1.5), height / 2 + 256, (float)width / (i / 1.5), height / 2 + 256);
		line(width / 3.5 - i * 1.7, i * 6.1, width - width / 3.5 + i * 1.7, i * 6.1);
		line(width / 3.5 + i / 8, i / 12, width - width / 3.5 - i / 8, i / 12);
		
		//strokeCap(PROJECT);
		//stroke(0, 0, 0, 255);
		//strokeWeight(12);
		//fill(128+(frameCount + 4) % 8 * 8, 128, 255, 16 * norm_i);
		//rect(width / 6, height / 12, 128, 128);
		//fill(128+(frameCount + 1) % 8 * 8, 128, 255, 16 * norm_i);
		//rect(width - width / 6 - 128, height / 12, 128, 128);
		//noStroke();
	}
	stroke(64+(frameCount + 4) % 8 * 8, 128, 255, 16);
	noFill();
	
	triangle(width / 2, height / 2 - 800 + 64, 0, height / 2 + 256, width, height / 2 + 256);
	noStroke();
	fill(0, 0, 0, 64);
	triangle(width / 2, height / 2 - 800 + 64, width - width / 8, height / 2 + 290, width / 8, height / 2 + 256);
	
	fill(64+(frameCount + 4) % 8 * 8, 128, 255, 128);
	
	// h : square pattern
	//triangle(0, 0, 64, 0, 64, 64);
	//triangle(0, 0, 0, 64, 64, 64);
	
	float size = 64;

	triangle(width / 2 - 128, height / 2 - 22 + 32, width / 2 - 41, height / 2 - 22 + 32, width / 2 - 45, height / 2 + 22 + 32);
	triangle(width / 2 - 128, height / 2 - 22 + 32, width / 2 - 138, height / 2 + 22 + 32, width / 2 - 46, height / 2 + 22 + 32);
	triangle(width / 2 + 128, height / 2 - 22 + 32, width / 2 + 41, height / 2 - 22 + 32, width / 2 + 45, height / 2 + 22 + 32);
	triangle(width / 2 + 128, height / 2 - 22 + 32, width / 2 + 138, height / 2 + 22 + 32, width / 2 + 46, height / 2 + 22 + 32);
	triangle(width / 2 - 28, height / 2 - 128, width / 2 - 54, height / 2 + 128, width / 2 + 54, height / 2 + 128);
	triangle(width / 2 - 27, height / 2 - 128, width / 2 + 28, height / 2 - 128, width / 2 + 54, height / 2 + 128);
	
	xmotion += 0.1;
	ymotion += 0.4;
}

void setup() {
  size(600, 600);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	noFill();
	strokeWeight(16);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	fill(0, 0, 255, 255);
	
	//ellipse(width / 2, height / 2, 700, 700);

	rectMode(CORNER);
	ellipseMode(CORNER);
	
	//smooth();
}

void draw() {
  draw_func();
}"
"679622","sHades","mySketch","float xmotion = 8.8;
float ymotion = 2.2;

void draw_func() {
	noStroke();
	
	loadPixels();
	for (int x = 8; x < width - 8; x += 4) {
		float norm_x = x / width;
		float anorm_x = abs(0.5 - norm_x) * 2;
		
		for (int y = 8; y < height - 8; y += 4) {
			color p = pixels[y * width + x];
			
			if (brightness(p) > 1 && brightness(p) < 128) {
				int ppx = random(8);
				int ppy = random(8);
				color p2 = pixels[(y+ceil(random(-ppx, ppx))) * width + (x+ceil(random(-ppy, ppy)))];
				
				fill(hue(p2) * 1.025, 128, 255, 12);
				
				ellipse(x + random(-8, 8), y + random(-8, 8), 4, 4);
			} else if (brightness(p) >= 128) {
				float norm_y = y / height;
				float anorm_y = abs(0.5 - norm_y) * 2;
				
				float r = random(2, 48);
				
				fill(0, 0, 0, r);
				ellipse(x + sin(anorm_x * PI * 2 + ymotion) * 4, y + cos(anorm_y * PI * 2 + xmotion) * 4, r, r);
				//ellipse(y + cos(anorm_y * PI * 2 + xmotion) * 8, x + sin(anorm_x * PI * 2 + ymotion) * 8, r, r);
			}
		}
	}
	
	noStroke();
strokeWeight(2);
	for (int i = 2; i < 92; i += 1) {
		float norm_i = (float)(i - 2) / 14;
		noFill();
		stroke(64+(frameCount + 4) % 8 * 8, 128, 255, random(8, 24) * norm_i);
		triangle(width / 2, height / 2 - 800 + 64, width - (float)width / (i / 1.5), height / 2 + 256, (float)width / (i / 1.5), height / 2 + 256);
		line(width / 3.5 - i * 1.7, i * 6.1, width - width / 3.5 + i * 1.7, i * 6.1);
		line(width / 3.5 + i / 8, i / 12, width - width / 3.5 - i / 8, i / 12);
		
		//strokeCap(PROJECT);
		//stroke(0, 0, 0, 255);
		//strokeWeight(12);
		//fill(128+(frameCount + 4) % 8 * 8, 128, 255, 16 * norm_i);
		//rect(width / 6, height / 12, 128, 128);
		//fill(128+(frameCount + 1) % 8 * 8, 128, 255, 16 * norm_i);
		//rect(width - width / 6 - 128, height / 12, 128, 128);
		//noStroke();
	}
	stroke(64+(frameCount + 4) % 8 * 8, 128, 255, 16);
	noFill();
	
	triangle(width / 2, height / 2 - 800 + 64, 0, height / 2 + 256, width, height / 2 + 256);
	noStroke();
	fill(0, 0, 0, 64);
	triangle(width / 2, height / 2 - 800 + 64, width - width / 8, height / 2 + 290, width / 8, height / 2 + 256);
	
	fill(64+(frameCount + 4) % 8 * 8, 128, 255, 128);
	
	// h : square pattern
	//triangle(0, 0, 64, 0, 64, 64);
	//triangle(0, 0, 0, 64, 64, 64);
	
	float size = 64;

	triangle(width / 2 - 128, height / 2 - 22 + 32, width / 2 - 41, height / 2 - 22 + 32, width / 2 - 45, height / 2 + 22 + 32);
	triangle(width / 2 - 128, height / 2 - 22 + 32, width / 2 - 138, height / 2 + 22 + 32, width / 2 - 46, height / 2 + 22 + 32);
	triangle(width / 2 + 128, height / 2 - 22 + 32, width / 2 + 41, height / 2 - 22 + 32, width / 2 + 45, height / 2 + 22 + 32);
	triangle(width / 2 + 128, height / 2 - 22 + 32, width / 2 + 138, height / 2 + 22 + 32, width / 2 + 46, height / 2 + 22 + 32);
	triangle(width / 2 - 28, height / 2 - 128, width / 2 - 54, height / 2 + 128, width / 2 + 54, height / 2 + 128);
	triangle(width / 2 - 27, height / 2 - 128, width / 2 + 28, height / 2 - 128, width / 2 + 54, height / 2 + 128);
	
	xmotion += 0.1;
	ymotion += 0.4;
}

void setup() {
  size(600, 600);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	noFill();
	strokeWeight(16);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	fill(0, 0, 255, 255);
	
	//ellipse(width / 2, height / 2, 700, 700);

	rectMode(CORNER);
	ellipseMode(CORNER);
	
	//smooth();
}

void draw() {
  draw_func();
}"
"679622","sHades","mySketch","float xmotion = 8.8;
float ymotion = 2.2;

void draw_func() {
	noStroke();
	
	loadPixels();
	for (int x = 8; x < width - 8; x += 4) {
		float norm_x = x / width;
		float anorm_x = abs(0.5 - norm_x) * 2;
		
		for (int y = 8; y < height - 8; y += 4) {
			color p = pixels[y * width + x];
			
			if (brightness(p) > 1 && brightness(p) < 128) {
				int ppx = random(8);
				int ppy = random(8);
				color p2 = pixels[(y+ceil(random(-ppx, ppx))) * width + (x+ceil(random(-ppy, ppy)))];
				
				fill(hue(p2) * 1.025, 128, 255, 12);
				
				ellipse(x + random(-8, 8), y + random(-8, 8), 4, 4);
			} else if (brightness(p) >= 128) {
				float norm_y = y / height;
				float anorm_y = abs(0.5 - norm_y) * 2;
				
				float r = random(2, 48);
				
				fill(0, 0, 0, r);
				ellipse(x + sin(anorm_x * PI * 2 + ymotion) * 4, y + cos(anorm_y * PI * 2 + xmotion) * 4, r, r);
				//ellipse(y + cos(anorm_y * PI * 2 + xmotion) * 8, x + sin(anorm_x * PI * 2 + ymotion) * 8, r, r);
			}
		}
	}
	
	noStroke();
strokeWeight(2);
	for (int i = 2; i < 92; i += 1) {
		float norm_i = (float)(i - 2) / 14;
		noFill();
		stroke(64+(frameCount + 4) % 8 * 8, 128, 255, random(8, 24) * norm_i);
		triangle(width / 2, height / 2 - 800 + 64, width - (float)width / (i / 1.5), height / 2 + 256, (float)width / (i / 1.5), height / 2 + 256);
		line(width / 3.5 - i * 1.7, i * 6.1, width - width / 3.5 + i * 1.7, i * 6.1);
		line(width / 3.5 + i / 8, i / 12, width - width / 3.5 - i / 8, i / 12);
		
		//strokeCap(PROJECT);
		//stroke(0, 0, 0, 255);
		//strokeWeight(12);
		//fill(128+(frameCount + 4) % 8 * 8, 128, 255, 16 * norm_i);
		//rect(width / 6, height / 12, 128, 128);
		//fill(128+(frameCount + 1) % 8 * 8, 128, 255, 16 * norm_i);
		//rect(width - width / 6 - 128, height / 12, 128, 128);
		//noStroke();
	}
	stroke(64+(frameCount + 4) % 8 * 8, 128, 255, 16);
	noFill();
	
	triangle(width / 2, height / 2 - 800 + 64, 0, height / 2 + 256, width, height / 2 + 256);
	noStroke();
	fill(0, 0, 0, 64);
	triangle(width / 2, height / 2 - 800 + 64, width - width / 8, height / 2 + 290, width / 8, height / 2 + 256);
	
	fill(64+(frameCount + 4) % 8 * 8, 128, 255, 128);
	
	// h : square pattern
	//triangle(0, 0, 64, 0, 64, 64);
	//triangle(0, 0, 0, 64, 64, 64);
	
	float size = 64;

	triangle(width / 2 - 128, height / 2 - 22 + 32, width / 2 - 41, height / 2 - 22 + 32, width / 2 - 45, height / 2 + 22 + 32);
	triangle(width / 2 - 128, height / 2 - 22 + 32, width / 2 - 138, height / 2 + 22 + 32, width / 2 - 46, height / 2 + 22 + 32);
	triangle(width / 2 + 128, height / 2 - 22 + 32, width / 2 + 41, height / 2 - 22 + 32, width / 2 + 45, height / 2 + 22 + 32);
	triangle(width / 2 + 128, height / 2 - 22 + 32, width / 2 + 138, height / 2 + 22 + 32, width / 2 + 46, height / 2 + 22 + 32);
	triangle(width / 2 - 28, height / 2 - 128, width / 2 - 54, height / 2 + 128, width / 2 + 54, height / 2 + 128);
	triangle(width / 2 - 27, height / 2 - 128, width / 2 + 28, height / 2 - 128, width / 2 + 54, height / 2 + 128);
	
	xmotion += 0.1;
	ymotion += 0.4;
}

void setup() {
  size(600, 600);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	noFill();
	strokeWeight(16);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	fill(0, 0, 255, 255);
	
	//ellipse(width / 2, height / 2, 700, 700);

	rectMode(CORNER);
	ellipseMode(CORNER);
	
	//smooth();
}

void draw() {
  draw_func();
}"
"679143","With images","mySketch","// Same tech as my feedback sketch with colors! (depend on brightness and neightbours)

float xmotion = 8.8;
float ymotion = 2.2;

void draw_func() {
	noStroke();
	
	loadPixels();
	for (int x = 1; x < width; x += 4) {
		float norm_x = x / width;

		for (int y = 1; y < height; y += 4) {
			color p = pixels[y * width + x];
			
			if (brightness(p) > 64 && brightness(p) < 128) {
				color p2 = pixels[(y+ceil(random(-1, 1))) * width + (x+ceil(random(-1, 1)))];
				
				fill(brightness(p) + hue(p2) / 2, 128, 255, 92);
				
				rect(width - x + random(8), height - y + random(8), 2, 4);
				rect(width - x + random(8), height - y + random(8), 2, 4);
			} else if (brightness(p) > 224) {
				float norm_y = y / height;
				
				fill(0, 0, 0, 12);
				ellipse(x + sin(norm_x * PI * 2 + ymotion) * 64, y + cos(norm_y * PI * 2 + xmotion) * 64, 64, 64);
				ellipse(y + cos(norm_x * PI * 2 + xmotion) * 64, x + sin(norm_y * PI * 2 + ymotion) * 64, 64, 64);
			}
		}
	}
	/*
	rectMode(CENTER);
	ellipseMode(CENTER);
	stroke(0, 0, 0, 128);
	noFill();
	strokeWeight(8);
  ellipse(width / 2, height / 2, 700, 700);
	rectMode(CORNER);
	ellipseMode(CORNER);*/
	
	xmotion += 0.01;
	ymotion += 0.04;
}

void setup() {
  size(1000, 800);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	noFill();
	strokeWeight(16);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	fill(0, 0, 255, 255);
	
	//ellipse(width / 2, height / 2, 700, 700);
	PImage img = loadImage(""truc.png"");
	image(img, 0, 0);

	rectMode(CORNER);
	ellipseMode(CORNER);
	
	//smooth();
}

void draw() {
  draw_func();
}"
"679143","With images","mySketch","// Same tech as my feedback sketch with colors! (depend on brightness and neightbours)

float xmotion = 8.8;
float ymotion = 2.2;

void draw_func() {
	noStroke();
	
	loadPixels();
	for (int x = 1; x < width; x += 4) {
		float norm_x = x / width;

		for (int y = 1; y < height; y += 4) {
			color p = pixels[y * width + x];
			
			if (brightness(p) > 64 && brightness(p) < 128) {
				color p2 = pixels[(y+ceil(random(-1, 1))) * width + (x+ceil(random(-1, 1)))];
				
				fill(brightness(p) + hue(p2) / 2, 128, 255, 92);
				
				rect(width - x + random(8), height - y + random(8), 2, 4);
				rect(width - x + random(8), height - y + random(8), 2, 4);
			} else if (brightness(p) > 224) {
				float norm_y = y / height;
				
				fill(0, 0, 0, 12);
				ellipse(x + sin(norm_x * PI * 2 + ymotion) * 64, y + cos(norm_y * PI * 2 + xmotion) * 64, 64, 64);
				ellipse(y + cos(norm_x * PI * 2 + xmotion) * 64, x + sin(norm_y * PI * 2 + ymotion) * 64, 64, 64);
			}
		}
	}
	/*
	rectMode(CENTER);
	ellipseMode(CENTER);
	stroke(0, 0, 0, 128);
	noFill();
	strokeWeight(8);
  ellipse(width / 2, height / 2, 700, 700);
	rectMode(CORNER);
	ellipseMode(CORNER);*/
	
	xmotion += 0.01;
	ymotion += 0.04;
}

void setup() {
  size(1000, 800);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	noFill();
	strokeWeight(16);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	fill(0, 0, 255, 255);
	
	//ellipse(width / 2, height / 2, 700, 700);
	PImage img = loadImage(""cuba.jpg"");
	image(img, width / 2 - img.width / 2, height / 2 - img.height / 2);

	rectMode(CORNER);
	ellipseMode(CORNER);
	
	//smooth();
}

void draw() {
  draw_func();
}"
"679143","With images","mySketch","// Same tech as my feedback sketch with colors! (depend on brightness and neightbours)

float xmotion = 8.8;
float ymotion = 2.2;

void draw_func() {
	noStroke();
	
	loadPixels();
	for (int x = 1; x < width; x += 4) {
		float norm_x = x / width;

		for (int y = 1; y < height; y += 4) {
			color p = pixels[y * width + x];
			
			if (brightness(p) > 64 && brightness(p) < 128) {
				color p2 = pixels[(y+ceil(random(-1, 1))) * width + (x+ceil(random(-1, 1)))];
				
				fill(brightness(p) + hue(p2) / 2, 128, 255, 92);
				
				rect(width - x + random(8), height - y + random(8), 2, 4);
				rect(width - x + random(8), height - y + random(8), 2, 4);
			} else if (brightness(p) > 224) {
				float norm_y = y / height;
				
				fill(0, 0, 0, 12);
				ellipse(x + sin(norm_x * PI * 2 + ymotion) * 64, y + cos(norm_y * PI * 2 + xmotion) * 64, 64, 64);
				ellipse(y + cos(norm_x * PI * 2 + xmotion) * 64, x + sin(norm_y * PI * 2 + ymotion) * 64, 64, 64);
			}
		}
	}
	/*
	rectMode(CENTER);
	ellipseMode(CENTER);
	stroke(0, 0, 0, 128);
	noFill();
	strokeWeight(8);
  ellipse(width / 2, height / 2, 700, 700);
	rectMode(CORNER);
	ellipseMode(CORNER);*/
	
	xmotion += 0.01;
	ymotion += 0.04;
}

void setup() {
  size(1000, 800);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	PImage img = loadImage(""cuba.jpg"");
	image(img, width / 2 - img.width / 2, height / 2 - img.height / 2);
}

void draw() {
  draw_func();
}"
"679143","With images","mySketch","// Same tech as my feedback sketch with colors! (depend on brightness and neightbours)

float xmotion = 8.8;
float ymotion = 2.2;
PImage img;
void draw_func() {
	noStroke();
	
	loadPixels();
	for (int x = 1; x < width; x += 4) {
		float norm_x = x / width;

		for (int y = 1; y < height; y += 4) {
			color p = pixels[y * width + x];
			
			if (brightness(p) > 192 * norm_x) {
				color p2 = pixels[(y+ceil(random(-1, 1))) * width + (x+ceil(random(-1, 1)))];
				
				fill(hue(p2), max(0, saturation(p2)+random(-64, 64)), max(brightness(p2)+random(-64, 64), 0), 4);
				
				rect(x + random(-64, 64), y + random(-64, 64), 4, 4);
				rect(x + random(-64, 64), y + random(-64, 64), 4, 4);
			}
		}
	}
	/*
	rectMode(CENTER);
	ellipseMode(CENTER);
	stroke(0, 0, 0, 128);
	noFill();
	strokeWeight(8);
  ellipse(width / 2, height / 2, 700, 700);
	rectMode(CORNER);
	ellipseMode(CORNER);*/
	
	xmotion += 0.01;
	ymotion += 0.04;
	
	if (frameCount%(60 *2) == 0)
	image(img, width / 2 - img.width / 2, height / 2 - img.height / 2);
}

void setup() {
  size(800, 800);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	img = loadImage(""cuba.jpg"");
	image(img, width / 2 - img.width / 2, height / 2 - img.height / 2);
}

void draw() {
  draw_func();
}"
"679143","With images","mySketch","// Same tech as my feedback sketch with colors! (depend on brightness and neightbours)

float xmotion = 8.8;
float ymotion = 2.2;
PImage img;
void draw_func() {
	noStroke();
	
	loadPixels();
	for (int x = 1; x < width; x += 8) {
		float norm_x = x / width;

		for (int y = 1; y < height; y += 8) {
			color p = pixels[y * width + x];
			
			if (brightness(p) > 0) {
				float ppw = 64;
				float pph = 64;
				color p2 = pixels[(y+ceil(random(-ppw, ppw))) * width + (x+ceil(random(-pph, pph)))];
				
				fill(hue(p2), max(0, saturation(p2)), max(brightness(p2), 0), 1);
				
				rect(x + random(-8, 8), y + random(-8, 8), 8, 8);
				rect(x + random(-8, 8), y + random(-8, 8), 8, 8);
			}
		}
	}
	/*
	rectMode(CENTER);
	ellipseMode(CENTER);
	stroke(0, 0, 0, 128);
	noFill();
	strokeWeight(8);
  ellipse(width / 2, height / 2, 700, 700);
	rectMode(CORNER);
	ellipseMode(CORNER);*/
	
	xmotion += 0.01;
	ymotion += 0.04;
	
	if (frameCount < 140)
	image(img, width / 2 - img.width / 2, height / 2 - img.height / 2);
}

void setup() {
  size(800, 800);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	img = loadImage(""cuba.jpg"");
	image(img, width / 2 - img.width / 2, height / 2 - img.height / 2);
}

void draw() {
  draw_func();
}"
"679143","With images","mySketch","// Same tech as my feedback sketch with colors! (depend on brightness and neightbours)

float xmotion = 8.8;
float ymotion = 2.2;
PImage img;
void draw_func() {
	noStroke();
	
	loadPixels();
	for (int x = 1; x < width; x += 4) {
		float norm_x = x / width;

		for (int y = 1; y < height; y += 4) {
			color p = pixels[y * width + x];
			
			if (brightness(p) > 0) {
				float ppw = 2;
				float pph = 64;
				color p2 = pixels[(y+ceil(random(-ppw, ppw))) * width + (x+ceil(random(-pph, pph)))];
				
				fill(hue(p2), max(0, saturation(p2)), max(brightness(p2), 0), 1);
				
				rect(x + random(-64, 68), y + random(-68,68), 8, 8);
				rect(x + random(-68, 68), y + random(-68, 68), 8, 8);
			}
		}
	}
	/*
	rectMode(CENTER);
	ellipseMode(CENTER);
	stroke(0, 0, 0, 128);
	noFill();
	strokeWeight(8);
  ellipse(width / 2, height / 2, 700, 700);
	rectMode(CORNER);
	ellipseMode(CORNER);*/
	
	xmotion += 0.01;
	ymotion += 0.04;
	
	if (frameCount < 140)
	image(img, width / 2 - img.width / 2, height / 2 - img.height / 2);
}

void setup() {
  size(800, 800);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	img = loadImage(""cuba.jpg"");
	image(img, width / 2 - img.width / 2, height / 2 - img.height / 2);
}

void draw() {
  draw_func();
}"
"679143","With images","mySketch","// Same tech as my feedback sketch with colors! (depend on brightness and neightbours)

float xmotion = 8.8;
float ymotion = 2.2;
PImage img;
void draw_func() {
	noStroke();
	
	loadPixels();
	for (int x = 1; x < width; x += 4) {
		float norm_x = x / width;

		for (int y = 1; y < height; y += 4) {
			color p = pixels[y * width + x];
			
			if (brightness(p) > 0) {
				float ppw = 2;
				float pph = 64;
				color p2 = pixels[(y+ceil(random(-ppw, ppw))) * width + (x+ceil(random(-pph, pph)))];
				
				fill((hue(p2)+hue(p))/2, max(0, saturation(p2)), max(brightness(p2), 0), 1);
				
				rect(x + random(-64, 68), y + random(-68, 68), 8, 8);
				rect(x + random(-68, 68), y + random(-68, 68), 8, 8);
			}
		}
	}
	/*
	rectMode(CENTER);
	ellipseMode(CENTER);
	stroke(0, 0, 0, 128);
	noFill();
	strokeWeight(8);
  ellipse(width / 2, height / 2, 700, 700);
	rectMode(CORNER);
	ellipseMode(CORNER);*/
	
	xmotion += 0.01;
	ymotion += 0.04;
	
	if (frameCount < 140)
	image(img, width / 2 - img.width / 2, height / 2 - img.height / 2);
}

void setup() {
  size(800, 800);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	img = loadImage(""cuba.jpg"");
	image(img, width / 2 - img.width / 2, height / 2 - img.height / 2);
}

void draw() {
  draw_func();
}"
"679143","With images","mySketch","// Same tech as my feedback sketch with colors! (depend on brightness and neightbours)

float xmotion = 8.8;
float ymotion = 2.2;
PImage img;
void draw_func() {
	noStroke();
	
	loadPixels();
	for (int x = 1; x < width; x += 4) {
		float norm_x = x / width;

		for (int y = 1; y < height; y += 4) {
			color p = pixels[y * width + x];
			
			if (brightness(p) > 0) {
				float ppw = 2;
				float pph = 64;
				color p2 = pixels[(y+ceil(random(-ppw, ppw))) * width + (x+ceil(random(-pph, pph)))];
				
				fill((hue(p2)+hue(p))/2, max(0, saturation(p2)), max(brightness(p2), 0), 1);
				
				rect(x + random(-4, 4), y + random(-4, 4), 8, 8);
				rect(x + random(-4, 4), y + random(-4, 4), 8, 8);
			}
		}
	}
	/*
	rectMode(CENTER);
	ellipseMode(CENTER);
	stroke(0, 0, 0, 128);
	noFill();
	strokeWeight(8);
  ellipse(width / 2, height / 2, 700, 700);
	rectMode(CORNER);
	ellipseMode(CORNER);*/
	
	xmotion += 0.01;
	ymotion += 0.04;
	
	if (frameCount < 140)
	image(img, width / 2 - img.width / 2, height / 2 - img.height / 2);
}

void setup() {
  size(800, 800);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	img = loadImage(""cuba.jpg"");
	image(img, width / 2 - img.width / 2, height / 2 - img.height / 2);
}

void draw() {
  draw_func();
}"
"679143","With images","mySketch","// Same tech as my feedback sketch with colors! (depend on brightness and neightbours)

float xmotion = 8.8;
float ymotion = 2.2;
PImage img;
void draw_func() {
	noStroke();
	
	loadPixels();
	for (int x = 1; x < width; x += 4) {
		float norm_x = x / width;

		for (int y = 1; y < height; y += 4) {
			color p = pixels[y * width + x];
			
			if (brightness(p) > 0) {
				float ppw = 2;
				float pph = 2;
				color p2 = pixels[(y+ceil(random(-ppw, ppw))) * width + (x+ceil(random(-pph, pph)))];
				
				fill((hue(p2)+hue(p))/2, max(0, saturation(p2)), max(brightness(p2), 0), 1);
				
				rect(x + random(-4, 4), y + random(-4, 4), 8, 8);
				//rect(x + random(-4, 4), y + random(-4, 4), 8, 8);
			}
		}
	}
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	stroke(0, 0, 0, 128);
	noFill();
	strokeWeight(8);
  ellipse(width / 2, height / 2, 500, 500);
	rectMode(CORNER);
	ellipseMode(CORNER);
	
	xmotion += 0.01;
	ymotion += 0.04;
	
	if (frameCount < 140)
	image(img, width / 2 - img.width / 2, height / 2 - img.height / 2);
}

void setup() {
  size(800, 800);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	img = loadImage(""cuba.jpg"");
	image(img, width / 2 - img.width / 2, height / 2 - img.height / 2);
}

void draw() {
  draw_func();
}"
"679143","With images","mySketch","// Same tech as my feedback sketch with colors! (depend on brightness and neightbours)

float xmotion = 8.8;
float ymotion = 2.2;
PImage img;

bool initial = true;

void draw_func() {
	noStroke();
	
	loadPixels();
	for (int x = 1; x < width; x += 8) {
		float norm_x = x / width;

		for (int y = 1; y < height; y += 8) {
			color p = pixels[y * width + x];
			
			if (brightness(p) > 192) {
				float ppw = 2;
				float pph = 2;
				color p2 = pixels[(y+ceil(random(-ppw, ppw))) * width + (x+ceil(random(-pph, pph)))];
				
				fill((hue(p2)+hue(p))/2.5, max(0, saturation(p2)), 0, 8);
				
				rect(x + random(-6, 6) - 2, y + random(-6, 6) - 2, 4, 4);
				//rect(x - 4, y - 4, 8, 8);
			} else {
				float ppw = 1;
				float pph = 1;
				color p2 = pixels[(y+ceil(random(-ppw, ppw))) * width + (x+ceil(random(-pph, pph)))];
				
				fill((hue(p2)+hue(p))/2.5, max(0, saturation(p2)), max(brightness(p), 0), 255);
				
				ellipse(x + random(-6, 6) - 2, y + random(-6, 6) - 2, 4, 4);
			}
		}
	}
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	stroke(0, 0, 0, 128);
	noFill();
	strokeWeight(8);
  ellipse(width / 2, height / 2, 500, 500);
	rectMode(CORNER);
	ellipseMode(CORNER);
	
	xmotion += 0.01;
	ymotion += 0.04;
	
	if (img.width > 0 && initial) {
		image(img, width / 2 - img.width / 2, height / 2 - img.height / 2);
		initial = false;
	}
}

void setup() {
  size(800, 800);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	img = loadImage(""royaltyfree.jpg"");
	image(img, width / 2 - img.width / 2, height / 2 - img.height / 2);
}

void draw() {
  draw_func();
}"
"679143","With images","mySketch","// Same tech as my feedback sketch with images.

float xmotion = 8.8;
float ymotion = 2.2;
PImage img;

bool initial = true;

void draw_func() {
	noStroke();
	
	loadPixels();
	for (int x = 1; x < width; x += 8) {
		float norm_x = x / width;

		for (int y = 1; y < height; y += 8) {
			color p = pixels[y * width + x];
			
			if (brightness(p) > 192) {
				float ppw = 2;
				float pph = 2;
				color p2 = pixels[(y+ceil(random(-ppw, ppw))) * width + (x+ceil(random(-pph, pph)))];
				
				fill((hue(p2)+hue(p))/2.5, max(0, saturation(p2)), 0, 8);
				
				rect(x + random(-6, 6) - 2, y + random(-6, 6) - 2, 4, 4);
				//rect(x - 4, y - 4, 8, 8);
			} else {
				float ppw = 1;
				float pph = 1;
				color p2 = pixels[(y+ceil(random(-ppw, ppw))) * width + (x+ceil(random(-pph, pph)))];
				
				fill((hue(p2)+hue(p))/2.5, max(0, saturation(p2)), max(brightness(p), 0), 255);
				
				ellipse(x + random(-6, 6) - 2, y + random(-6, 6) - 2, 4, 4);
			}
		}
	}
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	stroke(0, 0, 0, 128);
	noFill();
	strokeWeight(8);
  ellipse(width / 2, height / 2, 500, 500);
	rectMode(CORNER);
	ellipseMode(CORNER);
	
	xmotion += 0.01;
	ymotion += 0.04;
	
	if (img.width > 0 && initial) {
		image(img, width / 2 - img.width / 2, height / 2 - img.height / 2);
		initial = false;
	}
}

void setup() {
  size(800, 800);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	img = loadImage(""royaltyfree.jpg"");
	image(img, width / 2 - img.width / 2, height / 2 - img.height / 2);
}

void draw() {
  draw_func();
}"
"679143","With images","mySketch","// Same tech as my feedback sketch with images.

float xmotion = 8.8;
float ymotion = 2.2;
PImage img;

bool initial = true;

void draw_func() {
	noStroke();
	
	loadPixels();
	for (int x = 1; x < width; x += 8) {
		float norm_x = x / width;

		for (int y = 1; y < height; y += 8) {
			color p = pixels[y * width + x];
			
			if (brightness(p) > 192) {
				float ppw = 2;
				float pph = 2;
				color p2 = pixels[(y+ceil(random(-ppw, ppw))) * width + (x+ceil(random(-pph, pph)))];
				
				fill((hue(p2)+hue(p))/2.5, max(0, saturation(p2)), 0, 8);
				
				rect(x + random(-6, 6) - 2, y + random(-6, 6) - 2, 4, 4);
				//rect(x - 4, y - 4, 8, 8);
			} else {
				float ppw = 1;
				float pph = 1;
				color p2 = pixels[(y+ceil(random(-ppw, ppw))) * width + (x+ceil(random(-pph, pph)))];
				
				fill((hue(p2)+hue(p))/2.5, max(0, saturation(p2)), max(brightness(p), 0), 255);
				
				ellipse(x + random(-6, 6) - 2, y + random(-6, 6) - 2, 4, 4);
			}
		}
	}
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	stroke(0, 0, 0, 128);
	noFill();
	strokeWeight(8);
  ellipse(width / 2, height / 2, 500, 500);
	rectMode(CORNER);
	ellipseMode(CORNER);
	
	xmotion += 0.01;
	ymotion += 0.04;
	
	if (img.width > 0 && initial) {
		image(img, width / 2 - img.width / 2, height / 2 - img.height / 2);
		initial = false;
	}
}

void setup() {
  size(800, 800);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	img = loadImage(""royaltyfree.jpg"");
	image(img, width / 2 - img.width / 2, height / 2 - img.height / 2);
}

void draw() {
  draw_func();
}"
"679143","With images","mySketch","// Same tech as my feedback sketch with images.

float xmotion = 8.8;
float ymotion = 2.2;
PImage img;

bool initial = true;

void draw_func() {
	noStroke();
	
	loadPixels();
	for (int x = 1; x < width; x += 8) {
		float norm_x = x / width;

		for (int y = 1; y < height; y += 8) {
			color p = pixels[y * width + x];
			
			if (brightness(p) > 192) {
				float ppw = 2;
				float pph = 2;
				color p2 = pixels[(y+ceil(random(-ppw, ppw))) * width + (x+ceil(random(-pph, pph)))];
				
				fill((hue(p2)+hue(p))/2.5, max(0, saturation(p2)), 0, 8);
				
				rect(x + random(-6, 6) - 2, y + random(-6, 6) - 2, 4, 4);
				//rect(x - 4, y - 4, 8, 8);
			} else {
				float ppw = 1;
				float pph = 1;
				color p2 = pixels[(y+ceil(random(-ppw, ppw))) * width + (x+ceil(random(-pph, pph)))];
				
				fill((hue(p2)+hue(p))/2.5, max(0, saturation(p2)), max(brightness(p), 0), 255);
				
				ellipse(x + random(-6, 6) - 2, y + random(-6, 6) - 2, 4, 4);
			}
		}
	}
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	stroke(0, 0, 0, 128);
	noFill();
	strokeWeight(8);
  ellipse(width / 2, height / 2, 500, 500);
	rectMode(CORNER);
	ellipseMode(CORNER);
	
	xmotion += 0.01;
	ymotion += 0.04;
	
	if (img.width > 0 && initial) {
		image(img, width / 2 - img.width / 2, height / 2 - img.height / 2);
		initial = false;
	}
}

void setup() {
  size(800, 800);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	img = loadImage(""royaltyfree.jpg"");
	image(img, width / 2 - img.width / 2, height / 2 - img.height / 2);
}

void draw() {
  draw_func();
}"
"679072","Colorful","mySketch","float xmotion = 8.8;
float ymotion = 2.2;

void draw_func() {
	noStroke();
	
	loadPixels();
	for (int x = 4; x < width; x += 4) {
		float norm_x = x / width;
		float anorm_x = abs(0.5 - norm_x) * 2;
		
		for (int y = 4; y < height; y += 4) {
			color p = pixels[y * width + x];
			
			if (brightness(p) > 64 && brightness(p) < 128) {
				int ppx = random(8);
				int ppy = random(8);
				color p2 = pixels[(y+ceil(random(-ppx, ppx))) * width + (x+ceil(random(-ppy, ppy)))];
				
				fill(hue(p2) * 1.25, 128, 255, 48);
				
				rect(x + random(-8, 8), y + random(-8, 8), 4, 4);
			} else if (brightness(p) > 192) {
				float norm_y = y / height;
				float anorm_y = abs(0.5 - norm_y) * 2;
				
				fill(0, 0, 0, 24);
				ellipse(x + sin(norm_x * PI * 2 + ymotion) * 64, y + cos(norm_y * PI * 2 + xmotion) * 64, 64, 64);
				ellipse(y + cos(norm_x * PI * 2 + xmotion) * 64, x + sin(norm_y * PI * 2 + ymotion) * 64, 64, 64);
			}
		}
	}
	
	stroke(frameCount % 64 * 4, 128, 255, 64);
	noFill();
	strokeCap(PROJECT);
	strokeWeight(8);
	fill((frameCount + 0) % 64 * 4, 128, 255, 64);
  ellipse(width / 2 - 100, height / 2 - 100, 200, 200);
	fill(0, 0, 255, 255);
	ellipse(width / 2 - 48 / 2 - 48, height / 2 - 48/2 - 12, 48, 48);
	ellipse(width / 2 - 48 / 2 + 48, height / 2 - 48/2 - 10, 48, 48);
	fill((frameCount + 4) % 64 * 4, 128, 255, 24);
	triangle(width / 2, height / 2 - 256, width - width / 4, height / 2 + 256, width / 4, height / 2 + 256);
	//fill(0, 0, 0, 255);
	//rect(width / 2 - 50, height / 2 + 32, 100, 24);
	fill(0, 0, 0, 128);
	ellipse(width / 2 - 12 / 2, height / 2 + 8, 12, 12);
	noStroke();
	fill(0, 0, 255, 255);
	arc(width / 2 - 50, height / 2 + 48, 100, 12, 0, PI, CHORD);
	
	xmotion += 0.01;
	ymotion += 0.04;
}

void setup() {
  size(1000, 800);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	noFill();
	strokeWeight(16);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	fill(0, 0, 255, 255);
	
	//ellipse(width / 2, height / 2, 700, 700);

	rectMode(CORNER);
	ellipseMode(CORNER);
	
	//smooth();
}

void draw() {
  draw_func();
}"
"679035","Seabed","mySketch","float xmotion = 8.8;
float ymotion = 2.2;

void draw_func() {
	noStroke();
	
	loadPixels();
	for (int x = 1; x < width; x += 4) {
		float norm_x = x / width;

		for (int y = 1; y < height; y += 4) {
			color p = pixels[y * width + x];
			
			if (brightness(p) > 64 && brightness(p) < 128) {
				color p2 = pixels[(y+ceil(random(-1, 1))) * width + (x+ceil(random(-1, 1)))];
				
				fill(brightness(p) + hue(p2) / 2, 128, 255, 92);
				
				rect(width - x + random(8), height - y + random(8), 2, 4);
				rect(width - x + random(8), height - y + random(8), 2, 4);
			} else if (brightness(p) > 224) {
				float norm_y = y / height;
				
				fill(0, 0, 0, 12);
				ellipse(x + sin(norm_x * PI * 2 + ymotion) * 64, y + cos(norm_y * PI * 2 + xmotion) * 64, 64, 64);
				ellipse(y + cos(norm_x * PI * 2 + xmotion) * 64, x + sin(norm_y * PI * 2 + ymotion) * 64, 64, 64);
			}
		}
	}
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	stroke(0, 0, 0, 128);
	noFill();
	strokeWeight(8);
  ellipse(width / 2, height / 2, 700, 700);
	rectMode(CORNER);
	ellipseMode(CORNER);
	
	xmotion += 0.01;
	ymotion += 0.04;
}

void setup() {
  size(1000, 800);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	noFill();
	strokeWeight(16);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	fill(0, 0, 255, 255);
	
	ellipse(width / 2, height / 2, 700, 700);

	rectMode(CORNER);
	ellipseMode(CORNER);
	
	//smooth();
}

void draw() {
  draw_func();
}"
"679035","Seabed","mySketch","// Same tech as my feedback sketch with colors! (depend on brightness and neightbours)

float xmotion = 8.8;
float ymotion = 2.2;

void draw_func() {
	noStroke();
	
	loadPixels();
	for (int x = 1; x < width; x += 4) {
		float norm_x = x / width;

		for (int y = 1; y < height; y += 4) {
			color p = pixels[y * width + x];
			
			if (brightness(p) > 64 && brightness(p) < 128) {
				color p2 = pixels[(y+ceil(random(-1, 1))) * width + (x+ceil(random(-1, 1)))];
				
				fill(brightness(p) + hue(p2) / 2, 128, 255, 92);
				
				rect(width - x + random(8), height - y + random(8), 2, 4);
				rect(width - x + random(8), height - y + random(8), 2, 4);
			} else if (brightness(p) > 224) {
				float norm_y = y / height;
				
				fill(0, 0, 0, 12);
				ellipse(x + sin(norm_x * PI * 2 + ymotion) * 64, y + cos(norm_y * PI * 2 + xmotion) * 64, 64, 64);
				ellipse(y + cos(norm_x * PI * 2 + xmotion) * 64, x + sin(norm_y * PI * 2 + ymotion) * 64, 64, 64);
			}
		}
	}
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	stroke(0, 0, 0, 128);
	noFill();
	strokeWeight(8);
  ellipse(width / 2, height / 2, 700, 700);
	rectMode(CORNER);
	ellipseMode(CORNER);
	
	xmotion += 0.01;
	ymotion += 0.04;
}

void setup() {
  size(1000, 800);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	noFill();
	strokeWeight(16);
	
	rectMode(CENTER);
	ellipseMode(CENTER);
	
	fill(0, 0, 255, 255);
	
	ellipse(width / 2, height / 2, 700, 700);

	rectMode(CORNER);
	ellipseMode(CORNER);
	
	//smooth();
}

void draw() {
  draw_func();
}"
"678498","Terrarium","mySketch","float xmotion = 8.8;
float ymotion = 2.2;

void draw_func() {
	noStroke();
	
	loadPixels();
	for (int x = 1; x < width; x += 4) {
		float norm_x = x / width;

		for (int y = 1; y < height; y += 4) {
			color p = pixels[y * width + x];
			
			if (brightness(p) > 64 && brightness(p) < 128) {
				color p2 = pixels[(y+ceil(random(-1, 1))) * width + (x+ceil(random(-1, 1)))];
				
				fill(0, 0, 255, 16);
				
				rect(width - x + random(8), height - y + random(8), 4, 4);
				rect(width - x + random(24), height - y + random(24), 4, 4);
			} else if (brightness(p) > 224) {
				float norm_y = y / height;
				
				fill(0, 0, 0, 12);
				ellipse(x + sin(norm_x * PI * 2 + ymotion) * 24, y + cos(norm_y * PI * 2 + xmotion) * 24, 64, 64);
				ellipse(y + cos(norm_x * PI * 2 + xmotion) * 24, x + sin(norm_y * PI * 2 + ymotion) * 24, 64, 64);
			}
		}
	}

	xmotion += 0.001;
	ymotion += 0.004;
}

void setup() {
  size(1000, 800);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	noFill();
	strokeWeight(16);
	
	rectMode(CENTER);
	ellipseMode(CENTER);

	float c = 0;
	for (int j = 2; j < 6; j += 1) {
		for (int i = 2; i < 6; i += 1) {
			int w = (width - 1) / i;
			int h = (height - 1) / j;
			
			stroke(64 + abs(sin((c / 16) * PI * 8) * 64), abs(sin((c / 16) * PI * 4) * 64), 255, 255);
			
			point(w, h);
			point(width - w, h);
			point(w, height - h);
			point(width - w, height - h);
			
			c += 1;
		}
	}

	rectMode(CORNER);
	ellipseMode(CORNER);
	
	//smooth();
}

void draw() {
  draw_func();
}"
"678491","Processing","mySketch","float xmotion = 0.8;
float ymotion = 2.2;

void draw_func() {
	noStroke();
	
	loadPixels();
	for (int x = 1; x < width; x += 4) {
		float norm_x = x / width;
		float norm_xa = abs(0.5 - norm_x) * 2;

		for (int y = 1; y < height; y += 4) {
			color p = pixels[y * width + x];
			
			float norm_y = y / height;
			float norm_ya = abs(0.5 - norm_y) * 2;
			
			if (brightness(p) > (random(0, 1) > 0.125 ? 64 : 48) && brightness(p) < 128) {
				color p2 = pixels[(y+ceil(random(-1, 1))) * width + (x+ceil(random(-1, 1)))];
				
				fill(0, 0, 255, 14);
				
				rect(width - x + random(8), height - y + random(8), 4, 4);
				rect(width - x + random(12), height - y + random(12), 4, 4);
			} else if (brightness(p) >= 224) {
				float r = (random(0, 1) > 0.125 ? 64 : 24);
				float r2 = (random(0, 1) > 0.125 ? 64 : 8);
				
				fill(0, 0, 0, 18);
				ellipse(x + sin(norm_x * PI * 2 + ymotion) * random(4, 24), y + cos(norm_y * PI * 2 + xmotion) * random(4, 24), r, r2);
				ellipse(y + cos(norm_y * PI * 2 + xmotion) * random(24, 24), x + sin(norm_x * PI * 2 + ymotion) * random(4, 24), r, r2);
				
				noStroke();
			}
		}
	}
		noFill();
	textSize(118);
	fill(0, 0, 255, 48);
	textAlign(CENTER);
	text(""PROCESSING"", width / 2, height / 2);
	
	xmotion += 0.5;
	ymotion += 0.008;
}

void setup() {
  size(800, 800);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	//smooth();
}

void draw() {
  draw_func();
}"
"677901","Chronopolis","mySketch","/**
  * See 'Amoeba' sketch.
	*
	* Applying masks to make feedback look like stained glass.
	*/

float xmotion = 8.8;
float ymotion = 2.2;

void draw_func() {
	noStroke();
	
	loadPixels();
	for (int x = 1; x < width; x += 4) {
		float norm_x = x / width;

		for (int y = 1; y < height; y += 4) {
			color p = pixels[y * width + x];
			
			if (brightness(p) > 42 && brightness(p) < 192) {
				color p2 = pixels[(y+ceil(random(-1, 1))) * width + (x+ceil(random(-1, 1)))];
				
				float norm_y = y / height;
				
				int h = 42 + (hue(p2) + hue(p)) / 2;
				int s = 128;
				int b = 255;
				
				fill(h, s, b, 44);
				
				rect(width - x + random(64) - 2, height - y + random(64) - 2, 2, 2);
			} else if (brightness(p) > 192) {
				fill(0, 0, 0, 24);
				// quite cool stuff by playing with noise size
				rect(x + random(2), y + random(2), 4, 4);
				rect(y + random(2), x + random(2), 4, 4);
			}
		}
	}
	
	noFill();
	ellipseMode(CENTER);
	for (int j = 2; j < 8; j += 2) {
		strokeWeight(random(1, 24) / (j - 1));
		stroke(0, 0, 0, random(0, 92));
		
		int w = (width - 1) / j;
		int h = (height - 1) / j;
		ellipse(w, h, width - w, height - h);
		ellipse(width - w, h, width - w, height - h);
		ellipse(width - w, height - h, width - w, height - h);
		ellipse(w, height - h, width - w, height - h);
		
		rect(w, h, w, h);
		rect(width - w, h, w, h);
		rect(w, height - h, w, h);
		rect(width - w, height - h, w, h);
	}
	ellipseMode(CORNER);

	xmotion += 0.005;
	ymotion += 0.008;
}

void setup() {
  size(600, 600);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	noFill();
	strokeWeight(16);
	
	rectMode(CENTER);
	ellipseMode(CENTER);

	float c = 0;
	for (int j = 2; j < 4; j += 1) {
		for (int i = 2; i < 4; i += 1) {
			int w = (width - 1) / i;
			int h = (height - 1) / j;
			
			stroke(64 + abs(sin((c / 4) * PI * 2) * (360 - 128)), 128, 128, 255);
			
			//rect(width / 2, height / 2, w, h);
			//ellipse(width / 2, height / 2, w, h);
			point(w, h);
			point(width - w, h);
			point(w, height - h);
			point(width - w, height - h);
			
			c += 1;
		}
	}

	//ellipse(width / 4, height / 3, 32, 32);
	//ellipse(width - width / 4, height / 3, 32, 32);
	
	rectMode(CORNER);
	ellipseMode(CORNER);
	
	//smooth();
}

void draw() {
  draw_func();
}"
"677901","Chronopolis","mySketch","/**
  * See 'Amoeba' and 'Stained glass' sketch.
	*
	* Applying masks again on a different kind of noise.
	*/

float xmotion = 8.8;
float ymotion = 2.2;

void draw_func() {
	noStroke();
	
	loadPixels();
	for (int x = 1; x < width; x += 4) {
		float norm_x = x / width;

		for (int y = 1; y < height; y += 4) {
			color p = pixels[y * width + x];
			
			if (brightness(p) > 42 && brightness(p) < 192) {
				color p2 = pixels[(y+ceil(random(-1, 1))) * width + (x+ceil(random(-1, 1)))];
				
				float norm_y = y / height;
				
				int h = 42 + (hue(p2) + hue(p)) / 2;
				int s = 128;
				int b = 255;
				
				fill(h, s, b, 44);
				
				rect(width - x + random(64) - 2, height - y + random(64) - 2, 2, 2);
			} else if (brightness(p) > 192) {
				fill(0, 0, 0, 24);
				// quite cool stuff by playing with noise size
				rect(x + random(2), y + random(2), 4, 4);
				rect(y + random(2), x + random(2), 4, 4);
			}
		}
	}
	
	noFill();
	ellipseMode(CENTER);
	for (int j = 2; j < 8; j += 2) {
		strokeWeight(random(1, 24) / (j - 1));
		stroke(0, 0, 0, random(0, 92));
		
		int w = (width - 1) / j;
		int h = (height - 1) / j;
		ellipse(w, h, width - w, height - h);
		ellipse(width - w, h, width - w, height - h);
		ellipse(width - w, height - h, width - w, height - h);
		ellipse(w, height - h, width - w, height - h);
		
		rect(w, h, w, h);
		rect(width - w, h, w, h);
		rect(w, height - h, w, h);
		rect(width - w, height - h, w, h);
	}
	ellipseMode(CORNER);

	xmotion += 0.005;
	ymotion += 0.008;
}

void setup() {
  size(600, 600);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	noFill();
	strokeWeight(16);
	
	rectMode(CENTER);
	ellipseMode(CENTER);

	float c = 0;
	for (int j = 2; j < 4; j += 1) {
		for (int i = 2; i < 4; i += 1) {
			int w = (width - 1) / i;
			int h = (height - 1) / j;
			
			stroke(64 + abs(sin((c / 4) * PI * 2) * (360 - 128)), 128, 128, 255);
			
			//rect(width / 2, height / 2, w, h);
			//ellipse(width / 2, height / 2, w, h);
			point(w, h);
			point(width - w, h);
			point(w, height - h);
			point(width - w, height - h);
			
			c += 1;
		}
	}

	//ellipse(width / 4, height / 3, 32, 32);
	//ellipse(width - width / 4, height / 3, 32, 32);
	
	rectMode(CORNER);
	ellipseMode(CORNER);
	
	//smooth();
}

void draw() {
  draw_func();
}"
"677895","Stained glass","mySketch","/**
  * See 'Amoeba' sketch.
	*
	* Applying masks to make feedback look like stained glass.
	*/

float xmotion = 8.8;
float ymotion = 2.2;

void draw_func() {
	noStroke();
	
	loadPixels();
	for (int x = 1; x < width; x += 4) {
		float norm_x = x / width;

		for (int y = 1; y < height; y += 4) {
			color p = pixels[y * width + x];
			
			if (brightness(p) > 2 && brightness(p) < 128) {
				color p2 = pixels[(y+ceil(random(-1, 1))) * width + (x+ceil(random(-1, 1)))];
				
				float norm_y = y / height;
				
				int h = (hue(p2) + hue(p)) / 2;
				int s = saturation(p);
				int b = 255;
				
				fill(h, s, b, 24);
				
				rect(width - x + random(8) - 2, height - y + random(8) - 2, 2, 2);
			} else if (brightness(p) > 224) {
				fill(0, 0, 0, 12);
				// quite cool stuff by playing with noise size
				rect(x + random(8), y + random(8), 4, 4);
				rect(y + random(8), x + random(8), 4, 4);
			}
		}
	}
	
	noFill();
	stroke(0, 0, 0, 255);
	ellipseMode(CENTER);
	for (int j = 3; j < 5; j += 1) {
		strokeWeight(random(1, 8));
		int w = (width - 1) / j;
		int h = (height - 1) / j;
		ellipse(w, h, width - w, height - h);
		ellipse(width - w, h, width - w, height - h);
		ellipse(width - w, height - h, width - w, height - h);
		ellipse(w, height - h, width - w, height - h);
		
		ellipse(w, h, w, h);
		ellipse(width - w, h, w, h);
		ellipse(w, height - h, w, h);
		ellipse(width - w, height - h, w, h);
	}
	ellipseMode(CORNER);

	xmotion += 0.005;
	ymotion += 0.008;
}

void setup() {
  size(600, 600);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	noFill();
	strokeWeight(16);
	
	rectMode(CENTER);
	ellipseMode(CENTER);

	float c = 0;
	for (int j = 1; j < 4; j += 1) {
		for (int i = 1; i < 4; i += 1) {
			int w = (width - 1) / i;
			int h = (height - 1) / j;
			
			stroke(128 + abs(sin((c / 12) * PI * 2) * (360 - 128)), 128, 128, 255);
			
			//rect(width / 2, height / 2, w, h);
			//ellipse(width / 2, height / 2, w, h);
			//point(w, h);
			//point(width - w, h);
			//point(w, height - h);
			point(width - w, height - h);
			
			c += 1;
		}
	}

	//ellipse(width / 4, height / 3, 32, 32);
	//ellipse(width - width / 4, height / 3, 32, 32);
	
	rectMode(CORNER);
	ellipseMode(CORNER);
	
	//smooth();
}

void draw() {
  draw_func();
}"
"677885","Amoeba","mySketch","/**
  * More thoughtful rétroaction / feedback (again)
	* Feedback seed is given by some simple starting shapes which are shaded together by neightbours,
	* large scale patterns are made by increasing the cancelling noise size and careful choice of brightness filter which give the picture its shading quality,
	* additionally a mask is applied to stop the feedback process on spherical boundary loosely. 
	*
	* Resolution can be increased by changing the loops step (and decreasing shapes size) but its slow.
	*
	* Marvelous algorithm to make chemical / organic like patterns / texture / shapes and way more.
	*/

float xmotion = 8.8;
float ymotion = 2.2;

void draw_func() {
	noStroke();
	
	loadPixels();
	for (int x = 1; x < width; x += 2) {
		float norm_x = x / width;

		for (int y = 1; y < height; y += 2) {
			color p = pixels[y * width + x];
			
			if (brightness(p) > 64 && brightness(p) < 128) {
				color p2 = pixels[(y+ceil(random(-1, 1))) * width + (x+ceil(random(-1, 1)))];
				
				float norm_y = y / height;
				
				int h = (hue(p2) + hue(p)) * 2;
				int s = saturation(p);
				int b = 255;
				
				fill(h, s, b, 24);
				
				rect(width - x + random(8) - 2, height - y + random(8) - 2, 4, 4);
			} else if (brightness(p) > 224) {
				fill(0, 0, 0, 12);
				// quite cool stuff by playing with noise size
				rect(x + random(64), y + random(128), 4, 4);
				rect(y + random(64), x + random(128), 4, 4);
			}
		}
	}
	
	noFill();
	strokeWeight(8);
	stroke(0, 0, 0, 255);
	ellipseMode(CENTER);
	ellipse(width / 2, height / 2, width, height);
	ellipseMode(CORNER);

	xmotion += 0.005;
	ymotion += 0.008;
}

void setup() {
  size(600, 600);

  background(0);
	
	colorMode(HSB, 360, 256, 256);
	
	noFill();
	strokeWeight(16);
	
	rectMode(CENTER);
	ellipseMode(CENTER);

	float c = 0;
	for (int j = 2; j < 4; j += 1) {
		for (int i = 2; i < 4; i += 1) {
			int w = (width - 1) / i;
			int h = (height - 1) / j;
			
			stroke(abs(sin((c / 64) * PI * 2) * 360), 128, 128, 255);
			
			//rect(width / 2, height / 2, w, h);
			ellipse(width / 2, height / 2, w, h);
			//point(w, h);
			//point(width - w, h);
			//point(w, height - h);
			//point(width - w, height - h);
			
			c += 1;
		}
	}

	//ellipse(width / 4, height / 3, 32, 32);
	//ellipse(width - width / 4, height / 3, 32, 32);
	
	rectMode(CORNER);
	ellipseMode(CORNER);
	
	//smooth();
}

void draw() {
  draw_func();
}"
"671228","Shadows","mySketch","float xmotion = 4;
float ymotion = 4;

void setup() {
  size(800, 800);
  
  colorMode(HSB, 360, 255, 255);
  
  background(0);
  noStroke();
  
  strokeWeight(1);
  
  noiseDetail(7, 0.5);
}

float radius = 292;
int lastmx = -1;

void draw() {
  //background(0, 0, 0, 2);
  noStroke();
	
  fill(0, 0, 0, 8);
	rect(0, 0, width, height);
  
  float count = 26;
  
  float i = 0; float j = 0;
  
  for (j = 0; j < 1; j += 0.01) {
		float jnorm_j = abs(0.5 - j) * 2;
  for (i = 0; i < count; i += 1) {
    float norm_i = i / count;
    float unit_i = 1 / count;
    
    float inorm_i = abs(0.5 - norm_i) * 2;
    
    float n = noise(inorm_i, jnorm_j) / 32;
    float nn = n * 2;
    
    float cx = radius * sin(norm_i * PI * 2 + j / 4);
    float cy = radius * cos(norm_i * PI * 2 + j / 4);
    
    float cx2 = radius * sin((unit_i + norm_i) * PI * 2 + cos(xmotion)/1.75 + 0.5) * (radius * 8 + jnorm_j * 2);
    float cy2 = radius * cos((unit_i + norm_i) * PI * 2 + sin(ymotion)/1.75 + 0.5) * (radius * 8 + jnorm_j * 2);
		
		//float dst = abs(cx - cx2) + abs(cy - cy2);
		//if (dst > 2000) continue;
		
    float x =  width / 2;
    float y = height / 2;
    
    fill(0, 0, 0, random(0, 64));
    ellipse(x + cx, y + cy, 32, 32);
		ellipse(x + cx2 / 2, y + cy2 / 2, 32, 32);
    
    stroke(inorm_i * 360 * 2 % 360, 0, 0, 128);
    line(x + cx / 2, y + cy / 2, x + cx2 / 2, y + cy2 / 2);

    noStroke();
		
  }
  	fill(60, 128, 255, 32 * (1-j));
		ellipse(width / 2, height / 2, height * j/(1.25 + cos(xmotion)/10), height * j/(1.25 + cos(xmotion)/10));
  }
	
  xmotion += 0.004;
  ymotion += 0.004;
}"
"671227","Tournesol","mySketch","float xmotion = 4;
float ymotion = 4;

void setup() {
  size(1920, 800);
  
  colorMode(HSB, 360, 255, 255);
  
  background(0);
  noStroke();
  
  strokeWeight(1);
  
  noiseDetail(7, 0.5);
}

float radius = 292;
int lastmx = -1;

void draw() {
  //background(0, 0, 0, 2);
  noStroke();
	
  fill(0, 0, 0, 8);
	rect(0, 0, width, height);
  
  float count = 24;
  
  float i = 0; float j = 0;
  
  for (j = 0; j < 1; j += 0.01) {
		float jnorm_j = abs(0.5 - j) * 2;
  for (i = 0; i < count; i += 1) {
    float norm_i = i / count;
    float unit_i = 1 / count;
    
    float inorm_i = abs(0.5 - norm_i) * 2;
    
    float n = noise(inorm_i, jnorm_j) / 32;
    float nn = n * 2;
    
    float cx = radius * sin(norm_i * PI * 2 + j / 4);
    float cy = radius * cos(norm_i * PI * 2 + j / 4);
    
    float cx2 = radius * sin((unit_i + norm_i) * PI * 2 + cos(xmotion)/1.75 + 0.5) * (radius * 8 + jnorm_j * 2);
    float cy2 = radius * cos((unit_i + norm_i) * PI * 2 + sin(ymotion)/1.75 + 0.5) * (radius * 8 + jnorm_j * 2);
		
		//float dst = abs(cx - cx2) + abs(cy - cy2);
		//if (dst > 2000) continue;
		
    float x =  width / 2;
    float y = height / 2;
    
    //fill(0, 0, 64, random(0, 64));
    //ellipse(x + cx, y + cy, 4, 4);
		//ellipse(x + cx2 / 2, y + cy2 / 2, 8, 8);
    
    stroke(inorm_i * 360 * 2 % 360, 128, 255, 16);
    //line(x + cx, y + cy, x + cx2, y + cy2);
    //line(x + cx / 2, y + cy / 2, x + cx2 / 2, y + cy2 / 2);
		
    line(x + cx, y + cy, x + cx2 / 2, y + cy2 / 2);
		//line(x + cx / 2, y + cy / 2, x + cx2 / 64, y + cy2 / 64);
    line(width - x + cx, height - y + cy, width - x + cx2, height - y + cy2);
    noStroke();
		
  }
  	fill(60, 128, 255, 32 * (1-j));
		ellipse(width / 2, height / 2, height * j/(1.25 + cos(xmotion)/10), height * j/(1.25 + cos(xmotion)/10));
  }
	
  xmotion += 0.004;
  ymotion += 0.004;
}"
"671227","Tournesol","mySketch","float xmotion = 4;
float ymotion = 4;

void setup() {
  size(800, 800);
  
  colorMode(HSB, 360, 255, 255);
  
  background(0);
  noStroke();
  
  strokeWeight(1);
  
  noiseDetail(7, 0.5);
}

float radius = 292;
int lastmx = -1;

void draw() {
  //background(0, 0, 0, 2);
  noStroke();
	
  fill(0, 0, 0, 8);
	rect(0, 0, width, height);
  
  float count = 24;
  
  float i = 0; float j = 0;
  
  for (j = 0; j < 1; j += 0.01) {
		float jnorm_j = abs(0.5 - j) * 2;
  for (i = 0; i < count; i += 1) {
    float norm_i = i / count;
    float unit_i = 1 / count;
    
    float inorm_i = abs(0.5 - norm_i) * 2;
    
    float n = noise(inorm_i, jnorm_j) / 32;
    float nn = n * 2;
    
    float cx = radius * sin(norm_i * PI * 2 + j / 4);
    float cy = radius * cos(norm_i * PI * 2 + j / 4);
    
    float cx2 = radius * sin((unit_i + norm_i) * PI * 2 + cos(xmotion)/1.75 + 0.5) * (radius * 8 + jnorm_j * 2);
    float cy2 = radius * cos((unit_i + norm_i) * PI * 2 + sin(ymotion)/1.75 + 0.5) * (radius * 8 + jnorm_j * 2);
		
		//float dst = abs(cx - cx2) + abs(cy - cy2);
		//if (dst > 2000) continue;
		
    float x =  width / 2;
    float y = height / 2;
    
    //fill(0, 0, 64, random(0, 64));
    //ellipse(x + cx, y + cy, 4, 4);
		//ellipse(x + cx2 / 2, y + cy2 / 2, 8, 8);
    
    stroke(inorm_i * 360 * 2 % 360, 128, 255, 16);
    //line(x + cx, y + cy, x + cx2, y + cy2);
    //line(x + cx / 2, y + cy / 2, x + cx2 / 2, y + cy2 / 2);
		
    line(x + cx, y + cy, x + cx2 / 2, y + cy2 / 2);
		//line(x + cx / 2, y + cy / 2, x + cx2 / 64, y + cy2 / 64);
    line(width - x + cx, height - y + cy, width - x + cx2, height - y + cy2);
    noStroke();
		
  }
  	fill(60, 128, 255, 32 * (1-j));
		ellipse(width / 2, height / 2, height * j/(1.25 + cos(xmotion)/10), height * j/(1.25 + cos(xmotion)/10));
  }
	
  xmotion += 0.004;
  ymotion += 0.004;
}"
"671227","Tournesol","mySketch","float xmotion = 4;
float ymotion = 4;

void setup() {
  size(800, 800);
  
  colorMode(HSB, 360, 255, 255);
  
  background(0);
  noStroke();
  
  strokeWeight(1);
  
  noiseDetail(7, 0.5);
}

float radius = 292;
int lastmx = -1;

void draw() {
  //background(0, 0, 0, 2);
  noStroke();
	
  fill(0, 0, 0, 8);
	rect(0, 0, width, height);
  
  float count = 24;
  
  float i = 0; float j = 0;
  
  for (j = 0; j < 1; j += 0.01) {
		float jnorm_j = abs(0.5 - j) * 2;
  for (i = 0; i < count; i += 1) {
    float norm_i = i / count;
    float unit_i = 1 / count;
    
    float inorm_i = abs(0.5 - norm_i) * 2;
    
    float n = noise(inorm_i, jnorm_j) / 32;
    float nn = n * 2;
    
    float cx = radius * sin(norm_i * PI * 2 + j / 4);
    float cy = radius * cos(norm_i * PI * 2 + j / 4);
    
    float cx2 = radius * sin((unit_i + norm_i) * PI * 2 + cos(xmotion)/1.75 + 0.5) * (radius * 8 + jnorm_j * 2);
    float cy2 = radius * cos((unit_i + norm_i) * PI * 2 + sin(ymotion)/1.75 + 0.5) * (radius * 8 + jnorm_j * 2);
		
		//float dst = abs(cx - cx2) + abs(cy - cy2);
		//if (dst > 2000) continue;
		
    float x =  width / 2;
    float y = height / 2;
    
    //fill(0, 0, 64, random(0, 64));
    //ellipse(x + cx, y + cy, 4, 4);
		//ellipse(x + cx2 / 2, y + cy2 / 2, 8, 8);
    
    stroke(inorm_i * 360 * 2 % 360, 128, 255, 16);
    //line(x + cx, y + cy, x + cx2, y + cy2);
    //line(x + cx / 2, y + cy / 2, x + cx2 / 2, y + cy2 / 2);
		
    line(x + cx, y + cy, x + cx2 / 2, y + cy2 / 2);
		//line(x + cx / 2, y + cy / 2, x + cx2 / 64, y + cy2 / 64);
    line(width - x + cx, height - y + cy, width - x + cx2, height - y + cy2);
    noStroke();
		
  }
  	fill(60, 128, 255, 32 * (1-j));
		ellipse(width / 2, height / 2, height * j/(1.25 + cos(xmotion)/10), height * j/(1.25 + cos(xmotion)/10));
  }
	
  xmotion += 0.004;
  ymotion += 0.004;
}"
"670943","Rainbow sphere","mySketch","float xmotion = 0;
float ymotion = 0;

void setup() {
  size(800, 640);
  
  colorMode(HSB, 360, 255, 255);
  
  background(0);
  noStroke();
  
  strokeWeight(1);
  
  noiseDetail(7, 0.5);
}

float radius = 292;
int lastmx = -1;

void draw() {
  //background(0, 0, 0, 2);
  noStroke();
	
  fill(0, 0, 0, 8);
	rect(0, 0, width, height);
  
  float count = 24;
  
  float i = 0; float j = 0;
  
  for (j = 0; j < 1; j += 0.01) {
		float jnorm_j = abs(0.5 - j) * 2;
  for (i = 0; i < count; i += 1) {
    float norm_i = i / count;
    float unit_i = 1 / count;
    
    float inorm_i = abs(0.5 - norm_i) * 2;
    
    float n = noise(inorm_i, jnorm_j) / 32;
    float nn = n * 2;
    
    float cx = radius * sin(norm_i * PI * 2 + j / 4);
    float cy = radius * cos(norm_i * PI * 2 + j / 4);
    
    float cx2 = radius * sin((unit_i + norm_i) * PI * 2 + cos(xmotion) + 4.5) * (radius / 2 + jnorm_j * 16);
    float cy2 = radius * cos((unit_i + norm_i) * PI * 2 + sin(ymotion) + 0.5) * (radius / 2 + jnorm_j * 16);
		
		//float dst = abs(cx - cx2) + abs(cy - cy2);
		//if (dst > 2000) continue;
		
    float x =  width / 2;
    float y = height / 2;
    
    //fill(0, 0, 64, random(0, 64));
    //ellipse(x + cx, y + cy, 4, 4);
		//ellipse(x + cx2 / 2, y + cy2 / 2, 8, 8);
    
    stroke(inorm_i * 360 * 2 % 360, 128, 255, 16);
    //line(x + cx, y + cy, x + cx2, y + cy2);
    //line(x + cx / 2, y + cy / 2, x + cx2 / 2, y + cy2 / 2);
		
    line(x + cx, y + cy, x + cx2 / 2, y + cy2 / 2);
		//line(x + cx / 2, y + cy / 2, x + cx2 / 64, y + cy2 / 64);
    line(width - x + cx, height - y + cy, width - x + cx2, height - y + cy2);
    noStroke();
		
  }
  	fill(0, 0, 0, 48 * (1-j));
		ellipse(width / 2, height / 2, height * j, height * j);
  }
	
  xmotion += 0.005;
  ymotion += 0.005;
}"
"670702","Polymess","mySketch","
float xmotion = 0;
float ymotion = 0;

static int n = 500;

float xx[] = new float[n];
float yy[] = new float[n];
float vv[] = new float[n];

int sign(float v) {
  return (v > 0) ? 1 : -1;
}

void setup() {
  size(1024, 600);
  
  colorMode(HSB, 360, 255, 255);
  
  background(0);
  noStroke();
  
  strokeWeight(1);
  
  int j = 0;
  
  for (j = 0; j < n; j += 1){
    float norm_j = (float)j / n;
    float anorm_j = abs(0.5 - norm_j) * 2;
		
    xx[j] = random(0, width);
    yy[j] = random(0, height);
    vv[j] = random(1, 2) * sign(random(-1, 1));
  }
}

int x = 0; int y = 0; int v = 8;

void draw() {
	noStroke();
  //background(0, 0, 0, 8);
  fill(0, 0, 0, 1);
  rect(0, 0, width, height);
 
  int j = 0;
  
  for (j = 0; j < n; j += 1) {
    float norm_j = (float)j / n;
    float anorm_j = abs(0.5 - norm_j) * 2;
    float norm_x = (float)xx[j] / width;
    float anorm_x = abs(0.5 - norm_x) * 2;
    
    //fill(aa[j] * 360, rr[j], anorm_j * 255, 10 + anorm_j * 245);
    //rect(xx[j], yy[j], 2, 2);
    //rect(yy[j], xx[j], 2, 2);
    
    float shortest_dst = 99999999;
    int sp = j;
		int spp = j;
    for (int k = 0; k < n; k += 1) {
      if (k != j) {
        float dstx = abs(xx[k] - xx[j]);
        float dsty = abs(yy[k] - yy[j]);
        float mnh_dst = dstx + dsty;
        if (shortest_dst > mnh_dst) {
          shortest_dst = mnh_dst;
					spp = sp;
          sp = k;
        }
      }
    }
    
		stroke(0, 0, anorm_j * 255, 10 + anorm_j * 245);
    line(xx[j], yy[j], xx[sp], yy[sp]);
    line(yy[j], xx[j], yy[sp], xx[sp]);
		
		stroke(0, 0, 0, 245);
    line(width - xx[j], yy[j], width - xx[sp], yy[sp]);
    line(yy[j], width - xx[j], yy[sp], width - xx[sp]);
      
    fill(0, 0, anorm_j * 255, anorm_j * 255);
    triangle(xx[j], yy[j], xx[sp], yy[sp], xx[spp], yy[spp]);
    
    xx[j] += vv[j];
		
    if (xx[j] >= width ||xx[j] < 0 ) {
      vv[j] = -vv[j];
      yy[j] += sign(random(-1, 1)) * 8;
      if (yy[j] >= height || yy[j] < 0) {
        yy[j] = (int)random(0, height);
      }
      
      if (random(1) > 0.5) {
        xx[j] = 0;
      } else {
        xx[j] = width;
      }
    }
    
    for (int k = 0; k < n; k += 1) {
      if (k != j && 
          xx[k] == xx[j] &&
          yy[k] == yy[j]) {
        vv[j] = -vv[j];
        vv[k] = -vv[k];
      }
    }
  }
  
  xmotion += 0.005;
  ymotion += 0.005;
}
"
"668892","Polysions 2","mySketch","float xmotion = 0;
float ymotion = 0;

int PCOUNT = 128;

float[] px = new float[PCOUNT];
float[] py = new float[PCOUNT];
float[] px2 = new float[PCOUNT];
float[] py2 = new float[PCOUNT];
float[] pxv = new float[PCOUNT];
float[] pyv = new float[PCOUNT];
float[] pc = new float[PCOUNT];
float[] plc = new float[PCOUNT];

void setup() {
  size(512, 512);
  
  colorMode(HSB, 360, 255, 255);
  
  background(0);
  noStroke();
  
  strokeWeight(1);

	initPoints();
	
	/*for (float j = 0; j < 300; j += 1) {
		draw();
	}*/
}

void initPoints() {
	for (float j = 0; j < PCOUNT; j += 1) {
		float norm_j = j / PCOUNT;
		float norm_ia = abs(0.5 + norm_j) * 2;
		
		float shape = 0.01;
		
		px[j] = width / 2;
		py[j] = height / 2;
		px2[j] = 0;
		py2[j] = 0;
		pxv[j] = shape + sin(norm_ia * PI * 2) / 64;
		pyv[j] = shape+ cos(norm_ia * PI * 2) / 64;
		pc[j] = random(0, PI);
		plc[j] = 0;
	}
	
	background(0);
}

void draw() {
  noStroke()

  fill(0, 0, 0, 1);
	rect(0, 0, width, height);
	
	stroke(0, 0, 0, 32);
	
  int i = 0; int j = 0;
  for (j = 0; j < PCOUNT; j += 1) {
		//fill(abs(sin(pc[j] + ymotion)) * 64, 128, 55 + abs(sin(pc[j] + xmotion)) * 200, 8);
		/*rect(px[j], py[j], 1, 1);
		rect(width - px[j], py[j], 1, 1);
		rect(px[j], height - py[j], 1, 1);*/
		//fill(abs(sin(pc[j] + ymotion)) * 64, 0, 55 + 200 - (abs(sin(pc[j] + xmotion)) * 200));
		/*rect(px[j], py[j], 1, 1);
		rect(width - px[j], height - py[j], 1, 1);*/
		
		if (j >= 4) {
			for (i = 1; i < 8; i += 2) {
				fill(abs(sin(pc[j] + ymotion)) * 64, 128, 55 + abs(sin(pc[j] + xmotion)) * 200, 48);
				quad(width - px[j], py[j], width - px[j - 1], py[j - 1], width - px[j - 2], py[j - 2], width - px[j - 3], py[j - 3]);
				quad(px[j], height - py[j], px[j - 1], height - py[j - 1], px[j - 2], height - py[j - 2], px[j - 3], height - py[j - 3]);
				fill(128+abs(sin(pc[j] + ymotion)) * 64, 128, 55 + 200 - (abs(sin(pc[j] + xmotion)) * 200), 48);
				quad(px[j], py[j], px[j - 1], py[j - 1], px[j - 2], py[j - 2], px[j - 3], py[j - 3]);
				quad(width - px[j], height - py[j], width - px[j - 1], height - py[j - 1], width - px[j - 2], height - py[j - 2], width - px[j - 3], height - py[j - 3]);
				
				px[j] += pxv[j] * (i * 4);
				py[j] += pyv[j] * (i * 4);
			}
		}
		
		if (px[j] < 0 || px[j] > width) {
			//initPoints();
			pxv[j] = -pxv[j];

			continue;
		}
		
		if (py[j] < 0 || py[j] > height) {
			//initPoints();
			pyv[j] = -pyv[j];

			continue;
		}
/*
		for (i = 0; i < PCOUNT; i += 1) {
			if (i != j) {
				//float norm_i = (float)i / PCOUNT;
				//float dst = norm_i * 4;
				if (px[j] == px[i] && py[j] == py[i]) {
				//if (px[j] <= px[i] + dst && px[j] >= px[i] - dst &&
				//		py[j] <= py[i] + dst && py[j] <= py[i] - dst) {
					pxv[j] = -pxv[j];
					pyv[j] = -pyv[j];

					pxv[i] = -pxv[i];
					pyv[i] = -pyv[i];
				}
			}
		}*/
  }
  
  xmotion += 0.05;
  ymotion += 0.05;
}"
"667431","Polysions","mySketch","float xmotion = 0;
float ymotion = 0;

int PCOUNT = 16;

float[] px = new float[PCOUNT];
float[] py = new float[PCOUNT];
float[] px2 = new float[PCOUNT];
float[] py2 = new float[PCOUNT];
float[] pxv = new float[PCOUNT];
float[] pyv = new float[PCOUNT];
float[] pc = new float[PCOUNT];
float[] plc = new float[PCOUNT];

void setup() {
  size(640, 640);
  
  colorMode(HSB, 360, 255, 255);
  
  background(0);
  noStroke();
  
  strokeWeight(1);

	initPoints();
	
	/*for (float j = 0; j < 300; j += 1) {
		draw();
	}*/
}

void initPoints() {
	for (float j = 0; j < PCOUNT; j += 1) {
		float norm_j = j / PCOUNT;
		float norm_ia = abs(0.5 + norm_j) * 2;
		
		float a = random(1, 4);
		
		px[j] = width / 2;
		py[j] = height / 2;
		px2[j] = 0;
		py2[j] = 0;
		pxv[j] = 0.01 + (norm_j * (1+j%a)) / a;//random(0.01, 1);
		pyv[j] = 0.01 + ((1.-norm_j) * (1+j%a)) / a;//random(0.01, 1);
		pc[j] = random(0, PI);
		plc[j] = 0;
	}
	
	background(0);
}

void draw() {
  noStroke()

  fill(0, 0, 0, 24);
	rect(0, 0, width, height);
	
	//stroke(0, 0, 32); // can be fun
	
  int i = 0; int j = 0;
  for (j = 0; j < PCOUNT; j += 1) {
		//fill(abs(sin(pc[j] + ymotion)) * 64, 128, 55 + abs(sin(pc[j] + xmotion)) * 200, 8);
		/*rect(px[j], py[j], 1, 1);
		rect(width - px[j], py[j], 1, 1);
		rect(px[j], height - py[j], 1, 1);*/
		//fill(abs(sin(pc[j] + ymotion)) * 64, 0, 55 + 200 - (abs(sin(pc[j] + xmotion)) * 200));
		/*rect(px[j], py[j], 1, 1);
		rect(width - px[j], height - py[j], 1, 1);*/
		
		if (j >= 4) {
			fill(abs(sin(pc[j] + ymotion)) * 64, 128, 55 + abs(sin(pc[j] + xmotion)) * 200, 192);
			quad(width - px[j], py[j], width - px[j - 1], py[j - 1], width - px[j - 2], py[j - 2], width - px[j - 3], py[j - 3]);
			quad(px[j], height - py[j], px[j - 1], height - py[j - 1], px[j - 2], height - py[j - 2], px[j - 3], height - py[j - 3]);
			fill(128+abs(sin(pc[j] + ymotion)) * 64, 128, 55 + 200 - (abs(sin(pc[j] + xmotion)) * 200), 192);
			quad(px[j], py[j], px[j - 1], py[j - 1], px[j - 2], py[j - 2], px[j - 3], py[j - 3]);
			quad(width - px[j], height - py[j], width - px[j - 1], height - py[j - 1], width - px[j - 2], height - py[j - 2], width - px[j - 3], height - py[j - 3]);
		}
		
		px[j] += pxv[j];
		py[j] += pyv[j];
		
		if (px[j] < 0 || px[j] > width) {
			initPoints();
			pxv[j] = -pxv[j];

			continue;
		}
		
		if (py[j] < 0 || py[j] > height) {
			initPoints();
			pyv[j] = -pyv[j];

			continue;
		}
/*
		for (i = 0; i < PCOUNT; i += 1) {
			if (i != j) {
				//float norm_i = (float)i / PCOUNT;
				//float dst = norm_i * 4;
				if (px[j] == px[i] && py[j] == py[i]) {
				//if (px[j] <= px[i] + dst && px[j] >= px[i] - dst &&
				//		py[j] <= py[i] + dst && py[j] <= py[i] - dst) {
					pxv[j] = -pxv[j];
					pyv[j] = -pyv[j];

					pxv[i] = -pxv[i];
					pyv[i] = -pyv[i];
				}
			}
		}*/
  }
  
  xmotion += 0.05;
  ymotion += 0.05;
}"
"651274","3D Terrain tunnel 2","mySketch","/**
  * Same as 3D terrain tunnel sketch with flat shading
	* for this to work with quads / lines the heightmap sampling was modified to use polar coordinates
  */

PImage colormap;
PImage heightmap;
PImage water;

float xmotion = 0;
float ymotion = 0;
float rmotion = 0;

int[] pex = new int[dots * 2];
int[] pey = new int[dots * 2];

int elems = 128; // can improve the rendering quality by increasing it and lowering the xrad_step / yrad_step variable
int dots = 92; // improve tunnel quality (to be used with rect_size)

int dots_step = 1;
int elems_step = 1;

void draw_landscape() {
  int rect_size = 4;
  
  // apply motion blur
  //fill(0, 0, 0, 8);
  //rect(0, 0, 800, 600);
	background(0);
  
  noStroke();
  
  // initial circle size
  int bsize = 80;
  
  int xoff = 800 / 2;
  int yoff = 600 / 2;
  
  // the circles stepping
  int xrad_step = 6;
  int yrad_step = 6;
  
  // max motion deform.
  int xdeform = 80;
  int ydeform = 80;
  
  float crepeat = 1; // heightmap / colormap repeat
  int wrepeat = 16; // water texture repeat
  
  // we start by eliminating the blur effect at the end of the tunnel
  fill(0, 0, 0);
  ellipse(xoff + sin(360 * (PI / 180) + xmotion) * xdeform, yoff + cos(360 * (PI / 180) + ymotion) * xdeform, bsize * 1.5, bsize * 1.5);
  
  for (int e = 0; e < elems; e += elems_step) {
    float de = (float)e / elems;
		float de2 = (float)(e + elems_step) / elems;
    
    // fog computation
    float bd = 1.-max(min((0.5-abs(de - 0.5)) * 16, 1), 0.05);
    
    float ex = sin(de * 360 * (PI / 180) + xmotion);
    float ey = cos(de * 360 * (PI / 180) + ymotion);
     
    float xrad = e * xrad_step + bsize + sin(de * 360 * (PI / 180) + xmotion) * 4;
    float yrad = e * yrad_step + bsize + cos(de * 360 * (PI / 180) + xmotion) * 4;
    
    float final_ex = xoff + ex * xdeform;
    
    float xpp = (de * 360 * (PI / 180)) / 2;
		float xpp2 = (de2 * 360 * (PI / 180)) / 2;
    
    // pre-computing textures lookup
    int yyd = (((int)(de * (colormap.height * crepeat)) % colormap.height)) * colormap.width;
    int wyd = (((int)(de * (colormap.height * wrepeat)) % colormap.height)) * colormap.width; 
		
		int j = 0;

    for (int d = 0; d < dots; d += dots_step) {
      float dd = (float)d / dots;
			float dd2 = (float)(d + dots_step) / dots;
      
      float xp = dd * 360 * (PI / 180);
      float yp = dd * 360 * (PI / 180);
			
      float xp2 = dd2 * 360 * (PI / 180);
      float yp2 = dd2 * 360 * (PI / 180);
			
      xp2 += xpp2 + rmotion;
      yp2 += xpp2 + rmotion;
      
      xp += xpp + rmotion;
      yp += xpp + rmotion;
      
      // compute height & apply it
			int hl = ((int)abs(heightmap.height / 2 + (de * heightmap.height + bsize) * cos(yp) * crepeat) % heightmap.height) * heightmap.width;
      float normalized_height = (heightmap.pixels[(((int)abs(heightmap.width / 2 + (de * heightmap.width + bsize) * sin(xp) * crepeat)) % heightmap.width) + hl] >> 16 & 0xFF) / 255.0;
			hl = ((int)abs(heightmap.height / 2 + (de2 * heightmap.height + bsize) * cos(yp2) * crepeat) % heightmap.height) * heightmap.width;
      float normalized_height2 = (heightmap.pixels[(((int)abs(heightmap.width / 2 + (de2 * heightmap.width + bsize) * sin(xp2) * crepeat)) % heightmap.width) + hl] >> 16 & 0xFF) / 255.0;
      
      float h = 1.0 - normalized_height * (1.-de);
			float h2 = 1.0 - normalized_height2 * (1.-de2);
      
      float final_x = final_ex + sin(xp) * xrad * h;
      float final_y = yoff + ey * ydeform + cos(yp) * yrad * h;
			
      float final_x2 = final_ex + sin(xp2) * xrad * h2;
      float final_y2 = yoff + ey * ydeform + cos(yp2) * yrad * h2;
			
      // do not compute outside boundary
      if (final_x >= 1280 || final_x < -400 || final_y >= 1024 | final_y < -400) {
				quad(pex[j], pey[j], final_x, final_y, final_x2, final_y2, pex[j+dots], pey[j+dots]);
				
				j += 1;
				
        continue;
      }
      
      // apply colormap / texture
      int xxd = ((int)(dd * (colormap.width * crepeat)) % colormap.width);

      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]));
      int g = (int)(green(colormap.pixels[cl]));
      int b = (int)(blue(colormap.pixels[cl]));
      
      // water map
      int wxd = ((int)(dd * (colormap.width * wrepeat)) % colormap.width);

      int wcl = (int)wxd + wyd;
      
      int wr = (int)(red(water.pixels[wcl]));
      int wg = (int)(green(water.pixels[wcl]));
      int wb = (int)(blue(water.pixels[wcl]));
      
      float finalr = r, finalg = g , finalb = b;
      float water_level = 0.2;
      if (normalized_height < water_level) {
        float wl = normalized_height * (1.0 / water_level);
        
        finalr = lerp(wr, r, wl);
        finalg = lerp(wg, g, wl);
        finalb = lerp(wb, b, wl);
      }
      
      float snow_level = 0.45;
      if (normalized_height > snow_level) {
        float wl = (normalized_height - snow_level) * (1.0 / snow_level);
        
        finalr = lerp(r, 255, wl);
        finalg = lerp(g, 255, wl);
        finalb = lerp(b, 255, wl);
      }
      
      finalr = lerp((int)finalr, 0, bd);
      finalg = lerp((int)finalg, 0, bd);
      finalb = lerp((int)finalb, 0, bd);
      
      fill(finalr, finalg, finalb);
      
      //rect(final_x, final_y, rect_size, rect_size);
			//stroke(finalr, finalg, finalb);
			//line(pex[j], pey[j], final_x, final_y);
			//line(final_x, final_y, final_x2, final_y2);
			
			quad(pex[j], pey[j], final_x, final_y, final_x2, final_y2, pex[j+dots], pey[j+dots]);
			
			pex[j] = final_x;
			pey[j] = final_y;

			pex[j+dots] = final_x2;
			pey[j+dots] = final_y2;
			
			j += 1;
    }
  }
  
  xmotion += 0.05;
  ymotion += 0.025;
  rmotion += 0;//0.012;
}

void setup() {
  size(800, 600);

  frameRate(60); 
  
  colormap = loadImage(""colormap.jpg"");
  
  water = loadImage(""water.jpg"");
  
  heightmap = loadImage(""heightmap.jpg"");

  background(0);
}

void draw() {
  //ckground(0);
 
  draw_landscape();
}"
"651262","Lineshade","mySketch","float xmotion = 0;
float ymotion = 0;

void setup() {
  size(800, 640);
  
  colorMode(HSB, 360, 255, 255);
  
  background(0);
  noStroke();
  
  strokeWeight(1);
  
  noiseDetail(7, 0.5);
}

float radius = 292;
int lastmx = -1;

void draw() {
  //background(0, 0, 0, 2);
  noStroke();
	
	int mmx = round(mouseX / width * 16);
	
	if (mmx != lastmx) {
		lastmx = mmx;
		background(0);
	}
  
  fill(0, 0, 0, 8);
	rect(0, 0, width, height);
  
  float count = 4 + mmx;
  
  float i = 0; float j = 0;
  
  for (j = 0; j < 1; j += 0.01) {
		float jnorm_j = abs(0.5 - j) * 2;
  for (i = 0; i < count; i += 1) {
    float norm_i = i / count;
    float unit_i = 1 / count;
    
    float inorm_i = abs(0.5 - norm_i) * 2;
    
    float n = noise(inorm_i, jnorm_j) / 32;
    float nn = n * 2;
    
    float cx = radius * sin(norm_i * PI * 2 + j / 4);
    float cy = radius * cos(norm_i * PI * 2 + j / 4);
    
    float cx2 = radius * sin((unit_i + norm_i) * PI * 2) * (radius / 16 - jnorm_j * 16);
    float cy2 = radius * cos((unit_i + norm_i) * PI * 2) * (radius / 16 - jnorm_j * 16);
		
    float x =  width / 2;
    float y = height / 2;
    
    //fill(0, 0, 255, random(0, 2));
    //ellipse(x + cx, y + cy, 24, 24);
		//ellipse(x + cx2 / 32, y + cy2 / 32, 8, 8);
    
    stroke(inorm_i * 360 * 2 % 360, 128, 255, 16);
    //line(x + cx, y + cy, x + cx2, y + cy2);
    //line(x + cx / 2, y + cy / 2, x + cx2 / 2, y + cy2 / 2);
		
    line(x + cx, y + cy, x + cx2 / 32, y + cy2 / 32);
		//line(x + cx / 2, y + cy / 2, x + cx2 / 64, y + cy2 / 64);
    line(width - x + cx, height - y + cy, width - x + cx2, height - y + cy2);
    noStroke();
  }
  }
  
  xmotion += 0.005;
  ymotion += 0.005;
}
"
"649349","Cracked tunnel","mySketch","/**
  * 3D textured / fur tunnel made of rectangles
  */

PImage colormap;

float xmotion = 0;
float ymotion = 0;
float rmotion = 0;

int elems = 120; // can improve the rendering quality by increasing it and lowering the xrad_step / yrad_step variable
int dots = 90; // improve tunnel quality (to be used with rect_size)

int dots_step = 1;
int elems_step = 1;

float []ldmotion = new float[elems * dots];

int[] pex = new int[dots + 1];
int[] pey = new int[dots + 1];

void draw_landscape() {
  float mx = 4. + mouseX / 1024.0 * 8;
  
  int rect_size = (int)mx;
  
  // make it like ""fur"" by applying motion blur
  //fill(0, 0, 0, 24);
  //rect(0, 0, 1024, 700);
	background(0);
  
  noStroke();
	noFill();
  
  // initial circle size
  int bsize = 16;
  
  int xoff = 1024 / 2;
  int yoff = 700 / 2;
  
  int xrad_step = 6;
  int yrad_step = 6;
  
  int xdeform = 100;
  int ydeform = 100;
  
  float xrmotion_size = 16;
  float yrmotion_size = 16;
	
	int j = 0;
	for (int d = 0; d < dots; d += dots_step) {
		pex[j] = -1;
		pey[j] = -1;
		
		j += 1;
	}
  
  for (int e = 0; e < elems; e += elems_step) {
    float de = (float)e / elems;
    
    float bd = de * 4;
    
    float ex = sin(de * 360 * (PI / 180) + xmotion);
    float ey = cos(de * 360 * (PI / 180) + ymotion);
    
    float xrad = e * xrad_step + bsize + sin(de * 360 * (PI / 180) + xmotion) * xrmotion_size;
    float yrad = e * yrad_step + bsize + cos(de * 360 * (PI / 180) + xmotion) * yrmotion_size;
    
    float final_ex = xoff + ex * xdeform;
    
    float xpp = (de * 360 * (PI / 180)) / 2;
  
    float xrepeat = 1; // if you increase this you must add ""%colormap.width"" to xxd below (after ""xrepeat)"") and ""%colormap.height"" to yyd
    int xxd = ((int)(de * (colormap.width * xrepeat)));
		
		int j = 0;
    
    for (int d = 0; d < dots; d += dots_step) {
      float dd = (float)d / dots;
      
      float xp = dd * 360 * (PI / 180);
      float yp = dd * 360 * (PI / 180);
      
      // important phase to improve the rendering, offset the dots per circles so that it ""fill more space"", additionaly mess up the dots gradually
      xp += xpp;// + rmotion * ldmotion[d + e * dots];
      yp += xpp;// + rmotion * ldmotion[d + e * dots];
      
      float final_x = final_ex + sin(xp) * xrad;
      float final_y = yoff + ey * ydeform + cos(yp) * yrad;
      
      // do not compute outside boundary
      if (final_x >= 1040 || final_x < -16 || final_y >= 716 | final_y < -16) {
				line(pex[j], pey[j], final_x, final_y);
				
				pex[j] = final_x;
				pey[j] = final_y;
				
				j += 1;
				
        continue;
      }
      
      // apply colormap / texture
      float yrepeat = 1;
      
      int yyd = (((int)(dd * (colormap.height * yrepeat)))) * colormap.width;
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      fill(r, g, b);
			stroke(r, g, b);
			
			if (pex[j] > 0 && pey[j] > 0) {
				line(pex[j], pey[j], final_x, final_y);
				//quad(pex[j], pey[j], pex[j+1], pey[j], pex[j+1], final_y, final_x, final_y);
			}
			
			if (pex[j] > 0 && pey[j] > 0 || pex[j] == -1 && pey[j] == -1) {
		  	pex[j] = final_x;
				pey[j] = final_y;
			}
      
      rect(final_x, final_y, rect_size, rect_size);
			
			j += 1;
    }
  }
  
  xmotion += 0.05;
  ymotion += 0.025;
  rmotion += 0.012;
}

void setup() {
  size(1024, 700);

  frameRate(60); 
  
  colormap = loadImage(""data.jpg"");
  
  for (int e = 0; e < elems; e += elems_step) {
    for (int d = 0; d < dots; d += dots_step) {
      ldmotion[d + e * dots] = random(0.005);
    }
  }

  background(0);
}

void draw() {
  //background(0);
 
  draw_landscape();
}"
"649349","Cracked tunnel","mySketch","/**
  * 3D textured / fur tunnel made of rectangles
  */

PImage colormap;

float xmotion = 0;
float ymotion = 0;
float rmotion = 0;

int elems = 120; // can improve the rendering quality by increasing it and lowering the xrad_step / yrad_step variable
int dots = 90; // improve tunnel quality (to be used with rect_size)

int dots_step = 1;
int elems_step = 1;

float []ldmotion = new float[elems * dots];

int[] pex = new int[dots + 1];
int[] pey = new int[dots + 1];

void draw_landscape() {
  float mx = 4. + mouseX / 1024.0 * 8;
  
  int rect_size = (int)mx;
  
  // make it like ""fur"" by applying motion blur
  //fill(0, 0, 0, 24);
  //rect(0, 0, 1024, 700);
	background(0);
  
  noStroke();
	noFill();
  
  // initial circle size
  int bsize = 16;
  
  int xoff = 1024 / 2;
  int yoff = 700 / 2;
  
  int xrad_step = 6;
  int yrad_step = 6;
  
  int xdeform = 100;
  int ydeform = 100;
  
  float xrmotion_size = 16;
  float yrmotion_size = 16;
	
	int j = 0;
	for (int d = 0; d < dots; d += dots_step) {
		pex[j] = -1;
		pey[j] = -1;
		
		j += 1;
	}
  
  for (int e = 0; e < elems; e += elems_step) {
    float de = (float)e / elems;
    
    float bd = de * 4;
    
    float ex = sin(de * 360 * (PI / 180) + xmotion);
    float ey = cos(de * 360 * (PI / 180) + ymotion);
    
    float xrad = e * xrad_step + bsize + sin(de * 360 * (PI / 180) + xmotion) * xrmotion_size;
    float yrad = e * yrad_step + bsize + cos(de * 360 * (PI / 180) + xmotion) * yrmotion_size;
    
    float final_ex = xoff + ex * xdeform;
    
    float xpp = (de * 360 * (PI / 180)) / 2;
  
    float xrepeat = 1; // if you increase this you must add ""%colormap.width"" to xxd below (after ""xrepeat)"") and ""%colormap.height"" to yyd
    int xxd = ((int)(de * (colormap.width * xrepeat)));
		
		int j = 0;
    
    for (int d = 0; d < dots; d += dots_step) {
      float dd = (float)d / dots;
      
      float xp = dd * 360 * (PI / 180);
      float yp = dd * 360 * (PI / 180);
      
      // important phase to improve the rendering, offset the dots per circles so that it ""fill more space"", additionaly mess up the dots gradually
      xp += xpp;// + rmotion * ldmotion[d + e * dots];
      yp += xpp;// + rmotion * ldmotion[d + e * dots];
      
      float final_x = final_ex + sin(xp) * xrad;
      float final_y = yoff + ey * ydeform + cos(yp) * yrad;
      
      // do not compute outside boundary
      if (final_x >= 1040 || final_x < -16 || final_y >= 716 | final_y < -16) {
				line(pex[j], pey[j], final_x, final_y);
				
				pex[j] = final_x;
				pey[j] = final_y;
				
				j += 1;
				
        continue;
      }
      
      // apply colormap / texture
      float yrepeat = 1;
      
      int yyd = (((int)(dd * (colormap.height * yrepeat)))) * colormap.width;
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      //fill(r, g, b);
			stroke(r, g, b);
			
			if (pex[j] > 0 && pey[j] > 0) {
				line(pex[j], pey[j], final_x, final_y);
				//quad(pex[j], pey[j], pex[j+1], pey[j], pex[j+1], final_y, final_x, final_y);
			}
			
			if (pex[j] > 0 && pey[j] > 0 || pex[j] == -1 && pey[j] == -1) {
		  	pex[j] = final_x;
				pey[j] = final_y;
			}
      
      rect(final_x, final_y, rect_size, rect_size);
			
			j += 1;
    }
  }
  
  xmotion += 0.05;
  ymotion += 0.025;
  rmotion += 0.012;
}

void setup() {
  size(1024, 700);

  frameRate(60); 
  
  colormap = loadImage(""data.jpg"");
  
  for (int e = 0; e < elems; e += elems_step) {
    for (int d = 0; d < dots; d += dots_step) {
      ldmotion[d + e * dots] = random(0.005);
    }
  }

  background(0);
}

void draw() {
  //background(0);
 
  draw_landscape();
}"
"649349","Cracked tunnel","mySketch","/**
  * 3D textured / fur tunnel made of rectangles
  */

PImage colormap;

float xmotion = 0;
float ymotion = 0;
float rmotion = 0;

int elems = 120; // can improve the rendering quality by increasing it and lowering the xrad_step / yrad_step variable
int dots = 90; // improve tunnel quality (to be used with rect_size)

int dots_step = 1;
int elems_step = 1;

float []ldmotion = new float[elems * dots];

int[] pex = new int[dots + 1];
int[] pey = new int[dots + 1];

void draw_landscape() {
  float mx = 4. + mouseX / 1024.0 * 8;
  
  int rect_size = (int)mx;
  
  // make it like ""fur"" by applying motion blur
  //fill(0, 0, 0, 24);
  //rect(0, 0, 1024, 700);
	background(0);
  
  noStroke();
	noFill();
  
  // initial circle size
  int bsize = 16;
  
  int xoff = 1024 / 2;
  int yoff = 700 / 2;
  
  int xrad_step = 6;
  int yrad_step = 6;
  
  int xdeform = 100;
  int ydeform = 100;
  
  float xrmotion_size = 16;
  float yrmotion_size = 16;
	
	int j = 0;
	for (int d = 0; d < dots; d += dots_step) {
		pex[j] = -1;
		pey[j] = -1;
		
		j += 1;
	}
  
  for (int e = 0; e < elems; e += elems_step) {
    float de = (float)e / elems;
    
    float bd = de * 4;
    
    float ex = sin(de * 360 * (PI / 180) + xmotion);
    float ey = cos(de * 360 * (PI / 180) + ymotion);
    
    float xrad = e * xrad_step + bsize + sin(de * 360 * (PI / 180) + xmotion) * xrmotion_size;
    float yrad = e * yrad_step + bsize + cos(de * 360 * (PI / 180) + xmotion) * yrmotion_size;
    
    float final_ex = xoff + ex * xdeform;
    
    float xpp = (de * 360 * (PI / 180)) / 2;
  
    float xrepeat = 1; // if you increase this you must add ""%colormap.width"" to xxd below (after ""xrepeat)"") and ""%colormap.height"" to yyd
    int xxd = ((int)(de * (colormap.width * xrepeat)));
		
		int j = 0;
    
    for (int d = 0; d < dots; d += dots_step) {
      float dd = (float)d / dots;
      
      float xp = dd * 360 * (PI / 180);
      float yp = dd * 360 * (PI / 180);
      
      // important phase to improve the rendering, offset the dots per circles so that it ""fill more space"", additionaly mess up the dots gradually
      xp += xpp;// + rmotion * ldmotion[d + e * dots];
      yp += xpp;// + rmotion * ldmotion[d + e * dots];
      
      float final_x = final_ex + sin(xp) * xrad;
      float final_y = yoff + ey * ydeform + cos(yp) * yrad;
      
      // do not compute outside boundary
      if (final_x >= 1040 || final_x < -16 || final_y >= 716 | final_y < -16) {
				line(pex[j], pey[j], final_x, final_y);
				
				pex[j] = final_x;
				pey[j] = final_y;
				
				j += 1;
				
        continue;
      }
      
      // apply colormap / texture
      float yrepeat = 1;
      
      int yyd = (((int)(dd * (colormap.height * yrepeat)))) * colormap.width;
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      //fill(r, g, b);
			stroke(r, g, b);
			
			if (pex[j] > 0 && pey[j] > 0) {
				line(pex[j], pey[j], final_x, final_y);
				//quad(pex[j], pey[j], pex[j+1], pey[j], pex[j+1], final_y, final_x, final_y);
			}
			
			if (pex[j] > 0 && pey[j] > 0 || pex[j] == -1 && pey[j] == -1) {
		  	pex[j] = final_x;
				pey[j] = final_y;
			}
      
      //rect(final_x, final_y, rect_size, rect_size);
			
			j += 1;
    }
  }
  
  xmotion += 0.05;
  ymotion += 0.025;
  rmotion += 0.012;
}

void setup() {
  size(1024, 700);

  frameRate(60); 
  
  colormap = loadImage(""data.jpg"");
  
  for (int e = 0; e < elems; e += elems_step) {
    for (int d = 0; d < dots; d += dots_step) {
      ldmotion[d + e * dots] = random(0.005);
    }
  }

  background(0);
}

void draw() {
  //background(0);
 
  draw_landscape();
}"
"649349","Cracked tunnel","mySketch","/**
  * 3D textured / fur tunnel made of rectangles
  */

PImage colormap;

float xmotion = 0;
float ymotion = 0;
float rmotion = 0;

int elems = 120; // can improve the rendering quality by increasing it and lowering the xrad_step / yrad_step variable
int dots = 90; // improve tunnel quality (to be used with rect_size)

int dots_step = 1;
int elems_step = 1;

float []ldmotion = new float[elems * dots];

int[] pex = new int[dots * 2];
int[] pey = new int[dots * 2];

void draw_landscape() {
  float mx = 4. + mouseX / 1024.0 * 8;
  
  int rect_size = (int)mx;
  
  // make it like ""fur"" by applying motion blur
  //fill(0, 0, 0, 24);
  //rect(0, 0, 1024, 700);
	background(0);
  
  noStroke();
	noFill();
  
  // initial circle size
  int bsize = 16;
  
  int xoff = 1024 / 2;
  int yoff = 700 / 2;
  
  int xrad_step = 6;
  int yrad_step = 6;
  
  int xdeform = 100;
  int ydeform = 100;
  
  float xrmotion_size = 16;
  float yrmotion_size = 16;
	
	int j = 0;
	for (int d = 0; d < dots*2; d += dots_step) {
		pex[j] = -1;
		pey[j] = -1;
		
		j += 1;
	}

  for (int e = 0; e < elems; e += elems_step) {
    float de = (float)e / elems;
    
    float bd = de * 4;
    
    float ex = sin(de * 360 * (PI / 180) + xmotion);
    float ey = cos(de * 360 * (PI / 180) + ymotion);
    
    float xrad = e * xrad_step + bsize + sin(de * 360 * (PI / 180) + xmotion) * xrmotion_size;
    float yrad = e * yrad_step + bsize + cos(de * 360 * (PI / 180) + xmotion) * yrmotion_size;
    
    float final_ex = xoff + ex * xdeform;
    
    float xrepeat = 1; // if you increase this you must add ""%colormap.width"" to xxd below (after ""xrepeat)"") and ""%colormap.height"" to yyd
    int xxd = ((int)(de * (colormap.width * xrepeat)));
		
		int j = 0;
    
    for (int d = 0; d < dots; d += dots_step) {
      float dd = (float)d / dots;
			float dd2 = (float)(d + dots_step) / dots;
      
      float xp = dd * 360 * (PI / 180);
      float yp = dd * 360 * (PI / 180);
			
      float xp2 = dd2 * 360 * (PI / 180);
      float yp2 = dd2 * 360 * (PI / 180);
      
      float final_x = final_ex + sin(xp) * xrad;
      float final_y = yoff + ey * ydeform + cos(yp) * yrad;
			
      float final_x2 = final_ex + sin(xp2) * xrad;
      float final_y2 = yoff + ey * ydeform + cos(yp2) * yrad;
      
      // do not compute outside boundary
      if (final_x >= 1080 || final_x < -64 || final_y >= 764 | final_y < -64) {
				//line(pex[j], pey[j], final_x, final_y);
				//line(final_x, final_y, final_x2, final_y2);
				
				pex[j] = final_x;
				pey[j] = final_y;
				
				pex[j+dots] = final_x2;
				pey[j+dots] = final_y2;
				
				quad(pex[j], pey[j], final_x, final_y, final_x2, final_y2, pex[j+dots], pey[j+dots]);
				
				j += 1;
				
        continue;
      }
      
      // apply colormap / texture
      float yrepeat = 1;
      
      int yyd = (((int)(dd * (colormap.height * yrepeat)))) * colormap.width;
 
      int cl = (int)xxd + yyd;
      
      int r = 360.0 * dd;//(int)(red(colormap.pixels[cl]) * bd);
      int g = 128;//(int)(green(colormap.pixels[cl]) * bd);
      int b = 128.0 * de + (int)(blue(colormap.pixels[cl]) * bd)/2;
      
      fill(r, g, b);
			//stroke(r, 32, b);
			
			//if (pex[j] > 0 && pey[j] > 0) {
				//line(pex[j], pey[j], final_x, final_y);
				//line(final_x, final_y, final_x2, final_y2);
				//line()
				quad(pex[j], pey[j], final_x, final_y, final_x2, final_y2, pex[j+dots], pey[j+dots]);
			//}
			
			pex[j] = final_x;
			pey[j] = final_y;

			pex[j+dots] = final_x2;
			pey[j+dots] = final_y2;
      
      //rect(final_x, final_y, rect_size, rect_size);
			
			j += 1;
    }
  }
  
  xmotion += 0.05;
  ymotion += 0.025;
  rmotion += 0.012;
}

void setup() {
  size(1024, 700);

  frameRate(60); 
  
  colormap = loadImage(""data.jpg"");
  
  for (int e = 0; e < elems; e += elems_step) {
    for (int d = 0; d < dots; d += dots_step) {
      ldmotion[d + e * dots] = random(0.005);
    }
  }
	
	colorMode(HSB, 320, 256, 256);

  background(0);
}

void draw() {
  //background(0);
 
  draw_landscape();
}"
"649349","Cracked tunnel","mySketch","/**
  * Cracked tunnel, same sketch as dots tunnel but with polygons!
  */

float xmotion = 0;
float ymotion = 0;
float rmotion = 0;

int elems = 160;
int dots = 90;

// subdivision controls
int dots_step = 12;
int elems_step = 2;

float []ldmotion = new float[elems * dots * 2];

int[] pex = new int[dots * 2];
int[] pey = new int[dots * 2];

void draw_landscape() {
  //fill(0, 0, 0, 24);
  //rect(0, 0, 1024, 700);
	background(0);
  
  noStroke();
	noFill();
  
  // initial circle size
  int bsize = 64;
  
  int xoff = 1024 / 2;
  int yoff = 700 / 2;
  
  int xrad_step = 5;
  int yrad_step = 5;
  
  int xdeform = 190;
  int ydeform = 190;
  
  float xrmotion_size = 24;
  float yrmotion_size = 24;

  for (int e = 0; e < elems; e += elems_step) {
    float de = (float)e / elems;
    
    float bd = de * 4;
    
    float ex = sin(de * 360 * (PI / 180) + xmotion);
    float ey = cos(de * 360 * (PI / 180) + ymotion);
    
    float xrad = e * xrad_step + bsize + sin(de * 360 * (PI / 180) + xmotion) * xrmotion_size;
    float yrad = e * yrad_step + bsize + cos(de * 360 * (PI / 180) + xmotion) * yrmotion_size;
    
    float final_ex = xoff + ex * xdeform;
		
		float xpp = (de * 360 * (PI / 180)) / 2;
		
		int j = 0;
    
    for (int d = 0; d < dots; d += dots_step) {
      float dd = (float)d / dots;
			float dd2 = (float)(d + dots_step) / dots;
      
      float xp = dd * 360 * (PI / 180);
      float yp = dd * 360 * (PI / 180);
			
      xp += xpp + rmotion * ldmotion[d + e * dots];
      yp += xpp + rmotion * ldmotion[d + e * dots];
			
      float xp2 = dd2 * 360 * (PI / 180);
      float yp2 = dd2 * 360 * (PI / 180);
			
      xp2 += xpp + rmotion * ldmotion[(d + e * dots)*2];
      yp2 += xpp + rmotion * ldmotion[(d + e * dots)*2];
      
      float final_x = final_ex + sin(xp) * xrad;
      float final_y = yoff + ey * ydeform + cos(yp) * yrad;
			
      float final_x2 = final_ex + sin(xp2) * xrad;
      float final_y2 = yoff + ey * ydeform + cos(yp2) * yrad;
      
      // clip roughly outside screen boundary
      if (final_x >= 1280 || final_x < -400 || final_y >= 1024 | final_y < -400) {
				//line(pex[j], pey[j], final_x, final_y);
				//line(final_x, final_y, final_x2, final_y2);
				
				quad(pex[j], pey[j], final_x, final_y, final_x2, final_y2, pex[j+dots], pey[j+dots]);
				
				j += 1;
				
        continue;
      }
      
      int r = (int)(128 + (cos(de * PI * 2 / 2 - rmotion) * 92));
      int g = 128;
      int b = 128.0 * pow(de * 6,2);
      
      fill(r, g, b);
			//stroke(r, 128, b*2);

			quad(pex[j], pey[j], final_x, final_y, final_x2, final_y2, pex[j+dots], pey[j+dots]);
			
			pex[j] = final_x;
			pey[j] = final_y;

			pex[j+dots] = final_x2;
			pey[j+dots] = final_y2;
      
      //rect(final_x, final_y, 8, 8);
			
			j += 1;
    }
  }
  
  xmotion += 0.05;
  ymotion += 0.025;
  rmotion += 0.022;
}

void setup() {
  size(1024, 700);

  frameRate(60); 

  for (int e = 0; e < elems; e += elems_step) {
    for (int d = 0; d < dots; d += dots_step) {
      ldmotion[d + e * dots] = random(0.01);
			ldmotion[(d + e * dots)*2] = random(0.02);
    }
  }
	
	colorMode(HSB, 320, 256, 256);

  background(0);
}

void draw() {
  //background(0);
 
  draw_landscape();
}"
"649349","Cracked tunnel","mySketch","/**
  * Cracked tunnel, same sketch as dots tunnel but with polygons!
  */

float xmotion = 0;
float ymotion = 0;
float rmotion = 0;

int elems = 160;
int dots = 90;

// subdivision controls
int dots_step = 4;
int elems_step = 2;

float []ldmotion = new float[elems * dots * 2];

int[] pex = new int[dots * 2];
int[] pey = new int[dots * 2];

void draw_landscape() {
  //fill(0, 0, 0, 24);
  //rect(0, 0, 1024, 700);
	background(0);
  
  noStroke();
	noFill();
  
  // initial circle size
  int bsize = 0;
  
  int xoff = width / 2;
  int yoff = height / 2;
  
  int xrad_step = 5;
  int yrad_step = 5;
  
  int xdeform = width / 4;
  int ydeform = width / 4;
  
  float xrmotion_size = 24;
  float yrmotion_size = 24;

  for (int e = 0; e < elems; e += elems_step) {
    float de = (float)e / elems;
    
    float bd = de * 4;
    
    float ex = sin(de * 360 * (PI / 180) + xmotion);
    float ey = cos(de * 360 * (PI / 180) + ymotion);
    
    float xrad = e * xrad_step + bsize + sin(de * 360 * (PI / 180) + xmotion) * xrmotion_size;
    float yrad = e * yrad_step + bsize + cos(de * 360 * (PI / 180) + xmotion) * yrmotion_size;
    
    float final_ex = xoff + ex * xdeform;
		
		float xpp = (de * 360 * (PI / 180)) / 2;
		
		int j = 0;
    
    for (int d = 0; d < dots; d += dots_step) {
      float dd = (float)d / dots;
			float dd2 = (float)(d + dots_step) / dots;
      
      float xp = dd * 360 * (PI / 180);
      float yp = dd * 360 * (PI / 180);
			
      xp += xpp + rmotion * ldmotion[d + e * dots];
      yp += xpp + rmotion * ldmotion[d + e * dots];
			
      float xp2 = dd2 * 360 * (PI / 180);
      float yp2 = dd2 * 360 * (PI / 180);
			
      xp2 += xpp + rmotion * ldmotion[(d + e * dots)*2];
      yp2 += xpp + rmotion * ldmotion[(d + e * dots)*2];
      
      float final_x = final_ex + sin(xp) * xrad;
      float final_y = yoff + ey * ydeform + cos(yp) * yrad;
			
      float final_x2 = final_ex + sin(xp2) * xrad;
      float final_y2 = yoff + ey * ydeform + cos(yp2) * yrad;
      
      // clip roughly outside screen boundary
      if (final_x >= 1280 || final_x < -400 || final_y >= 1024 | final_y < -400) {
				//line(pex[j], pey[j], final_x, final_y);
				//line(final_x, final_y, final_x2, final_y2);
				
				quad(pex[j], pey[j], final_x, final_y, final_x2, final_y2, pex[j+dots], pey[j+dots]);
				
				j += 1;
				
        continue;
      }
      
      int r = (int)(128 + (cos(de * PI * 2 / 2 - rmotion) * 92));
      int g = 128;
      int b = 128.0 * pow(de * 6,2);
      
      fill(r, g, b);
			//stroke(r, 128, b*2);

			quad(pex[j], pey[j], final_x, final_y, final_x2, final_y2, pex[j+dots], pey[j+dots]);
			
			pex[j] = final_x;
			pey[j] = final_y;

			pex[j+dots] = final_x2;
			pey[j+dots] = final_y2;
      
      //rect(final_x, final_y, 8, 8);
			
			j += 1;
    }
  }
  
  xmotion += 0.05;
  ymotion += 0.025;
  rmotion += 0.022;
}

void setup() {
  size(600, 600);

  frameRate(60); 

  for (int e = 0; e < elems; e += elems_step) {
    for (int d = 0; d < dots; d += dots_step) {
      ldmotion[d + e * dots] = random(0.01);
			ldmotion[(d + e * dots)*2] = random(0.02);
    }
  }
	
	colorMode(HSB, 320, 256, 256);
	/* // shadow add depth
				externals.context.shadowOffsetX = random(-1, 1);
        externals.context.shadowOffsetY = random(-1, 1);
        externals.context.shadowBlur = 8;
        externals.context.shadowColor = ""black"";
	*/
  background(0);
}

void draw() {
  //background(0);
 
  draw_landscape();
}"
"649334","REYES rasterization","mySketch","/**
  * A tentative to do a 3D renderer using REYES like algorithms (a type of rendering invented / developed by Lucasfilm / Pixar in the mid-80s and still used to late 2000s)
	* Actually REYES is more like a collection of classical computer graphics algorithms packed into a single solution with a well defined pipeline process.
	*
	* REYES algorithm is simple and powerful, it is like rasterization and state of art algorithms like raytracing / pathtracing
	* in term of power and it have some speed advantages over that last one but it is most importantly very flexible and parallelization friendly.
	* 
	* So how does it work ? It is pretty similar to a standard rasterizer and work mainly with polygons but... with a process of massive surfaces subdivision (preferably adaptive)
	* which produce ""micropolygons"", polygons that are the size of a pixel or so and which allow easy / fast shading computations.
	* Surfaces points can easily be displaced while maintaining high quality output. Effects such as depth of field or motion blur can be done efficiently.
	*
	* https://en.wikipedia.org/wiki/Reyes_rendering
	* 
	* How it was made :
	*  - first we want to define a geometric object (a cube) programmatically, i chose to do it as a parametric surface by simply stepping
	*    in normalized space through points for X,Y,Z then converting to screen space and centering the object. Doing it by stepping on the surface
	*    allow us to control as wanted the stepping factor (which will be our subdivision factor for our polygons)
	*  - since we also stepped through Z we are already rendering a kind of volumetric cube data (which is cool because you could even do volumetric effects later on !)
	*  - since we are only interested by the cube surface, we filter the volumetric data and retain the points on the surface
	*  - we do projection + rotation of our object at the same time with simple matrix / vector operation
	*  - once we have the object points rendered we can do a simple shading that will give us some depth by computing
  *    the length then normalizing the point position vector and assigning the Z value scaled by the max. RGB value to the point color
	*  - at this point we have several ways to render our object :
	*   - by simply rendering the dots
	*   - by detecting the surfaces of the cube we are on (by looking to points position), computing next value for X/Y or X/Z or Y/Z
	*     using those values to draw lines to form two triangles (a quad), this is wireframe mode, we can also compute points value in different order for different wireframe mode
	*   - same step as above but then fill the triangles with barycentric algorithm (find bounding box of triangle, step through X/Y and check wether we are in or out)
	*     we will have flat shading but... it also pave the road to the easy application of more complex shading algorithms or texturing!! an important step is also to
	*     check shaded point distance against a Z buffer to remove hidden surfaces
	*/

int frame = 0;

float[] displaceX;
float[] displaceY;
float[] displaceZ;

static float cs = 580;
static float inc = 0.1;//1.0 / (cs / 128.0);
static float csi = 1.0 / inc;
static float scale = 1.0 / 8.0;

PGraphics depthbuffer;

void setup() {
  size(1024, 768);

  background(0);
	
	noStroke();
	
	randomSeed(0);
	
	displaceX = new float[(int)csi];
	displaceY = new float[(int)csi];
	displaceZ = new float[(int)csi];
	
	for (int i = 0; i <= (int)csi; i += 1) {
		displaceX[i] = random(-1, 1) / 64;
		displaceY[i] = random(-1, 1) / 64;
		displaceZ[i] = random(-1, 1) / 64;
	}
	
	depthbuffer = createGraphics(width, height);
	depthbuffer.noStroke();
}

void draw() {
	// clear z-buffer
	depthbuffer.beginDraw();
	depthbuffer.background(0);
	depthbuffer.endDraw();
	
  background(0);
	//fill(0, 0, 0, 48);
	//rect(0, 0, width, height);
	
	float rxa = 0.03 * frame;
	float rya = 0.04 * frame;

	// rotation values
	float crx = cos(rxa);
	float cry = cos(rya);
	float srx = sin(rxa);
	float sry = sin(rya);
	
	// rm = rotation matrix
	float[] rm = {0,0,0,0,0,0,0,0,0};

	rm[0] = cry;     /*rm[1] = 0.0f;*/ rm[2] = -sry;
	rm[3] = sry * srx; rm[4] = crx;    rm[5] = cry * srx;
	rm[6] = sry * crx; rm[7] = -srx;   rm[8] = cry * crx;
	
	int x2 = width / 2;
	int y2 = height / 2;
	
	float x, y, z;
	
	for (z = 0.0; z <= 1.0; z += inc) {
		float[] vr = {0,0,0};

		float pz = 2.0 * z - 1.0;

		vr[2] = pz * scale;
		for (y = 0.0; y <= 1.0; y += inc) {
			float py = 2.0 * y - 1.0;

			vr[1] = py * scale;
			for (x = 0.0; x <= 1.0; x += inc) {
				// filter volumetric data (eg. we only want the points on the surface)
				if (x > 0.0 && x < (1.0 - inc) && y > 0.0 && y < (1.0 - inc) && z > 0.0 && z < (1.0 - inc)) continue;
				
				float px = (2.0 * x - 1.0);
				
				vr[0] = px * scale;

				// rotate our points
				float[] vrr = {
						rm[0] * vr[0] + rm[3] * vr[1] + rm[6] * vr[2],
						rm[1] * vr[0] + rm[4] * vr[1] + rm[7] * vr[2],
						rm[2] * vr[0] + rm[5] * vr[1] + rm[8] * vr[2]
				};
			
				// compute length & normalize
				float le = sqrt((vrr[0] * vrr[0]) + (vrr[1] * vrr[1]) + (vrr[2] * vrr[2]));
			  float[] vrn = { vrr[0] / le, vrr[1] / le, vrr[2] / le };

				// point shade based on normalized Z value
			  int shading = vrn[2] * 255;
				//fill(shading, shading, shading);

				// since we were in normalized space we scale it to screen space and translate it at the center of the screen
				float posx = x2 - (int)(vrr[0] * cs);
				float posy = y2 - (int)(vrr[1] * cs);
		
				// draw cube surface by computing the quad given from 4 points on the surface
				float px2 = (2.0 * (x + inc) - 1.0);
				float pxs = px2 * scale;
				float py2 = (2.0 * (y + inc) - 1.0);
				float pys = py2 * scale;
				float pz2 = (2.0 * (z + inc) - 1.0);
				float pzs = pz2 * scale;
		
				float posx2; float posy2;
				float posx3; float posy3;
				float posx4; float posy4;
		
				if (y >= 0.0 && y <= (1.0 - inc) &&
						z >= 0.0 && z <= (1.0 - inc) &&
					  (x >= 0.99 || x <= 0.0)) {
					float[] vrr2 = {
							rm[0] * vr[0] + rm[3] * vr[1] + rm[6] * pzs,
							rm[1] * vr[0] + rm[4] * vr[1] + rm[7] * pzs,
							rm[2] * vr[0] + rm[5] * vr[1] + rm[8] * pzs
					};
		
					float[] vrr3 = {
							rm[0] * vr[0] + rm[3] * pys + rm[6] * pzs,
							rm[1] * vr[0] + rm[4] * pys + rm[7] * pzs,
							rm[2] * vr[0] + rm[5] * pys + rm[8] * pzs
					};
	
					float[] vrr4 = {
							rm[0] * vr[0] + rm[3] * pys + rm[6] * vr[2],
							rm[1] * vr[0] + rm[4] * pys + rm[7] * vr[2],
							rm[2] * vr[0] + rm[5] * pys + rm[8] * vr[2]
					};
		
					posx2 = x2 - (int)(vrr2[0] * cs);
					posy2 = y2 - (int)(vrr2[1] * cs);
					posx3 = x2 - (int)(vrr3[0] * cs);
					posy3 = y2 - (int)(vrr3[1] * cs);
					posx4 = x2 - (int)(vrr4[0] * cs);
					posy4 = y2 - (int)(vrr4[1] * cs);

					stroke(shading, shading, shading);
					line(posx, posy, posx2, posy2);
					line(posx2, posy2, posx3, posy3);
					line(posx3, posy3, posx, posy);

					stroke(shading, 0, 0);
					line(posx, posy, posx4, posy4);
					line(posx4, posy4, posx3, posy3);
					line(posx3, posy3, posx, posy);
				}
				
				if (x >= 0.0 && x <= (1.0 - inc) &&
									 y >= 0.0 && y <= (1.0 - inc) &&
									 (z >= 0.99 || z <= 0.0)) {
					float[] vrr2 = {
							rm[0] * pxs + rm[3] * vr[1] + rm[6] * vr[2],
							rm[1] * pxs + rm[4] * vr[1] + rm[7] * vr[2],
							rm[2] * pxs + rm[5] * vr[1] + rm[8] * vr[2]
					};
		
					float[] vrr3 = {
							rm[0] * pxs + rm[3] * pys + rm[6] * vr[2],
							rm[1] * pxs + rm[4] * pys + rm[7] * vr[2],
							rm[2] * pxs + rm[5] * pys + rm[8] * vr[2]
					};
	
					float[] vrr4 = {
							rm[0] * vr[0] + rm[3] * pys + rm[6] * vr[2],
							rm[1] * vr[0] + rm[4] * pys + rm[7] * vr[2],
							rm[2] * vr[0] + rm[5] * pys + rm[8] * vr[2]
					};
		
					posx2 = x2 - (int)(vrr2[0] * cs);
					posy2 = y2 - (int)(vrr2[1] * cs);
					posx3 = x2 - (int)(vrr3[0] * cs);
					posy3 = y2 - (int)(vrr3[1] * cs);
					posx4 = x2 - (int)(vrr4[0] * cs);
					posy4 = y2 - (int)(vrr4[1] * cs);

					stroke(shading, shading, shading);
					line(posx, posy, posx2, posy2);
					line(posx2, posy2, posx3, posy3);
					line(posx3, posy3, posx, posy);

					stroke(shading, 0, 0);
					line(posx, posy, posx4, posy4);
					line(posx4, posy4, posx3, posy3);
					line(posx3, posy3, posx, posy);
				}
				
				if (x >= 0.0 && x <= (1.0 - inc) &&
									 z >= 0.0 && z <= (1.0 - inc) &&
									 (y >= 0.99 || y <= 0.0)) {
					float[] vrr2 = {
							rm[0] * pxs + rm[3] * vr[1] + rm[6] * vr[2],
							rm[1] * pxs + rm[4] * vr[1] + rm[7] * vr[2],
							rm[2] * pxs + rm[5] * vr[1] + rm[8] * vr[2]
					};
		
					float[] vrr3 = {
							rm[0] * pxs + rm[3] * vr[1] + rm[6] * pzs,
							rm[1] * pxs + rm[4] * vr[1] + rm[7] * pzs,
							rm[2] * pxs + rm[5] * vr[1] + rm[8] * pzs
					};
	
					float[] vrr4 = {
							rm[0] * vr[0] + rm[3] * vr[1] + rm[6] * pzs,
							rm[1] * vr[0] + rm[4] * vr[1] + rm[7] * pzs,
							rm[2] * vr[0] + rm[5] * vr[1] + rm[8] * pzs
					};
		
					posx2 = x2 - (int)(vrr2[0] * cs);
					posy2 = y2 - (int)(vrr2[1] * cs);
					posx3 = x2 - (int)(vrr3[0] * cs);
					posy3 = y2 - (int)(vrr3[1] * cs);
					posx4 = x2 - (int)(vrr4[0] * cs);
					posy4 = y2 - (int)(vrr4[1] * cs);

					stroke(shading, shading, shading);
					line(posx, posy, posx2, posy2);
					line(posx2, posy2, posx3, posy3);
					line(posx3, posy3, posx, posy);

					stroke(shading, 0, 0);
					line(posx, posy, posx4, posy4);
					line(posx4, posy4, posx3, posy3);
					line(posx3, posy3, posx, posy);
				}

				if (shading >= brightness(depthbuffer.get(posx,posy))) {
					// depth value go into depth buffer
					depthbuffer.beginDraw();
					depthbuffer.fill(shading, shading, shading);
					depthbuffer.quad(posx, posy, posx2, posy2, posx3, posy3, posx4, posy4);
					depthbuffer.endDraw();
					
					//quad(posx, posy, posx2, posy2, posx3, posy3, posx4, posy4);
				}
				
				// no z-buffer
				//quad(posx, posy, posx2, posy2, posx3, posy3, posx4, posy4);

				// points only
				//fill(255, 0, 0);
				//ellipse(posx, posy, 2, 2);
			}
		}
	}
	
	//image(depthbuffer, 0, 0);

	frame += 1;
}"
"649334","REYES rasterization","mySketch","/**
  * A tentative to do a 3D renderer using REYES like algorithms (a type of rendering invented / developed by Lucasfilm / Pixar in the mid-80s and still used to late 2000s)
	* Actually REYES is more like a collection of classical computer graphics algorithms packed into a single solution with a well defined pipeline process.
	*
	* REYES algorithm is simple and powerful, it is like rasterization and state of art algorithms like raytracing / pathtracing
	* in term of power and it have some speed advantages over that last one but it is most importantly very flexible and parallelization friendly.
	* 
	* So how does it work ? It is pretty similar to a standard rasterizer and work mainly with polygons but... with a process of massive surfaces subdivision (preferably adaptive)
	* which produce ""micropolygons"", polygons that are the size of a pixel or so and which allow easy / fast shading computations.
	* Surfaces points can easily be displaced while maintaining high quality output. Effects such as depth of field or motion blur can be done efficiently.
	*
	* https://en.wikipedia.org/wiki/Reyes_rendering
	* 
	* How it was made :
	*  - first we want to define a geometric object (a cube) programmatically, i chose to do it as a parametric surface by simply stepping
	*    in normalized space through points for X,Y,Z then converting to screen space and centering the object. Doing it by stepping on the surface
	*    allow us to control as wanted the stepping factor (which will be our subdivision factor for our polygons)
	*  - since we also stepped through Z we are already rendering a kind of volumetric cube data (which is cool because you could even do volumetric effects later on !)
	*  - since we are only interested by the cube surface, we filter the volumetric data and retain the points on the surface
	*  - we do projection + rotation of our object at the same time with simple matrix / vector operation
	*  - once we have the object points rendered we can do a simple shading that will give us some depth by computing
  *    the length then normalizing the point position vector and assigning the Z value scaled by the max. RGB value to the point color
	*  - at this point we have several ways to render our object :
	*   - by simply rendering the dots
	*   - by detecting the surfaces of the cube we are on (by looking to points position), computing next value for X/Y or X/Z or Y/Z
	*     using those values to draw lines to form two triangles (a quad), this is wireframe mode, we can also compute points value in different order for different wireframe mode
	*   - same step as above but then fill the triangles with barycentric algorithm (find bounding box of triangle, step through X/Y and check wether we are in or out)
	*     we will have flat shading but... it also pave the road to the easy application of more complex shading algorithms or texturing!! an important step is also to
	*     check shaded point distance against a Z buffer to remove hidden surfaces
	*/

int frame = 0;

float[] displaceX;
float[] displaceY;
float[] displaceZ;

static float cs = 580;
static float inc = 0.1;//1.0 / (cs / 128.0);
static float csi = 1.0 / inc;
static float scale = 1.0 / 8.0;

PGraphics depthbuffer;

void setup() {
  size(1024, 768);

  background(0);
	
	noStroke();
	
	randomSeed(0);
	
	displaceX = new float[(int)csi];
	displaceY = new float[(int)csi];
	displaceZ = new float[(int)csi];
	
	for (int i = 0; i <= (int)csi; i += 1) {
		displaceX[i] = random(-1, 1) / 64;
		displaceY[i] = random(-1, 1) / 64;
		displaceZ[i] = random(-1, 1) / 64;
	}
	
	depthbuffer = createGraphics(width, height);
	depthbuffer.noStroke();
}

void fillTriangle(float x1, float y1,
									float x2, float y2,
									float x3, float y3, int shading) {
	int maxX = max(x1, max(x2, x3));
	int minX = min(x1, min(x2, x3));
	int maxY = max(y1, max(y2, y3));
	int minY = min(y1, min(y2, y3));
	
	float vs1x = x2 - x1;
	float vs1y = y2 - y1;
	float vs2x = x3 - x1;
	float vs2y = y3 - y1;

	for (float x = minX; x <= maxX; x += 4) {
  	for (float y = minY; y <= maxY; y += 4) {
			float qx = x - x1;
			float qy = y - y1;
			
			float s = (qx * vs2y - vs2x * qy) / (vs1x * vs2y - vs2x * vs1y);
			float t = (vs1x * qy - qx * vs1y) / (vs1x * vs2y - vs2x * vs1y);

			if ( (s >= 0) && (t >= 0) && (s + t <= 1)) {
				// check against Z buffer!
				if (shading >= brightness(depthbuffer.get(x, y))) {
					// depth value go into depth buffer
					depthbuffer.beginDraw();
					depthbuffer.fill(shading, shading, shading);
					depthbuffer.rect(x, y, 4, 4);
					depthbuffer.endDraw();
					
					rect(x, y, 4, 4);
				}
			}
		}
	}
}

void draw() {
	// clear z-buffer
	depthbuffer.beginDraw();
	depthbuffer.background(0);
	depthbuffer.endDraw();
	
  background(0);
	//fill(0, 0, 0, 48);
	//rect(0, 0, width, height);
	
	float rxa = 0.03 * frame;
	float rya = 0.04 * frame;

	// rotation values
	float crx = cos(rxa);
	float cry = cos(rya);
	float srx = sin(rxa);
	float sry = sin(rya);
	
	// rm = rotation matrix
	float[] rm = {0,0,0,0,0,0,0,0,0};

	rm[0] = cry;     /*rm[1] = 0.0f;*/ rm[2] = -sry;
	rm[3] = sry * srx; rm[4] = crx;    rm[5] = cry * srx;
	rm[6] = sry * crx; rm[7] = -srx;   rm[8] = cry * crx;
	
	int x2 = width / 2;
	int y2 = height / 2;
	
	float x, y, z;
	
	for (z = 0.0; z <= 1.0; z += inc) {
		float[] vr = {0,0,0};

		float pz = 2.0 * z - 1.0;

		vr[2] = pz * scale;
		for (y = 0.0; y <= 1.0; y += inc) {
			float py = 2.0 * y - 1.0;

			vr[1] = py * scale;
			for (x = 0.0; x <= 1.0; x += inc) {
				// filter volumetric data (eg. we only want the points on the surface)
				if (x > 0.0 && x < (1.0 - inc) && y > 0.0 && y < (1.0 - inc) && z > 0.0 && z < (1.0 - inc)) continue;
				
				float px = (2.0 * x - 1.0);
				
				vr[0] = px * scale;

				// rotate our points
				float[] vrr = {
						rm[0] * vr[0] + rm[3] * vr[1] + rm[6] * vr[2],
						rm[1] * vr[0] + rm[4] * vr[1] + rm[7] * vr[2],
						rm[2] * vr[0] + rm[5] * vr[1] + rm[8] * vr[2]
				};
			
				// compute length & normalize
				float le = sqrt((vrr[0] * vrr[0]) + (vrr[1] * vrr[1]) + (vrr[2] * vrr[2]));
			  float[] vrn = { vrr[0] / le, vrr[1] / le, vrr[2] / le };

				// point shade based on normalized Z value
			  int shading = vrn[2] * 255;
				//fill(shading, shading, shading);

				// since we were in normalized space we scale it to screen space and translate it at the center of the screen
				float posx = x2 - (int)(vrr[0] * cs);
				float posy = y2 - (int)(vrr[1] * cs);
		
				// draw cube surface by computing the quad given from 4 points on the surface
				float px2 = (2.0 * (x + inc) - 1.0);
				float pxs = px2 * scale;
				float py2 = (2.0 * (y + inc) - 1.0);
				float pys = py2 * scale;
				float pz2 = (2.0 * (z + inc) - 1.0);
				float pzs = pz2 * scale;
		
				float posx2; float posy2;
				float posx3; float posy3;
				float posx4; float posy4;
		
				if (y >= 0.0 && y <= (1.0 - inc) &&
						z >= 0.0 && z <= (1.0 - inc) &&
					  (x >= 0.99 || x <= 0.0)) {
					float[] vrr2 = {
							rm[0] * vr[0] + rm[3] * vr[1] + rm[6] * pzs,
							rm[1] * vr[0] + rm[4] * vr[1] + rm[7] * pzs,
							rm[2] * vr[0] + rm[5] * vr[1] + rm[8] * pzs
					};
		
					float[] vrr3 = {
							rm[0] * vr[0] + rm[3] * pys + rm[6] * pzs,
							rm[1] * vr[0] + rm[4] * pys + rm[7] * pzs,
							rm[2] * vr[0] + rm[5] * pys + rm[8] * pzs
					};
	
					float[] vrr4 = {
							rm[0] * vr[0] + rm[3] * pys + rm[6] * vr[2],
							rm[1] * vr[0] + rm[4] * pys + rm[7] * vr[2],
							rm[2] * vr[0] + rm[5] * pys + rm[8] * vr[2]
					};
		
					posx2 = x2 - (int)(vrr2[0] * cs);
					posy2 = y2 - (int)(vrr2[1] * cs);
					posx3 = x2 - (int)(vrr3[0] * cs);
					posy3 = y2 - (int)(vrr3[1] * cs);
					posx4 = x2 - (int)(vrr4[0] * cs);
					posy4 = y2 - (int)(vrr4[1] * cs);
/*
					stroke(shading, shading, shading);
					line(posx, posy, posx2, posy2);
					line(posx2, posy2, posx3, posy3);
					line(posx3, posy3, posx, posy);

					stroke(shading, 0, 0);
					line(posx, posy, posx4, posy4);
					line(posx4, posy4, posx3, posy3);
					line(posx3, posy3, posx, posy);
*/
					noStroke();
					fill(shading, shading, shading);
					fillTriangle(posx, posy, posx2, posy2, posx3, posy3, shading);
					fillTriangle(posx, posy, posx4, posy4, posx3, posy3, shading);
					noFill();
				}
				
				if (x >= 0.0 && x <= (1.0 - inc) &&
									 y >= 0.0 && y <= (1.0 - inc) &&
									 (z >= 0.99 || z <= 0.0)) {
					float[] vrr2 = {
							rm[0] * pxs + rm[3] * vr[1] + rm[6] * vr[2],
							rm[1] * pxs + rm[4] * vr[1] + rm[7] * vr[2],
							rm[2] * pxs + rm[5] * vr[1] + rm[8] * vr[2]
					};
		
					float[] vrr3 = {
							rm[0] * pxs + rm[3] * pys + rm[6] * vr[2],
							rm[1] * pxs + rm[4] * pys + rm[7] * vr[2],
							rm[2] * pxs + rm[5] * pys + rm[8] * vr[2]
					};
	
					float[] vrr4 = {
							rm[0] * vr[0] + rm[3] * pys + rm[6] * vr[2],
							rm[1] * vr[0] + rm[4] * pys + rm[7] * vr[2],
							rm[2] * vr[0] + rm[5] * pys + rm[8] * vr[2]
					};
		
					posx2 = x2 - (int)(vrr2[0] * cs);
					posy2 = y2 - (int)(vrr2[1] * cs);
					posx3 = x2 - (int)(vrr3[0] * cs);
					posy3 = y2 - (int)(vrr3[1] * cs);
					posx4 = x2 - (int)(vrr4[0] * cs);
					posy4 = y2 - (int)(vrr4[1] * cs);
/*
					stroke(shading, shading, shading);
					line(posx, posy, posx2, posy2);
					line(posx2, posy2, posx3, posy3);
					line(posx3, posy3, posx, posy);

					stroke(shading, 0, 0);
					line(posx, posy, posx4, posy4);
					line(posx4, posy4, posx3, posy3);
					line(posx3, posy3, posx, posy);
*/
					noStroke();
					fill(shading, shading, shading);
					fillTriangle(posx, posy, posx2, posy2, posx3, posy3, shading);
					fillTriangle(posx, posy, posx4, posy4, posx3, posy3, shading);
					noFill();
				}
				
				if (x >= 0.0 && x <= (1.0 - inc) &&
									 z >= 0.0 && z <= (1.0 - inc) &&
									 (y >= 0.99 || y <= 0.0)) {
					float[] vrr2 = {
							rm[0] * pxs + rm[3] * vr[1] + rm[6] * vr[2],
							rm[1] * pxs + rm[4] * vr[1] + rm[7] * vr[2],
							rm[2] * pxs + rm[5] * vr[1] + rm[8] * vr[2]
					};
		
					float[] vrr3 = {
							rm[0] * pxs + rm[3] * vr[1] + rm[6] * pzs,
							rm[1] * pxs + rm[4] * vr[1] + rm[7] * pzs,
							rm[2] * pxs + rm[5] * vr[1] + rm[8] * pzs
					};
	
					float[] vrr4 = {
							rm[0] * vr[0] + rm[3] * vr[1] + rm[6] * pzs,
							rm[1] * vr[0] + rm[4] * vr[1] + rm[7] * pzs,
							rm[2] * vr[0] + rm[5] * vr[1] + rm[8] * pzs
					};
		
					posx2 = x2 - (int)(vrr2[0] * cs);
					posy2 = y2 - (int)(vrr2[1] * cs);
					posx3 = x2 - (int)(vrr3[0] * cs);
					posy3 = y2 - (int)(vrr3[1] * cs);
					posx4 = x2 - (int)(vrr4[0] * cs);
					posy4 = y2 - (int)(vrr4[1] * cs);
/*
					stroke(shading, shading, shading);
					line(posx, posy, posx2, posy2);
					line(posx2, posy2, posx3, posy3);
					line(posx3, posy3, posx, posy);

					stroke(shading, 0, 0);
					line(posx, posy, posx4, posy4);
					line(posx4, posy4, posx3, posy3);
					line(posx3, posy3, posx, posy);
*/
					noStroke();
					fill(shading, shading, shading);
					fillTriangle(posx, posy, posx2, posy2, posx3, posy3, shading);
					fillTriangle(posx, posy, posx4, posy4, posx3, posy3, shading);
					noFill();
				}
				
				// no z-buffer
				//quad(posx, posy, posx2, posy2, posx3, posy3, posx4, posy4);

				// points only
				//fill(255, 0, 0);
				//ellipse(posx, posy, 2, 2);
			}
		}
	}
	
	//image(depthbuffer, 0, 0);

	frame += 1;
}"
"649334","REYES rasterization","mySketch","/**
  * A tentative to do a 3D renderer using REYES like algorithms (a type of rendering invented / developed by Lucasfilm / Pixar in the mid-80s and still used to late 2000s)
	* Actually REYES is more like a collection of classical computer graphics algorithms packed into a single solution with a well defined pipeline process.
	*
	* REYES algorithm is simple and powerful, it is like rasterization and state of art algorithms like raytracing / pathtracing
	* in term of power and it have some speed advantages over that last one but it is most importantly very flexible and parallelization friendly.
	* 
	* So how does it work ? It is pretty similar to a standard rasterizer and work mainly with polygons but... with a process of massive surfaces subdivision (preferably adaptive)
	* which produce ""micropolygons"", polygons that are the size of a pixel or so and which allow easy / fast shading computations.
	* Surfaces points can easily be displaced while maintaining high quality output. Effects such as depth of field or motion blur can be done efficiently.
	*
	* https://en.wikipedia.org/wiki/Reyes_rendering
	* 
	* How it was made :
	*  - first we want to define a geometric object (a cube) programmatically, i chose to do it as a parametric surface by simply stepping
	*    in normalized space through points for X,Y,Z then converting to screen space and centering the object. Doing it by stepping on the surface
	*    allow us to control as wanted the stepping factor (which will be our subdivision factor for our polygons)
	*  - since we also stepped through Z we are already rendering a kind of volumetric cube data (which is cool because you could even do volumetric effects later on !)
	*  - since we are only interested by the cube surface, we filter the volumetric data and retain the points on the surface
	*  - we do projection + rotation of our object at the same time with simple matrix / vector operation
	*  - once we have the object points rendered we can do a simple shading that will give us some depth by computing
  *    the length then normalizing the point position vector and assigning the Z value scaled by the max. RGB value to the point color
	*  - at this point we have several ways to render our object :
	*   - by simply rendering the dots
	*   - by detecting the surfaces of the cube we are on (by looking to points position), computing next value for X/Y or X/Z or Y/Z
	*     using those values to draw lines to form two triangles (a quad), this is wireframe mode, we can also compute points value in different order for different wireframe mode
	*   - same step as above but then fill the triangles with barycentric algorithm (find bounding box of triangle, step through X/Y and check wether we are in or out)
	*     we will have flat shading at low resolution but... it also pave the road to the easy application of more complex shading algorithms or texturing!! an important step is also to
	*     check shaded point distance against a Z buffer to remove hidden surfaces
	*
	* Note : When filling polygon we give a step of more than 1 and increase the size of the ""rect"" primitive, this allow fast rendering at the price of huge quality lost
	*        but if you are doing it non-realtime you would increase subdivision to the point of each triangles being 1px, the flat shading would suddenly be smooth shading! :)
	*/

int frame = 0;

float[] displaceX;
float[] displaceY;
float[] displaceZ;

static float cs = 580;
static float inc = 0.1;//1.0 / (cs / 128.0);
static float csi = 1.0 / inc;
static float scale = 1.0 / 8.0;

PGraphics depthbuffer;

void setup() {
  size(1024, 768);

  background(0);
	
	noStroke();
	
	randomSeed(0);
	
	displaceX = new float[(int)csi];
	displaceY = new float[(int)csi];
	displaceZ = new float[(int)csi];
	
	for (int i = 0; i <= (int)csi; i += 1) {
		displaceX[i] = random(-1, 1) / 64;
		displaceY[i] = random(-1, 1) / 64;
		displaceZ[i] = random(-1, 1) / 64;
	}
	
	depthbuffer = createGraphics(width, height);
	depthbuffer.noStroke();
}

void fillTriangle(float x1, float y1,
									float x2, float y2,
									float x3, float y3, int shading) {
	int maxX = max(x1, max(x2, x3));
	int minX = min(x1, min(x2, x3));
	int maxY = max(y1, max(y2, y3));
	int minY = min(y1, min(y2, y3));
	
	float vs1x = x2 - x1;
	float vs1y = y2 - y1;
	float vs2x = x3 - x1;
	float vs2y = y3 - y1;

	for (float x = minX; x <= maxX; x += 4) {
  	for (float y = minY; y <= maxY; y += 4) {
			float qx = x - x1;
			float qy = y - y1;
			
			float s = (qx * vs2y - vs2x * qy) / (vs1x * vs2y - vs2x * vs1y);
			float t = (vs1x * qy - qx * vs1y) / (vs1x * vs2y - vs2x * vs1y);

			if ( (s >= 0) && (t >= 0) && (s + t <= 1)) {
				// check against Z buffer!
				if (shading >= brightness(depthbuffer.get(x, y))) {
					// depth value go into depth buffer
					depthbuffer.beginDraw();
					depthbuffer.fill(shading, shading, shading);
					depthbuffer.rect(x, y, 4, 4);
					depthbuffer.endDraw();
					
					rect(x, y, 4, 4);
				}
			}
		}
	}
}

void draw() {
	// clear z-buffer
	depthbuffer.beginDraw();
	depthbuffer.background(0);
	depthbuffer.endDraw();
	
  background(0);
	//fill(0, 0, 0, 48);
	//rect(0, 0, width, height);
	
	float rxa = 0.03 * frame;
	float rya = 0.04 * frame;

	// rotation values
	float crx = cos(rxa);
	float cry = cos(rya);
	float srx = sin(rxa);
	float sry = sin(rya);
	
	// rm = rotation matrix
	float[] rm = {0,0,0,0,0,0,0,0,0};

	rm[0] = cry;     /*rm[1] = 0.0f;*/ rm[2] = -sry;
	rm[3] = sry * srx; rm[4] = crx;    rm[5] = cry * srx;
	rm[6] = sry * crx; rm[7] = -srx;   rm[8] = cry * crx;
	
	int x2 = width / 2;
	int y2 = height / 2;
	
	float x, y, z;
	
	for (z = 0.0; z <= 1.0; z += inc) {
		float[] vr = {0,0,0};

		float pz = 2.0 * z - 1.0;

		vr[2] = pz * scale;
		for (y = 0.0; y <= 1.0; y += inc) {
			float py = 2.0 * y - 1.0;

			vr[1] = py * scale;
			for (x = 0.0; x <= 1.0; x += inc) {
				// filter volumetric data (eg. we only want the points on the surface)
				if (x > 0.0 && x < (1.0 - inc) && y > 0.0 && y < (1.0 - inc) && z > 0.0 && z < (1.0 - inc)) continue;
				
				float px = (2.0 * x - 1.0);
				
				vr[0] = px * scale;

				// rotate our points
				float[] vrr = {
						rm[0] * vr[0] + rm[3] * vr[1] + rm[6] * vr[2],
						rm[1] * vr[0] + rm[4] * vr[1] + rm[7] * vr[2],
						rm[2] * vr[0] + rm[5] * vr[1] + rm[8] * vr[2]
				};
			
				// compute length & normalize
				float le = sqrt((vrr[0] * vrr[0]) + (vrr[1] * vrr[1]) + (vrr[2] * vrr[2]));
			  float[] vrn = { vrr[0] / le, vrr[1] / le, vrr[2] / le };

				// point shade based on normalized Z value
			  int shading = vrn[2] * 255;
				//fill(shading, shading, shading);

				// since we were in normalized space we scale it to screen space and translate it at the center of the screen
				float posx = x2 - (int)(vrr[0] * cs);
				float posy = y2 - (int)(vrr[1] * cs);
		
				// draw cube surface by computing the quad given from 4 points on the surface
				float px2 = (2.0 * (x + inc) - 1.0);
				float pxs = px2 * scale;
				float py2 = (2.0 * (y + inc) - 1.0);
				float pys = py2 * scale;
				float pz2 = (2.0 * (z + inc) - 1.0);
				float pzs = pz2 * scale;
		
				float posx2; float posy2;
				float posx3; float posy3;
				float posx4; float posy4;
		
				if (y >= 0.0 && y <= (1.0 - inc) &&
						z >= 0.0 && z <= (1.0 - inc) &&
					  (x >= 0.99 || x <= 0.0)) {
					float[] vrr2 = {
							rm[0] * vr[0] + rm[3] * vr[1] + rm[6] * pzs,
							rm[1] * vr[0] + rm[4] * vr[1] + rm[7] * pzs,
							rm[2] * vr[0] + rm[5] * vr[1] + rm[8] * pzs
					};
		
					float[] vrr3 = {
							rm[0] * vr[0] + rm[3] * pys + rm[6] * pzs,
							rm[1] * vr[0] + rm[4] * pys + rm[7] * pzs,
							rm[2] * vr[0] + rm[5] * pys + rm[8] * pzs
					};
	
					float[] vrr4 = {
							rm[0] * vr[0] + rm[3] * pys + rm[6] * vr[2],
							rm[1] * vr[0] + rm[4] * pys + rm[7] * vr[2],
							rm[2] * vr[0] + rm[5] * pys + rm[8] * vr[2]
					};
		
					posx2 = x2 - (int)(vrr2[0] * cs);
					posy2 = y2 - (int)(vrr2[1] * cs);
					posx3 = x2 - (int)(vrr3[0] * cs);
					posy3 = y2 - (int)(vrr3[1] * cs);
					posx4 = x2 - (int)(vrr4[0] * cs);
					posy4 = y2 - (int)(vrr4[1] * cs);
/*
					stroke(shading, shading, shading);
					line(posx, posy, posx2, posy2);
					line(posx2, posy2, posx3, posy3);
					line(posx3, posy3, posx, posy);

					stroke(shading, 0, 0);
					line(posx, posy, posx4, posy4);
					line(posx4, posy4, posx3, posy3);
					line(posx3, posy3, posx, posy);
*/
					noStroke();
					fill(shading, shading, shading);
					fillTriangle(posx, posy, posx2, posy2, posx3, posy3, shading);
					fillTriangle(posx, posy, posx4, posy4, posx3, posy3, shading);
					noFill();
				}
				
				if (x >= 0.0 && x <= (1.0 - inc) &&
									 y >= 0.0 && y <= (1.0 - inc) &&
									 (z >= 0.99 || z <= 0.0)) {
					float[] vrr2 = {
							rm[0] * pxs + rm[3] * vr[1] + rm[6] * vr[2],
							rm[1] * pxs + rm[4] * vr[1] + rm[7] * vr[2],
							rm[2] * pxs + rm[5] * vr[1] + rm[8] * vr[2]
					};
		
					float[] vrr3 = {
							rm[0] * pxs + rm[3] * pys + rm[6] * vr[2],
							rm[1] * pxs + rm[4] * pys + rm[7] * vr[2],
							rm[2] * pxs + rm[5] * pys + rm[8] * vr[2]
					};
	
					float[] vrr4 = {
							rm[0] * vr[0] + rm[3] * pys + rm[6] * vr[2],
							rm[1] * vr[0] + rm[4] * pys + rm[7] * vr[2],
							rm[2] * vr[0] + rm[5] * pys + rm[8] * vr[2]
					};
		
					posx2 = x2 - (int)(vrr2[0] * cs);
					posy2 = y2 - (int)(vrr2[1] * cs);
					posx3 = x2 - (int)(vrr3[0] * cs);
					posy3 = y2 - (int)(vrr3[1] * cs);
					posx4 = x2 - (int)(vrr4[0] * cs);
					posy4 = y2 - (int)(vrr4[1] * cs);
/*
					stroke(shading, shading, shading);
					line(posx, posy, posx2, posy2);
					line(posx2, posy2, posx3, posy3);
					line(posx3, posy3, posx, posy);

					stroke(shading, 0, 0);
					line(posx, posy, posx4, posy4);
					line(posx4, posy4, posx3, posy3);
					line(posx3, posy3, posx, posy);
*/
					noStroke();
					fill(shading, shading, shading);
					fillTriangle(posx, posy, posx2, posy2, posx3, posy3, shading);
					fillTriangle(posx, posy, posx4, posy4, posx3, posy3, shading);
					noFill();
				}
				
				if (x >= 0.0 && x <= (1.0 - inc) &&
									 z >= 0.0 && z <= (1.0 - inc) &&
									 (y >= 0.99 || y <= 0.0)) {
					float[] vrr2 = {
							rm[0] * pxs + rm[3] * vr[1] + rm[6] * vr[2],
							rm[1] * pxs + rm[4] * vr[1] + rm[7] * vr[2],
							rm[2] * pxs + rm[5] * vr[1] + rm[8] * vr[2]
					};
		
					float[] vrr3 = {
							rm[0] * pxs + rm[3] * vr[1] + rm[6] * pzs,
							rm[1] * pxs + rm[4] * vr[1] + rm[7] * pzs,
							rm[2] * pxs + rm[5] * vr[1] + rm[8] * pzs
					};
	
					float[] vrr4 = {
							rm[0] * vr[0] + rm[3] * vr[1] + rm[6] * pzs,
							rm[1] * vr[0] + rm[4] * vr[1] + rm[7] * pzs,
							rm[2] * vr[0] + rm[5] * vr[1] + rm[8] * pzs
					};
		
					posx2 = x2 - (int)(vrr2[0] * cs);
					posy2 = y2 - (int)(vrr2[1] * cs);
					posx3 = x2 - (int)(vrr3[0] * cs);
					posy3 = y2 - (int)(vrr3[1] * cs);
					posx4 = x2 - (int)(vrr4[0] * cs);
					posy4 = y2 - (int)(vrr4[1] * cs);
/*
					stroke(shading, shading, shading);
					line(posx, posy, posx2, posy2);
					line(posx2, posy2, posx3, posy3);
					line(posx3, posy3, posx, posy);

					stroke(shading, 0, 0);
					line(posx, posy, posx4, posy4);
					line(posx4, posy4, posx3, posy3);
					line(posx3, posy3, posx, posy);
*/
					noStroke();
					fill(shading, shading, shading);
					fillTriangle(posx, posy, posx2, posy2, posx3, posy3, shading);
					fillTriangle(posx, posy, posx4, posy4, posx3, posy3, shading);
					noFill();
				}
				
				// no z-buffer
				//quad(posx, posy, posx2, posy2, posx3, posy3, posx4, posy4);

				// points only
				//fill(255, 0, 0);
				//ellipse(posx, posy, 2, 2);
			}
		}
	}
	
	//image(depthbuffer, 0, 0);

	frame += 1;
}"
"649334","REYES rasterization","mySketch","/**
  * A tentative to do a 3D renderer using REYES like algorithms (a type of rendering invented / developed by Lucasfilm / Pixar in the mid-80s and still used to late 2000s)
	* Actually REYES is more like a collection of classical computer graphics algorithms packed into a single solution with a well defined pipeline process.
	*
	* REYES algorithm is simple and powerful, it is like rasterization and state of art algorithms like raytracing / pathtracing
	* in term of power and it have some speed advantages over that last one but it is most importantly very flexible and parallelization friendly.
	* 
	* So how does it work ? It is pretty similar to a standard rasterizer and work mainly with polygons but... with a process of massive surfaces subdivision (preferably adaptive)
	* which produce ""micropolygons"", polygons that are the size of a pixel or so and which allow easy / fast shading computations.
	* Surfaces points can easily be displaced while maintaining high quality output. Effects such as depth of field or motion blur can be done efficiently.
	*
	* https://en.wikipedia.org/wiki/Reyes_rendering
	* 
	* How it was made :
	*  - first we want to define a geometric object (a cube) programmatically, i chose to do it as a parametric surface by simply stepping
	*    in normalized space through points for X,Y,Z then converting to screen space and centering the object. Doing it by stepping on the surface
	*    allow us to control as wanted the stepping factor (which will be our subdivision factor for our polygons)
	*  - since we also stepped through Z we are already rendering a kind of volumetric cube data (which is cool because you could even do volumetric effects later on !)
	*  - since we are only interested by the cube surface, we filter the volumetric data and retain the points on the surface
	*  - we do projection + rotation of our object at the same time with simple matrix / vector operation
	*  - once we have the object points rendered we can do a simple shading that will give us some depth by computing
  *    the length then normalizing the point position vector and assigning the Z value scaled by the max. RGB value to the point color
	*  - at this point we have several ways to render our object :
	*   - by simply rendering the dots
	*   - by detecting the surfaces of the cube we are on (by looking to points position), computing next value for X/Y or X/Z or Y/Z
	*     using those values to draw lines to form two triangles (a quad), this is wireframe mode, we can also compute points value in different order for different wireframe mode
	*   - same step as above but then fill the triangles with barycentric algorithm (find bounding box of triangle, step through X/Y and check wether we are in or out)
	*     we will have flat shading at low resolution but... it also pave the road to the easy application of more complex shading algorithms or texturing!! an important step is also to
	*     check shaded point distance against a Z buffer to remove hidden surfaces
	*
	* Note : When filling polygon we give a step of more than 1 and increase the size of the ""rect"" primitive, this allow fast rendering at the price of huge quality lost
	*        but if you are doing it non-realtime you would increase subdivision to the point of each triangles being 1px, the flat shading would suddenly be smooth shading! :)
	*/

int frame = 0;

static float cs = 580; // also scale :P
static float inc = 0.5; // control surface subdivision, lower = higher quality (but too slow for realtime)
static float csi = 1.0 / inc; // how much points our surface will have along a specific axis
static float scale = 1.0 / 8.0; // cube scale

PGraphics depthbuffer;

void setup() {
  size(1024, 768);

  background(0);
	
	noStroke();
	
	depthbuffer = createGraphics(width, height);
	depthbuffer.noStroke();
}

void fillTriangle(float x1, float y1,
									float x2, float y2,
									float x3, float y3, int shading) {
	int maxX = max(x1, max(x2, x3));
	int minX = min(x1, min(x2, x3));
	int maxY = max(y1, max(y2, y3));
	int minY = min(y1, min(y2, y3));
	
	float vs1x = x2 - x1;
	float vs1y = y2 - y1;
	float vs2x = x3 - x1;
	float vs2y = y3 - y1;

	for (float x = minX; x <= maxX; x += 4) {
  	for (float y = minY; y <= maxY; y += 4) {
			float qx = x - x1;
			float qy = y - y1;
			
			float s = (qx * vs2y - vs2x * qy) / (vs1x * vs2y - vs2x * vs1y);
			float t = (vs1x * qy - qx * vs1y) / (vs1x * vs2y - vs2x * vs1y);

			if ( (s >= 0) && (t >= 0) && (s + t <= 1)) {
				// check against Z buffer!
				if (shading >= brightness(depthbuffer.get(x, y))) {
					// depth value go into depth buffer
					depthbuffer.beginDraw();
					depthbuffer.fill(shading, shading, shading);
					depthbuffer.rect(x, y, 4, 4);
					depthbuffer.endDraw();
					
					rect(x, y, 4, 4);
				}
			}
		}
	}
}

void draw() {
	// clear z-buffer
	depthbuffer.beginDraw();
	depthbuffer.background(0);
	depthbuffer.endDraw();
	
  background(0);
	//fill(0, 0, 0, 48);
	//rect(0, 0, width, height);
	
	float rxa = 0.03 * frame;
	float rya = 0.04 * frame;

	// rotation values
	float crx = cos(rxa);
	float cry = cos(rya);
	float srx = sin(rxa);
	float sry = sin(rya);
	
	// rm = rotation matrix
	float[] rm = {0,0,0,0,0,0,0,0,0};

	rm[0] = cry;     /*rm[1] = 0.0f;*/ rm[2] = -sry;
	rm[3] = sry * srx; rm[4] = crx;    rm[5] = cry * srx;
	rm[6] = sry * crx; rm[7] = -srx;   rm[8] = cry * crx;
	
	int x2 = width / 2;
	int y2 = height / 2;
	
	// step cube volume along X,Y,Z in normalized space
	float x, y, z;
	for (z = 0.0; z <= 1.0; z += inc) {
		float[] vr = {0,0,0};

		float pz = 2.0 * z - 1.0; // normalize screen space

		vr[2] = pz * scale;
		for (y = 0.0; y <= 1.0; y += inc) {
			float py = 2.0 * y - 1.0;

			vr[1] = py * scale;
			for (x = 0.0; x <= 1.0; x += inc) {
				// filter volumetric data (eg. we only want the points on the surface)
				if (x > 0.0 && x < (1.0 - inc) && y > 0.0 && y < (1.0 - inc) && z > 0.0 && z < (1.0 - inc)) continue;
				
				float px = (2.0 * x - 1.0);
				
				vr[0] = px * scale;

				// rotate/transform our points
				float[] vrr = {
						rm[0] * vr[0] + rm[3] * vr[1] + rm[6] * vr[2],
						rm[1] * vr[0] + rm[4] * vr[1] + rm[7] * vr[2],
						rm[2] * vr[0] + rm[5] * vr[1] + rm[8] * vr[2]
				};
			
				// compute length & normalize
				float le = sqrt((vrr[0] * vrr[0]) + (vrr[1] * vrr[1]) + (vrr[2] * vrr[2]));
			  float[] vrn = { vrr[0] / le, vrr[1] / le, vrr[2] / le };

				// point shade based on normalized Z value
			  int shading = vrn[2] * 255;
				//fill(shading, shading, shading);

				// since we were in normalized space we scale it to screen space and translate it at the center of the screen
				float posx = x2 - (int)(vrr[0] * cs);
				float posy = y2 - (int)(vrr[1] * cs);
		
				// draw cube surface
				float px2 = (2.0 * (x + inc) - 1.0);
				float pxs = px2 * scale;
				float py2 = (2.0 * (y + inc) - 1.0);
				float pys = py2 * scale;
				float pz2 = (2.0 * (z + inc) - 1.0);
				float pzs = pz2 * scale;
		
				float posx2; float posy2;
				float posx3; float posy3;
				float posx4; float posy4;
				
				// cube side detection & polygons drawing
				// note : could be optimized into much shorted code...
				if (y >= 0.0 && y <= (1.0 - inc) &&
						z >= 0.0 && z <= (1.0 - inc) &&
					  (x >= 0.99 || x <= 0.0)) {
					float[] vrr2 = {
							rm[0] * vr[0] + rm[3] * vr[1] + rm[6] * pzs,
							rm[1] * vr[0] + rm[4] * vr[1] + rm[7] * pzs,
							rm[2] * vr[0] + rm[5] * vr[1] + rm[8] * pzs
					};
		
					float[] vrr3 = {
							rm[0] * vr[0] + rm[3] * pys + rm[6] * pzs,
							rm[1] * vr[0] + rm[4] * pys + rm[7] * pzs,
							rm[2] * vr[0] + rm[5] * pys + rm[8] * pzs
					};
	
					float[] vrr4 = {
							rm[0] * vr[0] + rm[3] * pys + rm[6] * vr[2],
							rm[1] * vr[0] + rm[4] * pys + rm[7] * vr[2],
							rm[2] * vr[0] + rm[5] * pys + rm[8] * vr[2]
					};
		
					posx2 = x2 - (int)(vrr2[0] * cs);
					posy2 = y2 - (int)(vrr2[1] * cs);
					posx3 = x2 - (int)(vrr3[0] * cs);
					posy3 = y2 - (int)(vrr3[1] * cs);
					posx4 = x2 - (int)(vrr4[0] * cs);
					posy4 = y2 - (int)(vrr4[1] * cs);
/*
					// wireframe
					stroke(shading, shading, shading);
					line(posx, posy, posx2, posy2);
					line(posx2, posy2, posx3, posy3);
					line(posx3, posy3, posx, posy);

					stroke(shading, 0, 0);
					line(posx, posy, posx4, posy4);
					line(posx4, posy4, posx3, posy3);
					line(posx3, posy3, posx, posy);
*/
					noStroke();
					fill(shading, shading, shading);
					fillTriangle(posx, posy, posx2, posy2, posx3, posy3, shading);
					fillTriangle(posx, posy, posx4, posy4, posx3, posy3, shading);
					noFill();
				}
				
				if (x >= 0.0 && x <= (1.0 - inc) &&
									 y >= 0.0 && y <= (1.0 - inc) &&
									 (z >= 0.99 || z <= 0.0)) {
					float[] vrr2 = {
							rm[0] * pxs + rm[3] * vr[1] + rm[6] * vr[2],
							rm[1] * pxs + rm[4] * vr[1] + rm[7] * vr[2],
							rm[2] * pxs + rm[5] * vr[1] + rm[8] * vr[2]
					};
		
					float[] vrr3 = {
							rm[0] * pxs + rm[3] * pys + rm[6] * vr[2],
							rm[1] * pxs + rm[4] * pys + rm[7] * vr[2],
							rm[2] * pxs + rm[5] * pys + rm[8] * vr[2]
					};
	
					float[] vrr4 = {
							rm[0] * vr[0] + rm[3] * pys + rm[6] * vr[2],
							rm[1] * vr[0] + rm[4] * pys + rm[7] * vr[2],
							rm[2] * vr[0] + rm[5] * pys + rm[8] * vr[2]
					};
		
					posx2 = x2 - (int)(vrr2[0] * cs);
					posy2 = y2 - (int)(vrr2[1] * cs);
					posx3 = x2 - (int)(vrr3[0] * cs);
					posy3 = y2 - (int)(vrr3[1] * cs);
					posx4 = x2 - (int)(vrr4[0] * cs);
					posy4 = y2 - (int)(vrr4[1] * cs);
/*
					// wireframe
					stroke(shading, shading, shading);
					line(posx, posy, posx2, posy2);
					line(posx2, posy2, posx3, posy3);
					line(posx3, posy3, posx, posy);

					stroke(shading, 0, 0);
					line(posx, posy, posx4, posy4);
					line(posx4, posy4, posx3, posy3);
					line(posx3, posy3, posx, posy);
*/
					noStroke();
					fill(shading, shading, shading);
					fillTriangle(posx, posy, posx2, posy2, posx3, posy3, shading);
					fillTriangle(posx, posy, posx4, posy4, posx3, posy3, shading);
					noFill();
				}
				
				if (x >= 0.0 && x <= (1.0 - inc) &&
									 z >= 0.0 && z <= (1.0 - inc) &&
									 (y >= 0.99 || y <= 0.0)) {
					float[] vrr2 = {
							rm[0] * pxs + rm[3] * vr[1] + rm[6] * vr[2],
							rm[1] * pxs + rm[4] * vr[1] + rm[7] * vr[2],
							rm[2] * pxs + rm[5] * vr[1] + rm[8] * vr[2]
					};
		
					float[] vrr3 = {
							rm[0] * pxs + rm[3] * vr[1] + rm[6] * pzs,
							rm[1] * pxs + rm[4] * vr[1] + rm[7] * pzs,
							rm[2] * pxs + rm[5] * vr[1] + rm[8] * pzs
					};
	
					float[] vrr4 = {
							rm[0] * vr[0] + rm[3] * vr[1] + rm[6] * pzs,
							rm[1] * vr[0] + rm[4] * vr[1] + rm[7] * pzs,
							rm[2] * vr[0] + rm[5] * vr[1] + rm[8] * pzs
					};
		
					posx2 = x2 - (int)(vrr2[0] * cs);
					posy2 = y2 - (int)(vrr2[1] * cs);
					posx3 = x2 - (int)(vrr3[0] * cs);
					posy3 = y2 - (int)(vrr3[1] * cs);
					posx4 = x2 - (int)(vrr4[0] * cs);
					posy4 = y2 - (int)(vrr4[1] * cs);
/*
					// wireframe
					stroke(shading, shading, shading);
					line(posx, posy, posx2, posy2);
					line(posx2, posy2, posx3, posy3);
					line(posx3, posy3, posx, posy);

					stroke(shading, 0, 0);
					line(posx, posy, posx4, posy4);
					line(posx4, posy4, posx3, posy3);
					line(posx3, posy3, posx, posy);
*/
					noStroke();
					fill(shading, shading, shading);
					fillTriangle(posx, posy, posx2, posy2, posx3, posy3, shading);
					fillTriangle(posx, posy, posx4, posy4, posx3, posy3, shading);
					noFill();
				}
				
				// no z-buffer, optimized filling
				//quad(posx, posy, posx2, posy2, posx3, posy3, posx4, posy4);

				// points only
				//fill(255, 0, 0);
				//ellipse(posx, posy, 2, 2);
			}
		}
	}
	
	// display z buffer
	//image(depthbuffer, 0, 0);

	frame += 1;
}"
"649334","REYES rasterization","mySketch","/**
  * A tentative to do a 3D renderer using REYES like algorithms (a type of rendering invented / developed by Lucasfilm / Pixar in the mid-80s and still used to late 2000s)
	* Actually REYES is more like a collection of classical computer graphics algorithms packed into a single solution with a well defined pipeline process.
	*
	* REYES algorithm is simple and powerful, it is like rasterization and state of art algorithms like raytracing / pathtracing
	* in term of power and it have some speed advantages over that last one but it is most importantly very flexible and parallelization friendly.
	* 
	* So how does it work ? It is pretty similar to a standard rasterizer and work mainly with polygons but... with a process of massive surfaces subdivision (preferably adaptive)
	* which produce ""micropolygons"", polygons that are the size of a pixel or so and which allow easy / fast shading computations.
	* Surfaces points can easily be displaced while maintaining high quality output. Effects such as depth of field or motion blur can be done efficiently.
	*
	* https://en.wikipedia.org/wiki/Reyes_rendering
	* 
	* How it was made :
	*  - first we want to define a geometric object (a cube) programmatically, i chose to do it as a parametric surface by simply stepping
	*    in normalized space through points for X,Y,Z then converting to screen space and centering the object. Doing it by stepping on the surface
	*    allow us to control as wanted the stepping factor (which will be our subdivision factor for our polygons)
	*  - since we also stepped through Z we are already rendering a kind of volumetric cube data (which is cool because you could even do volumetric effects later on !)
	*  - since we are only interested by the cube surface, we filter the volumetric data and retain the points on the surface
	*  - we do projection + rotation of our object at the same time with simple matrix / vector operation
	*  - once we have the object points rendered we can do a simple shading that will give us some depth by computing
  *    the length then normalizing the point position vector and assigning the Z value scaled by the max. RGB value to the point color
	*  - at this point we have several ways to render our object :
	*   - by simply rendering the dots
	*   - by detecting the surfaces of the cube we are on (by looking to points position), computing next value for X/Y or X/Z or Y/Z
	*     using those values to draw lines to form two triangles (a quad), this is wireframe mode, we can also compute points value in different order for different wireframe mode
	*   - same step as above but then fill the triangles with barycentric algorithm (find bounding box of triangle, step through X/Y and check wether we are in or out)
	*     we will have flat shading at low resolution but... it also pave the road to the easy application of more complex shading algorithms or texturing!! an important step is also to
	*     check shaded point distance against a Z buffer to remove hidden surfaces
	*
	* Note : When filling polygon we give a step of more than 1 and increase the size of the ""rect"" primitive, this allow fast rendering at the price of huge quality lost
	*        but if you are doing it non-realtime you would increase subdivision to the point of each triangles being 1px, the flat shading would suddenly be smooth shading! :)
	*/

int frame = 0;

static float cs = 580; // also scale :P
static float inc = 0.5; // control surface subdivision, lower = higher quality (but too slow for realtime)
static float csi = 1.0 / inc; // how much points our surface will have along a specific axis
static float scale = 1.0 / 8.0; // cube scale

PGraphics depthbuffer;

void setup() {
  size(1024, 768);

  background(0);
	
	noStroke();
	
	depthbuffer = createGraphics(width, height);
	depthbuffer.noStroke();
}

void fillTriangle(float x1, float y1,
									float x2, float y2,
									float x3, float y3, int shading) {
	int maxX = max(x1, max(x2, x3));
	int minX = min(x1, min(x2, x3));
	int maxY = max(y1, max(y2, y3));
	int minY = min(y1, min(y2, y3));
	
	float vs1x = x2 - x1;
	float vs1y = y2 - y1;
	float vs2x = x3 - x1;
	float vs2y = y3 - y1;

	for (float x = minX; x <= maxX; x += 4) {
  	for (float y = minY; y <= maxY; y += 4) {
			float qx = x - x1;
			float qy = y - y1;
			
			float s = (qx * vs2y - vs2x * qy) / (vs1x * vs2y - vs2x * vs1y);
			float t = (vs1x * qy - qx * vs1y) / (vs1x * vs2y - vs2x * vs1y);

			if ( (s >= 0) && (t >= 0) && (s + t <= 1)) {
				// check against Z buffer!
				if (shading >= brightness(depthbuffer.get(x, y))) {
					// depth value go into depth buffer
					depthbuffer.beginDraw();
					depthbuffer.fill(shading, shading, shading);
					depthbuffer.rect(x, y, 4, 4);
					depthbuffer.endDraw();
					
					rect(x, y, 4, 4);
				}
			}
		}
	}
}

void draw() {
	// clear z-buffer
	depthbuffer.beginDraw();
	depthbuffer.background(0);
	depthbuffer.endDraw();
	
  background(0);
	//fill(0, 0, 0, 48);
	//rect(0, 0, width, height);
	
	float rxa = 0.03 * frame;
	float rya = 0.04 * frame;

	// rotation values
	float crx = cos(rxa);
	float cry = cos(rya);
	float srx = sin(rxa);
	float sry = sin(rya);
	
	// rm = rotation matrix
	float[] rm = {0,0,0,0,0,0,0,0,0};

	rm[0] = cry;     /*rm[1] = 0.0f;*/ rm[2] = -sry;
	rm[3] = sry * srx; rm[4] = crx;    rm[5] = cry * srx;
	rm[6] = sry * crx; rm[7] = -srx;   rm[8] = cry * crx;
	
	int x2 = width / 2;
	int y2 = height / 2;
	
	// step cube volume along X,Y,Z in normalized space
	float x, y, z;
	for (z = 0.0; z <= 1.0; z += inc) {
		float[] vr = {0,0,0};

		float pz = 2.0 * z - 1.0; // normalize screen space

		vr[2] = pz * scale;
		for (y = 0.0; y <= 1.0; y += inc) {
			float py = 2.0 * y - 1.0;

			vr[1] = py * scale;
			for (x = 0.0; x <= 1.0; x += inc) {
				// filter volumetric data (eg. we only want the points on the surface)
				if (x > 0.0 && x < (1.0 - inc) && y > 0.0 && y < (1.0 - inc) && z > 0.0 && z < (1.0 - inc)) continue;
				
				float px = (2.0 * x - 1.0);
				
				vr[0] = px * scale;

				// rotate/transform our points
				float[] vrr = {
						rm[0] * vr[0] + rm[3] * vr[1] + rm[6] * vr[2],
						rm[1] * vr[0] + rm[4] * vr[1] + rm[7] * vr[2],
						rm[2] * vr[0] + rm[5] * vr[1] + rm[8] * vr[2]
				};
			
				// compute length & normalize
				float le = sqrt((vrr[0] * vrr[0]) + (vrr[1] * vrr[1]) + (vrr[2] * vrr[2]));
			  float[] vrn = { vrr[0] / le, vrr[1] / le, vrr[2] / le };

				// point shade based on normalized Z value
			  int shading = vrn[2] * 255;
				//fill(shading, shading, shading);

				// since we were in normalized space we scale it to screen space and translate it at the center of the screen
				float posx = x2 - (int)(vrr[0] * cs);
				float posy = y2 - (int)(vrr[1] * cs);
		
				// draw cube surface
				float px2 = (2.0 * (x + inc) - 1.0);
				float pxs = px2 * scale;
				float py2 = (2.0 * (y + inc) - 1.0);
				float pys = py2 * scale;
				float pz2 = (2.0 * (z + inc) - 1.0);
				float pzs = pz2 * scale;
		
				float posx2; float posy2;
				float posx3; float posy3;
				float posx4; float posy4;
				
				// cube side detection & polygons drawing
				// note : could be optimized into much shorted code...
				if (y >= 0.0 && y <= (1.0 - inc) &&
						z >= 0.0 && z <= (1.0 - inc) &&
					  (x >= 0.99 || x <= 0.0)) {
					float[] vrr2 = {
							rm[0] * vr[0] + rm[3] * vr[1] + rm[6] * pzs,
							rm[1] * vr[0] + rm[4] * vr[1] + rm[7] * pzs,
							rm[2] * vr[0] + rm[5] * vr[1] + rm[8] * pzs
					};
		
					float[] vrr3 = {
							rm[0] * vr[0] + rm[3] * pys + rm[6] * pzs,
							rm[1] * vr[0] + rm[4] * pys + rm[7] * pzs,
							rm[2] * vr[0] + rm[5] * pys + rm[8] * pzs
					};
	
					float[] vrr4 = {
							rm[0] * vr[0] + rm[3] * pys + rm[6] * vr[2],
							rm[1] * vr[0] + rm[4] * pys + rm[7] * vr[2],
							rm[2] * vr[0] + rm[5] * pys + rm[8] * vr[2]
					};
		
					posx2 = x2 - (int)(vrr2[0] * cs);
					posy2 = y2 - (int)(vrr2[1] * cs);
					posx3 = x2 - (int)(vrr3[0] * cs);
					posy3 = y2 - (int)(vrr3[1] * cs);
					posx4 = x2 - (int)(vrr4[0] * cs);
					posy4 = y2 - (int)(vrr4[1] * cs);
/*
					// wireframe
					stroke(shading, shading, shading);
					line(posx, posy, posx2, posy2);
					line(posx2, posy2, posx3, posy3);
					line(posx3, posy3, posx, posy);

					stroke(shading, 0, 0);
					line(posx, posy, posx4, posy4);
					line(posx4, posy4, posx3, posy3);
					line(posx3, posy3, posx, posy);
*/
					noStroke();
					fill(shading, shading, shading);
					fillTriangle(posx, posy, posx2, posy2, posx3, posy3, shading);
					fillTriangle(posx, posy, posx4, posy4, posx3, posy3, shading);
					noFill();
				}
				
				if (x >= 0.0 && x <= (1.0 - inc) &&
									 y >= 0.0 && y <= (1.0 - inc) &&
									 (z >= 0.99 || z <= 0.0)) {
					float[] vrr2 = {
							rm[0] * pxs + rm[3] * vr[1] + rm[6] * vr[2],
							rm[1] * pxs + rm[4] * vr[1] + rm[7] * vr[2],
							rm[2] * pxs + rm[5] * vr[1] + rm[8] * vr[2]
					};
		
					float[] vrr3 = {
							rm[0] * pxs + rm[3] * pys + rm[6] * vr[2],
							rm[1] * pxs + rm[4] * pys + rm[7] * vr[2],
							rm[2] * pxs + rm[5] * pys + rm[8] * vr[2]
					};
	
					float[] vrr4 = {
							rm[0] * vr[0] + rm[3] * pys + rm[6] * vr[2],
							rm[1] * vr[0] + rm[4] * pys + rm[7] * vr[2],
							rm[2] * vr[0] + rm[5] * pys + rm[8] * vr[2]
					};
		
					posx2 = x2 - (int)(vrr2[0] * cs);
					posy2 = y2 - (int)(vrr2[1] * cs);
					posx3 = x2 - (int)(vrr3[0] * cs);
					posy3 = y2 - (int)(vrr3[1] * cs);
					posx4 = x2 - (int)(vrr4[0] * cs);
					posy4 = y2 - (int)(vrr4[1] * cs);
/*
					// wireframe
					stroke(shading, shading, shading);
					line(posx, posy, posx2, posy2);
					line(posx2, posy2, posx3, posy3);
					line(posx3, posy3, posx, posy);

					stroke(shading, 0, 0);
					line(posx, posy, posx4, posy4);
					line(posx4, posy4, posx3, posy3);
					line(posx3, posy3, posx, posy);
*/
					noStroke();
					fill(shading, shading, shading);
					fillTriangle(posx, posy, posx2, posy2, posx3, posy3, shading);
					fillTriangle(posx, posy, posx4, posy4, posx3, posy3, shading);
					noFill();
				}
				
				if (x >= 0.0 && x <= (1.0 - inc) &&
									 z >= 0.0 && z <= (1.0 - inc) &&
									 (y >= 0.99 || y <= 0.0)) {
					float[] vrr2 = {
							rm[0] * pxs + rm[3] * vr[1] + rm[6] * vr[2],
							rm[1] * pxs + rm[4] * vr[1] + rm[7] * vr[2],
							rm[2] * pxs + rm[5] * vr[1] + rm[8] * vr[2]
					};
		
					float[] vrr3 = {
							rm[0] * pxs + rm[3] * vr[1] + rm[6] * pzs,
							rm[1] * pxs + rm[4] * vr[1] + rm[7] * pzs,
							rm[2] * pxs + rm[5] * vr[1] + rm[8] * pzs
					};
	
					float[] vrr4 = {
							rm[0] * vr[0] + rm[3] * vr[1] + rm[6] * pzs,
							rm[1] * vr[0] + rm[4] * vr[1] + rm[7] * pzs,
							rm[2] * vr[0] + rm[5] * vr[1] + rm[8] * pzs
					};
		
					posx2 = x2 - (int)(vrr2[0] * cs);
					posy2 = y2 - (int)(vrr2[1] * cs);
					posx3 = x2 - (int)(vrr3[0] * cs);
					posy3 = y2 - (int)(vrr3[1] * cs);
					posx4 = x2 - (int)(vrr4[0] * cs);
					posy4 = y2 - (int)(vrr4[1] * cs);
/*
					// wireframe
					stroke(shading, shading, shading);
					line(posx, posy, posx2, posy2);
					line(posx2, posy2, posx3, posy3);
					line(posx3, posy3, posx, posy);

					stroke(shading, 0, 0);
					line(posx, posy, posx4, posy4);
					line(posx4, posy4, posx3, posy3);
					line(posx3, posy3, posx, posy);
*/
					noStroke();
					fill(shading, shading, shading);
					fillTriangle(posx, posy, posx2, posy2, posx3, posy3, shading);
					fillTriangle(posx, posy, posx4, posy4, posx3, posy3, shading);
					noFill();
				}
				
				// no z-buffer, optimized filling
				//quad(posx, posy, posx2, posy2, posx3, posy3, posx4, posy4);

				// points only
				//fill(255, 0, 0);
				//ellipse(posx, posy, 2, 2);
			}
		}
	}
	
	// display z buffer
	//image(depthbuffer, 0, 0);

	frame += 1;
}"
"649334","REYES rasterization","mySketch","/**
  * A tentative to do a 3D renderer using REYES like algorithms (a type of rendering invented / developed by Lucasfilm / Pixar in the mid-80s and still used to late 2000s)
	* Actually REYES is more like a collection of classical computer graphics algorithms packed into a single solution with a well defined pipeline process.
	*
	* REYES algorithm is simple and powerful, it is between rasterization and state of art algorithms like raytracing / pathtracing
	* in term of power and it have some speed advantages over that last one but it is most importantly very flexible and parallelization friendly.
	* 
	* So how does it work ? It is pretty similar to a standard rasterizer and work mainly with polygons but... with a process of massive surfaces subdivision (preferably adaptive)
	* which produce ""micropolygons"", polygons that are the size of a pixel or so and which allow easy / fast shading computations.
	* Surfaces points can easily be displaced while maintaining high quality output. Effects such as depth of field or motion blur can be done efficiently.
	*
	* https://en.wikipedia.org/wiki/Reyes_rendering
	* 
	* How it was made :
	*  - first we want to define a geometric object (a cube) programmatically, i chose to do it as a parametric surface by simply stepping
	*    in normalized space through points for X,Y,Z then converting to screen space and centering the object. Doing it by stepping on the surface
	*    allow us to control as wanted the stepping factor (which will be our subdivision factor for our polygons)
	*  - since we also stepped through Z we are already rendering a kind of volumetric cube data (which is cool because you could even do volumetric effects later on !)
	*  - since we are only interested by the cube surface, we filter the volumetric data and retain the points on the surface
	*  - we do projection + rotation of our object at the same time with simple matrix / vector operation
	*  - once we have the object points rendered we can do a simple shading that will give us some depth by computing
  *    the length then normalizing the point position vector and assigning the Z value scaled by the max. RGB value to the point color
	*  - at this point we have several ways to render our object :
	*   - by simply rendering the dots
	*   - by detecting the surfaces of the cube we are on (by looking to points position), computing next value for X/Y or X/Z or Y/Z
	*     using those values to draw lines to form two triangles (a quad), this is wireframe mode, we can also compute points value in different order for different wireframe mode
	*   - same step as above but then fill the triangles with barycentric algorithm (find bounding box of triangle, step through X/Y and check wether we are in or out)
	*     we will have flat shading at low resolution but... it also pave the road to the easy application of more complex shading algorithms or texturing!! an important step is also to
	*     check shaded point distance against a Z buffer to remove hidden surfaces
	*
	* Note : When filling polygon we give a step of more than 1 and increase the size of the ""rect"" primitive, this allow fast rendering at the price of huge quality lost
	*        but if you are doing it non-realtime you would increase subdivision to the point of each triangles being 1px, the flat shading would suddenly be smooth shading! :)
	*
	* How can this be improved ?
	*  - add more parametric surfaces and especially more generic surfaces
	*  - add shading algorithms (phong etc.)
	*  - play with volumetric data :)
	*  - adaptative subdivision ?
	*  - parallelization
	*  - cleanup of the sides checking
	*  - non-realtime render to obtain high quality images (when subdivision is low)
	*/

int frame = 0;

static float cs = 580; // also scale :P
static float inc = 0.5; // control surface subdivision, lower = higher quality (but too slow for realtime)
static float csi = 1.0 / inc; // how much points our surface will have along a specific axis
static float scale = 1.0 / 8.0; // cube scale

PGraphics depthbuffer;

void setup() {
  size(1024, 768);

  background(0);
	
	noStroke();
	
	depthbuffer = createGraphics(width, height);
	depthbuffer.noStroke();
}

void fillTriangle(float x1, float y1,
									float x2, float y2,
									float x3, float y3, int shading) {
	int maxX = max(x1, max(x2, x3));
	int minX = min(x1, min(x2, x3));
	int maxY = max(y1, max(y2, y3));
	int minY = min(y1, min(y2, y3));
	
	float vs1x = x2 - x1;
	float vs1y = y2 - y1;
	float vs2x = x3 - x1;
	float vs2y = y3 - y1;

	for (float x = minX; x <= maxX; x += 4) {
  	for (float y = minY; y <= maxY; y += 4) {
			float qx = x - x1;
			float qy = y - y1;
			
			float s = (qx * vs2y - vs2x * qy) / (vs1x * vs2y - vs2x * vs1y);
			float t = (vs1x * qy - qx * vs1y) / (vs1x * vs2y - vs2x * vs1y);

			if ( (s >= 0) && (t >= 0) && (s + t <= 1)) {
				// check against Z buffer!
				if (shading >= brightness(depthbuffer.get(x, y))) {
					// depth value go into depth buffer
					depthbuffer.beginDraw();
					depthbuffer.fill(shading, shading, shading);
					depthbuffer.rect(x, y, 4, 4);
					depthbuffer.endDraw();
					
					rect(x, y, 4, 4);
				}
			}
		}
	}
}

void draw() {
	// clear z-buffer
	depthbuffer.beginDraw();
	depthbuffer.background(0);
	depthbuffer.endDraw();
	
  background(0);
	//fill(0, 0, 0, 48);
	//rect(0, 0, width, height);
	
	float rxa = 0.03 * frame;
	float rya = 0.04 * frame;

	// rotation values
	float crx = cos(rxa);
	float cry = cos(rya);
	float srx = sin(rxa);
	float sry = sin(rya);
	
	// rm = rotation matrix
	float[] rm = {0,0,0,0,0,0,0,0,0};

	rm[0] = cry;     /*rm[1] = 0.0f;*/ rm[2] = -sry;
	rm[3] = sry * srx; rm[4] = crx;    rm[5] = cry * srx;
	rm[6] = sry * crx; rm[7] = -srx;   rm[8] = cry * crx;
	
	int x2 = width / 2;
	int y2 = height / 2;
	
	// step cube volume along X,Y,Z in normalized space
	float x, y, z;
	for (z = 0.0; z <= 1.0; z += inc) {
		float[] vr = {0,0,0};

		float pz = 2.0 * z - 1.0; // normalize screen space

		vr[2] = pz * scale;
		for (y = 0.0; y <= 1.0; y += inc) {
			float py = 2.0 * y - 1.0;

			vr[1] = py * scale;
			for (x = 0.0; x <= 1.0; x += inc) {
				// filter volumetric data (eg. we only want the points on the surface)
				if (x > 0.0 && x < (1.0 - inc) && y > 0.0 && y < (1.0 - inc) && z > 0.0 && z < (1.0 - inc)) continue;
				
				float px = (2.0 * x - 1.0);
				
				vr[0] = px * scale;

				// rotate/transform our points
				float[] vrr = {
						rm[0] * vr[0] + rm[3] * vr[1] + rm[6] * vr[2],
						rm[1] * vr[0] + rm[4] * vr[1] + rm[7] * vr[2],
						rm[2] * vr[0] + rm[5] * vr[1] + rm[8] * vr[2]
				};
			
				// compute length & normalize
				float le = sqrt((vrr[0] * vrr[0]) + (vrr[1] * vrr[1]) + (vrr[2] * vrr[2]));
			  float[] vrn = { vrr[0] / le, vrr[1] / le, vrr[2] / le };

				// point shade based on normalized Z value
			  int shading = vrn[2] * 255;
				//fill(shading, shading, shading);

				// since we were in normalized space we scale it to screen space and translate it at the center of the screen
				float posx = x2 - (int)(vrr[0] * cs);
				float posy = y2 - (int)(vrr[1] * cs);
		
				// draw cube surface
				float px2 = (2.0 * (x + inc) - 1.0);
				float pxs = px2 * scale;
				float py2 = (2.0 * (y + inc) - 1.0);
				float pys = py2 * scale;
				float pz2 = (2.0 * (z + inc) - 1.0);
				float pzs = pz2 * scale;
		
				float posx2; float posy2;
				float posx3; float posy3;
				float posx4; float posy4;
				
				// cube side detection & polygons drawing
				// note : could be optimized into much shorted code...
				if (y >= 0.0 && y <= (1.0 - inc) &&
						z >= 0.0 && z <= (1.0 - inc) &&
					  (x >= 0.99 || x <= 0.0)) {
					float[] vrr2 = {
							rm[0] * vr[0] + rm[3] * vr[1] + rm[6] * pzs,
							rm[1] * vr[0] + rm[4] * vr[1] + rm[7] * pzs,
							rm[2] * vr[0] + rm[5] * vr[1] + rm[8] * pzs
					};
		
					float[] vrr3 = {
							rm[0] * vr[0] + rm[3] * pys + rm[6] * pzs,
							rm[1] * vr[0] + rm[4] * pys + rm[7] * pzs,
							rm[2] * vr[0] + rm[5] * pys + rm[8] * pzs
					};
	
					float[] vrr4 = {
							rm[0] * vr[0] + rm[3] * pys + rm[6] * vr[2],
							rm[1] * vr[0] + rm[4] * pys + rm[7] * vr[2],
							rm[2] * vr[0] + rm[5] * pys + rm[8] * vr[2]
					};
		
					posx2 = x2 - (int)(vrr2[0] * cs);
					posy2 = y2 - (int)(vrr2[1] * cs);
					posx3 = x2 - (int)(vrr3[0] * cs);
					posy3 = y2 - (int)(vrr3[1] * cs);
					posx4 = x2 - (int)(vrr4[0] * cs);
					posy4 = y2 - (int)(vrr4[1] * cs);
/*
					// wireframe
					stroke(shading, shading, shading);
					line(posx, posy, posx2, posy2);
					line(posx2, posy2, posx3, posy3);
					line(posx3, posy3, posx, posy);

					stroke(shading, 0, 0);
					line(posx, posy, posx4, posy4);
					line(posx4, posy4, posx3, posy3);
					line(posx3, posy3, posx, posy);
*/
					noStroke();
					fill(shading, shading, shading);
					fillTriangle(posx, posy, posx2, posy2, posx3, posy3, shading);
					fillTriangle(posx, posy, posx4, posy4, posx3, posy3, shading);
					noFill();
				}
				
				if (x >= 0.0 && x <= (1.0 - inc) &&
									 y >= 0.0 && y <= (1.0 - inc) &&
									 (z >= 0.99 || z <= 0.0)) {
					float[] vrr2 = {
							rm[0] * pxs + rm[3] * vr[1] + rm[6] * vr[2],
							rm[1] * pxs + rm[4] * vr[1] + rm[7] * vr[2],
							rm[2] * pxs + rm[5] * vr[1] + rm[8] * vr[2]
					};
		
					float[] vrr3 = {
							rm[0] * pxs + rm[3] * pys + rm[6] * vr[2],
							rm[1] * pxs + rm[4] * pys + rm[7] * vr[2],
							rm[2] * pxs + rm[5] * pys + rm[8] * vr[2]
					};
	
					float[] vrr4 = {
							rm[0] * vr[0] + rm[3] * pys + rm[6] * vr[2],
							rm[1] * vr[0] + rm[4] * pys + rm[7] * vr[2],
							rm[2] * vr[0] + rm[5] * pys + rm[8] * vr[2]
					};
		
					posx2 = x2 - (int)(vrr2[0] * cs);
					posy2 = y2 - (int)(vrr2[1] * cs);
					posx3 = x2 - (int)(vrr3[0] * cs);
					posy3 = y2 - (int)(vrr3[1] * cs);
					posx4 = x2 - (int)(vrr4[0] * cs);
					posy4 = y2 - (int)(vrr4[1] * cs);
/*
					// wireframe
					stroke(shading, shading, shading);
					line(posx, posy, posx2, posy2);
					line(posx2, posy2, posx3, posy3);
					line(posx3, posy3, posx, posy);

					stroke(shading, 0, 0);
					line(posx, posy, posx4, posy4);
					line(posx4, posy4, posx3, posy3);
					line(posx3, posy3, posx, posy);
*/
					noStroke();
					fill(shading, shading, shading);
					fillTriangle(posx, posy, posx2, posy2, posx3, posy3, shading);
					fillTriangle(posx, posy, posx4, posy4, posx3, posy3, shading);
					noFill();
				}
				
				if (x >= 0.0 && x <= (1.0 - inc) &&
									 z >= 0.0 && z <= (1.0 - inc) &&
									 (y >= 0.99 || y <= 0.0)) {
					float[] vrr2 = {
							rm[0] * pxs + rm[3] * vr[1] + rm[6] * vr[2],
							rm[1] * pxs + rm[4] * vr[1] + rm[7] * vr[2],
							rm[2] * pxs + rm[5] * vr[1] + rm[8] * vr[2]
					};
		
					float[] vrr3 = {
							rm[0] * pxs + rm[3] * vr[1] + rm[6] * pzs,
							rm[1] * pxs + rm[4] * vr[1] + rm[7] * pzs,
							rm[2] * pxs + rm[5] * vr[1] + rm[8] * pzs
					};
	
					float[] vrr4 = {
							rm[0] * vr[0] + rm[3] * vr[1] + rm[6] * pzs,
							rm[1] * vr[0] + rm[4] * vr[1] + rm[7] * pzs,
							rm[2] * vr[0] + rm[5] * vr[1] + rm[8] * pzs
					};
		
					posx2 = x2 - (int)(vrr2[0] * cs);
					posy2 = y2 - (int)(vrr2[1] * cs);
					posx3 = x2 - (int)(vrr3[0] * cs);
					posy3 = y2 - (int)(vrr3[1] * cs);
					posx4 = x2 - (int)(vrr4[0] * cs);
					posy4 = y2 - (int)(vrr4[1] * cs);
/*
					// wireframe
					stroke(shading, shading, shading);
					line(posx, posy, posx2, posy2);
					line(posx2, posy2, posx3, posy3);
					line(posx3, posy3, posx, posy);

					stroke(shading, 0, 0);
					line(posx, posy, posx4, posy4);
					line(posx4, posy4, posx3, posy3);
					line(posx3, posy3, posx, posy);
*/
					noStroke();
					fill(shading, shading, shading);
					fillTriangle(posx, posy, posx2, posy2, posx3, posy3, shading);
					fillTriangle(posx, posy, posx4, posy4, posx3, posy3, shading);
					noFill();
				}
				
				// no z-buffer, optimized filling
				//quad(posx, posy, posx2, posy2, posx3, posy3, posx4, posy4);

				// points only
				//fill(255, 0, 0);
				//ellipse(posx, posy, 2, 2);
			}
		}
	}
	
	// display z buffer
	//image(depthbuffer, 0, 0);

	frame += 1;
}"
"649334","REYES rasterization","mySketch","/**
  * A tentative to do a 3D renderer using REYES like algorithms (a type of rendering invented / developed by Lucasfilm / Pixar in the mid-80s and still used to late 2000s)
	* Actually REYES is more like a collection of classical computer graphics algorithms packed into a single solution with a well defined pipeline process.
	*
	* REYES algorithm is simple and powerful, it is between rasterization and state of art algorithms like raytracing / pathtracing
	* in term of power and it have some speed advantages over that last one but it is most importantly very flexible and parallelization friendly.
	* 
	* So how does it work ? It is pretty similar to a standard rasterizer and work mainly with polygons but... with a process of massive surfaces subdivision (preferably adaptive)
	* which produce ""micropolygons"", polygons that are the size of a pixel or so and which allow easy / fast shading computations.
	* Surfaces points can easily be displaced while maintaining high quality output. Effects such as depth of field or motion blur can be done efficiently.
	*
	* https://en.wikipedia.org/wiki/Reyes_rendering
	* 
	* How it was made :
	*  - first we want to define a geometric object (a cube) programmatically, i chose to do it as a parametric surface by simply stepping
	*    in normalized space through points for X,Y,Z then converting to screen space and centering the object. Doing it by stepping on the surface
	*    allow us to control as wanted the stepping factor (which will be our subdivision factor for our polygons)
	*  - since we also stepped through Z we are already rendering a kind of volumetric cube data (which is cool because you could even do volumetric effects later on !)
	*  - since we are only interested by the cube surface, we filter the volumetric data and retain the points on the surface
	*  - we do projection + rotation of our object at the same time with simple matrix / vector operation
	*  - once we have the object points rendered we can do a simple shading that will give us some depth by computing
  *    the length then normalizing the point position vector and assigning the Z value scaled by the max. RGB value to the point color
	*  - at this point we have several ways to render our object :
	*   - by simply rendering the dots
	*   - by detecting the surfaces of the cube we are on (by looking to points position), computing next value for X/Y or X/Z or Y/Z
	*     using those values to draw lines to form two triangles (a quad), this is wireframe mode, we can also compute points value in different order for different wireframe mode
	*   - same step as above but then fill the triangles with barycentric algorithm (find bounding box of triangle, step through X/Y and check wether we are in or out)
	*     we will have flat shading at low resolution but... it also pave the road to the easy application of more complex shading algorithms or texturing!! an important step is also to
	*     check shaded point distance against a Z buffer to remove hidden surfaces
	*
	* Note : When filling polygon we give a step of more than 1 and increase the size of the ""rect"" primitive, this allow fast rendering at the price of huge quality lost
	*        but if you are doing it non-realtime you would increase subdivision to the point of each triangles being 1px, the flat shading would suddenly be smooth shading! :)
	*
	* How can this be improved ?
	*  - add texturing
	*  - fill quads instead of triangles
	*  - add more parametric surfaces and especially more generic surfaces
	*  - add shading algorithms (phong etc.)
	*  - play with volumetric data :)
	*  - adaptative subdivision ?
	*  - parallelization
	*  - cleanup of the sides checking
	*  - non-realtime render to obtain high quality images (when subdivision is low)
	*/

int frame = 0;

static float cs = 580; // also scale :P
static float inc = 0.5; // control surface subdivision, lower = higher quality (but too slow for realtime)
static float csi = 1.0 / inc; // how much points our surface will have along a specific axis
static float scale = 1.0 / 8.0; // cube scale

PGraphics depthbuffer;

void setup() {
  size(1024, 768);

  background(0);
	
	noStroke();
	
	depthbuffer = createGraphics(width, height);
	depthbuffer.noStroke();
}

void fillTriangle(float x1, float y1,
									float x2, float y2,
									float x3, float y3, int shading) {
	int maxX = max(x1, max(x2, x3));
	int minX = min(x1, min(x2, x3));
	int maxY = max(y1, max(y2, y3));
	int minY = min(y1, min(y2, y3));
	
	float vs1x = x2 - x1;
	float vs1y = y2 - y1;
	float vs2x = x3 - x1;
	float vs2y = y3 - y1;

	for (float x = minX; x <= maxX; x += 4) {
  	for (float y = minY; y <= maxY; y += 4) {
			float qx = x - x1;
			float qy = y - y1;
			
			float s = (qx * vs2y - vs2x * qy) / (vs1x * vs2y - vs2x * vs1y);
			float t = (vs1x * qy - qx * vs1y) / (vs1x * vs2y - vs2x * vs1y);

			if ( (s >= 0) && (t >= 0) && (s + t <= 1)) {
				// check against Z buffer!
				if (shading >= brightness(depthbuffer.get(x, y))) {
					// depth value go into depth buffer
					depthbuffer.beginDraw();
					depthbuffer.fill(shading, shading, shading);
					depthbuffer.rect(x, y, 4, 4);
					depthbuffer.endDraw();
					
					rect(x, y, 4, 4);
				}
			}
		}
	}
}

void draw() {
	// clear z-buffer
	depthbuffer.beginDraw();
	depthbuffer.background(0);
	depthbuffer.endDraw();
	
  background(0);
	//fill(0, 0, 0, 48);
	//rect(0, 0, width, height);
	
	float rxa = 0.03 * frame;
	float rya = 0.04 * frame;

	// rotation values
	float crx = cos(rxa);
	float cry = cos(rya);
	float srx = sin(rxa);
	float sry = sin(rya);
	
	// rm = rotation matrix
	float[] rm = {0,0,0,0,0,0,0,0,0};

	rm[0] = cry;     /*rm[1] = 0.0f;*/ rm[2] = -sry;
	rm[3] = sry * srx; rm[4] = crx;    rm[5] = cry * srx;
	rm[6] = sry * crx; rm[7] = -srx;   rm[8] = cry * crx;
	
	int x2 = width / 2;
	int y2 = height / 2;
	
	// step cube volume along X,Y,Z in normalized space
	float x, y, z;
	for (z = 0.0; z <= 1.0; z += inc) {
		float[] vr = {0,0,0};

		float pz = 2.0 * z - 1.0; // normalize screen space

		vr[2] = pz * scale;
		for (y = 0.0; y <= 1.0; y += inc) {
			float py = 2.0 * y - 1.0;

			vr[1] = py * scale;
			for (x = 0.0; x <= 1.0; x += inc) {
				// filter volumetric data (eg. we only want the points on the surface)
				if (x > 0.0 && x < (1.0 - inc) && y > 0.0 && y < (1.0 - inc) && z > 0.0 && z < (1.0 - inc)) continue;
				
				float px = (2.0 * x - 1.0);
				
				vr[0] = px * scale;

				// rotate/transform our points
				float[] vrr = {
						rm[0] * vr[0] + rm[3] * vr[1] + rm[6] * vr[2],
						rm[1] * vr[0] + rm[4] * vr[1] + rm[7] * vr[2],
						rm[2] * vr[0] + rm[5] * vr[1] + rm[8] * vr[2]
				};
			
				// compute length & normalize
				float le = sqrt((vrr[0] * vrr[0]) + (vrr[1] * vrr[1]) + (vrr[2] * vrr[2]));
			  float[] vrn = { vrr[0] / le, vrr[1] / le, vrr[2] / le };

				// point shade based on normalized Z value
			  int shading = vrn[2] * 255;
				//fill(shading, shading, shading);

				// since we were in normalized space we scale it to screen space and translate it at the center of the screen
				float posx = x2 - (int)(vrr[0] * cs);
				float posy = y2 - (int)(vrr[1] * cs);
		
				// draw cube surface
				float px2 = (2.0 * (x + inc) - 1.0);
				float pxs = px2 * scale;
				float py2 = (2.0 * (y + inc) - 1.0);
				float pys = py2 * scale;
				float pz2 = (2.0 * (z + inc) - 1.0);
				float pzs = pz2 * scale;
		
				float posx2; float posy2;
				float posx3; float posy3;
				float posx4; float posy4;
				
				// cube side detection & polygons drawing
				// note : could be optimized into much shorted code...
				if (y >= 0.0 && y <= (1.0 - inc) &&
						z >= 0.0 && z <= (1.0 - inc) &&
					  (x >= 0.99 || x <= 0.0)) {
					float[] vrr2 = {
							rm[0] * vr[0] + rm[3] * vr[1] + rm[6] * pzs,
							rm[1] * vr[0] + rm[4] * vr[1] + rm[7] * pzs,
							rm[2] * vr[0] + rm[5] * vr[1] + rm[8] * pzs
					};
		
					float[] vrr3 = {
							rm[0] * vr[0] + rm[3] * pys + rm[6] * pzs,
							rm[1] * vr[0] + rm[4] * pys + rm[7] * pzs,
							rm[2] * vr[0] + rm[5] * pys + rm[8] * pzs
					};
	
					float[] vrr4 = {
							rm[0] * vr[0] + rm[3] * pys + rm[6] * vr[2],
							rm[1] * vr[0] + rm[4] * pys + rm[7] * vr[2],
							rm[2] * vr[0] + rm[5] * pys + rm[8] * vr[2]
					};
		
					posx2 = x2 - (int)(vrr2[0] * cs);
					posy2 = y2 - (int)(vrr2[1] * cs);
					posx3 = x2 - (int)(vrr3[0] * cs);
					posy3 = y2 - (int)(vrr3[1] * cs);
					posx4 = x2 - (int)(vrr4[0] * cs);
					posy4 = y2 - (int)(vrr4[1] * cs);
/*
					// wireframe
					stroke(shading, shading, shading);
					line(posx, posy, posx2, posy2);
					line(posx2, posy2, posx3, posy3);
					line(posx3, posy3, posx, posy);

					stroke(shading, 0, 0);
					line(posx, posy, posx4, posy4);
					line(posx4, posy4, posx3, posy3);
					line(posx3, posy3, posx, posy);
*/
					noStroke();
					fill(shading, shading, shading);
					fillTriangle(posx, posy, posx2, posy2, posx3, posy3, shading);
					fillTriangle(posx, posy, posx4, posy4, posx3, posy3, shading);
					noFill();
				}
				
				if (x >= 0.0 && x <= (1.0 - inc) &&
									 y >= 0.0 && y <= (1.0 - inc) &&
									 (z >= 0.99 || z <= 0.0)) {
					float[] vrr2 = {
							rm[0] * pxs + rm[3] * vr[1] + rm[6] * vr[2],
							rm[1] * pxs + rm[4] * vr[1] + rm[7] * vr[2],
							rm[2] * pxs + rm[5] * vr[1] + rm[8] * vr[2]
					};
		
					float[] vrr3 = {
							rm[0] * pxs + rm[3] * pys + rm[6] * vr[2],
							rm[1] * pxs + rm[4] * pys + rm[7] * vr[2],
							rm[2] * pxs + rm[5] * pys + rm[8] * vr[2]
					};
	
					float[] vrr4 = {
							rm[0] * vr[0] + rm[3] * pys + rm[6] * vr[2],
							rm[1] * vr[0] + rm[4] * pys + rm[7] * vr[2],
							rm[2] * vr[0] + rm[5] * pys + rm[8] * vr[2]
					};
		
					posx2 = x2 - (int)(vrr2[0] * cs);
					posy2 = y2 - (int)(vrr2[1] * cs);
					posx3 = x2 - (int)(vrr3[0] * cs);
					posy3 = y2 - (int)(vrr3[1] * cs);
					posx4 = x2 - (int)(vrr4[0] * cs);
					posy4 = y2 - (int)(vrr4[1] * cs);
/*
					// wireframe
					stroke(shading, shading, shading);
					line(posx, posy, posx2, posy2);
					line(posx2, posy2, posx3, posy3);
					line(posx3, posy3, posx, posy);

					stroke(shading, 0, 0);
					line(posx, posy, posx4, posy4);
					line(posx4, posy4, posx3, posy3);
					line(posx3, posy3, posx, posy);
*/
					noStroke();
					fill(shading, shading, shading);
					fillTriangle(posx, posy, posx2, posy2, posx3, posy3, shading);
					fillTriangle(posx, posy, posx4, posy4, posx3, posy3, shading);
					noFill();
				}
				
				if (x >= 0.0 && x <= (1.0 - inc) &&
									 z >= 0.0 && z <= (1.0 - inc) &&
									 (y >= 0.99 || y <= 0.0)) {
					float[] vrr2 = {
							rm[0] * pxs + rm[3] * vr[1] + rm[6] * vr[2],
							rm[1] * pxs + rm[4] * vr[1] + rm[7] * vr[2],
							rm[2] * pxs + rm[5] * vr[1] + rm[8] * vr[2]
					};
		
					float[] vrr3 = {
							rm[0] * pxs + rm[3] * vr[1] + rm[6] * pzs,
							rm[1] * pxs + rm[4] * vr[1] + rm[7] * pzs,
							rm[2] * pxs + rm[5] * vr[1] + rm[8] * pzs
					};
	
					float[] vrr4 = {
							rm[0] * vr[0] + rm[3] * vr[1] + rm[6] * pzs,
							rm[1] * vr[0] + rm[4] * vr[1] + rm[7] * pzs,
							rm[2] * vr[0] + rm[5] * vr[1] + rm[8] * pzs
					};
		
					posx2 = x2 - (int)(vrr2[0] * cs);
					posy2 = y2 - (int)(vrr2[1] * cs);
					posx3 = x2 - (int)(vrr3[0] * cs);
					posy3 = y2 - (int)(vrr3[1] * cs);
					posx4 = x2 - (int)(vrr4[0] * cs);
					posy4 = y2 - (int)(vrr4[1] * cs);
/*
					// wireframe
					stroke(shading, shading, shading);
					line(posx, posy, posx2, posy2);
					line(posx2, posy2, posx3, posy3);
					line(posx3, posy3, posx, posy);

					stroke(shading, 0, 0);
					line(posx, posy, posx4, posy4);
					line(posx4, posy4, posx3, posy3);
					line(posx3, posy3, posx, posy);
*/
					noStroke();
					fill(shading, shading, shading);
					fillTriangle(posx, posy, posx2, posy2, posx3, posy3, shading);
					fillTriangle(posx, posy, posx4, posy4, posx3, posy3, shading);
					noFill();
				}
				
				// no z-buffer, optimized filling
				//quad(posx, posy, posx2, posy2, posx3, posy3, posx4, posy4);

				// points only
				//fill(255, 0, 0);
				//ellipse(posx, posy, 2, 2);
			}
		}
	}
	
	// display z buffer
	//image(depthbuffer, 0, 0);

	frame += 1;
}"
"649334","REYES rasterization","mySketch","/**
  * A tentative to do a 3D renderer using REYES like algorithms (a type of rendering invented / developed by Lucasfilm / Pixar in the mid-80s and still used to late 2000s)
	* Actually REYES is more like a collection of classical computer graphics algorithms packed into a single solution with a well defined pipeline process.
	*
	* REYES algorithm is simple and powerful, it is between rasterization and state of art algorithms like raytracing / pathtracing
	* in term of power and it have some speed advantages over that last one but it is most importantly very flexible and parallelization friendly.
	* 
	* So how does it work ? It is pretty similar to a standard rasterizer and work mainly with polygons but... with a process of massive surfaces subdivision (preferably adaptive)
	* which produce ""micropolygons"", polygons that are the size of a pixel or so and which allow easy / fast shading computations, there is also some important optimization steps.
	*
	* ""All objects are reduced to common world-space geometric entities called micropolygons, and all of the shading and visibility calculations operate on these micropolygons.
	*  Each type of calculation is performed in a coordinate system that is natural for that type of calculation.
	*  Micropolygons are created and textured in the local coordinate system of the object, with the result that texture filtering is simplified and improved.
	*  Visibility is calculated in screen space using stochastic point sampling with a z buffer.
	*  There are no clipping or perspective calculations. Geometric and texture locality are exploited to minimize paging and to support models that contain arbitrarily many primitives.""
  *
	* Surfaces may be defined through NURBS for example but i chose a parametric object for this demonstration.
	*
	* https://en.wikipedia.org/wiki/Reyes_rendering
	* 
	* How it was made :
	*  - first we want to define a geometric object (a cube) programmatically, i chose to do it as a parametric surface by simply stepping
	*    in normalized space through points for X,Y,Z then converting to screen space and centering the object. Doing it by stepping on the surface
	*    allow us to control as wanted the stepping factor (which will be our subdivision factor for our polygons)
	*  - since we also stepped through Z we are already rendering a kind of volumetric cube data (which is cool because you could even do volumetric effects later on !)
	*  - since we are only interested by the cube surface, we filter the volumetric data and retain the points on the surface
	*  - we do projection + rotation of our object at the same time with simple matrix / vector operation
	*  - once we have the object points rendered we can do a simple shading that will give us some depth by computing
  *    the length then normalizing the point position vector and assigning the Z value scaled by the max. RGB value to the point color
	*  - at this point we have several ways to render our object :
	*   - by simply rendering the dots
	*   - by detecting the surfaces of the cube we are on (by looking to points position), computing next value for X/Y or X/Z or Y/Z
	*     using those values to draw lines to form two triangles (a quad), this is wireframe mode, we can also compute points value in different order for different wireframe mode
	*   - same step as above but then fill the triangles with barycentric algorithm (find bounding box of triangle, step through X/Y and check wether we are in or out)
	*     we will have flat shading at low resolution but... it also pave the road to the easy application of more complex shading algorithms or texturing!! an important step is also to
	*     check shaded point distance against a Z buffer to remove hidden surfaces
	*
	* Note : When filling polygon we give a step of more than 1 and increase the size of the ""rect"" primitive, this allow fast rendering at the price of huge quality lost
	*        but if you are doing it non-realtime you would increase subdivision to the point of each triangles being 1px, the flat shading would suddenly be smooth shading! :)
	*
	* How can this be improved ?
	*  - add texturing
	*  - fill quads instead of triangles
	*  - add more parametric surfaces and especially more generic surfaces
	*  - add shading algorithms (phong etc.)
	*  - play with volumetric data :)
	*  - adaptative subdivision ?
	*  - parallelization
	*  - cleanup of the sides checking
	*  - non-realtime render to obtain high quality images (when subdivision is low)
	*/

int frame = 0;

static float cs = 580; // also scale :P
static float inc = 0.5; // control surface subdivision, lower = higher quality (but too slow for realtime)
static float csi = 1.0 / inc; // how much points our surface will have along a specific axis
static float scale = 1.0 / 8.0; // cube scale

PGraphics depthbuffer;

void setup() {
  size(1024, 768);

  background(0);
	
	noStroke();
	
	depthbuffer = createGraphics(width, height);
	depthbuffer.noStroke();
}

void fillTriangle(float x1, float y1,
									float x2, float y2,
									float x3, float y3, int shading) {
	int maxX = max(x1, max(x2, x3));
	int minX = min(x1, min(x2, x3));
	int maxY = max(y1, max(y2, y3));
	int minY = min(y1, min(y2, y3));
	
	float vs1x = x2 - x1;
	float vs1y = y2 - y1;
	float vs2x = x3 - x1;
	float vs2y = y3 - y1;

	for (float x = minX; x <= maxX; x += 4) {
  	for (float y = minY; y <= maxY; y += 4) {
			float qx = x - x1;
			float qy = y - y1;
			
			float s = (qx * vs2y - vs2x * qy) / (vs1x * vs2y - vs2x * vs1y);
			float t = (vs1x * qy - qx * vs1y) / (vs1x * vs2y - vs2x * vs1y);

			if ( (s >= 0) && (t >= 0) && (s + t <= 1)) {
				// check against Z buffer!
				if (shading >= brightness(depthbuffer.get(x, y))) {
					// depth value go into depth buffer
					depthbuffer.beginDraw();
					depthbuffer.fill(shading, shading, shading);
					depthbuffer.rect(x, y, 4, 4);
					depthbuffer.endDraw();
					
					rect(x, y, 4, 4);
				}
			}
		}
	}
}

void draw() {
	// clear z-buffer
	depthbuffer.beginDraw();
	depthbuffer.background(0);
	depthbuffer.endDraw();
	
  background(0);
	//fill(0, 0, 0, 48);
	//rect(0, 0, width, height);
	
	float rxa = 0.03 * frame;
	float rya = 0.04 * frame;

	// rotation values
	float crx = cos(rxa);
	float cry = cos(rya);
	float srx = sin(rxa);
	float sry = sin(rya);
	
	// rm = rotation matrix
	float[] rm = {0,0,0,0,0,0,0,0,0};

	rm[0] = cry;     /*rm[1] = 0.0f;*/ rm[2] = -sry;
	rm[3] = sry * srx; rm[4] = crx;    rm[5] = cry * srx;
	rm[6] = sry * crx; rm[7] = -srx;   rm[8] = cry * crx;
	
	int x2 = width / 2;
	int y2 = height / 2;
	
	// step cube volume along X,Y,Z in normalized space
	float x, y, z;
	for (z = 0.0; z <= 1.0; z += inc) {
		float[] vr = {0,0,0};

		float pz = 2.0 * z - 1.0; // normalize screen space

		vr[2] = pz * scale;
		for (y = 0.0; y <= 1.0; y += inc) {
			float py = 2.0 * y - 1.0;

			vr[1] = py * scale;
			for (x = 0.0; x <= 1.0; x += inc) {
				// filter volumetric data (eg. we only want the points on the surface)
				if (x > 0.0 && x < (1.0 - inc) && y > 0.0 && y < (1.0 - inc) && z > 0.0 && z < (1.0 - inc)) continue;
				
				float px = (2.0 * x - 1.0);
				
				vr[0] = px * scale;

				// rotate/transform our points
				float[] vrr = {
						rm[0] * vr[0] + rm[3] * vr[1] + rm[6] * vr[2],
						rm[1] * vr[0] + rm[4] * vr[1] + rm[7] * vr[2],
						rm[2] * vr[0] + rm[5] * vr[1] + rm[8] * vr[2]
				};
			
				// compute length & normalize
				float le = sqrt((vrr[0] * vrr[0]) + (vrr[1] * vrr[1]) + (vrr[2] * vrr[2]));
			  float[] vrn = { vrr[0] / le, vrr[1] / le, vrr[2] / le };

				// point shade based on normalized Z value
			  int shading = vrn[2] * 255;
				//fill(shading, shading, shading);

				// since we were in normalized space we scale it to screen space and translate it at the center of the screen
				float posx = x2 - (int)(vrr[0] * cs);
				float posy = y2 - (int)(vrr[1] * cs);
		
				// draw cube surface
				float px2 = (2.0 * (x + inc) - 1.0);
				float pxs = px2 * scale;
				float py2 = (2.0 * (y + inc) - 1.0);
				float pys = py2 * scale;
				float pz2 = (2.0 * (z + inc) - 1.0);
				float pzs = pz2 * scale;
		
				float posx2; float posy2;
				float posx3; float posy3;
				float posx4; float posy4;
				
				// cube side detection & polygons drawing
				// note : could be optimized into much shorted code...
				if (y >= 0.0 && y <= (1.0 - inc) &&
						z >= 0.0 && z <= (1.0 - inc) &&
					  (x >= 0.99 || x <= 0.0)) {
					float[] vrr2 = {
							rm[0] * vr[0] + rm[3] * vr[1] + rm[6] * pzs,
							rm[1] * vr[0] + rm[4] * vr[1] + rm[7] * pzs,
							rm[2] * vr[0] + rm[5] * vr[1] + rm[8] * pzs
					};
		
					float[] vrr3 = {
							rm[0] * vr[0] + rm[3] * pys + rm[6] * pzs,
							rm[1] * vr[0] + rm[4] * pys + rm[7] * pzs,
							rm[2] * vr[0] + rm[5] * pys + rm[8] * pzs
					};
	
					float[] vrr4 = {
							rm[0] * vr[0] + rm[3] * pys + rm[6] * vr[2],
							rm[1] * vr[0] + rm[4] * pys + rm[7] * vr[2],
							rm[2] * vr[0] + rm[5] * pys + rm[8] * vr[2]
					};
		
					posx2 = x2 - (int)(vrr2[0] * cs);
					posy2 = y2 - (int)(vrr2[1] * cs);
					posx3 = x2 - (int)(vrr3[0] * cs);
					posy3 = y2 - (int)(vrr3[1] * cs);
					posx4 = x2 - (int)(vrr4[0] * cs);
					posy4 = y2 - (int)(vrr4[1] * cs);
/*
					// wireframe
					stroke(shading, shading, shading);
					line(posx, posy, posx2, posy2);
					line(posx2, posy2, posx3, posy3);
					line(posx3, posy3, posx, posy);

					stroke(shading, 0, 0);
					line(posx, posy, posx4, posy4);
					line(posx4, posy4, posx3, posy3);
					line(posx3, posy3, posx, posy);
*/
					noStroke();
					fill(shading, shading, shading);
					fillTriangle(posx, posy, posx2, posy2, posx3, posy3, shading);
					fillTriangle(posx, posy, posx4, posy4, posx3, posy3, shading);
					noFill();
				}
				
				if (x >= 0.0 && x <= (1.0 - inc) &&
									 y >= 0.0 && y <= (1.0 - inc) &&
									 (z >= 0.99 || z <= 0.0)) {
					float[] vrr2 = {
							rm[0] * pxs + rm[3] * vr[1] + rm[6] * vr[2],
							rm[1] * pxs + rm[4] * vr[1] + rm[7] * vr[2],
							rm[2] * pxs + rm[5] * vr[1] + rm[8] * vr[2]
					};
		
					float[] vrr3 = {
							rm[0] * pxs + rm[3] * pys + rm[6] * vr[2],
							rm[1] * pxs + rm[4] * pys + rm[7] * vr[2],
							rm[2] * pxs + rm[5] * pys + rm[8] * vr[2]
					};
	
					float[] vrr4 = {
							rm[0] * vr[0] + rm[3] * pys + rm[6] * vr[2],
							rm[1] * vr[0] + rm[4] * pys + rm[7] * vr[2],
							rm[2] * vr[0] + rm[5] * pys + rm[8] * vr[2]
					};
		
					posx2 = x2 - (int)(vrr2[0] * cs);
					posy2 = y2 - (int)(vrr2[1] * cs);
					posx3 = x2 - (int)(vrr3[0] * cs);
					posy3 = y2 - (int)(vrr3[1] * cs);
					posx4 = x2 - (int)(vrr4[0] * cs);
					posy4 = y2 - (int)(vrr4[1] * cs);
/*
					// wireframe
					stroke(shading, shading, shading);
					line(posx, posy, posx2, posy2);
					line(posx2, posy2, posx3, posy3);
					line(posx3, posy3, posx, posy);

					stroke(shading, 0, 0);
					line(posx, posy, posx4, posy4);
					line(posx4, posy4, posx3, posy3);
					line(posx3, posy3, posx, posy);
*/
					noStroke();
					fill(shading, shading, shading);
					fillTriangle(posx, posy, posx2, posy2, posx3, posy3, shading);
					fillTriangle(posx, posy, posx4, posy4, posx3, posy3, shading);
					noFill();
				}
				
				if (x >= 0.0 && x <= (1.0 - inc) &&
									 z >= 0.0 && z <= (1.0 - inc) &&
									 (y >= 0.99 || y <= 0.0)) {
					float[] vrr2 = {
							rm[0] * pxs + rm[3] * vr[1] + rm[6] * vr[2],
							rm[1] * pxs + rm[4] * vr[1] + rm[7] * vr[2],
							rm[2] * pxs + rm[5] * vr[1] + rm[8] * vr[2]
					};
		
					float[] vrr3 = {
							rm[0] * pxs + rm[3] * vr[1] + rm[6] * pzs,
							rm[1] * pxs + rm[4] * vr[1] + rm[7] * pzs,
							rm[2] * pxs + rm[5] * vr[1] + rm[8] * pzs
					};
	
					float[] vrr4 = {
							rm[0] * vr[0] + rm[3] * vr[1] + rm[6] * pzs,
							rm[1] * vr[0] + rm[4] * vr[1] + rm[7] * pzs,
							rm[2] * vr[0] + rm[5] * vr[1] + rm[8] * pzs
					};
		
					posx2 = x2 - (int)(vrr2[0] * cs);
					posy2 = y2 - (int)(vrr2[1] * cs);
					posx3 = x2 - (int)(vrr3[0] * cs);
					posy3 = y2 - (int)(vrr3[1] * cs);
					posx4 = x2 - (int)(vrr4[0] * cs);
					posy4 = y2 - (int)(vrr4[1] * cs);
/*
					// wireframe
					stroke(shading, shading, shading);
					line(posx, posy, posx2, posy2);
					line(posx2, posy2, posx3, posy3);
					line(posx3, posy3, posx, posy);

					stroke(shading, 0, 0);
					line(posx, posy, posx4, posy4);
					line(posx4, posy4, posx3, posy3);
					line(posx3, posy3, posx, posy);
*/
					noStroke();
					fill(shading, shading, shading);
					fillTriangle(posx, posy, posx2, posy2, posx3, posy3, shading);
					fillTriangle(posx, posy, posx4, posy4, posx3, posy3, shading);
					noFill();
				}
				
				// no z-buffer, optimized filling
				//quad(posx, posy, posx2, posy2, posx3, posy3, posx4, posy4);

				// points only
				//fill(255, 0, 0);
				//ellipse(posx, posy, 2, 2);
			}
		}
	}
	
	// display z buffer
	//image(depthbuffer, 0, 0);

	frame += 1;
}"
"649334","REYES rasterization","mySketch","/**
  * A tentative to do a 3D renderer using REYES like algorithms (a type of rendering invented / developed by Lucasfilm / Pixar in the mid-80s and still used to late 2000s)
	* Actually REYES is more like a collection of classical computer graphics algorithms packed into a single solution with a well defined pipeline process.
	*
	* Actually it is more like a standard rasterizer than REYES... :)
	*
	* REYES algorithm is simple and powerful, it is between rasterization and state of art algorithms like raytracing / pathtracing
	* in term of power and it have some speed advantages over that last one but it is most importantly very flexible and parallelization friendly.
	* 
	* So how does it work ? It is pretty similar to a standard rasterizer and work mainly with polygons but... with a process of massive surfaces subdivision (preferably adaptive)
	* which produce ""micropolygons"", polygons that are the size of a pixel or so and which allow easy / fast shading computations, there is also some important optimization steps.
	*
	* ""All objects are reduced to common world-space geometric entities called micropolygons, and all of the shading and visibility calculations operate on these micropolygons.
	*  Each type of calculation is performed in a coordinate system that is natural for that type of calculation.
	*  Micropolygons are created and textured in the local coordinate system of the object, with the result that texture filtering is simplified and improved.
	*  Visibility is calculated in screen space using stochastic point sampling with a z buffer.
	*  There are no clipping or perspective calculations. Geometric and texture locality are exploited to minimize paging and to support models that contain arbitrarily many primitives.""
  *
	* Surfaces may be defined through NURBS for example but i chose a parametric object for this demonstration.
	*
	* https://en.wikipedia.org/wiki/Reyes_rendering
	* 
	* How it was made :
	*  - first we want to define a geometric object (a cube) programmatically, i chose to do it as a parametric surface by simply stepping
	*    in normalized space through points for X,Y,Z then converting to screen space and centering the object. Doing it by stepping on the surface
	*    allow us to control as wanted the stepping factor (which will be our subdivision factor for our polygons)
	*  - since we also stepped through Z we are already rendering a kind of volumetric cube data (which is cool because you could even do volumetric effects later on !)
	*  - since we are only interested by the cube surface, we filter the volumetric data and retain the points on the surface
	*  - we do projection + rotation of our object at the same time with simple matrix / vector operation
	*  - once we have the object points rendered we can do a simple shading that will give us some depth by computing
  *    the length then normalizing the point position vector and assigning the Z value scaled by the max. RGB value to the point color
	*  - at this point we have several ways to render our object :
	*   - by simply rendering the dots
	*   - by detecting the surfaces of the cube we are on (by looking to points position), computing next value for X/Y or X/Z or Y/Z
	*     using those values to draw lines to form two triangles (a quad), this is wireframe mode, we can also compute points value in different order for different wireframe mode
	*   - same step as above but then fill the triangles with barycentric algorithm (find bounding box of triangle, step through X/Y and check wether we are in or out)
	*     we will have flat shading at low resolution but... it also pave the road to the easy application of more complex shading algorithms or texturing!! an important step is also to
	*     check shaded point distance against a Z buffer to remove hidden surfaces
	*
	* Note : When filling polygon we give a step of more than 1 and increase the size of the ""rect"" primitive, this allow fast rendering at the price of huge quality lost
	*        but if you are doing it non-realtime you would increase subdivision to the point of each triangles being 1px, the flat shading would suddenly be smooth shading! :)
	*
	* How can this be improved ?
	*  - add texturing
	*  - fill quads instead of triangles
	*  - add more parametric surfaces and especially more generic surfaces
	*  - add shading algorithms (phong etc.)
	*  - play with volumetric data :)
	*  - adaptative subdivision ?
	*  - parallelization
	*  - cleanup of the sides checking
	*  - non-realtime render to obtain high quality images (when subdivision is low)
	*/

int frame = 0;

static float cs = 580; // also scale :P
static float inc = 0.5; // control surface subdivision, lower = higher quality (but too slow for realtime)
static float csi = 1.0 / inc; // how much points our surface will have along a specific axis
static float scale = 1.0 / 8.0; // cube scale

PGraphics depthbuffer;

void setup() {
  size(1024, 768);

  background(0);
	
	noStroke();
	
	depthbuffer = createGraphics(width, height);
	depthbuffer.noStroke();
}

void fillTriangle(float x1, float y1,
									float x2, float y2,
									float x3, float y3, int shading) {
	int maxX = max(x1, max(x2, x3));
	int minX = min(x1, min(x2, x3));
	int maxY = max(y1, max(y2, y3));
	int minY = min(y1, min(y2, y3));
	
	float vs1x = x2 - x1;
	float vs1y = y2 - y1;
	float vs2x = x3 - x1;
	float vs2y = y3 - y1;

	for (float x = minX; x <= maxX; x += 4) {
  	for (float y = minY; y <= maxY; y += 4) {
			float qx = x - x1;
			float qy = y - y1;
			
			float s = (qx * vs2y - vs2x * qy) / (vs1x * vs2y - vs2x * vs1y);
			float t = (vs1x * qy - qx * vs1y) / (vs1x * vs2y - vs2x * vs1y);

			if ( (s >= 0) && (t >= 0) && (s + t <= 1)) {
				// check against Z buffer!
				if (shading >= brightness(depthbuffer.get(x, y))) {
					// depth value go into depth buffer
					depthbuffer.beginDraw();
					depthbuffer.fill(shading, shading, shading);
					depthbuffer.rect(x, y, 4, 4);
					depthbuffer.endDraw();
					
					rect(x, y, 4, 4);
				}
			}
		}
	}
}

void draw() {
	// clear z-buffer
	depthbuffer.beginDraw();
	depthbuffer.background(0);
	depthbuffer.endDraw();
	
  background(0);
	//fill(0, 0, 0, 48);
	//rect(0, 0, width, height);
	
	float rxa = 0.03 * frame;
	float rya = 0.04 * frame;

	// rotation values
	float crx = cos(rxa);
	float cry = cos(rya);
	float srx = sin(rxa);
	float sry = sin(rya);
	
	// rm = rotation matrix
	float[] rm = {0,0,0,0,0,0,0,0,0};

	rm[0] = cry;     /*rm[1] = 0.0f;*/ rm[2] = -sry;
	rm[3] = sry * srx; rm[4] = crx;    rm[5] = cry * srx;
	rm[6] = sry * crx; rm[7] = -srx;   rm[8] = cry * crx;
	
	int x2 = width / 2;
	int y2 = height / 2;
	
	// step cube volume along X,Y,Z in normalized space
	float x, y, z;
	for (z = 0.0; z <= 1.0; z += inc) {
		float[] vr = {0,0,0};

		float pz = 2.0 * z - 1.0; // normalize screen space

		vr[2] = pz * scale;
		for (y = 0.0; y <= 1.0; y += inc) {
			float py = 2.0 * y - 1.0;

			vr[1] = py * scale;
			for (x = 0.0; x <= 1.0; x += inc) {
				// filter volumetric data (eg. we only want the points on the surface)
				if (x > 0.0 && x < (1.0 - inc) && y > 0.0 && y < (1.0 - inc) && z > 0.0 && z < (1.0 - inc)) continue;
				
				float px = (2.0 * x - 1.0);
				
				vr[0] = px * scale;

				// rotate/transform our points
				float[] vrr = {
						rm[0] * vr[0] + rm[3] * vr[1] + rm[6] * vr[2],
						rm[1] * vr[0] + rm[4] * vr[1] + rm[7] * vr[2],
						rm[2] * vr[0] + rm[5] * vr[1] + rm[8] * vr[2]
				};
			
				// compute length & normalize
				float le = sqrt((vrr[0] * vrr[0]) + (vrr[1] * vrr[1]) + (vrr[2] * vrr[2]));
			  float[] vrn = { vrr[0] / le, vrr[1] / le, vrr[2] / le };

				// point shade based on normalized Z value
			  int shading = vrn[2] * 255;
				//fill(shading, shading, shading);

				// since we were in normalized space we scale it to screen space and translate it at the center of the screen
				float posx = x2 - (int)(vrr[0] * cs);
				float posy = y2 - (int)(vrr[1] * cs);
		
				// draw cube surface
				float px2 = (2.0 * (x + inc) - 1.0);
				float pxs = px2 * scale;
				float py2 = (2.0 * (y + inc) - 1.0);
				float pys = py2 * scale;
				float pz2 = (2.0 * (z + inc) - 1.0);
				float pzs = pz2 * scale;
		
				float posx2; float posy2;
				float posx3; float posy3;
				float posx4; float posy4;
				
				// cube side detection & polygons drawing
				// note : could be optimized into much shorted code...
				if (y >= 0.0 && y <= (1.0 - inc) &&
						z >= 0.0 && z <= (1.0 - inc) &&
					  (x >= 0.99 || x <= 0.0)) {
					float[] vrr2 = {
							rm[0] * vr[0] + rm[3] * vr[1] + rm[6] * pzs,
							rm[1] * vr[0] + rm[4] * vr[1] + rm[7] * pzs,
							rm[2] * vr[0] + rm[5] * vr[1] + rm[8] * pzs
					};
		
					float[] vrr3 = {
							rm[0] * vr[0] + rm[3] * pys + rm[6] * pzs,
							rm[1] * vr[0] + rm[4] * pys + rm[7] * pzs,
							rm[2] * vr[0] + rm[5] * pys + rm[8] * pzs
					};
	
					float[] vrr4 = {
							rm[0] * vr[0] + rm[3] * pys + rm[6] * vr[2],
							rm[1] * vr[0] + rm[4] * pys + rm[7] * vr[2],
							rm[2] * vr[0] + rm[5] * pys + rm[8] * vr[2]
					};
		
					posx2 = x2 - (int)(vrr2[0] * cs);
					posy2 = y2 - (int)(vrr2[1] * cs);
					posx3 = x2 - (int)(vrr3[0] * cs);
					posy3 = y2 - (int)(vrr3[1] * cs);
					posx4 = x2 - (int)(vrr4[0] * cs);
					posy4 = y2 - (int)(vrr4[1] * cs);
/*
					// wireframe
					stroke(shading, shading, shading);
					line(posx, posy, posx2, posy2);
					line(posx2, posy2, posx3, posy3);
					line(posx3, posy3, posx, posy);

					stroke(shading, 0, 0);
					line(posx, posy, posx4, posy4);
					line(posx4, posy4, posx3, posy3);
					line(posx3, posy3, posx, posy);
*/
					noStroke();
					fill(shading, shading, shading);
					fillTriangle(posx, posy, posx2, posy2, posx3, posy3, shading);
					fillTriangle(posx, posy, posx4, posy4, posx3, posy3, shading);
					noFill();
				}
				
				if (x >= 0.0 && x <= (1.0 - inc) &&
									 y >= 0.0 && y <= (1.0 - inc) &&
									 (z >= 0.99 || z <= 0.0)) {
					float[] vrr2 = {
							rm[0] * pxs + rm[3] * vr[1] + rm[6] * vr[2],
							rm[1] * pxs + rm[4] * vr[1] + rm[7] * vr[2],
							rm[2] * pxs + rm[5] * vr[1] + rm[8] * vr[2]
					};
		
					float[] vrr3 = {
							rm[0] * pxs + rm[3] * pys + rm[6] * vr[2],
							rm[1] * pxs + rm[4] * pys + rm[7] * vr[2],
							rm[2] * pxs + rm[5] * pys + rm[8] * vr[2]
					};
	
					float[] vrr4 = {
							rm[0] * vr[0] + rm[3] * pys + rm[6] * vr[2],
							rm[1] * vr[0] + rm[4] * pys + rm[7] * vr[2],
							rm[2] * vr[0] + rm[5] * pys + rm[8] * vr[2]
					};
		
					posx2 = x2 - (int)(vrr2[0] * cs);
					posy2 = y2 - (int)(vrr2[1] * cs);
					posx3 = x2 - (int)(vrr3[0] * cs);
					posy3 = y2 - (int)(vrr3[1] * cs);
					posx4 = x2 - (int)(vrr4[0] * cs);
					posy4 = y2 - (int)(vrr4[1] * cs);
/*
					// wireframe
					stroke(shading, shading, shading);
					line(posx, posy, posx2, posy2);
					line(posx2, posy2, posx3, posy3);
					line(posx3, posy3, posx, posy);

					stroke(shading, 0, 0);
					line(posx, posy, posx4, posy4);
					line(posx4, posy4, posx3, posy3);
					line(posx3, posy3, posx, posy);
*/
					noStroke();
					fill(shading, shading, shading);
					fillTriangle(posx, posy, posx2, posy2, posx3, posy3, shading);
					fillTriangle(posx, posy, posx4, posy4, posx3, posy3, shading);
					noFill();
				}
				
				if (x >= 0.0 && x <= (1.0 - inc) &&
									 z >= 0.0 && z <= (1.0 - inc) &&
									 (y >= 0.99 || y <= 0.0)) {
					float[] vrr2 = {
							rm[0] * pxs + rm[3] * vr[1] + rm[6] * vr[2],
							rm[1] * pxs + rm[4] * vr[1] + rm[7] * vr[2],
							rm[2] * pxs + rm[5] * vr[1] + rm[8] * vr[2]
					};
		
					float[] vrr3 = {
							rm[0] * pxs + rm[3] * vr[1] + rm[6] * pzs,
							rm[1] * pxs + rm[4] * vr[1] + rm[7] * pzs,
							rm[2] * pxs + rm[5] * vr[1] + rm[8] * pzs
					};
	
					float[] vrr4 = {
							rm[0] * vr[0] + rm[3] * vr[1] + rm[6] * pzs,
							rm[1] * vr[0] + rm[4] * vr[1] + rm[7] * pzs,
							rm[2] * vr[0] + rm[5] * vr[1] + rm[8] * pzs
					};
		
					posx2 = x2 - (int)(vrr2[0] * cs);
					posy2 = y2 - (int)(vrr2[1] * cs);
					posx3 = x2 - (int)(vrr3[0] * cs);
					posy3 = y2 - (int)(vrr3[1] * cs);
					posx4 = x2 - (int)(vrr4[0] * cs);
					posy4 = y2 - (int)(vrr4[1] * cs);
/*
					// wireframe
					stroke(shading, shading, shading);
					line(posx, posy, posx2, posy2);
					line(posx2, posy2, posx3, posy3);
					line(posx3, posy3, posx, posy);

					stroke(shading, 0, 0);
					line(posx, posy, posx4, posy4);
					line(posx4, posy4, posx3, posy3);
					line(posx3, posy3, posx, posy);
*/
					noStroke();
					fill(shading, shading, shading);
					fillTriangle(posx, posy, posx2, posy2, posx3, posy3, shading);
					fillTriangle(posx, posy, posx4, posy4, posx3, posy3, shading);
					noFill();
				}
				
				// no z-buffer, optimized filling
				//quad(posx, posy, posx2, posy2, posx3, posy3, posx4, posy4);

				// points only
				//fill(255, 0, 0);
				//ellipse(posx, posy, 2, 2);
			}
		}
	}
	
	// display z buffer
	//image(depthbuffer, 0, 0);

	frame += 1;
}"
"649334","REYES rasterization","mySketch","int f = 0;

float[] displaceX;
float[] displaceY;
float[] displaceZ;

static float cs = 580;
static float inc = 1.0 / (cs / 32.0);
static float csi = 1.0 / inc;
static float scale = 1.0 / 8.0;

void setup() {
  size(1024, 768);

  background(0);
	
	noStroke();
	
	randomSeed(0);
	
	displaceX = new float[(int)csi];
	displaceY = new float[(int)csi];
	displaceZ = new float[(int)csi];
	
	for (int i = 0; i <= (int)csi; i += 1) {
		displaceX[i] = random(-1, 1) / 64;
		displaceY[i] = random(-1, 1) / 64;
		displaceZ[i] = random(-1, 1) / 64;
	}
}

void draw() {
  background(0);
	//fill(0, 0, 0, 48);
	//rect(0, 0, width, height);
	
	float rxa = 0.03 * f;
	float rya = 0.04 * f;

	float crx = cos(rxa);
	float cry = cos(rya);
	float srx = sin(rxa);
	float sry = sin(rya);
	
	float[] rm = {0,0,0,0,0,0,0,0,0};

	rm[0] = cry;     /*rm[1] = 0.0f;*/ rm[2] = -sry;
	rm[3] = sry * srx; rm[4] = crx;    rm[5] = cry * srx;
	rm[6] = sry * crx; rm[7] = -srx;   rm[8] = cry * crx;
	
	int x2 = width / 2;
	int y2 = height / 2;
	
	for (z = 0.0; z < 1.0; z += inc) {
		float[] vr = {0,0,0};

		float pz = 2.0 * z - 1.0;

		vr[2] = pz * scale;
		for (y = 0.0; y < 1.0; y += inc) {
			float py = 2.0 * y - 1.0;

			vr[1] = py * scale;
			for (x = 0.0; x < 1.0; x += inc) {
				float px = (2.0 * x - 1.0);

				if (x > 0.0 && x < (1.0 - inc) && y > 0.0 && y < (1.0 - inc) && z > 0.0 && z < (1.0 - inc)) continue;

				vr[0] = px * scale;

				// rotate, rm is rotation matrix
				float[] vrr = {
						rm[0] * vr[0] + rm[3] * vr[1] + rm[6] * vr[2],
						rm[1] * vr[0] + rm[4] * vr[1] + rm[7] * vr[2],
						rm[2] * vr[0] + rm[5] * vr[1] + rm[8] * vr[2]
				};
			
				float le = sqrt((vrr[0] * vrr[0]) + (vrr[1] * vrr[1]) + (vrr[2] * vrr[2]));
			  float[] vrn = { vrr[0] / le, vrr[1] / le, vrr[2] / le };

			  int shading = vrn[2] * 255;

				fill(shading, shading, shading);

				rect((x2 - (int)(vrr[0] * cs) ), (y2 - (int)(vrr[1] * cs)), 2, 2);
			}
		}
	}

f += 1;
}"
"649334","REYES rasterization","mySketch","int f = 0;

float[] displaceX;
float[] displaceY;
float[] displaceZ;

static float cs = 580;
static float inc = 1.0 / (cs / 64.0);
static float csi = 1.0 / inc;
static float scale = 1.0 / 8.0;

void setup() {
  size(1024, 768);

  background(0);
	
	noStroke();
	
	randomSeed(0);
	
	displaceX = new float[(int)csi];
	displaceY = new float[(int)csi];
	displaceZ = new float[(int)csi];
	
	for (int i = 0; i <= (int)csi; i += 1) {
		displaceX[i] = random(-1, 1) / 64;
		displaceY[i] = random(-1, 1) / 64;
		displaceZ[i] = random(-1, 1) / 64;
	}
}

void draw() {
  background(0);
	//fill(0, 0, 0, 48);
	//rect(0, 0, width, height);
	
	float rxa = 0.03 * f;
	float rya = 0.04 * f;

	float crx = cos(rxa);
	float cry = cos(rya);
	float srx = sin(rxa);
	float sry = sin(rya);
	
	float[] rm = {0,0,0,0,0,0,0,0,0};

	rm[0] = cry;     /*rm[1] = 0.0f;*/ rm[2] = -sry;
	rm[3] = sry * srx; rm[4] = crx;    rm[5] = cry * srx;
	rm[6] = sry * crx; rm[7] = -srx;   rm[8] = cry * crx;
	
	int x2 = width / 2;
	int y2 = height / 2;
	
	for (z = 0.0; z < 1.0; z += inc) {
		float[] vr = {0,0,0};

		float pz = 2.0 * z - 1.0;

		vr[2] = pz * scale;
		for (y = 0.0; y < 1.0; y += inc) {
			float py = 2.0 * y - 1.0;

			vr[1] = py * scale;
			for (x = 0.0; x < 1.0; x += inc) {
				float px = (2.0 * x - 1.0);

				// filter volumetric data (eg. cube edges only)
				if (x > 0.0 && x < (1.0 - inc) && y > 0.0 && y < (1.0 - inc) && z > 0.0 && z < (1.0 - inc)) continue;

				vr[0] = px * scale;

				// rotate, rm is rotation matrix
				float[] vrr = {
						rm[0] * vr[0] + rm[3] * vr[1] + rm[6] * vr[2],
						rm[1] * vr[0] + rm[4] * vr[1] + rm[7] * vr[2],
						rm[2] * vr[0] + rm[5] * vr[1] + rm[8] * vr[2]
				};
			
				// compute length & normalize
				float le = sqrt((vrr[0] * vrr[0]) + (vrr[1] * vrr[1]) + (vrr[2] * vrr[2]));
			  float[] vrn = { vrr[0] / le, vrr[1] / le, vrr[2] / le };

			  int shading = vrn[2] * 255; // shade based on depth value

				fill(shading, shading, shading);

				int x = x2 - (int)(vrr[0] * cs);
				int y = y2 - (int)(vrr[1] * cs);
		
				rect(x, y, 2, 2);
			}
		}
	}

f += 1;
}"
"649334","REYES rasterization","mySketch","int f = 0;

float[] displaceX;
float[] displaceY;
float[] displaceZ;

static float cs = 580;
static float inc = 1.0 / (cs / 64.0);
static float csi = 1.0 / inc;
static float scale = 1.0 / 8.0;

void setup() {
  size(1024, 768);

  background(0);
	
	noStroke();
	
	randomSeed(0);
	
	displaceX = new float[(int)csi];
	displaceY = new float[(int)csi];
	displaceZ = new float[(int)csi];
	
	for (int i = 0; i <= (int)csi; i += 1) {
		displaceX[i] = random(-1, 1) / 64;
		displaceY[i] = random(-1, 1) / 64;
		displaceZ[i] = random(-1, 1) / 64;
	}
}

void draw() {
  background(0);
	//fill(0, 0, 0, 48);
	//rect(0, 0, width, height);
	
	float rxa = 0.03 * f;
	float rya = 0.04 * f;

	float crx = cos(rxa);
	float cry = cos(rya);
	float srx = sin(rxa);
	float sry = sin(rya);
	
	float[] rm = {0,0,0,0,0,0,0,0,0};

	rm[0] = cry;     /*rm[1] = 0.0f;*/ rm[2] = -sry;
	rm[3] = sry * srx; rm[4] = crx;    rm[5] = cry * srx;
	rm[6] = sry * crx; rm[7] = -srx;   rm[8] = cry * crx;
	
	int x2 = width / 2;
	int y2 = height / 2;
	
	for (z = 0.0; z < 1.0; z += inc) {
		float[] vr = {0,0,0};

		float pz = 2.0 * z - 1.0;

		vr[2] = pz * scale;
		for (y = 0.0; y < 1.0; y += inc) {
			float py = 2.0 * y - 1.0;

			vr[1] = py * scale;
			for (x = 0.0; x < 1.0; x += inc) {
				float px = (2.0 * x - 1.0);
				
				vr[0] = px * scale;

				// filter volumetric data (eg. cube edges only)
				if (x > 0.0 && x < (1.0 - inc) && y > 0.0 && y < (1.0 - inc) && z > 0.0 && z < (1.0 - inc)) continue;

				// rotate, rm is rotation matrix
				float[] vrr = {
						rm[0] * vr[0] + rm[3] * vr[1] + rm[6] * vr[2],
						rm[1] * vr[0] + rm[4] * vr[1] + rm[7] * vr[2],
						rm[2] * vr[0] + rm[5] * vr[1] + rm[8] * vr[2]
				};
			
				// compute length & normalize
				float le = sqrt((vrr[0] * vrr[0]) + (vrr[1] * vrr[1]) + (vrr[2] * vrr[2]));
			  float[] vrn = { vrr[0] / le, vrr[1] / le, vrr[2] / le };

				// shade based on normalized Z value
			  int shading = vrn[2] * 255;
				fill(shading, shading, shading);

				// since we were in normalized space we scale it to screen space and translate it at the center of the screen
				int x = x2 - (int)(vrr[0] * cs);
				int y = y2 - (int)(vrr[1] * cs);
		
				rect(x, y, 2, 2);
			}
		}
	}

f += 1;
}"
"649334","REYES rasterization","mySketch","int f = 0;

float[] displaceX;
float[] displaceY;
float[] displaceZ;

static float cs = 580;
static float inc = 1.0 / (cs / 64.0);
static float csi = 1.0 / inc;
static float scale = 1.0 / 8.0;

void setup() {
  size(1024, 768);

  background(0);
	
	noStroke();
	
	randomSeed(0);
	
	displaceX = new float[(int)csi];
	displaceY = new float[(int)csi];
	displaceZ = new float[(int)csi];
	
	for (int i = 0; i <= (int)csi; i += 1) {
		displaceX[i] = random(-1, 1) / 64;
		displaceY[i] = random(-1, 1) / 64;
		displaceZ[i] = random(-1, 1) / 64;
	}
}

void draw() {
  background(0);
	//fill(0, 0, 0, 48);
	//rect(0, 0, width, height);
	
	float rxa = 0.03 * f;
	float rya = 0.04 * f;

	float crx = cos(rxa);
	float cry = cos(rya);
	float srx = sin(rxa);
	float sry = sin(rya);
	
	float[] rm = {0,0,0,0,0,0,0,0,0};

	rm[0] = cry;     /*rm[1] = 0.0f;*/ rm[2] = -sry;
	rm[3] = sry * srx; rm[4] = crx;    rm[5] = cry * srx;
	rm[6] = sry * crx; rm[7] = -srx;   rm[8] = cry * crx;
	
	int x2 = width / 2;
	int y2 = height / 2;
	
	for (z = 0.0; z < 1.0; z += inc) {
		float[] vr = {0,0,0};

		float pz = 2.0 * z - 1.0;

		vr[2] = pz * scale;
		for (y = 0.0; y < 1.0; y += inc) {
			float py = 2.0 * y - 1.0;

			vr[1] = py * scale;
			for (x = 0.0; x < 1.0; x += inc) {
				float px = (2.0 * x - 1.0);
				
				vr[0] = px * scale;

				// filter volumetric data (eg. cube edges only)
				if (x > 0.0 && x < (1.0 - inc) && y > 0.0 && y < (1.0 - inc) && z > 0.0 && z < (1.0 - inc)) continue;

				// rotate, rm is rotation matrix
				float[] vrr = {
						rm[0] * vr[0] + rm[3] * vr[1] + rm[6] * vr[2],
						rm[1] * vr[0] + rm[4] * vr[1] + rm[7] * vr[2],
						rm[2] * vr[0] + rm[5] * vr[1] + rm[8] * vr[2]
				};
			
				// compute length & normalize
				float le = sqrt((vrr[0] * vrr[0]) + (vrr[1] * vrr[1]) + (vrr[2] * vrr[2]));
			  float[] vrn = { vrr[0] / le, vrr[1] / le, vrr[2] / le };

				// shade based on normalized Z value
			  int shading = vrn[2] * 255;
				fill(shading, shading, shading);

				// since we were in normalized space we scale it to screen space and translate it at the center of the screen
				int x = x2 - (int)(vrr[0] * cs);
				int y = y2 - (int)(vrr[1] * cs);
		
				rect(x, y, 2, 2);
			}
		}
	}

	f += 1;
}"
"649334","REYES rasterization","mySketch","int frame = 0;

float[] displaceX;
float[] displaceY;
float[] displaceZ;

static float cs = 580;
static float inc = 1.0 / (cs / 64.0);
static float csi = 1.0 / inc;
static float scale = 1.0 / 8.0;

void setup() {
  size(1024, 768);

  background(0);
	
	noStroke();
	
	randomSeed(0);
	
	displaceX = new float[(int)csi];
	displaceY = new float[(int)csi];
	displaceZ = new float[(int)csi];
	
	for (int i = 0; i <= (int)csi; i += 1) {
		displaceX[i] = random(-1, 1) / 64;
		displaceY[i] = random(-1, 1) / 64;
		displaceZ[i] = random(-1, 1) / 64;
	}
}

void draw() {
  background(0);
	//fill(0, 0, 0, 48);
	//rect(0, 0, width, height);
	
	float rxa = 0.03 * frame;
	float rya = 0.04 * frame;

	float crx = cos(rxa);
	float cry = cos(rya);
	float srx = sin(rxa);
	float sry = sin(rya);
	
	float[] rm = {0,0,0,0,0,0,0,0,0};

	rm[0] = cry;     /*rm[1] = 0.0f;*/ rm[2] = -sry;
	rm[3] = sry * srx; rm[4] = crx;    rm[5] = cry * srx;
	rm[6] = sry * crx; rm[7] = -srx;   rm[8] = cry * crx;
	
	int x2 = width / 2;
	int y2 = height / 2;
	
	for (z = 0.0; z < 1.0; z += inc) {
		float[] vr = {0,0,0};

		float pz = 2.0 * z - 1.0;

		vr[2] = pz * scale;
		for (y = 0.0; y < 1.0; y += inc) {
			float py = 2.0 * y - 1.0;

			vr[1] = py * scale;
			for (x = 0.0; x < 1.0; x += inc) {
				float px = (2.0 * x - 1.0);
				
				vr[0] = px * scale;

				// filter volumetric data (eg. cube edges only)
				if (x > 0.0 && x < (1.0 - inc) && y > 0.0 && y < (1.0 - inc) && z > 0.0 && z < (1.0 - inc)) continue;

				// rotate, rm is rotation matrix
				float[] vrr = {
						rm[0] * vr[0] + rm[3] * vr[1] + rm[6] * vr[2],
						rm[1] * vr[0] + rm[4] * vr[1] + rm[7] * vr[2],
						rm[2] * vr[0] + rm[5] * vr[1] + rm[8] * vr[2]
				};
			
				// compute length & normalize
				float le = sqrt((vrr[0] * vrr[0]) + (vrr[1] * vrr[1]) + (vrr[2] * vrr[2]));
			  float[] vrn = { vrr[0] / le, vrr[1] / le, vrr[2] / le };

				// shade based on normalized Z value
			  int shading = vrn[2] * 255;
				fill(shading, shading, shading);

				// since we were in normalized space we scale it to screen space and translate it at the center of the screen
				int x = x2 - (int)(vrr[0] * cs);
				int y = y2 - (int)(vrr[1] * cs);
		
				rect(x, y, 2, 2);
			}
		}
	}

	frame += 1;
}"
"649334","REYES rasterization","mySketch","int frame = 0;

float[] displaceX;
float[] displaceY;
float[] displaceZ;

static float cs = 580;
static float inc = 1.0 / (cs / 64.0);
static float csi = 1.0 / inc;
static float scale = 1.0 / 8.0;

void setup() {
  size(1024, 768);

  background(0);
	
	noStroke();
	
	randomSeed(0);
	
	displaceX = new float[(int)csi];
	displaceY = new float[(int)csi];
	displaceZ = new float[(int)csi];
	
	for (int i = 0; i <= (int)csi; i += 1) {
		displaceX[i] = random(-1, 1) / 64;
		displaceY[i] = random(-1, 1) / 64;
		displaceZ[i] = random(-1, 1) / 64;
	}
}

void draw() {
  background(0);
	//fill(0, 0, 0, 48);
	//rect(0, 0, width, height);
	
	float rxa = 0.03 * frame;
	float rya = 0.04 * frame;

	float crx = cos(rxa);
	float cry = cos(rya);
	float srx = sin(rxa);
	float sry = sin(rya);
	
	// rm = rotation matrix
	float[] rm = {0,0,0,0,0,0,0,0,0};

	rm[0] = cry;     /*rm[1] = 0.0f;*/ rm[2] = -sry;
	rm[3] = sry * srx; rm[4] = crx;    rm[5] = cry * srx;
	rm[6] = sry * crx; rm[7] = -srx;   rm[8] = cry * crx;
	
	int x2 = width / 2;
	int y2 = height / 2;
	
	for (z = 0.0; z < 1.0; z += inc) {
		float[] vr = {0,0,0};

		float pz = 2.0 * z - 1.0;

		vr[2] = pz * scale;
		for (y = 0.0; y < 1.0; y += inc) {
			float py = 2.0 * y - 1.0;

			vr[1] = py * scale;
			for (x = 0.0; x < 1.0; x += inc) {
				float px = (2.0 * x - 1.0);
				
				vr[0] = px * scale;

				// filter volumetric data (eg. cube edges only)
				if (x > 0.0 && x < (1.0 - inc) && y > 0.0 && y < (1.0 - inc) && z > 0.0 && z < (1.0 - inc)) continue;

				// rotate our points
				float[] vrr = {
						rm[0] * vr[0] + rm[3] * vr[1] + rm[6] * vr[2],
						rm[1] * vr[0] + rm[4] * vr[1] + rm[7] * vr[2],
						rm[2] * vr[0] + rm[5] * vr[1] + rm[8] * vr[2]
				};
			
				// compute length & normalize
				float le = sqrt((vrr[0] * vrr[0]) + (vrr[1] * vrr[1]) + (vrr[2] * vrr[2]));
			  float[] vrn = { vrr[0] / le, vrr[1] / le, vrr[2] / le };

				// shade based on normalized Z value
			  int shading = vrn[2] * 255;
				fill(shading, shading, shading);

				// since we were in normalized space we scale it to screen space and translate it at the center of the screen
				int x = x2 - (int)(vrr[0] * cs);
				int y = y2 - (int)(vrr[1] * cs);
		
				rect(x, y, 2, 2);
			}
		}
	}

	frame += 1;
}"
"649334","REYES rasterization","mySketch","int frame = 0;

float[] displaceX;
float[] displaceY;
float[] displaceZ;

static float cs = 580;
static float inc = 1.0 / (cs / 64.0);
static float csi = 1.0 / inc;
static float scale = 1.0 / 8.0;

void setup() {
  size(1024, 768);

  background(0);
	
	noStroke();
	
	randomSeed(0);
	
	displaceX = new float[(int)csi];
	displaceY = new float[(int)csi];
	displaceZ = new float[(int)csi];
	
	for (int i = 0; i <= (int)csi; i += 1) {
		displaceX[i] = random(-1, 1) / 64;
		displaceY[i] = random(-1, 1) / 64;
		displaceZ[i] = random(-1, 1) / 64;
	}
}

void draw() {
  background(0);
	//fill(0, 0, 0, 48);
	//rect(0, 0, width, height);
	
	float rxa = 0.03 * frame;
	float rya = 0.04 * frame;

	// rotation values
	float crx = cos(rxa);
	float cry = cos(rya);
	float srx = sin(rxa);
	float sry = sin(rya);
	
	// rm = rotation matrix
	float[] rm = {0,0,0,0,0,0,0,0,0};

	rm[0] = cry;     /*rm[1] = 0.0f;*/ rm[2] = -sry;
	rm[3] = sry * srx; rm[4] = crx;    rm[5] = cry * srx;
	rm[6] = sry * crx; rm[7] = -srx;   rm[8] = cry * crx;
	
	int x2 = width / 2;
	int y2 = height / 2;
	
	for (z = 0.0; z < 1.0; z += inc) {
		float[] vr = {0,0,0};

		float pz = 2.0 * z - 1.0;

		vr[2] = pz * scale;
		for (y = 0.0; y < 1.0; y += inc) {
			float py = 2.0 * y - 1.0;

			vr[1] = py * scale;
			for (x = 0.0; x < 1.0; x += inc) {
				float px = (2.0 * x - 1.0);
				
				vr[0] = px * scale;

				// filter volumetric data (eg. cube edges only)
				if (x > 0.0 && x < (1.0 - inc) && y > 0.0 && y < (1.0 - inc) && z > 0.0 && z < (1.0 - inc)) continue;

				// rotate our points
				float[] vrr = {
						rm[0] * vr[0] + rm[3] * vr[1] + rm[6] * vr[2],
						rm[1] * vr[0] + rm[4] * vr[1] + rm[7] * vr[2],
						rm[2] * vr[0] + rm[5] * vr[1] + rm[8] * vr[2]
				};
			
				// compute length & normalize
				float le = sqrt((vrr[0] * vrr[0]) + (vrr[1] * vrr[1]) + (vrr[2] * vrr[2]));
			  float[] vrn = { vrr[0] / le, vrr[1] / le, vrr[2] / le };

				// shade based on normalized Z value
			  int shading = vrn[2] * 255;
				fill(shading, shading, shading);

				// since we were in normalized space we scale it to screen space and translate it at the center of the screen
				int x = x2 - (int)(vrr[0] * cs);
				int y = y2 - (int)(vrr[1] * cs);
		
				rect(x, y, 2, 2);
			}
		}
	}

	frame += 1;
}"
"649334","REYES rasterization","mySketch","int frame = 0;

float[] displaceX;
float[] displaceY;
float[] displaceZ;

static float cs = 580;
static float inc = 1.0 / (cs / 64.0);
static float csi = 1.0 / inc;
static float scale = 1.0 / 8.0;

void setup() {
  size(1024, 768);

  background(0);
	
	noStroke();
	
	randomSeed(0);
	
	displaceX = new float[(int)csi];
	displaceY = new float[(int)csi];
	displaceZ = new float[(int)csi];
	
	for (int i = 0; i <= (int)csi; i += 1) {
		displaceX[i] = random(-1, 1) / 64;
		displaceY[i] = random(-1, 1) / 64;
		displaceZ[i] = random(-1, 1) / 64;
	}
}

void draw() {
  background(0);
	//fill(0, 0, 0, 48);
	//rect(0, 0, width, height);
	
	float rxa = 0.03 * frame;
	float rya = 0.04 * frame;

	// rotation values
	float crx = cos(rxa);
	float cry = cos(rya);
	float srx = sin(rxa);
	float sry = sin(rya);
	
	// rm = rotation matrix
	float[] rm = {0,0,0,0,0,0,0,0,0};

	rm[0] = cry;     /*rm[1] = 0.0f;*/ rm[2] = -sry;
	rm[3] = sry * srx; rm[4] = crx;    rm[5] = cry * srx;
	rm[6] = sry * crx; rm[7] = -srx;   rm[8] = cry * crx;
	
	int x2 = width / 2;
	int y2 = height / 2;
	
	for (z = 0.0; z < 1.0; z += inc) {
		float[] vr = {0,0,0};

		float pz = 2.0 * z - 1.0;

		vr[2] = pz * scale;
		for (y = 0.0; y < 1.0; y += inc) {
			float py = 2.0 * y - 1.0;

			vr[1] = py * scale;
			for (x = 0.0; x < 1.0; x += inc) {
				// filter volumetric data (eg. we only want the points on the surface)
				if (x > 0.0 && x < (1.0 - inc) && y > 0.0 && y < (1.0 - inc) && z > 0.0 && z < (1.0 - inc)) continue;
				
				float px = (2.0 * x - 1.0);
				
				vr[0] = px * scale;

				// rotate our points
				float[] vrr = {
						rm[0] * vr[0] + rm[3] * vr[1] + rm[6] * vr[2],
						rm[1] * vr[0] + rm[4] * vr[1] + rm[7] * vr[2],
						rm[2] * vr[0] + rm[5] * vr[1] + rm[8] * vr[2]
				};
			
				// compute length & normalize
				float le = sqrt((vrr[0] * vrr[0]) + (vrr[1] * vrr[1]) + (vrr[2] * vrr[2]));
			  float[] vrn = { vrr[0] / le, vrr[1] / le, vrr[2] / le };

				// shade based on normalized Z value
			  int shading = vrn[2] * 255;
				fill(shading, shading, shading);

				// since we were in normalized space we scale it to screen space and translate it at the center of the screen
				int x = x2 - (int)(vrr[0] * cs);
				int y = y2 - (int)(vrr[1] * cs);
		
				rect(x, y, 2, 2);
			}
		}
	}

	frame += 1;
}"
"649334","REYES rasterization","mySketch","int frame = 0;

float[] displaceX;
float[] displaceY;
float[] displaceZ;

static float cs = 580;
static float inc = 1.0 / (cs / 64.0);
static float csi = 1.0 / inc;
static float scale = 1.0 / 8.0;

void setup() {
  size(1024, 768);

  background(0);
	
	noStroke();
	
	randomSeed(0);
	
	displaceX = new float[(int)csi];
	displaceY = new float[(int)csi];
	displaceZ = new float[(int)csi];
	
	for (int i = 0; i <= (int)csi; i += 1) {
		displaceX[i] = random(-1, 1) / 64;
		displaceY[i] = random(-1, 1) / 64;
		displaceZ[i] = random(-1, 1) / 64;
	}
}

void draw() {
  background(0);
	//fill(0, 0, 0, 48);
	//rect(0, 0, width, height);
	
	float rxa = 0.03 * frame;
	float rya = 0.04 * frame;

	// rotation values
	float crx = cos(rxa);
	float cry = cos(rya);
	float srx = sin(rxa);
	float sry = sin(rya);
	
	// rm = rotation matrix
	float[] rm = {0,0,0,0,0,0,0,0,0};

	rm[0] = cry;     /*rm[1] = 0.0f;*/ rm[2] = -sry;
	rm[3] = sry * srx; rm[4] = crx;    rm[5] = cry * srx;
	rm[6] = sry * crx; rm[7] = -srx;   rm[8] = cry * crx;
	
	int x2 = width / 2;
	int y2 = height / 2;
	
	for (z = 0.0; z < 1.0; z += inc) {
		float[] vr = {0,0,0};

		float pz = 2.0 * z - 1.0;

		vr[2] = pz * scale;
		for (y = 0.0; y < 1.0; y += inc) {
			float py = 2.0 * y - 1.0;

			vr[1] = py * scale;
			for (x = 0.0; x < 1.0; x += inc) {
				// filter volumetric data (eg. we only want the points on the surface)
				if (x > 0.0 && x < (1.0 - inc) && y > 0.0 && y < (1.0 - inc) && z > 0.0 && z < (1.0 - inc)) continue;
				
				float px = (2.0 * x - 1.0);
				
				vr[0] = px * scale;

				// rotate our points
				float[] vrr = {
						rm[0] * vr[0] + rm[3] * vr[1] + rm[6] * vr[2],
						rm[1] * vr[0] + rm[4] * vr[1] + rm[7] * vr[2],
						rm[2] * vr[0] + rm[5] * vr[1] + rm[8] * vr[2]
				};
			
				// compute length & normalize
				float le = sqrt((vrr[0] * vrr[0]) + (vrr[1] * vrr[1]) + (vrr[2] * vrr[2]));
			  float[] vrn = { vrr[0] / le, vrr[1] / le, vrr[2] / le };

				// shade based on normalized Z value
			  int shading = vrn[2] * 255;
				fill(shading, shading, shading);

				// since we were in normalized space we scale it to screen space and translate it at the center of the screen
				float posx = x2 - (int)(vrr[0] * cs);
				float posy = y2 - (int)(vrr[1] * cs);
		
				rect(posx, posy, 2, 2);
			}
		}
	}

	frame += 1;
}"
"649334","REYES rasterization","mySketch","int frame = 0;

float[] displaceX;
float[] displaceY;
float[] displaceZ;

static float cs = 580;
static float inc = 1.0 / (cs / 128.0);
static float csi = 1.0 / inc;
static float scale = 1.0 / 8.0;

PGraphics depthbuffer;

void setup() {
  size(1024, 768);

  background(0);
	
	noStroke();
	
	randomSeed(0);
	
	displaceX = new float[(int)csi];
	displaceY = new float[(int)csi];
	displaceZ = new float[(int)csi];
	
	for (int i = 0; i <= (int)csi; i += 1) {
		displaceX[i] = random(-1, 1) / 64;
		displaceY[i] = random(-1, 1) / 64;
		displaceZ[i] = random(-1, 1) / 64;
	}
	
	depthbuffer = createGraphics(width, height);
}

void draw() {
	// clear z-buffer
	depthbuffer.beginDraw();
	depthbuffer.background(0);
	depthbuffer.endDraw();
	
  background(0);
	//fill(0, 0, 0, 48);
	//rect(0, 0, width, height);
	
	float rxa = 0.003 * frame;
	float rya = 0.004 * frame;

	// rotation values
	float crx = cos(rxa);
	float cry = cos(rya);
	float srx = sin(rxa);
	float sry = sin(rya);
	
	// rm = rotation matrix
	float[] rm = {0,0,0,0,0,0,0,0,0};

	rm[0] = cry;     /*rm[1] = 0.0f;*/ rm[2] = -sry;
	rm[3] = sry * srx; rm[4] = crx;    rm[5] = cry * srx;
	rm[6] = sry * crx; rm[7] = -srx;   rm[8] = cry * crx;
	
	int x2 = width / 2;
	int y2 = height / 2;
	
	for (z = 0.0; z < 1.0; z += inc) {
		float[] vr = {0,0,0};

		float pz = 2.0 * z - 1.0;

		vr[2] = pz * scale;
		for (y = 0.0; y < 1.0; y += inc) {
			float py = 2.0 * y - 1.0;

			vr[1] = py * scale;
			for (x = 0.0; x < 1.0; x += inc) {
				// filter volumetric data (eg. we only want the points on the surface)
				if (x > 0.0 && x < (1.0 - inc) && y > 0.0 && y < (1.0 - inc) && z > 0.0 && z < (1.0 - inc)) continue;
				
				float px = (2.0 * x - 1.0);
				
				vr[0] = px * scale;

				// rotate our points
				float[] vrr = {
						rm[0] * vr[0] + rm[3] * vr[1] + rm[6] * vr[2],
						rm[1] * vr[0] + rm[4] * vr[1] + rm[7] * vr[2],
						rm[2] * vr[0] + rm[5] * vr[1] + rm[8] * vr[2]
				};
			
				// compute length & normalize
				float le = sqrt((vrr[0] * vrr[0]) + (vrr[1] * vrr[1]) + (vrr[2] * vrr[2]));
			  float[] vrn = { vrr[0] / le, vrr[1] / le, vrr[2] / le };

				// point shade based on normalized Z value
			  int shading = vrn[2] * 255;
				fill(shading, shading, shading);

				// since we were in normalized space we scale it to screen space and translate it at the center of the screen
				float posx = x2 - (int)(vrr[0] * cs);
				float posy = y2 - (int)(vrr[1] * cs);
		
				// draw cube surface by computing the quad given 4 points on the surface
				// the 'depth' sides (when viewed non-rotated)
				float px2 = (2.0 * (x + inc) - 1.0);
				float pxs = px2 * scale;
				float py2 = (2.0 * (y + inc) - 1.0);
				float pys = py2 * scale;
				float pz2 = (2.0 * (z + inc) - 1.0);
				float pzs = pz2 * scale;
		
				if (y >= 0.0 && y < (1.0 - inc) && z >= 0.0 && z < (1.0 - inc)) {
					float[] vrr2 = {
							rm[0] * vr[0] + rm[3] * vr[1] + rm[6] * pzs,
							rm[1] * vr[0] + rm[4] * vr[1] + rm[7] * pzs,
							rm[2] * vr[0] + rm[5] * vr[1] + rm[8] * pzs
					};
		
					float[] vrr3 = {
							rm[0] * vr[0] + rm[3] * pys + rm[6] * pzs,
							rm[1] * vr[0] + rm[4] * pys + rm[7] * pzs,
							rm[2] * vr[0] + rm[5] * pys + rm[8] * pzs
					};
	
					float[] vrr4 = {
							rm[0] * vr[0] + rm[3] * pys + rm[6] * vr[2],
							rm[1] * vr[0] + rm[4] * pys + rm[7] * vr[2],
							rm[2] * vr[0] + rm[5] * pys + rm[8] * vr[2]
					};
		
					float posx2 = x2 - (int)(vrr2[0] * cs);
					float posy2 = y2 - (int)(vrr2[1] * cs);
					float posx3 = x2 - (int)(vrr3[0] * cs);
					float posy3 = y2 - (int)(vrr3[1] * cs);
					float posx4 = x2 - (int)(vrr4[0] * cs);
					float posy4 = y2 - (int)(vrr4[1] * cs);
				} else if (x >= 0.0 && x < (1.0 - inc) && y >= 0.0 && y < (1.0 - inc)) {
					float[] vrr2 = {
							rm[0] * pxs + rm[3] * vr[1] + rm[6] * vr[2],
							rm[1] * pxs + rm[4] * vr[1] + rm[7] * vr[2],
							rm[2] * pxs + rm[5] * vr[1] + rm[8] * vr[2]
					};
		
					float[] vrr3 = {
							rm[0] * pxs + rm[3] * pys + rm[6] * vr[2],
							rm[1] * pxs + rm[4] * pys + rm[7] * vr[2],
							rm[2] * pxs + rm[5] * pys + rm[8] * vr[2]
					};
	
					float[] vrr4 = {
							rm[0] * vr[0] + rm[3] * pys + rm[6] * vr[2],
							rm[1] * vr[0] + rm[4] * pys + rm[7] * vr[2],
							rm[2] * vr[0] + rm[5] * pys + rm[8] * vr[2]
					};
		
					float posx2 = x2 - (int)(vrr2[0] * cs);
					float posy2 = y2 - (int)(vrr2[1] * cs);
					float posx3 = x2 - (int)(vrr3[0] * cs);
					float posy3 = y2 - (int)(vrr3[1] * cs);
					float posx4 = x2 - (int)(vrr4[0] * cs);
					float posy4 = y2 - (int)(vrr4[1] * cs);
				} else if (x >= 0.0 && x < (1.0 - inc) && z >= 0.0 && z < (1.0 - inc)) {
					float[] vrr2 = {
							rm[0] * pxs + rm[3] * vr[1] + rm[6] * vr[2],
							rm[1] * pxs + rm[4] * vr[1] + rm[7] * vr[2],
							rm[2] * pxs + rm[5] * vr[1] + rm[8] * vr[2]
					};
		
					float[] vrr3 = {
							rm[0] * pxs + rm[3] * vr[1] + rm[6] * pzs,
							rm[1] * pxs + rm[4] * vr[1] + rm[7] * pzs,
							rm[2] * pxs + rm[5] * vr[1] + rm[8] * pzs
					};
	
					float[] vrr4 = {
							rm[0] * vr[0] + rm[3] * vr[1] + rm[6] * pzs,
							rm[1] * vr[0] + rm[4] * vr[1] + rm[7] * pzs,
							rm[2] * vr[0] + rm[5] * vr[1] + rm[8] * pzs
					};
		
					float posx2 = x2 - (int)(vrr2[0] * cs);
					float posy2 = y2 - (int)(vrr2[1] * cs);
					float posx3 = x2 - (int)(vrr3[0] * cs);
					float posy3 = y2 - (int)(vrr3[1] * cs);
					float posx4 = x2 - (int)(vrr4[0] * cs);
					float posy4 = y2 - (int)(vrr4[1] * cs);
				}

				//depthbuffer.loadPixels();
				if (shading > brightness(depthbuffer.get(posx,posy))) {//brightness(depthbuffer.pixels[posx + posy * width])) {
					// depth value go into depth buffer
					depthbuffer.beginDraw();
					depthbuffer.fill(shading, shading, shading);
					depthbuffer.quad(posx, posy, posx2, posy2, posx3, posy3, posx4, posy4);
					depthbuffer.endDraw();
					
					quad(posx, posy, posx2, posy2, posx3, posy3, posx4, posy4);
				}
				
				// no z-buffer
				//quad(posx, posy, posx2, posy2, posx3, posy3, posx4, posy4);

				// points only
				//rect(posx, posy, 2, 2);
			}
		}
	}

	frame += 1;
}"
"649334","REYES rasterization","mySketch","int frame = 0;

float[] displaceX;
float[] displaceY;
float[] displaceZ;

static float cs = 580;
static float inc = 0.5;//1.0 / (cs / 128.0);
static float csi = 1.0 / inc;
static float scale = 1.0 / 8.0;

PGraphics depthbuffer;

void setup() {
  size(1024, 768);

  background(0);
	
	noStroke();
	
	randomSeed(0);
	
	displaceX = new float[(int)csi];
	displaceY = new float[(int)csi];
	displaceZ = new float[(int)csi];
	
	for (int i = 0; i <= (int)csi; i += 1) {
		displaceX[i] = random(-1, 1) / 64;
		displaceY[i] = random(-1, 1) / 64;
		displaceZ[i] = random(-1, 1) / 64;
	}
	
	depthbuffer = createGraphics(width, height);
	depthbuffer.noStroke();
}

void draw() {
	// clear z-buffer
	depthbuffer.beginDraw();
	depthbuffer.background(0);
	depthbuffer.endDraw();
	
  background(0);
	//fill(0, 0, 0, 48);
	//rect(0, 0, width, height);
	
	float rxa = 0.003 * frame;
	float rya = 0.004 * frame;

	// rotation values
	float crx = cos(rxa);
	float cry = cos(rya);
	float srx = sin(rxa);
	float sry = sin(rya);
	
	// rm = rotation matrix
	float[] rm = {0,0,0,0,0,0,0,0,0};

	rm[0] = cry;     /*rm[1] = 0.0f;*/ rm[2] = -sry;
	rm[3] = sry * srx; rm[4] = crx;    rm[5] = cry * srx;
	rm[6] = sry * crx; rm[7] = -srx;   rm[8] = cry * crx;
	
	int x2 = width / 2;
	int y2 = height / 2;
	
	float x, y, z;
	
	for (z = 0.0; z <= 1.0; z += inc) {
		float[] vr = {0,0,0};

		float pz = 2.0 * z - 1.0;

		vr[2] = pz * scale;
		for (y = 0.0; y <= 1.0; y += inc) {
			float py = 2.0 * y - 1.0;

			vr[1] = py * scale;
			for (x = 0.0; x <= 1.0; x += inc) {
				// filter volumetric data (eg. we only want the points on the surface)
				if (x > 0.0 && x < (1.0 - inc) && y > 0.0 && y < (1.0 - inc) && z > 0.0 && z < (1.0 - inc)) continue;
				
				float px = (2.0 * x - 1.0);
				
				vr[0] = px * scale;

				// rotate our points
				float[] vrr = {
						rm[0] * vr[0] + rm[3] * vr[1] + rm[6] * vr[2],
						rm[1] * vr[0] + rm[4] * vr[1] + rm[7] * vr[2],
						rm[2] * vr[0] + rm[5] * vr[1] + rm[8] * vr[2]
				};
			
				// compute length & normalize
				float le = sqrt((vrr[0] * vrr[0]) + (vrr[1] * vrr[1]) + (vrr[2] * vrr[2]));
			  float[] vrn = { vrr[0] / le, vrr[1] / le, vrr[2] / le };

				// point shade based on normalized Z value
			  int shading = vrn[2] * 255;
				//fill(shading, shading, shading);

				// since we were in normalized space we scale it to screen space and translate it at the center of the screen
				float posx = x2 - (int)(vrr[0] * cs);
				float posy = y2 - (int)(vrr[1] * cs);
		
				// draw cube surface by computing the quad given from 4 points on the surface
				float px2 = (2.0 * (x + inc) - 1.0);
				float pxs = px2 * scale;
				float py2 = (2.0 * (y + inc) - 1.0);
				float pys = py2 * scale;
				float pz2 = (2.0 * (z + inc) - 1.0);
				float pzs = pz2 * scale;
		
				float posx2; float posy2;
				float posx3; float posy3;
				float posx4; float posy4;
		
				if (y >= 0.0 && y <= (1.0 - inc) &&
						z >= 0.0 && z <= (1.0 - inc) &&
					  (x >= 1.0 || x <= 0.0)) {
					float[] vrr2 = {
							rm[0] * vr[0] + rm[3] * vr[1] + rm[6] * pzs,
							rm[1] * vr[0] + rm[4] * vr[1] + rm[7] * pzs,
							rm[2] * vr[0] + rm[5] * vr[1] + rm[8] * pzs
					};
		
					float[] vrr3 = {
							rm[0] * vr[0] + rm[3] * pys + rm[6] * pzs,
							rm[1] * vr[0] + rm[4] * pys + rm[7] * pzs,
							rm[2] * vr[0] + rm[5] * pys + rm[8] * pzs
					};
	
					float[] vrr4 = {
							rm[0] * vr[0] + rm[3] * pys + rm[6] * vr[2],
							rm[1] * vr[0] + rm[4] * pys + rm[7] * vr[2],
							rm[2] * vr[0] + rm[5] * pys + rm[8] * vr[2]
					};
		
					posx2 = x2 - (int)(vrr2[0] * cs);
					posy2 = y2 - (int)(vrr2[1] * cs);
					posx3 = x2 - (int)(vrr3[0] * cs);
					posy3 = y2 - (int)(vrr3[1] * cs);
					posx4 = x2 - (int)(vrr4[0] * cs);
					posy4 = y2 - (int)(vrr4[1] * cs);

					stroke(shading, shading, shading);
					line(posx, posy, posx2, posy2);
					line(posx2, posy2, posx3, posy3);
					line(posx3, posy3, posx, posy);

					stroke(shading, 0, 0);
					line(posx, posy, posx4, posy4);
					line(posx4, posy4, posx3, posy3);
					line(posx3, posy3, posx, posy);
				}
				
				if (x >= 0.0 && x <= (1.0 - inc) &&
									 y >= 0.0 && y <= (1.0 - inc) &&
									 (z >= 1.0 || z <= 0.0)) {
					float[] vrr2 = {
							rm[0] * pxs + rm[3] * vr[1] + rm[6] * vr[2],
							rm[1] * pxs + rm[4] * vr[1] + rm[7] * vr[2],
							rm[2] * pxs + rm[5] * vr[1] + rm[8] * vr[2]
					};
		
					float[] vrr3 = {
							rm[0] * pxs + rm[3] * pys + rm[6] * vr[2],
							rm[1] * pxs + rm[4] * pys + rm[7] * vr[2],
							rm[2] * pxs + rm[5] * pys + rm[8] * vr[2]
					};
	
					float[] vrr4 = {
							rm[0] * vr[0] + rm[3] * pys + rm[6] * vr[2],
							rm[1] * vr[0] + rm[4] * pys + rm[7] * vr[2],
							rm[2] * vr[0] + rm[5] * pys + rm[8] * vr[2]
					};
		
					posx2 = x2 - (int)(vrr2[0] * cs);
					posy2 = y2 - (int)(vrr2[1] * cs);
					posx3 = x2 - (int)(vrr3[0] * cs);
					posy3 = y2 - (int)(vrr3[1] * cs);
					posx4 = x2 - (int)(vrr4[0] * cs);
					posy4 = y2 - (int)(vrr4[1] * cs);

					stroke(shading, shading, shading);
					line(posx, posy, posx2, posy2);
					line(posx2, posy2, posx3, posy3);
					line(posx3, posy3, posx, posy);

					stroke(shading, 0, 0);
					line(posx, posy, posx4, posy4);
					line(posx4, posy4, posx3, posy3);
					line(posx3, posy3, posx, posy);
				}
				
				if (x >= 0.0 && x <= (1.0 - inc) &&
									 z >= 0.0 && z <= (1.0 - inc) &&
									 (y >= 1.0 || y <= 0.0)) {
					float[] vrr2 = {
							rm[0] * pxs + rm[3] * vr[1] + rm[6] * vr[2],
							rm[1] * pxs + rm[4] * vr[1] + rm[7] * vr[2],
							rm[2] * pxs + rm[5] * vr[1] + rm[8] * vr[2]
					};
		
					float[] vrr3 = {
							rm[0] * pxs + rm[3] * vr[1] + rm[6] * pzs,
							rm[1] * pxs + rm[4] * vr[1] + rm[7] * pzs,
							rm[2] * pxs + rm[5] * vr[1] + rm[8] * pzs
					};
	
					float[] vrr4 = {
							rm[0] * vr[0] + rm[3] * vr[1] + rm[6] * pzs,
							rm[1] * vr[0] + rm[4] * vr[1] + rm[7] * pzs,
							rm[2] * vr[0] + rm[5] * vr[1] + rm[8] * pzs
					};
		
					posx2 = x2 - (int)(vrr2[0] * cs);
					posy2 = y2 - (int)(vrr2[1] * cs);
					posx3 = x2 - (int)(vrr3[0] * cs);
					posy3 = y2 - (int)(vrr3[1] * cs);
					posx4 = x2 - (int)(vrr4[0] * cs);
					posy4 = y2 - (int)(vrr4[1] * cs);

					stroke(shading, shading, shading);
					line(posx, posy, posx2, posy2);
					line(posx2, posy2, posx3, posy3);
					line(posx3, posy3, posx, posy);

					stroke(shading, 0, 0);
					line(posx, posy, posx4, posy4);
					line(posx4, posy4, posx3, posy3);
					line(posx3, posy3, posx, posy);
				}

				if (shading >= brightness(depthbuffer.get(posx,posy))) {
					// depth value go into depth buffer
					depthbuffer.beginDraw();
					depthbuffer.fill(shading, shading, shading);
					depthbuffer.quad(posx, posy, posx2, posy2, posx3, posy3, posx4, posy4);
					depthbuffer.endDraw();
					
					//quad(posx, posy, posx2, posy2, posx3, posy3, posx4, posy4);
				}
				
				// no z-buffer
				//quad(posx, posy, posx2, posy2, posx3, posy3, posx4, posy4);

				// points only
				//fill(255, 0, 0);
				//ellipse(posx, posy, 2, 2);
			}
		}
	}
	
	//image(depthbuffer, 0, 0);

	frame += 1;
}"
"645549","Melting pot","mySketch","float shape_size = 300;
float shape_angle_y;
float shape_z = -100;

float xmotion = 0.;
float ymotion = 0.;

PGraphics off;
PGraphics off_2d;

PImage img1;
PImage img2;

int w = 700;
int h = 700;

// control the rendering quality / speed (basically the resolution by which we scan the 3D offscreen pixels)
int iter_step_x = 4;
int iter_step_y = 6;

int[] buffer = new int[w * h];

void setup() {
  size(w, h, P2D);  
	
	frameRate(60);
	
	noStroke();
	
	// we need a 2D offscreen context to draw the 3D offscreen context and process the pixels data
	off_2d = createGraphics(w, h, P2D);
	off_2d.background(0);

	// 3d offscreen context
	off = createGraphics(w, h, P3D);
	off.textureMode(NORMALIZED);
	off.smooth();
	off.lights();
	off.ambientLight(128, 128, 128);
	off.directionalLight(128, 128, 128, 0, 0, -1);
	off.lightFalloff(1, 0.1, 0.05);
	off.lightSpecular(0, 0, 0);
	//off.noFill();
	
	img1 = loadImage(""data.jpg"");
	img2 = loadImage(""vapor.jpg"");
	
	background(0);
}
 
void draw() {
	//background(0);
  fill(0, 0, 0, 64);
  rect(0, 0, w, h);
	
	// draw a cube into the 3D offscreen context
	off.beginDraw(); 
	off.pushMatrix();
	off.stroke(4);
	off.background(0, 0, 0, 4);
	off.translate(w / 2 + sin(xmotion) * 24, h / 2 - cos(ymotion) * 24, shape_z - sin(xmotion) * 48);
  off.rotateX(shape_angle_y + 2);
	off.rotateY(ymotion / 4 + 4);
	off.rotateZ(shape_angle_y + xmotion);
  off.box(shape_size);
	off.popMatrix();
	off.endDraw();
	
	/*
	off.beginDraw(); 
	off.pushMatrix();
	off.translate(w - w / 4, h / 2, shape_z);
  off.rotateX(shape_angle_y);
	off.rotateZ(shape_angle_y);
	off.sphere(shape_size / 2);
	off.popMatrix();
	off.endDraw();
	*/
	/*
	// don't work and i don't know why (bug ?)
	off.pushMatrix();
	off.background(0, 0, 0, 255);
	//off.noStroke();
	off.fill(255);
	off.translate(w / 2, h / 2, shape_z);
  //off.rotateX(shape_angle_y);
	//off.rotateZ(shape_angle_y);
	off.scale(shape_size * 1.5);
	texturedCube(off, img1);
	off.popMatrix();
	*/
	shape_angle_y += .01;
	
	// draw the 3D offscreen context to the 2D offscreen context
	off_2d.image(off);
	
	// draw background
	image(img2, 0, 256);
	
	// load 2D offscreen context pixels and iterate over all of them (by steps)
  /*off_2d.loadPixels();
	int i = 0;
  for (int y = 0; y < h; y += iter_step_y) {
		float yn = y / h;
		int yi = y * h;
		
		for (int x = 0; x < w; x += iter_step_x) {
			int p = off_2d.pixels[x + yi];
			
			float pbr = brightness(p);

			if (pbr > 0) {
				float pr = red(p);
				float pg = green(p);
				float pb = blue(p);
				
				float xn = x / w;
				float inn = i / (w * h);
				
				float pbn = pbr / 255;
				
				// image lookup
				// can be fun, would be better with real texture mapping from the 3D context
				//float xrepeat = 1;
				//float yrepeat = 1;

				//int xxd = ((int)(xn * (img1.width * xrepeat) - xmotion))%(img1.width);
				//int yyd = (((int)((1.-yn) * (img1.height * yrepeat) - ymotion))%(img1.height)) * img1.width;

				//xxd = abs(xxd);
				//yyd = abs(yyd);

				//int cl = (int)xxd + yyd;

				//int r = (int)(red(img1.pixels[cl]) * (pbn * 2));
				//int g = (int)(green(img1.pixels[cl]) * (pbn * 2));
				//int b = (int)(blue(img1.pixels[cl]) * (pbn * 2));
				
				//
				
				float r = pr * (abs(sin(yn * PI + xmotion * pbn)));
				float g = pg * (abs(cos(xn * PI + xmotion)));
				float b = pb * (abs(sin(inn * PI + ymotion)));

				fill(r, g, b, pr);
				ellipse(x + cos(pbn * PI + xmotion) * (pbn * 128), y + sin(pbn * PI + ymotion) * (pbn * 64), 2 + random(16), 2 + random(16));
			}
			
			i += 1;
		}
  }*/
	
	// debug
	image(off);
	
	xmotion += 0.05;
	ymotion += 0.09;
}"
"645549","Melting pot","mySketch","float shape_size = 300;
float shape_angle_y;
float shape_z = -100;

float xmotion = 0.;
float ymotion = 0.;

PGraphics off;
PGraphics off_2d;

PImage img1;
PImage img2;

int w = 500;
int h = 500;

// control the rendering quality / speed (basically the resolution by which we scan the 3D offscreen pixels)
int iter_step_x = 3;
int iter_step_y = 3;

int[] buffer = new int[w * h];

void setup() {
  size(w, h, P2D);  
	
	frameRate(60);
	
	noStroke();
	
	// we need a 2D offscreen context to draw the 3D offscreen context and process the pixels data
	off_2d = createGraphics(w, h, P2D);
	off_2d.background(0);

	// 3d offscreen context
	off = createGraphics(w, h, P3D);
	off.textureMode(NORMALIZED);
	off.smooth();
	off.lights();
	off.ambientLight(128, 128, 128);
	off.directionalLight(128, 128, 128, 0, 0, -1);
	off.lightFalloff(1, 0.1, 0.05);
	off.lightSpecular(0, 0, 0);
	//off.noFill();
	
	img2 = loadImage(""data.jpg"");
	
	colorMode(HSB, 360, 255, 255);
	
	background(0);
}
 
void draw() {
	//background(255);
  fill(0, 0, 0, 128);
  rect(0, 0, w, h);
	
	// draw a cube into the 3D offscreen context
	off.beginDraw(); 
	off.pushMatrix();
	off.strokeWeight(4);
	off.stroke(255, 0, 0);
	off.background(0, 0, 0, 16);
	off.translate(w / 2 + sin(xmotion) * 24, h / 2 - cos(ymotion) * 24, shape_z - sin(xmotion) * 48);
  off.rotateX(shape_angle_y + 2);
	off.rotateY(ymotion / 2 + 4);
	off.rotateZ(shape_angle_y + xmotion);
  off.box(shape_size, shape_size, shape_size);
	off.popMatrix();
	
	off.pushMatrix();
	off.strokeWeight(4);
	off.stroke(0, 255, 0);
	off.translate(w / 2 + sin(xmotion) * 24, h / 2 - cos(ymotion) * 24, shape_z - sin(xmotion) * 48);
  off.rotateX(shape_angle_y + 2);
	off.rotateY(ymotion / 2 + 4);
	off.rotateZ(shape_angle_y + xmotion);
  off.sphere(shape_size / 1.9 + abs(sin(xmotion) * shape_size / 4));
	off.popMatrix();
	off.endDraw();
	
	shape_angle_y += .0075;
	
	// draw the 3D offscreen context to the 2D offscreen context
  off_2d.fill(0, 0, 0, 16);
  off_2d.rect(0, 0, w, h);
	off_2d.image(off);
	
	// draw background
	//image(img2, 0, 0);
	
	// load 2D offscreen context pixels and iterate over all of them (by steps)
  off_2d.loadPixels();
	int i = 0;
  for (int y = 0; y < h; y += iter_step_y) {
		float yn = y / h;
		float yni = 1-abs(0.5 - yn) * 2;
		int yi = y * h;
		
		float sy = cos(ymotion + yn * PI * 4) * 12;
		float sy2 = cos(ymotion / 2 + pbrn * PI * 2) * 32;
		
		for (int x = 0; x < w; x += iter_step_x) {
			int p = off_2d.pixels[x + yi];
			
			float pb = brightness(p);
			
			noStroke();
			
			if (pb > 0 && pb < 224) {
				float pbr = red(p);
				float pbg = green(p);
				
				float xn = x / w;
				float xni = 1-abs(0.5 - x / w) * 2;
				
				float pbn = pb / 255;
				float pbrn = pbr / 255;
				float pbgn = pbg / 255;
				
				int rx = 4 + random(4, 8) * pbgn * xn;
				int ry = 4 + random(4, 8) * pbgn * yn;

				fill(48 * pbrn, 148, 255, 224 * pbrn * xni * yni * pbgn);
				rect(x - rx / 2 + sin(xmotion + xn * PI * 4) * 8, y - ry / 2 + sy, rx, ry);
			} else if (pb > 224 && pb < 248) {
				float pbrn = pbr / 255;
				
				fill(0, 0, 255, 92);
				rect(x - 4 + sin(xmotion / 2 + pbrn * PI * 2) * 32, y - 4 + sy2, 8, 8);
				
				fill(0, 0, 0, 48);
				int rnx = random(8, 16);
				int rny = random(8, 16);
				rect(x - rnx / 2, y - rny / 2, rnx, rny);
			} else if (pb >= 250 && pb < 254) {
				//fill(0, 32, 32, 48);
				int rnx = random(8, 24);
				int rny = random(8, 24);
				
				int p1x = random(x - rnx, x + rnx);
				int p2x = random(x - rnx, x + rnx);
				int p1y = random(y - rny, y + rny);
				int p2y = random(y - rny, y + rny);
				//rect(x - rnx / 2, y - rny / 2, rnx, rny);
				stroke(random(16, 64), 128, 255, 128);
				line(p1x, p1y, p2x, p2y);
			}
			
			i += 1;
		}
  }
	
	//image(off_2d, 0, 0);
	// debug
	//image(off);
	
	xmotion += 0.05;
	ymotion += 0.09;
}"
"645549","Melting pot","mySketch","float shape_size = 300;
float shape_angle_y;
float shape_z = -100;

float xmotion = 0.;
float ymotion = 0.;

PGraphics off;
PGraphics off_2d;

PImage img1;
PImage img2;

int w = 500;
int h = 500;

// control the rendering quality / speed (basically the resolution by which we scan the 3D offscreen pixels)
int iter_step_x = 3;
int iter_step_y = 3;

int[] buffer = new int[w * h];

void setup() {
  size(w, h, P2D);  
	
	frameRate(60);
	
	noStroke();
	
	// we need a 2D offscreen context to draw the 3D offscreen context and process the pixels data
	off_2d = createGraphics(w, h, P2D);
	off_2d.background(0);

	// 3d offscreen context
	off = createGraphics(w, h, P3D);
	off.textureMode(NORMALIZED);
	off.smooth();
	off.lights();
	off.ambientLight(128, 128, 128);
	off.directionalLight(128, 128, 128, 0, 0, -1);
	off.lightFalloff(1, 0.1, 0.05);
	off.lightSpecular(0, 0, 0);
	//off.noFill();
	
	img2 = loadImage(""data.jpg"");
	
	colorMode(HSB, 360, 255, 255);
	
	background(0);
}
 
void draw() {
	//background(255);
  fill(0, 0, 0, 128);
  rect(0, 0, w, h);
	
	// draw a cube into the 3D offscreen context
	off.beginDraw(); 
	off.pushMatrix();
	off.strokeWeight(4);
	off.stroke(255, 0, 0);
	off.background(0, 0, 0, 16);
	off.translate(w / 2 + sin(xmotion) * 24, h / 2 - cos(ymotion) * 24, shape_z - sin(xmotion) * 48);
  off.rotateX(shape_angle_y + 2);
	off.rotateY(ymotion / 2 + 4);
	off.rotateZ(shape_angle_y + xmotion);
  off.box(shape_size, shape_size, shape_size);
	off.popMatrix();
	
	off.pushMatrix();
	off.strokeWeight(4);
	off.stroke(0, 255, 0);
	off.translate(w / 2 + sin(xmotion) * 24, h / 2 - cos(ymotion) * 24, shape_z - sin(xmotion) * 48);
  off.rotateX(shape_angle_y + 2);
	off.rotateY(ymotion / 2 + 4);
	off.rotateZ(shape_angle_y + xmotion);
  off.sphere(shape_size / 1.9 + abs(sin(xmotion) * shape_size / 4));
	off.popMatrix();
	off.endDraw();
	
	shape_angle_y += .0075;
	
	// draw the 3D offscreen context to the 2D offscreen context
  off_2d.fill(0, 0, 0, 16);
  off_2d.rect(0, 0, w, h);
	off_2d.image(off);
	
	// draw background
	//image(img2, 0, 0);
	
	// load 2D offscreen context pixels and iterate over all of them (by steps)
  off_2d.loadPixels();
	int i = 0;
  for (int y = 0; y < h; y += iter_step_y) {
		float yn = y / h;
		float yni = 1-abs(0.5 - yn) * 2;
		int yi = y * h;
		
		float sy = cos(ymotion + yn * PI * 4) * 12;
		float sy2 = cos(ymotion / 2 + pbrn * PI * 2) * 32;
		
		for (int x = 0; x < w; x += iter_step_x) {
			int p = off_2d.pixels[x + yi];
			
			float pb = brightness(p);
			
			noStroke();
			
			if (pb > 0 && pb < 224) {
				float pbr = red(p);
				float pbg = green(p);
				
				float xn = x / w;
				float xni = 1-abs(0.5 - x / w) * 2;
				
				float pbn = pb / 255;
				float pbrn = pbr / 255;
				float pbgn = pbg / 255;
				
				int rx = 4 + random(4, 8) * pbgn * xn;
				int ry = 4 + random(4, 8) * pbgn * yn;

				fill(48 * pbrn, 148, 255, 224 * pbrn * xni * yni * pbgn);
				rect(x - rx / 2 + sin(xmotion + xn * PI * 4) * 8, y - ry / 2 + sy, rx, ry);
			} else if (pb > 224 && pb < 248) {
				float pbrn = pbr / 255;
				
				fill(0, 0, 255, 92);
				rect(x - 4 + sin(xmotion / 2 + pbrn * PI * 2) * 32, y - 4 + sy2, 8, 8);
				
				fill(0, 0, 0, 48);
				int rnx = random(8, 16);
				int rny = random(8, 16);
				rect(x - rnx / 2, y - rny / 2, rnx, rny);
			} else if (pb >= 250 && pb < 254) {
				//fill(0, 32, 32, 48);
				int rnx = random(8, 24);
				int rny = random(8, 24);
				
				int p1x = random(x - rnx, x + rnx);
				int p2x = random(x - rnx, x + rnx);
				int p1y = random(y - rny, y + rny);
				int p2y = random(y - rny, y + rny);
				//rect(x - rnx / 2, y - rny / 2, rnx, rny);
				stroke(random(16, 64), 128, 255, 128);
				line(p1x, p1y, p2x, p2y);
			}
			
			i += 1;
		}
  }
	
	//image(off_2d, 0, 0);
	// debug
	//image(off);
	
	xmotion += 0.05;
	ymotion += 0.09;
}"
"643606","at the heart of it all","mySketch","/**
  * More noise from feedback.
	*/

float xmotion = 8.8;
float ymotion = 2.2;

float motion = -1;

void draw_func(int s) {
	noStroke();
	
	loadPixels();
	for (int x = 0; x < width; x += 4) {
		float norm_x = x / width;
		float norm_x2 = abs(0.5 - norm_x) * 2;

		float noise_sizex = (sin(xmotion / 32)) * random(8, norm_x2 * 32);
		
		for (int y = 0; y < height; y += 4) {
			color p = pixels[abs(height / 2 - y) * width + abs(width / 2 - x)];
			
			if (brightness(p) > s) {
				float norm_y = y / height;
				
				float noise_sizey = abs(cos(ymotion / 16)) * random(8, norm_x2 * 32);

				int r = 192 + noise_sizey;
				int g = 192 + noise_sizey;
				int b = 255;
				
				fill(r, g, b, 92);
				ellipse(x + sin(xmotion * 2) * 16, y - cos(ymotion * 2) * 16, 8, 4);
				rect(height - y + cos(ymotion * 2) * 16, width - x + sin(xmotion * 2) * 16, 1, 1);	
				fill(0, 0, 0, 48);
				rect(x, y, (noise_sizex), (noise_sizey));
				rect(height - y, width - x, (noise_sizex), (noise_sizey));
			}
		}
	}

	xmotion += 0.005;
	ymotion += 0.008;
}

void setup() {
  size(400, 400);

  background(0);
	
	float noiseScale = 1.7;
	draw_func(-8);
}

void draw() {
  draw_func(128);
}"
"643592","Dasein","mySketch","/**
  * Making noise with feedback again.
	*/

float xmotion = 8.8;
float ymotion = 2.2;

void draw_func(int s) {
	noStroke();
	noFill();
	
	loadPixels();
	for (int x = 0; x < width; x += 92) {
		float norm_x = x / width;
		
		for (int y = 0; y < height; y += 92) {
			color p = pixels[y * width + x];
			
			int b = brightness(p);
		
			int b2 = b / 3; // change this for variations 2 - 4 is good
			int b3 = b / 128;
			
			if (brightness(p) < 72) {
				float norm_y = y / height;
				
				float noise_sizex = (abs(sin(xmotion / 2 + norm_x * PI * 2)) + abs(cos(ymotion / 2 + norm_y * PI * 2))) * b3;
				float noise_sizey = (abs(cos(xmotion / 2 + norm_x * PI * 2)) + abs(sin(ymotion / 2 + norm_y * PI * 2))) * b3;

				int r = abs(240 * (sin(xmotion * 8 + norm_x * PI / 4) * cos(ymotion * 8 + norm_y * PI / 4))) + noise_sizex * 64; // h
				int g = 148; // s
				int b = 255; // l
				
				float v = b2 / 64 + 48;
				
				fill(r, g, b, 14);
				stroke(0, 0, 0, 1 + v);
				// remove sin / cos to reveal tiles pattern
				if ((int)random(0, 2) > 0) {
					rect(v/2 + abs(width / 2 - x) * 2 + sin(xmotion * 80 + norm_x * PI * 2) * b2, v/2 + abs(height / 2 - y) * 2 + cos(ymotion * 80 + norm_y * PI * 2) * b2, v, v);
				} else {
					ellipse(v/2 + abs(width / 2 - x) * 2 + sin(xmotion * 80 + norm_x * PI * 2) * b2 + v / 2, v/2 + abs(height / 2 - y) * 2 + cos(ymotion * 80 + norm_y * PI * 2) * b2 + v / 2, v + random(0, v/2), v+ random(0, v/2));
				}
			
				fill(0, 0, 0, 1);
				stroke(0, 0, 0, 128);
				if ((int)random(0, 7) > 0) {
					rect(v/2 + abs(height / 2 - y) * 2 + cos(xmotion * 80 + norm_x * PI * 2) * b2, v/2 + abs(width / 2 - x) * 2 + sin(ymotion * 80 + norm_y * PI * 2) * b2, v, v);	
				} else {
					ellipse(v/2 + abs(height / 2 - y) * 2 + cos(xmotion * 80 + norm_x * PI * 2) * b2 + v / 2, v/2 + abs(width / 2 - x) * 2 + sin(ymotion * 80 + norm_y * PI * 2) * b2 + v / 2, v, v);	
				}
				
			} else if (brightness(p) > 128) {
				noFill();
				fill(0, 0, 0, 1);
				ellipse(x + random(-b2, b2), y + random(-b2, b2), 32, 32);
				ellipse(width - x + random(-b2, b2), height - y + random(-b2, b2), 32, 32);
			}
		}
	}

	xmotion += 0.5;
	ymotion += 0.8;
}

void setup() {
  size(600, 600);
	
	colorMode(HSB, 360, 255, 255);

  background(0);
	
	smooth();
	
	draw_func(0);
}

void draw() {
  draw_func(64);
}"
"643578","Windows","mySketch","/**
  * Making noise with feedback again.
	*/

float xmotion = 8.8;
float ymotion = 2.2;

void draw_func(int s) {
	noStroke();
	noFill();
	
	loadPixels();
	for (int x = 0; x < width; x += 24) {
		float norm_x = x / width;
		
		for (int y = 0; y < height; y += 24) {
			color p = pixels[y * width + x];
			
			int b = brightness(p);
		
			int b2 = b / 6; // change this for variations 2 - 4 is good
			int b3 = b / 128;
			
			if (brightness(p) < 72) {
				float norm_y = y / height;
				
				float noise_sizex = (abs(sin(xmotion / 2 + norm_x * PI * 2)) + abs(cos(ymotion / 2 + norm_y * PI * 2))) * b3;
				float noise_sizey = (abs(cos(xmotion / 2 + norm_x * PI * 2)) + abs(sin(ymotion / 2 + norm_y * PI * 2))) * b3;

				int r = abs(128 * (sin(xmotion * 8 + norm_x * PI / 4) * cos(ymotion * 8 + norm_y * PI / 4))) + noise_sizex * 64; // h
				int g = 148; // s
				int b = 255; // l
				
				float v = b2 / 64 + 14;
				
				fill(r, g, b, 2);
				stroke(r, g, b, 1 + v);
				// remove sin / cos to reveal tiles pattern
				rect(abs(width / 2 - x) * 2 + sin(xmotion * 8 + norm_x * PI * 2) * b2, abs(height / 2 - y) * 2 + cos(ymotion * 8 + norm_y * PI * 2) * b2, v, v);
			
				fill(0, 0, 0, 1);
				stroke(0, 0, 0, 92);
				rect(abs(height / 2 - y) * 2 + cos(xmotion * 8 + norm_x * PI * 2) * b2, abs(width / 2 - x) * 2 + sin(ymotion * 8 + norm_y * PI * 2) * b2, v, v);	
				
			} else if (brightness(p) > 128) {
				noFill();
				fill(0, 0, 0, 1);
				ellipse(x + random(-b2, b2), y + random(-b2, b2), 32, 32);
				ellipse(width - x + random(-b2, b2), height - y + random(-b2, b2), 32, 32);
			}
		}
	}

	xmotion += 0.5;
	ymotion += 0.8;
}

void setup() {
	// 600x600 look good!
  size(800, 800);
	
	colorMode(HSB, 360, 255, 255);

  background(0);
	
	smooth();
	
	draw_func(0);
}

void draw() {
  draw_func(64);
}"
"642774","PolyBezier","mySketch","/*
 * Bezier fun from polygons
 * Inspiration : https://cormullion.github.io/blog/2018/06/21/bezier.html
 */

float xmotion = 8.8;
float ymotion = 2.2;

class BCtrl {
	PVector p1;
	PVector p2;
	
	BCtrl(PVector p1, PVector p2) {
		this.p1 = p1;
		this.p2 = p2;
	}
}

// ported from 
// https://github.com/JuliaGraphics/Luxor.jl/blob/6eaeb2740604e6d1681a13e738418cf3435006ef/src/bezierpath.jl#L123
BCtrl findbeziercontrolpoints(PVector previouspt, PVector point1, PVector point2, PVector nextpt, float smoothing) {
    float xc1 = (previouspt.x + point1.x)/2.0 ; float yc1 = (previouspt.y + point1.y)/2.0;
    float xc2 = (point1.x + point2.x)/2.0     ; float yc2 = (point1.y + point2.y)/2.0;
    float xc3 = (point2.x + nextpt.x)/2.0     ; float yc3 = (point2.y + nextpt.y)/2.0;

    float l1 = previouspt.dist(point1);
		float l2 = point2.dist(point1);
		float l3 = nextpt.dist(point2);
	
    float k1 = l1 / (l1 + l2)   ; float k2 = l2 / (l2 + l3);
    float xm1 = xc1 + (xc2-xc1) * k1  ; float ym1 = yc1 + (yc2-yc1) * k1;
    float xm2 = xc2 + (xc3-xc2) * k2  ; float ym2 = yc2 + (yc3-yc2) * k2;
    float c1x = xm1 + (xc2-xm1) * smoothing + point1.x-xm1;
    float c1y = ym1 + (yc2-ym1) * smoothing + point1.y-ym1;
    float c2x = xm2 + (xc2-xm2) * smoothing + point2.x-xm2;
    float c2y = ym2 + (yc2-ym2) * smoothing + point2.y-ym2;
		
    return new BCtrl(new PVector(c1x, c1y), new PVector(c2x, c2y));
}

int seed = 0;

void draw_func() {
	noStroke();
	
	fill(0, 0, 0, 16);
	rect(0, 0, width, height);
	
	noFill();
	
	if (frameCount % 4 == 0) {
		seed = random(0, 99999);
	}
	
	randomSeed(seed);
	
	int subdx = 24;
	int subdy = 24;
	
	for (int y = 0; y < subdy; y += 1) {
		float norm_y = abs(0.5 - (float)y / subdy + cos(xmotion + y / subdy * PI / 3));
		
		for (int x = 0; x < subdx; x += 1) {
			float pn = noise((float)x / width, (float)y / height, sin(xmotion * 8));
			
			float norm_x = abs(0.5 - (float)x / subdx + sin(ymotion + norm_y * PI / 4));
			
			stroke(abs(sin(xmotion * 8 + norm_x * PI * 2)) * 180 + abs(cos(ymotion * 8 + norm_y * PI * 1.5)) * 180, 192, 255, 192);
			strokeWeight(random(0.05, 1));
			
			float xs = width / subdx;
			float ys = height / subdy;
			
			float xp = xs * x;
			float yp = ys * y;
			
			// a random quad
			PVector p1 = new PVector(random(xp, xs + xp), random(yp, ys + yp));
			PVector p2 = new PVector(random(xp, xs + xp), random(yp, ys + yp));
			PVector p3 = new PVector(random(xp, xs + xp), random(yp, ys + yp));
			PVector p4 = new PVector(random(xp, xs + xp), random(yp, ys + yp));

			float bezier_smooth_factor = abs(sin(xmotion * 2 + norm_x * norm_y * PI / 2)) * pn * 24;//random(0, 4);

			BCtrl cp1 = findbeziercontrolpoints(p4, p1, p2, p3, bezier_smooth_factor);
			BCtrl cp2 = findbeziercontrolpoints(p1, p2, p3, p4, bezier_smooth_factor);
			BCtrl cp3 = findbeziercontrolpoints(p2, p3, p4, p1, bezier_smooth_factor);
			BCtrl cp4 = findbeziercontrolpoints(p3, p4, p1, p2, bezier_smooth_factor);

			bezier(p1.x, p1.y, cp1.p1.x, cp1.p1.y, cp1.p2.x, cp1.p2.y, p2.x, p2.y);
			bezier(p2.x, p2.y, cp2.p1.x, cp2.p1.y, cp2.p2.x, cp2.p2.y, p3.x, p3.y);
			bezier(p3.x, p3.y, cp3.p1.x, cp3.p1.y, cp3.p2.x, cp3.p2.y, p4.x, p4.y);
			bezier(p4.x, p4.y, cp4.p1.x, cp4.p1.y, cp4.p2.x, cp4.p2.y, p1.x, p1.y);

		  //stroke(abs(sin(xmotion * PI) * 360), 128, 255);
			//quad(p1.x, p1.y, p2.x, p2.y, p3.x, p3.y, p4.x, p4.y);
		}
	}
	
	xmotion += 0.004;
	ymotion += 0.005;
}

void setup() {
  size(1280, 700);
	
	colorMode(HSB, 360, 255, 255);
	
	noiseDetail(7, 0.7);

  background(0);
	
	smooth();
	
	//frameRate(2);
}

void draw() {
  draw_func();
}"
"641961","Rétroaction 2","mySketch","/**
  * Procedural texture through simple feedback mechanisms again, same tech as ""feedback texturing"" sketch
	* Playing with shapes & colors
	*/

float xmotion = 8.8;
float ymotion = 2.2;

void draw_func(int s) {
	noStroke();
	
	loadPixels();
	for (int x = 0; x < width; x += 2) {
		float norm_x = abs(0.5 - x / width);
		
		for (int y = 0; y < height; y += 2) {
			color p = pixels[y * width + x];
			
			int b = brightness(p);
		
			int b2 = b / 32;
			int b3 = b / 24;
			
			if (b >= s && brightness(p) < 92) {
				float norm_y = abs(0.5 - y / height);
				
				float noise_sizex = abs(sin(xmotion / 2 + norm_x * PI)) * b3;
				float noise_sizey = abs(cos(ymotion / 2 + norm_y * PI)) * b3;

				int r = 240 + noise_sizex * 80; // h
				int g = 64; // s
				int b = 255; // l
				
				float v = 8;
				
				fill(r, g, b, 2 + v);
				ellipse(width - x, height - y, v, v);
				fill(0, 0, 0, 2);
				ellipse(width - y, height - x, v, v);	
				
				fill(0, 0, 0, 92);
				rect(x + b2, y + b2, noise_sizex, noise_sizey);
				rect(width - y + b2, height - x + b2, noise_sizex, noise_sizey);
			} else if (brightness(p) > 192) { //  + 64 * abs(sin(xmotion))
				fill(0, 0, 0, 2 + b2);
				rect(x + b2, y + b2, 32, 32);
				rect(width - y + b2, height - x + b2, 2, 2);
			}
		}
	}

	xmotion += 0.0005;
	ymotion += 0.0008;
}

void setup() {
  size(300, 300);
	
	colorMode(HSB, 360, 255, 255);

  background(0);
	
	smooth();
	
	draw_func(0);
}

void draw() {
  draw_func(64);
}"
"641954","Rétroaction","mySketch","/**
  * Procedural texture through simple feedback mechanisms again, same tech as ""feedback texturing"" sketch
	* Playing with shapes & colors
	*/

float xmotion = 8.8;
float ymotion = 2.2;

void draw_func() {
	noStroke();
	
	loadPixels();
	for (int x = 0; x < width; x += 2) {
		float norm_x = x / width;
		
		for (int y = 0; y < height; y += 4) {
			color p = pixels[y * width + x];
			
			if (brightness(p) < 2) {
				float norm_y = y / height;
				
				float noise_sizex = abs(sin(xmotion / 2 + norm_x * PI)) * random(8, 32);
				float noise_sizey = (ymotion / 2) * random(2, 8);

				int r = 90 + noise_sizex * 4; // h
				int g = 92; // s
				int b = 255; // l
				
				float v = 28 + 8 * sin(xmotion*8);
				
				fill(r, g, b, 64);
				rect(x, y, v, v);
				fill(0, 0, 0, 24);
				ellipse(y, x, v, v);	
				
				fill(0, 0, 0, 48);
				rect(x + random(2), y + random(2), noise_sizex, noise_sizey);
				rect(width - y - random(2), height - x + random(2), noise_sizex, noise_sizey);
			} else if (brightness(p) > 48) { //  + 64 * abs(sin(xmotion))
				fill(0, 0, 0, 16);
				rect(x + random(20), y + random(20), 8, 8);
				rect(width - y + random(20), height - x + random(20), 8, 8);
			}
		}
	}

	xmotion += 0.005;
	ymotion += 0.0008;
}

void setup() {
  size(400, 400);
	
	colorMode(HSB, 360, 255, 255);

  background(0);
	
	smooth();
}

void draw() {
  draw_func();
}"
"625500","Rubber Vector 2","mySketch","/*
 * ""Rubber Vector"" effect which is simply a scanline-based post-process applied to a 3D scene with a history buffer.
 * Note : this one isn't the original ""Rubber Vector"" as it doesn't pre-render a rotation, instead the history buffer is filled in real-time.
 */

float shape_size = 300;
float shape_angle_y;
float shape_z = -100;

float xmotion = 0.;
float ymotion = 0.;

PGraphics off;
PGraphics off_2d;

PImage img1;
PImage img2;

int w = 400;
int h = 400;

// for missing scanlines (think like old analog display / arcade hardware)
int iter_step_x = 1;
int iter_step_y = 1;

int scanline_history_count = 60 * 4;

color[] scanline_buffer = new color[w * h * scanline_history_count];

void setup() {
  size(w, h, P2D);  
	
	frameRate(60);
	
	noStroke();
	
	// we need a 2D offscreen context to draw the 3D offscreen context and process the pixels data
	off_2d = createGraphics(w, h, P2D);
	off_2d.background(0);

	// 3d offscreen context
	off = createGraphics(w, h, P3D);
	off.textureMode(NORMALIZED);
	off.smooth();
	off.lights();
	off.ambientLight(128, 0, 128);
	off.directionalLight(128, 128, 64, 0, 0, -1);
	off.lightFalloff(1, 0.1, 0.05);
	off.lightSpecular(0, 0, 0);

	colorMode(HSB, 360, 255, 255);
	
	background(0);
}

int frame = 0;
int frame_vel = 1;

// a mesh made of a elongated cube in a spherical pattern
void draw_mesh(float x, float y, float z) {
	float xx = x + w / 2 + sin(xmotion) * 2;
	float yy = y + h / 2 - cos(ymotion) * 2;
	float zz = z + shape_z - sin(xmotion) * 24 - 240;
	
	float scale_factor = 8;
	float spike_scale_factor = 3;
	
	off.beginDraw(); 
	off.pushMatrix();
	off.stroke(0);
	off.translate(xx, yy, zz);
  off.rotateX(shape_angle_y + 2);
	off.rotateY(ymotion / 4 + 4);
	off.rotateZ(shape_angle_y / 8 + xmotion);
  off.box(shape_size / scale_factor, shape_size / scale_factor, shape_size * spike_scale_factor);
	off.popMatrix();
	
	off.beginDraw(); 
	off.pushMatrix();
	off.stroke(0);
	off.translate(xx, yy, zz);
  off.rotateX(shape_angle_y + 2);
	off.rotateY(ymotion / 4 + 4 + radians(45));
	off.rotateZ(shape_angle_y / 8 + xmotion);
  off.box(shape_size / scale_factor, shape_size / scale_factor, shape_size * spike_scale_factor);
	off.popMatrix();
	
	off.beginDraw(); 
	off.pushMatrix();
	off.stroke(0);
	off.translate(xx, yy, zz);
  off.rotateX(shape_angle_y + 2);
	off.rotateY(ymotion / 4 + 4);
	off.rotateZ(shape_angle_y / 8 + xmotion + radians(45));
  off.box(shape_size / scale_factor, shape_size * spike_scale_factor, shape_size / scale_factor);
	off.popMatrix();
	
	off.beginDraw(); 
	off.pushMatrix();
	off.stroke(0);
	off.translate(xx, yy, zz);
  off.rotateX(shape_angle_y + 2);
	off.rotateY(ymotion / 4 + 4);
	off.rotateZ(shape_angle_y / 8 + xmotion);
  off.box(shape_size / scale_factor, shape_size * spike_scale_factor, shape_size / scale_factor);
	off.popMatrix();
	
	off.beginDraw(); 
	off.pushMatrix();
	off.stroke(0);
	off.translate(xx, yy, zz);
  off.rotateX(shape_angle_y + 2);
	off.rotateY(ymotion / 4 + 4 - radians(45));
	off.rotateZ(shape_angle_y / 8 + xmotion);
  off.box(shape_size / scale_factor, shape_size / scale_factor, shape_size * spike_scale_factor);
	off.popMatrix();
	
	off.beginDraw(); 
	off.pushMatrix();
	off.stroke(0);
	off.translate(xx, yy, zz);
  off.rotateX(shape_angle_y + 2);
	off.rotateY(ymotion / 4 + 4);
	off.rotateZ(shape_angle_y / 8 + xmotion);
  off.box(shape_size * spike_scale_factor, shape_size / scale_factor, shape_size / scale_factor);
	off.popMatrix();
	
	off.beginDraw(); 
	off.pushMatrix();
	off.stroke(0);
	off.translate(xx, yy, zz);
  off.rotateX(shape_angle_y + 2);
	off.rotateY(ymotion / 4 + 4);
	off.rotateZ(shape_angle_y / 8 + xmotion);
  off.box(shape_size * spike_scale_factor, shape_size / scale_factor, shape_size / scale_factor);
	off.popMatrix();
}
 
void draw() {
	//background(0);
  fill(0, 0, 0, 64);
  rect(0, 0, w, h);
	
	// setup light (hue/color change based on frames)
	off.noLights();
	off.lights();
	off.ambientLight(0, 0, 0);
	off.directionalLight(cos(frame / scanline_history_count * PI * 2 * 4) * 360, 128, 0 + sin(frame / scanline_history_count * PI * 2) * 128, 0, 0, -1);
	off.lightFalloff(1, 0.1 + mouseX / width, 0.05);
	off.lightSpecular(0, 0, 0);
	
	off.background(0, 0, 0, 64);
	
	// draw a mesh into the 3D offscreen context
	draw_mesh(0, 0, 0);
	
	shape_angle_y += .01;
	
	// draw the 3D offscreen context to the 2D offscreen context
	off_2d.image(off);
	
  off_2d.loadPixels();
	loadPixels();

	int i = 0;
  for (int y = 0; y < h; y += iter_step_y) {
		int yi = y * width;
		
		float norm_y = y / h;
		
		float c = cos(xmotion / 10 + norm_y * PI / 18);

		for (int x = 0; x < w; x += iter_step_x) {
			int index_src = x + yi;
			
			// standard scanline-based deformation, note : must add a factor to 'c' (and change frequency) above like : * 64
			//int index_dst = x + int(c) + yi;
			//color src_color = off_2d.pixels[index_src];
			//pixels[index_dst] = src_color;
			
			scanline_buffer[index_src + w * h * frame] = off_2d.pixels[index_src];
			
			pixels[index_src] = scanline_buffer[index_src + w * h * (int)(scanline_history_count - abs(c * scanline_history_count))];
		}
  }
	updatePixels();
	
	frame += frame_vel;
	if (frame >= scanline_history_count || frame <= 0) {
		frame_vel = -frame_vel;
	}
		
	// debug
	//image(off);
	
	xmotion += 0.05;
	ymotion += 0.09;
}"
"625399","Rubber Vector","mySketch","/*
 * Simple ""Rubber Vector"" effect which is simply a scanline-based post-process applied to a 3D scene.
 */

float shape_size = 300;
float shape_angle_y;
float shape_z = -100;

float xmotion = 0.;
float ymotion = 0.;

PGraphics off;
PGraphics off_2d;

PImage img1;
PImage img2;

int w = 600;
int h = 600;

// for missing scanlines (think like old analog display / arcade hardware)
int iter_step_x = 1;
int iter_step_y = 1;

void setup() {
  size(w, h, P2D);  
	
	frameRate(60);
	
	noStroke();
	
	// we need a 2D offscreen context to draw the 3D offscreen context and process the pixels data
	off_2d = createGraphics(w, h, P2D);
	off_2d.background(0);

	// 3d offscreen context
	off = createGraphics(w, h, P3D);
	off.textureMode(NORMALIZED);
	off.smooth();
	off.lights();
	off.ambientLight(128, 0, 128);
	off.directionalLight(128, 128, 64, 0, 0, -1);
	off.lightFalloff(1, 0.1, 0.05);
	off.lightSpecular(0, 0, 0);
	
	background(0);
}
 
void draw() {
	//background(0);
  fill(0, 0, 0, 64);
  rect(0, 0, w, h);
	
	// draw a cube into the 3D offscreen context
	off.beginDraw(); 
	off.pushMatrix();
	off.stroke(0);
	off.background(0, 0, 0, 8);
	off.translate(w / 2 + sin(xmotion) * 12, h / 2 - cos(ymotion) * 12, shape_z - sin(xmotion) * 24 - 240);
  off.rotateX(shape_angle_y + 2);
	off.rotateY(ymotion / 4 + 4);
	off.rotateZ(shape_angle_y + xmotion);
  off.box(shape_size / 2, shape_size, shape_size * 2);
	off.popMatrix();
	
	shape_angle_y += .01;
	
	// draw the 3D offscreen context to the 2D offscreen context
	off_2d.image(off);
	
  off_2d.loadPixels();
	loadPixels();

	int i = 0;
  for (int y = 0; y < h; y += iter_step_y) {
		int yi = y * width;
		
		float norm_y = y / h;
		
		float c = 64 * cos(xmotion + norm_y * PI * 2);

		for (int x = 0; x < w; x += iter_step_x) {
			int index_src = x + yi;
			int index_dst = x + int(c) + yi;
			
			color src_color = off_2d.pixels[index_src];
			
			pixels[index_dst] = src_color;
		}
  }
	updatePixels();
		
	// debug
	//image(off);
	
	xmotion += 0.05;
	ymotion += 0.09;
}"
"625399","Rubber Vector","mySketch","/*
 * ""voxels"" (sort of) from 3D rendering, the idea is to first render 3D stuff (a cube) into a offscreen context
 * then iterate over all the pixels data of that offscreen context and draw 2D shapes on screen for some of them,
 * the 2D shapes position and size are modulated to make seemingly complex stuff, the cube faces look like they are displaced,
 * some motion blur is applied to both the offscreen context and the screen,
 * the grid background is just an image, this idea can be quite fun to play with with more complex shapes and lights...!
 */

float shape_size = 300;
float shape_angle_y;
float shape_z = -100;

float xmotion = 0.;
float ymotion = 0.;

PGraphics off;
PGraphics off_2d;

PImage img1;
PImage img2;

int w = 600;
int h = 600;

// control the rendering quality / speed (basically the resolution by which we scan the 3D offscreen pixels)
int iter_step_x = 4;
int iter_step_y = 1;

int[] buffer = new int[w * h];
 
void texturedCube(PGraphics dst, PImage tex) {
  dst.beginShape(QUADS);
  dst.texture(tex);
  
	dst.vertex(-1, -1,  1, 0, 0);
	dst.vertex( 1, -1,  1, 1, 0);
	dst.vertex( 1,  1,  1, 1, 1);
	dst.vertex(-1,  1,  1, 0, 1);

	// -Z ""back"" face
	dst.vertex( 1, -1, -1, 0, 0);
	dst.vertex(-1, -1, -1, 1, 0);
	dst.vertex(-1,  1, -1, 1, 1);
	dst.vertex( 1,  1, -1, 0, 1);

	// +Y ""bottom"" face
	dst.vertex(-1,  1,  1, 0, 0);
	dst.vertex( 1,  1,  1, 1, 0);
	dst.vertex( 1,  1, -1, 1, 1);
	dst.vertex(-1,  1, -1, 0, 1);

	// -Y ""top"" face
	dst.vertex(-1, -1, -1, 0, 0);
	dst.vertex( 1, -1, -1, 1, 0);
	dst.vertex( 1, -1,  1, 1, 1);
	dst.vertex(-1, -1,  1, 0, 1);

	// +X ""right"" face
	dst.vertex( 1, -1,  1, 0, 0);
	dst.vertex( 1, -1, -1, 1, 0);
	dst.vertex( 1,  1, -1, 1, 1);
	dst.vertex( 1,  1,  1, 0, 1);

	// -X ""left"" face
	dst.vertex(-1, -1, -1, 0, 0);
	dst.vertex(-1, -1,  1, 1, 0);
	dst.vertex(-1,  1,  1, 1, 1);
	dst.vertex(-1,  1, -1, 0, 1);

  dst.endShape(CLOSE);
}

void setup() {
  size(w, h, P2D);  
	
	frameRate(60);
	
	noStroke();
	
	// we need a 2D offscreen context to draw the 3D offscreen context and process the pixels data
	off_2d = createGraphics(w, h, P2D);
	off_2d.background(0);

	// 3d offscreen context
	off = createGraphics(w, h, P3D);
	off.textureMode(NORMALIZED);
	off.smooth();
	off.lights();
	off.ambientLight(128, 0, 128);
	off.directionalLight(128, 128, 64, 0, 0, -1);
	off.lightFalloff(1, 0.1, 0.05);
	off.lightSpecular(0, 0, 0);
	//off.noFill();
	
	img1 = loadImage(""data.jpg"");
	img2 = loadImage(""vapor.jpg"");
	
	background(0);
}
 
void draw() {
	//background(0);
  fill(0, 0, 0, 64);
  rect(0, 0, w, h);
	
	// draw a cube into the 3D offscreen context
	off.beginDraw(); 
	off.pushMatrix();
	off.stroke(0);
	off.background(0, 0, 0, 8);
	off.translate(w / 2 + sin(xmotion) * 12, h / 2 - cos(ymotion) * 12, shape_z - sin(xmotion) * 24 - 240);
  off.rotateX(shape_angle_y + 2);
	off.rotateY(ymotion / 4 + 4);
	off.rotateZ(shape_angle_y + xmotion);
  off.box(shape_size / 2, shape_size, shape_size * 2);
	off.popMatrix();
	
	shape_angle_y += .01;
	
	// draw background
	off_2d.image(img1, 0, 0);
	// draw the 3D offscreen context to the 2D offscreen context
	off_2d.image(off);
	
  off_2d.loadPixels();
	loadPixels();
	//off.loadPixels();
	int i = 0;
  for (int y = 0; y < h; y += 1) {
		int yi = y * width;
		
		float norm_y = y / h;
		
		float c = 64 * cos(xmotion + norm_y * PI * 2);
		
		//arrayCopy(off_2d.pixels, yi, pixels, yi, w);
		for (int x = 0; x < w; x += 1) {
			int index_src = x + yi;
			int index_dst = x + int(c) + yi;
			
			color src_color = off_2d.pixels[index_src];
			
			pixels[index_dst] = src_color;
		}
  }
	updatePixels();
	
	
	// debug
	//image(off);
	
	xmotion += 0.05;
	ymotion += 0.09;
}"
"625399","Rubber Vector","mySketch","/*
 * ""Rubber Vector"" effect which is simply a scanline-based post-process applied to a 3D scenewuth a history buffer.
 * Note : this one isn't the original ""Rubber Vector"" as it doesn't pre-render a rotation, instead the history buffer is filled in real-time.
 */

float shape_size = 300;
float shape_angle_y;
float shape_z = -100;

float xmotion = 0.;
float ymotion = 0.;

PGraphics off;
PGraphics off_2d;

PImage img1;
PImage img2;

int w = 400;
int h = 400;

// for missing scanlines (think like old analog display / arcade hardware)
int iter_step_x = 1;
int iter_step_y = 1;

int scanline_history_count = 60 * 4;

color[] scanline_buffer = new color[w * h * scanline_history_count];

void setup() {
  size(w, h, P2D);  
	
	frameRate(60);
	
	noStroke();
	
	// we need a 2D offscreen context to draw the 3D offscreen context and process the pixels data
	off_2d = createGraphics(w, h, P2D);
	off_2d.background(0);

	// 3d offscreen context
	off = createGraphics(w, h, P3D);
	off.textureMode(NORMALIZED);
	off.smooth();
	off.lights();
	off.ambientLight(128, 0, 128);
	off.directionalLight(128, 128, 64, 0, 0, -1);
	off.lightFalloff(1, 0.1, 0.05);
	off.lightSpecular(0, 0, 0);

	colorMode(HSB, 360, 255, 255);
	
	background(0);
}

int frame = 0;
int frame_vel = 1;

// a mesh made of a cube + elongated cube for each faces / 2
void draw_mesh(float x, float y, float z) {
	float xx = x + w / 2 + sin(xmotion) * 12;
	float yy = y + h / 2 - cos(ymotion) * 12;
	float zz = z + shape_z - sin(xmotion) * 24 - 240;
	
	off.beginDraw(); 
	off.pushMatrix();
	off.stroke(0);
	off.translate(xx, yy, zz);
  //off.rotateX(shape_angle_y + 2);
	off.rotateY(ymotion / 4 + 4);
	off.rotateZ(shape_angle_y / 8 + xmotion);
  off.box(shape_size, shape_size, shape_size);
	off.popMatrix();
	
	off.beginDraw(); 
	off.pushMatrix();
	off.stroke(0);
	off.translate(xx, yy, zz);
  //off.rotateX(shape_angle_y + 2);
	off.rotateY(ymotion / 4 + 4);
	off.rotateZ(shape_angle_y / 8 + xmotion);
  off.box(shape_size / 4, shape_size / 4, shape_size * 2);
	off.popMatrix();
	
	off.beginDraw(); 
	off.pushMatrix();
	off.stroke(0);
	off.translate(xx, yy, zz);
  //off.rotateX(shape_angle_y + 2);
	off.rotateY(ymotion / 4 + 4);
	off.rotateZ(shape_angle_y / 8 + xmotion);
  off.box(shape_size * 2, shape_size / 4, shape_size / 4);
	off.popMatrix();
	
	off.beginDraw(); 
	off.pushMatrix();
	off.stroke(0);
	off.translate(xx, yy, zz);
  //off.rotateX(shape_angle_y + 2);
	off.rotateY(ymotion / 4 + 4);
	off.rotateZ(shape_angle_y / 8 + xmotion);
  off.box(shape_size / 4, shape_size * 2, shape_size / 4);
	off.popMatrix();
}
 
void draw() {
	//background(0);
  fill(0, 0, 0, 64);
  rect(0, 0, w, h);
	
	// setup light (hue/color change based on frames)
	off.noLights();
	off.lights();
	off.ambientLight(0, 0, 0);
	off.directionalLight(cos(frame / scanline_history_count * PI * 2) * 360, 255, sin(frame / scanline_history_count * PI * 2) * 255, 0, 0, -1);
	off.lightFalloff(1, 0.1 + mouseX / width, 0.05);
	off.lightSpecular(0, 0, 0);
	
	off.background(0, 0, 0, 32);
	
	// draw a mesh into the 3D offscreen context
	draw_mesh(0, 0, 0);
	
	shape_angle_y += .01;
	
	// draw the 3D offscreen context to the 2D offscreen context
	off_2d.image(off);
	
  off_2d.loadPixels();
	loadPixels();

	int i = 0;
  for (int y = 0; y < h; y += iter_step_y) {
		int yi = y * width;
		
		float norm_y = y / h;
		
		float c = cos(xmotion / 10 + norm_y * PI / 16);

		for (int x = 0; x < w; x += iter_step_x) {
			int index_src = x + yi;
			
			// standard scanline-based deformation
			//int index_dst = x + int(c) + yi;
			//color src_color = off_2d.pixels[index_src];
			//pixels[index_dst] = src_color;
			
			scanline_buffer[index_src + w * h * frame] = off_2d.pixels[index_src];
			
			pixels[index_src] = scanline_buffer[index_src + w * h * (int)(scanline_history_count - abs(c * scanline_history_count))];
		}
  }
	updatePixels();
	
	frame += frame_vel;
	if (frame >= scanline_history_count || frame <= 0) {
		frame_vel = -frame_vel;
	}
		
	// debug
	//image(off);
	
	xmotion += 0.05;
	ymotion += 0.09;
}"
"625399","Rubber Vector","mySketch","/*
 * ""Rubber Vector"" effect which is simply a scanline-based post-process applied to a 3D scene with a history buffer.
 * Note : this one isn't the original ""Rubber Vector"" as it doesn't pre-render a rotation, instead the history buffer is filled in real-time.
 */

float shape_size = 300;
float shape_angle_y;
float shape_z = -100;

float xmotion = 0.;
float ymotion = 0.;

PGraphics off;
PGraphics off_2d;

PImage img1;
PImage img2;

int w = 400;
int h = 400;

// for missing scanlines (think like old analog display / arcade hardware)
int iter_step_x = 1;
int iter_step_y = 1;

int scanline_history_count = 60 * 4;

color[] scanline_buffer = new color[w * h * scanline_history_count];

void setup() {
  size(w, h, P2D);  
	
	frameRate(60);
	
	noStroke();
	
	// we need a 2D offscreen context to draw the 3D offscreen context and process the pixels data
	off_2d = createGraphics(w, h, P2D);
	off_2d.background(0);

	// 3d offscreen context
	off = createGraphics(w, h, P3D);
	off.textureMode(NORMALIZED);
	off.smooth();
	off.lights();
	off.ambientLight(128, 0, 128);
	off.directionalLight(128, 128, 64, 0, 0, -1);
	off.lightFalloff(1, 0.1, 0.05);
	off.lightSpecular(0, 0, 0);

	colorMode(HSB, 360, 255, 255);
	
	background(0);
}

int frame = 0;
int frame_vel = 1;

// a mesh made of a cube + elongated cube for each faces / 2
void draw_mesh(float x, float y, float z) {
	float xx = x + w / 2 + sin(xmotion) * 12;
	float yy = y + h / 2 - cos(ymotion) * 12;
	float zz = z + shape_z - sin(xmotion) * 24 - 240;
	
	off.beginDraw(); 
	off.pushMatrix();
	off.stroke(0);
	off.translate(xx, yy, zz);
  //off.rotateX(shape_angle_y + 2);
	off.rotateY(ymotion / 4 + 4);
	off.rotateZ(shape_angle_y / 8 + xmotion);
  off.box(shape_size, shape_size, shape_size);
	off.popMatrix();
	
	off.beginDraw(); 
	off.pushMatrix();
	off.stroke(0);
	off.translate(xx, yy, zz);
  //off.rotateX(shape_angle_y + 2);
	off.rotateY(ymotion / 4 + 4);
	off.rotateZ(shape_angle_y / 8 + xmotion);
  off.box(shape_size / 4, shape_size / 4, shape_size * 2);
	off.popMatrix();
	
	off.beginDraw(); 
	off.pushMatrix();
	off.stroke(0);
	off.translate(xx, yy, zz);
  //off.rotateX(shape_angle_y + 2);
	off.rotateY(ymotion / 4 + 4);
	off.rotateZ(shape_angle_y / 8 + xmotion);
  off.box(shape_size * 2, shape_size / 4, shape_size / 4);
	off.popMatrix();
	
	off.beginDraw(); 
	off.pushMatrix();
	off.stroke(0);
	off.translate(xx, yy, zz);
  //off.rotateX(shape_angle_y + 2);
	off.rotateY(ymotion / 4 + 4);
	off.rotateZ(shape_angle_y / 8 + xmotion);
  off.box(shape_size / 4, shape_size * 2, shape_size / 4);
	off.popMatrix();
}
 
void draw() {
	//background(0);
  fill(0, 0, 0, 64);
  rect(0, 0, w, h);
	
	// setup light (hue/color change based on frames)
	off.noLights();
	off.lights();
	off.ambientLight(0, 0, 0);
	off.directionalLight(cos(frame / scanline_history_count * PI * 2) * 360, 255, sin(frame / scanline_history_count * PI * 2) * 255, 0, 0, -1);
	off.lightFalloff(1, 0.1 + mouseX / width, 0.05);
	off.lightSpecular(0, 0, 0);
	
	off.background(0, 0, 0, 32);
	
	// draw a mesh into the 3D offscreen context
	draw_mesh(0, 0, 0);
	
	shape_angle_y += .01;
	
	// draw the 3D offscreen context to the 2D offscreen context
	off_2d.image(off);
	
  off_2d.loadPixels();
	loadPixels();

	int i = 0;
  for (int y = 0; y < h; y += iter_step_y) {
		int yi = y * width;
		
		float norm_y = y / h;
		
		float c = cos(xmotion / 10 + norm_y * PI / 16);

		for (int x = 0; x < w; x += iter_step_x) {
			int index_src = x + yi;
			
			// standard scanline-based deformation
			//int index_dst = x + int(c) + yi;
			//color src_color = off_2d.pixels[index_src];
			//pixels[index_dst] = src_color;
			
			scanline_buffer[index_src + w * h * frame] = off_2d.pixels[index_src];
			
			pixels[index_src] = scanline_buffer[index_src + w * h * (int)(scanline_history_count - abs(c * scanline_history_count))];
		}
  }
	updatePixels();
	
	frame += frame_vel;
	if (frame >= scanline_history_count || frame <= 0) {
		frame_vel = -frame_vel;
	}
		
	// debug
	//image(off);
	
	xmotion += 0.05;
	ymotion += 0.09;
}"
"625399","Rubber Vector","mySketch","/*
 * ""Rubber Vector"" effect which is simply a scanline-based post-process applied to a 3D scene with a history buffer.
 * Note : this one isn't the original ""Rubber Vector"" as it doesn't pre-render a rotation, instead the history buffer is filled in real-time.
 */

float shape_size = 300;
float shape_angle_y;
float shape_z = -100;

float xmotion = 0.;
float ymotion = 0.;

PGraphics off;
PGraphics off_2d;

PImage img1;
PImage img2;

int w = 400;
int h = 400;

// for missing scanlines (think like old analog display / arcade hardware)
int iter_step_x = 1;
int iter_step_y = 1;

int scanline_history_count = 60 * 4;

color[] scanline_buffer = new color[w * h * scanline_history_count];

void setup() {
  size(w, h, P2D);  
	
	frameRate(60);
	
	noStroke();
	
	// we need a 2D offscreen context to draw the 3D offscreen context and process the pixels data
	off_2d = createGraphics(w, h, P2D);
	off_2d.background(0);

	// 3d offscreen context
	off = createGraphics(w, h, P3D);
	off.textureMode(NORMALIZED);
	off.smooth();
	off.lights();
	off.ambientLight(128, 0, 128);
	off.directionalLight(128, 128, 64, 0, 0, -1);
	off.lightFalloff(1, 0.1, 0.05);
	off.lightSpecular(0, 0, 0);

	colorMode(HSB, 360, 255, 255);
	
	background(0);
}

int frame = 0;
int frame_vel = 1;

// a mesh made of a cube + elongated cube for each faces / 2
void draw_mesh(float x, float y, float z) {
	float xx = x + w / 2 + sin(xmotion) * 12;
	float yy = y + h / 2 - cos(ymotion) * 12;
	float zz = z + shape_z - sin(xmotion) * 24 - 240;
	
	off.beginDraw(); 
	off.pushMatrix();
	off.stroke(0);
	off.translate(xx, yy, zz);
  //off.rotateX(shape_angle_y + 2);
	off.rotateY(ymotion / 4 + 4);
	off.rotateZ(shape_angle_y / 8 + xmotion);
  off.box(shape_size, shape_size, shape_size);
	off.popMatrix();
	
	off.beginDraw(); 
	off.pushMatrix();
	off.stroke(0);
	off.translate(xx, yy, zz);
  //off.rotateX(shape_angle_y + 2);
	off.rotateY(ymotion / 4 + 4);
	off.rotateZ(shape_angle_y / 8 + xmotion);
  off.box(shape_size / 4, shape_size / 4, shape_size * 4);
	off.popMatrix();
	
	off.beginDraw(); 
	off.pushMatrix();
	off.stroke(0);
	off.translate(xx, yy, zz);
  //off.rotateX(shape_angle_y + 2);
	off.rotateY(ymotion / 4 + 4);
	off.rotateZ(shape_angle_y / 8 + xmotion);
  off.box(shape_size * 4, shape_size / 4, shape_size / 4);
	off.popMatrix();
	
	off.beginDraw(); 
	off.pushMatrix();
	off.stroke(0);
	off.translate(xx, yy, zz);
  //off.rotateX(shape_angle_y + 2);
	off.rotateY(ymotion / 4 + 4);
	off.rotateZ(shape_angle_y / 8 + xmotion);
  off.box(shape_size / 4, shape_size * 4, shape_size / 4);
	off.popMatrix();
}
 
void draw() {
	//background(0);
  fill(0, 0, 0, 64);
  rect(0, 0, w, h);
	
	// setup light (hue/color change based on frames)
	off.noLights();
	off.lights();
	off.ambientLight(0, 0, 0);
	off.directionalLight(cos(frame / scanline_history_count * PI * 2) * 360, 255, sin(frame / scanline_history_count * PI * 2) * 255, 0, 0, -1);
	off.lightFalloff(1, 0.1 + mouseX / width, 0.05);
	off.lightSpecular(0, 0, 0);
	
	off.background(0, 0, 0, 32);
	
	// draw a mesh into the 3D offscreen context
	draw_mesh(0, 0, 0);
	
	shape_angle_y += .01;
	
	// draw the 3D offscreen context to the 2D offscreen context
	off_2d.image(off);
	
  off_2d.loadPixels();
	loadPixels();

	int i = 0;
  for (int y = 0; y < h; y += iter_step_y) {
		int yi = y * width;
		
		float norm_y = y / h;
		
		float c = cos(xmotion / 10 + norm_y * PI / 16);

		for (int x = 0; x < w; x += iter_step_x) {
			int index_src = x + yi;
			
			// standard scanline-based deformation
			//int index_dst = x + int(c) + yi;
			//color src_color = off_2d.pixels[index_src];
			//pixels[index_dst] = src_color;
			
			scanline_buffer[index_src + w * h * frame] = off_2d.pixels[index_src];
			
			pixels[index_src] = scanline_buffer[index_src + w * h * (int)(scanline_history_count - abs(c * scanline_history_count))];
		}
  }
	updatePixels();
	
	frame += frame_vel;
	if (frame >= scanline_history_count || frame <= 0) {
		frame_vel = -frame_vel;
	}
		
	// debug
	//image(off);
	
	xmotion += 0.05;
	ymotion += 0.09;
}"
"625399","Rubber Vector","mySketch","/*
 * ""Rubber Vector"" effect which is simply a scanline-based post-process applied to a 3D scene with a history buffer.
 * Note : this one isn't the original ""Rubber Vector"" as it doesn't pre-render a rotation, instead the history buffer is filled in real-time.
 */

float shape_size = 300;
float shape_angle_y;
float shape_z = -100;

float xmotion = 0.;
float ymotion = 0.;

PGraphics off;
PGraphics off_2d;

PImage img1;
PImage img2;

int w = 400;
int h = 400;

// for missing scanlines (think like old analog display / arcade hardware)
int iter_step_x = 1;
int iter_step_y = 1;

int scanline_history_count = 60 * 4;

color[] scanline_buffer = new color[w * h * scanline_history_count];

void setup() {
  size(w, h, P2D);  
	
	frameRate(60);
	
	noStroke();
	
	// we need a 2D offscreen context to draw the 3D offscreen context and process the pixels data
	off_2d = createGraphics(w, h, P2D);
	off_2d.background(0);

	// 3d offscreen context
	off = createGraphics(w, h, P3D);
	off.textureMode(NORMALIZED);
	off.smooth();
	off.lights();
	off.ambientLight(128, 0, 128);
	off.directionalLight(128, 128, 64, 0, 0, -1);
	off.lightFalloff(1, 0.1, 0.05);
	off.lightSpecular(0, 0, 0);

	colorMode(HSB, 360, 255, 255);
	
	background(0);
}

int frame = 0;
int frame_vel = 1;

// a mesh made of a cube + elongated cube for each faces / 2
void draw_mesh(float x, float y, float z) {
	float xx = x + w / 2 + sin(xmotion) * 12;
	float yy = y + h / 2 - cos(ymotion) * 12;
	float zz = z + shape_z - sin(xmotion) * 24 - 240;
	
	off.beginDraw(); 
	off.pushMatrix();
	off.stroke(0);
	off.translate(xx, yy, zz);
  //off.rotateX(shape_angle_y + 2);
	off.rotateY(ymotion / 4 + 4);
	off.rotateZ(shape_angle_y / 8 + xmotion);
  off.box(shape_size, shape_size, shape_size);
	off.popMatrix();
	
	off.beginDraw(); 
	off.pushMatrix();
	off.stroke(0);
	off.translate(xx, yy, zz);
  //off.rotateX(shape_angle_y + 2);
	off.rotateY(ymotion / 4 + 4);
	off.rotateZ(shape_angle_y / 8 + xmotion);
  off.box(shape_size / 4, shape_size / 4, shape_size * 4);
	off.popMatrix();
	
	off.beginDraw(); 
	off.pushMatrix();
	off.stroke(0);
	off.translate(xx, yy, zz);
  //off.rotateX(shape_angle_y + 2);
	off.rotateY(ymotion / 4 + 4);
	off.rotateZ(shape_angle_y / 8 + xmotion);
  off.box(shape_size * 4, shape_size / 4, shape_size / 4);
	off.popMatrix();
	
	off.beginDraw(); 
	off.pushMatrix();
	off.stroke(0);
	off.translate(xx, yy, zz);
  //off.rotateX(shape_angle_y + 2);
	off.rotateY(ymotion / 4 + 4);
	off.rotateZ(shape_angle_y / 8 + xmotion);
  off.box(shape_size / 4, shape_size * 4, shape_size / 4);
	off.popMatrix();
}
 
void draw() {
	//background(0);
  fill(0, 0, 0, 64);
  rect(0, 0, w, h);
	
	// setup light (hue/color change based on frames)
	off.noLights();
	off.lights();
	off.ambientLight(0, 0, 0);
	off.directionalLight(cos(frame / scanline_history_count * PI * 2) * 360, 255, sin(frame / scanline_history_count * PI * 2) * 255, 0, 0, -1);
	off.lightFalloff(1, 0.1 + mouseX / width, 0.05);
	off.lightSpecular(0, 0, 0);
	
	off.background(0, 0, 0, 32);
	
	// draw a mesh into the 3D offscreen context
	draw_mesh(0, 0, 0);
	
	shape_angle_y += .01;
	
	// draw the 3D offscreen context to the 2D offscreen context
	off_2d.image(off);
	
  off_2d.loadPixels();
	loadPixels();

	int i = 0;
  for (int y = 0; y < h; y += iter_step_y) {
		int yi = y * width;
		
		float norm_y = y / h;
		
		float c = cos(xmotion / 10 + norm_y * PI / 16);

		for (int x = 0; x < w; x += iter_step_x) {
			int index_src = x + yi;
			
			// standard scanline-based deformation, note : must add a factor to 'c' (and change frequency) above like : * 64
			//int index_dst = x + int(c) + yi;
			//color src_color = off_2d.pixels[index_src];
			//pixels[index_dst] = src_color;
			
			scanline_buffer[index_src + w * h * frame] = off_2d.pixels[index_src];
			
			pixels[index_src] = scanline_buffer[index_src + w * h * (int)(scanline_history_count - abs(c * scanline_history_count))];
		}
  }
	updatePixels();
	
	frame += frame_vel;
	if (frame >= scanline_history_count || frame <= 0) {
		frame_vel = -frame_vel;
	}
		
	// debug
	//image(off);
	
	xmotion += 0.05;
	ymotion += 0.09;
}"
"620758","Viscous matter","mySketch","/**
  * Procedural texture through simple feedback mechanisms
	* Same method as the others procedural texture sketchs except :
	*  - feedback is now applied on the brighter pixels (this require to do a noise pass on setup)
	*  - the noise scale function is different
	*/

float xmotion = 8.8;
float ymotion = 2.2;

float motion = -1;

void draw_func(int s) {
	noStroke();
	
	loadPixels();
	for (int x = 0; x < width; x += 2) {
		float norm_x = x / width;
		float norm_x2 = abs(0.5 - norm_x) * 2;
		float norm_x3 = abs(0.5 - sin(norm_x * PI / 2) - (cos(norm_x2 * PI * 80)));
		
		float noise_sizex = (sin(xmotion / 32)) * random(4, norm_x3 * 32);
		
		for (int y = 0; y < height; y += 2) {
			color p = pixels[y * width + x];
			
			if (brightness(p) > s) {
				float norm_y = y / height;
				
				float noise_sizey = abs(cos(ymotion / 16)) * random(4, norm_x3 * 32);

				int r = 192 + noise_sizey;
				int g = 192 + noise_sizey;
				int b = 255;
				
				fill(r, g, b, 128);
				rect(x + cos(motion * 16) * 2 * motion, y + cos(xmotion * 4) * 2 * motion, 1, 4);
				rect(y + sin(motion * 2) * 2 * motion, x + sin(motion * 16) * 2 * motion, 4, 1);	
				fill(0, 0, 0, 20);
				rect(x + cos(motion * 2), y + sin(motion * 16), (noise_sizex), (noise_sizey));
				rect(y + sin(motion * 2), x + cos(motion * 2), (noise_sizex), (noise_sizey));
			}
		}
	}

	xmotion += 0.005;
	ymotion += 0.008;
}

void setup() {
  size(600, 600);

  background(0);
	
	float noiseScale = 1.7;
	draw_func(-8);
}

void draw() {
  draw_func(164);
}"
"620751","Dusty window","mySketch","/**
  * Procedural texture through simple feedback mechanisms
	* Same method as the others procedural texture sketchs except :
	*  - feedback is now applied on the brighter pixels (this require to do a noise pass on setup)
	*  - the noise scale function is different
	*/

float xmotion = 8.8;
float ymotion = 2.2;

float motion = -1;

void draw_func(int s) {
	noStroke();
	
	loadPixels();
	for (int x = 0; x < width; x += 4) {
		float norm_x = x / width;
		float norm_x2 = abs(0.5 + sin(xmotion / 100) - norm_x) * 2;
		float norm_x3 = abs(sin(norm_x * PI) / (cos(norm_x2 * PI) * 4));
		
		float noise_sizex = (sin(xmotion / 28)) * random(2, norm_x3 * 48);
		
		for (int y = 0; y < height; y += 4) {
			color p = pixels[y * width + x];
			
			if (brightness(p) > s) {
				float norm_y = y / height;
				
				float noise_sizey = (cos(ymotion / 28)) * random(2, norm_x3 * 48);

				int r = 192;
				int g = 192;
				int b = 255;
				
				fill(r, g, b, 128);
				rect(x + random(8) * motion, y + random(8) * motion, 4, 1);
				rect(y + random(8) * motion, x + random(8) * motion, 4, 1);	
				fill(0, 0, 0, 20);
				rect(x + random(8) * motion, y + random(8) * motion, abs(noise_sizex), abs(noise_sizey));
				rect(y + random(8) * motion, x + random(8) * motion, abs(noise_sizex), abs(noise_sizey));
			}
		}
	}

	if (frameCount % (60 * 2) == 0) {
		xmotion = 8.8;
		ymotion = 2.2;
	}

	xmotion += 0.005;
	ymotion += 0.008;
}

void setup() {
  size(600, 600);

  background(0);
	
	smooth();
	
	draw_func(-8);
}

void draw() {
  draw_func(164);
}"
"616534","Scan","mySketch","float xmotion = 0;

void setup() {
	size(800, 600);
	
	colorMode(HSB, 360, 255, 255);
	
	background(0, 0, 255, 255);
	noStroke();
}

void draw() {
	noStroke();
	for (int k = 0; k < width; k += 1) {
		float norm_k = (float)k / width;

		float a = random(0, 1);
		
		if (a > 0.85) {
			float offset = (abs(xmotion * 80) % (height - 1));
			
			fill(0, 0, 0, 128);
			rect(k, height - 1 - offset, 8, 1);
			fill(0, 0, 255, 255);
			rect(width - k, height - 1 - offset, 8, 8 * a);	
			
			fill(0, 0, 0, 128);
			rect(k, offset, 8, 1);
			fill(0, 0, 255, 255);
			rect(width - k, offset, 80, 8 * a);	
		}
		
	}
	
	float noise_size = 4;
	
	loadPixels();
	for (int x = 0; x < width; x += 8) {
		for (int y = 0; y < height; y += 8) {
			color p = pixels[y * width + x];
			
			float b = brightness(p);
			
			if (b < 192) {
				fill(0, 0, 255, 24);
				ellipse(x + random(-16, 16), y + random(-16, 16), 4, 4);	
				fill(0, 0, 255, 24);
				ellipse(x + random(-64, 64), y + random(-64, 64), noise_size, noise_size);	
			}
		}
	}
	
	xmotion += 0.0075;
}"
"616517","Rosace 3","mySketch","float xmotion = 0;

void setup() {
	size(800, 600);
	
	colorMode(HSB, 360, 255, 255);
	
	background(0);
	noStroke();
}

void draw() {
	noStroke();
	
	fill(0, 0, 0, 1);
	rect(0, 0, width, height);
	
	int fill_width = 48;
	int count_y = 64;
	
	noiseDetail(9, 0.8);
	
	for (int k = 2; k < count_y; k += 2) {
		float norm_k = (float)k / count_y;
		float inorm_k = 1 - norm_k;
		
		float norm_k2 = 0.5 + abs(0.5 - norm_k) * 2;
		
		for (int i = 0; i < fill_width; i += 1) {
			float norm_i = (float)i / fill_width;
			
			float pn = noise(norm_i * 16 + xmotion / 16, norm_k * 16 + xmotion / 16);

			fill(32 * pn * inorm_k * 8, 255 * pn, 255 * abs((0.5 + sin(xmotion * 2) / 16) - norm_k) * 2, 255 * inorm_k);
			
			float x = width / 2 + cos(norm_i * PI * 2 + xmotion + norm_k * PI * 2) * 8 * k + sin(norm_i * PI * (4 + abs(sin(xmotion / 5 + PI * 2) * 4))) * 16;
			float y = height / 2 + sin(norm_i * PI * 2 + xmotion + norm_k * PI * 2) * 8 * k + cos(norm_i * PI * (4 + abs(sin(xmotion / 5 + PI * 2) * 4))) * 16;
			float w = 64 - cos(norm_i * PI * 16) * 32 * norm_i;
			float h = 64 - sin(norm_i * PI * 16) * 32 * norm_i;

			ellipse(x, y, w, h);
			
			noFill();
			stroke(0, 0, 255 * abs(0.5 - norm_k) * 2, 255 * abs(0.5 - norm_k) * 2);
			ellipse(width - x, height - y, h, w);
		}
	}
	
	xmotion += 0.0075;
}"
"616512","Rosace","mySketch","float xmotion = 0;

void setup() {
	size(800, 600);
	
	colorMode(HSB, 360, 255, 255);
	
	background(0);
	noStroke();
}

void draw() {
	noStroke();
	
	fill(0, 0, 0, 32);
	rect(0, 0, width, height);
	
	int fill_width = 48;
	int count_y = 64;
	
	noiseDetail(9, 0.81);
	
	for (int k = 2; k < count_y; k += 1) {
		float norm_k = (float)k / count_y;
		float inorm_k = 1 - norm_k;
		
		float norm_k2 = 0.5 + abs(0.5 - norm_k) * 2;
		
		for (int i = 0; i < fill_width; i += 1) {
			float norm_i = (float)i / fill_width;
			
			float pn = noise(norm_i * 4 + xmotion / 2, norm_k * 4 + xmotion / 2);

			fill(32 * pn * inorm_k, 255 * pn, 255 * abs((0.5 + sin(xmotion * 2) / 8) - norm_k) * 2, 128 + 128 * inorm_k);
			
			float x = width / 2 + cos(norm_i * PI * 2 + xmotion + norm_k * PI * 3) * 8 * k + sin(norm_i * PI * (4 + abs(sin(xmotion / 5 + PI * 2) * 2))) * 16;
			float y = height / 2 + sin(norm_i * PI * 2 + xmotion + norm_k * PI * 3) * 8 * k + cos(norm_i * PI * (4 + abs(sin(xmotion / 5 + PI * 2) * 2))) * 16;
			float w = 8 - cos(norm_i * PI * 16) * 4;
			float h = 8 - sin(norm_i * PI * 16) * 4;

			ellipse(x, y, w, h);
		}
	}
	
	xmotion += 0.0075;
}"
"616509","Rosace","mySketch","float xmotion = 0;

void setup() {
	size(800, 600);
	
	colorMode(HSB, 360, 255, 255);
	
	background(0);
	noStroke();
}

void draw() {
	noStroke();
	
	fill(0, 0, 0, 32);
	rect(0, 0, width, height);
	
	int fill_width = 92;
	int count_y = 24;
	
	noiseDetail(9, 0.81);
	
	for (int k = 1; k < count_y; k += 1) {
		float norm_k = (float)k / count_y;
		float inorm_k = 1 - norm_k;
		
		float norm_k2 = 0.5 + abs(0.5 - norm_k) * 2;
		
		for (int i = 0; i < fill_width; i += 1) {
			float norm_i = (float)i / fill_width;
			
			float pn = noise(norm_i * 4 + xmotion / 8, norm_k * 4 + xmotion / 8);

			fill(32 * pn * inorm_k, 255 * pn, 255 * inorm_k, 255 * inorm_k);
			
			float x = width / 2 + cos(norm_i * PI * 2 + xmotion + norm_k * PI * 2) * 32 * k + sin(norm_i * PI * (4 + abs(sin(xmotion / 5 + PI / 2) * 4))) * 16;
			float y = height / 2 + sin(norm_i * PI * 2 + xmotion + norm_k * PI * 2) * 16 * k + cos(norm_i * PI * (4 + abs(sin(xmotion / 5 + PI / 2) * 4))) * 16;
			float w = 8 - cos(norm_i * PI * 16) * 4;
			float h = 8 - sin(norm_i * PI * 16) * 4;

			ellipse(x, y, w, h);
		}
	}
	
	xmotion += 0.0075;
}"
"616486","Set your sails","mySketch","float xmotion = 0;

void setup() {
	size(800, 400);
	
	colorMode(HSB, 360, 255, 255);
	
	background(0);
	noStroke();
}

void draw() {
	noStroke();
	
	fill(0, 0, 0, 16);
	rect(0, 0, width, height);
	
	int fill_width = width / 4;
	int count_y = 20;
	
	noiseDetail(9, 0.81);
	
	for (int k = 0; k < count_y; k += 1) {
		float norm_k = (float)k / count_y;
		float inorm_k = 1 - norm_k;
		
		float norm_k2 = 0.5 + abs(0.5 - norm_k) * 2;
		
		for (int i = 0; i < fill_width; i += 1) {
			float norm_i = (float)i / fill_width;
			
			float pn = noise(norm_i, norm_k);

			float size = 256;

			float y = height - 32 * k + pn * 64 * norm_k2;
			
			int h = abs(cos(norm_k * PI / 4 + xmotion / 8) * 10) * norm_i * 5;
			int s = 255 - norm_k * 224; // / norm_i/4
			
			if (k > 14) {
				stroke(190 + 20 + h, 255 - inorm_k * 255 / 2 * norm_i, 255, inorm_k * 32);
				fill(200 + 20 + h, s / 1.5, 255, 64 * norm_i);
			} else {
				stroke(190 + 20 + h, 255 - inorm_k * 255 * 2, 255, 92);
				fill(190 + 20 + h, s, 255, 192);
			}

			ellipse(-64 + i * 8 + cos(norm_i * PI + xmotion / 2) * 64, y, size, size * 4 * pn / 6);	
		}
	}
	
	xmotion += 0.01;
}"
"616486","Set your sails","mySketch","float xmotion = 0;

void setup() {
	size(800, 400);
	
	colorMode(HSB, 360, 255, 255);
	
	background(0);
	noStroke();
}

void draw() {
	noStroke();
	
	fill(0, 0, 0, 16);
	rect(0, 0, width, height);
	
	int fill_width = width / 4;
	int count_y = 20;
	
	noiseDetail(9, 0.81);
	
	for (int k = 0; k < count_y; k += 1) {
		float norm_k = (float)k / count_y;
		float inorm_k = 1 - norm_k;
		
		float norm_k2 = 0.5 + abs(0.5 - norm_k) * 2;
		
		for (int i = 0; i < fill_width; i += 1) {
			float norm_i = (float)i / fill_width;
			
			float pn = noise(norm_i + xmotion, norm_k + xmotion);

			float size = 256;

			float y = height - 32 * k + pn * 64 * norm_k2;
			
			int h = abs(cos(norm_k * PI / 4 + xmotion / 8) * 10) * norm_i * 5;
			int s = 255 - norm_k * 224; // / norm_i/4
			
			if (k > 14) {
				stroke(190 + 20 + h, 255 - inorm_k * 255 / 2 * norm_i, 255, inorm_k * 32);
				fill(200 + 20 + h, s / 1.5, 255, 64 * norm_i);
			} else {
				stroke(190 + 20 + h, 255 - inorm_k * 255 * 2, 255, 92);
				fill(190 + 20 + h, s, 255, 192);
			}

			ellipse(-64 + i * 8 + cos(norm_i * PI + xmotion / 2) * 64, y, size, size * 4 * pn / 6);	
		}
	}
	
	xmotion += 0.0001;
}"
"616486","Set your sails","mySketch","float xmotion = 0;

void setup() {
	size(800, 400);
	
	colorMode(HSB, 360, 255, 255);
	
	background(0);
	noStroke();
}

void draw() {
	noStroke();
	
	fill(0, 0, 0, 16);
	rect(0, 0, width, height);
	
	int fill_width = width / 4;
	int count_y = 20;
	
	noiseDetail(9, 0.81);
	
	for (int k = 0; k < count_y; k += 1) {
		float norm_k = (float)k / count_y;
		float inorm_k = 1 - norm_k;
		
		float norm_k2 = 0.5 + abs(0.5 - norm_k) * 2;
		
		for (int i = 0; i < fill_width; i += 1) {
			float norm_i = (float)i / fill_width;
			
			float pn = noise(norm_i + xmotion, norm_k + xmotion);

			float size = 256;

			float y = height - 32 * k + pn * 64 * norm_k2;
			
			int h = abs(cos(norm_k * PI / 4 + xmotion / 8) * 10) * norm_i * 5;
			int s = 255 - norm_k * 224; // / norm_i/4
			
			if (k > 14) {
				stroke(190 + 20 + h, 255 - inorm_k * 255 / 2 * norm_i, 255, inorm_k * 32);
				fill(200 + 20 + h, s / 1.5, 255, 64 * norm_i);
			} else {
				stroke(190 + 20 + h, 255 - inorm_k * 255 * 2, 255, 92);
				fill(190 + 20 + h, s, 255, 192);
			}

			ellipse(-64 + i * 8 + cos(norm_i * PI + xmotion / 2) * 64, y, size, size * 4 * pn / 6);	
		}
	}
	
	xmotion += 0.000075;
}"
"616486","Set your sails","mySketch","floatfloat xmotion = 0;

void setup() {
	size(800, 400);
	
	colorMode(HSB, 360, 255, 255);
	
	background(0);
	noStroke();
}

void draw() {
	noStroke();
	
	fill(0, 0, 0, 16);
	rect(0, 0, width, height);
	
	int fill_width = width / 4;
	int count_y = 20;
	
	noiseDetail(9, 0.81);
	
	for (int k = 0; k < count_y; k += 1) {
		float norm_k = (float)k / count_y;
		float inorm_k = 1 - norm_k;
		
		float norm_k2 = 0.5 + abs(0.5 - norm_k) * 2;
		
		for (int i = 0; i < fill_width; i += 1) {
			float norm_i = (float)i / fill_width;
			
			float pn = noise(norm_i + xmotion, norm_k + xmotion);

			float size = 256;

			float y = height - 32 * k + pn * 64 * norm_k2;
			
			int h = abs(cos(norm_k * PI / 4 + xmotion / 8) * 10) * norm_i * 5;
			int s = 255 - norm_k * 224; // / norm_i/4
			
			if (k > 14) {
				stroke(190 + 20 + h, 255 - inorm_k * 255 / 2 * norm_i, 255, inorm_k * 32);
				fill(200 + 20 + h, s / 1.5, 255, 64 * norm_i);
			} else {
				stroke(190 + 20 + h, 255 - inorm_k * 255 * 2, 255, 92);
				fill(190 + 20 + h, s, 255, 192);
			}

			ellipse(-64 + i * 8 + cos(norm_i * PI + xmotion / 2) * 64, y, size, size * 4 * pn / 6);	
		}
	}
	
	xmotion += 0.000075;
}"
"616486","Set your sails","mySketch","floatfloat xmotion = 0;

void setup() {
	size(800, 400);
	
	colorMode(HSB, 360, 255, 255);
	
	background(0);
	noStroke();
}

void draw() {
	noStroke();
	
	fill(0, 0, 0, 16);
	rect(0, 0, width, height);
	
	int fill_width = width / 4;
	int count_y = 20;
	
	noiseDetail(9, 0.81);
	
	for (int k = 0; k < count_y; k += 1) {
		float norm_k = (float)k / count_y;
		float inorm_k = 1 - norm_k;
		
		float norm_k2 = 0.5 + abs(0.5 - norm_k) * 2;
		
		for (int i = 0; i < fill_width; i += 1) {
			float norm_i = (float)i / fill_width;
			
			float pn = noise(norm_i + xmotion, norm_k + xmotion);

			float size = 256;

			float y = height - 32 * k + pn * 64 * norm_k2;
			
			int h = abs(cos(norm_k * PI / 4 + xmotion / 8) * 10) * norm_i * 5;
			int s = 255 - norm_k * 224; // / norm_i/4
			
			if (k > 14) {
				stroke(190 + 20 + h, 255 - inorm_k * 255 / 2 * norm_i, 255, inorm_k * 32);
				fill(200 + 20 + h, s / 1.5, 255, 64 * norm_i);
			} else {
				stroke(190 + 20 + h, 255 - inorm_k * 255 * 2, 255, 48);
				fill(190 + 20 + h, s, 255, 192);
			}

			ellipse(-64 + i * 8 + cos(norm_i * PI + xmotion / 2) * 64, y, size, size * 4 * pn / 6);	
		}
	}
	
	xmotion += 0.000075;
}"
"616338","Kefrens bars","mySketch","/**
  * Procedural texture through simple feedback mechanisms
	* Kinda dusty / snow texture with rolling dust
	*/

float xmotion = 8.8;
float ymotion = 2.2;

float motion = -0.75;

PGraphics buffer;

int back_hue = 0;
int back_saturation = 0;
int back_brightness = 0;

void draw_func() {
	buffer.noStroke();
	
	buffer.loadPixels();
	for (int x = 0; x < width; x += 2) {
		float norm_x = x / width;
		float norm_x2 = 0.5 - abs(0.5 - sin(xmotion / 6 + norm_x * PI) - norm_x);
		
		float noise_sizex = abs(sin(xmotion * 4)) * random(4, 16 + norm_x2 * 8);
		
		for (int y = 0; y < height; y += 4) {
			color p = buffer.pixels[y * width + x];
			
			if (brightness(p) < 92) {
				float norm_y = y / height;
				
				float noise_sizey = abs(cos(ymotion * 4)) * random(4, 16 + norm_x2 * 8);
				
				int r = 40 + 40 * norm_x2;
				int g = 256;
				int b = 256;
				
				int cx = random(4 - norm_x2 * 2) * motion;
				int cy = random(4 - norm_x2 * 2) * motion;
				
				buffer.fill(r, g, b, 192 + norm_x2 * 48);
				buffer.ellipse(x + cx - noise_sizex, y - cy - noise_sizey, 4, 2);
				buffer.ellipse(y - cx - noise_sizex, x + cy - noise_sizey, 4, 2);	
				buffer.fill(0, 0, 0, 8 + norm_x2 * 2);
				buffer.ellipse(x - cx - noise_sizex, y - noise_sizey, noise_sizex, noise_sizey);
			  buffer.ellipse(y - noise_sizex, x - cy - noise_sizey, noise_sizex, noise_sizey);
			}
		}
	}
	
	image(buffer, 0, 0);
	
	xmotion += 0.005;
	ymotion += 0.008;
}

void setup() {
  size(400, 400);

	smooth();
	
	colorMode(HSB, 360, 256, 256);
	
	buffer = createGraphics(width, height);
	
	buffer.background(0);
	buffer.smooth();
	buffer.colorMode(HSB, 360, 256, 256);
	
  background(0);
	
	buffer.background(back_hue, back_saturation, back_brightness);
}

void draw() {
  draw_func();
}"
"616338","Kefrens bars","mySketch","/**
  * ""Kefren"" bars aka vertical rasters
	* How : Scan the screen vertically and draw a bar of defined width and of the leftover height for each rasters
	* Background is done with raster bars as well :)
	* Oldschool demo effect which were done with VBlank / HBlank interruption on old 80s/90s hardwares
	*/

float xmotion = 8.8;
float ymotion = 2.2;

float motion = -0.75;

PGraphics buffer;

int bar_width = 20;

// can improve speed
int step_y = 3;

int display_width = 300;
int display_height = 400;

void draw_func() {
	buffer.background(0, 0, 0, 24);
	
	for (int y = 0; y < height; y += step_y) {
		float norm_y = (float)y / height;
		float norm_ay = 1 - abs(0.5 - norm_y) * 2;
		
		//for (int y2 = y; y2 < y+step_y; y2 += 1) {
			buffer.fill(abs(cos(xmotion + norm_y * PI * 2 * 4)) * 64 * norm_ay, 224, 256, 64 * (norm_y));
			buffer.rect(0, y, width, 1);
		//}
		
		float offset_x = width / 2 + cos(xmotion / 1.25 + norm_y * PI * 2 * 3) * 16 + sin(xmotion / 1.25 + norm_y * PI * 2 * 3) * (width / 2.5 + cos(ymotion / 4 + norm_y * norm_ay * PI * 2 * 8) * 16) * norm_y;
		// can also add many others for multi kefrens bars...
		
		for (int x = 0; x < bar_width; x += 1) {
			float norm_x = (float)x / bar_width;
			float norm_ax = abs(0.5 - norm_x) * 2;

			buffer.fill(24 /** (y % 2)*/ + norm_ax * 32, 224, 256, 256);
			buffer.rect((int)offset_x + x + 1, y + 1, 1, height - y);
		}
	}

	image(buffer, 0, 0);
	
	xmotion += 0.05;
	ymotion += 0.0018;
}

void setup() {
  size(display_width, display_height);

	smooth();
	
	colorMode(HSB, 360, 256, 256);
	
	buffer = createGraphics(width, height);
	
	buffer.background(0);
	buffer.smooth();
	buffer.colorMode(HSB, 360, 256, 256);
	
  background(0);
	
	buffer.background(0);
	
	buffer.noStroke();
}

void draw() {
  draw_func();
}"
"616338","Kefrens bars","mySketch","/**
  * ""Kefren"" bars aka vertical rasters
	* How : Scan the screen vertically and draw a bar of defined width and of the leftover height for each rasters
	* Background is done with raster bars as well :)
	* Oldschool demo effect which were done with VBlank / HBlank interruption on old 80s/90s hardwares
	*/

float xmotion = 8.8;
float ymotion = 2.2;

float motion = -0.75;

PGraphics buffer;

int bar_width = 20;

// can improve speed
int step_y = 3;

int display_width = 300;
int display_height = 400;

void draw_func() {
	buffer.background(0, 0, 0, 24);
	
	for (int y = 0; y < height; y += step_y) {
		float norm_y = (float)y / height;
		float norm_ay = 1 - abs(0.5 - norm_y) * 2;
		
		//for (int y2 = y; y2 < y+step_y; y2 += 1) {
			buffer.fill(abs(cos(xmotion + norm_y * PI * 2 * 4)) * 64 * norm_ay, 224, 256, 64 * (norm_y));
			buffer.rect(0, y, width, 1);
		//}
		
		float offset_x = width / 2 + cos(xmotion / 1.25 + norm_y * PI * 2 * 3) * 16 + sin(xmotion / 1.25 + norm_y * PI * 2 * 3) * (width / 2.5 + cos(ymotion / 4 + norm_y * norm_ay * PI * 2 * 8) * 16) * norm_y;
		// can also add many others for multi kefrens bars...
		
		for (int x = 0; x < bar_width; x += 1) {
			float norm_x = (float)x / bar_width;
			float norm_ax = abs(0.5 - norm_x) * 2;

			buffer.fill(24 /** (y % 2)*/ + norm_ax * 32, 224, 256, 256);
			buffer.rect((int)offset_x + x + 1, y + 1, 1, height - y);
		}
	}

	image(buffer, 0, 0);
	
	xmotion += 0.05;
	ymotion += 0.0018;
}

void setup() {
  size(display_width, display_height);

	smooth();
	
	colorMode(HSB, 360, 256, 256);
	
	buffer = createGraphics(width, height);
	
	buffer.background(0);
	buffer.smooth();
	buffer.colorMode(HSB, 360, 256, 256);
	
  background(0);
	
	buffer.background(0);
	
	buffer.noStroke();
}

void draw() {
  draw_func();
}"
"616335","Procedural texture","mySketch","/**
  * Procedural texture through simple feedback mechanisms
	* Kinda dusty / snow texture with rolling dust
	*/

float xmotion = 8.8;
float ymotion = 2.2;

float motion = -0.75;

PGraphics buffer;

int back_hue = 0;
int back_saturation = 0;
int back_brightness = 0;

void draw_func() {
	buffer.noStroke();
	
	buffer.loadPixels();
	for (int x = 0; x < width; x += 2) {
		float norm_x = x / width;
		float norm_x2 = 0.475 - abs(0.5 * sin(xmotion / 6) - norm_x);
		
		float noise_sizex = abs(sin(xmotion / 2)) * random(8, norm_x2 * 42);
		
		for (int y = 0; y < height; y += 2) {
			color p = buffer.pixels[y * width + x];
			
			if (brightness(p) < random(48, 72)) {
				float norm_y = y / height;
				
				float noise_sizey = abs(cos(ymotion / 10)) * random(8, norm_x2 * 32);
				
				float br = abs(1.-norm_x2 * 2.5);
				
				if (br < 0.5) {
					br = 0;
				}

				int r = 160 + 40 * norm_x2;
				int g = 256;
				int b = 256 - 180 * br;
				
				int cx = random(3) * motion;
				int cy = random(3) * motion;
				
				buffer.fill(r, g, b, 192 + norm_x2 * 48);
				buffer.rect(x + cx, y + cy, 4, 2);
				buffer.rect(y + cx, x + cy, 4, 2);	
				buffer.fill(0, 0, 0, 20 - norm_x2 * 2);
				buffer.rect(x + cx, y + cy, noise_sizex, noise_sizey);
			  buffer.rect(y + cx, x + cy, noise_sizex, noise_sizey);
			}
		}
	}
	
	if (frameCount % (60 * 2) == 0) {
		xmotion = 8.8;
		ymotion = 2.2;
	}
	
	image(buffer, 0, 0);
	
	xmotion += 0.005;
	ymotion += 0.008;
}

void setup() {
  size(400, 400);

	smooth();
	
	colorMode(HSB, 360, 256, 256);
	
	buffer = createGraphics(width, height);
	
	buffer.background(0);
	buffer.smooth();
	buffer.colorMode(HSB, 360, 256, 256);
	
  background(0);
	
	buffer.background(back_hue, back_saturation, back_brightness);
}

void draw() {
  draw_func();
}"
"616335","Procedural texture","mySketch","/**
  * Procedural texture through simple feedback mechanisms
	* Oceanic
	*/

float xmotion = 8.8;
float ymotion = 2.2;

float motion = -0.75;

PGraphics buffer;

int back_hue = 0;
int back_saturation = 0;
int back_brightness = 0;

void draw_func() {
	buffer.noStroke();
	
	buffer.loadPixels();
	for (int x = 0; x < width; x += 2) {
		float norm_x = x / width;
		float norm_x2 = 0.475 - abs(0.5 * sin(xmotion / 6) - norm_x);
		
		float noise_sizex = abs(sin(xmotion / 2)) * random(8, norm_x2 * 42);
		
		for (int y = 0; y < height; y += 2) {
			color p = buffer.pixels[y * width + x];
			
			if (brightness(p) < random(48, 72)) {
				float norm_y = y / height;
				
				float noise_sizey = abs(cos(ymotion / 10)) * random(8, norm_x2 * 32);
				
				float br = abs(1.-norm_x2 * 2.5);
				
				if (br < 0.5) {
					br = 0;
				}

				int r = 160 + 40 * norm_x2;
				int g = 256;
				int b = 256 - 180 * br;
				
				int cx = random(3) * motion;
				int cy = random(3) * motion;
				
				buffer.fill(r, g, b, 192 + norm_x2 * 48);
				buffer.rect(x + cx, y + cy, 4, 2);
				buffer.rect(y + cx, x + cy, 4, 2);	
				buffer.fill(0, 0, 0, 20 - norm_x2 * 2);
				buffer.rect(x + cx, y + cy, noise_sizex, noise_sizey);
			  buffer.rect(y + cx, x + cy, noise_sizex, noise_sizey);
			}
		}
	}
	
	if (frameCount % (60 * 2) == 0) {
		xmotion = 8.8;
		ymotion = 2.2;
	}
	
	image(buffer, 0, 0);
	
	xmotion += 0.005;
	ymotion += 0.008;
}

void setup() {
  size(400, 400);

	smooth();
	
	colorMode(HSB, 360, 256, 256);
	
	buffer = createGraphics(width, height);
	
	buffer.background(0);
	buffer.smooth();
	buffer.colorMode(HSB, 360, 256, 256);
	
  background(0);
	
	buffer.background(back_hue, back_saturation, back_brightness);
}

void draw() {
  draw_func();
}"
"616328","Procedural texture","mySketch","/**
  * Procedural texture through simple feedback mechanisms
	* Kinda dusty / snow texture with rolling dust
	*/

float xmotion = 8.8;
float ymotion = 2.2;

float motion = -1;

void draw_func() {
	noStroke();
	
	loadPixels();
	for (int x = 0; x < width; x += 2) {
		float norm_x = x / width;
		float norm_x2 = abs(0.5 + sin(xmotion / 100) - norm_x);
		
		float noise_sizex = abs(sin(xmotion / 20)) * random(8, norm_x2 * 48);
		
		for (int y = 0; y < height; y += 2) {
			color p = pixels[y * width + x];
			
			if (brightness(p) < 32 * norm_x2) {
				float norm_y = y / height;
				
				float noise_sizey = abs(cos(ymotion / 20)) * random(8, norm_x2 * 48);

				int r = 192;
				int g = 192;
				int b = 255;
				
				fill(r, g, b, 128);
				rect(x + random(8) * motion, y + random(8) * motion, 4, 2);
				rect(y + random(8) * motion, x + random(8) * motion, 4, 2);	
				fill(0, 0, 0, 20);
				rect(x + random(8) * motion, y + random(8) * motion, noise_sizex, noise_sizey);
				rect(y + random(8) * motion, x + random(8) * motion, noise_sizex, noise_sizey);
			}
		}
	}
/*	
	if (frameCount % (60) == 0) {
		motion = -motion;	
	}*/
	
	if (frameCount % (60 * 2) == 0) {
		xmotion = 8.8;
		ymotion = 2.2;
	}

	xmotion += 0.005;
	ymotion += 0.008;
}

void setup() {
  size(600, 600);

  background(0);
	
	smooth();
}

void draw() {
  draw_func();
}"
"616324","Procedural texture","mySketch","/**
  * Procedural texture through simple feedback mechanisms, same tech as ""feedback texturing"" sketch with different setup
	* The idea was to make some kind of old stone texture with resplenishing materials + erosion
	* akin to what can be seen in the Chronopolis movie by Piotr Kamler ~1:30 : https://www.youtube.com/watch?v=ve_iosPQeh0
	*
	* This sketch introduce a second conditional which act as ""erosion"" control by attenuating noise.
	*
	* Some pretty cool textures can be made using this method :)
	*/

float xmotion = 8.8;
float ymotion = 2.2;

void draw_func() {
	noStroke();
	
	loadPixels();
	for (int x = 0; x < width; x += 2) {
		float norm_x = x / width;
		
		float noise_sizex = abs(sin(xmotion / 2)) * random(24, 32);
		
		for (int y = 0; y < height; y += 2) {
			color p = pixels[y * width + x];
			
			if (brightness(p) < 32 * norm_x) {
				float norm_y = y / height;
				
				float noise_sizey = abs(tan(ymotion / 2)) * random(2, 8);

				int r = 192;
				int g = 192;
				int b = 255;
				
				fill(r, g, b, 128);
				ellipse(x + random(8) - 2, y + random(8) - 2, 2, 2);
				ellipse(y + random(8) - 2, x + random(8) - 2, 2, 2);	
				fill(0, 0, 0, 4);
				rect(x + random(8), y + random(8), noise_sizex, noise_sizey);
				rect(y + random(8), x + random(8), noise_sizex, noise_sizey);
			} else if (brightness(p) > 224) {
				fill(0, 0, 0, 2);
				rect(x + random(8), y + random(8), 8, 8);
				rect(y + random(8), x + random(8), 8, 8);
			}
		}
	}

	xmotion += 0.005;
	ymotion += 0.008;
}

void setup() {
  size(600, 600);

  background(0);
	
	smooth();
}

void draw() {
  draw_func();
}"
"616324","Procedural texture","mySketch","/**
  * Procedural texture through simple feedback mechanisms, same tech as ""feedback texturing"" sketch with different setup
	* The idea was to make some kind of old stone texture with resplenishing materials + erosion
	* akin to what can be seen in the Chronopolis movie by Piotr Kamler ~1:30 : https://www.youtube.com/watch?v=ve_iosPQeh0
	*
	* This sketch introduce a second conditional which act as ""erosion"" control by attenuating noise.
	*
	* Some pretty cool textures can be made using this method :)
	*/

float xmotion = 8.8;
float ymotion = 2.2;

void draw_func() {
	noStroke();
	
	loadPixels();
	for (int x = 0; x < width; x += 2) {
		float norm_x = x / width;
		
		float noise_sizex = abs(0.5-sin(xmotion / 2)) * random(24, 32);
		
		for (int y = 0; y < height; y += 2) {
			color p = pixels[y * width + x];
			
			if (brightness(p) < 32 * norm_x) {
				float norm_y = y / height;
				
				float noise_sizey = abs(0.5-tan(ymotion / 2)) * random(2, 8);

				int r = 192;
				int g = 192;
				int b = 255;
				
				fill(r, g, b, 128);
				ellipse(x + random(8) - 2, y + random(8) - 2, 2, 2);
				ellipse(y + random(8) - 2, x + random(8) - 2, 2, 2);	
				fill(0, 0, 0, 4);
				rect(x + random(8), y + random(8), noise_sizex, noise_sizey);
				rect(y + random(8), x + random(8), noise_sizex, noise_sizey);
			} else if (brightness(p) > 224) {
				fill(0, 0, 0, 2);
				rect(x + random(8), y + random(8), 8, 8);
				rect(y + random(8), x + random(8), 8, 8);
			}
		}
	}

	xmotion += 0.005;
	ymotion += 0.008;
}

void setup() {
  size(600, 600);

  background(0);
	
	smooth();
}

void draw() {
  draw_func();
}"
"616324","Procedural texture","mySketch","/**
  * Procedural texture through simple feedback mechanisms, same tech as ""feedback texturing"" sketch with different setup
	* The idea was to make some kind of old stone texture with resplenishing materials + erosion
	* akin to what can be seen in the Chronopolis movie by Piotr Kamler ~1:30 : https://www.youtube.com/watch?v=ve_iosPQeh0
	*
	* This sketch introduce a second conditional which act as ""erosion"" control by attenuating noise.
	*
	* Some pretty cool textures can be made using this method :)
	*/

float xmotion = 8.8;
float ymotion = 2.2;

void draw_func() {
	noStroke();
	
	loadPixels();
	for (int x = 0; x < width; x += 2) {
		float norm_x = x / width;
		
		float noise_sizex = abs(sin(xmotion / 2)) * random(24, 32);
		
		for (int y = 0; y < height; y += 2) {
			color p = pixels[y * width + x];
			
			if (brightness(p) < 32 * norm_x) {
				float norm_y = y / height;
				
				float noise_sizey = abs(tan(ymotion / 2)) * random(2, 8);

				int r = 192;
				int g = 192;
				int b = 255;
				
				fill(r, g, b, 128);
				ellipse(x + random(8) - 2, y + random(8) - 2, 2, 2);
				ellipse(y + random(8) - 2, x + random(8) - 2, 2, 2);	
				fill(0, 0, 0, 4);
				rect(x + random(8), y + random(8), noise_sizex, noise_sizey);
				rect(y + random(8), x + random(8), noise_sizex, noise_sizey);
			} else if (brightness(p) > 224) {
				fill(0, 0, 0, 2);
				rect(x + random(8), y + random(8), 8, 8);
				rect(y + random(8), x + random(8), 8, 8);
			}
		}
	}

	xmotion += 0.005;
	ymotion += 0.008;
}

void setup() {
  size(600, 600);

  background(0);
	
	smooth();
}

void draw() {
  draw_func();
}"
"610184","Torn sky 2","mySketch","// speed / quality control
int step_x = 3;
int step_y = 3;

float xmotion = 8.8;
float ymotion = 2.2;

void draw_func() {
	noStroke();
	
  fill(0, 0, 0, 2);
  rect(0, 0, width, height);
	
	float sinx = sin(xmotion * 4);

	for (int x = 0; x < width; x += step_x) {
		float norm_x = x / width;
		for (int y = 0; y < height; y += step_y) {
			float norm_y = y / height;
			
			// convection is done by moving 3d noise
			noiseDetail(9, 0.8);
			float pn = noise(x / width - cos(xmotion) * 80, y / height + xmotion, ymotion / 8) * abs(0.5 + norm_x) * 2;
			// we subtract it with another to make it more interesting
			noiseDetail(1, 0.35);
			pn *= noise((width - x) / width - sin(xmotion) * 8, (height - y) / height - xmotion / 2 + cos(ymotion) * 8, ymotion / 2) * (1 + 1.975 * abs(cos(ymotion * 8)));
			
			// make the noise more interesting
			float n = abs(max(pow(24 * pn, pn) * 28 * ((y - (height / 2 - (height / 2))) / (height)), 1.));
			
			// hue palette range is 0 / 60, saturation is adjusted from the height so that plasma turn into regular smoke
			fill(abs(sin(xmotion * 4) * 44) + min(n / 20, 160), 255 - 255 * abs(0.5 + 0.25 * sin(norm_y * 2 + xmotion * 16) - norm_y / 0.5), 8 + n / abs(0.5 + (sinx / 2) * cos(norm_x * 8 + ymotion * 8) * norm_x - norm_y) / 48, 255 * norm_y);
			rect(x, y, step_x, step_y);
			
			// smooth it out by adding randomness, this improve quality and is used to counter the high stepping effect
			/*rect(x + random(2, 2), y + random(-2, 2), 2, 2);
			rect(x + random(-2, 2), y + random(-2, 2), 2, 2);*/
		}
	}
	
	xmotion += 0.005;
	ymotion += 0.008;
}

void setup() {
  size(400, 400);

  frameRate(60); 

  background(0);
	
	//smooth();
	
	colorMode(HSB, 360, 256, 256);
}

void draw() {
	draw_func();
}"
"609383","Torn sky","mySketch","// speed / quality control
int step_x = 4;
int step_y = 4;

float xmotion = 8.8;
float ymotion = 2.2;

void draw_func() {
	noStroke();
	
  fill(0, 0, 0, 32);
  rect(0, 0, width, height);
	
	float sinx = sin(xmotion * 4);

	for (int x = 0; x < width; x += step_x) {
		float norm_x = x / width;
		for (int y = 0; y < height; y += step_y) {
			float norm_y = y / height;
			
			// convection is done by moving 3d noise
			noiseDetail(9, 0.78);
			float pn = noise(x / width - xmotion / 2, y / height + xmotion, ymotion / 8) * abs(0.5 + norm_x) * 2;
			// we subtract it with another to make it more interesting
			noiseDetail(1, 0.45);
			pn *= noise((width - x) / width, (height - y) / height - xmotion / 2, ymotion / 2) * 1.75;
			
			// make the noise more interesting
			float n = abs(max(pow(24 * pn, pn) * 28 * ((y - (height / 2 - (height / 2))) / (height)), 1.));
			
			// hue palette range is 0 / 60, saturation is adjusted from the height so that plasma turn into regular smoke
			fill(abs(sin(xmotion * 4) * 54) + min(n / 20, 160), 255 - 255 * abs(0.5 + 0.25 * sin(norm_y * 2 + xmotion * 16) - norm_y / 0.5), 8 + n / abs(0.5 + (sinx / 4) * cos(norm_x * 8 + ymotion * 8) - norm_y) / 48, 255 * norm_y);
			rect(x, y, step_x, step_y);
			
			// smooth it out by adding randomness, this improve quality and is used to counter the high stepping effect
			/*rect(x + random(2, 2), y + random(-2, 2), 2, 2);
			rect(x + random(-2, 2), y + random(-2, 2), 2, 2);*/
		}
	}
	
	xmotion += 0.005;
	ymotion += 0.008;
}

void setup() {
  size(400, 400);

  frameRate(60); 

  background(0);
	
	//smooth();
	
	colorMode(HSB, 360, 256, 256);
}

void draw() {
	draw_func();
}"
"607383","Voxel landscape","mySketch","/**
  * Custom raycaster done for fun on a phone (APDE Android app.) while commuting.
	* Improved afterward on desktop because APDE is buggy and crashed as the sketch complexity increased ! :)
	*
	* This use Wolfenstein 3D textures.
	*
	* This is actually a 2D volume raycaster as map objects are as-is (not blocky) thus it allow curved walls and any wall shapes actually for free...
	* It is however a bit slower than a blocky raycaster and will take way more memory.
	* The rays are also not going from grid cell to grid cell but as a steady user-defined step (enhance why it is more like a volume raycaster),
	* one could extend this to cast rays in a more free ways (in all direction: 3D) and this would basically become a volume raycaster so voxels yeh! :)
	*
	* A blocky raycaster (a la Wolfenstein 3D) isn't really far from this, the ray step would need to be fixed to the 2D grid and the grid objects would just need to have a defined size.
	*
	* The walls are mirrored on the y axis so we get a cheap floor mirror :p
	*/

static int display_width = 640;
static int display_height = 480;

static int board_width = 256;
static int board_height = board_width; // linked
static int board_size = board_width * board_height;

// typically the diagonal of the map so we stop any rays casted outside...
// but this can also be used for performances, this is the camera z clipping so with fog and this we can speed the rendering up :)
static int max_ray_step = board_width * 2;

static int wall_height = 32;

static int player_fov = 60;

static int minimap_width = 128;
static int minimap_height = minimap_width; // linked
static int minimap_width_m1 = minimap_width - 1;
static int minimap_fov_step = 88;
static float minimap_scale_x = (float)minimap_width / board_width;
static float minimap_scale_y = (float)minimap_height / board_height;

// increase for more performances
static int stepping_x = 8;
static int floor_stepping = 8;
static int ceil_stepping = 8;
static int texture_stepping = 2;

int edit_mode = 0;

float boards[];
// we use this actually instead of ""boards"" to store the map data
// this allow to draw our map directly with Processing shapes since we are not restricted to perpendicular walls :)
PGraphics pg_map;

PVector raydir[];
PVector latest_rays[];

PImage textures;

PGraphics pg_minimap;

// an entity class which hold player data and other entities
class Entity {
  PVector position;
  float rotation;
  float fov;
	float dst_proj_plane;
	float vel_multiplier = 2;
  float height = 50;
 
  Entity(PVector position, float rotation, float fov) {
    this.position = position;
    this.rotation = rotation;
    this.fov = fov;
		this.dst_proj_plane = 160 / tan(radians(fov / 2));
  }
};

Entity player = new Entity(
    new PVector(board_width / 2,
                board_height / 2), 90, player_fov);

void setup() {
  size(display_width, display_height);
  frameRate(60);
  colorMode(RGB,255,255,255,100);
 
	// initialize the map
	// since this is a volume raycaster we can do fun walls so we use curves, ellipse and more :)
	pg_map = createGraphics(board_width, board_height);
	pg_map.beginDraw();
	pg_map.noFill();
	pg_map.stroke(255);
	pg_map.rect(0, 0, board_width - 1, board_height - 1);
	pg_map.bezier(85, 20, 10, 10, 90, 90, 15, 80);
	pg_map.bezier(85 * 2, 20 * 2, 10 * 2, 10 * 2, 90 * 2, 90 * 2, 15 * 2, 80 * 2);
	pg_map.ellipse(board_width / 1.25, board_height / 1.25, 16, 16);
	pg_map.triangle(192, 200, 100, 210, 95, 240);
	pg_map.endDraw();
	pg_map.loadPixels();
	
/* // classical array
	boards = new float[board_size];

  for (int i = 0; i < board_width; i += 1) {
    boards[i] = 1;
    boards[i + board_width * (board_height - 1)] = 1;
  }
 
  for (int i = 0; i < board_height; i += 1) {
    boards[i * board_width] = 1;
    boards[(board_width - 1) + i * board_width] = 1;
  }
	
	for (int i = 0; i < 360; i += 1) {
		boards[(int)(board_width / 4 + 4 * cos(radians(i))) + (int)(board_height / 4 + 4 * sin(radians(i))) * board_width] = 1;
		boards[(int)(board_width / 4 + 4 * cos(radians(i))) + (int)(board_height - board_height / 4 + 4 * sin(radians(i))) * board_width] = 1;
		boards[(int)(board_width - board_width / 4 + 4 * cos(radians(i))) + (int)(board_height / 4 + 4 * sin(radians(i))) * board_width] = 1;
		boards[(int)(board_width - board_width / 4 + 4 * cos(radians(i))) + (int)(board_height - board_height / 4 + 4 * sin(radians(i))) * board_width] = 1;
	}
*/
	
	// pre-calculate all ray directions for the player FOV
	raydir = new PVector[width * 360];
	
	for (int i = 0; i < (width * 360); i += 1) {
		int rotation_degree = int((float)i / width);

		float ri = i % width;
		float norm_i = ri / width;
		
		raydir[i] = new PVector(
									cos(radians(rotation_degree) - radians(player.fov / 2) + radians(player.fov) * norm_i),
		            	sin(radians(rotation_degree) - radians(player.fov / 2) + radians(player.fov) * norm_i));
	}
	
	// latest rays are stored here (used to display the player FOV in the minimap)
	latest_rays = new PVector[width];
	for (int i = 0; i < width; i += 1) {
		latest_rays[i] = new PVector(0, 0);
	}
	
	textures = loadImage(""wolftextures.png"");
	textures.loadPixels();
	
	pg_minimap = createGraphics(minimap_width, minimap_height);
	
	updateMinimap();
	
}

void draw() {
  background(0);
 
  noStroke();
 
  raycast();
	
	if (edit_mode) {
		
	} else {
  	render_minimap();
	}
 
  player.rotation = ((float)mouseX / width * 2 * 359) % 360;
	
	keyPressCheck();
}

// core algorithm
void raycast() {
  int i = 0, j = 0;
	
	int rot_i = int(player.rotation) * width;
	
	// scan the screen horizontally and raycast from the defined player FOV
  for (i = 0; i < width; i += stepping_x) {
    float norm_i = (float)i / width;
		
		// we use pre-computed ray directions (see below for the raw formula)
		PVector ray_direction = raydir[i + rot_i];
   
    float dx = ray_direction.x;
		//float dx = cos(radians(player.rotation) - radians(player.fov / 2) + radians(player.fov) * norm_i);
    float dy = ray_direction.y;
		//float dy = sin(radians(player.rotation) - radians(player.fov / 2) + radians(player.fov) * norm_i);
		
    float px = player.position.x;
    float py = player.position.y;
		
		int step = 0;
		
		// traverse the map & check for collisions
    while (step < max_ray_step) {
      //float result = boards[(int)px + (int)py * board_width];
			float result = brightness(pg_map.pixels[(int)px + (int)py * board_width]);
     
      if (result > 0) {					
				// compute distance with corrected perspective
				// if the perspective is not corrected this will produce fish-eye / distorded walls effect because rays on the edge of the screen need to travel 'further' than the middle rays one 
				float ddx = abs(player.position.x - px);
				float ddy = abs(player.position.y - py);
				
        float dist = sqrt(ddx * ddx + ddy * ddy) * (cos(-radians(player.fov / 2) + radians(player.fov) * norm_i));
        float norm_dist = dist / max(board_width, board_height) / 1.25;
				float inorm_dist = max(1 - norm_dist, 0.01);
				
				// determine horizontal texture coordinate (note : not really correct!!)
				float tu = abs(px - py);

				// determine wall height from the computed distance
				// dst_proj_plane is just a value related to the FOV, it relate to the player / projection plane distance
        float wh = wall_height / dist * player.dst_proj_plane;
				// now determine the vertical wall start position
        float wall_start_y = height / 2 - wh / 2 + player.height;
				
				// draw wall (untextured)
				/*
				fill(inorm_dist * 255, 0, 0, 255);
        rect(i, wall_start_y, stepping_x, wh);
				*/
				
				// simple ceiling
				/*int ceil_start = height / 2;
				for (j = ceil_start; j > -ceil_stepping; j -= ceil_stepping) {
					float inorm_j = (float)j / (height / 2);
					float norm_j = 1. - inorm_j;
					float ceil_brightness = 255 * (inorm_j);

					fill(0, 0, ceil_brightness, 64);
					rect(i, j, stepping_x, ceil_stepping);
				}*/
				
				// can change texture here (64, 128, 192 etc)
				int u = (int(tu) % (textures.width / 8) + 64);
				
	      // draw wall (textured)
				for (j = wall_start_y; j < wall_start_y + wh; j += texture_stepping) {
					float norm_j = (float)(j - wall_start_y) / wh;
					color c = textures.pixels[u + (int(norm_j * textures.height) % textures.height) * textures.width];
					fill(red(c) * inorm_dist, green(c) * inorm_dist, blue(c) * inorm_dist);
        	rect(i, j, stepping_x, texture_stepping);
					
					float cm = norm_dist * norm_j * 2;
					
					// mirrored :)
					fill(red(c) * cm, green(c) * cm, blue(c) * cm);
					rect(i, (wall_start_y + wh) * 2 - j, stepping_x, texture_stepping);
				}
				
				// draw ceiling
				/*int ceil_start = wall_start_y - ceil_stepping;
				for (j = ceil_start; j > -ceil_stepping; j -= ceil_stepping) {
					float inorm_j = (float)j / wall_start_y;
					float norm_j = 1. - inorm_j;
					float ceil_brightness = 255 * (inorm_j * inorm_dist * 2);

					fill(0, 0, ceil_brightness, 64);
					rect(i, j, stepping_x, ceil_stepping);
				}*/
				
				// draw floor
				int floor_start = wh + wall_start_y;
				for (j = floor_start; j < height; j += floor_stepping) {
					float norm_j = (float)(j - floor_start) / (height - floor_start);
					float inorm_j = 1. - norm_j;
					float floor_brightness = 255 * norm_j;
					
					fill(floor_brightness, 0, 0, 64);
					rect(i, j, stepping_x, floor_stepping);
				}
				
				// store ray for later use (minimap FOV)
				latest_rays[i].x = floor(px);
				latest_rays[i].y = floor(py);
				
        break;
      }

			// show complete raycast FOV on minimap (pixels perfect but slow and should be computed outside to fix order issues)
      //fill(0, 255, 0, 64);
      //rect(int(px * minimap_scale_x + width - minimap_width_m1), int(py * minimap_scale_y), 1, 1);
			
      px += dx;
      py += dy;
			
			step += 1;
    }
  }
}

// physics logic
void keyPressCheck() {
  if (keyPressed) {
		int rot_i = int(player.rotation) * width;
		
		PVector ray_direction = raydir[width / 2 + rot_i];
		
		PVector velocity = new PVector(ray_direction.x, ray_direction.y);
		velocity.mult(player.vel_multiplier);
		
		int dir = 1;
		if (player.rotation > 90 || player.rotation < 180) {
			dir = -1;
		}
		
		PVector newPosition = new PVector(player.position.x, player.position.y);
		
    if (keyCode == UP) {
			newPosition.add(velocity);
		} else if (keyCode == DOWN) {
			newPosition.sub(velocity);
		}
		
		if (keyCode == LEFT) {
			newPosition.x -= cos(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
			newPosition.y -= sin(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
		} else if (keyCode == RIGHT) {
			newPosition.x += cos(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
			newPosition.y += sin(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
		}
		
		if (newPosition.x < board_width - 1 && newPosition.y < board_height - 1 &&
				newPosition.x > 0 && newPosition.y > 0) {
			player.position = newPosition;
		}
	}
}

void keyReleased() {
	if (keyCode == ENTER || keyCode == RETURN) {
		edit_mode += 1;
		edit_mode %= 2;
	}
}

// update minimap buffer (so we don't compute the minimap rendering it at every frames)
void updateMinimap() {
	pg_minimap.beginDraw();
	pg_minimap.noStroke();
	pg_minimap.fill(255);
  for (int i = 0; i < board_size; i += int(board_width / minimap_width)) {
    //float w = boards[i];
		float w = brightness(pg_map.pixels[i]);
   
    if (w > 0.5) {
			int x = i % board_width;
			int y = int((float)i / board_width);

			x = int((float)x * minimap_scale_x);
			y = int((float)y * minimap_scale_y);
     
      pg_minimap.rect(x, y, 1, 1);
    }
  }
	pg_minimap.endDraw();
}

void render_minimap() {
	int minimap_offset_x = width - minimap_width_m1;

	image(pg_minimap, minimap_offset_x, 0);
	
	// player FOV on the minimap from all the latest rays casted (fast but not pixel perfect)
	stroke(255, 0, 0);
	for (int i = 0; i < width; i += minimap_fov_step) {
		PVector ray = latest_rays[i];
		line(player.position.x * minimap_scale_x + minimap_offset_x,
				 player.position.y * minimap_scale_y,
				 ray.x * minimap_scale_x + minimap_offset_x,
				 ray.y * minimap_scale_y);
	}
	noStroke();
	
	// player position
	fill(255, 255, 0);
	ellipse(player.position.x * minimap_scale_x + minimap_offset_x,
			 player.position.y * minimap_scale_y, 6, 6);
}"
"607383","Voxel landscape","mySketch","/**
  * Custom raycaster done for fun on a phone (APDE Android app.) while commuting.
	* Improved afterward on desktop because APDE is buggy and crashed as the sketch complexity increased ! :)
	*
	* This use Wolfenstein 3D textures.
	*
	* This is actually a 2D volume raycaster as map objects are as-is (not blocky) thus it allow curved walls and any wall shapes actually for free...
	* It is however a bit slower than a blocky raycaster and will take way more memory.
	* The rays are also not going from grid cell to grid cell but as a steady user-defined step (enhance why it is more like a volume raycaster),
	* one could extend this to cast rays in a more free ways (in all direction: 3D) and this would basically become a volume raycaster so voxels yeh! :)
	*
	* A blocky raycaster (a la Wolfenstein 3D) isn't really far from this, the ray step would need to be fixed to the 2D grid and the grid objects would just need to have a defined size.
	*
	* The walls are mirrored on the y axis so we get a cheap floor mirror :p
	*/

static int display_width = 640;
static int display_height = 480;

static int board_width = 512;
static int board_height = board_width; // linked
static int board_size = board_width * board_height;

// typically the diagonal of the map so we stop any rays casted outside...
// but this can also be used for performances, this is the camera z clipping so with fog and this we can speed the rendering up :)
static int max_ray_step = board_width * 2;

static int wall_height = 32;

static int player_fov = 60;

static int minimap_width = 128;
static int minimap_height = minimap_width; // linked
static int minimap_width_m1 = minimap_width - 1;
static int minimap_fov_step = 88;
static float minimap_scale_x = (float)minimap_width / board_width;
static float minimap_scale_y = (float)minimap_height / board_height;

// increase for more performances
static int stepping_x = 8;
static int floor_stepping = 8;
static int ceil_stepping = 8;
static int texture_stepping = 2;

int edit_mode = 0;

float boards[];
// we use this actually instead of ""boards"" to store the map data
// this allow to draw our map directly with Processing shapes since we are not restricted to perpendicular walls :)
PGraphics pg_map;

PVector raydir[];
PVector latest_rays[];

PImage textures;

PGraphics pg_minimap;

// an entity class which hold player data and other entities
class Entity {
  PVector position;
  float rotation;
  float fov;
	float dst_proj_plane;
	float vel_multiplier = 2;
  float height = 50;
 
  Entity(PVector position, float rotation, float fov) {
    this.position = position;
    this.rotation = rotation;
    this.fov = fov;
		this.dst_proj_plane = 160 / tan(radians(fov / 2));
  }
};

Entity player = new Entity(
    new PVector(board_width / 2,
                board_height / 2), 90, player_fov);

void setup() {
  size(display_width, display_height);
  frameRate(60);
  colorMode(RGB,255,255,255,100);
 
	// initialize the map
	// since this is a volume raycaster we can do fun walls so we use curves, ellipse and more :)
	pg_map = createGraphics(board_width, board_height);
	
	PImage heightmap = loadImage(""heightmap.png"");
	heightmap.loadPixels();
	pg_map.loadPixels();
	
	for (int i = 0; i < 512*512; i += 1) {
		pg_map.pixels[i] = heightmap.pixels[i];
	}
	pg_map.updatePixels();
	
	/*pg_map.beginDraw();
	pg_map.noFill();
	pg_map.stroke(255);
	pg_map.rect(0, 0, board_width - 1, board_height - 1);
	pg_map.bezier(85, 20, 10, 10, 90, 90, 15, 80);
	pg_map.bezier(85 * 2, 20 * 2, 10 * 2, 10 * 2, 90 * 2, 90 * 2, 15 * 2, 80 * 2);
	pg_map.ellipse(board_width / 1.25, board_height / 1.25, 16, 16);
	pg_map.triangle(192, 200, 100, 210, 95, 240);
	pg_map.endDraw();
	pg_map.loadPixels();*/
	
/* // classical array
	boards = new float[board_size];

  for (int i = 0; i < board_width; i += 1) {
    boards[i] = 1;
    boards[i + board_width * (board_height - 1)] = 1;
  }
 
  for (int i = 0; i < board_height; i += 1) {
    boards[i * board_width] = 1;
    boards[(board_width - 1) + i * board_width] = 1;
  }
	
	for (int i = 0; i < 360; i += 1) {
		boards[(int)(board_width / 4 + 4 * cos(radians(i))) + (int)(board_height / 4 + 4 * sin(radians(i))) * board_width] = 1;
		boards[(int)(board_width / 4 + 4 * cos(radians(i))) + (int)(board_height - board_height / 4 + 4 * sin(radians(i))) * board_width] = 1;
		boards[(int)(board_width - board_width / 4 + 4 * cos(radians(i))) + (int)(board_height / 4 + 4 * sin(radians(i))) * board_width] = 1;
		boards[(int)(board_width - board_width / 4 + 4 * cos(radians(i))) + (int)(board_height - board_height / 4 + 4 * sin(radians(i))) * board_width] = 1;
	}
*/
	
	// pre-calculate all ray directions for the player FOV
	raydir = new PVector[width * 360];
	
	for (int i = 0; i < (width * 360); i += 1) {
		int rotation_degree = int((float)i / width);

		float ri = i % width;
		float norm_i = ri / width;
		
		raydir[i] = new PVector(
									cos(radians(rotation_degree) - radians(player.fov / 2) + radians(player.fov) * norm_i),
		            	sin(radians(rotation_degree) - radians(player.fov / 2) + radians(player.fov) * norm_i));
	}
	
	// latest rays are stored here (used to display the player FOV in the minimap)
	latest_rays = new PVector[width];
	for (int i = 0; i < width; i += 1) {
		latest_rays[i] = new PVector(0, 0);
	}
	
	textures = loadImage(""C2W.png"");
	textures.loadPixels();
	
	pg_minimap = createGraphics(minimap_width, minimap_height);
	
	updateMinimap();
	
}

void draw() {
  background(0);
 
  noStroke();
 
  raycast();
	
	if (edit_mode) {
		
	} else {
  	render_minimap();
	}
 
  player.rotation = ((float)mouseX / width * 2 * 359) % 360;
	
	keyPressCheck();
}

// core algorithm
void raycast() {
  int i = 0, j = 0;
	
	int rot_i = int(player.rotation) * width;
	
	// scan the screen horizontally and raycast from the defined player FOV
  for (i = 0; i < width; i += stepping_x) {
    float norm_i = (float)i / width;
		
		// we use pre-computed ray directions (see below for the raw formula)
		PVector ray_direction = raydir[i + rot_i];
   
    float dx = ray_direction.x;
		//float dx = cos(radians(player.rotation) - radians(player.fov / 2) + radians(player.fov) * norm_i);
    float dy = ray_direction.y;
		//float dy = sin(radians(player.rotation) - radians(player.fov / 2) + radians(player.fov) * norm_i);
		
    float px = player.position.x;
    float py = player.position.y;
		
		int step = 0;
		
		// traverse the map & check for collisions
    while (step < max_ray_step) {
      //float result = boards[(int)px + (int)py * board_width];
			float result = brightness(pg_map.pixels[(int)px + (int)py * board_width]);
     
      if (result > 0) {					
				// compute distance with corrected perspective
				// if the perspective is not corrected this will produce fish-eye / distorded walls effect because rays on the edge of the screen need to travel 'further' than the middle rays one 
				float ddx = abs(player.position.x - px);
				float ddy = abs(player.position.y - py);
				
        float dist = sqrt(ddx * ddx + ddy * ddy) * (cos(-radians(player.fov / 2) + radians(player.fov) * norm_i));
        float norm_dist = dist / max(board_width, board_height) / 1.25;
				float inorm_dist = max(1 - norm_dist, 0.01);
				
				// determine horizontal texture coordinate (note : not really correct!!)
				float tu = abs(px - py);

				// determine wall height from the computed distance
				// dst_proj_plane is just a value related to the FOV, it relate to the player / projection plane distance
        float wh = wall_height / dist * player.dst_proj_plane;
				// now determine the vertical wall start position
        float wall_start_y = height / 2 - wh / 2 + player.height;
				
				// draw wall (untextured)
				/*
				fill(inorm_dist * 255, 0, 0, 255);
        rect(i, wall_start_y, stepping_x, wh);
				*/
				
				// simple ceiling
				/*int ceil_start = height / 2;
				for (j = ceil_start; j > -ceil_stepping; j -= ceil_stepping) {
					float inorm_j = (float)j / (height / 2);
					float norm_j = 1. - inorm_j;
					float ceil_brightness = 255 * (inorm_j);

					fill(0, 0, ceil_brightness, 64);
					rect(i, j, stepping_x, ceil_stepping);
				}*/
				
				// can change texture here (64, 128, 192 etc)
				int u = (int(tu) % textures.width);
				
	      // draw wall (textured)
				for (j = wall_start_y; j < wall_start_y + wh; j += texture_stepping) {
					float norm_j = (float)(j - wall_start_y) / wh;
					color c = textures.pixels[u + (int(norm_j * textures.height) % textures.height) * textures.width];
					fill(red(c) * inorm_dist, green(c) * inorm_dist, blue(c) * inorm_dist);
        	rect(i, j, stepping_x, texture_stepping);
					
					float cm = norm_dist * norm_j * 2;
					
					// mirrored :)
					fill(red(c) * cm, green(c) * cm, blue(c) * cm);
					rect(i, (wall_start_y + wh) * 2 - j, stepping_x, texture_stepping);
				}
				
				// draw ceiling
				/*int ceil_start = wall_start_y - ceil_stepping;
				for (j = ceil_start; j > -ceil_stepping; j -= ceil_stepping) {
					float inorm_j = (float)j / wall_start_y;
					float norm_j = 1. - inorm_j;
					float ceil_brightness = 255 * (inorm_j * inorm_dist * 2);

					fill(0, 0, ceil_brightness, 64);
					rect(i, j, stepping_x, ceil_stepping);
				}*/
				
				// draw floor
				int floor_start = wh + wall_start_y;
				for (j = floor_start; j < height; j += floor_stepping) {
					float norm_j = (float)(j - floor_start) / (height - floor_start);
					float inorm_j = 1. - norm_j;
					float floor_brightness = 255 * norm_j;
					
					fill(floor_brightness, 0, 0, 64);
					rect(i, j, stepping_x, floor_stepping);
				}
				
				// store ray for later use (minimap FOV)
				latest_rays[i].x = floor(px);
				latest_rays[i].y = floor(py);
				
        break;
      }

			// show complete raycast FOV on minimap (pixels perfect but slow and should be computed outside to fix order issues)
      //fill(0, 255, 0, 64);
      //rect(int(px * minimap_scale_x + width - minimap_width_m1), int(py * minimap_scale_y), 1, 1);
			
      px += dx;
      py += dy;
			
			step += 1;
    }
  }
}

// physics logic
void keyPressCheck() {
  if (keyPressed) {
		int rot_i = int(player.rotation) * width;
		
		PVector ray_direction = raydir[width / 2 + rot_i];
		
		PVector velocity = new PVector(ray_direction.x, ray_direction.y);
		velocity.mult(player.vel_multiplier);
		
		int dir = 1;
		if (player.rotation > 90 || player.rotation < 180) {
			dir = -1;
		}
		
		PVector newPosition = new PVector(player.position.x, player.position.y);
		
    if (keyCode == UP) {
			newPosition.add(velocity);
		} else if (keyCode == DOWN) {
			newPosition.sub(velocity);
		}
		
		if (keyCode == LEFT) {
			newPosition.x -= cos(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
			newPosition.y -= sin(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
		} else if (keyCode == RIGHT) {
			newPosition.x += cos(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
			newPosition.y += sin(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
		}
		
		if (newPosition.x < board_width - 1 && newPosition.y < board_height - 1 &&
				newPosition.x > 0 && newPosition.y > 0) {
			player.position = newPosition;
		}
	}
}

void keyReleased() {
	if (keyCode == ENTER || keyCode == RETURN) {
		edit_mode += 1;
		edit_mode %= 2;
	}
}

// update minimap buffer (so we don't compute the minimap rendering it at every frames)
void updateMinimap() {
	pg_minimap.beginDraw();
	pg_minimap.noStroke();
	pg_minimap.fill(255);
  for (int i = 0; i < board_size; i += int(board_width / minimap_width)) {
    //float w = boards[i];
		float w = brightness(pg_map.pixels[i]);
   
    if (w > 0.5) {
			int x = i % board_width;
			int y = int((float)i / board_width);

			x = int((float)x * minimap_scale_x);
			y = int((float)y * minimap_scale_y);
     
      pg_minimap.rect(x, y, 1, 1);
    }
  }
	pg_minimap.endDraw();
}

void render_minimap() {
	int minimap_offset_x = width - minimap_width_m1;

	image(pg_minimap, minimap_offset_x, 0);
	
	// player FOV on the minimap from all the latest rays casted (fast but not pixel perfect)
	stroke(255, 0, 0);
	for (int i = 0; i < width; i += minimap_fov_step) {
		PVector ray = latest_rays[i];
		line(player.position.x * minimap_scale_x + minimap_offset_x,
				 player.position.y * minimap_scale_y,
				 ray.x * minimap_scale_x + minimap_offset_x,
				 ray.y * minimap_scale_y);
	}
	noStroke();
	
	// player position
	fill(255, 255, 0);
	ellipse(player.position.x * minimap_scale_x + minimap_offset_x,
			 player.position.y * minimap_scale_y, 6, 6);
}"
"607383","Voxel landscape","mySketch","/**
  * This is like my custom volume raycaster sketch but tuned for 'infinite' voxel landscapes.
	*
	* It is the same technically except that rays go from far to near and are not stopped once they hit something (they walk on the heightmap)
	* Another difference is that it is infinite, rays are warped when they go outside map boundary
	*
	* This sketch is much faster also because texturing is almost free; from a secondary colormap.
	*
	* Perspective is done that way for fun, it look like the inside of a sphere with mapped terrain :)
	* Heightmap and Colormap come from Comanche game
	*
	* Water level is not rendered correctly, this may be fixed by drawing front to back (this may be faster as well)
	*
	* All of these rendering tricks are specialized version of voxel rendering.
	*/

static int display_width = 640;
static int display_height = 480;

static int board_width = 512;
static int board_height = board_width; // linked
static int board_size = board_width * board_height;

// typically the diagonal of the map so we stop any rays casted outside...
// but this can also be used for performances, this is the camera z clipping so with fog and this we can speed the rendering up :)
static int max_ray_step = board_width / 2;

static int wall_height = 1;

static int player_fov = 60;

static int minimap_width = 128;
static int minimap_height = minimap_width; // linked
static int minimap_width_m1 = minimap_width - 1;
static int minimap_fov_step = 88;
static float minimap_scale_x = (float)minimap_width / board_width;
static float minimap_scale_y = (float)minimap_height / board_height;

// increase for more performances
static int stepping_x = 4;

float boards[];
// we use this actually instead of ""boards"" to store the map data
// this allow to draw our map directly with Processing shapes since we are not restricted to perpendicular walls :)
PImage pg_map;

PVector raydir[];
PVector latest_rays[];

PImage textures;

PGraphics pg_minimap;

// an entity class which hold player data and other entities
class Entity {
  PVector position;
  float rotation;
  float fov;
	float dst_proj_plane;
	float vel_multiplier = 2;
  float height = 164;
 
  Entity(PVector position, float rotation, float fov) {
    this.position = position;
    this.rotation = rotation;
    this.fov = fov;
		this.dst_proj_plane = 160 / tan(radians(fov / 2));
  }
};

Entity player = new Entity(
    new PVector(board_width / 2,
                board_height / 2), 90, player_fov);

int pred = 0;

void setup() {
  size(display_width, display_height);
  frameRate(60);
  colorMode(RGB,255,255,255,100);
 
	// initialize the map from a heightmap
	pg_map = loadImage(""heightmap.png"");
	pg_map.loadPixels();
	
	// pre-calculate all ray directions for the player FOV
	raydir = new PVector[width * 360];
	
	for (int i = 0; i < (width * 360); i += 1) {
		int rotation_degree = int((float)i / width);

		float ri = i % width;
		float norm_i = ri / width;
		
		raydir[i] = new PVector(
									cos(radians(rotation_degree) - radians(player.fov / 2) + radians(player.fov) * norm_i),
		            	sin(radians(rotation_degree) - radians(player.fov / 2) + radians(player.fov) * norm_i));
	}
	
	// latest rays are stored here (used to display the player FOV in the minimap)
	latest_rays = new PVector[width];
	for (int i = 0; i < width; i += 1) {
		latest_rays[i] = new PVector(0, 0);
	}
	
	textures = loadImage(""C2W.png"");
	textures.loadPixels();
	
	pg_minimap = createGraphics(minimap_width, minimap_height);
	
	pred = red(pg_map.pixels[0]);
}

void draw() {
  background(0);
 
  noStroke();
 
  raycast();
	
	render_minimap();
 
  player.rotation = ((float)mouseX / width * 2 * 359) % 360;
	
	// comment this and uncomment keyPressCheck for regular keyboard playable movement
	move();
	
	//keyPressCheck();
	
	// we update the minimap only once when the heightmap is loaded (need that to avoid asynchronous issues)
	if (red(pg_map.pixels[0]) != pred) {
		updateMinimap();
		
		pred = red(pg_map.pixels[0]);
	}
}

// core algorithm
void raycast() {
  int i = 0, j = 0;
	
	int rot_i = int(player.rotation) * width;
	
	// scan the screen horizontally and raycast from the defined player FOV
  for (i = 0; i < width; i += stepping_x) {
    float norm_i = (float)i / width;
		
		// we use pre-computed ray directions (see below for the raw formula)
		PVector ray_direction = raydir[i + rot_i];
   
    float dx = ray_direction.x;
		//float dx = cos(radians(player.rotation) - radians(player.fov / 2) + radians(player.fov) * norm_i);
    float dy = ray_direction.y;
		//float dy = sin(radians(player.rotation) - radians(player.fov / 2) + radians(player.fov) * norm_i);
		
    float px = player.position.x + dx * max_ray_step;
    float py = player.position.y + dy * max_ray_step;
		
		latest_rays[i].x = floor(px);
		latest_rays[i].y = floor(py);
		
		int step = 0;
		
		// traverse the map & check for collisions
    while (step < max_ray_step) {
			int ix = (int)px;
			int iy = (int)py;
			
      //float result = boards[(int)px + (int)py * board_width];
			color result = pg_map.pixels[ix + iy * board_width];
			
			float heightmap_height = red(result);
     
      if (heightmap_height > 0) {
				float dst = (float)step / max_ray_step;
				
				// now determine the slice height from heightmap brightness value and fake the perspective
        int wall_start_y = (height - height * ((float)heightmap_height / 255)) * dst * 2 - (max_ray_step - player.height);
				
				// draw terrain slice with color from colormap (* 2 because the colormap size is 1024 and heightmap 512)
				color colormap = textures.pixels[ix * 2 + iy * 2 * textures.width];
				
				fill(red(colormap), green(colormap), blue(colormap));
        rect(i, wall_start_y, stepping_x, height - wall_start_y);
      }

			// show complete raycast FOV on minimap (pixels perfect but slow and should be computed outside to fix order issues)
      //fill(0, 255, 0, 64);
      //rect(int(px * minimap_scale_x + width - minimap_width_m1), int(py * minimap_scale_y), 1, 1);
			
      px -= dx;
      py -= dy;
			
			if (px < 0) {
				px = board_width - abs(px);	
			}
			
			px = px % board_width;
			
			if (py < 0) {
				py = board_height - abs(py);	
			}
			
			py = py % board_height;
			
			step += 1;
    }
  }
}

// just move up
void move() {
	int rot_i = int(player.rotation) * width;

	PVector ray_direction = raydir[width / 2 + rot_i];

	PVector velocity = new PVector(ray_direction.x, ray_direction.y);
	velocity.mult(player.vel_multiplier);
	
	PVector newPosition = new PVector(player.position.x, player.position.y);
	newPosition.add(velocity);
	player.position = newPosition;	
	
	if (player.position.x < 0) {
		player.position.x = board_width - 1;
	}
	
	if (player.position.y < 0) {
		player.position.y = board_height - 1;
	}
	
	if (player.position.x > board_width) {
		player.position.x = 0;
	}

	if (player.position.y > board_height) {
		player.position.y = 0;
	}
}

// physics logic (unused but working!)
void keyPressCheck() {
  if (keyPressed) {
		int rot_i = int(player.rotation) * width;
		
		PVector ray_direction = raydir[width / 2 + rot_i];
		
		PVector velocity = new PVector(ray_direction.x, ray_direction.y);
		velocity.mult(player.vel_multiplier);
		
		int dir = 1;
		if (player.rotation > 90 || player.rotation < 180) {
			dir = -1;
		}
		
		PVector newPosition = new PVector(player.position.x, player.position.y);
		
    if (keyCode == UP) {
			newPosition.add(velocity);
		} else if (keyCode == DOWN) {
			newPosition.sub(velocity);
		}
		
		if (keyCode == LEFT) {
			newPosition.x -= cos(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
			newPosition.y -= sin(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
		} else if (keyCode == RIGHT) {
			newPosition.x += cos(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
			newPosition.y += sin(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
		}
		
		if (newPosition.x < board_width - 1 && newPosition.y < board_height - 1 &&
				newPosition.x > 0 && newPosition.y > 0) {
			player.position = newPosition;
		}
	}
}

void keyReleased() {
	if (keyCode == ENTER || keyCode == RETURN) {
		edit_mode += 1;
		edit_mode %= 2;
	}
}

// update minimap buffer (so we don't compute the minimap rendering it at every frames)
void updateMinimap() {
	pg_minimap.beginDraw();
	pg_minimap.noStroke();
  for (int i = 0; i < board_size; i += int(board_width / minimap_width)) {
    //float w = boards[i];
		float w = brightness(pg_map.pixels[i]);
   
		int x = i % board_width;
		int y = int((float)i / board_width);

		x = int((float)x * minimap_scale_x);
		y = int((float)y * minimap_scale_y);

		pg_minimap.fill(w);
		pg_minimap.rect(x, y, 1, 1);
  }
	pg_minimap.endDraw();
}

void render_minimap() {
	int minimap_offset_x = width - minimap_width_m1;

	image(pg_minimap, minimap_offset_x, 0);
	
	// player FOV on the minimap from all the latest rays casted (fast but not pixel perfect)
	stroke(255, 0, 0);
	for (int i = 0; i < width; i += minimap_fov_step) {
		PVector ray = latest_rays[i];
		line(player.position.x * minimap_scale_x + minimap_offset_x,
				 player.position.y * minimap_scale_y,
				 ray.x * minimap_scale_x + minimap_offset_x,
				 ray.y * minimap_scale_y);
	}
	noStroke();
	
	// player position
	fill(255, 255, 0);
	ellipse(player.position.x * minimap_scale_x + minimap_offset_x,
			 player.position.y * minimap_scale_y, 6, 6);
}"
"607383","Voxel landscape","mySketch","/**
  * This is like my custom volume raycaster sketch but tuned for 'infinite' voxel landscapes.
	*
	* It is the same technically except that rays go from far to near and are not stopped once they hit something (they walk on the heightmap), all cells are also drawn
	* Another difference is that it is infinite, rays are warped when they go outside map boundary
	*
	* This sketch is much faster also because texturing is almost free; from a secondary colormap.
	*
	* Perspective is done that way for fun, it look like the inside of a sphere with mapped terrain :)
	* Heightmap and Colormap come from Comanche game
	*
	* All of these rendering tricks are specialized version of voxel rendering.
	*/

static int display_width = 640;
static int display_height = 480;

static int board_width = 512;
static int board_height = board_width; // linked
static int board_size = board_width * board_height;

// typically the diagonal of the map so we stop any rays casted outside...
// but this can also be used for performances, this is the camera z clipping so with fog and this we can speed the rendering up :)
static int max_ray_step = board_width / 2;

static int wall_height = 1;

static int player_fov = 60;

static int minimap_width = 128;
static int minimap_height = minimap_width; // linked
static int minimap_width_m1 = minimap_width - 1;
static int minimap_fov_step = 88;
static float minimap_scale_x = (float)minimap_width / board_width;
static float minimap_scale_y = (float)minimap_height / board_height;

// increase for more performances
static int stepping_x = 4;

float boards[];
// we use this actually instead of ""boards"" to store the map data
// this allow to draw our map directly with Processing shapes since we are not restricted to perpendicular walls :)
PImage pg_map;

PVector raydir[];
PVector latest_rays[];

PImage textures;

PGraphics pg_minimap;

// an entity class which hold player data and other entities
class Entity {
  PVector position;
  float rotation;
  float fov;
	float dst_proj_plane;
	float vel_multiplier = 2;
  float height = 164;
 
  Entity(PVector position, float rotation, float fov) {
    this.position = position;
    this.rotation = rotation;
    this.fov = fov;
		this.dst_proj_plane = 160 / tan(radians(fov / 2));
  }
};

Entity player = new Entity(
    new PVector(board_width / 2,
                board_height / 2), 90, player_fov);

int pred = 0;

void setup() {
  size(display_width, display_height);
  frameRate(60);
  colorMode(RGB,255,255,255,100);
 
	// initialize the map from a heightmap
	pg_map = loadImage(""heightmap.png"");
	pg_map.loadPixels();
	
	// pre-calculate all ray directions for the player FOV
	raydir = new PVector[width * 360];
	
	for (int i = 0; i < (width * 360); i += 1) {
		int rotation_degree = int((float)i / width);

		float ri = i % width;
		float norm_i = ri / width;
		
		raydir[i] = new PVector(
									cos(radians(rotation_degree) - radians(player.fov / 2) + radians(player.fov) * norm_i),
		            	sin(radians(rotation_degree) - radians(player.fov / 2) + radians(player.fov) * norm_i));
	}
	
	// latest rays are stored here (used to display the player FOV in the minimap)
	latest_rays = new PVector[width];
	for (int i = 0; i < width; i += 1) {
		latest_rays[i] = new PVector(0, 0);
	}
	
	textures = loadImage(""C2W.png"");
	textures.loadPixels();
	
	pg_minimap = createGraphics(minimap_width, minimap_height);
	
	pred = red(pg_map.pixels[0]);
}

void draw() {
  background(0);
 
  noStroke();
 
  raycast();
	
	render_minimap();
 
  player.rotation = ((float)mouseX / width * 2 * 359) % 360;
	
	// comment this and uncomment keyPressCheck for regular keyboard playable movement
	move();
	
	//keyPressCheck();
	
	// we update the minimap only once when the heightmap is loaded (need that to avoid asynchronous issues)
	if (red(pg_map.pixels[0]) != pred) {
		updateMinimap();
		
		pred = red(pg_map.pixels[0]);
	}
}

// core algorithm
void raycast() {
  int i = 0, j = 0;
	
	int rot_i = int(player.rotation) * width;
	
	// scan the screen horizontally and raycast from the defined player FOV
  for (i = 0; i < width; i += stepping_x) {
    float norm_i = (float)i / width;
		
		// we use pre-computed ray directions (see below for the raw formula)
		PVector ray_direction = raydir[i + rot_i];
   
    float dx = ray_direction.x;
		//float dx = cos(radians(player.rotation) - radians(player.fov / 2) + radians(player.fov) * norm_i);
    float dy = ray_direction.y;
		//float dy = sin(radians(player.rotation) - radians(player.fov / 2) + radians(player.fov) * norm_i);
		
    float px = player.position.x + dx * max_ray_step;
    float py = player.position.y + dy * max_ray_step;
		
		latest_rays[i].x = floor(px);
		latest_rays[i].y = floor(py);
		
		int step = 0;
		
		// traverse the map & check for collisions
    while (step < max_ray_step) {
			int ix = (int)px;
			int iy = (int)py;
			
      //float result = boards[(int)px + (int)py * board_width];
			color result = pg_map.pixels[ix + iy * board_width];
			
			float heightmap_height = red(result);
     
			float dst = (float)step / max_ray_step;

			// now determine the slice height from heightmap brightness value and fake the perspective
			int wall_start_y = (height - height * ((float)heightmap_height / 255)) * dst * 2 - (max_ray_step - player.height);

			// draw terrain slice with color from colormap (* 2 because the colormap size is 1024 and heightmap 512)
			color colormap = textures.pixels[ix * 2 + iy * 2 * textures.width];

			fill(red(colormap), green(colormap), blue(colormap));
			rect(i, wall_start_y, stepping_x, height - wall_start_y);

			// show complete raycast FOV on minimap (pixels perfect but slow and should be computed outside to fix order issues)
      //fill(0, 255, 0, 64);
      //rect(int(px * minimap_scale_x + width - minimap_width_m1), int(py * minimap_scale_y), 1, 1);
			
      px -= dx;
      py -= dy;
			
			if (px < 0) {
				px = board_width - abs(px);	
			}
			
			px = px % board_width;
			
			if (py < 0) {
				py = board_height - abs(py);	
			}
			
			py = py % board_height;
			
			step += 1;
    }
  }
}

// just move up
void move() {
	int rot_i = int(player.rotation) * width;

	PVector ray_direction = raydir[width / 2 + rot_i];

	PVector velocity = new PVector(ray_direction.x, ray_direction.y);
	velocity.mult(player.vel_multiplier);
	
	PVector newPosition = new PVector(player.position.x, player.position.y);
	newPosition.add(velocity);
	player.position = newPosition;	
	
	if (player.position.x < 0) {
		player.position.x = board_width - 1;
	}
	
	if (player.position.y < 0) {
		player.position.y = board_height - 1;
	}
	
	if (player.position.x > board_width) {
		player.position.x = 0;
	}

	if (player.position.y > board_height) {
		player.position.y = 0;
	}
}

// physics logic (unused but working!)
void keyPressCheck() {
  if (keyPressed) {
		int rot_i = int(player.rotation) * width;
		
		PVector ray_direction = raydir[width / 2 + rot_i];
		
		PVector velocity = new PVector(ray_direction.x, ray_direction.y);
		velocity.mult(player.vel_multiplier);
		
		int dir = 1;
		if (player.rotation > 90 || player.rotation < 180) {
			dir = -1;
		}
		
		PVector newPosition = new PVector(player.position.x, player.position.y);
		
    if (keyCode == UP) {
			newPosition.add(velocity);
		} else if (keyCode == DOWN) {
			newPosition.sub(velocity);
		}
		
		if (keyCode == LEFT) {
			newPosition.x -= cos(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
			newPosition.y -= sin(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
		} else if (keyCode == RIGHT) {
			newPosition.x += cos(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
			newPosition.y += sin(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
		}
		
		if (newPosition.x < board_width - 1 && newPosition.y < board_height - 1 &&
				newPosition.x > 0 && newPosition.y > 0) {
			player.position = newPosition;
		}
	}
}

void keyReleased() {
	if (keyCode == ENTER || keyCode == RETURN) {
		edit_mode += 1;
		edit_mode %= 2;
	}
}

// update minimap buffer (so we don't compute the minimap rendering it at every frames)
void updateMinimap() {
	pg_minimap.beginDraw();
	pg_minimap.noStroke();
  for (int i = 0; i < board_size; i += int(board_width / minimap_width)) {
    //float w = boards[i];
		float w = brightness(pg_map.pixels[i]);
   
		int x = i % board_width;
		int y = int((float)i / board_width);

		x = int((float)x * minimap_scale_x);
		y = int((float)y * minimap_scale_y);

		pg_minimap.fill(w);
		pg_minimap.rect(x, y, 1, 1);
  }
	pg_minimap.endDraw();
}

void render_minimap() {
	int minimap_offset_x = width - minimap_width_m1;

	image(pg_minimap, minimap_offset_x, 0);
	
	// player FOV on the minimap from all the latest rays casted (fast but not pixel perfect)
	stroke(255, 0, 0);
	for (int i = 0; i < width; i += minimap_fov_step) {
		PVector ray = latest_rays[i];
		line(player.position.x * minimap_scale_x + minimap_offset_x,
				 player.position.y * minimap_scale_y,
				 ray.x * minimap_scale_x + minimap_offset_x,
				 ray.y * minimap_scale_y);
	}
	noStroke();
	
	// player position
	fill(255, 255, 0);
	ellipse(player.position.x * minimap_scale_x + minimap_offset_x,
			 player.position.y * minimap_scale_y, 6, 6);
}"
"607383","Voxel landscape","mySketch","/**
  * This is like my custom volume raycaster sketch but tuned for 'infinite' voxel landscapes.
	*
	* It is the same technically except that rays go from far to near and are not stopped once they hit something (they walk on the heightmap), all cells are also drawn
	* Another difference is that it is infinite, rays are warped when they go outside map boundary
	*
	* This sketch is much faster also because texturing is almost free; from a secondary colormap.
	*
	* Perspective is done that way for fun, it look like the inside of a sphere with mapped terrain :)
	* Heightmap and Colormap come from Comanche game
	*
	* All of these rendering tricks are specialized version of voxel rendering.
	*/

static int display_width = 640;
static int display_height = 480;

static int board_width = 512;
static int board_height = board_width; // linked
static int board_size = board_width * board_height;

// typically the diagonal of the map so we stop any rays casted outside...
// but this can also be used for performances, this is the camera z clipping so with fog and this we can speed the rendering up :)
static int max_ray_step = board_width / 2;

static int wall_height = 1;

static int player_fov = 60;

static int minimap_width = 128;
static int minimap_height = minimap_width; // linked
static int minimap_width_m1 = minimap_width - 1;
static int minimap_fov_step = 88;
static float minimap_scale_x = (float)minimap_width / board_width;
static float minimap_scale_y = (float)minimap_height / board_height;

// increase for more performances
static int stepping_x = 4;

float boards[];
// we use this actually instead of ""boards"" to store the map data
// this allow to draw our map directly with Processing shapes since we are not restricted to perpendicular walls :)
PImage pg_map;

PVector raydir[];
PVector latest_rays[];

PImage textures;

PGraphics pg_minimap;

// an entity class which hold player data and other entities
class Entity {
  PVector position;
  float rotation;
  float fov;
	float dst_proj_plane;
	float vel_multiplier = 2;
  float height = 164;
 
  Entity(PVector position, float rotation, float fov) {
    this.position = position;
    this.rotation = rotation;
    this.fov = fov;
		this.dst_proj_plane = 160 / tan(radians(fov / 2));
  }
};

Entity player = new Entity(
    new PVector(board_width / 2,
                board_height / 2), 90, player_fov);

int pred = 0;

void setup() {
  size(display_width, display_height);
  frameRate(60);
  colorMode(RGB,255,255,255,100);
 
	// initialize the map from a heightmap
	pg_map = loadImage(""heightmap.png"");
	pg_map.loadPixels();
	
	// pre-calculate all ray directions for the player FOV
	raydir = new PVector[width * 360];
	
	for (int i = 0; i < (width * 360); i += 1) {
		int rotation_degree = int((float)i / width);

		float ri = i % width;
		float norm_i = ri / width;
		
		raydir[i] = new PVector(
									cos(radians(rotation_degree) - radians(player.fov / 2) + radians(player.fov) * norm_i),
		            	sin(radians(rotation_degree) - radians(player.fov / 2) + radians(player.fov) * norm_i));
	}
	
	// latest rays are stored here (used to display the player FOV in the minimap)
	latest_rays = new PVector[width];
	for (int i = 0; i < width; i += 1) {
		latest_rays[i] = new PVector(0, 0);
	}
	
	textures = loadImage(""C2W.png"");
	textures.loadPixels();
	
	pg_minimap = createGraphics(minimap_width, minimap_height);
	
	pred = red(pg_map.pixels[0]);
}

void draw() {
  background(0);
 
  noStroke();
 
  raycast();
	
	render_minimap();
 
  player.rotation = ((float)mouseX / width * 2 * 359) % 360;
	
	// comment this and uncomment keyPressCheck for regular keyboard playable movement
	move();
	
	//keyPressCheck();
	
	// we update the minimap only once when the heightmap is loaded (need that to avoid asynchronous issues)
	if (red(pg_map.pixels[0]) != pred) {
		updateMinimap();
		
		pred = red(pg_map.pixels[0]);
	}
}

// core algorithm
void raycast() {
  int i = 0, j = 0;
	
	int rot_i = int(player.rotation) * width;
	
	// scan the screen horizontally and raycast from the defined player FOV
  for (i = 0; i < width; i += stepping_x) {
    float norm_i = (float)i / width;
		
		// we use pre-computed ray directions (see below for the raw formula)
		PVector ray_direction = raydir[i + rot_i];
   
    float dx = ray_direction.x;
		//float dx = cos(radians(player.rotation) - radians(player.fov / 2) + radians(player.fov) * norm_i);
    float dy = ray_direction.y;
		//float dy = sin(radians(player.rotation) - radians(player.fov / 2) + radians(player.fov) * norm_i);
		
    float px = player.position.x + dx * max_ray_step;
    float py = player.position.y + dy * max_ray_step;
		
		latest_rays[i].x = floor(px);
		latest_rays[i].y = floor(py);
		
		int step = 0;
		
		// traverse the map & check for collisions
    while (step < max_ray_step) {
			int ix = (int)px;
			int iy = (int)py;
			
      //float result = boards[(int)px + (int)py * board_width];
			color result = pg_map.pixels[ix + iy * board_width];
			
			float heightmap_height = red(result);
     
			float dst = (float)step / max_ray_step * (cos(-radians(player.fov / 2) + radians(player.fov) * norm_i));

			// now determine the slice height from heightmap brightness value and fake the perspective
			int wall_start_y = (height - height * ((float)heightmap_height / 255)) * dst * 2 - (max_ray_step - player.height);

			// draw terrain slice with color from colormap (* 2 because the colormap size is 1024 and heightmap 512)
			color colormap = textures.pixels[ix * 2 + iy * 2 * textures.width];

			fill(red(colormap), green(colormap), blue(colormap));
			rect(i, wall_start_y, stepping_x, height - wall_start_y);

			// show complete raycast FOV on minimap (pixels perfect but slow and should be computed outside to fix order issues)
      //fill(0, 255, 0, 64);
      //rect(int(px * minimap_scale_x + width - minimap_width_m1), int(py * minimap_scale_y), 1, 1);
			
      px -= dx;
      py -= dy;
			
			if (px < 0) {
				px = board_width - abs(px);	
			}
			
			px = px % board_width;
			
			if (py < 0) {
				py = board_height - abs(py);	
			}
			
			py = py % board_height;
			
			step += 1;
    }
  }
}

// just move up
void move() {
	int rot_i = int(player.rotation) * width;

	PVector ray_direction = raydir[width / 2 + rot_i];

	PVector velocity = new PVector(ray_direction.x, ray_direction.y);
	velocity.mult(player.vel_multiplier);
	
	PVector newPosition = new PVector(player.position.x, player.position.y);
	newPosition.add(velocity);
	player.position = newPosition;	
	
	if (player.position.x < 0) {
		player.position.x = board_width - 1;
	}
	
	if (player.position.y < 0) {
		player.position.y = board_height - 1;
	}
	
	if (player.position.x > board_width) {
		player.position.x = 0;
	}

	if (player.position.y > board_height) {
		player.position.y = 0;
	}
}

// physics logic (unused but working!)
void keyPressCheck() {
  if (keyPressed) {
		int rot_i = int(player.rotation) * width;
		
		PVector ray_direction = raydir[width / 2 + rot_i];
		
		PVector velocity = new PVector(ray_direction.x, ray_direction.y);
		velocity.mult(player.vel_multiplier);
		
		int dir = 1;
		if (player.rotation > 90 || player.rotation < 180) {
			dir = -1;
		}
		
		PVector newPosition = new PVector(player.position.x, player.position.y);
		
    if (keyCode == UP) {
			newPosition.add(velocity);
		} else if (keyCode == DOWN) {
			newPosition.sub(velocity);
		}
		
		if (keyCode == LEFT) {
			newPosition.x -= cos(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
			newPosition.y -= sin(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
		} else if (keyCode == RIGHT) {
			newPosition.x += cos(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
			newPosition.y += sin(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
		}
		
		if (newPosition.x < board_width - 1 && newPosition.y < board_height - 1 &&
				newPosition.x > 0 && newPosition.y > 0) {
			player.position = newPosition;
		}
	}
}

void keyReleased() {
	if (keyCode == ENTER || keyCode == RETURN) {
		edit_mode += 1;
		edit_mode %= 2;
	}
}

// update minimap buffer (so we don't compute the minimap rendering it at every frames)
void updateMinimap() {
	pg_minimap.beginDraw();
	pg_minimap.noStroke();
  for (int i = 0; i < board_size; i += int(board_width / minimap_width)) {
    //float w = boards[i];
		float w = brightness(pg_map.pixels[i]);
   
		int x = i % board_width;
		int y = int((float)i / board_width);

		x = int((float)x * minimap_scale_x);
		y = int((float)y * minimap_scale_y);

		pg_minimap.fill(w);
		pg_minimap.rect(x, y, 1, 1);
  }
	pg_minimap.endDraw();
}

void render_minimap() {
	int minimap_offset_x = width - minimap_width_m1;

	image(pg_minimap, minimap_offset_x, 0);
	
	// player FOV on the minimap from all the latest rays casted (fast but not pixel perfect)
	stroke(255, 0, 0);
	for (int i = 0; i < width; i += minimap_fov_step) {
		PVector ray = latest_rays[i];
		line(player.position.x * minimap_scale_x + minimap_offset_x,
				 player.position.y * minimap_scale_y,
				 ray.x * minimap_scale_x + minimap_offset_x,
				 ray.y * minimap_scale_y);
	}
	noStroke();
	
	// player position
	fill(255, 255, 0);
	ellipse(player.position.x * minimap_scale_x + minimap_offset_x,
			 player.position.y * minimap_scale_y, 6, 6);
}"
"607383","Voxel landscape","mySketch","/**
  * This is like my custom volume raycaster sketch but tuned for 'infinite' voxel landscapes.
	*
	* It is the same technically except that rays go from far to near and are not stopped once they hit something (they walk on the heightmap), all cells are also drawn
	* Another difference is that it is infinite, rays are warped when they go outside map boundary
	*
	* This sketch is much faster also because texturing is almost free; from a secondary colormap.
	*
	* Perspective is done that way for fun, it look like the inside of a sphere with mapped terrain :)
	* Heightmap and Colormap come from Comanche game
	*
	* All of these rendering tricks are specialized version of voxel rendering.
	*/

static int display_width = 640;
static int display_height = 480;

static int board_width = 512;
static int board_height = board_width; // linked
static int board_size = board_width * board_height;

// typically the diagonal of the map so we stop any rays casted outside...
// but this can also be used for performances, this is the camera z clipping so with fog and this we can speed the rendering up :)
static int max_ray_step = board_width / 2;

static int wall_height = 1;

static int player_fov = 60;

static int minimap_width = 128;
static int minimap_height = minimap_width; // linked
static int minimap_width_m1 = minimap_width - 1;
static int minimap_fov_step = 88;
static float minimap_scale_x = (float)minimap_width / board_width;
static float minimap_scale_y = (float)minimap_height / board_height;

// increase for more performances
static int stepping_x = 4;

float boards[];
// we use this actually instead of ""boards"" to store the map data
// this allow to draw our map directly with Processing shapes since we are not restricted to perpendicular walls :)
PImage pg_map;

PVector raydir[];
PVector latest_rays[];

PImage textures;

PGraphics pg_minimap;

// an entity class which hold player data and other entities
class Entity {
  PVector position;
  float rotation;
  float fov;
	float dst_proj_plane;
	float vel_multiplier = 2;
  float height = 164;
 
  Entity(PVector position, float rotation, float fov) {
    this.position = position;
    this.rotation = rotation;
    this.fov = fov;
		this.dst_proj_plane = 160 / tan(radians(fov / 2));
  }
};

Entity player = new Entity(
    new PVector(board_width / 2,
                board_height / 2), 90, player_fov);

int pred = 0;

void setup() {
  size(display_width, display_height);
  frameRate(60);
  colorMode(RGB,255,255,255,100);
 
	// initialize the map from a heightmap
	pg_map = loadImage(""heightmap.png"");
	pg_map.loadPixels();
	
	// pre-calculate all ray directions for the player FOV
	raydir = new PVector[width * 360];
	
	for (int i = 0; i < (width * 360); i += 1) {
		int rotation_degree = int((float)i / width);

		float ri = i % width;
		float norm_i = ri / width;
		
		raydir[i] = new PVector(
									cos(radians(rotation_degree) - radians(player.fov / 2) + radians(player.fov) * norm_i),
		            	sin(radians(rotation_degree) - radians(player.fov / 2) + radians(player.fov) * norm_i));
	}
	
	// latest rays are stored here (used to display the player FOV in the minimap)
	latest_rays = new PVector[width];
	for (int i = 0; i < width; i += 1) {
		latest_rays[i] = new PVector(0, 0);
	}
	
	textures = loadImage(""C2W.png"");
	textures.loadPixels();
	
	pg_minimap = createGraphics(minimap_width, minimap_height);
	
	pred = red(pg_map.pixels[0]);
}

void draw() {
  background(0);
 
  noStroke();
 
  raycast();
	
	render_minimap();
 
  player.rotation = ((float)mouseX / width * 2 * 359) % 360;
	
	// comment this and uncomment keyPressCheck for regular keyboard playable movement
	move();
	
	//keyPressCheck();
	
	// we update the minimap only once when the heightmap is loaded (need that to avoid asynchronous issues)
	if (red(pg_map.pixels[0]) != pred) {
		updateMinimap();
		
		pred = red(pg_map.pixels[0]);
	}
}

// core algorithm
void raycast() {
  int i = 0, j = 0;
	
	int rot_i = int(player.rotation) * width;
	
	// scan the screen horizontally and raycast from the defined player FOV
  for (i = 0; i < width; i += stepping_x) {
    float norm_i = (float)i / width;
		
		// we use pre-computed ray directions (see below for the raw formula)
		PVector ray_direction = raydir[i + rot_i];
   
    float dx = ray_direction.x;
		//float dx = cos(radians(player.rotation) - radians(player.fov / 2) + radians(player.fov) * norm_i);
    float dy = ray_direction.y;
		//float dy = sin(radians(player.rotation) - radians(player.fov / 2) + radians(player.fov) * norm_i);
		
    float px = player.position.x + dx * max_ray_step;
    float py = player.position.y + dy * max_ray_step;
		
		latest_rays[i].x = floor(px);
		latest_rays[i].y = floor(py);
		
		int step = 0;
		
		// traverse the map & check for collisions
    while (step < max_ray_step) {
			int ix = (int)px;
			int iy = (int)py;
			
      //float result = boards[(int)px + (int)py * board_width];
			color result = pg_map.pixels[ix + iy * board_width];
			
			float heightmap_height = red(result);
     
			float dst_to_plane = (float)step / max_ray_step;
			
			float dst = dst_to_plane * (cos(-radians(player.fov / 2) + radians(player.fov) * norm_i));

			// now determine the slice height from heightmap brightness value and fake the perspective
			int wall_start_y = (height - height * ((float)heightmap_height / 255)) * dst - (player.height - height) * dst_to_plane;

			// draw terrain slice with color from colormap (* 2 because the colormap size is 1024 and heightmap 512)
			color colormap = textures.pixels[ix * 2 + iy * 2 * textures.width];

			fill(red(colormap), green(colormap), blue(colormap));
			rect(i, wall_start_y, stepping_x, height - wall_start_y);

			// show complete raycast FOV on minimap (pixels perfect but slow and should be computed outside to fix order issues)
      //fill(0, 255, 0, 64);
      //rect(int(px * minimap_scale_x + width - minimap_width_m1), int(py * minimap_scale_y), 1, 1);
			
      px -= dx;
      py -= dy;
			
			if (px < 0) {
				px = board_width - abs(px);	
			}
			
			px = px % board_width;
			
			if (py < 0) {
				py = board_height - abs(py);	
			}
			
			py = py % board_height;
			
			step += 1;
    }
  }
}

// just move up
void move() {
	int rot_i = int(player.rotation) * width;

	PVector ray_direction = raydir[width / 2 + rot_i];

	PVector velocity = new PVector(ray_direction.x, ray_direction.y);
	velocity.mult(player.vel_multiplier);
	
	PVector newPosition = new PVector(player.position.x, player.position.y);
	newPosition.add(velocity);
	player.position = newPosition;	
	
	if (player.position.x < 0) {
		player.position.x = board_width - 1;
	}
	
	if (player.position.y < 0) {
		player.position.y = board_height - 1;
	}
	
	if (player.position.x > board_width) {
		player.position.x = 0;
	}

	if (player.position.y > board_height) {
		player.position.y = 0;
	}
}

// physics logic (unused but working!)
void keyPressCheck() {
  if (keyPressed) {
		int rot_i = int(player.rotation) * width;
		
		PVector ray_direction = raydir[width / 2 + rot_i];
		
		PVector velocity = new PVector(ray_direction.x, ray_direction.y);
		velocity.mult(player.vel_multiplier);
		
		int dir = 1;
		if (player.rotation > 90 || player.rotation < 180) {
			dir = -1;
		}
		
		PVector newPosition = new PVector(player.position.x, player.position.y);
		
    if (keyCode == UP) {
			newPosition.add(velocity);
		} else if (keyCode == DOWN) {
			newPosition.sub(velocity);
		}
		
		if (keyCode == LEFT) {
			newPosition.x -= cos(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
			newPosition.y -= sin(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
		} else if (keyCode == RIGHT) {
			newPosition.x += cos(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
			newPosition.y += sin(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
		}
		
		if (newPosition.x < board_width - 1 && newPosition.y < board_height - 1 &&
				newPosition.x > 0 && newPosition.y > 0) {
			player.position = newPosition;
		}
	}
}

void keyReleased() {
	if (keyCode == ENTER || keyCode == RETURN) {
		edit_mode += 1;
		edit_mode %= 2;
	}
}

// update minimap buffer (so we don't compute the minimap rendering it at every frames)
void updateMinimap() {
	pg_minimap.beginDraw();
	pg_minimap.noStroke();
  for (int i = 0; i < board_size; i += int(board_width / minimap_width)) {
    //float w = boards[i];
		float w = brightness(pg_map.pixels[i]);
   
		int x = i % board_width;
		int y = int((float)i / board_width);

		x = int((float)x * minimap_scale_x);
		y = int((float)y * minimap_scale_y);

		pg_minimap.fill(w);
		pg_minimap.rect(x, y, 1, 1);
  }
	pg_minimap.endDraw();
}

void render_minimap() {
	int minimap_offset_x = width - minimap_width_m1;

	image(pg_minimap, minimap_offset_x, 0);
	
	// player FOV on the minimap from all the latest rays casted (fast but not pixel perfect)
	stroke(255, 0, 0);
	for (int i = 0; i < width; i += minimap_fov_step) {
		PVector ray = latest_rays[i];
		line(player.position.x * minimap_scale_x + minimap_offset_x,
				 player.position.y * minimap_scale_y,
				 ray.x * minimap_scale_x + minimap_offset_x,
				 ray.y * minimap_scale_y);
	}
	noStroke();
	
	// player position
	fill(255, 255, 0);
	ellipse(player.position.x * minimap_scale_x + minimap_offset_x,
			 player.position.y * minimap_scale_y, 6, 6);
}"
"607383","Voxel landscape","mySketch","/**
  * This is like my custom volume raycaster sketch but tuned for 'infinite' voxel landscapes.
	*
	* It is the same technically except that rays go from far to near and are not stopped once they hit something (they walk on the heightmap), all cells are also drawn
	* Another difference is that it is infinite, rays are warped when they go outside map boundary
	*
	* This sketch is much faster also because texturing is almost free; from a secondary colormap.
	*
	* Perspective is done that way for fun, it look like the inside of a sphere with mapped terrain :)
	* Heightmap and Colormap come from Comanche game
	*
	* All of these rendering tricks are specialized version of voxel rendering.
	*/

static int display_width = 640;
static int display_height = 480;

static int board_width = 512;
static int board_height = board_width; // linked
static int board_size = board_width * board_height;

// typically the diagonal of the map so we stop any rays casted outside...
// but this can also be used for performances, this is the camera z clipping so with fog and this we can speed the rendering up :)
static int max_ray_step = board_width / 2;

static int wall_height = 1;

static int player_fov = 60;

static int minimap_width = 128;
static int minimap_height = minimap_width; // linked
static int minimap_width_m1 = minimap_width - 1;
static int minimap_fov_step = 88;
static float minimap_scale_x = (float)minimap_width / board_width;
static float minimap_scale_y = (float)minimap_height / board_height;

// increase for more performances
static int stepping_x = 4;

float boards[];
// we use this actually instead of ""boards"" to store the map data
// this allow to draw our map directly with Processing shapes since we are not restricted to perpendicular walls :)
PImage pg_map;

PVector raydir[];
PVector latest_rays[];

PImage textures;

PGraphics pg_minimap;

// an entity class which hold player data and other entities
class Entity {
  PVector position;
  float rotation;
  float fov;
	float dst_proj_plane;
	float vel_multiplier = 2;
  float height = 100;
 
  Entity(PVector position, float rotation, float fov) {
    this.position = position;
    this.rotation = rotation;
    this.fov = fov;
		this.dst_proj_plane = 160 / tan(radians(fov / 2));
  }
};

Entity player = new Entity(
    new PVector(board_width / 2,
                board_height / 2), 90, player_fov);

int pred = 0;

void setup() {
  size(display_width, display_height);
  frameRate(60);
  colorMode(RGB,255,255,255,100);
 
	// initialize the map from a heightmap
	pg_map = loadImage(""heightmap.png"");
	pg_map.loadPixels();
	
	// pre-calculate all ray directions for the player FOV
	raydir = new PVector[width * 360];
	
	for (int i = 0; i < (width * 360); i += 1) {
		int rotation_degree = int((float)i / width);

		float ri = i % width;
		float norm_i = ri / width;
		
		raydir[i] = new PVector(
									cos(radians(rotation_degree) - radians(player.fov / 2) + radians(player.fov) * norm_i),
		            	sin(radians(rotation_degree) - radians(player.fov / 2) + radians(player.fov) * norm_i));
	}
	
	// latest rays are stored here (used to display the player FOV in the minimap)
	latest_rays = new PVector[width];
	for (int i = 0; i < width; i += 1) {
		latest_rays[i] = new PVector(0, 0);
	}
	
	textures = loadImage(""C2W.png"");
	textures.loadPixels();
	
	pg_minimap = createGraphics(minimap_width, minimap_height);
	
	pred = red(pg_map.pixels[0]);
}

void draw() {
  background(0);
 
  noStroke();
 
  raycast();
	
	render_minimap();
 
  player.rotation = ((float)mouseX / width * 2 * 359) % 360;
	
	// comment this and uncomment keyPressCheck for regular keyboard playable movement
	move();
	
	//keyPressCheck();
	
	// we update the minimap only once when the heightmap is loaded (need that to avoid asynchronous issues)
	if (red(pg_map.pixels[0]) != pred) {
		updateMinimap();
		
		pred = red(pg_map.pixels[0]);
	}
}

// core algorithm
void raycast() {
  int i = 0, j = 0;
	
	int rot_i = int(player.rotation) * width;
	
	// scan the screen horizontally and raycast from the defined player FOV
  for (i = 0; i < width; i += stepping_x) {
    float norm_i = (float)i / width;
		
		// we use pre-computed ray directions (see below for the raw formula)
		PVector ray_direction = raydir[i + rot_i];
   
    float dx = ray_direction.x;
		//float dx = cos(radians(player.rotation) - radians(player.fov / 2) + radians(player.fov) * norm_i);
    float dy = ray_direction.y;
		//float dy = sin(radians(player.rotation) - radians(player.fov / 2) + radians(player.fov) * norm_i);
		
    float px = player.position.x + dx * max_ray_step;
    float py = player.position.y + dy * max_ray_step;
		
		latest_rays[i].x = floor(px);
		latest_rays[i].y = floor(py);
		
		int step = 0;
		
		// traverse the map & check for collisions
    while (step < max_ray_step) {
			int ix = (int)px;
			int iy = (int)py;
			
      //float result = boards[(int)px + (int)py * board_width];
			color result = pg_map.pixels[ix + iy * board_width];
			
			float heightmap_height = red(result);
     
			float dst_to_plane = (float)step / max_ray_step;
			
			float dst = dst_to_plane * (cos(-radians(player.fov / 2) + radians(player.fov) * norm_i));

			// now determine the slice height from heightmap brightness value and fake the perspective
			int wall_start_y = (height - height * ((float)heightmap_height / 255) * 2) * dst - (player.height - height) * dst_to_plane;

			// draw terrain slice with color from colormap (* 2 because the colormap size is 1024 and heightmap 512)
			color colormap = textures.pixels[ix * 2 + iy * 2 * textures.width];

			fill(red(colormap), green(colormap), blue(colormap));
			rect(i, wall_start_y, stepping_x, height - wall_start_y);

			// show complete raycast FOV on minimap (pixels perfect but slow and should be computed outside to fix order issues)
      //fill(0, 255, 0, 64);
      //rect(int(px * minimap_scale_x + width - minimap_width_m1), int(py * minimap_scale_y), 1, 1);
			
      px -= dx;
      py -= dy;
			
			if (px < 0) {
				px = board_width - abs(px);	
			}
			
			px = px % board_width;
			
			if (py < 0) {
				py = board_height - abs(py);	
			}
			
			py = py % board_height;
			
			step += 1;
    }
  }
}

// just move up
void move() {
	int rot_i = int(player.rotation) * width;

	PVector ray_direction = raydir[width / 2 + rot_i];

	PVector velocity = new PVector(ray_direction.x, ray_direction.y);
	velocity.mult(player.vel_multiplier);
	
	PVector newPosition = new PVector(player.position.x, player.position.y);
	newPosition.add(velocity);
	player.position = newPosition;	
	
	if (player.position.x < 0) {
		player.position.x = board_width - 1;
	}
	
	if (player.position.y < 0) {
		player.position.y = board_height - 1;
	}
	
	if (player.position.x > board_width) {
		player.position.x = 0;
	}

	if (player.position.y > board_height) {
		player.position.y = 0;
	}
}

// physics logic (unused but working!)
void keyPressCheck() {
  if (keyPressed) {
		int rot_i = int(player.rotation) * width;
		
		PVector ray_direction = raydir[width / 2 + rot_i];
		
		PVector velocity = new PVector(ray_direction.x, ray_direction.y);
		velocity.mult(player.vel_multiplier);
		
		int dir = 1;
		if (player.rotation > 90 || player.rotation < 180) {
			dir = -1;
		}
		
		PVector newPosition = new PVector(player.position.x, player.position.y);
		
    if (keyCode == UP) {
			newPosition.add(velocity);
		} else if (keyCode == DOWN) {
			newPosition.sub(velocity);
		}
		
		if (keyCode == LEFT) {
			newPosition.x -= cos(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
			newPosition.y -= sin(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
		} else if (keyCode == RIGHT) {
			newPosition.x += cos(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
			newPosition.y += sin(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
		}
		
		if (newPosition.x < board_width - 1 && newPosition.y < board_height - 1 &&
				newPosition.x > 0 && newPosition.y > 0) {
			player.position = newPosition;
		}
	}
}

void keyReleased() {
	if (keyCode == ENTER || keyCode == RETURN) {
		edit_mode += 1;
		edit_mode %= 2;
	}
}

// update minimap buffer (so we don't compute the minimap rendering it at every frames)
void updateMinimap() {
	pg_minimap.beginDraw();
	pg_minimap.noStroke();
  for (int i = 0; i < board_size; i += int(board_width / minimap_width)) {
    //float w = boards[i];
		float w = brightness(pg_map.pixels[i]);
   
		int x = i % board_width;
		int y = int((float)i / board_width);

		x = int((float)x * minimap_scale_x);
		y = int((float)y * minimap_scale_y);

		pg_minimap.fill(w);
		pg_minimap.rect(x, y, 1, 1);
  }
	pg_minimap.endDraw();
}

void render_minimap() {
	int minimap_offset_x = width - minimap_width_m1;

	image(pg_minimap, minimap_offset_x, 0);
	
	// player FOV on the minimap from all the latest rays casted (fast but not pixel perfect)
	stroke(255, 0, 0);
	for (int i = 0; i < width; i += minimap_fov_step) {
		PVector ray = latest_rays[i];
		line(player.position.x * minimap_scale_x + minimap_offset_x,
				 player.position.y * minimap_scale_y,
				 ray.x * minimap_scale_x + minimap_offset_x,
				 ray.y * minimap_scale_y);
	}
	noStroke();
	
	// player position
	fill(255, 255, 0);
	ellipse(player.position.x * minimap_scale_x + minimap_offset_x,
			 player.position.y * minimap_scale_y, 6, 6);
}"
"606206","2D volume raycasting","mySketch","/**
  * Custom raytracer done for fun on a phone (APDE Android app.) while commuting.
	* Improved afterward on desktop because APDE is buggy and crashed as the sketch complexity increased ! :)
	* This use Wolfenstein 3D textures.
	*/

static int display_width = 800;
static int display_height = 600;

static int board_width = 128;
static int board_height = board_width; // linked
static int board_size = board_width * board_height;

static int wall_height = 64;

static int player_fov = 60;

static int minimap_width = 128;
static int minimap_height = minimap_width; // linked
static int minimap_width_m1 = minimap_width - 1;
static int minimap_fov_step = 48;
static float minimap_scale_x = (float)minimap_width / board_width;
static float minimap_scale_y = (float)minimap_height / board_height;

// increase for more performances
static int stepping_x = 24;
static int floor_ceil_stepping = 24;

int edit_mode = 0;

float boards[];
PVector raydir[];
PVector latest_rays[];

PImage textures; 

// an entity class which hold player data and other entities
class Entity {
  PVector position;
  float rotation;
  float fov;
	float dst_proj_plane;
	float vel_multiplier = 8;
 
  Entity(PVector position, float rotation, float fov) {
    this.position = position;
    this.rotation = rotation;
    this.fov = fov;
		this.dst_proj_plane = 160 / tan(radians(fov / 2));
  }
};

Entity player = new Entity(
    new PVector(board_width / 2,
                board_height / 2), 90, player_fov);

void setup() {
  size(display_width, display_height);
  frameRate(60);
  colorMode(RGB,255,255,255,100);
 
	// initialize the map, enclose it with walls
  boards = new float[board_size];
	
  for (int i = 0; i < board_width; i += 1) {
    boards[i] = 1;
    boards[i + board_width * (board_height - 1)] = 1;
  }
 
  for (int i = 0; i < board_height; i += 1) {
    boards[i * board_width] = 1;
    boards[(board_width - 1) + i * board_width] = 1;
  }
	
	// pre-calculate all ray directions for the player FOV
	raydir = new PVector[width * 360];
	
	for (int i = 0; i < (width * 360); i += 1) {
		int rotation_degree = int((float)i / width);

		float ri = i % width;
		float norm_i = ri / width;
		
		raydir[i] = new PVector(
									cos(radians(rotation_degree) - radians(player.fov / 2) + radians(player.fov) * norm_i),
		            	sin(radians(rotation_degree) - radians(player.fov / 2) + radians(player.fov) * norm_i));
	}
	
	// latest rays are stored here
	latest_rays = new PVector[width];
	for (int i = 0; i < width; i += 1) {
		latest_rays[i] = new PVector(0, 0);
	}
	
	textures = loadImage(""wolftextures.png"");
	textures.loadPixels();
}

void draw() {
  background(0);
 
  noStroke();
 
  raycast();
	
	if (edit_mode) {
		
	} else {
  	minimap();
	}
 
  player.rotation = ((float)mouseX / width * 2 * 359) % 360;
	
	keyPressCheck();
}

// core algorithm
void raycast() {
  int i = 0, j = 0;
	
	int rot_i = int(player.rotation) * width;
	
	//loadPixels();
	
	// scan the screen horizontally and raycast from the defined player FOV
  for (i = 0; i < width; i += stepping_x) {
    float norm_i = (float)i / width;
		
		// we use pre-computed ray directions (see below for the raw formula)
		PVector ray_direction = raydir[i + rot_i];
   
    float dx = ray_direction.x;
		//float dx = cos(radians(player.rotation) - radians(player.fov / 2) + radians(player.fov) * norm_i);
    float dy = ray_direction.y;
		//float dy = sin(radians(player.rotation) - radians(player.fov / 2) + radians(player.fov) * norm_i);
   
    float px = player.position.x;
    float py = player.position.y;
		
		// traverse the map & check for collisions
    while (px >= 0 && px < board_width && 
					 py >= 0 && py < board_height) {
      float result = boards[(int)px + (int)py * board_width];
     
      if (result > 0) {
				// manhattan distance (faster to compute but may need further investigation to use it properly)
				// (abs(player.getX() - px) + abs(player.getY() - py))
				
				// compute distance with corrected perspective
				// if the perspective is not corrected this will produce fish-eye / distorded walls effect because rays on the edge of the screen need to travel 'further' than the middle rays one 
				float ddx = abs(player.position.x - px);
				float ddy = abs(player.position.y - py);
				
        float dist = sqrt(ddx * ddx + ddy * ddy) * (cos(-radians(player.fov / 2) + radians(player.fov) * norm_i));
        float norm_dist = dist / max(board_width, board_height) / 1.25;
				float inorm_dist = max(1 - norm_dist, 0.1);
				
				// determine wall height from the computed distance
				// dst_proj_plane is just a value related to the FOV, it relate to the player / projection plane distance
        float wh = wall_height / dist * player.dst_proj_plane;
				// now determine the vertical wall start position
        float wall_start_y = height / 2 - wh / 2;
       
				// draw floor and ceiling
        for (j = 0; j < wall_start_y; j += floor_ceil_stepping) {
          float norm_j = j / wall_start_y;
          float inorm_j = 1. - norm_j;
					float ceil_brightness = 255 * (norm_j * inorm_dist * 2);
					float floor_brightness = 255 * (inorm_j * inorm_dist * 2);
					
          fill(0, 0, ceil_brightness, 32);
          rect(i, j, stepping_x, floor_ceil_stepping);
          fill(floor_brightness, 0, 0, 32);
          rect(i, j + wh + wall_start_y, stepping_x, floor_ceil_stepping);
        }
				
				// draw wall (untextured)
				/*
				fill(inorm_dist * 255, 0, 0, 255);
        rect(i, wall_start_y, stepping_x, wh);
				*/
				
	      // draw wall (textured)
				for (j = wall_start_y; j < wall_start_y + wh; j += 2) {
					color c = textures.pixels[(i % textures.width) + (j % textures.height) * textures.width];
					fill(red(c), green(c), blue(c));
        	rect(i, j, 4, 4);
					//pixels[i + j * width] = c;
				}
				
				// store ray for later use (minimap FOV)
				latest_rays[i].x = round(px);
				latest_rays[i].y = round(py);

        break;
      }
     
			// show complete raycast FOV on minimap (pixels perfect but slow and should be computed outside to fix order issues)
      //fill(0, 255, 0, 64);
      //rect(int(px * minimap_scale_x + width - minimap_width_m1), int(py * minimap_scale_y), 1, 1);
			
      px += dx;
      py += dy;
    }
  }
	
	//updatePixels();
}

// physics logic
void keyPressCheck() {
  if (keyPressed) {
		int rot_i = int(player.rotation) * width;
		
		PVector ray_direction = raydir[width / 2 + rot_i];
		
		PVector velocity = new PVector(ray_direction.x, ray_direction.y);
		velocity.mult(player.vel_multiplier);
		
		int dir = 1;
		if (player.rotation > 90 || player.rotation < 180) {
			dir = -1;
		}
		
		PVector newPosition = new PVector(player.position.x, player.position.y);
		
    if (keyCode == UP) {
			newPosition.add(velocity);
		} else if (keyCode == DOWN) {
			newPosition.sub(velocity);
		} else if (keyCode == LEFT) {
			newPosition.x -= cos(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
			newPosition.y -= sin(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
		} else if (keyCode == RIGHT) {
			newPosition.x += cos(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
			newPosition.y += sin(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
		}
		
		if (newPosition.x < board_width - 1 && newPosition.y < board_height - 1 &&
				newPosition.x > 0 && newPosition.y > 0) {
			player.position = newPosition;
		}
	}
}

void keyReleased() {
	if (keyCode == ENTER || keyCode == RETURN) {
		edit_mode += 1;
		edit_mode %= 2;
	}
}

void minimap() {
	int minimap_offset_x = width - minimap_width_m1;
	/*
	// minimap for a typical raycaster
  for (int i = 0; i < board_size; i += int(board_width / minimap_width)) {
    float w = boards[i];
   
    if (w > 0.5) {
      fill(255, 255, 255, 192);
			
			int x = i % board_width;
			int y = int((float)i / board_width);

			x = int((float)x * minimap_scale_x);
			y = int((float)y * minimap_scale_y);
     
      rect(x + minimap_offset_x, y, 1, 1);
    }
  }
  */
	// player FOV on the minimap from all the latest rays casted (fast but not pixel perfect)
	stroke(0, 255, 0, 255);
	for (int i = 0; i < width; i += minimap_fov_step) {
		PVector ray = latest_rays[i];
		line(player.position.x * minimap_scale_x + minimap_offset_x,
				 player.position.y * minimap_scale_y,
				 ray.x * minimap_scale_x + minimap_offset_x,
				 ray.y * minimap_scale_y);
	}
	noStroke();
	
	// player position
	fill(0, 128, 0);
	rect(player.position.x * minimap_scale_x + minimap_offset_x - 2,
			 player.position.y * minimap_scale_y - 2, 4, 4);
}"
"606206","2D volume raycasting","mySketch","/**
  * Custom raytracer done for fun on a phone (APDE Android app.) while commuting.
	* Improved afterward on desktop because APDE is buggy and crashed as the sketch complexity increased ! :)
	* This use Wolfenstein 3D textures.
	*/

static int display_width = 800;
static int display_height = 600;

static int board_width = 128;
static int board_height = board_width; // linked
static int board_size = board_width * board_height;

static int wall_height = 64;

static int player_fov = 60;

static int minimap_width = 128;
static int minimap_height = minimap_width; // linked
static int minimap_width_m1 = minimap_width - 1;
static int minimap_fov_step = 48;
static float minimap_scale_x = (float)minimap_width / board_width;
static float minimap_scale_y = (float)minimap_height / board_height;

// increase for more performances
static int stepping_x = 8;
static int floor_ceil_stepping = 24;

int edit_mode = 0;

float boards[];
PVector raydir[];
PVector latest_rays[];

PImage textures; 

// an entity class which hold player data and other entities
class Entity {
  PVector position;
  float rotation;
  float fov;
	float dst_proj_plane;
	float vel_multiplier = 8;
 
  Entity(PVector position, float rotation, float fov) {
    this.position = position;
    this.rotation = rotation;
    this.fov = fov;
		this.dst_proj_plane = 160 / tan(radians(fov / 2));
  }
};

Entity player = new Entity(
    new PVector(board_width / 2,
                board_height / 2), 90, player_fov);

void setup() {
  size(display_width, display_height);
  frameRate(60);
  colorMode(RGB,255,255,255,100);
 
	// initialize the map, enclose it with walls
  boards = new float[board_size];
	
  for (int i = 0; i < board_width; i += 1) {
    boards[i] = 1;
    boards[i + board_width * (board_height - 1)] = 1;
  }
 
  for (int i = 0; i < board_height; i += 1) {
    boards[i * board_width] = 1;
    boards[(board_width - 1) + i * board_width] = 1;
  }
	
	// pre-calculate all ray directions for the player FOV
	raydir = new PVector[width * 360];
	
	for (int i = 0; i < (width * 360); i += 1) {
		int rotation_degree = int((float)i / width);

		float ri = i % width;
		float norm_i = ri / width;
		
		raydir[i] = new PVector(
									cos(radians(rotation_degree) - radians(player.fov / 2) + radians(player.fov) * norm_i),
		            	sin(radians(rotation_degree) - radians(player.fov / 2) + radians(player.fov) * norm_i));
	}
	
	// latest rays are stored here
	latest_rays = new PVector[width];
	for (int i = 0; i < width; i += 1) {
		latest_rays[i] = new PVector(0, 0);
	}
	
	textures = loadImage(""wolftextures.png"");
	textures.loadPixels();
}

void draw() {
  background(0);
 
  noStroke();
 
  raycast();
	
	if (edit_mode) {
		
	} else {
  	minimap();
	}
 
  player.rotation = ((float)mouseX / width * 2 * 359) % 360;
	
	keyPressCheck();
}

// core algorithm
void raycast() {
  int i = 0, j = 0;
	
	int rot_i = int(player.rotation) * width;
	
	// scan the screen horizontally and raycast from the defined player FOV
  for (i = 0; i < width; i += stepping_x) {
    float norm_i = (float)i / width;
		
		// we use pre-computed ray directions (see below for the raw formula)
		PVector ray_direction = raydir[i + rot_i];
   
    float dx = ray_direction.x;
		//float dx = cos(radians(player.rotation) - radians(player.fov / 2) + radians(player.fov) * norm_i);
    float dy = ray_direction.y;
		//float dy = sin(radians(player.rotation) - radians(player.fov / 2) + radians(player.fov) * norm_i);
   
    float px = player.position.x;
    float py = player.position.y;
		
		// traverse the map & check for collisions
    while (px >= 0 && px < board_width && 
					 py >= 0 && py < board_height) {
      float result = boards[(int)px + (int)py * board_width];
     
      if (result > 0) {	
				// determine the wall side touched by the ray, this is important for texture mapping
				int tu = (int)px; // horizontal texture coord
				float tx = px - floor(px);
				
				int side = 0;
				if (tx > 0) {
					side = 1; // cell was hit at the bottom
					tu = (int)py;
				}
				
				// compute distance with corrected perspective
				// if the perspective is not corrected this will produce fish-eye / distorded walls effect because rays on the edge of the screen need to travel 'further' than the middle rays one 
				float ddx = abs(player.position.x - px);
				float ddy = abs(player.position.y - py);
				
        float dist = sqrt(ddx * ddx + ddy * ddy) * (cos(-radians(player.fov / 2) + radians(player.fov) * norm_i));
        float norm_dist = dist / max(board_width, board_height) / 1.25;
				float inorm_dist = max(1 - norm_dist, 0.1);
				
				// determine wall height from the computed distance
				// dst_proj_plane is just a value related to the FOV, it relate to the player / projection plane distance
        float wh = wall_height / dist * player.dst_proj_plane;
				// now determine the vertical wall start position
        float wall_start_y = height / 2 - wh / 2;
       
				// draw floor and ceiling
        for (j = 0; j < wall_start_y; j += floor_ceil_stepping) {
          float norm_j = j / wall_start_y;
          float inorm_j = 1. - norm_j;
					float ceil_brightness = 255 * (norm_j * inorm_dist * 2);
					float floor_brightness = 255 * (inorm_j * inorm_dist * 2);
					
          fill(0, 0, ceil_brightness, 32);
          rect(i, j, stepping_x, floor_ceil_stepping);
          fill(floor_brightness, 0, 0, 32);
          rect(i, j + wh + wall_start_y, stepping_x, floor_ceil_stepping);
        }
				
				// draw wall (untextured)
				/*
				fill(inorm_dist * 255, 0, 0, 255);
        rect(i, wall_start_y, stepping_x, wh);
				*/
				
	      // draw wall (textured)
				for (j = wall_start_y; j < wall_start_y + wh; j += 4) {
					float norm_j = (float)(j - wall_start_y) / wh;
					color c = textures.pixels[((tu * 2) % (textures.width / 8) + 64) + 
																				(int(norm_j * textures.height) % textures.height) * textures.width];
					fill(c);
        	rect(i, j, stepping_x, 4);
				}
				
				// store ray for later use (minimap FOV)
				latest_rays[i].x = floor(px);
				latest_rays[i].y = floor(py);

        break;
      }
     
			// show complete raycast FOV on minimap (pixels perfect but slow and should be computed outside to fix order issues)
      //fill(0, 255, 0, 64);
      //rect(int(px * minimap_scale_x + width - minimap_width_m1), int(py * minimap_scale_y), 1, 1);
			
      px += dx;
      py += dy;
    }
  }
}

// physics logic
void keyPressCheck() {
  if (keyPressed) {
		int rot_i = int(player.rotation) * width;
		
		PVector ray_direction = raydir[width / 2 + rot_i];
		
		PVector velocity = new PVector(ray_direction.x, ray_direction.y);
		velocity.mult(player.vel_multiplier);
		
		int dir = 1;
		if (player.rotation > 90 || player.rotation < 180) {
			dir = -1;
		}
		
		PVector newPosition = new PVector(player.position.x, player.position.y);
		
    if (keyCode == UP) {
			newPosition.add(velocity);
		} else if (keyCode == DOWN) {
			newPosition.sub(velocity);
		} else if (keyCode == LEFT) {
			newPosition.x -= cos(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
			newPosition.y -= sin(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
		} else if (keyCode == RIGHT) {
			newPosition.x += cos(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
			newPosition.y += sin(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
		}
		
		if (newPosition.x < board_width - 1 && newPosition.y < board_height - 1 &&
				newPosition.x > 0 && newPosition.y > 0) {
			player.position = newPosition;
		}
	}
}

void keyReleased() {
	if (keyCode == ENTER || keyCode == RETURN) {
		edit_mode += 1;
		edit_mode %= 2;
	}
}

void minimap() {
	int minimap_offset_x = width - minimap_width_m1;
	
	// minimap
	fill(255);
  for (int i = 1; i < board_size - 1; i += int(board_width / minimap_width)) {
    float w = boards[i];
   
    if (w > 0.5) {
			int x = i % board_width;
			int y = int((float)i / board_width);

			x = int((float)x * minimap_scale_x);
			y = int((float)y * minimap_scale_y);
     
      rect(x + minimap_offset_x, y, 1, 1);
    }
  }
  
	fill(8);
	stroke(255);
	rect(minimap_offset_x - 1, 0, minimap_width - 1, minimap_height);
	
	// player FOV on the minimap from all the latest rays casted (fast but not pixel perfect)
	stroke(255, 0, 0);
	for (int i = 0; i < width; i += minimap_fov_step) {
		PVector ray = latest_rays[i];
		line(player.position.x * minimap_scale_x + minimap_offset_x,
				 player.position.y * minimap_scale_y,
				 ray.x * minimap_scale_x + minimap_offset_x,
				 ray.y * minimap_scale_y);
	}
	noStroke();
	
	// player position
	fill(255, 255, 0);
	ellipse(player.position.x * minimap_scale_x + minimap_offset_x,
			 player.position.y * minimap_scale_y, 6, 6);
}"
"606206","2D volume raycasting","mySketch","/**
  * Custom raytracer done for fun on a phone (APDE Android app.) while commuting.
	* Improved afterward on desktop because APDE is buggy and crashed as the sketch complexity increased ! :)
	* This use Wolfenstein 3D textures.
	*/

static int display_width = 800;
static int display_height = 600;

static int board_width = 256;
static int board_height = board_width; // linked
static int board_size = board_width * board_height;

static int wall_height = 64;

static int player_fov = 60;

static int minimap_width = 128;
static int minimap_height = minimap_width; // linked
static int minimap_width_m1 = minimap_width - 1;
static int minimap_fov_step = 88;
static float minimap_scale_x = (float)minimap_width / board_width;
static float minimap_scale_y = (float)minimap_height / board_height;

// increase for more performances
static int stepping_x = 4;
static int floor_ceil_stepping = 24;

int edit_mode = 0;

float boards[];
PVector raydir[];
PVector latest_rays[];

PImage textures;

PGraphics pg_minimap;

// an entity class which hold player data and other entities
class Entity {
  PVector position;
  float rotation;
  float fov;
	float dst_proj_plane;
	float vel_multiplier = 2;
  float height = 50;
 
  Entity(PVector position, float rotation, float fov) {
    this.position = position;
    this.rotation = rotation;
    this.fov = fov;
		this.dst_proj_plane = 160 / tan(radians(fov / 2));
  }
};

Entity player = new Entity(
    new PVector(board_width / 2,
                board_height / 2), 90, player_fov);

void setup() {
  size(display_width, display_height);
  frameRate(60);
  colorMode(RGB,255,255,255,100);
 
	// initialize the map, enclose it with walls
  boards = new float[board_size];
	
  for (int i = 0; i < board_width; i += 1) {
    boards[i] = 1;
    boards[i + board_width * (board_height - 1)] = 1;
  }
 
  for (int i = 0; i < board_height; i += 1) {
    boards[i * board_width] = 1;
    boards[(board_width - 1) + i * board_width] = 1;
  }
	
	for (int i = 0; i < 360; i += 1) {
		boards[(int)(board_width / 4 + 4 * cos(radians(i))) + (int)(board_height / 4 + 4 * sin(radians(i))) * board_width] = 1;
		boards[(int)(board_width / 4 + 4 * cos(radians(i))) + (int)(board_height - board_height / 4 + 4 * sin(radians(i))) * board_width] = 1;
		boards[(int)(board_width - board_width / 4 + 4 * cos(radians(i))) + (int)(board_height / 4 + 4 * sin(radians(i))) * board_width] = 1;
		boards[(int)(board_width - board_width / 4 + 4 * cos(radians(i))) + (int)(board_height - board_height / 4 + 4 * sin(radians(i))) * board_width] = 1;
	}
	
	// pre-calculate all ray directions for the player FOV
	raydir = new PVector[width * 360];
	
	for (int i = 0; i < (width * 360); i += 1) {
		int rotation_degree = int((float)i / width);

		float ri = i % width;
		float norm_i = ri / width;
		
		raydir[i] = new PVector(
									cos(radians(rotation_degree) - radians(player.fov / 2) + radians(player.fov) * norm_i),
		            	sin(radians(rotation_degree) - radians(player.fov / 2) + radians(player.fov) * norm_i));
	}
	
	// latest rays are stored here
	latest_rays = new PVector[width];
	for (int i = 0; i < width; i += 1) {
		latest_rays[i] = new PVector(0, 0);
	}
	
	textures = loadImage(""wolftextures.png"");
	textures.loadPixels();
	
	pg_minimap = createGraphics(minimap_width, minimap_height);
	
	updateMinimap();
}

void draw() {
  background(0);
 
  noStroke();
 
  raycast();
	
	if (edit_mode) {
		
	} else {
  	render_minimap();
	}
 
  player.rotation = ((float)mouseX / width * 2 * 359) % 360;
	
	keyPressCheck();
}

// core algorithm
void raycast() {
  int i = 0, j = 0;
	
	int rot_i = int(player.rotation) * width;
	
	// scan the screen horizontally and raycast from the defined player FOV
  for (i = 0; i < width; i += stepping_x) {
    float norm_i = (float)i / width;
		
		// we use pre-computed ray directions (see below for the raw formula)
		PVector ray_direction = raydir[i + rot_i];
   
    float dx = ray_direction.x;
		//float dx = cos(radians(player.rotation) - radians(player.fov / 2) + radians(player.fov) * norm_i);
    float dy = ray_direction.y;
		//float dy = sin(radians(player.rotation) - radians(player.fov / 2) + radians(player.fov) * norm_i);
   
    float px = player.position.x;
    float py = player.position.y;
		
		int step = 0;
		
		// traverse the map & check for collisions
    while (step < board_width * 2) {
      float result = boards[(int)px + (int)py * board_width];
     
      if (result > 0) {	
				// determine the wall side touched by the ray, this is important for texture mapping
				/*int tu = (int)px; // horizontal texture coord
				float tx = px - floor(px);
				float ty = py - floor(py);
				
				int side = 0;
				if (tx < ty) {
					side = 1; // cell was hit at the bottom
					tu = (int)py;
				}*/
				
				int tu = (int)((px + py) / 2);
				
				// compute distance with corrected perspective
				// if the perspective is not corrected this will produce fish-eye / distorded walls effect because rays on the edge of the screen need to travel 'further' than the middle rays one 
				float ddx = abs(player.position.x - px);
				float ddy = abs(player.position.y - py);
				
        float dist = sqrt(ddx * ddx + ddy * ddy) * (cos(-radians(player.fov / 2) + radians(player.fov) * norm_i));
        float norm_dist = dist / max(board_width, board_height) / 1.25;
				float inorm_dist = max(1 - norm_dist, 0.01);
				
				// determine wall height from the computed distance
				// dst_proj_plane is just a value related to the FOV, it relate to the player / projection plane distance
        float wh = wall_height / dist * player.dst_proj_plane;
				// now determine the vertical wall start position
        float wall_start_y = height / 2 - wh / 2 + player.height;
       
				// draw floor and ceiling
        /*for (j = 0; j < wall_start_y; j += floor_ceil_stepping) {
          float norm_j = j / wall_start_y;
          float inorm_j = 1. - norm_j;
					float ceil_brightness = 255 * (norm_j * inorm_dist * 2);
					float floor_brightness = 255 * (inorm_j * inorm_dist * 2);
					
          fill(0, 0, ceil_brightness, 32);
          rect(i, j, stepping_x, floor_ceil_stepping);
          fill(floor_brightness, 0, 0, 32);
          rect(i, j + wh + wall_start_y, stepping_x, floor_ceil_stepping);
        }*/
				
				// draw wall (untextured)
				/*
				fill(inorm_dist * 255, 0, 0, 255);
        rect(i, wall_start_y, stepping_x, wh);
				*/
				
	      // draw wall (textured)
				for (j = wall_start_y; j < wall_start_y + wh; j += 2) {
					float norm_j = (float)(j - wall_start_y) / wh;
					color c = textures.pixels[((tu * 4) % (textures.width / 8) + 64) + 
																				(int(norm_j * textures.height) % textures.height) * textures.width];
					fill(red(c) * inorm_dist, green(c) * inorm_dist, blue(c) * inorm_dist);
        	rect(i, j, stepping_x, 2);
				}
				
				// store ray for later use (minimap FOV)
				latest_rays[i].x = floor(px);
				latest_rays[i].y = floor(py);

        break;
      }
     
			// show complete raycast FOV on minimap (pixels perfect but slow and should be computed outside to fix order issues)
      //fill(0, 255, 0, 64);
      //rect(int(px * minimap_scale_x + width - minimap_width_m1), int(py * minimap_scale_y), 1, 1);
			
      px += dx;
      py += dy;
			
			step += 1;
    }
  }
}

// physics logic
void keyPressCheck() {
  if (keyPressed) {
		int rot_i = int(player.rotation) * width;
		
		PVector ray_direction = raydir[width / 2 + rot_i];
		
		PVector velocity = new PVector(ray_direction.x, ray_direction.y);
		velocity.mult(player.vel_multiplier);
		
		int dir = 1;
		if (player.rotation > 90 || player.rotation < 180) {
			dir = -1;
		}
		
		PVector newPosition = new PVector(player.position.x, player.position.y);
		
    if (keyCode == UP) {
			newPosition.add(velocity);
		} else if (keyCode == DOWN) {
			newPosition.sub(velocity);
		} else if (keyCode == LEFT) {
			newPosition.x -= cos(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
			newPosition.y -= sin(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
		} else if (keyCode == RIGHT) {
			newPosition.x += cos(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
			newPosition.y += sin(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
		}
		
		if (newPosition.x < board_width - 1 && newPosition.y < board_height - 1 &&
				newPosition.x > 0 && newPosition.y > 0) {
			player.position = newPosition;
		}
	}
}

void keyReleased() {
	if (keyCode == ENTER || keyCode == RETURN) {
		edit_mode += 1;
		edit_mode %= 2;
	}
}

// update minimap buffer (so we don't compute the minimap rendering it at every frames)
void updateMinimap() {
	pg_minimap.beginDraw();
	pg_minimap.noStroke();
	pg_minimap.fill(255);
  for (int i = 0; i < board_size; i += int(board_width / minimap_width)) {
    float w = boards[i];
   
    if (w > 0.5) {
			int x = i % board_width;
			int y = int((float)i / board_width);

			x = int((float)x * minimap_scale_x);
			y = int((float)y * minimap_scale_y);
     
      pg_minimap.rect(x, y, 1, 1);
    }
  }
	pg_minimap.endDraw();
}

void render_minimap() {
	int minimap_offset_x = width - minimap_width_m1;

	image(pg_minimap, minimap_offset_x, 0);
	
	// player FOV on the minimap from all the latest rays casted (fast but not pixel perfect)
	stroke(255, 0, 0);
	for (int i = 0; i < width; i += minimap_fov_step) {
		PVector ray = latest_rays[i];
		line(player.position.x * minimap_scale_x + minimap_offset_x,
				 player.position.y * minimap_scale_y,
				 ray.x * minimap_scale_x + minimap_offset_x,
				 ray.y * minimap_scale_y);
	}
	noStroke();
	
	// player position
	fill(255, 255, 0);
	ellipse(player.position.x * minimap_scale_x + minimap_offset_x,
			 player.position.y * minimap_scale_y, 6, 6);
}"
"606206","2D volume raycasting","mySketch","/**
  * Custom raytracer done for fun on a phone (APDE Android app.) while commuting.
	* Improved afterward on desktop because APDE is buggy and crashed as the sketch complexity increased ! :)
	* This use Wolfenstein 3D textures.
	*/

static int display_width = 800;
static int display_height = 600;

static int board_width = 256;
static int board_height = board_width; // linked
static int board_size = board_width * board_height;

static int wall_height = 64;

static int player_fov = 60;

static int minimap_width = 128;
static int minimap_height = minimap_width; // linked
static int minimap_width_m1 = minimap_width - 1;
static int minimap_fov_step = 88;
static float minimap_scale_x = (float)minimap_width / board_width;
static float minimap_scale_y = (float)minimap_height / board_height;

// increase for more performances
static int stepping_x = 4;
static int floor_ceil_stepping = 24;

int edit_mode = 0;

float boards[];
PVector raydir[];
PVector latest_rays[];

PImage textures;

PGraphics pg_minimap;

// an entity class which hold player data and other entities
class Entity {
  PVector position;
  float rotation;
  float fov;
	float dst_proj_plane;
	float vel_multiplier = 2;
  float height = 50;
 
  Entity(PVector position, float rotation, float fov) {
    this.position = position;
    this.rotation = rotation;
    this.fov = fov;
		this.dst_proj_plane = 160 / tan(radians(fov / 2));
  }
};

Entity player = new Entity(
    new PVector(board_width / 2,
                board_height / 2), 90, player_fov);

void setup() {
  size(display_width, display_height);
  frameRate(60);
  colorMode(RGB,255,255,255,100);
 
	// initialize the map, enclose it with walls
  boards = new float[board_size];
	
  for (int i = 0; i < board_width; i += 1) {
    boards[i] = 1;
    boards[i + board_width * (board_height - 1)] = 1;
  }
 
  for (int i = 0; i < board_height; i += 1) {
    boards[i * board_width] = 1;
    boards[(board_width - 1) + i * board_width] = 1;
  }
	
	for (int i = 0; i < 360; i += 1) {
		boards[(int)(board_width / 4 + 4 * cos(radians(i))) + (int)(board_height / 4 + 4 * sin(radians(i))) * board_width] = 1;
		boards[(int)(board_width / 4 + 4 * cos(radians(i))) + (int)(board_height - board_height / 4 + 4 * sin(radians(i))) * board_width] = 1;
		boards[(int)(board_width - board_width / 4 + 4 * cos(radians(i))) + (int)(board_height / 4 + 4 * sin(radians(i))) * board_width] = 1;
		boards[(int)(board_width - board_width / 4 + 4 * cos(radians(i))) + (int)(board_height - board_height / 4 + 4 * sin(radians(i))) * board_width] = 1;
	}
	
	// pre-calculate all ray directions for the player FOV
	raydir = new PVector[width * 360];
	
	for (int i = 0; i < (width * 360); i += 1) {
		int rotation_degree = int((float)i / width);

		float ri = i % width;
		float norm_i = ri / width;
		
		raydir[i] = new PVector(
									cos(radians(rotation_degree) - radians(player.fov / 2) + radians(player.fov) * norm_i),
		            	sin(radians(rotation_degree) - radians(player.fov / 2) + radians(player.fov) * norm_i));
	}
	
	// latest rays are stored here
	latest_rays = new PVector[width];
	for (int i = 0; i < width; i += 1) {
		latest_rays[i] = new PVector(0, 0);
	}
	
	textures = loadImage(""wolftextures.png"");
	textures.loadPixels();
	
	pg_minimap = createGraphics(minimap_width, minimap_height);
	
	updateMinimap();
}

void draw() {
  background(0);
 
  noStroke();
 
  raycast();
	
	if (edit_mode) {
		
	} else {
  	render_minimap();
	}
 
  player.rotation = ((float)mouseX / width * 2 * 359) % 360;
	
	keyPressCheck();
}

// core algorithm
void raycast() {
  int i = 0, j = 0;
	
	int rot_i = int(player.rotation) * width;
	
	// scan the screen horizontally and raycast from the defined player FOV
  for (i = 0; i < width; i += stepping_x) {
    float norm_i = (float)i / width;
		
		// we use pre-computed ray directions (see below for the raw formula)
		PVector ray_direction = raydir[i + rot_i];
   
    float dx = ray_direction.x;
		//float dx = cos(radians(player.rotation) - radians(player.fov / 2) + radians(player.fov) * norm_i);
    float dy = ray_direction.y;
		//float dy = sin(radians(player.rotation) - radians(player.fov / 2) + radians(player.fov) * norm_i);
   
    float px = player.position.x;
    float py = player.position.y;
		
		int step = 0;
		
		// traverse the map & check for collisions
    while (step < board_width * 2) {
      float result = boards[(int)px + (int)py * board_width];
     
      if (result > 0) {	
				// determine the wall side touched by the ray, this is important for texture mapping
				/*int tu = (int)px; // horizontal texture coord
				float tx = px - floor(px);
				float ty = py - floor(py);
				
				int side = 0;
				if (tx > 0) {
					side = 1; // cell was hit at the bottom
					tu = (int)py;
				}*/
				
				int tu = (int)abs(px - py);
				
				// compute distance with corrected perspective
				// if the perspective is not corrected this will produce fish-eye / distorded walls effect because rays on the edge of the screen need to travel 'further' than the middle rays one 
				float ddx = abs(player.position.x - px);
				float ddy = abs(player.position.y - py);
				
        float dist = sqrt(ddx * ddx + ddy * ddy) * (cos(-radians(player.fov / 2) + radians(player.fov) * norm_i));
        float norm_dist = dist / max(board_width, board_height) / 1.25;
				float inorm_dist = max(1 - norm_dist, 0.01);
				
				// determine wall height from the computed distance
				// dst_proj_plane is just a value related to the FOV, it relate to the player / projection plane distance
        float wh = wall_height / dist * player.dst_proj_plane;
				// now determine the vertical wall start position
        float wall_start_y = height / 2 - wh / 2 + player.height;
       
				// draw floor and ceiling
        /*for (j = 0; j < wall_start_y; j += floor_ceil_stepping) {
          float norm_j = j / wall_start_y;
          float inorm_j = 1. - norm_j;
					float ceil_brightness = 255 * (norm_j * inorm_dist * 2);
					float floor_brightness = 255 * (inorm_j * inorm_dist * 2);
					
          fill(0, 0, ceil_brightness, 32);
          rect(i, j, stepping_x, floor_ceil_stepping);
          fill(floor_brightness, 0, 0, 32);
          rect(i, j + wh + wall_start_y, stepping_x, floor_ceil_stepping);
        }*/
				
				// draw wall (untextured)
				/*
				fill(inorm_dist * 255, 0, 0, 255);
        rect(i, wall_start_y, stepping_x, wh);
				*/
				
	      // draw wall (textured)
				for (j = wall_start_y; j < wall_start_y + wh; j += 2) {
					float norm_j = (float)(j - wall_start_y) / wh;
					color c = textures.pixels[((tu * 4) % (textures.width / 8) + 64) + 
																				(int(norm_j * textures.height) % textures.height) * textures.width];
					fill(red(c) * inorm_dist, green(c) * inorm_dist, blue(c) * inorm_dist);
        	rect(i, j, stepping_x, 2);
				}
				
				// store ray for later use (minimap FOV)
				latest_rays[i].x = floor(px);
				latest_rays[i].y = floor(py);

        break;
      }
     
			// show complete raycast FOV on minimap (pixels perfect but slow and should be computed outside to fix order issues)
      //fill(0, 255, 0, 64);
      //rect(int(px * minimap_scale_x + width - minimap_width_m1), int(py * minimap_scale_y), 1, 1);
			
      px += dx;
      py += dy;
			
			step += 1;
    }
  }
}

// physics logic
void keyPressCheck() {
  if (keyPressed) {
		int rot_i = int(player.rotation) * width;
		
		PVector ray_direction = raydir[width / 2 + rot_i];
		
		PVector velocity = new PVector(ray_direction.x, ray_direction.y);
		velocity.mult(player.vel_multiplier);
		
		int dir = 1;
		if (player.rotation > 90 || player.rotation < 180) {
			dir = -1;
		}
		
		PVector newPosition = new PVector(player.position.x, player.position.y);
		
    if (keyCode == UP) {
			newPosition.add(velocity);
		} else if (keyCode == DOWN) {
			newPosition.sub(velocity);
		} else if (keyCode == LEFT) {
			newPosition.x -= cos(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
			newPosition.y -= sin(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
		} else if (keyCode == RIGHT) {
			newPosition.x += cos(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
			newPosition.y += sin(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
		}
		
		if (newPosition.x < board_width - 1 && newPosition.y < board_height - 1 &&
				newPosition.x > 0 && newPosition.y > 0) {
			player.position = newPosition;
		}
	}
}

void keyReleased() {
	if (keyCode == ENTER || keyCode == RETURN) {
		edit_mode += 1;
		edit_mode %= 2;
	}
}

// update minimap buffer (so we don't compute the minimap rendering it at every frames)
void updateMinimap() {
	pg_minimap.beginDraw();
	pg_minimap.noStroke();
	pg_minimap.fill(255);
  for (int i = 0; i < board_size; i += int(board_width / minimap_width)) {
    float w = boards[i];
   
    if (w > 0.5) {
			int x = i % board_width;
			int y = int((float)i / board_width);

			x = int((float)x * minimap_scale_x);
			y = int((float)y * minimap_scale_y);
     
      pg_minimap.rect(x, y, 1, 1);
    }
  }
	pg_minimap.endDraw();
}

void render_minimap() {
	int minimap_offset_x = width - minimap_width_m1;

	image(pg_minimap, minimap_offset_x, 0);
	
	// player FOV on the minimap from all the latest rays casted (fast but not pixel perfect)
	stroke(255, 0, 0);
	for (int i = 0; i < width; i += minimap_fov_step) {
		PVector ray = latest_rays[i];
		line(player.position.x * minimap_scale_x + minimap_offset_x,
				 player.position.y * minimap_scale_y,
				 ray.x * minimap_scale_x + minimap_offset_x,
				 ray.y * minimap_scale_y);
	}
	noStroke();
	
	// player position
	fill(255, 255, 0);
	ellipse(player.position.x * minimap_scale_x + minimap_offset_x,
			 player.position.y * minimap_scale_y, 6, 6);
}"
"606206","2D volume raycasting","mySketch","/**
  * Custom raytracer done for fun on a phone (APDE Android app.) while commuting.
	* Improved afterward on desktop because APDE is buggy and crashed as the sketch complexity increased ! :)
	* This use Wolfenstein 3D textures.
	*/

static int display_width = 800;
static int display_height = 600;

static int board_width = 256;
static int board_height = board_width; // linked
static int board_size = board_width * board_height;

static int wall_height = 64;

static int player_fov = 60;

static int minimap_width = 128;
static int minimap_height = minimap_width; // linked
static int minimap_width_m1 = minimap_width - 1;
static int minimap_fov_step = 88;
static float minimap_scale_x = (float)minimap_width / board_width;
static float minimap_scale_y = (float)minimap_height / board_height;

// increase for more performances
static int stepping_x = 4;
static int floor_ceil_stepping = 24;

int edit_mode = 0;

float boards[];
PVector raydir[];
PVector latest_rays[];

PImage textures;

PGraphics pg_minimap;

// an entity class which hold player data and other entities
class Entity {
  PVector position;
  float rotation;
  float fov;
	float dst_proj_plane;
	float vel_multiplier = 2;
  float height = 50;
 
  Entity(PVector position, float rotation, float fov) {
    this.position = position;
    this.rotation = rotation;
    this.fov = fov;
		this.dst_proj_plane = 160 / tan(radians(fov / 2));
  }
};

Entity player = new Entity(
    new PVector(board_width / 2,
                board_height / 2), 90, player_fov);

void setup() {
  size(display_width, display_height);
  frameRate(60);
  colorMode(RGB,255,255,255,100);
 
	// initialize the map, enclose it with walls
  boards = new float[board_size];
	
  for (int i = 0; i < board_width; i += 1) {
    boards[i] = 1;
    boards[i + board_width * (board_height - 1)] = 1;
  }
 
  for (int i = 0; i < board_height; i += 1) {
    boards[i * board_width] = 1;
    boards[(board_width - 1) + i * board_width] = 1;
  }
	
	for (int i = 0; i < 360; i += 1) {
		boards[(int)(board_width / 4 + 4 * cos(radians(i))) + (int)(board_height / 4 + 4 * sin(radians(i))) * board_width] = 1;
		boards[(int)(board_width / 4 + 4 * cos(radians(i))) + (int)(board_height - board_height / 4 + 4 * sin(radians(i))) * board_width] = 1;
		boards[(int)(board_width - board_width / 4 + 4 * cos(radians(i))) + (int)(board_height / 4 + 4 * sin(radians(i))) * board_width] = 1;
		boards[(int)(board_width - board_width / 4 + 4 * cos(radians(i))) + (int)(board_height - board_height / 4 + 4 * sin(radians(i))) * board_width] = 1;
	}
	
	// pre-calculate all ray directions for the player FOV
	raydir = new PVector[width * 360];
	
	for (int i = 0; i < (width * 360); i += 1) {
		int rotation_degree = int((float)i / width);

		float ri = i % width;
		float norm_i = ri / width;
		
		raydir[i] = new PVector(
									cos(radians(rotation_degree) - radians(player.fov / 2) + radians(player.fov) * norm_i),
		            	sin(radians(rotation_degree) - radians(player.fov / 2) + radians(player.fov) * norm_i));
	}
	
	// latest rays are stored here
	latest_rays = new PVector[width];
	for (int i = 0; i < width; i += 1) {
		latest_rays[i] = new PVector(0, 0);
	}
	
	textures = loadImage(""wolftextures.png"");
	textures.loadPixels();
	
	pg_minimap = createGraphics(minimap_width, minimap_height);
	
	updateMinimap();
}

void draw() {
  background(0);
 
  noStroke();
 
  raycast();
	
	if (edit_mode) {
		
	} else {
  	render_minimap();
	}
 
  player.rotation = ((float)mouseX / width * 2 * 359) % 360;
	
	keyPressCheck();
}

// core algorithm
void raycast() {
  int i = 0, j = 0;
	
	int rot_i = int(player.rotation) * width;
	
	// scan the screen horizontally and raycast from the defined player FOV
  for (i = 0; i < width; i += stepping_x) {
    float norm_i = (float)i / width;
		
		// we use pre-computed ray directions (see below for the raw formula)
		PVector ray_direction = raydir[i + rot_i];
   
    float dx = ray_direction.x;
		//float dx = cos(radians(player.rotation) - radians(player.fov / 2) + radians(player.fov) * norm_i);
    float dy = ray_direction.y;
		//float dy = sin(radians(player.rotation) - radians(player.fov / 2) + radians(player.fov) * norm_i);
   
    float px = player.position.x;
    float py = player.position.y;
		
		int step = 0;
		
		// traverse the map & check for collisions
    while (step < board_width * 2) {
      float result = boards[(int)px + (int)py * board_width];
     
      if (result > 0) {	
				// determine horizontal texture coordinate
				int tu = (int)abs(px - py);
				
				// compute distance with corrected perspective
				// if the perspective is not corrected this will produce fish-eye / distorded walls effect because rays on the edge of the screen need to travel 'further' than the middle rays one 
				float ddx = abs(player.position.x - px);
				float ddy = abs(player.position.y - py);
				
        float dist = sqrt(ddx * ddx + ddy * ddy) * (cos(-radians(player.fov / 2) + radians(player.fov) * norm_i));
        float norm_dist = dist / max(board_width, board_height) / 1.25;
				float inorm_dist = max(1 - norm_dist, 0.01);
				
				// determine wall height from the computed distance
				// dst_proj_plane is just a value related to the FOV, it relate to the player / projection plane distance
        float wh = wall_height / dist * player.dst_proj_plane;
				// now determine the vertical wall start position
        float wall_start_y = height / 2 - wh / 2 + player.height;
       
				// draw floor and ceiling
        /*for (j = 0; j < wall_start_y; j += floor_ceil_stepping) {
          float norm_j = j / wall_start_y;
          float inorm_j = 1. - norm_j;
					float ceil_brightness = 255 * (norm_j * inorm_dist * 2);
					float floor_brightness = 255 * (inorm_j * inorm_dist * 2);
					
          fill(0, 0, ceil_brightness, 32);
          rect(i, j, stepping_x, floor_ceil_stepping);
          fill(floor_brightness, 0, 0, 32);
          rect(i, j + wh + wall_start_y, stepping_x, floor_ceil_stepping);
        }*/
				
				// draw wall (untextured)
				/*
				fill(inorm_dist * 255, 0, 0, 255);
        rect(i, wall_start_y, stepping_x, wh);
				*/
				
	      // draw wall (textured)
				for (j = wall_start_y; j < wall_start_y + wh; j += 2) {
					float norm_j = (float)(j - wall_start_y) / wh;
					color c = textures.pixels[((tu * 4) % (textures.width / 8) + 64) + 
																				(int(norm_j * textures.height) % textures.height) * textures.width];
					fill(red(c) * inorm_dist, green(c) * inorm_dist, blue(c) * inorm_dist);
        	rect(i, j, stepping_x, 2);
				}
				
				// store ray for later use (minimap FOV)
				latest_rays[i].x = floor(px);
				latest_rays[i].y = floor(py);

        break;
      }
     
			// show complete raycast FOV on minimap (pixels perfect but slow and should be computed outside to fix order issues)
      //fill(0, 255, 0, 64);
      //rect(int(px * minimap_scale_x + width - minimap_width_m1), int(py * minimap_scale_y), 1, 1);
			
      px += dx;
      py += dy;
			
			step += 1;
    }
  }
}

// physics logic
void keyPressCheck() {
  if (keyPressed) {
		int rot_i = int(player.rotation) * width;
		
		PVector ray_direction = raydir[width / 2 + rot_i];
		
		PVector velocity = new PVector(ray_direction.x, ray_direction.y);
		velocity.mult(player.vel_multiplier);
		
		int dir = 1;
		if (player.rotation > 90 || player.rotation < 180) {
			dir = -1;
		}
		
		PVector newPosition = new PVector(player.position.x, player.position.y);
		
    if (keyCode == UP) {
			newPosition.add(velocity);
		} else if (keyCode == DOWN) {
			newPosition.sub(velocity);
		} else if (keyCode == LEFT) {
			newPosition.x -= cos(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
			newPosition.y -= sin(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
		} else if (keyCode == RIGHT) {
			newPosition.x += cos(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
			newPosition.y += sin(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
		}
		
		if (newPosition.x < board_width - 1 && newPosition.y < board_height - 1 &&
				newPosition.x > 0 && newPosition.y > 0) {
			player.position = newPosition;
		}
	}
}

void keyReleased() {
	if (keyCode == ENTER || keyCode == RETURN) {
		edit_mode += 1;
		edit_mode %= 2;
	}
}

// update minimap buffer (so we don't compute the minimap rendering it at every frames)
void updateMinimap() {
	pg_minimap.beginDraw();
	pg_minimap.noStroke();
	pg_minimap.fill(255);
  for (int i = 0; i < board_size; i += int(board_width / minimap_width)) {
    float w = boards[i];
   
    if (w > 0.5) {
			int x = i % board_width;
			int y = int((float)i / board_width);

			x = int((float)x * minimap_scale_x);
			y = int((float)y * minimap_scale_y);
     
      pg_minimap.rect(x, y, 1, 1);
    }
  }
	pg_minimap.endDraw();
}

void render_minimap() {
	int minimap_offset_x = width - minimap_width_m1;

	image(pg_minimap, minimap_offset_x, 0);
	
	// player FOV on the minimap from all the latest rays casted (fast but not pixel perfect)
	stroke(255, 0, 0);
	for (int i = 0; i < width; i += minimap_fov_step) {
		PVector ray = latest_rays[i];
		line(player.position.x * minimap_scale_x + minimap_offset_x,
				 player.position.y * minimap_scale_y,
				 ray.x * minimap_scale_x + minimap_offset_x,
				 ray.y * minimap_scale_y);
	}
	noStroke();
	
	// player position
	fill(255, 255, 0);
	ellipse(player.position.x * minimap_scale_x + minimap_offset_x,
			 player.position.y * minimap_scale_y, 6, 6);
}"
"606206","2D volume raycasting","mySketch","/**
  * Custom raycaster done for fun on a phone (APDE Android app.) while commuting.
	* Improved afterward on desktop because APDE is buggy and crashed as the sketch complexity increased ! :)
	*
	* This use Wolfenstein 3D textures.
	*
	* This is actually a 2D volume raycaster as map objects are as-is (not blocky) thus it allow curved walls and any wall shapes actually for free...
	* It is however a bit slower than a blocky raycaster and will take way more memory.
	* The rays are also not going from grid cell to grid cell but as a steady user-defined step (enhance why it is more like a volume raycaster),
	* one could extend this to cast rays in a more free ways (in all direction: 3D) and this would basically become a volume raycaster so voxels yeh! :)
	*
	* UV texturing is not really perfect on the horizontal axis because the world isn't blocky, this may be improved in the future but i have yet to find a solution (probably regular texture mapping).
	*
	* A blocky raycaster (a la Wolfenstein 3D) isn't really far from this, the ray step would need to be fixed to the 2D grid and the grid objects would just need to have a defined size.
	*
	* The walls are mirrored on the y axis so we get a cheap floor mirror :p
	*/

static int display_width = 640;
static int display_height = 480;

static int board_width = 256;
static int board_height = board_width; // linked
static int board_size = board_width * board_height;

// typically the diagonal of the map so we stop any rays casted outside...
// but this can also be used for performances, this is the camera z clipping so with fog and this we can speed the rendering up :)
static int max_ray_step = board_width * 2;

static int wall_height = 32;

static int player_fov = 60;

static int minimap_width = 128;
static int minimap_height = minimap_width; // linked
static int minimap_width_m1 = minimap_width - 1;
static int minimap_fov_step = 88;
static float minimap_scale_x = (float)minimap_width / board_width;
static float minimap_scale_y = (float)minimap_height / board_height;

// increase for more performances
static int stepping_x = 8;
static int floor_stepping = 8;
static int ceil_stepping = 8;
static int texture_stepping = 2;

int edit_mode = 0;

float boards[];
// we use this actually instead of ""boards"" to store the map data
// this allow to draw our map directly with Processing shapes since we are not restricted to perpendicular walls :)
PGraphics pg_map;

PVector raydir[];
PVector latest_rays[];

PImage textures;

PGraphics pg_minimap;

// an entity class which hold player data and other entities
class Entity {
  PVector position;
  float rotation;
  float fov;
	float dst_proj_plane;
	float vel_multiplier = 2;
  float height = 50;
 
  Entity(PVector position, float rotation, float fov) {
    this.position = position;
    this.rotation = rotation;
    this.fov = fov;
		this.dst_proj_plane = 160 / tan(radians(fov / 2));
  }
};

Entity player = new Entity(
    new PVector(board_width / 2,
                board_height / 2), 90, player_fov);

void setup() {
  size(display_width, display_height);
  frameRate(60);
  colorMode(RGB,255,255,255,100);
 
	// initialize the map
	// since this is a volume raycaster we can do fun walls so we use curves, ellipse and more :)
	pg_map = createGraphics(board_width, board_height);
	pg_map.beginDraw();
	pg_map.noFill();
	pg_map.stroke(255);
	pg_map.rect(0, 0, board_width - 1, board_height - 1);
	pg_map.bezier(85, 20, 10, 10, 90, 90, 15, 80);
	pg_map.bezier(85 * 2, 20 * 2, 10 * 2, 10 * 2, 90 * 2, 90 * 2, 15 * 2, 80 * 2);
	pg_map.ellipse(board_width / 1.25, board_height / 1.25, 16, 16);
	pg_map.triangle(192, 200, 100, 210, 95, 240);
	pg_map.endDraw();
	pg_map.loadPixels();
	
/* // classical array
	boards = new float[board_size];

  for (int i = 0; i < board_width; i += 1) {
    boards[i] = 1;
    boards[i + board_width * (board_height - 1)] = 1;
  }
 
  for (int i = 0; i < board_height; i += 1) {
    boards[i * board_width] = 1;
    boards[(board_width - 1) + i * board_width] = 1;
  }
	
	for (int i = 0; i < 360; i += 1) {
		boards[(int)(board_width / 4 + 4 * cos(radians(i))) + (int)(board_height / 4 + 4 * sin(radians(i))) * board_width] = 1;
		boards[(int)(board_width / 4 + 4 * cos(radians(i))) + (int)(board_height - board_height / 4 + 4 * sin(radians(i))) * board_width] = 1;
		boards[(int)(board_width - board_width / 4 + 4 * cos(radians(i))) + (int)(board_height / 4 + 4 * sin(radians(i))) * board_width] = 1;
		boards[(int)(board_width - board_width / 4 + 4 * cos(radians(i))) + (int)(board_height - board_height / 4 + 4 * sin(radians(i))) * board_width] = 1;
	}
*/
	
	// pre-calculate all ray directions for the player FOV
	raydir = new PVector[width * 360];
	
	for (int i = 0; i < (width * 360); i += 1) {
		int rotation_degree = int((float)i / width);

		float ri = i % width;
		float norm_i = ri / width;
		
		raydir[i] = new PVector(
									cos(radians(rotation_degree) - radians(player.fov / 2) + radians(player.fov) * norm_i),
		            	sin(radians(rotation_degree) - radians(player.fov / 2) + radians(player.fov) * norm_i));
	}
	
	// latest rays are stored here (used to display the player FOV in the minimap)
	latest_rays = new PVector[width];
	for (int i = 0; i < width; i += 1) {
		latest_rays[i] = new PVector(0, 0);
	}
	
	textures = loadImage(""wolftextures.png"");
	textures.loadPixels();
	
	pg_minimap = createGraphics(minimap_width, minimap_height);
	
	updateMinimap();
	
}

void draw() {
  background(0);
 
  noStroke();
 
  raycast();
	
	if (edit_mode) {
		
	} else {
  	render_minimap();
	}
 
  player.rotation = ((float)mouseX / width * 2 * 359) % 360;
	
	keyPressCheck();
}

// core algorithm
void raycast() {
  int i = 0, j = 0;
	
	int rot_i = int(player.rotation) * width;
	
	// scan the screen horizontally and raycast from the defined player FOV
  for (i = 0; i < width; i += stepping_x) {
    float norm_i = (float)i / width;
		
		// we use pre-computed ray directions (see below for the raw formula)
		PVector ray_direction = raydir[i + rot_i];
   
    float dx = ray_direction.x;
		//float dx = cos(radians(player.rotation) - radians(player.fov / 2) + radians(player.fov) * norm_i);
    float dy = ray_direction.y;
		//float dy = sin(radians(player.rotation) - radians(player.fov / 2) + radians(player.fov) * norm_i);
		
    float px = player.position.x;
    float py = player.position.y;
		
		int step = 0;
		
		// traverse the map & check for collisions
    while (step < max_ray_step) {
      //float result = boards[(int)px + (int)py * board_width];
			float result = brightness(pg_map.pixels[(int)px + (int)py * board_width]);
     
      if (result > 0) {	
				// determine horizontal texture coordinate (note : too simple for this type of raycaster)
				float tu = px + py;
				
				// compute distance with corrected perspective
				// if the perspective is not corrected this will produce fish-eye / distorded walls effect because rays on the edge of the screen need to travel 'further' than the middle rays one 
				float ddx = abs(player.position.x - px);
				float ddy = abs(player.position.y - py);
				
        float dist = sqrt(ddx * ddx + ddy * ddy) * (cos(-radians(player.fov / 2) + radians(player.fov) * norm_i));
        float norm_dist = dist / max(board_width, board_height) / 1.25;
				float inorm_dist = max(1 - norm_dist, 0.01);

				// determine wall height from the computed distance
				// dst_proj_plane is just a value related to the FOV, it relate to the player / projection plane distance
        float wh = wall_height / dist * player.dst_proj_plane;
				// now determine the vertical wall start position
        float wall_start_y = height / 2 - wh / 2 + player.height;
				
				// draw wall (untextured)
				/*
				fill(inorm_dist * 255, 0, 0, 255);
        rect(i, wall_start_y, stepping_x, wh);
				*/
				
				// simple ceiling
				/*int ceil_start = height / 2;
				for (j = ceil_start; j > -ceil_stepping; j -= ceil_stepping) {
					float inorm_j = (float)j / (height / 2);
					float norm_j = 1. - inorm_j;
					float ceil_brightness = 255 * (inorm_j);

					fill(0, 0, ceil_brightness, 64);
					rect(i, j, stepping_x, ceil_stepping);
				}*/
				
				// can change texture here (64, 128, 192 etc)
				int u = (int(tu) % (textures.width / 8) + 64);
				
	      // draw wall (textured)
				for (j = wall_start_y; j < wall_start_y + wh; j += texture_stepping) {
					float norm_j = (float)(j - wall_start_y) / wh;
					color c = textures.pixels[u + (int(norm_j * textures.height) % textures.height) * textures.width];
					fill(red(c) * inorm_dist, green(c) * inorm_dist, blue(c) * inorm_dist);
        	rect(i, j, stepping_x, texture_stepping);
					
					float cm = norm_dist * norm_j * 2;
					
					// mirrored :)
					fill(red(c) * cm, green(c) * cm, blue(c) * cm);
					rect(i, (wall_start_y + wh) * 2 - j, stepping_x, texture_stepping);
				}
				
				// draw ceiling
				/*int ceil_start = wall_start_y - ceil_stepping;
				for (j = ceil_start; j > -ceil_stepping; j -= ceil_stepping) {
					float inorm_j = (float)j / wall_start_y;
					float norm_j = 1. - inorm_j;
					float ceil_brightness = 255 * (inorm_j * inorm_dist * 2);

					fill(0, 0, ceil_brightness, 64);
					rect(i, j, stepping_x, ceil_stepping);
				}*/
				
				// draw floor
				int floor_start = wh + wall_start_y;
				for (j = floor_start; j < height; j += floor_stepping) {
					float norm_j = (float)(j - floor_start) / (height - floor_start);
					float inorm_j = 1. - norm_j;
					float floor_brightness = 255 * norm_j;
					
					fill(floor_brightness, 0, 0, 64);
					rect(i, j, stepping_x, floor_stepping);
				}
				
				// store ray for later use (minimap FOV)
				latest_rays[i].x = floor(px);
				latest_rays[i].y = floor(py);
				
        break;
      }

			// show complete raycast FOV on minimap (pixels perfect but slow and should be computed outside to fix order issues)
      //fill(0, 255, 0, 64);
      //rect(int(px * minimap_scale_x + width - minimap_width_m1), int(py * minimap_scale_y), 1, 1);
			
      px += dx;
      py += dy;
			
			step += 1;
    }
  }
}

// physics logic
void keyPressCheck() {
  if (keyPressed) {
		int rot_i = int(player.rotation) * width;
		
		PVector ray_direction = raydir[width / 2 + rot_i];
		
		PVector velocity = new PVector(ray_direction.x, ray_direction.y);
		velocity.mult(player.vel_multiplier);
		
		int dir = 1;
		if (player.rotation > 90 || player.rotation < 180) {
			dir = -1;
		}
		
		PVector newPosition = new PVector(player.position.x, player.position.y);
		
    if (keyCode == UP) {
			newPosition.add(velocity);
		} else if (keyCode == DOWN) {
			newPosition.sub(velocity);
		}
		
		if (keyCode == LEFT) {
			newPosition.x -= cos(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
			newPosition.y -= sin(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
		} else if (keyCode == RIGHT) {
			newPosition.x += cos(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
			newPosition.y += sin(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
		}
		
		if (newPosition.x < board_width - 1 && newPosition.y < board_height - 1 &&
				newPosition.x > 0 && newPosition.y > 0) {
			player.position = newPosition;
		}
	}
}

void keyReleased() {
	if (keyCode == ENTER || keyCode == RETURN) {
		edit_mode += 1;
		edit_mode %= 2;
	}
}

// update minimap buffer (so we don't compute the minimap rendering it at every frames)
void updateMinimap() {
	pg_minimap.beginDraw();
	pg_minimap.noStroke();
	pg_minimap.fill(255);
  for (int i = 0; i < board_size; i += int(board_width / minimap_width)) {
    //float w = boards[i];
		float w = brightness(pg_map.pixels[i]);
   
    if (w > 0.5) {
			int x = i % board_width;
			int y = int((float)i / board_width);

			x = int((float)x * minimap_scale_x);
			y = int((float)y * minimap_scale_y);
     
      pg_minimap.rect(x, y, 1, 1);
    }
  }
	pg_minimap.endDraw();
}

void render_minimap() {
	int minimap_offset_x = width - minimap_width_m1;

	image(pg_minimap, minimap_offset_x, 0);
	
	// player FOV on the minimap from all the latest rays casted (fast but not pixel perfect)
	stroke(255, 0, 0);
	for (int i = 0; i < width; i += minimap_fov_step) {
		PVector ray = latest_rays[i];
		line(player.position.x * minimap_scale_x + minimap_offset_x,
				 player.position.y * minimap_scale_y,
				 ray.x * minimap_scale_x + minimap_offset_x,
				 ray.y * minimap_scale_y);
	}
	noStroke();
	
	// player position
	fill(255, 255, 0);
	ellipse(player.position.x * minimap_scale_x + minimap_offset_x,
			 player.position.y * minimap_scale_y, 6, 6);
}"
"606206","2D volume raycasting","mySketch","/**
  * Custom raycaster done for fun on a phone (APDE Android app.) while commuting.
	* Improved afterward on desktop because APDE is buggy and crashed as the sketch complexity increased ! :)
	*
	* This use Wolfenstein 3D textures.
	*
	* This is actually a 2D volume raycaster as map objects are as-is (not blocky) thus it allow curved walls and any wall shapes actually for free...
	* It is however a bit slower than a blocky raycaster and will take way more memory.
	* The rays are also not going from grid cell to grid cell but as a steady user-defined step (enhance why it is more like a volume raycaster),
	* one could extend this to cast rays in a more free ways (in all direction: 3D) and this would basically become a volume raycaster so voxels yeh! :)
	*
	* UV texturing is not really perfect on the horizontal axis because the world isn't blocky, this may be improved in the future but i have yet to find a solution (probably regular texture mapping).
	*
	* A blocky raycaster (a la Wolfenstein 3D) isn't really far from this, the ray step would need to be fixed to the 2D grid and the grid objects would just need to have a defined size.
	*
	* The walls are mirrored on the y axis so we get a cheap floor mirror :p
	*/

static int display_width = 640;
static int display_height = 480;

static int board_width = 256;
static int board_height = board_width; // linked
static int board_size = board_width * board_height;

// typically the diagonal of the map so we stop any rays casted outside...
// but this can also be used for performances, this is the camera z clipping so with fog and this we can speed the rendering up :)
static int max_ray_step = board_width * 2;

static int wall_height = 32;

static int player_fov = 60;

static int minimap_width = 128;
static int minimap_height = minimap_width; // linked
static int minimap_width_m1 = minimap_width - 1;
static int minimap_fov_step = 88;
static float minimap_scale_x = (float)minimap_width / board_width;
static float minimap_scale_y = (float)minimap_height / board_height;

// increase for more performances
static int stepping_x = 8;
static int floor_stepping = 8;
static int ceil_stepping = 8;
static int texture_stepping = 2;

int edit_mode = 0;

float boards[];
// we use this actually instead of ""boards"" to store the map data
// this allow to draw our map directly with Processing shapes since we are not restricted to perpendicular walls :)
PGraphics pg_map;

PVector raydir[];
PVector latest_rays[];

PImage textures;

PGraphics pg_minimap;

// an entity class which hold player data and other entities
class Entity {
  PVector position;
  float rotation;
  float fov;
	float dst_proj_plane;
	float vel_multiplier = 2;
  float height = 50;
 
  Entity(PVector position, float rotation, float fov) {
    this.position = position;
    this.rotation = rotation;
    this.fov = fov;
		this.dst_proj_plane = 160 / tan(radians(fov / 2));
  }
};

Entity player = new Entity(
    new PVector(board_width / 2,
                board_height / 2), 90, player_fov);

void setup() {
  size(display_width, display_height);
  frameRate(60);
  colorMode(RGB,255,255,255,100);
 
	// initialize the map
	// since this is a volume raycaster we can do fun walls so we use curves, ellipse and more :)
	pg_map = createGraphics(board_width, board_height);
	pg_map.beginDraw();
	pg_map.noFill();
	pg_map.stroke(255);
	pg_map.rect(0, 0, board_width - 1, board_height - 1);
	pg_map.bezier(85, 20, 10, 10, 90, 90, 15, 80);
	pg_map.bezier(85 * 2, 20 * 2, 10 * 2, 10 * 2, 90 * 2, 90 * 2, 15 * 2, 80 * 2);
	pg_map.ellipse(board_width / 1.25, board_height / 1.25, 16, 16);
	pg_map.triangle(192, 200, 100, 210, 95, 240);
	pg_map.endDraw();
	pg_map.loadPixels();
	
/* // classical array
	boards = new float[board_size];

  for (int i = 0; i < board_width; i += 1) {
    boards[i] = 1;
    boards[i + board_width * (board_height - 1)] = 1;
  }
 
  for (int i = 0; i < board_height; i += 1) {
    boards[i * board_width] = 1;
    boards[(board_width - 1) + i * board_width] = 1;
  }
	
	for (int i = 0; i < 360; i += 1) {
		boards[(int)(board_width / 4 + 4 * cos(radians(i))) + (int)(board_height / 4 + 4 * sin(radians(i))) * board_width] = 1;
		boards[(int)(board_width / 4 + 4 * cos(radians(i))) + (int)(board_height - board_height / 4 + 4 * sin(radians(i))) * board_width] = 1;
		boards[(int)(board_width - board_width / 4 + 4 * cos(radians(i))) + (int)(board_height / 4 + 4 * sin(radians(i))) * board_width] = 1;
		boards[(int)(board_width - board_width / 4 + 4 * cos(radians(i))) + (int)(board_height - board_height / 4 + 4 * sin(radians(i))) * board_width] = 1;
	}
*/
	
	// pre-calculate all ray directions for the player FOV
	raydir = new PVector[width * 360];
	
	for (int i = 0; i < (width * 360); i += 1) {
		int rotation_degree = int((float)i / width);

		float ri = i % width;
		float norm_i = ri / width;
		
		raydir[i] = new PVector(
									cos(radians(rotation_degree) - radians(player.fov / 2) + radians(player.fov) * norm_i),
		            	sin(radians(rotation_degree) - radians(player.fov / 2) + radians(player.fov) * norm_i));
	}
	
	// latest rays are stored here (used to display the player FOV in the minimap)
	latest_rays = new PVector[width];
	for (int i = 0; i < width; i += 1) {
		latest_rays[i] = new PVector(0, 0);
	}
	
	textures = loadImage(""wolftextures.png"");
	textures.loadPixels();
	
	pg_minimap = createGraphics(minimap_width, minimap_height);
	
	updateMinimap();
	
}

void draw() {
  background(0);
 
  noStroke();
 
  raycast();
	
	if (edit_mode) {
		
	} else {
  	render_minimap();
	}
 
  player.rotation = ((float)mouseX / width * 2 * 359) % 360;
	
	keyPressCheck();
}

// core algorithm
void raycast() {
  int i = 0, j = 0;
	
	int rot_i = int(player.rotation) * width;
	
	// scan the screen horizontally and raycast from the defined player FOV
  for (i = 0; i < width; i += stepping_x) {
    float norm_i = (float)i / width;
		
		// we use pre-computed ray directions (see below for the raw formula)
		PVector ray_direction = raydir[i + rot_i];
   
    float dx = ray_direction.x;
		//float dx = cos(radians(player.rotation) - radians(player.fov / 2) + radians(player.fov) * norm_i);
    float dy = ray_direction.y;
		//float dy = sin(radians(player.rotation) - radians(player.fov / 2) + radians(player.fov) * norm_i);
		
    float px = player.position.x;
    float py = player.position.y;
		
		int step = 0;
		
		// traverse the map & check for collisions
    while (step < max_ray_step) {
      //float result = boards[(int)px + (int)py * board_width];
			float result = brightness(pg_map.pixels[(int)px + (int)py * board_width]);
     
      if (result > 0) {	
				// determine horizontal texture coordinate (note : too simple for this type of raycaster)
				float tu = px + py;
				
				// compute distance with corrected perspective
				// if the perspective is not corrected this will produce fish-eye / distorded walls effect because rays on the edge of the screen need to travel 'further' than the middle rays one 
				float ddx = abs(player.position.x - px);
				float ddy = abs(player.position.y - py);
				
        float dist = sqrt(ddx * ddx + ddy * ddy) * (cos(-radians(player.fov / 2) + radians(player.fov) * norm_i));
        float norm_dist = dist / max(board_width, board_height) / 1.25;
				float inorm_dist = max(1 - norm_dist, 0.01);

				// determine wall height from the computed distance
				// dst_proj_plane is just a value related to the FOV, it relate to the player / projection plane distance
        float wh = wall_height / dist * player.dst_proj_plane;
				// now determine the vertical wall start position
        float wall_start_y = height / 2 - wh / 2 + player.height;
				
				// draw wall (untextured)
				/*
				fill(inorm_dist * 255, 0, 0, 255);
        rect(i, wall_start_y, stepping_x, wh);
				*/
				
				// simple ceiling
				/*int ceil_start = height / 2;
				for (j = ceil_start; j > -ceil_stepping; j -= ceil_stepping) {
					float inorm_j = (float)j / (height / 2);
					float norm_j = 1. - inorm_j;
					float ceil_brightness = 255 * (inorm_j);

					fill(0, 0, ceil_brightness, 64);
					rect(i, j, stepping_x, ceil_stepping);
				}*/
				
				// can change texture here (64, 128, 192 etc)
				int u = (int(tu) % (textures.width / 8) + 64);
				
	      // draw wall (textured)
				for (j = wall_start_y; j < wall_start_y + wh; j += texture_stepping) {
					float norm_j = (float)(j - wall_start_y) / wh;
					color c = textures.pixels[u + (int(norm_j * textures.height) % textures.height) * textures.width];
					fill(red(c) * inorm_dist, green(c) * inorm_dist, blue(c) * inorm_dist);
        	rect(i, j, stepping_x, texture_stepping);
					
					float cm = norm_dist * norm_j * 2;
					
					// mirrored :)
					fill(red(c) * cm, green(c) * cm, blue(c) * cm);
					rect(i, (wall_start_y + wh) * 2 - j, stepping_x, texture_stepping);
				}
				
				// draw ceiling
				/*int ceil_start = wall_start_y - ceil_stepping;
				for (j = ceil_start; j > -ceil_stepping; j -= ceil_stepping) {
					float inorm_j = (float)j / wall_start_y;
					float norm_j = 1. - inorm_j;
					float ceil_brightness = 255 * (inorm_j * inorm_dist * 2);

					fill(0, 0, ceil_brightness, 64);
					rect(i, j, stepping_x, ceil_stepping);
				}*/
				
				// draw floor
				int floor_start = wh + wall_start_y;
				for (j = floor_start; j < height; j += floor_stepping) {
					float norm_j = (float)(j - floor_start) / (height - floor_start);
					float inorm_j = 1. - norm_j;
					float floor_brightness = 255 * norm_j;
					
					fill(floor_brightness, 0, 0, 64);
					rect(i, j, stepping_x, floor_stepping);
				}
				
				// store ray for later use (minimap FOV)
				latest_rays[i].x = floor(px);
				latest_rays[i].y = floor(py);
				
        break;
      }

			// show complete raycast FOV on minimap (pixels perfect but slow and should be computed outside to fix order issues)
      //fill(0, 255, 0, 64);
      //rect(int(px * minimap_scale_x + width - minimap_width_m1), int(py * minimap_scale_y), 1, 1);
			
      px += dx;
      py += dy;
			
			step += 1;
    }
  }
}

// physics logic
void keyPressCheck() {
  if (keyPressed) {
		int rot_i = int(player.rotation) * width;
		
		PVector ray_direction = raydir[width / 2 + rot_i];
		
		PVector velocity = new PVector(ray_direction.x, ray_direction.y);
		velocity.mult(player.vel_multiplier);
		
		int dir = 1;
		if (player.rotation > 90 || player.rotation < 180) {
			dir = -1;
		}
		
		PVector newPosition = new PVector(player.position.x, player.position.y);
		
    if (keyCode == UP) {
			newPosition.add(velocity);
		} else if (keyCode == DOWN) {
			newPosition.sub(velocity);
		}
		
		if (keyCode == LEFT) {
			newPosition.x -= cos(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
			newPosition.y -= sin(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
		} else if (keyCode == RIGHT) {
			newPosition.x += cos(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
			newPosition.y += sin(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
		}
		
		if (newPosition.x < board_width - 1 && newPosition.y < board_height - 1 &&
				newPosition.x > 0 && newPosition.y > 0) {
			player.position = newPosition;
		}
	}
}

void keyReleased() {
	if (keyCode == ENTER || keyCode == RETURN) {
		edit_mode += 1;
		edit_mode %= 2;
	}
}

// update minimap buffer (so we don't compute the minimap rendering it at every frames)
void updateMinimap() {
	pg_minimap.beginDraw();
	pg_minimap.noStroke();
	pg_minimap.fill(255);
  for (int i = 0; i < board_size; i += int(board_width / minimap_width)) {
    //float w = boards[i];
		float w = brightness(pg_map.pixels[i]);
   
    if (w > 0.5) {
			int x = i % board_width;
			int y = int((float)i / board_width);

			x = int((float)x * minimap_scale_x);
			y = int((float)y * minimap_scale_y);
     
      pg_minimap.rect(x, y, 1, 1);
    }
  }
	pg_minimap.endDraw();
}

void render_minimap() {
	int minimap_offset_x = width - minimap_width_m1;

	image(pg_minimap, minimap_offset_x, 0);
	
	// player FOV on the minimap from all the latest rays casted (fast but not pixel perfect)
	stroke(255, 0, 0);
	for (int i = 0; i < width; i += minimap_fov_step) {
		PVector ray = latest_rays[i];
		line(player.position.x * minimap_scale_x + minimap_offset_x,
				 player.position.y * minimap_scale_y,
				 ray.x * minimap_scale_x + minimap_offset_x,
				 ray.y * minimap_scale_y);
	}
	noStroke();
	
	// player position
	fill(255, 255, 0);
	ellipse(player.position.x * minimap_scale_x + minimap_offset_x,
			 player.position.y * minimap_scale_y, 6, 6);
}"
"606206","2D volume raycasting","mySketch","/**
  * Custom raycaster done for fun on a phone (APDE Android app.) while commuting.
	* Improved afterward on desktop because APDE is buggy and crashed as the sketch complexity increased ! :)
	*
	* This use Wolfenstein 3D textures.
	*
	* This is actually a 2D volume raycaster as map objects are as-is (not blocky) thus it allow curved walls and any wall shapes actually for free...
	* It is however a bit slower than a blocky raycaster and will take way more memory.
	* The rays are also not going from grid cell to grid cell but as a steady user-defined step (enhance why it is more like a volume raycaster),
	* one could extend this to cast rays in a more free ways (in all direction: 3D) and this would basically become a volume raycaster so voxels yeh! :)
	*
	* A blocky raycaster (a la Wolfenstein 3D) isn't really far from this, the ray step would need to be fixed to the 2D grid and the grid objects would just need to have a defined size.
	*
	* The walls are mirrored on the y axis so we get a cheap floor mirror :p
	*/

static int display_width = 640;
static int display_height = 480;

static int board_width = 256;
static int board_height = board_width; // linked
static int board_size = board_width * board_height;

// typically the diagonal of the map so we stop any rays casted outside...
// but this can also be used for performances, this is the camera z clipping so with fog and this we can speed the rendering up :)
static int max_ray_step = board_width * 2;

static int wall_height = 32;

static int player_fov = 60;

static int minimap_width = 128;
static int minimap_height = minimap_width; // linked
static int minimap_width_m1 = minimap_width - 1;
static int minimap_fov_step = 88;
static float minimap_scale_x = (float)minimap_width / board_width;
static float minimap_scale_y = (float)minimap_height / board_height;

// increase for more performances
static int stepping_x = 8;
static int floor_stepping = 8;
static int ceil_stepping = 8;
static int texture_stepping = 2;

int edit_mode = 0;

float boards[];
// we use this actually instead of ""boards"" to store the map data
// this allow to draw our map directly with Processing shapes since we are not restricted to perpendicular walls :)
PGraphics pg_map;

PVector raydir[];
PVector latest_rays[];

PImage textures;

PGraphics pg_minimap;

// an entity class which hold player data and other entities
class Entity {
  PVector position;
  float rotation;
  float fov;
	float dst_proj_plane;
	float vel_multiplier = 2;
  float height = 50;
 
  Entity(PVector position, float rotation, float fov) {
    this.position = position;
    this.rotation = rotation;
    this.fov = fov;
		this.dst_proj_plane = 160 / tan(radians(fov / 2));
  }
};

Entity player = new Entity(
    new PVector(board_width / 2,
                board_height / 2), 90, player_fov);

void setup() {
  size(display_width, display_height);
  frameRate(60);
  colorMode(RGB,255,255,255,100);
 
	// initialize the map
	// since this is a volume raycaster we can do fun walls so we use curves, ellipse and more :)
	pg_map = createGraphics(board_width, board_height);
	pg_map.beginDraw();
	pg_map.noFill();
	pg_map.stroke(255);
	pg_map.rect(0, 0, board_width - 1, board_height - 1);
	pg_map.bezier(85, 20, 10, 10, 90, 90, 15, 80);
	pg_map.bezier(85 * 2, 20 * 2, 10 * 2, 10 * 2, 90 * 2, 90 * 2, 15 * 2, 80 * 2);
	pg_map.ellipse(board_width / 1.25, board_height / 1.25, 16, 16);
	pg_map.triangle(192, 200, 100, 210, 95, 240);
	pg_map.endDraw();
	pg_map.loadPixels();
	
/* // classical array
	boards = new float[board_size];

  for (int i = 0; i < board_width; i += 1) {
    boards[i] = 1;
    boards[i + board_width * (board_height - 1)] = 1;
  }
 
  for (int i = 0; i < board_height; i += 1) {
    boards[i * board_width] = 1;
    boards[(board_width - 1) + i * board_width] = 1;
  }
	
	for (int i = 0; i < 360; i += 1) {
		boards[(int)(board_width / 4 + 4 * cos(radians(i))) + (int)(board_height / 4 + 4 * sin(radians(i))) * board_width] = 1;
		boards[(int)(board_width / 4 + 4 * cos(radians(i))) + (int)(board_height - board_height / 4 + 4 * sin(radians(i))) * board_width] = 1;
		boards[(int)(board_width - board_width / 4 + 4 * cos(radians(i))) + (int)(board_height / 4 + 4 * sin(radians(i))) * board_width] = 1;
		boards[(int)(board_width - board_width / 4 + 4 * cos(radians(i))) + (int)(board_height - board_height / 4 + 4 * sin(radians(i))) * board_width] = 1;
	}
*/
	
	// pre-calculate all ray directions for the player FOV
	raydir = new PVector[width * 360];
	
	for (int i = 0; i < (width * 360); i += 1) {
		int rotation_degree = int((float)i / width);

		float ri = i % width;
		float norm_i = ri / width;
		
		raydir[i] = new PVector(
									cos(radians(rotation_degree) - radians(player.fov / 2) + radians(player.fov) * norm_i),
		            	sin(radians(rotation_degree) - radians(player.fov / 2) + radians(player.fov) * norm_i));
	}
	
	// latest rays are stored here (used to display the player FOV in the minimap)
	latest_rays = new PVector[width];
	for (int i = 0; i < width; i += 1) {
		latest_rays[i] = new PVector(0, 0);
	}
	
	textures = loadImage(""wolftextures.png"");
	textures.loadPixels();
	
	pg_minimap = createGraphics(minimap_width, minimap_height);
	
	updateMinimap();
	
}

void draw() {
  background(0);
 
  noStroke();
 
  raycast();
	
	if (edit_mode) {
		
	} else {
  	render_minimap();
	}
 
  player.rotation = ((float)mouseX / width * 2 * 359) % 360;
	
	keyPressCheck();
}

// core algorithm
void raycast() {
  int i = 0, j = 0;
	
	int rot_i = int(player.rotation) * width;
	
	// scan the screen horizontally and raycast from the defined player FOV
  for (i = 0; i < width; i += stepping_x) {
    float norm_i = (float)i / width;
		
		// we use pre-computed ray directions (see below for the raw formula)
		PVector ray_direction = raydir[i + rot_i];
   
    float dx = ray_direction.x;
		//float dx = cos(radians(player.rotation) - radians(player.fov / 2) + radians(player.fov) * norm_i);
    float dy = ray_direction.y;
		//float dy = sin(radians(player.rotation) - radians(player.fov / 2) + radians(player.fov) * norm_i);
		
    float px = player.position.x;
    float py = player.position.y;
		
		int step = 0;
		
		// traverse the map & check for collisions
    while (step < max_ray_step) {
      //float result = boards[(int)px + (int)py * board_width];
			float result = brightness(pg_map.pixels[(int)px + (int)py * board_width]);
     
      if (result > 0) {					
				// compute distance with corrected perspective
				// if the perspective is not corrected this will produce fish-eye / distorded walls effect because rays on the edge of the screen need to travel 'further' than the middle rays one 
				float ddx = abs(player.position.x - px);
				float ddy = abs(player.position.y - py);
				
        float dist = sqrt(ddx * ddx + ddy * ddy) * (cos(-radians(player.fov / 2) + radians(player.fov) * norm_i));
        float norm_dist = dist / max(board_width, board_height) / 1.25;
				float inorm_dist = max(1 - norm_dist, 0.01);
				
				// determine horizontal texture coordinate
				float tu = px / norm_dist + py / norm_dist;

				// determine wall height from the computed distance
				// dst_proj_plane is just a value related to the FOV, it relate to the player / projection plane distance
        float wh = wall_height / dist * player.dst_proj_plane;
				// now determine the vertical wall start position
        float wall_start_y = height / 2 - wh / 2 + player.height;
				
				// draw wall (untextured)
				/*
				fill(inorm_dist * 255, 0, 0, 255);
        rect(i, wall_start_y, stepping_x, wh);
				*/
				
				// simple ceiling
				/*int ceil_start = height / 2;
				for (j = ceil_start; j > -ceil_stepping; j -= ceil_stepping) {
					float inorm_j = (float)j / (height / 2);
					float norm_j = 1. - inorm_j;
					float ceil_brightness = 255 * (inorm_j);

					fill(0, 0, ceil_brightness, 64);
					rect(i, j, stepping_x, ceil_stepping);
				}*/
				
				// can change texture here (64, 128, 192 etc)
				int u = (int(tu) % (textures.width / 8) + 64);
				
	      // draw wall (textured)
				for (j = wall_start_y; j < wall_start_y + wh; j += texture_stepping) {
					float norm_j = (float)(j - wall_start_y) / wh;
					color c = textures.pixels[u + (int(norm_j * textures.height) % textures.height) * textures.width];
					fill(red(c) * inorm_dist, green(c) * inorm_dist, blue(c) * inorm_dist);
        	rect(i, j, stepping_x, texture_stepping);
					
					float cm = norm_dist * norm_j * 2;
					
					// mirrored :)
					fill(red(c) * cm, green(c) * cm, blue(c) * cm);
					rect(i, (wall_start_y + wh) * 2 - j, stepping_x, texture_stepping);
				}
				
				// draw ceiling
				/*int ceil_start = wall_start_y - ceil_stepping;
				for (j = ceil_start; j > -ceil_stepping; j -= ceil_stepping) {
					float inorm_j = (float)j / wall_start_y;
					float norm_j = 1. - inorm_j;
					float ceil_brightness = 255 * (inorm_j * inorm_dist * 2);

					fill(0, 0, ceil_brightness, 64);
					rect(i, j, stepping_x, ceil_stepping);
				}*/
				
				// draw floor
				int floor_start = wh + wall_start_y;
				for (j = floor_start; j < height; j += floor_stepping) {
					float norm_j = (float)(j - floor_start) / (height - floor_start);
					float inorm_j = 1. - norm_j;
					float floor_brightness = 255 * norm_j;
					
					fill(floor_brightness, 0, 0, 64);
					rect(i, j, stepping_x, floor_stepping);
				}
				
				// store ray for later use (minimap FOV)
				latest_rays[i].x = floor(px);
				latest_rays[i].y = floor(py);
				
        break;
      }

			// show complete raycast FOV on minimap (pixels perfect but slow and should be computed outside to fix order issues)
      //fill(0, 255, 0, 64);
      //rect(int(px * minimap_scale_x + width - minimap_width_m1), int(py * minimap_scale_y), 1, 1);
			
      px += dx;
      py += dy;
			
			step += 1;
    }
  }
}

// physics logic
void keyPressCheck() {
  if (keyPressed) {
		int rot_i = int(player.rotation) * width;
		
		PVector ray_direction = raydir[width / 2 + rot_i];
		
		PVector velocity = new PVector(ray_direction.x, ray_direction.y);
		velocity.mult(player.vel_multiplier);
		
		int dir = 1;
		if (player.rotation > 90 || player.rotation < 180) {
			dir = -1;
		}
		
		PVector newPosition = new PVector(player.position.x, player.position.y);
		
    if (keyCode == UP) {
			newPosition.add(velocity);
		} else if (keyCode == DOWN) {
			newPosition.sub(velocity);
		}
		
		if (keyCode == LEFT) {
			newPosition.x -= cos(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
			newPosition.y -= sin(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
		} else if (keyCode == RIGHT) {
			newPosition.x += cos(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
			newPosition.y += sin(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
		}
		
		if (newPosition.x < board_width - 1 && newPosition.y < board_height - 1 &&
				newPosition.x > 0 && newPosition.y > 0) {
			player.position = newPosition;
		}
	}
}

void keyReleased() {
	if (keyCode == ENTER || keyCode == RETURN) {
		edit_mode += 1;
		edit_mode %= 2;
	}
}

// update minimap buffer (so we don't compute the minimap rendering it at every frames)
void updateMinimap() {
	pg_minimap.beginDraw();
	pg_minimap.noStroke();
	pg_minimap.fill(255);
  for (int i = 0; i < board_size; i += int(board_width / minimap_width)) {
    //float w = boards[i];
		float w = brightness(pg_map.pixels[i]);
   
    if (w > 0.5) {
			int x = i % board_width;
			int y = int((float)i / board_width);

			x = int((float)x * minimap_scale_x);
			y = int((float)y * minimap_scale_y);
     
      pg_minimap.rect(x, y, 1, 1);
    }
  }
	pg_minimap.endDraw();
}

void render_minimap() {
	int minimap_offset_x = width - minimap_width_m1;

	image(pg_minimap, minimap_offset_x, 0);
	
	// player FOV on the minimap from all the latest rays casted (fast but not pixel perfect)
	stroke(255, 0, 0);
	for (int i = 0; i < width; i += minimap_fov_step) {
		PVector ray = latest_rays[i];
		line(player.position.x * minimap_scale_x + minimap_offset_x,
				 player.position.y * minimap_scale_y,
				 ray.x * minimap_scale_x + minimap_offset_x,
				 ray.y * minimap_scale_y);
	}
	noStroke();
	
	// player position
	fill(255, 255, 0);
	ellipse(player.position.x * minimap_scale_x + minimap_offset_x,
			 player.position.y * minimap_scale_y, 6, 6);
}"
"606206","2D volume raycasting","mySketch","/**
  * Custom raycaster done for fun on a phone (APDE Android app.) while commuting.
	* Improved afterward on desktop because APDE is buggy and crashed as the sketch complexity increased ! :)
	*
	* This use Wolfenstein 3D textures.
	*
	* This is actually a 2D volume raycaster as map objects are as-is (not blocky) thus it allow curved walls and any wall shapes actually for free...
	* It is however a bit slower than a blocky raycaster and will take way more memory.
	* The rays are also not going from grid cell to grid cell but as a steady user-defined step (enhance why it is more like a volume raycaster),
	* one could extend this to cast rays in a more free ways (in all direction: 3D) and this would basically become a volume raycaster so voxels yeh! :)
	*
	* A blocky raycaster (a la Wolfenstein 3D) isn't really far from this, the ray step would need to be fixed to the 2D grid and the grid objects would just need to have a defined size.
	*
	* The walls are mirrored on the y axis so we get a cheap floor mirror :p
	*/

static int display_width = 640;
static int display_height = 480;

static int board_width = 256;
static int board_height = board_width; // linked
static int board_size = board_width * board_height;

// typically the diagonal of the map so we stop any rays casted outside...
// but this can also be used for performances, this is the camera z clipping so with fog and this we can speed the rendering up :)
static int max_ray_step = board_width * 2;

static int wall_height = 32;

static int player_fov = 60;

static int minimap_width = 128;
static int minimap_height = minimap_width; // linked
static int minimap_width_m1 = minimap_width - 1;
static int minimap_fov_step = 88;
static float minimap_scale_x = (float)minimap_width / board_width;
static float minimap_scale_y = (float)minimap_height / board_height;

// increase for more performances
static int stepping_x = 8;
static int floor_stepping = 8;
static int ceil_stepping = 8;
static int texture_stepping = 2;

int edit_mode = 0;

float boards[];
// we use this actually instead of ""boards"" to store the map data
// this allow to draw our map directly with Processing shapes since we are not restricted to perpendicular walls :)
PGraphics pg_map;

PVector raydir[];
PVector latest_rays[];

PImage textures;

PGraphics pg_minimap;

// an entity class which hold player data and other entities
class Entity {
  PVector position;
  float rotation;
  float fov;
	float dst_proj_plane;
	float vel_multiplier = 2;
  float height = 50;
 
  Entity(PVector position, float rotation, float fov) {
    this.position = position;
    this.rotation = rotation;
    this.fov = fov;
		this.dst_proj_plane = 160 / tan(radians(fov / 2));
  }
};

Entity player = new Entity(
    new PVector(board_width / 2,
                board_height / 2), 90, player_fov);

void setup() {
  size(display_width, display_height);
  frameRate(60);
  colorMode(RGB,255,255,255,100);
 
	// initialize the map
	// since this is a volume raycaster we can do fun walls so we use curves, ellipse and more :)
	pg_map = createGraphics(board_width, board_height);
	pg_map.beginDraw();
	pg_map.noFill();
	pg_map.stroke(255);
	pg_map.rect(0, 0, board_width - 1, board_height - 1);
	pg_map.bezier(85, 20, 10, 10, 90, 90, 15, 80);
	pg_map.bezier(85 * 2, 20 * 2, 10 * 2, 10 * 2, 90 * 2, 90 * 2, 15 * 2, 80 * 2);
	pg_map.ellipse(board_width / 1.25, board_height / 1.25, 16, 16);
	pg_map.triangle(192, 200, 100, 210, 95, 240);
	pg_map.endDraw();
	pg_map.loadPixels();
	
/* // classical array
	boards = new float[board_size];

  for (int i = 0; i < board_width; i += 1) {
    boards[i] = 1;
    boards[i + board_width * (board_height - 1)] = 1;
  }
 
  for (int i = 0; i < board_height; i += 1) {
    boards[i * board_width] = 1;
    boards[(board_width - 1) + i * board_width] = 1;
  }
	
	for (int i = 0; i < 360; i += 1) {
		boards[(int)(board_width / 4 + 4 * cos(radians(i))) + (int)(board_height / 4 + 4 * sin(radians(i))) * board_width] = 1;
		boards[(int)(board_width / 4 + 4 * cos(radians(i))) + (int)(board_height - board_height / 4 + 4 * sin(radians(i))) * board_width] = 1;
		boards[(int)(board_width - board_width / 4 + 4 * cos(radians(i))) + (int)(board_height / 4 + 4 * sin(radians(i))) * board_width] = 1;
		boards[(int)(board_width - board_width / 4 + 4 * cos(radians(i))) + (int)(board_height - board_height / 4 + 4 * sin(radians(i))) * board_width] = 1;
	}
*/
	
	// pre-calculate all ray directions for the player FOV
	raydir = new PVector[width * 360];
	
	for (int i = 0; i < (width * 360); i += 1) {
		int rotation_degree = int((float)i / width);

		float ri = i % width;
		float norm_i = ri / width;
		
		raydir[i] = new PVector(
									cos(radians(rotation_degree) - radians(player.fov / 2) + radians(player.fov) * norm_i),
		            	sin(radians(rotation_degree) - radians(player.fov / 2) + radians(player.fov) * norm_i));
	}
	
	// latest rays are stored here (used to display the player FOV in the minimap)
	latest_rays = new PVector[width];
	for (int i = 0; i < width; i += 1) {
		latest_rays[i] = new PVector(0, 0);
	}
	
	textures = loadImage(""wolftextures.png"");
	textures.loadPixels();
	
	pg_minimap = createGraphics(minimap_width, minimap_height);
	
	updateMinimap();
	
}

void draw() {
  background(0);
 
  noStroke();
 
  raycast();
	
	if (edit_mode) {
		
	} else {
  	render_minimap();
	}
 
  player.rotation = ((float)mouseX / width * 2 * 359) % 360;
	
	keyPressCheck();
}

// core algorithm
void raycast() {
  int i = 0, j = 0;
	
	int rot_i = int(player.rotation) * width;
	
	// scan the screen horizontally and raycast from the defined player FOV
  for (i = 0; i < width; i += stepping_x) {
    float norm_i = (float)i / width;
		
		// we use pre-computed ray directions (see below for the raw formula)
		PVector ray_direction = raydir[i + rot_i];
   
    float dx = ray_direction.x;
		//float dx = cos(radians(player.rotation) - radians(player.fov / 2) + radians(player.fov) * norm_i);
    float dy = ray_direction.y;
		//float dy = sin(radians(player.rotation) - radians(player.fov / 2) + radians(player.fov) * norm_i);
		
    float px = player.position.x;
    float py = player.position.y;
		
		int step = 0;
		
		// traverse the map & check for collisions
    while (step < max_ray_step) {
      //float result = boards[(int)px + (int)py * board_width];
			float result = brightness(pg_map.pixels[(int)px + (int)py * board_width]);
     
      if (result > 0) {					
				// compute distance with corrected perspective
				// if the perspective is not corrected this will produce fish-eye / distorded walls effect because rays on the edge of the screen need to travel 'further' than the middle rays one 
				float ddx = abs(player.position.x - px);
				float ddy = abs(player.position.y - py);
				
        float dist = sqrt(ddx * ddx + ddy * ddy) * (cos(-radians(player.fov / 2) + radians(player.fov) * norm_i));
        float norm_dist = dist / max(board_width, board_height) / 1.25;
				float inorm_dist = max(1 - norm_dist, 0.01);
				
				// determine horizontal texture coordinate (note : not really correct!!)
				float tu = px + py;

				// determine wall height from the computed distance
				// dst_proj_plane is just a value related to the FOV, it relate to the player / projection plane distance
        float wh = wall_height / dist * player.dst_proj_plane;
				// now determine the vertical wall start position
        float wall_start_y = height / 2 - wh / 2 + player.height;
				
				// draw wall (untextured)
				/*
				fill(inorm_dist * 255, 0, 0, 255);
        rect(i, wall_start_y, stepping_x, wh);
				*/
				
				// simple ceiling
				/*int ceil_start = height / 2;
				for (j = ceil_start; j > -ceil_stepping; j -= ceil_stepping) {
					float inorm_j = (float)j / (height / 2);
					float norm_j = 1. - inorm_j;
					float ceil_brightness = 255 * (inorm_j);

					fill(0, 0, ceil_brightness, 64);
					rect(i, j, stepping_x, ceil_stepping);
				}*/
				
				// can change texture here (64, 128, 192 etc)
				int u = (int(tu) % (textures.width / 8) + 64);
				
	      // draw wall (textured)
				for (j = wall_start_y; j < wall_start_y + wh; j += texture_stepping) {
					float norm_j = (float)(j - wall_start_y) / wh;
					color c = textures.pixels[u + (int(norm_j * textures.height) % textures.height) * textures.width];
					fill(red(c) * inorm_dist, green(c) * inorm_dist, blue(c) * inorm_dist);
        	rect(i, j, stepping_x, texture_stepping);
					
					float cm = norm_dist * norm_j * 2;
					
					// mirrored :)
					fill(red(c) * cm, green(c) * cm, blue(c) * cm);
					rect(i, (wall_start_y + wh) * 2 - j, stepping_x, texture_stepping);
				}
				
				// draw ceiling
				/*int ceil_start = wall_start_y - ceil_stepping;
				for (j = ceil_start; j > -ceil_stepping; j -= ceil_stepping) {
					float inorm_j = (float)j / wall_start_y;
					float norm_j = 1. - inorm_j;
					float ceil_brightness = 255 * (inorm_j * inorm_dist * 2);

					fill(0, 0, ceil_brightness, 64);
					rect(i, j, stepping_x, ceil_stepping);
				}*/
				
				// draw floor
				int floor_start = wh + wall_start_y;
				for (j = floor_start; j < height; j += floor_stepping) {
					float norm_j = (float)(j - floor_start) / (height - floor_start);
					float inorm_j = 1. - norm_j;
					float floor_brightness = 255 * norm_j;
					
					fill(floor_brightness, 0, 0, 64);
					rect(i, j, stepping_x, floor_stepping);
				}
				
				// store ray for later use (minimap FOV)
				latest_rays[i].x = floor(px);
				latest_rays[i].y = floor(py);
				
        break;
      }

			// show complete raycast FOV on minimap (pixels perfect but slow and should be computed outside to fix order issues)
      //fill(0, 255, 0, 64);
      //rect(int(px * minimap_scale_x + width - minimap_width_m1), int(py * minimap_scale_y), 1, 1);
			
      px += dx;
      py += dy;
			
			step += 1;
    }
  }
}

// physics logic
void keyPressCheck() {
  if (keyPressed) {
		int rot_i = int(player.rotation) * width;
		
		PVector ray_direction = raydir[width / 2 + rot_i];
		
		PVector velocity = new PVector(ray_direction.x, ray_direction.y);
		velocity.mult(player.vel_multiplier);
		
		int dir = 1;
		if (player.rotation > 90 || player.rotation < 180) {
			dir = -1;
		}
		
		PVector newPosition = new PVector(player.position.x, player.position.y);
		
    if (keyCode == UP) {
			newPosition.add(velocity);
		} else if (keyCode == DOWN) {
			newPosition.sub(velocity);
		}
		
		if (keyCode == LEFT) {
			newPosition.x -= cos(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
			newPosition.y -= sin(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
		} else if (keyCode == RIGHT) {
			newPosition.x += cos(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
			newPosition.y += sin(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
		}
		
		if (newPosition.x < board_width - 1 && newPosition.y < board_height - 1 &&
				newPosition.x > 0 && newPosition.y > 0) {
			player.position = newPosition;
		}
	}
}

void keyReleased() {
	if (keyCode == ENTER || keyCode == RETURN) {
		edit_mode += 1;
		edit_mode %= 2;
	}
}

// update minimap buffer (so we don't compute the minimap rendering it at every frames)
void updateMinimap() {
	pg_minimap.beginDraw();
	pg_minimap.noStroke();
	pg_minimap.fill(255);
  for (int i = 0; i < board_size; i += int(board_width / minimap_width)) {
    //float w = boards[i];
		float w = brightness(pg_map.pixels[i]);
   
    if (w > 0.5) {
			int x = i % board_width;
			int y = int((float)i / board_width);

			x = int((float)x * minimap_scale_x);
			y = int((float)y * minimap_scale_y);
     
      pg_minimap.rect(x, y, 1, 1);
    }
  }
	pg_minimap.endDraw();
}

void render_minimap() {
	int minimap_offset_x = width - minimap_width_m1;

	image(pg_minimap, minimap_offset_x, 0);
	
	// player FOV on the minimap from all the latest rays casted (fast but not pixel perfect)
	stroke(255, 0, 0);
	for (int i = 0; i < width; i += minimap_fov_step) {
		PVector ray = latest_rays[i];
		line(player.position.x * minimap_scale_x + minimap_offset_x,
				 player.position.y * minimap_scale_y,
				 ray.x * minimap_scale_x + minimap_offset_x,
				 ray.y * minimap_scale_y);
	}
	noStroke();
	
	// player position
	fill(255, 255, 0);
	ellipse(player.position.x * minimap_scale_x + minimap_offset_x,
			 player.position.y * minimap_scale_y, 6, 6);
}"
"606206","2D volume raycasting","mySketch","/**
  * Custom raycaster done for fun on a phone (APDE Android app.) while commuting.
	* Improved afterward on desktop because APDE is buggy and crashed as the sketch complexity increased ! :)
	*
	* This use Wolfenstein 3D textures.
	*
	* This is actually a 2D volume raycaster as map objects are as-is (not blocky) thus it allow curved walls and any wall shapes actually for free...
	* It is however a bit slower than a blocky raycaster and will take way more memory.
	* The rays are also not going from grid cell to grid cell but as a steady user-defined step (enhance why it is more like a volume raycaster),
	* one could extend this to cast rays in a more free ways (in all direction: 3D) and this would basically become a volume raycaster so voxels yeh! :)
	*
	* A blocky raycaster (a la Wolfenstein 3D) isn't really far from this, the ray step would need to be fixed to the 2D grid and the grid objects would just need to have a defined size.
	*
	* The walls are mirrored on the y axis so we get a cheap floor mirror :p
	*/

static int display_width = 640;
static int display_height = 480;

static int board_width = 256;
static int board_height = board_width; // linked
static int board_size = board_width * board_height;

// typically the diagonal of the map so we stop any rays casted outside...
// but this can also be used for performances, this is the camera z clipping so with fog and this we can speed the rendering up :)
static int max_ray_step = board_width * 2;

static int wall_height = 32;

static int player_fov = 60;

static int minimap_width = 128;
static int minimap_height = minimap_width; // linked
static int minimap_width_m1 = minimap_width - 1;
static int minimap_fov_step = 88;
static float minimap_scale_x = (float)minimap_width / board_width;
static float minimap_scale_y = (float)minimap_height / board_height;

// increase for more performances
static int stepping_x = 8;
static int floor_stepping = 8;
static int ceil_stepping = 8;
static int texture_stepping = 2;

int edit_mode = 0;

float boards[];
// we use this actually instead of ""boards"" to store the map data
// this allow to draw our map directly with Processing shapes since we are not restricted to perpendicular walls :)
PGraphics pg_map;

PVector raydir[];
PVector latest_rays[];

PImage textures;

PGraphics pg_minimap;

// an entity class which hold player data and other entities
class Entity {
  PVector position;
  float rotation;
  float fov;
	float dst_proj_plane;
	float vel_multiplier = 2;
  float height = 50;
 
  Entity(PVector position, float rotation, float fov) {
    this.position = position;
    this.rotation = rotation;
    this.fov = fov;
		this.dst_proj_plane = 160 / tan(radians(fov / 2));
  }
};

Entity player = new Entity(
    new PVector(board_width / 2,
                board_height / 2), 90, player_fov);

void setup() {
  size(display_width, display_height);
  frameRate(60);
  colorMode(RGB,255,255,255,100);
 
	// initialize the map
	// since this is a volume raycaster we can do fun walls so we use curves, ellipse and more :)
	pg_map = createGraphics(board_width, board_height);
	pg_map.beginDraw();
	pg_map.noFill();
	pg_map.stroke(255);
	pg_map.rect(0, 0, board_width - 1, board_height - 1);
	pg_map.bezier(85, 20, 10, 10, 90, 90, 15, 80);
	pg_map.bezier(85 * 2, 20 * 2, 10 * 2, 10 * 2, 90 * 2, 90 * 2, 15 * 2, 80 * 2);
	pg_map.ellipse(board_width / 1.25, board_height / 1.25, 16, 16);
	pg_map.triangle(192, 200, 100, 210, 95, 240);
	pg_map.endDraw();
	pg_map.loadPixels();
	
/* // classical array
	boards = new float[board_size];

  for (int i = 0; i < board_width; i += 1) {
    boards[i] = 1;
    boards[i + board_width * (board_height - 1)] = 1;
  }
 
  for (int i = 0; i < board_height; i += 1) {
    boards[i * board_width] = 1;
    boards[(board_width - 1) + i * board_width] = 1;
  }
	
	for (int i = 0; i < 360; i += 1) {
		boards[(int)(board_width / 4 + 4 * cos(radians(i))) + (int)(board_height / 4 + 4 * sin(radians(i))) * board_width] = 1;
		boards[(int)(board_width / 4 + 4 * cos(radians(i))) + (int)(board_height - board_height / 4 + 4 * sin(radians(i))) * board_width] = 1;
		boards[(int)(board_width - board_width / 4 + 4 * cos(radians(i))) + (int)(board_height / 4 + 4 * sin(radians(i))) * board_width] = 1;
		boards[(int)(board_width - board_width / 4 + 4 * cos(radians(i))) + (int)(board_height - board_height / 4 + 4 * sin(radians(i))) * board_width] = 1;
	}
*/
	
	// pre-calculate all ray directions for the player FOV
	raydir = new PVector[width * 360];
	
	for (int i = 0; i < (width * 360); i += 1) {
		int rotation_degree = int((float)i / width);

		float ri = i % width;
		float norm_i = ri / width;
		
		raydir[i] = new PVector(
									cos(radians(rotation_degree) - radians(player.fov / 2) + radians(player.fov) * norm_i),
		            	sin(radians(rotation_degree) - radians(player.fov / 2) + radians(player.fov) * norm_i));
	}
	
	// latest rays are stored here (used to display the player FOV in the minimap)
	latest_rays = new PVector[width];
	for (int i = 0; i < width; i += 1) {
		latest_rays[i] = new PVector(0, 0);
	}
	
	textures = loadImage(""wolftextures.png"");
	textures.loadPixels();
	
	pg_minimap = createGraphics(minimap_width, minimap_height);
	
	updateMinimap();
	
}

void draw() {
  background(0);
 
  noStroke();
 
  raycast();
	
	if (edit_mode) {
		
	} else {
  	render_minimap();
	}
 
  player.rotation = ((float)mouseX / width * 2 * 359) % 360;
	
	keyPressCheck();
}

// core algorithm
void raycast() {
  int i = 0, j = 0;
	
	int rot_i = int(player.rotation) * width;
	
	// scan the screen horizontally and raycast from the defined player FOV
  for (i = 0; i < width; i += stepping_x) {
    float norm_i = (float)i / width;
		
		// we use pre-computed ray directions (see below for the raw formula)
		PVector ray_direction = raydir[i + rot_i];
   
    float dx = ray_direction.x;
		//float dx = cos(radians(player.rotation) - radians(player.fov / 2) + radians(player.fov) * norm_i);
    float dy = ray_direction.y;
		//float dy = sin(radians(player.rotation) - radians(player.fov / 2) + radians(player.fov) * norm_i);
		
    float px = player.position.x;
    float py = player.position.y;
		
		int step = 0;
		
		// traverse the map & check for collisions
    while (step < max_ray_step) {
      //float result = boards[(int)px + (int)py * board_width];
			float result = brightness(pg_map.pixels[(int)px + (int)py * board_width]);
     
      if (result > 0) {					
				// compute distance with corrected perspective
				// if the perspective is not corrected this will produce fish-eye / distorded walls effect because rays on the edge of the screen need to travel 'further' than the middle rays one 
				float ddx = abs(player.position.x - px);
				float ddy = abs(player.position.y - py);
				
        float dist = sqrt(ddx * ddx + ddy * ddy) * (cos(-radians(player.fov / 2) + radians(player.fov) * norm_i));
        float norm_dist = dist / max(board_width, board_height) / 1.25;
				float inorm_dist = max(1 - norm_dist, 0.01);
				
				// determine horizontal texture coordinate (note : not really correct!!)
				float tu = abs(px - py);

				// determine wall height from the computed distance
				// dst_proj_plane is just a value related to the FOV, it relate to the player / projection plane distance
        float wh = wall_height / dist * player.dst_proj_plane;
				// now determine the vertical wall start position
        float wall_start_y = height / 2 - wh / 2 + player.height;
				
				// draw wall (untextured)
				/*
				fill(inorm_dist * 255, 0, 0, 255);
        rect(i, wall_start_y, stepping_x, wh);
				*/
				
				// simple ceiling
				/*int ceil_start = height / 2;
				for (j = ceil_start; j > -ceil_stepping; j -= ceil_stepping) {
					float inorm_j = (float)j / (height / 2);
					float norm_j = 1. - inorm_j;
					float ceil_brightness = 255 * (inorm_j);

					fill(0, 0, ceil_brightness, 64);
					rect(i, j, stepping_x, ceil_stepping);
				}*/
				
				// can change texture here (64, 128, 192 etc)
				int u = (int(tu) % (textures.width / 8) + 64);
				
	      // draw wall (textured)
				for (j = wall_start_y; j < wall_start_y + wh; j += texture_stepping) {
					float norm_j = (float)(j - wall_start_y) / wh;
					color c = textures.pixels[u + (int(norm_j * textures.height) % textures.height) * textures.width];
					fill(red(c) * inorm_dist, green(c) * inorm_dist, blue(c) * inorm_dist);
        	rect(i, j, stepping_x, texture_stepping);
					
					float cm = norm_dist * norm_j * 2;
					
					// mirrored :)
					fill(red(c) * cm, green(c) * cm, blue(c) * cm);
					rect(i, (wall_start_y + wh) * 2 - j, stepping_x, texture_stepping);
				}
				
				// draw ceiling
				/*int ceil_start = wall_start_y - ceil_stepping;
				for (j = ceil_start; j > -ceil_stepping; j -= ceil_stepping) {
					float inorm_j = (float)j / wall_start_y;
					float norm_j = 1. - inorm_j;
					float ceil_brightness = 255 * (inorm_j * inorm_dist * 2);

					fill(0, 0, ceil_brightness, 64);
					rect(i, j, stepping_x, ceil_stepping);
				}*/
				
				// draw floor
				int floor_start = wh + wall_start_y;
				for (j = floor_start; j < height; j += floor_stepping) {
					float norm_j = (float)(j - floor_start) / (height - floor_start);
					float inorm_j = 1. - norm_j;
					float floor_brightness = 255 * norm_j;
					
					fill(floor_brightness, 0, 0, 64);
					rect(i, j, stepping_x, floor_stepping);
				}
				
				// store ray for later use (minimap FOV)
				latest_rays[i].x = floor(px);
				latest_rays[i].y = floor(py);
				
        break;
      }

			// show complete raycast FOV on minimap (pixels perfect but slow and should be computed outside to fix order issues)
      //fill(0, 255, 0, 64);
      //rect(int(px * minimap_scale_x + width - minimap_width_m1), int(py * minimap_scale_y), 1, 1);
			
      px += dx;
      py += dy;
			
			step += 1;
    }
  }
}

// physics logic
void keyPressCheck() {
  if (keyPressed) {
		int rot_i = int(player.rotation) * width;
		
		PVector ray_direction = raydir[width / 2 + rot_i];
		
		PVector velocity = new PVector(ray_direction.x, ray_direction.y);
		velocity.mult(player.vel_multiplier);
		
		int dir = 1;
		if (player.rotation > 90 || player.rotation < 180) {
			dir = -1;
		}
		
		PVector newPosition = new PVector(player.position.x, player.position.y);
		
    if (keyCode == UP) {
			newPosition.add(velocity);
		} else if (keyCode == DOWN) {
			newPosition.sub(velocity);
		}
		
		if (keyCode == LEFT) {
			newPosition.x -= cos(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
			newPosition.y -= sin(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
		} else if (keyCode == RIGHT) {
			newPosition.x += cos(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
			newPosition.y += sin(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
		}
		
		if (newPosition.x < board_width - 1 && newPosition.y < board_height - 1 &&
				newPosition.x > 0 && newPosition.y > 0) {
			player.position = newPosition;
		}
	}
}

void keyReleased() {
	if (keyCode == ENTER || keyCode == RETURN) {
		edit_mode += 1;
		edit_mode %= 2;
	}
}

// update minimap buffer (so we don't compute the minimap rendering it at every frames)
void updateMinimap() {
	pg_minimap.beginDraw();
	pg_minimap.noStroke();
	pg_minimap.fill(255);
  for (int i = 0; i < board_size; i += int(board_width / minimap_width)) {
    //float w = boards[i];
		float w = brightness(pg_map.pixels[i]);
   
    if (w > 0.5) {
			int x = i % board_width;
			int y = int((float)i / board_width);

			x = int((float)x * minimap_scale_x);
			y = int((float)y * minimap_scale_y);
     
      pg_minimap.rect(x, y, 1, 1);
    }
  }
	pg_minimap.endDraw();
}

void render_minimap() {
	int minimap_offset_x = width - minimap_width_m1;

	image(pg_minimap, minimap_offset_x, 0);
	
	// player FOV on the minimap from all the latest rays casted (fast but not pixel perfect)
	stroke(255, 0, 0);
	for (int i = 0; i < width; i += minimap_fov_step) {
		PVector ray = latest_rays[i];
		line(player.position.x * minimap_scale_x + minimap_offset_x,
				 player.position.y * minimap_scale_y,
				 ray.x * minimap_scale_x + minimap_offset_x,
				 ray.y * minimap_scale_y);
	}
	noStroke();
	
	// player position
	fill(255, 255, 0);
	ellipse(player.position.x * minimap_scale_x + minimap_offset_x,
			 player.position.y * minimap_scale_y, 6, 6);
}"
"606206","2D volume raycasting","mySketch","/**
  * Custom raycaster done for fun on a phone (APDE Android app.) while commuting.
	* Improved afterward on desktop because APDE is buggy and crashed as the sketch complexity increased ! :)
	*
	* This use Wolfenstein 3D textures.
	*
	* This is actually a 2D volume raycaster as map objects are as-is (not blocky) thus it allow curved walls and any wall shapes actually for free...
	* It is however a bit slower than a blocky raycaster, will take way more memory and the texturing is kinda buggy on some kind of walls.
	* There is two methods implemented for raycast :
	*   A naive not optimal one which walk the grid in the view direction through fixed step
	*   An optimal one which walk the grid in the view direction through each cells
	*
	* One could extend this to cast rays in a more free ways (in all direction: 3D) and this would basically become a volume raycaster so voxels yeh! :)
	*
	* A blocky raycaster (a la Wolfenstein 3D) isn't really far from this, the grid objects would just need to have a defined size.
	*
	* The walls are mirrored on the y axis so we get a cheap floor mirror :p
	*/

static int display_width = 640;
static int display_height = 480;

static int board_width = 256;
static int board_height = board_width; // linked
static int board_size = board_width * board_height;

// typically the diagonal of the map so we stop any rays casted outside...
// but this can also be used for performances, this is the camera z clipping so with fog and this we can speed the rendering up :)
static int max_ray_step = board_width * 2;

static int wall_height = 32;

static int player_fov = 60;

static int minimap_width = 128;
static int minimap_height = minimap_width; // linked
static int minimap_width_m1 = minimap_width - 1;
static int minimap_fov_step = 88;
static float minimap_scale_x = (float)minimap_width / board_width;
static float minimap_scale_y = (float)minimap_height / board_height;

// increase for more performances
static int stepping_x = 8;
static int floor_stepping = 8;
static int ceil_stepping = 8;
static int texture_stepping = 2;

int edit_mode = 0;

float boards[];
// we use this actually instead of ""boards"" to store the map data
// this allow to draw our map directly with Processing shapes since we are not restricted to perpendicular walls :)
PGraphics pg_map;

PVector raydir[];
PVector latest_rays[];

PImage textures;

PGraphics pg_minimap;

// an entity class which hold player data and other entities
class Entity {
  PVector position;
  float rotation;
  float fov;
	float dst_proj_plane;
	float vel_multiplier = 2;
  float height = 50;
 
  Entity(PVector position, float rotation, float fov) {
    this.position = position;
    this.rotation = rotation;
    this.fov = fov;
		this.dst_proj_plane = 160 / tan(radians(fov / 2));
  }
};

Entity player = new Entity(
    new PVector(board_width / 2,
                board_height / 2), 90, player_fov);

void setup() {
  size(display_width, display_height);
  frameRate(60);
  colorMode(RGB,255,255,255,100);
 
	// initialize the map
	// since this is a volume raycaster we can do fun walls so we use curves, ellipse and more :)
	pg_map = createGraphics(board_width, board_height);
	pg_map.beginDraw();
	pg_map.noFill();
	pg_map.stroke(255);
	pg_map.rect(0, 0, board_width - 1, board_height - 1);
	pg_map.bezier(85, 20, 10, 10, 90, 90, 15, 80);
	pg_map.bezier(85 * 2, 20 * 2, 10 * 2, 10 * 2, 90 * 2, 90 * 2, 15 * 2, 80 * 2);
	pg_map.ellipse(board_width / 1.25, board_height / 1.25, 16, 16);
	pg_map.triangle(192, 200, 100, 210, 95, 240);
	pg_map.endDraw();
	pg_map.loadPixels();
	
/* // classical array
	boards = new float[board_size];

  for (int i = 0; i < board_width; i += 1) {
    boards[i] = 1;
    boards[i + board_width * (board_height - 1)] = 1;
  }
 
  for (int i = 0; i < board_height; i += 1) {
    boards[i * board_width] = 1;
    boards[(board_width - 1) + i * board_width] = 1;
  }
	
	for (int i = 0; i < 360; i += 1) {
		boards[(int)(board_width / 4 + 4 * cos(radians(i))) + (int)(board_height / 4 + 4 * sin(radians(i))) * board_width] = 1;
		boards[(int)(board_width / 4 + 4 * cos(radians(i))) + (int)(board_height - board_height / 4 + 4 * sin(radians(i))) * board_width] = 1;
		boards[(int)(board_width - board_width / 4 + 4 * cos(radians(i))) + (int)(board_height / 4 + 4 * sin(radians(i))) * board_width] = 1;
		boards[(int)(board_width - board_width / 4 + 4 * cos(radians(i))) + (int)(board_height - board_height / 4 + 4 * sin(radians(i))) * board_width] = 1;
	}
*/
	
	// pre-calculate all ray directions for the player FOV
	raydir = new PVector[width * 360];
	
	for (int i = 0; i < (width * 360); i += 1) {
		int rotation_degree = int((float)i / width);

		float ri = i % width;
		float norm_i = ri / width;
		
		raydir[i] = new PVector(
									cos(radians(rotation_degree) - radians(player.fov / 2) + radians(player.fov) * norm_i),
		            	sin(radians(rotation_degree) - radians(player.fov / 2) + radians(player.fov) * norm_i));
	}
	
	// latest rays are stored here (used to display the player FOV in the minimap)
	latest_rays = new PVector[width];
	for (int i = 0; i < width; i += 1) {
		latest_rays[i] = new PVector(0, 0);
	}
	
	textures = loadImage(""wolftextures.png"");
	textures.loadPixels();
	
	pg_minimap = createGraphics(minimap_width, minimap_height);
	
	updateMinimap();
	
}

void draw() {
  background(0);
 
  noStroke();
 
  raycast();
	
	if (edit_mode) {
		
	} else {
  	render_minimap();
	}
 
  player.rotation = ((float)mouseX / width * 2 * 359) % 360;
	
	keyPressCheck();
}

// core algorithm
void raycast() {
  int i = 0, j = 0;
	
	int rot_i = int(player.rotation) * width;
	
	// scan the screen horizontally and raycast from the defined player FOV
  for (i = 0; i < width; i += stepping_x) {
    float norm_i = (float)i / width;
		
		// we use pre-computed ray directions (see below for the raw formula)
		PVector ray_direction = raydir[i + rot_i];
   
    float dx = ray_direction.x;
		//float dx = cos(radians(player.rotation) - radians(player.fov / 2) + radians(player.fov) * norm_i);
    float dy = ray_direction.y;
		//float dy = sin(radians(player.rotation) - radians(player.fov / 2) + radians(player.fov) * norm_i);
		
    float px = player.position.x;
    float py = player.position.y;
		
		// ""A Fast Voxel Traversal Algorithm for Ray Tracing"" paper by John Amanatides and Andrew Woo
		// basically a rather obvious way to cross each cells at each steps!
		int mx = floor(px);
		int my = floor(py);
		
		float step_x = (ray_direction.x >= 0) ? 1 : -1; 
		float step_y = (ray_direction.y >= 0) ? 1 : -1; 
		
		float tmax_x = (float)((mx + step_x) - px) / dx;
		float tmax_y = (float)((my + step_y) - py) / dy;
		
		float delta_x = step_x / dx;
		float delta_y = step_y / dy;
		//
		
		int step = 0;
		
		// traverse the map & check for collisions
    while (step < max_ray_step) {
      //float result = boards[mx + my * board_width];
			float result = brightness(pg_map.pixels[mx + my * board_width]);
     
      if (result > 0) {					
				// compute distance with corrected perspective
				// if the perspective is not corrected this will produce fish-eye / distorded walls effect because rays on the edge of the screen need to travel 'further' than the middle rays one 
				float ddx = abs(player.position.x - mx);
				float ddy = abs(player.position.y - my);
				
        float dist = sqrt(ddx * ddx + ddy * ddy) * (cos(-radians(player.fov / 2) + radians(player.fov) * norm_i));
        float norm_dist = dist / max(board_width, board_height) / 1.25;
				float inorm_dist = max(1 - norm_dist, 0.01);
				
				// determine horizontal texture coordinate (note : not really correct!!)
				float tu = abs(mx - my);

				// determine wall height from the computed distance
				// dst_proj_plane is just a value related to the FOV, it relate to the player / projection plane distance
        float wh = wall_height / dist * player.dst_proj_plane;
				// now determine the vertical wall start position
        float wall_start_y = height / 2 - wh / 2 + player.height;
				
				// draw wall (untextured)
				/*
				fill(inorm_dist * 255, 0, 0, 255);
        rect(i, wall_start_y, stepping_x, wh);
				*/
				
				// simple ceiling
				/*int ceil_start = height / 2;
				for (j = ceil_start; j > -ceil_stepping; j -= ceil_stepping) {
					float inorm_j = (float)j / (height / 2);
					float norm_j = 1. - inorm_j;
					float ceil_brightness = 255 * (inorm_j);

					fill(0, 0, ceil_brightness, 64);
					rect(i, j, stepping_x, ceil_stepping);
				}*/
				
				// can change texture here (64, 128, 192 etc)
				int u = (int(tu) % (textures.width / 8) + 64);
				
	      // draw wall (textured)
				for (j = wall_start_y; j < wall_start_y + wh; j += texture_stepping) {
					float norm_j = (float)(j - wall_start_y) / wh;
					color c = textures.pixels[u + (int(norm_j * textures.height) % textures.height) * textures.width];
					fill(red(c) * inorm_dist, green(c) * inorm_dist, blue(c) * inorm_dist);
        	rect(i, j, stepping_x, texture_stepping);
					
					float cm = norm_dist * norm_j * 2;
					
					// mirrored :)
					fill(red(c) * cm, green(c) * cm, blue(c) * cm);
					rect(i, (wall_start_y + wh) * 2 - j, stepping_x, texture_stepping);
				}
				
				// draw ceiling
				/*int ceil_start = wall_start_y - ceil_stepping;
				for (j = ceil_start; j > -ceil_stepping; j -= ceil_stepping) {
					float inorm_j = (float)j / wall_start_y;
					float norm_j = 1. - inorm_j;
					float ceil_brightness = 255 * (inorm_j * inorm_dist * 2);

					fill(0, 0, ceil_brightness, 64);
					rect(i, j, stepping_x, ceil_stepping);
				}*/
				
				// draw floor
				int floor_start = wh + wall_start_y;
				for (j = floor_start; j < height; j += floor_stepping) {
					float norm_j = (float)(j - floor_start) / (height - floor_start);
					float inorm_j = 1. - norm_j;
					float floor_brightness = 255 * norm_j;
					
					fill(floor_brightness, 0, 0, 64);
					rect(i, j, stepping_x, floor_stepping);
				}
				
				// store ray for later use (minimap FOV)
				latest_rays[i].x = mx;
				latest_rays[i].y = my;
				
        break;
      }

			// show complete raycast FOV on minimap (pixels perfect but slow and should be computed outside to fix order issues)
      //fill(0, 255, 0, 64);
      //rect(int(px * minimap_scale_x + width - minimap_width_m1), int(py * minimap_scale_y), 1, 1);
			
			/*
			// naive way to raycast : go along the direction as a fixed step (but it may take many steps to cross a single cell)
			// if you want to use this you must replace mx/my by px/py in that loop
      px += dx;
      py += dy;
			*/
			
			// ""A Fast Voxel Traversal Algorithm for Ray Tracing"" paper by John Amanatides and Andrew Woo
			// basically a rather obvious way to cross each cells at each steps!
			if (tmax_x < tmax_y) {
				tmax_x += delta_x;
				mx += step_x;
				side = 0;
			} else {
				tmax_y += delta_y;
				my += step_y;
				side = 1;
			}
			//
			
			step += 1;
    }
  }
}

// physics logic
void keyPressCheck() {
  if (keyPressed) {
		int rot_i = int(player.rotation) * width;
		
		PVector ray_direction = raydir[width / 2 + rot_i];
		
		PVector velocity = new PVector(ray_direction.x, ray_direction.y);
		velocity.mult(player.vel_multiplier);
		
		int dir = 1;
		if (player.rotation > 90 || player.rotation < 180) {
			dir = -1;
		}
		
		PVector newPosition = new PVector(player.position.x, player.position.y);
		
    if (keyCode == UP) {
			newPosition.add(velocity);
		} else if (keyCode == DOWN) {
			newPosition.sub(velocity);
		}
		
		if (keyCode == LEFT) {
			newPosition.x -= cos(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
			newPosition.y -= sin(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
		} else if (keyCode == RIGHT) {
			newPosition.x += cos(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
			newPosition.y += sin(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
		}
		
		if (newPosition.x < board_width - 1 && newPosition.y < board_height - 1 &&
				newPosition.x > 0 && newPosition.y > 0) {
			player.position = newPosition;
		}
	}
}

void keyReleased() {
	if (keyCode == ENTER || keyCode == RETURN) {
		edit_mode += 1;
		edit_mode %= 2;
	}
}

// update minimap buffer (so we don't compute the minimap rendering it at every frames)
void updateMinimap() {
	pg_minimap.beginDraw();
	pg_minimap.noStroke();
	pg_minimap.fill(255);
  for (int i = 0; i < board_size; i += int(board_width / minimap_width)) {
    //float w = boards[i];
		float w = brightness(pg_map.pixels[i]);
   
    if (w > 0.5) {
			int x = i % board_width;
			int y = int((float)i / board_width);

			x = int((float)x * minimap_scale_x);
			y = int((float)y * minimap_scale_y);
     
      pg_minimap.rect(x, y, 1, 1);
    }
  }
	pg_minimap.endDraw();
}

void render_minimap() {
	int minimap_offset_x = width - minimap_width_m1;

	image(pg_minimap, minimap_offset_x, 0);
	
	// player FOV on the minimap from all the latest rays casted (fast but not pixel perfect)
	stroke(255, 0, 0);
	for (int i = 0; i < width; i += minimap_fov_step) {
		PVector ray = latest_rays[i];
		line(player.position.x * minimap_scale_x + minimap_offset_x,
				 player.position.y * minimap_scale_y,
				 ray.x * minimap_scale_x + minimap_offset_x,
				 ray.y * minimap_scale_y);
	}
	noStroke();
	
	// player position
	fill(255, 255, 0);
	ellipse(player.position.x * minimap_scale_x + minimap_offset_x,
			 player.position.y * minimap_scale_y, 6, 6);
}"
"606206","2D volume raycasting","mySketch","static int board_width = 256;
static int board_height = board_width; // linked
static int board_size = board_width * board_height;

static int wall_height = 244;

static int minimap_width = 64;
static int minimap_height = minimap_width; // linked
static int minimap_width_m1 = minimap_width - 1;
static float minimap_scale_x = (float)minimap_width / board_width;
static float minimap_scale_y = (float)minimap_height / board_height;

static int stepping_x = 8;
static int floor_ceil_stepping = 8;

float boards[];
PVector raydir[];
PVector latest_rays[];

class Entity {
  PVector position;
  float rotation;
  float fov;
	float vel_multiplier = 8;
 
  Entity(PVector position, float rotation, float fov) {
    this.position = position;
    this.rotation = rotation;
    this.fov = fov;
  }
 
  float getX() {
    return position.x;
  }
 
  float getY() {
    return position.y;
  }
 
  int getTileX() {
    return round(position.x);
  }
 
  int getTileY() {
    return round(position.y);
  }
};

Entity player = new Entity(
    new PVector(board_width / 2,
                board_height / 2), 90, 60);

void setup() {
  size(800, 600);
  frameRate(60);
  colorMode(RGB,255,255,255,100);
 
	// initialize the map, enclose it with walls
  boards = new float[board_size];
	
  for (int i = 0; i < board_width; i += 1) {
    boards[i] = 1;
    boards[i + board_width * (board_height - 1)] = 1;
  }
 
  for (int i = 0; i < board_height; i += 1) {
    boards[i * board_width] = 1;
    boards[(board_width - 1) + i * board_width] = 1;
  }
	
	// pre-calculate all ray directions for the player FOV
	raydir = new PVector[width * 360];
	
	for (int i = 0; i < (width * 360); i += 1) {
		int rotation_degree = int((float)i / width);

		float ri = i % width;
		float norm_i = ri / width;
		
		raydir[i] = new PVector(
									cos(radians(rotation_degree) - radians(player.fov / 2) + radians(player.fov) * norm_i),
		            	sin(radians(rotation_degree) - radians(player.fov / 2) + radians(player.fov) * norm_i));
	}
	
	// latest rays are stored here
	latest_rays = new PVector[width];
	for (int i = 0; i < width; i += 1) {
		latest_rays[i] = new PVector(0, 0);
	}
}

void draw() {
  background(0);
 
  noStroke();
 
  raycast();
  minimap();
 
  player.rotation = (float)mouseX / width * 360;
	
	keyPressCheck();
}

// store start + end collision for the minimap
PVector ray_direction_start = new PVector();
PVector ray_direction_end = new PVector();

// core algorithm
void raycast() {
  int i = 0, j = 0;
	
	int rot_i = int(player.rotation) * width;

	// scan the screen horizontally and raycast from the defined FOV
  for (i = 0; i < width; i += stepping_x) {
    float norm_i = (float)i / width;
		
		PVector ray_direction = raydir[i + rot_i];
   
    float dx = ray_direction.x;
		//float dx = cos(radians(player.rotation) - radians(player.fov / 2) + radians(player.fov) * norm_i);
    float dy = ray_direction.y;
		//float dy = sin(radians(player.rotation) - radians(player.fov / 2) + radians(player.fov) * norm_i);
   
    float px = player.getX();
    float py = player.getY();
		
		// traverse the map & check collision
    while (px >= 0 && px < board_width && 
					 py >= 0 && py < board_height) {
      float result = boards[(int)px + (int)py * board_width];
     
      if (result > 0) {
				// manhattan distance (faster to compute but may need further investigation to fix precision issues)
				// (abs(player.getX() - px) + abs(player.getY() - py))
				float ddx = abs(player.getX() - px);
				float ddy = abs(player.getY() - py);
        float dist = sqrt(ddx * ddx + ddy * ddy) * cos(radians(player.fov) * norm_i); //* (cos(radians(player.fov) * norm_i));
        float norm_dist = 1. - dist / board_width;
				
				// determine wall Y position and its height from the computed distance
        float wh = norm_dist * wall_height;
        float wall_start_y = height / 2 - wh / 2;
       
        for (j = 0; j < wall_start_y; j += floor_ceil_stepping) {
          float norm_j = j / wall_start_y;
         
          fill((1. - norm_j) * 255, (1. - norm_j) * 255, (1. - norm_j) * 255, 32);
          rect(i, j, stepping_x, floor_ceil_stepping);
          fill(norm_j * 255, norm_j * 255, norm_j * 255, 32);
          rect(i, j + wh + wall_start_y, stepping_x, floor_ceil_stepping);
        }
				
        fill(norm_dist * 255, 0, 0, 255);
        rect(i, wall_start_y, stepping_x, wh);
				
				latest_rays[i].x = px;
				latest_rays[i].y = py;

        break;
      }
     
			// show complete raycast FOV on minimap
      //fill(0, 255, 0, 64);
      //rect(int(px * minimap_scale_x + width - minimap_width_m1), int(py * minimap_scale_y), 1, 1);
     
      px += dx;
      py += dy;
    }
  }
}

void keyPressCheck() {
  if (keyPressed) {
		int rot_i = int(player.rotation) * width;
		
		PVector ray_direction = raydir[width / 2 + rot_i];
		
		PVector velocity = new PVector(ray_direction.x, ray_direction.y);
		velocity.mult(player.vel_multiplier);
		
		int dir = 1;
		if (player.rotation > 180) {
			dir = -1;
		}
		
		PVector newPosition = new PVector(player.position.x, player.position.y);
		
    if (keyCode == UP) {
			newPosition.add(velocity);
		} else if (keyCode == DOWN) {
			newPosition.sub(velocity);
		} else if (keyCode == LEFT) {
			newPosition.x -= cos(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
			newPosition.y -= sin(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
		} else if (keyCode == RIGHT) {
			newPosition.x += cos(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
			newPosition.y += sin(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
		}
		
		if (newPosition.x < board_width - 1 && newPosition.y < board_height - 1 &&
				newPosition.x > 0 && newPosition.y > 0) {
			player.position = newPosition;
		}
	}
}

void minimap() {
	int minimap_offset_x = width - minimap_width_m1;
	
  for (int i = 0; i < board_size; i += int(board_width / minimap_width)) {
    float w = boards[i];
   
    if (w > 0.5) {
      fill(255, 255, 255, 192);
			
			int x = i % board_width;
			int y = int((float)i / board_width);

			x = int((float)x * minimap_scale_x);
			y = int((float)y * minimap_scale_y);
     
      rect(x + minimap_offset_x, y, 1, 1);
    }
  }
	
	// display the player FOV on the minimap
	stroke(255, 0, 0, 64);
	for (int i = 0; i < width; i += stepping_x) {
		PVector ray = latest_rays[i];
		line(player.getX() * minimap_scale_x + minimap_offset_x, player.getY() * minimap_scale_y, ray.x * minimap_scale_x + minimap_offset_x, ray.y * minimap_scale_y);
	}
	noStroke();
	
	// display player position
	fill(0, 255, 0);
	rect(player.getTileX() * minimap_scale_x + minimap_offset_x - 2,
			 player.getTileY() * minimap_scale_y - 2, 4, 4);
}"
"606206","2D volume raycasting","mySketch","static int board_width = 256;
static int board_height = board_width; // linked
static int board_size = board_width * board_height;

static int wall_height = 244;

static int minimap_width = 64;
static int minimap_height = minimap_width; // linked
static int minimap_width_m1 = minimap_width - 1;
static float minimap_scale_x = (float)minimap_width / board_width;
static float minimap_scale_y = (float)minimap_height / board_height;

static int stepping_x = 8;
static int floor_ceil_stepping = 8;

float boards[];
PVector raydir[];
PVector latest_rays[];

class Entity {
  PVector position;
  float rotation;
  float fov;
	float vel_multiplier = 8;
 
  Entity(PVector position, float rotation, float fov) {
    this.position = position;
    this.rotation = rotation;
    this.fov = fov;
  }
 
  float getX() {
    return position.x;
  }
 
  float getY() {
    return position.y;
  }
 
  int getTileX() {
    return round(position.x);
  }
 
  int getTileY() {
    return round(position.y);
  }
};

Entity player = new Entity(
    new PVector(board_width / 2,
                board_height / 2), 90, 60);

void setup() {
  size(800, 600);
  frameRate(60);
  colorMode(RGB,255,255,255,100);
 
	// initialize the map, enclose it with walls
  boards = new float[board_size];
	
  for (int i = 0; i < board_width; i += 1) {
    boards[i] = 1;
    boards[i + board_width * (board_height - 1)] = 1;
  }
 
  for (int i = 0; i < board_height; i += 1) {
    boards[i * board_width] = 1;
    boards[(board_width - 1) + i * board_width] = 1;
  }
	
	// pre-calculate all ray directions for the player FOV
	raydir = new PVector[width * 360];
	
	for (int i = 0; i < (width * 360); i += 1) {
		int rotation_degree = int((float)i / width);

		float ri = i % width;
		float norm_i = ri / width;
		
		raydir[i] = new PVector(
									cos(radians(rotation_degree) - radians(player.fov / 2) + radians(player.fov) * norm_i),
		            	sin(radians(rotation_degree) - radians(player.fov / 2) + radians(player.fov) * norm_i));
	}
	
	// latest rays are stored here
	latest_rays = new PVector[width];
	for (int i = 0; i < width; i += 1) {
		latest_rays[i] = new PVector(0, 0);
	}
}

void draw() {
  background(0);
 
  noStroke();
 
  raycast();
  minimap();
 
  player.rotation = (float)mouseX / width * 360;
	
	keyPressCheck();
}

// core algorithm
void raycast() {
  int i = 0, j = 0;
	
	int rot_i = int(player.rotation) * width;

	// scan the screen horizontally and raycast from the defined FOV
  for (i = 0; i < width; i += stepping_x) {
    float norm_i = (float)i / width;
		
		PVector ray_direction = raydir[i + rot_i];
   
    float dx = ray_direction.x;
		//float dx = cos(radians(player.rotation) - radians(player.fov / 2) + radians(player.fov) * norm_i);
    float dy = ray_direction.y;
		//float dy = sin(radians(player.rotation) - radians(player.fov / 2) + radians(player.fov) * norm_i);
   
    float px = player.getX();
    float py = player.getY();
		
		// traverse the map & check collision
    while (px >= 0 && px < board_width && 
					 py >= 0 && py < board_height) {
      float result = boards[(int)px + (int)py * board_width];
     
      if (result > 0) {
				// manhattan distance (faster to compute but may need further investigation to fix precision issues)
				// (abs(player.getX() - px) + abs(player.getY() - py))
				float ddx = abs(player.getX() - px);
				float ddy = abs(player.getY() - py);
        float dist = sqrt(ddx * ddx + ddy * ddy) * cos(radians(player.fov) * norm_i); //* (cos(radians(player.fov) * norm_i));
        float norm_dist = 1. - dist / board_width;
				
				// determine wall Y position and its height from the computed distance
        float wh = norm_dist * wall_height;
        float wall_start_y = height / 2 - wh / 2;
       
        for (j = 0; j < wall_start_y; j += floor_ceil_stepping) {
          float norm_j = j / wall_start_y;
         
          fill((1. - norm_j) * 255, (1. - norm_j) * 255, (1. - norm_j) * 255, 32);
          rect(i, j, stepping_x, floor_ceil_stepping);
          fill(norm_j * 255, norm_j * 255, norm_j * 255, 32);
          rect(i, j + wh + wall_start_y, stepping_x, floor_ceil_stepping);
        }
				
        fill(norm_dist * 255, 0, 0, 255);
        rect(i, wall_start_y, stepping_x, wh);
				
				latest_rays[i].x = px;
				latest_rays[i].y = py;

        break;
      }
     
			// show complete raycast FOV on minimap
      //fill(0, 255, 0, 64);
      //rect(int(px * minimap_scale_x + width - minimap_width_m1), int(py * minimap_scale_y), 1, 1);
     
      px += dx;
      py += dy;
    }
  }
}

void keyPressCheck() {
  if (keyPressed) {
		int rot_i = int(player.rotation) * width;
		
		PVector ray_direction = raydir[width / 2 + rot_i];
		
		PVector velocity = new PVector(ray_direction.x, ray_direction.y);
		velocity.mult(player.vel_multiplier);
		
		int dir = 1;
		if (player.rotation > 180) {
			dir = -1;
		}
		
		PVector newPosition = new PVector(player.position.x, player.position.y);
		
    if (keyCode == UP) {
			newPosition.add(velocity);
		} else if (keyCode == DOWN) {
			newPosition.sub(velocity);
		} else if (keyCode == LEFT) {
			newPosition.x -= cos(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
			newPosition.y -= sin(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
		} else if (keyCode == RIGHT) {
			newPosition.x += cos(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
			newPosition.y += sin(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
		}
		
		if (newPosition.x < board_width - 1 && newPosition.y < board_height - 1 &&
				newPosition.x > 0 && newPosition.y > 0) {
			player.position = newPosition;
		}
	}
}

void minimap() {
	int minimap_offset_x = width - minimap_width_m1;
	
  for (int i = 0; i < board_size; i += int(board_width / minimap_width)) {
    float w = boards[i];
   
    if (w > 0.5) {
      fill(255, 255, 255, 192);
			
			int x = i % board_width;
			int y = int((float)i / board_width);

			x = int((float)x * minimap_scale_x);
			y = int((float)y * minimap_scale_y);
     
      rect(x + minimap_offset_x, y, 1, 1);
    }
  }
	
	// display the player FOV on the minimap
	stroke(255, 0, 0, 64);
	for (int i = 0; i < width; i += stepping_x) {
		PVector ray = latest_rays[i];
		line(player.getX() * minimap_scale_x + minimap_offset_x, player.getY() * minimap_scale_y, ray.x * minimap_scale_x + minimap_offset_x, ray.y * minimap_scale_y);
	}
	noStroke();
	
	// display player position
	fill(0, 255, 0);
	rect(player.getTileX() * minimap_scale_x + minimap_offset_x - 2,
			 player.getTileY() * minimap_scale_y - 2, 4, 4);
}"
"606206","2D volume raycasting","mySketch","static int board_width = 256;
static int board_height = board_width; // linked
static int board_size = board_width * board_height;

static int wall_height = 244;

static int minimap_width = 64;
static int minimap_height = minimap_width; // linked
static int minimap_width_m1 = minimap_width - 1;
static float minimap_scale_x = (float)minimap_width / board_width;
static float minimap_scale_y = (float)minimap_height / board_height;

static int stepping_x = 8;
static int floor_ceil_stepping = 8;

float boards[];
PVector raydir[];
PVector latest_rays[];

class Entity {
  PVector position;
  float rotation;
  float fov;
	float vel_multiplier = 8;
 
  Entity(PVector position, float rotation, float fov) {
    this.position = position;
    this.rotation = rotation;
    this.fov = fov;
  }
 
  float getX() {
    return position.x;
  }
 
  float getY() {
    return position.y;
  }
 
  int getTileX() {
    return round(position.x);
  }
 
  int getTileY() {
    return round(position.y);
  }
};

Entity player = new Entity(
    new PVector(board_width / 2,
                board_height / 2), 90, 60);

void setup() {
  size(800, 600);
  frameRate(60);
  colorMode(RGB,255,255,255,100);
 
	// initialize the map, enclose it with walls
  boards = new float[board_size];
	
  for (int i = 0; i < board_width; i += 1) {
    boards[i] = 1;
    boards[i + board_width * (board_height - 1)] = 1;
  }
 
  for (int i = 0; i < board_height; i += 1) {
    boards[i * board_width] = 1;
    boards[(board_width - 1) + i * board_width] = 1;
  }
	
	// pre-calculate all ray directions for the player FOV
	raydir = new PVector[width * 360];
	
	for (int i = 0; i < (width * 360); i += 1) {
		int rotation_degree = int((float)i / width);

		float ri = i % width;
		float norm_i = ri / width;
		
		raydir[i] = new PVector(
									cos(radians(rotation_degree) - radians(player.fov / 2) + radians(player.fov) * norm_i),
		            	sin(radians(rotation_degree) - radians(player.fov / 2) + radians(player.fov) * norm_i));
	}
	
	// latest rays are stored here
	latest_rays = new PVector[width];
	for (int i = 0; i < width; i += 1) {
		latest_rays[i] = new PVector(0, 0);
	}
}

void draw() {
  background(0);
 
  noStroke();
 
  raycast();
  minimap();
 
  player.rotation = (float)mouseX / width * 360;
	
	keyPressCheck();
}

// core algorithm
void raycast() {
  int i = 0, j = 0;
	
	int rot_i = int(player.rotation) * width;

	// scan the screen horizontally and raycast from the defined player FOV
  for (i = 0; i < width; i += stepping_x) {
    float norm_i = (float)i / width;
		
		// we use pre-computed ray directions (see below for the raw formula)
		PVector ray_direction = raydir[i + rot_i];
   
    float dx = ray_direction.x;
		//float dx = cos(radians(player.rotation) - radians(player.fov / 2) + radians(player.fov) * norm_i);
    float dy = ray_direction.y;
		//float dy = sin(radians(player.rotation) - radians(player.fov / 2) + radians(player.fov) * norm_i);
   
    float px = player.getX();
    float py = player.getY();
		
		// traverse the map & check collision
    while (px >= 0 && px < board_width && 
					 py >= 0 && py < board_height) {
      float result = boards[(int)px + (int)py * board_width];
     
      if (result > 0) {
				// manhattan distance (faster to compute but may need further investigation to fix precision issues)
				// (abs(player.getX() - px) + abs(player.getY() - py))
				float ddx = abs(player.getX() - px);
				float ddy = abs(player.getY() - py);
        float dist = sqrt(ddx * ddx + ddy * ddy); //* (cos(radians(player.fov) * norm_i));
        float norm_dist = 1. - dist / board_width;
				
				// determine wall Y position and its height from the computed distance
        float wh = norm_dist * wall_height;
        float wall_start_y = height / 2 - wh / 2;
       
        for (j = 0; j < wall_start_y; j += floor_ceil_stepping) {
          float norm_j = j / wall_start_y;
         
          fill((1. - norm_j) * 255, (1. - norm_j) * 255, (1. - norm_j) * 255, 32);
          rect(i, j, stepping_x, floor_ceil_stepping);
          fill(norm_j * 255, norm_j * 255, norm_j * 255, 32);
          rect(i, j + wh + wall_start_y, stepping_x, floor_ceil_stepping);
        }
				
        fill(norm_dist * 255, 0, 0, 255);
        rect(i, wall_start_y, stepping_x, wh);
				
				latest_rays[i].x = px;
				latest_rays[i].y = py;

        break;
      }
     
			// show complete raycast FOV on minimap
      //fill(0, 255, 0, 64);
      //rect(int(px * minimap_scale_x + width - minimap_width_m1), int(py * minimap_scale_y), 1, 1);
     
      px += dx;
      py += dy;
    }
  }
}

void keyPressCheck() {
  if (keyPressed) {
		int rot_i = int(player.rotation) * width;
		
		PVector ray_direction = raydir[width / 2 + rot_i];
		
		PVector velocity = new PVector(ray_direction.x, ray_direction.y);
		velocity.mult(player.vel_multiplier);
		
		int dir = 1;
		if (player.rotation > 180) {
			dir = -1;
		}
		
		PVector newPosition = new PVector(player.position.x, player.position.y);
		
    if (keyCode == UP) {
			newPosition.add(velocity);
		} else if (keyCode == DOWN) {
			newPosition.sub(velocity);
		} else if (keyCode == LEFT) {
			newPosition.x -= cos(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
			newPosition.y -= sin(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
		} else if (keyCode == RIGHT) {
			newPosition.x += cos(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
			newPosition.y += sin(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
		}
		
		if (newPosition.x < board_width - 1 && newPosition.y < board_height - 1 &&
				newPosition.x > 0 && newPosition.y > 0) {
			player.position = newPosition;
		}
	}
}

void minimap() {
	int minimap_offset_x = width - minimap_width_m1;
	
  for (int i = 0; i < board_size; i += int(board_width / minimap_width)) {
    float w = boards[i];
   
    if (w > 0.5) {
      fill(255, 255, 255, 192);
			
			int x = i % board_width;
			int y = int((float)i / board_width);

			x = int((float)x * minimap_scale_x);
			y = int((float)y * minimap_scale_y);
     
      rect(x + minimap_offset_x, y, 1, 1);
    }
  }
	
	// display the player FOV on the minimap
	stroke(255, 0, 0, 64);
	for (int i = 0; i < width; i += stepping_x) {
		PVector ray = latest_rays[i];
		line(player.getX() * minimap_scale_x + minimap_offset_x, player.getY() * minimap_scale_y, ray.x * minimap_scale_x + minimap_offset_x, ray.y * minimap_scale_y);
	}
	noStroke();
	
	// display player position
	fill(0, 255, 0);
	rect(player.getTileX() * minimap_scale_x + minimap_offset_x - 2,
			 player.getTileY() * minimap_scale_y - 2, 4, 4);
}"
"606206","2D volume raycasting","mySketch","/**
  * Custom raytracer done for fun on a phone (APDE Android app.) while commuting.
	* Improved afterward on desktop because APDE is buggy and crashed as the complexity increased ! :)
	*/

static int board_width = 256;
static int board_height = board_width; // linked
static int board_size = board_width * board_height;

static int wall_height = 64;

static int minimap_width = 64;
static int minimap_height = minimap_width; // linked
static int minimap_width_m1 = minimap_width - 1;
static float minimap_scale_x = (float)minimap_width / board_width;
static float minimap_scale_y = (float)minimap_height / board_height;

static int stepping_x = 8;
static int floor_ceil_stepping = 8;

float boards[];
PVector raydir[];
PVector latest_rays[];

// an entity class which hold player data and other entities
class Entity {
  PVector position;
  float rotation;
  float fov;
	float vel_multiplier = 8;
 
  Entity(PVector position, float rotation, float fov) {
    this.position = position;
    this.rotation = rotation;
    this.fov = fov;
  }
 
  float getX() {
    return position.x;
  }
 
  float getY() {
    return position.y;
  }
 
  int getRoundX() {
    return round(position.x);
  }
 
  int getRoundY() {
    return round(position.y);
  }
};

Entity player = new Entity(
    new PVector(board_width / 2,
                board_height / 2), 90, 60);

void setup() {
  size(800, 600);
  frameRate(60);
  colorMode(RGB,255,255,255,100);
 
	// initialize the map, enclose it with walls
  boards = new float[board_size];
	
  for (int i = 0; i < board_width; i += 1) {
    boards[i] = 1;
    boards[i + board_width * (board_height - 1)] = 1;
  }
 
  for (int i = 0; i < board_height; i += 1) {
    boards[i * board_width] = 1;
    boards[(board_width - 1) + i * board_width] = 1;
  }
	
	// pre-calculate all ray directions for the player FOV
	raydir = new PVector[width * 360];
	
	for (int i = 0; i < (width * 360); i += 1) {
		int rotation_degree = int((float)i / width);

		float ri = i % width;
		float norm_i = ri / width;
		
		raydir[i] = new PVector(
									cos(radians(rotation_degree) - radians(player.fov / 2) + radians(player.fov) * norm_i),
		            	sin(radians(rotation_degree) - radians(player.fov / 2) + radians(player.fov) * norm_i));
	}
	
	// latest rays are stored here
	latest_rays = new PVector[width];
	for (int i = 0; i < width; i += 1) {
		latest_rays[i] = new PVector(0, 0);
	}
}

void draw() {
  background(0);
 
  noStroke();
 
  raycast();
  minimap();
 
  player.rotation = ((float)mouseX / width * 2 * 359) % 360;
	
	keyPressCheck();
}

// core algorithm
void raycast() {
  int i = 0, j = 0;
	
	int rot_i = int(player.rotation) * width;
	
	// scan the screen horizontally and raycast from the defined player FOV
  for (i = 0; i < width; i += stepping_x) {
    float norm_i = (float)i / width;
		
		// we use pre-computed ray directions (see below for the raw formula)
		PVector ray_direction = raydir[i + rot_i];
   
    float dx = ray_direction.x;
		//float dx = cos(radians(player.rotation) - radians(player.fov / 2) + radians(player.fov) * norm_i);
    float dy = ray_direction.y;
		//float dy = sin(radians(player.rotation) - radians(player.fov / 2) + radians(player.fov) * norm_i);
   
    float px = player.position.x;
    float py = player.position.y;
		
		// traverse the map & check collision
    while (px >= 0 && px < board_width && 
					 py >= 0 && py < board_height) {
      float result = boards[(int)px + (int)py * board_width];
     
      if (result > 0) {
				// manhattan distance (faster to compute but may need further investigation to use it properly)
				// (abs(player.getX() - px) + abs(player.getY() - py))
				float ddx = abs(player.position.x - px);
				float ddy = abs(player.position.y - py);
				
        float dist = sqrt(ddx * ddx + ddy * ddy) * (cos(-radians(player.fov / 2) + radians(player.fov) * norm_i));
        float norm_dist = dist / board_width;
				
				// determine wall Y position and its height from the computed distance
        float wh = wall_height / dist * 277;
        float wall_start_y = height / 2 - wh / 2;
       
        for (j = 0; j < wall_start_y; j += floor_ceil_stepping) {
          float norm_j = j / wall_start_y;
         
          fill((1. - norm_j) * 255, (1. - norm_j) * 255, (1. - norm_j) * 255, 32);
          rect(i, j, stepping_x, floor_ceil_stepping);
          fill(norm_j * 255, norm_j * 255, norm_j * 255, 32);
          rect(i, j + wh + wall_start_y, stepping_x, floor_ceil_stepping);
        }
				
        fill(norm_dist * 255, 0, 0, 255);
        rect(i, wall_start_y, stepping_x, wh);
				
				latest_rays[i].x = px;
				latest_rays[i].y = py;

        break;
      }
     
			// show complete raycast FOV on minimap (pixels perfect but slow and should be computed outside to fix order issues)
      //fill(0, 255, 0, 64);
      //rect(int(px * minimap_scale_x + width - minimap_width_m1), int(py * minimap_scale_y), 1, 1);
			
      px += dx;
      py += dy;
    }
  }
}

// physics logic
void keyPressCheck() {
  if (keyPressed) {
		int rot_i = int(player.rotation) * width;
		
		PVector ray_direction = raydir[width / 2 + rot_i];
		
		PVector velocity = new PVector(ray_direction.x, ray_direction.y);
		velocity.mult(player.vel_multiplier);
		
		int dir = 1;
		if (player.rotation > 90 || player.rotation < 180) {
			dir = -1;
		}
		
		PVector newPosition = new PVector(player.position.x, player.position.y);
		
    if (keyCode == UP) {
			newPosition.add(velocity);
		} else if (keyCode == DOWN) {
			newPosition.sub(velocity);
		} else if (keyCode == LEFT) {
			newPosition.x -= cos(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
			newPosition.y -= sin(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
		} else if (keyCode == RIGHT) {
			newPosition.x += cos(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
			newPosition.y += sin(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
		}
		
		if (newPosition.x < board_width - 1 && newPosition.y < board_height - 1 &&
				newPosition.x > 0 && newPosition.y > 0) {
			player.position = newPosition;
		}
	}
}

void minimap() {
	int minimap_offset_x = width - minimap_width_m1;
	
	// map
  for (int i = 0; i < board_size; i += int(board_width / minimap_width)) {
    float w = boards[i];
   
    if (w > 0.5) {
      fill(255, 255, 255, 192);
			
			int x = i % board_width;
			int y = int((float)i / board_width);

			x = int((float)x * minimap_scale_x);
			y = int((float)y * minimap_scale_y);
     
      rect(x + minimap_offset_x, y, 1, 1);
    }
  }
	
	// player FOV on the minimap from all the casted latest rays
	stroke(0, 255, 0, 255);
	for (int i = 0; i < width; i += stepping_x) {
		PVector ray = latest_rays[i];
		line(player.position.x * minimap_scale_x + minimap_offset_x,
				 player.position.y * minimap_scale_y,
				 ray.x * minimap_scale_x + minimap_offset_x,
				 ray.y * minimap_scale_y);
	}
	noStroke();
	
	// player position
	fill(0, 128, 0);
	rect(player.position.x * minimap_scale_x + minimap_offset_x - 2,
			 player.position.y * minimap_scale_y - 2, 4, 4);
}"
"606206","2D volume raycasting","mySketch","/**
  * Custom raytracer done for fun on a phone (APDE Android app.) while commuting.
	* Improved afterward on desktop because APDE is buggy and crashed as the complexity increased ! :)
	* This use Wolfenstein 3D textures.
	*/

static int board_width = 256;
static int board_height = board_width; // linked
static int board_size = board_width * board_height;

static int wall_height = 64;

static int minimap_width = 64;
static int minimap_height = minimap_width; // linked
static int minimap_width_m1 = minimap_width - 1;
static float minimap_scale_x = (float)minimap_width / board_width;
static float minimap_scale_y = (float)minimap_height / board_height;

static int stepping_x = 8;
static int floor_ceil_stepping = 8;

float boards[];
PVector raydir[];
PVector latest_rays[];

PImage textures; 

// an entity class which hold player data and other entities
class Entity {
  PVector position;
  float rotation;
  float fov;
	float dst_proj_plane;
	float vel_multiplier = 8;
 
  Entity(PVector position, float rotation, float fov) {
    this.position = position;
    this.rotation = rotation;
    this.fov = fov;
		this.dst_proj_plane = 160 / tan(radians(fov / 2));
  }
 
  float getX() {
    return position.x;
  }
 
  float getY() {
    return position.y;
  }
 
  int getRoundX() {
    return round(position.x);
  }
 
  int getRoundY() {
    return round(position.y);
  }
};

Entity player = new Entity(
    new PVector(board_width / 2,
                board_height / 2), 90, 60);

void setup() {
  size(800, 600);
  frameRate(60);
  colorMode(RGB,255,255,255,100);
 
	// initialize the map, enclose it with walls
  boards = new float[board_size];
	
  for (int i = 0; i < board_width; i += 1) {
    boards[i] = 1;
    boards[i + board_width * (board_height - 1)] = 1;
  }
 
  for (int i = 0; i < board_height; i += 1) {
    boards[i * board_width] = 1;
    boards[(board_width - 1) + i * board_width] = 1;
  }
	
	// pre-calculate all ray directions for the player FOV
	raydir = new PVector[width * 360];
	
	for (int i = 0; i < (width * 360); i += 1) {
		int rotation_degree = int((float)i / width);

		float ri = i % width;
		float norm_i = ri / width;
		
		raydir[i] = new PVector(
									cos(radians(rotation_degree) - radians(player.fov / 2) + radians(player.fov) * norm_i),
		            	sin(radians(rotation_degree) - radians(player.fov / 2) + radians(player.fov) * norm_i));
	}
	
	// latest rays are stored here
	latest_rays = new PVector[width];
	for (int i = 0; i < width; i += 1) {
		latest_rays[i] = new PVector(0, 0);
	}
	
	textures = loadImage(""wolftextures.png"");
}

void draw() {
  background(0);
 
  noStroke();
 
  raycast();
  minimap();
 
  player.rotation = ((float)mouseX / width * 2 * 359) % 360;
	
	keyPressCheck();
}

// core algorithm
void raycast() {
  int i = 0, j = 0;
	
	int rot_i = int(player.rotation) * width;
	
	// scan the screen horizontally and raycast from the defined player FOV
  for (i = 0; i < width; i += stepping_x) {
    float norm_i = (float)i / width;
		
		// we use pre-computed ray directions (see below for the raw formula)
		PVector ray_direction = raydir[i + rot_i];
   
    float dx = ray_direction.x;
		//float dx = cos(radians(player.rotation) - radians(player.fov / 2) + radians(player.fov) * norm_i);
    float dy = ray_direction.y;
		//float dy = sin(radians(player.rotation) - radians(player.fov / 2) + radians(player.fov) * norm_i);
   
    float px = player.position.x;
    float py = player.position.y;
		
		// traverse the map & check for collisions
    while (px >= 0 && px < board_width && 
					 py >= 0 && py < board_height) {
      float result = boards[(int)px + (int)py * board_width];
     
      if (result > 0) {
				// manhattan distance (faster to compute but may need further investigation to use it properly)
				// (abs(player.getX() - px) + abs(player.getY() - py))
				
				// compute distance with corrected perspective
				// if the perspective is not corrected this will produce fish-eye / distorded walls effect because rays on the edge of the screen need to travel 'further' than the middle rays one 
				float ddx = abs(player.position.x - px);
				float ddy = abs(player.position.y - py);
				
        float dist = sqrt(ddx * ddx + ddy * ddy) * (cos(-radians(player.fov / 2) + radians(player.fov) * norm_i));
        float norm_dist = dist / board_width;
				
				// determine wall height from the computed distance
				// dst_proj_plane is just a value related to the FOV, it relate to the player / projection plane distance
        float wh = wall_height / dist * player.dst_proj_plane;
				// now determine the vertical wall start position
        float wall_start_y = height / 2 - wh / 2;
       
				// draw floor and ceiling
        for (j = 0; j < wall_start_y; j += floor_ceil_stepping) {
          float norm_j = j / wall_start_y;
          float inorm_j = 1. - norm_j;
					float ceil_brightness = 255 * inorm_j;
					float floor_brightness = 255 * inorm_j;
					
          fill(ceil_brightness, ceil_brightness, ceil_brightness, 32);
          rect(i, j, stepping_x, floor_ceil_stepping);
          fill(floor_brightness, floor_brightness, floor_brightness, 32);
          rect(i, j + wh + wall_start_y, stepping_x, floor_ceil_stepping);
        }
				
				// draw wall
        fill(norm_dist * 255, 0, 0, 255);
        rect(i, wall_start_y, stepping_x, wh);
				
				// store ray for later use (minimap FOV)
				latest_rays[i].x = px;
				latest_rays[i].y = py;

        break;
      }
     
			// show complete raycast FOV on minimap (pixels perfect but slow and should be computed outside to fix order issues)
      //fill(0, 255, 0, 64);
      //rect(int(px * minimap_scale_x + width - minimap_width_m1), int(py * minimap_scale_y), 1, 1);
			
      px += dx;
      py += dy;
    }
  }
}

// physics logic
void keyPressCheck() {
  if (keyPressed) {
		int rot_i = int(player.rotation) * width;
		
		PVector ray_direction = raydir[width / 2 + rot_i];
		
		PVector velocity = new PVector(ray_direction.x, ray_direction.y);
		velocity.mult(player.vel_multiplier);
		
		int dir = 1;
		if (player.rotation > 90 || player.rotation < 180) {
			dir = -1;
		}
		
		PVector newPosition = new PVector(player.position.x, player.position.y);
		
    if (keyCode == UP) {
			newPosition.add(velocity);
		} else if (keyCode == DOWN) {
			newPosition.sub(velocity);
		} else if (keyCode == LEFT) {
			newPosition.x -= cos(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
			newPosition.y -= sin(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
		} else if (keyCode == RIGHT) {
			newPosition.x += cos(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
			newPosition.y += sin(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
		}
		
		if (newPosition.x < board_width - 1 && newPosition.y < board_height - 1 &&
				newPosition.x > 0 && newPosition.y > 0) {
			player.position = newPosition;
		}
	}
}

void minimap() {
	int minimap_offset_x = width - minimap_width_m1;
	
	// map
  for (int i = 0; i < board_size; i += int(board_width / minimap_width)) {
    float w = boards[i];
   
    if (w > 0.5) {
      fill(255, 255, 255, 192);
			
			int x = i % board_width;
			int y = int((float)i / board_width);

			x = int((float)x * minimap_scale_x);
			y = int((float)y * minimap_scale_y);
     
      rect(x + minimap_offset_x, y, 1, 1);
    }
  }
  
	// player FOV on the minimap from all the latest rays casted (fast but not pixel perfect)
	stroke(0, 255, 0, 255);
	for (int i = 0; i < width; i += stepping_x) {
		PVector ray = latest_rays[i];
		line(player.position.x * minimap_scale_x + minimap_offset_x,
				 player.position.y * minimap_scale_y,
				 ray.x * minimap_scale_x + minimap_offset_x,
				 ray.y * minimap_scale_y);
	}
	noStroke();
	
	// player position
	fill(0, 128, 0);
	rect(player.position.x * minimap_scale_x + minimap_offset_x - 2,
			 player.position.y * minimap_scale_y - 2, 4, 4);
}"
"606206","2D volume raycasting","mySketch","/**
  * Custom raytracer done for fun on a phone (APDE Android app.) while commuting.
	* Improved afterward on desktop because APDE is buggy and crashed as the complexity increased ! :)
	* This use Wolfenstein 3D textures.
	*/

static int board_width = 256;
static int board_height = board_width; // linked
static int board_size = board_width * board_height;

static int wall_height = 64;

static int minimap_width = 64;
static int minimap_height = minimap_width; // linked
static int minimap_width_m1 = minimap_width - 1;
static float minimap_scale_x = (float)minimap_width / board_width;
static float minimap_scale_y = (float)minimap_height / board_height;

static int stepping_x = 8;
static int floor_ceil_stepping = 8;

float boards[];
PVector raydir[];
PVector latest_rays[];

PImage textures; 

// an entity class which hold player data and other entities
class Entity {
  PVector position;
  float rotation;
  float fov;
	float dst_proj_plane;
	float vel_multiplier = 8;
 
  Entity(PVector position, float rotation, float fov) {
    this.position = position;
    this.rotation = rotation;
    this.fov = fov;
		this.dst_proj_plane = 160 / tan(radians(fov / 2));
  }
};

Entity player = new Entity(
    new PVector(board_width / 2,
                board_height / 2), 90, 60);

void setup() {
  size(800, 600);
  frameRate(60);
  colorMode(RGB,255,255,255,100);
 
	// initialize the map, enclose it with walls
  boards = new float[board_size];
	
  for (int i = 0; i < board_width; i += 1) {
    boards[i] = 1;
    boards[i + board_width * (board_height - 1)] = 1;
  }
 
  for (int i = 0; i < board_height; i += 1) {
    boards[i * board_width] = 1;
    boards[(board_width - 1) + i * board_width] = 1;
  }
	
	// pre-calculate all ray directions for the player FOV
	raydir = new PVector[width * 360];
	
	for (int i = 0; i < (width * 360); i += 1) {
		int rotation_degree = int((float)i / width);

		float ri = i % width;
		float norm_i = ri / width;
		
		raydir[i] = new PVector(
									cos(radians(rotation_degree) - radians(player.fov / 2) + radians(player.fov) * norm_i),
		            	sin(radians(rotation_degree) - radians(player.fov / 2) + radians(player.fov) * norm_i));
	}
	
	// latest rays are stored here
	latest_rays = new PVector[width];
	for (int i = 0; i < width; i += 1) {
		latest_rays[i] = new PVector(0, 0);
	}
	
	textures = loadImage(""wolftextures.png"");
}

void draw() {
  background(0);
 
  noStroke();
 
  raycast();
  minimap();
 
  player.rotation = ((float)mouseX / width * 2 * 359) % 360;
	
	keyPressCheck();
}

// core algorithm
void raycast() {
  int i = 0, j = 0;
	
	int rot_i = int(player.rotation) * width;
	
	// scan the screen horizontally and raycast from the defined player FOV
  for (i = 0; i < width; i += stepping_x) {
    float norm_i = (float)i / width;
		
		// we use pre-computed ray directions (see below for the raw formula)
		PVector ray_direction = raydir[i + rot_i];
   
    float dx = ray_direction.x;
		//float dx = cos(radians(player.rotation) - radians(player.fov / 2) + radians(player.fov) * norm_i);
    float dy = ray_direction.y;
		//float dy = sin(radians(player.rotation) - radians(player.fov / 2) + radians(player.fov) * norm_i);
   
    float px = player.position.x;
    float py = player.position.y;
		
		// traverse the map & check for collisions
    while (px >= 0 && px < board_width && 
					 py >= 0 && py < board_height) {
      float result = boards[(int)px + (int)py * board_width];
     
      if (result > 0) {
				// manhattan distance (faster to compute but may need further investigation to use it properly)
				// (abs(player.getX() - px) + abs(player.getY() - py))
				
				// compute distance with corrected perspective
				// if the perspective is not corrected this will produce fish-eye / distorded walls effect because rays on the edge of the screen need to travel 'further' than the middle rays one 
				float ddx = abs(player.position.x - px);
				float ddy = abs(player.position.y - py);
				
        float dist = sqrt(ddx * ddx + ddy * ddy) * (cos(-radians(player.fov / 2) + radians(player.fov) * norm_i));
        float norm_dist = dist / board_width;
				
				// determine wall height from the computed distance
				// dst_proj_plane is just a value related to the FOV, it relate to the player / projection plane distance
        float wh = wall_height / dist * player.dst_proj_plane;
				// now determine the vertical wall start position
        float wall_start_y = height / 2 - wh / 2;
       
				// draw floor and ceiling
        for (j = 0; j < wall_start_y; j += floor_ceil_stepping) {
          float norm_j = j / wall_start_y;
          float inorm_j = 1. - norm_j;
					float ceil_brightness = 255 * inorm_j;
					float floor_brightness = 255 * inorm_j;
					
          fill(ceil_brightness, ceil_brightness, ceil_brightness, 32);
          rect(i, j, stepping_x, floor_ceil_stepping);
          fill(floor_brightness, floor_brightness, floor_brightness, 32);
          rect(i, j + wh + wall_start_y, stepping_x, floor_ceil_stepping);
        }
				
				// draw wall
        fill(norm_dist * 255, 0, 0, 255);
        rect(i, wall_start_y, stepping_x, wh);
				
				// store ray for later use (minimap FOV)
				latest_rays[i].x = px;
				latest_rays[i].y = py;

        break;
      }
     
			// show complete raycast FOV on minimap (pixels perfect but slow and should be computed outside to fix order issues)
      //fill(0, 255, 0, 64);
      //rect(int(px * minimap_scale_x + width - minimap_width_m1), int(py * minimap_scale_y), 1, 1);
			
      px += dx;
      py += dy;
    }
  }
}

// physics logic
void keyPressCheck() {
  if (keyPressed) {
		int rot_i = int(player.rotation) * width;
		
		PVector ray_direction = raydir[width / 2 + rot_i];
		
		PVector velocity = new PVector(ray_direction.x, ray_direction.y);
		velocity.mult(player.vel_multiplier);
		
		int dir = 1;
		if (player.rotation > 90 || player.rotation < 180) {
			dir = -1;
		}
		
		PVector newPosition = new PVector(player.position.x, player.position.y);
		
    if (keyCode == UP) {
			newPosition.add(velocity);
		} else if (keyCode == DOWN) {
			newPosition.sub(velocity);
		} else if (keyCode == LEFT) {
			newPosition.x -= cos(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
			newPosition.y -= sin(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
		} else if (keyCode == RIGHT) {
			newPosition.x += cos(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
			newPosition.y += sin(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
		}
		
		if (newPosition.x < board_width - 1 && newPosition.y < board_height - 1 &&
				newPosition.x > 0 && newPosition.y > 0) {
			player.position = newPosition;
		}
	}
}

void minimap() {
	int minimap_offset_x = width - minimap_width_m1;
	
	// map
  for (int i = 0; i < board_size; i += int(board_width / minimap_width)) {
    float w = boards[i];
   
    if (w > 0.5) {
      fill(255, 255, 255, 192);
			
			int x = i % board_width;
			int y = int((float)i / board_width);

			x = int((float)x * minimap_scale_x);
			y = int((float)y * minimap_scale_y);
     
      rect(x + minimap_offset_x, y, 1, 1);
    }
  }
  
	// player FOV on the minimap from all the latest rays casted (fast but not pixel perfect)
	stroke(0, 255, 0, 255);
	for (int i = 0; i < width; i += stepping_x) {
		PVector ray = latest_rays[i];
		line(player.position.x * minimap_scale_x + minimap_offset_x,
				 player.position.y * minimap_scale_y,
				 ray.x * minimap_scale_x + minimap_offset_x,
				 ray.y * minimap_scale_y);
	}
	noStroke();
	
	// player position
	fill(0, 128, 0);
	rect(player.position.x * minimap_scale_x + minimap_offset_x - 2,
			 player.position.y * minimap_scale_y - 2, 4, 4);
}"
"606206","2D volume raycasting","mySketch","/**
  * Custom raytracer done for fun on a phone (APDE Android app.) while commuting.
	* Improved afterward on desktop because APDE is buggy and crashed as the sketch complexity increased ! :)
	* This use Wolfenstein 3D textures.
	*/

static int board_width = 256;
static int board_height = board_width; // linked
static int board_size = board_width * board_height;

static int wall_height = 64;

static int player_fov = 60;

static int minimap_width = 64;
static int minimap_height = minimap_width; // linked
static int minimap_width_m1 = minimap_width - 1;
static int minimap_fov_step = 24 * 4;
static float minimap_scale_x = (float)minimap_width / board_width;
static float minimap_scale_y = (float)minimap_height / board_height;

// increase for more performances
static int stepping_x = 24;
static int floor_ceil_stepping = 24;

float boards[];
PVector raydir[];
PVector latest_rays[];

PImage textures; 

// an entity class which hold player data and other entities
class Entity {
  PVector position;
  float rotation;
  float fov;
	float dst_proj_plane;
	float vel_multiplier = 8;
 
  Entity(PVector position, float rotation, float fov) {
    this.position = position;
    this.rotation = rotation;
    this.fov = fov;
		this.dst_proj_plane = 160 / tan(radians(fov / 2));
  }
};

Entity player = new Entity(
    new PVector(board_width / 2,
                board_height / 2), 90, player_fov);

void setup() {
  size(800, 600);
  frameRate(60);
  colorMode(RGB,255,255,255,100);
 
	// initialize the map, enclose it with walls
  boards = new float[board_size];
	
  for (int i = 0; i < board_width; i += 1) {
    boards[i] = 1;
    boards[i + board_width * (board_height - 1)] = 1;
  }
 
  for (int i = 0; i < board_height; i += 1) {
    boards[i * board_width] = 1;
    boards[(board_width - 1) + i * board_width] = 1;
  }
	
	// pre-calculate all ray directions for the player FOV
	raydir = new PVector[width * 360];
	
	for (int i = 0; i < (width * 360); i += 1) {
		int rotation_degree = int((float)i / width);

		float ri = i % width;
		float norm_i = ri / width;
		
		raydir[i] = new PVector(
									cos(radians(rotation_degree) - radians(player.fov / 2) + radians(player.fov) * norm_i),
		            	sin(radians(rotation_degree) - radians(player.fov / 2) + radians(player.fov) * norm_i));
	}
	
	// latest rays are stored here
	latest_rays = new PVector[width];
	for (int i = 0; i < width; i += 1) {
		latest_rays[i] = new PVector(0, 0);
	}
	
	textures = loadImage(""wolftextures.png"");
}

void draw() {
  background(0);
 
  noStroke();
 
  raycast();
  minimap();
 
  player.rotation = ((float)mouseX / width * 2 * 359) % 360;
	
	keyPressCheck();
}

// core algorithm
void raycast() {
  int i = 0, j = 0;
	
	int rot_i = int(player.rotation) * width;
	
	// scan the screen horizontally and raycast from the defined player FOV
  for (i = 0; i < width; i += stepping_x) {
    float norm_i = (float)i / width;
		
		// we use pre-computed ray directions (see below for the raw formula)
		PVector ray_direction = raydir[i + rot_i];
   
    float dx = ray_direction.x;
		//float dx = cos(radians(player.rotation) - radians(player.fov / 2) + radians(player.fov) * norm_i);
    float dy = ray_direction.y;
		//float dy = sin(radians(player.rotation) - radians(player.fov / 2) + radians(player.fov) * norm_i);
   
    float px = player.position.x;
    float py = player.position.y;
		
		// traverse the map & check for collisions
    while (px >= 0 && px < board_width && 
					 py >= 0 && py < board_height) {
      float result = boards[(int)px + (int)py * board_width];
     
      if (result > 0) {
				// manhattan distance (faster to compute but may need further investigation to use it properly)
				// (abs(player.getX() - px) + abs(player.getY() - py))
				
				// compute distance with corrected perspective
				// if the perspective is not corrected this will produce fish-eye / distorded walls effect because rays on the edge of the screen need to travel 'further' than the middle rays one 
				float ddx = abs(player.position.x - px);
				float ddy = abs(player.position.y - py);
				
        float dist = sqrt(ddx * ddx + ddy * ddy) * (cos(-radians(player.fov / 2) + radians(player.fov) * norm_i));
        float norm_dist = dist / max(board_width, board_height);
				float inorm_dist = 1 - norm_dist;
				
				// determine wall height from the computed distance
				// dst_proj_plane is just a value related to the FOV, it relate to the player / projection plane distance
        float wh = wall_height / dist * player.dst_proj_plane;
				// now determine the vertical wall start position
        float wall_start_y = height / 2 - wh / 2;
       
				// draw floor and ceiling
        for (j = 0; j < wall_start_y; j += floor_ceil_stepping) {
          float norm_j = j / wall_start_y;
          float inorm_j = 1. - norm_j;
					float ceil_brightness = 255 * inorm_j;
					float floor_brightness = 255 * norm_j;
					
          fill(ceil_brightness, ceil_brightness, ceil_brightness, 32);
          rect(i, j, stepping_x, floor_ceil_stepping);
          fill(floor_brightness, floor_brightness, floor_brightness, 32);
          rect(i, j + wh + wall_start_y, stepping_x, floor_ceil_stepping);
        }
				
				// draw wall
        fill(inorm_dist * 255, 0, 0, 255);
        rect(i, wall_start_y, stepping_x, wh);
				
				// store ray for later use (minimap FOV)
				latest_rays[i].x = px;
				latest_rays[i].y = py;

        break;
      }
     
			// show complete raycast FOV on minimap (pixels perfect but slow and should be computed outside to fix order issues)
      //fill(0, 255, 0, 64);
      //rect(int(px * minimap_scale_x + width - minimap_width_m1), int(py * minimap_scale_y), 1, 1);
			
      px += dx;
      py += dy;
    }
  }
}

// physics logic
void keyPressCheck() {
  if (keyPressed) {
		int rot_i = int(player.rotation) * width;
		
		PVector ray_direction = raydir[width / 2 + rot_i];
		
		PVector velocity = new PVector(ray_direction.x, ray_direction.y);
		velocity.mult(player.vel_multiplier);
		
		int dir = 1;
		if (player.rotation > 90 || player.rotation < 180) {
			dir = -1;
		}
		
		PVector newPosition = new PVector(player.position.x, player.position.y);
		
    if (keyCode == UP) {
			newPosition.add(velocity);
		} else if (keyCode == DOWN) {
			newPosition.sub(velocity);
		} else if (keyCode == LEFT) {
			newPosition.x -= cos(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
			newPosition.y -= sin(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
		} else if (keyCode == RIGHT) {
			newPosition.x += cos(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
			newPosition.y += sin(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
		}
		
		if (newPosition.x < board_width - 1 && newPosition.y < board_height - 1 &&
				newPosition.x > 0 && newPosition.y > 0) {
			player.position = newPosition;
		}
	}
}

void minimap() {
	int minimap_offset_x = width - minimap_width_m1;
	
	// map
  for (int i = 0; i < board_size; i += int(board_width / minimap_width)) {
    float w = boards[i];
   
    if (w > 0.5) {
      fill(255, 255, 255, 192);
			
			int x = i % board_width;
			int y = int((float)i / board_width);

			x = int((float)x * minimap_scale_x);
			y = int((float)y * minimap_scale_y);
     
      rect(x + minimap_offset_x, y, 1, 1);
    }
  }
  
	// player FOV on the minimap from all the latest rays casted (fast but not pixel perfect)
	stroke(0, 255, 0, 255);
	for (int i = 0; i < width; i += minimap_fov_step) {
		PVector ray = latest_rays[i];
		line(player.position.x * minimap_scale_x + minimap_offset_x,
				 player.position.y * minimap_scale_y,
				 ray.x * minimap_scale_x + minimap_offset_x,
				 ray.y * minimap_scale_y);
	}
	noStroke();
	
	// player position
	fill(0, 128, 0);
	rect(player.position.x * minimap_scale_x + minimap_offset_x - 2,
			 player.position.y * minimap_scale_y - 2, 4, 4);
}"
"606206","2D volume raycasting","mySketch","/**
  * Custom raycaster done for fun on a phone (APDE Android app.) while commuting.
	* Improved afterward on desktop because APDE is buggy and crashed as the sketch complexity increased ! :)
	*
	* This is actually a 2D volume raycaster as map objects are as-is (not blocky) thus it allow curved walls and any wall shapes actually for free...
	* It is however a bit slower than a ""blocky"" raycaster, will take way more memory and the texturing is buggy on highly curved walls.
	* There is two methods implemented for raycast :
	*   - A naive not optimal one which walk the grid in the view direction through fixed step
	*   - An optimal one which walk the grid in the view direction through each cells
	*
	* Optimizations done :
	*   - walk the grid in the view direction through each cells
	*   - clamp slice start y / height by the display height (so we don't draw unnecessarily outside the display)
	*   - pre-compute rays direction through a lookup table (this however make camera rotation a bit less smooth)
	*
	* The walls are mirrored on the y axis so we get a cheap floor mirror :p
	*
	* One could extend this to cast rays in a more free ways (in all direction: 3D) and this would basically become a volume raycaster so voxels yeh! :)
	*
	* An overview of old-school raycasting methods (compared to this one) :
	* 	A blocky raycaster like Wolfenstein 3D isn't really far from this: 
	*     - the map informations would just need to have a defined size when rendering them, this would make the world blocky and fix issue with texturing as well!
	* 	A high-quality raycaster (a la Duke Nukem 3D / Build engine) isn't really far from this as well :
	*   	- The map informations (as a bitmap) would need to be dropped for a map informations only made of lines / curves, this would fix the texturing problem on highly curved walls
	*     - This would however come with some problems related to culling which were fixed using methods such as portal rendering back in the days
	*   A 'voxel' landscape can be done easily by adapting this (see my other sketch) :
	*     - Send rays from far to near
	*     - Rays are not stopped once they hit something (they walk on the heightmap)
	*     - All cells traversed by the ray are drawn (could say the ray always hit something)
	*   Raytracing :
	*     - Same as raycasting except you continue sending rays once they hit something (you bounce them off, compute shading from lights etc)
	*     - Drop bitmap representation (this is really the definition of Volumetric in all Voxel methods)
	*
	* This use Wolfenstein 3D textures.
	*/

static int display_width = 640;
static int display_height = 480;

static int board_width = 256;
static int board_height = board_width; // linked
static int board_size = board_width * board_height;

// typically the diagonal of the map so we stop any rays casted outside...
// but this can also be used for performances, this is the camera z clipping so with fog and this we can speed the rendering up :)
static int max_ray_step = board_width * 2;

static int wall_height = 32;

static int player_fov = 60;

static int minimap_width = 128;
static int minimap_height = minimap_width; // linked
static int minimap_width_m1 = minimap_width - 1;
static int minimap_fov_step = 88;
static float minimap_scale_x = (float)minimap_width / board_width;
static float minimap_scale_y = (float)minimap_height / board_height;

// increase for more performances
static int stepping_x = 8;
static int floor_stepping = 8;
static int ceil_stepping = 8;
static int texture_stepping = 2;

int edit_mode = 0;

float boards[];
// we use this actually instead of ""boards"" to store the map data
// this allow to draw our map directly with Processing shapes since we are not restricted to perpendicular walls :)
PGraphics pg_map;

PVector raydir[];
PVector latest_rays[];

PImage textures;

PGraphics pg_minimap;

// an entity class which hold player data and other entities
class Entity {
  PVector position;
  float rotation;
  float fov;
	float dst_proj_plane;
	float vel_multiplier = 2;
  float height = 50;
 
  Entity(PVector position, float rotation, float fov) {
    this.position = position;
    this.rotation = rotation;
    this.fov = fov;
		this.dst_proj_plane = 160 / tan(radians(fov / 2));
  }
};

Entity player = new Entity(
    new PVector(board_width / 2,
                board_height / 2), 90, player_fov);

void setup() {
  size(display_width, display_height);
  frameRate(60);
  colorMode(RGB,255,255,255,100);
 
	// initialize the map
	// since this is a volume raycaster we can do fun walls so we use curves, ellipse and more :)
	pg_map = createGraphics(board_width, board_height);
	pg_map.beginDraw();
	pg_map.noFill();
	pg_map.stroke(255);
	pg_map.rect(0, 0, board_width - 1, board_height - 1);
	pg_map.bezier(85, 20, 10, 10, 90, 90, 15, 80);
	pg_map.bezier(85 * 2, 20 * 2, 10 * 2, 10 * 2, 90 * 2, 90 * 2, 15 * 2, 80 * 2);
	pg_map.ellipse(board_width / 1.25, board_height / 1.25, 16, 16);
	pg_map.triangle(192, 200, 100, 210, 95, 240);
	pg_map.endDraw();
	pg_map.loadPixels();
	
/* // classical array
	boards = new float[board_size];

  for (int i = 0; i < board_width; i += 1) {
    boards[i] = 1;
    boards[i + board_width * (board_height - 1)] = 1;
  }
 
  for (int i = 0; i < board_height; i += 1) {
    boards[i * board_width] = 1;
    boards[(board_width - 1) + i * board_width] = 1;
  }
	
	for (int i = 0; i < 360; i += 1) {
		boards[(int)(board_width / 4 + 4 * cos(radians(i))) + (int)(board_height / 4 + 4 * sin(radians(i))) * board_width] = 1;
		boards[(int)(board_width / 4 + 4 * cos(radians(i))) + (int)(board_height - board_height / 4 + 4 * sin(radians(i))) * board_width] = 1;
		boards[(int)(board_width - board_width / 4 + 4 * cos(radians(i))) + (int)(board_height / 4 + 4 * sin(radians(i))) * board_width] = 1;
		boards[(int)(board_width - board_width / 4 + 4 * cos(radians(i))) + (int)(board_height - board_height / 4 + 4 * sin(radians(i))) * board_width] = 1;
	}
*/
	
	// pre-calculate all ray directions for the player FOV
	raydir = new PVector[width * 360];
	
	for (int i = 0; i < (width * 360); i += 1) {
		int rotation_degree = int((float)i / width);

		float ri = i % width;
		float norm_i = ri / width;
		
		raydir[i] = new PVector(
									cos(radians(rotation_degree) - radians(player.fov / 2) + radians(player.fov) * norm_i),
		            	sin(radians(rotation_degree) - radians(player.fov / 2) + radians(player.fov) * norm_i));
	}
	
	// latest rays are stored here (used to display the player FOV in the minimap)
	latest_rays = new PVector[width];
	for (int i = 0; i < width; i += 1) {
		latest_rays[i] = new PVector(0, 0);
	}
	
	textures = loadImage(""wolftextures.png"");
	textures.loadPixels();
	
	pg_minimap = createGraphics(minimap_width, minimap_height);
	
	updateMinimap();
	
}

void draw() {
  background(0);
 
  noStroke();
 
  raycast();
	
	if (edit_mode) {
		
	} else {
  	render_minimap();
	}
 
  player.rotation = ((float)mouseX / width * 2 * 359) % 360;
	
	keyPressCheck();
}

// core algorithm
void raycast() {
  int i = 0, j = 0;
	
	int rot_i = int(player.rotation) * width;
	
	// scan the screen horizontally and raycast from the defined player FOV
  for (i = 0; i < width; i += stepping_x) {
    float norm_i = (float)i / width;
		
		// we use pre-computed ray directions (see below for the raw formula)
		PVector ray_direction = raydir[i + rot_i];
   
    float dx = ray_direction.x;
		//float dx = cos(radians(player.rotation) - radians(player.fov / 2) + radians(player.fov) * norm_i);
    float dy = ray_direction.y;
		//float dy = sin(radians(player.rotation) - radians(player.fov / 2) + radians(player.fov) * norm_i);
		
    float px = player.position.x;
    float py = player.position.y;
		
		// ""A Fast Voxel Traversal Algorithm for Ray Tracing"" paper by John Amanatides and Andrew Woo
		// basically a rather obvious way to cross each cells at each steps!
		int mx = floor(px);
		int my = floor(py);
		
		float step_x = (ray_direction.x >= 0) ? 1 : -1; 
		float step_y = (ray_direction.y >= 0) ? 1 : -1; 
		
		float tmax_x = (float)((mx + step_x) - px) / dx;
		float tmax_y = (float)((my + step_y) - py) / dy;
		
		float delta_x = step_x / dx;
		float delta_y = step_y / dy;
		//
		
		int step = 0;
		
		// traverse the map & check for collisions
    while (step < max_ray_step) {
      //float result = boards[mx + my * board_width];
			float result = brightness(pg_map.pixels[mx + my * board_width]);
     
      if (result > 0) {					
				// compute distance with corrected perspective
				// if the perspective is not corrected this will produce fish-eye / distorded walls effect because rays on the edge of the screen need to travel 'further' than the middle rays one 
				float ddx = abs(player.position.x - mx);
				float ddy = abs(player.position.y - my);
				
        float dist = sqrt(ddx * ddx + ddy * ddy) * (cos(-radians(player.fov / 2) + radians(player.fov) * norm_i));
        float norm_dist = dist / max(board_width, board_height) / 1.25;
				float inorm_dist = max(1 - norm_dist, 0.01);
				
				// determine horizontal texture coordinate (note : not really correct!!)
				float tu = abs(mx - my);

				// determine wall height from the computed distance
				// dst_proj_plane is just a value related to the FOV, it relate to the player / projection plane distance
        float wh = wall_height / dist * player.dst_proj_plane;
				// now determine the vertical wall start position
        float wall_start_y = height / 2 - wh / 2 + player.height;
				
				// clamp to [0, display_height], we will use these so we don't overdraw outside the screen... (thus increasing performances)
				int clamped_start_y = max(0, wall_start_y);
				int clamped_wh = min(wh, height);
				
				// draw wall (untextured)
				/*
				fill(inorm_dist * 255, 0, 0, 255);
        rect(i, wall_start_y, stepping_x, wh);
				*/
				
				// simple ceiling
				/*int ceil_start = height / 2;
				for (j = ceil_start; j > -ceil_stepping; j -= ceil_stepping) {
					float inorm_j = (float)j / (height / 2);
					float norm_j = 1. - inorm_j;
					float ceil_brightness = 255 * (inorm_j);

					fill(0, 0, ceil_brightness, 64);
					rect(i, j, stepping_x, ceil_stepping);
				}*/
				
				// can change texture here (64, 128, 192 etc)
				int u = (int(tu) % (textures.width / 8) + 64);
				
	      // draw wall (textured)
				for (j = clamped_start_y; j < clamped_start_y + clamped_wh; j += texture_stepping) {
					float norm_j = (float)(j - wall_start_y) / wh;
					color c = textures.pixels[u + (int(norm_j * textures.height) % textures.height) * textures.width];
					fill(red(c) * inorm_dist, green(c) * inorm_dist, blue(c) * inorm_dist);
        	rect(i, j, stepping_x, texture_stepping);
					
					float cm = norm_dist * norm_j * 2;
					
					// mirrored :)
					/*fill(red(c) * cm, green(c) * cm, blue(c) * cm);
					rect(i, (wall_start_y + wh) * 2 - j, stepping_x, texture_stepping);*/
				}
				
				// draw ceiling
				/*int ceil_start = wall_start_y - ceil_stepping;
				for (j = ceil_start; j > -ceil_stepping; j -= ceil_stepping) {
					float inorm_j = (float)j / wall_start_y;
					float norm_j = 1. - inorm_j;
					float ceil_brightness = 255 * (inorm_j * inorm_dist * 2);

					fill(0, 0, ceil_brightness, 64);
					rect(i, j, stepping_x, ceil_stepping);
				}*/
				
				// draw floor
				int floor_start = wh + wall_start_y;
				for (j = floor_start; j < height; j += floor_stepping) {
					float norm_j = (float)(j - floor_start) / (height - floor_start);
					float inorm_j = 1. - norm_j;
					float floor_brightness = 255 * norm_j;
					
					fill(floor_brightness, 0, 0, 64);
					rect(i, j, stepping_x, floor_stepping);
				}
				
				// store ray for later use (minimap FOV)
				latest_rays[i].x = mx;
				latest_rays[i].y = my;
				
        break;
      }

			// show complete raycast FOV on minimap (pixels perfect but slow and should be computed outside to fix order issues)
      //fill(0, 255, 0, 64);
      //rect(int(px * minimap_scale_x + width - minimap_width_m1), int(py * minimap_scale_y), 1, 1);
			
			/*
			// naive way to raycast : go along the direction as a fixed step (but it may take many steps to cross a single cell)
			// if you want to use this you must replace mx/my by px/py in that loop
      px += dx;
      py += dy;
			*/
			
			// ""A Fast Voxel Traversal Algorithm for Ray Tracing"" paper by John Amanatides and Andrew Woo
			// basically a rather obvious way to cross each cells at each steps!
			if (tmax_x < tmax_y) {
				tmax_x += delta_x;
				mx += step_x;
				side = 0;
			} else {
				tmax_y += delta_y;
				my += step_y;
				side = 1;
			}
			//
			
			step += 1;
    }
  }
}

// physics logic
void keyPressCheck() {
  if (keyPressed) {
		int rot_i = int(player.rotation) * width;
		
		PVector ray_direction = raydir[width / 2 + rot_i];
		
		PVector velocity = new PVector(ray_direction.x, ray_direction.y);
		velocity.mult(player.vel_multiplier);
		
		int dir = 1;
		if (player.rotation > 90 || player.rotation < 180) {
			dir = -1;
		}
		
		PVector newPosition = new PVector(player.position.x, player.position.y);
		
    if (keyCode == UP) {
			newPosition.add(velocity);
		} else if (keyCode == DOWN) {
			newPosition.sub(velocity);
		}
		
		if (keyCode == LEFT) {
			newPosition.x -= cos(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
			newPosition.y -= sin(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
		} else if (keyCode == RIGHT) {
			newPosition.x += cos(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
			newPosition.y += sin(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
		}
		
		if (newPosition.x < board_width - 1 && newPosition.y < board_height - 1 &&
				newPosition.x > 0 && newPosition.y > 0) {
			player.position = newPosition;
		}
	}
}

void keyReleased() {
	if (keyCode == ENTER || keyCode == RETURN) {
		edit_mode += 1;
		edit_mode %= 2;
	}
}

// update minimap buffer (so we don't compute the minimap rendering it at every frames)
void updateMinimap() {
	pg_minimap.beginDraw();
	pg_minimap.noStroke();
	pg_minimap.fill(255);
  for (int i = 0; i < board_size; i += int(board_width / minimap_width)) {
    //float w = boards[i];
		float w = brightness(pg_map.pixels[i]);
   
    if (w > 0.5) {
			int x = i % board_width;
			int y = int((float)i / board_width);

			x = int((float)x * minimap_scale_x);
			y = int((float)y * minimap_scale_y);
     
      pg_minimap.rect(x, y, 1, 1);
    }
  }
	pg_minimap.endDraw();
}

void render_minimap() {
	int minimap_offset_x = width - minimap_width_m1;

	image(pg_minimap, minimap_offset_x, 0);
	
	// player FOV on the minimap from all the latest rays casted (fast but not pixel perfect)
	stroke(255, 0, 0);
	for (int i = 0; i < width; i += minimap_fov_step) {
		PVector ray = latest_rays[i];
		line(player.position.x * minimap_scale_x + minimap_offset_x,
				 player.position.y * minimap_scale_y,
				 ray.x * minimap_scale_x + minimap_offset_x,
				 ray.y * minimap_scale_y);
	}
	noStroke();
	
	// player position
	fill(255, 255, 0);
	ellipse(player.position.x * minimap_scale_x + minimap_offset_x,
			 player.position.y * minimap_scale_y, 6, 6);
}"
"606206","2D volume raycasting","mySketch","/**
  * Custom raycaster done for fun on a phone (APDE Android app.) while commuting.
	* Improved afterward on desktop because APDE is buggy and crashed as the sketch complexity increased ! :)
	*
	* This is actually a 2D volume raycaster as map objects are as-is (not blocky) thus it allow curved walls and any wall shapes actually for free...
	* It is however a bit slower than a ""blocky"" raycaster, will take way more memory and the texturing is buggy on highly curved walls.
	* There is two methods implemented for raycast :
	*   - A naive not optimal one which walk the grid in the view direction through fixed step
	*   - An optimal one which walk the grid in the view direction through each cells
	*
	* Optimizations done :
	*   - walk the grid in the view direction through each cells
	*   - clamp slice start y / height by the display height (so we don't draw unnecessarily outside the display)
	*   - pre-compute rays direction through a lookup table (this however make camera rotation a bit less smooth)
	*
	* The walls are mirrored on the y axis so we get a cheap floor mirror :p
	*
	* One could extend this to cast rays in a more free ways (in all direction: 3D) and this would basically become a volume raycaster so voxels yeh! :)
	*
	* An overview of old-school raycasting methods (compared to this one) :
	* 	A blocky raycaster like Wolfenstein 3D isn't really far from this: 
	*     - the map informations would just need to have a defined size when rendering them, this would make the world blocky and fix issue with texturing as well!
	* 	A high-quality raycaster (a la Duke Nukem 3D / Build engine) isn't really far from this as well :
	*   	- The map informations (as a bitmap) would need to be dropped for a map informations only made of lines / curves, this would fix the texturing problem on highly curved walls
	*     - This would however come with some problems related to culling which were fixed using methods such as portal rendering back in the days
	*   A 'voxel' landscape can be done easily by adapting this (see my other sketch) :
	*     - Send rays from far to near
	*     - Rays are not stopped once they hit something (they walk on the heightmap)
	*     - All cells traversed by the ray are drawn (could say the ray always hit something)
	*   Raytracing :
	*     - Same as raycasting except you continue sending rays once they hit something (you bounce them off, compute shading from lights etc)
	*     - Drop bitmap representation (this is really the definition of Volumetric in all Voxel methods)
	*
	* This use Wolfenstein 3D textures.
	*/

static int display_width = 640;
static int display_height = 480;

static int board_width = 256;
static int board_height = board_width; // linked
static int board_size = board_width * board_height;

// typically the diagonal of the map so we stop any rays casted outside...
// but this can also be used for performances, this is the camera z clipping so with fog and this we can speed the rendering up :)
static int max_ray_step = board_width * 2;

static int wall_height = 32;

static int player_fov = 60;

static int minimap_width = 128;
static int minimap_height = minimap_width; // linked
static int minimap_width_m1 = minimap_width - 1;
static int minimap_fov_step = 88;
static float minimap_scale_x = (float)minimap_width / board_width;
static float minimap_scale_y = (float)minimap_height / board_height;

// increase for more performances
static int stepping_x = 8;
static int floor_stepping = 8;
static int ceil_stepping = 8;
static int texture_stepping = 2;

int edit_mode = 0;

float boards[];
// we use this actually instead of ""boards"" to store the map data
// this allow to draw our map directly with Processing shapes since we are not restricted to perpendicular walls :)
PGraphics pg_map;

PVector raydir[];
PVector latest_rays[];

PImage textures;

PGraphics pg_minimap;

// an entity class which hold player data and other entities
class Entity {
  PVector position;
  float rotation;
  float fov;
	float dst_proj_plane;
	float vel_multiplier = 2;
  float height = 50;
 
  Entity(PVector position, float rotation, float fov) {
    this.position = position;
    this.rotation = rotation;
    this.fov = fov;
		this.dst_proj_plane = 160 / tan(radians(fov / 2));
  }
};

Entity player = new Entity(
    new PVector(board_width / 2,
                board_height / 2), 90, player_fov);

void setup() {
  size(display_width, display_height);
  frameRate(60);
  colorMode(RGB,255,255,255,100);
 
	// initialize the map
	// since this is a volume raycaster we can do fun walls so we use curves, ellipse and more :)
	pg_map = createGraphics(board_width, board_height);
	pg_map.beginDraw();
	pg_map.noFill();
	pg_map.stroke(255);
	pg_map.rect(0, 0, board_width - 1, board_height - 1);
	pg_map.bezier(85, 20, 10, 10, 90, 90, 15, 80);
	pg_map.bezier(85 * 2, 20 * 2, 10 * 2, 10 * 2, 90 * 2, 90 * 2, 15 * 2, 80 * 2);
	pg_map.ellipse(board_width / 1.25, board_height / 1.25, 16, 16);
	pg_map.triangle(192, 200, 100, 210, 95, 240);
	pg_map.endDraw();
	pg_map.loadPixels();
	
/* // classical array
	boards = new float[board_size];

  for (int i = 0; i < board_width; i += 1) {
    boards[i] = 1;
    boards[i + board_width * (board_height - 1)] = 1;
  }
 
  for (int i = 0; i < board_height; i += 1) {
    boards[i * board_width] = 1;
    boards[(board_width - 1) + i * board_width] = 1;
  }
	
	for (int i = 0; i < 360; i += 1) {
		boards[(int)(board_width / 4 + 4 * cos(radians(i))) + (int)(board_height / 4 + 4 * sin(radians(i))) * board_width] = 1;
		boards[(int)(board_width / 4 + 4 * cos(radians(i))) + (int)(board_height - board_height / 4 + 4 * sin(radians(i))) * board_width] = 1;
		boards[(int)(board_width - board_width / 4 + 4 * cos(radians(i))) + (int)(board_height / 4 + 4 * sin(radians(i))) * board_width] = 1;
		boards[(int)(board_width - board_width / 4 + 4 * cos(radians(i))) + (int)(board_height - board_height / 4 + 4 * sin(radians(i))) * board_width] = 1;
	}
*/
	
	// pre-calculate all ray directions for the player FOV
	raydir = new PVector[width * 360];
	
	for (int i = 0; i < (width * 360); i += 1) {
		int rotation_degree = int((float)i / width);

		float ri = i % width;
		float norm_i = ri / width;
		
		raydir[i] = new PVector(
									cos(radians(rotation_degree) - radians(player.fov / 2) + radians(player.fov) * norm_i),
		            	sin(radians(rotation_degree) - radians(player.fov / 2) + radians(player.fov) * norm_i));
	}
	
	// latest rays are stored here (used to display the player FOV in the minimap)
	latest_rays = new PVector[width];
	for (int i = 0; i < width; i += 1) {
		latest_rays[i] = new PVector(0, 0);
	}
	
	textures = loadImage(""wolftextures.png"");
	textures.loadPixels();
	
	pg_minimap = createGraphics(minimap_width, minimap_height);
	
	updateMinimap();
	
}

void draw() {
  background(0);
 
  noStroke();
 
  raycast();
	
	if (edit_mode) {
		
	} else {
  	render_minimap();
	}
 
  player.rotation = ((float)mouseX / width * 2 * 359) % 360;
	
	keyPressCheck();
}

// core algorithm
void raycast() {
  int i = 0, j = 0;
	
	int rot_i = int(player.rotation) * width;
	
	// scan the screen horizontally and raycast from the defined player FOV
  for (i = 0; i < width; i += stepping_x) {
    float norm_i = (float)i / width;
		
		// we use pre-computed ray directions (see below for the raw formula)
		PVector ray_direction = raydir[i + rot_i];
   
    float dx = ray_direction.x;
		//float dx = cos(radians(player.rotation) - radians(player.fov / 2) + radians(player.fov) * norm_i);
    float dy = ray_direction.y;
		//float dy = sin(radians(player.rotation) - radians(player.fov / 2) + radians(player.fov) * norm_i);
		
    float px = player.position.x;
    float py = player.position.y;
		
		// ""A Fast Voxel Traversal Algorithm for Ray Tracing"" paper by John Amanatides and Andrew Woo
		// basically a rather obvious way to cross each cells at each steps!
		int mx = floor(px);
		int my = floor(py);
		
		float step_x = (ray_direction.x >= 0) ? 1 : -1; 
		float step_y = (ray_direction.y >= 0) ? 1 : -1; 
		
		float tmax_x = (float)((mx + step_x) - px) / dx;
		float tmax_y = (float)((my + step_y) - py) / dy;
		
		float delta_x = step_x / dx;
		float delta_y = step_y / dy;
		//
		
		int step = 0;
		
		// traverse the map & check for collisions
    while (step < max_ray_step) {
      //float result = boards[mx + my * board_width];
			float result = brightness(pg_map.pixels[mx + my * board_width]);
     
      if (result > 0) {					
				// compute distance with corrected perspective
				// if the perspective is not corrected this will produce fish-eye / distorded walls effect because rays on the edge of the screen need to travel 'further' than the middle rays one 
				float ddx = abs(player.position.x - mx);
				float ddy = abs(player.position.y - my);
				
        float dist = sqrt(ddx * ddx + ddy * ddy) * (cos(-radians(player.fov / 2) + radians(player.fov) * norm_i));
        float norm_dist = dist / max(board_width, board_height) / 1.25;
				float inorm_dist = max(1 - norm_dist, 0.01);
				
				// determine horizontal texture coordinate (note : not really correct!!)
				float tu = abs(mx - my);

				// determine wall height from the computed distance
				// dst_proj_plane is just a value related to the FOV, it relate to the player / projection plane distance
        float wh = wall_height / dist * player.dst_proj_plane;
				// now determine the vertical wall start position
        float wall_start_y = height / 2 - wh / 2 + player.height;
				
				// clamp to [0, display_height], we will use these so we don't overdraw outside the screen... (thus increasing performances)
				int clamped_start_y = max(0, wall_start_y);
				int clamped_wh = min(wh, height);
				
				// draw wall (untextured)
				/*
				fill(inorm_dist * 255, 0, 0, 255);
        rect(i, wall_start_y, stepping_x, wh);
				*/
				
				// simple ceiling
				/*int ceil_start = height / 2;
				for (j = ceil_start; j > -ceil_stepping; j -= ceil_stepping) {
					float inorm_j = (float)j / (height / 2);
					float norm_j = 1. - inorm_j;
					float ceil_brightness = 255 * (inorm_j);

					fill(0, 0, ceil_brightness, 64);
					rect(i, j, stepping_x, ceil_stepping);
				}*/
				
				// can change texture here (64, 128, 192 etc)
				int u = (int(tu) % (textures.width / 8) + 64);
				
	      // draw wall (textured)
				for (j = clamped_start_y; j < clamped_start_y + clamped_wh; j += texture_stepping) {
					float norm_j = (float)(j - wall_start_y) / wh;
					color c = textures.pixels[u + (int(norm_j * textures.height) % textures.height) * textures.width];
					fill(red(c) * inorm_dist, green(c) * inorm_dist, blue(c) * inorm_dist);
        	rect(i, j, stepping_x, texture_stepping);
					
					float cm = norm_dist * norm_j * 2;
					
					// mirrored :)
					fill(red(c) * cm, green(c) * cm, blue(c) * cm);
					rect(i, (wall_start_y + wh) * 2 - j, stepping_x, texture_stepping);
				}
				
				// draw ceiling
				/*int ceil_start = wall_start_y - ceil_stepping;
				for (j = ceil_start; j > -ceil_stepping; j -= ceil_stepping) {
					float inorm_j = (float)j / wall_start_y;
					float norm_j = 1. - inorm_j;
					float ceil_brightness = 255 * (inorm_j * inorm_dist * 2);

					fill(0, 0, ceil_brightness, 64);
					rect(i, j, stepping_x, ceil_stepping);
				}*/
				
				// draw floor
				int floor_start = wh + wall_start_y;
				for (j = floor_start; j < height; j += floor_stepping) {
					float norm_j = (float)(j - floor_start) / (height - floor_start);
					float inorm_j = 1. - norm_j;
					float floor_brightness = 255 * norm_j;
					
					fill(floor_brightness, 0, 0, 64);
					rect(i, j, stepping_x, floor_stepping);
				}
				
				// store ray for later use (minimap FOV)
				latest_rays[i].x = mx;
				latest_rays[i].y = my;
				
        break;
      }

			// show complete raycast FOV on minimap (pixels perfect but slow and should be computed outside to fix order issues)
      //fill(0, 255, 0, 64);
      //rect(int(px * minimap_scale_x + width - minimap_width_m1), int(py * minimap_scale_y), 1, 1);
			
			/*
			// naive way to raycast : go along the direction as a fixed step (but it may take many steps to cross a single cell)
			// if you want to use this you must replace mx/my by px/py in that loop
      px += dx;
      py += dy;
			*/
			
			// ""A Fast Voxel Traversal Algorithm for Ray Tracing"" paper by John Amanatides and Andrew Woo
			// basically a rather obvious way to cross each cells at each steps!
			if (tmax_x < tmax_y) {
				tmax_x += delta_x;
				mx += step_x;
				side = 0;
			} else {
				tmax_y += delta_y;
				my += step_y;
				side = 1;
			}
			//
			
			step += 1;
    }
  }
}

// physics logic
void keyPressCheck() {
  if (keyPressed) {
		int rot_i = int(player.rotation) * width;
		
		PVector ray_direction = raydir[width / 2 + rot_i];
		
		PVector velocity = new PVector(ray_direction.x, ray_direction.y);
		velocity.mult(player.vel_multiplier);
		
		int dir = 1;
		if (player.rotation > 90 || player.rotation < 180) {
			dir = -1;
		}
		
		PVector newPosition = new PVector(player.position.x, player.position.y);
		
    if (keyCode == UP) {
			newPosition.add(velocity);
		} else if (keyCode == DOWN) {
			newPosition.sub(velocity);
		}
		
		if (keyCode == LEFT) {
			newPosition.x -= cos(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
			newPosition.y -= sin(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
		} else if (keyCode == RIGHT) {
			newPosition.x += cos(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
			newPosition.y += sin(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
		}
		
		if (newPosition.x < board_width - 1 && newPosition.y < board_height - 1 &&
				newPosition.x > 0 && newPosition.y > 0) {
			player.position = newPosition;
		}
	}
}

void keyReleased() {
	if (keyCode == ENTER || keyCode == RETURN) {
		edit_mode += 1;
		edit_mode %= 2;
	}
}

// update minimap buffer (so we don't compute the minimap rendering it at every frames)
void updateMinimap() {
	pg_minimap.beginDraw();
	pg_minimap.noStroke();
	pg_minimap.fill(255);
  for (int i = 0; i < board_size; i += int(board_width / minimap_width)) {
    //float w = boards[i];
		float w = brightness(pg_map.pixels[i]);
   
    if (w > 0.5) {
			int x = i % board_width;
			int y = int((float)i / board_width);

			x = int((float)x * minimap_scale_x);
			y = int((float)y * minimap_scale_y);
     
      pg_minimap.rect(x, y, 1, 1);
    }
  }
	pg_minimap.endDraw();
}

void render_minimap() {
	int minimap_offset_x = width - minimap_width_m1;

	image(pg_minimap, minimap_offset_x, 0);
	
	// player FOV on the minimap from all the latest rays casted (fast but not pixel perfect)
	stroke(255, 0, 0);
	for (int i = 0; i < width; i += minimap_fov_step) {
		PVector ray = latest_rays[i];
		line(player.position.x * minimap_scale_x + minimap_offset_x,
				 player.position.y * minimap_scale_y,
				 ray.x * minimap_scale_x + minimap_offset_x,
				 ray.y * minimap_scale_y);
	}
	noStroke();
	
	// player position
	fill(255, 255, 0);
	ellipse(player.position.x * minimap_scale_x + minimap_offset_x,
			 player.position.y * minimap_scale_y, 6, 6);
}"
"606206","2D volume raycasting","mySketch","/**
  * Custom raycaster done for fun on a phone (APDE Android app.) while commuting.
	* Improved afterward on desktop because APDE is buggy and crashed as the sketch complexity increased ! :)
	*
	* This is actually a 2D volume raycaster as map objects are as-is (not blocky) thus it allow curved walls and any wall shapes actually for free...
	* It is however a bit slower than a ""blocky"" raycaster, will take way more memory and the texturing is buggy on highly curved walls.
	* There is two methods implemented for raycast :
	*   - A naive not optimal one which walk the grid in the view direction through fixed step
	*   - An optimal one which walk the grid in the view direction through each cells
	*
	* Optimizations done :
	*   - walk the grid in the view direction through each cells
	*   - clamp slice start y / height by the display height (so we don't draw unnecessarily outside the display)
	*   - pre-compute rays direction through a lookup table (this however make camera rotation a bit less smooth)
	*
	* The walls are mirrored on the y axis so we get a cheap floor mirror :p
	*
	* One could extend this to cast rays in a more free ways (in all direction: 3D) and this would basically become a volume raycaster so voxels yeh! :)
	*
	* An overview of old-school raycasting methods (compared to this one) :
	* 	A blocky raycaster like Wolfenstein 3D isn't really far from this: 
	*     - the map informations would just need to have a defined size when rendering them, this would make the world blocky and fix issue with texturing as well!
	* 	A high-quality raycaster (a la Duke Nukem 3D / Build engine) isn't really far from this as well :
	*   	- The map informations (as a bitmap) would need to be dropped for a map informations only made of lines / curves, this would fix the texturing problem on highly curved walls
	*     - This would however come with some problems related to culling which were fixed using methods such as portal rendering back in the days
	*   A 'voxel' landscape can be done easily by adapting this (see my other sketch) :
	*     - Send rays from far to near
	*     - Rays are not stopped once they hit something (they walk on the heightmap)
	*     - All cells traversed by the ray are drawn (could say the ray always hit something)
	*   Raytracing :
	*     - Same as raycasting except you continue sending rays once they hit something (you bounce them off, compute shading from lights etc)
	*     - Drop bitmap representation (this is really the definition of Volumetric in all Voxel methods, the data is volumetric)
	*
	* This use Wolfenstein 3D textures.
	*/

static int display_width = 640;
static int display_height = 480;

static int board_width = 256;
static int board_height = board_width; // linked
static int board_size = board_width * board_height;

// typically the diagonal of the map so we stop any rays casted outside...
// but this can also be used for performances, this is the camera z clipping so with fog and this we can speed the rendering up :)
static int max_ray_step = board_width * 2;

static int wall_height = 32;

static int player_fov = 60;

static int minimap_width = 128;
static int minimap_height = minimap_width; // linked
static int minimap_width_m1 = minimap_width - 1;
static int minimap_fov_step = 88;
static float minimap_scale_x = (float)minimap_width / board_width;
static float minimap_scale_y = (float)minimap_height / board_height;

// increase for more performances
static int stepping_x = 8;
static int floor_stepping = 8;
static int ceil_stepping = 8;
static int texture_stepping = 2;

int edit_mode = 0;

float boards[];
// we use this actually instead of ""boards"" to store the map data
// this allow to draw our map directly with Processing shapes since we are not restricted to perpendicular walls :)
PGraphics pg_map;

PVector raydir[];
PVector latest_rays[];

PImage textures;

PGraphics pg_minimap;

// an entity class which hold player data and other entities
class Entity {
  PVector position;
  float rotation;
  float fov;
	float dst_proj_plane;
	float vel_multiplier = 2;
  float height = 50;
 
  Entity(PVector position, float rotation, float fov) {
    this.position = position;
    this.rotation = rotation;
    this.fov = fov;
		this.dst_proj_plane = 160 / tan(radians(fov / 2));
  }
};

Entity player = new Entity(
    new PVector(board_width / 2,
                board_height / 2), 90, player_fov);

void setup() {
  size(display_width, display_height);
  frameRate(60);
  colorMode(RGB,255,255,255,100);
 
	// initialize the map
	// since this is a volume raycaster we can do fun walls so we use curves, ellipse and more :)
	pg_map = createGraphics(board_width, board_height);
	pg_map.beginDraw();
	pg_map.noFill();
	pg_map.stroke(255);
	pg_map.rect(0, 0, board_width - 1, board_height - 1);
	pg_map.bezier(85, 20, 10, 10, 90, 90, 15, 80);
	pg_map.bezier(85 * 2, 20 * 2, 10 * 2, 10 * 2, 90 * 2, 90 * 2, 15 * 2, 80 * 2);
	pg_map.ellipse(board_width / 1.25, board_height / 1.25, 16, 16);
	pg_map.triangle(192, 200, 100, 210, 95, 240);
	pg_map.endDraw();
	pg_map.loadPixels();
	
/* // classical array
	boards = new float[board_size];

  for (int i = 0; i < board_width; i += 1) {
    boards[i] = 1;
    boards[i + board_width * (board_height - 1)] = 1;
  }
 
  for (int i = 0; i < board_height; i += 1) {
    boards[i * board_width] = 1;
    boards[(board_width - 1) + i * board_width] = 1;
  }
	
	for (int i = 0; i < 360; i += 1) {
		boards[(int)(board_width / 4 + 4 * cos(radians(i))) + (int)(board_height / 4 + 4 * sin(radians(i))) * board_width] = 1;
		boards[(int)(board_width / 4 + 4 * cos(radians(i))) + (int)(board_height - board_height / 4 + 4 * sin(radians(i))) * board_width] = 1;
		boards[(int)(board_width - board_width / 4 + 4 * cos(radians(i))) + (int)(board_height / 4 + 4 * sin(radians(i))) * board_width] = 1;
		boards[(int)(board_width - board_width / 4 + 4 * cos(radians(i))) + (int)(board_height - board_height / 4 + 4 * sin(radians(i))) * board_width] = 1;
	}
*/
	
	// pre-calculate all ray directions for the player FOV
	raydir = new PVector[width * 360];
	
	for (int i = 0; i < (width * 360); i += 1) {
		int rotation_degree = int((float)i / width);

		float ri = i % width;
		float norm_i = ri / width;
		
		raydir[i] = new PVector(
									cos(radians(rotation_degree) - radians(player.fov / 2) + radians(player.fov) * norm_i),
		            	sin(radians(rotation_degree) - radians(player.fov / 2) + radians(player.fov) * norm_i));
	}
	
	// latest rays are stored here (used to display the player FOV in the minimap)
	latest_rays = new PVector[width];
	for (int i = 0; i < width; i += 1) {
		latest_rays[i] = new PVector(0, 0);
	}
	
	textures = loadImage(""wolftextures.png"");
	textures.loadPixels();
	
	pg_minimap = createGraphics(minimap_width, minimap_height);
	
	updateMinimap();
	
}

void draw() {
  background(0);
 
  noStroke();
 
  raycast();
	
	if (edit_mode) {
		
	} else {
  	render_minimap();
	}
 
  player.rotation = ((float)mouseX / width * 2 * 359) % 360;
	
	keyPressCheck();
}

// core algorithm
void raycast() {
  int i = 0, j = 0;
	
	int rot_i = int(player.rotation) * width;
	
	// scan the screen horizontally and raycast from the defined player FOV
  for (i = 0; i < width; i += stepping_x) {
    float norm_i = (float)i / width;
		
		// we use pre-computed ray directions (see below for the raw formula)
		PVector ray_direction = raydir[i + rot_i];
   
    float dx = ray_direction.x;
		//float dx = cos(radians(player.rotation) - radians(player.fov / 2) + radians(player.fov) * norm_i);
    float dy = ray_direction.y;
		//float dy = sin(radians(player.rotation) - radians(player.fov / 2) + radians(player.fov) * norm_i);
		
    float px = player.position.x;
    float py = player.position.y;
		
		// ""A Fast Voxel Traversal Algorithm for Ray Tracing"" paper by John Amanatides and Andrew Woo
		// basically a rather obvious way to cross each cells at each steps!
		int mx = floor(px);
		int my = floor(py);
		
		float step_x = (ray_direction.x >= 0) ? 1 : -1; 
		float step_y = (ray_direction.y >= 0) ? 1 : -1; 
		
		float tmax_x = (float)((mx + step_x) - px) / dx;
		float tmax_y = (float)((my + step_y) - py) / dy;
		
		float delta_x = step_x / dx;
		float delta_y = step_y / dy;
		//
		
		int step = 0;
		
		// traverse the map & check for collisions
    while (step < max_ray_step) {
      //float result = boards[mx + my * board_width];
			float result = brightness(pg_map.pixels[mx + my * board_width]);
     
      if (result > 0) {					
				// compute distance with corrected perspective
				// if the perspective is not corrected this will produce fish-eye / distorded walls effect because rays on the edge of the screen need to travel 'further' than the middle rays one 
				float ddx = abs(player.position.x - mx);
				float ddy = abs(player.position.y - my);
				
        float dist = sqrt(ddx * ddx + ddy * ddy) * (cos(-radians(player.fov / 2) + radians(player.fov) * norm_i));
        float norm_dist = dist / max(board_width, board_height) / 1.25;
				float inorm_dist = max(1 - norm_dist, 0.01);
				
				// determine horizontal texture coordinate (note : not really correct!!)
				float tu = abs(mx - my);

				// determine wall height from the computed distance
				// dst_proj_plane is just a value related to the FOV, it relate to the player / projection plane distance
        float wh = wall_height / dist * player.dst_proj_plane;
				// now determine the vertical wall start position
        float wall_start_y = height / 2 - wh / 2 + player.height;
				
				// clamp to [0, display_height], we will use these so we don't overdraw outside the screen... (thus increasing performances)
				int clamped_start_y = max(0, wall_start_y);
				int clamped_wh = min(wh, height);
				
				// draw wall (untextured)
				/*
				fill(inorm_dist * 255, 0, 0, 255);
        rect(i, wall_start_y, stepping_x, wh);
				*/
				
				// simple ceiling
				/*int ceil_start = height / 2;
				for (j = ceil_start; j > -ceil_stepping; j -= ceil_stepping) {
					float inorm_j = (float)j / (height / 2);
					float norm_j = 1. - inorm_j;
					float ceil_brightness = 255 * (inorm_j);

					fill(0, 0, ceil_brightness, 64);
					rect(i, j, stepping_x, ceil_stepping);
				}*/
				
				// can change texture here (64, 128, 192 etc)
				int u = (int(tu) % (textures.width / 8) + 64);
				
	      // draw wall (textured)
				for (j = clamped_start_y; j < clamped_start_y + clamped_wh; j += texture_stepping) {
					float norm_j = (float)(j - wall_start_y) / wh;
					color c = textures.pixels[u + (int(norm_j * textures.height) % textures.height) * textures.width];
					fill(red(c) * inorm_dist, green(c) * inorm_dist, blue(c) * inorm_dist);
        	rect(i, j, stepping_x, texture_stepping);
					
					float cm = norm_dist * norm_j * 2;
					
					// mirrored :)
					fill(red(c) * cm, green(c) * cm, blue(c) * cm);
					rect(i, (wall_start_y + wh) * 2 - j, stepping_x, texture_stepping);
				}
				
				// draw ceiling
				/*int ceil_start = wall_start_y - ceil_stepping;
				for (j = ceil_start; j > -ceil_stepping; j -= ceil_stepping) {
					float inorm_j = (float)j / wall_start_y;
					float norm_j = 1. - inorm_j;
					float ceil_brightness = 255 * (inorm_j * inorm_dist * 2);

					fill(0, 0, ceil_brightness, 64);
					rect(i, j, stepping_x, ceil_stepping);
				}*/
				
				// draw floor
				int floor_start = wh + wall_start_y;
				for (j = floor_start; j < height; j += floor_stepping) {
					float norm_j = (float)(j - floor_start) / (height - floor_start);
					float inorm_j = 1. - norm_j;
					float floor_brightness = 255 * norm_j;
					
					fill(floor_brightness, 0, 0, 64);
					rect(i, j, stepping_x, floor_stepping);
				}
				
				// store ray for later use (minimap FOV)
				latest_rays[i].x = mx;
				latest_rays[i].y = my;
				
        break;
      }

			// show complete raycast FOV on minimap (pixels perfect but slow and should be computed outside to fix order issues)
      //fill(0, 255, 0, 64);
      //rect(int(px * minimap_scale_x + width - minimap_width_m1), int(py * minimap_scale_y), 1, 1);
			
			/*
			// naive way to raycast : go along the direction as a fixed step (but it may take many steps to cross a single cell)
			// if you want to use this you must replace mx/my by px/py in that loop
      px += dx;
      py += dy;
			*/
			
			// ""A Fast Voxel Traversal Algorithm for Ray Tracing"" paper by John Amanatides and Andrew Woo
			// basically a rather obvious way to cross each cells at each steps!
			if (tmax_x < tmax_y) {
				tmax_x += delta_x;
				mx += step_x;
				side = 0;
			} else {
				tmax_y += delta_y;
				my += step_y;
				side = 1;
			}
			//
			
			step += 1;
    }
  }
}

// physics logic
void keyPressCheck() {
  if (keyPressed) {
		int rot_i = int(player.rotation) * width;
		
		PVector ray_direction = raydir[width / 2 + rot_i];
		
		PVector velocity = new PVector(ray_direction.x, ray_direction.y);
		velocity.mult(player.vel_multiplier);
		
		int dir = 1;
		if (player.rotation > 90 || player.rotation < 180) {
			dir = -1;
		}
		
		PVector newPosition = new PVector(player.position.x, player.position.y);
		
    if (keyCode == UP) {
			newPosition.add(velocity);
		} else if (keyCode == DOWN) {
			newPosition.sub(velocity);
		}
		
		if (keyCode == LEFT) {
			newPosition.x -= cos(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
			newPosition.y -= sin(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
		} else if (keyCode == RIGHT) {
			newPosition.x += cos(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
			newPosition.y += sin(radians(player.rotation) - PI/2) * player.vel_multiplier * dir;
		}
		
		if (newPosition.x < board_width - 1 && newPosition.y < board_height - 1 &&
				newPosition.x > 0 && newPosition.y > 0) {
			player.position = newPosition;
		}
	}
}

void keyReleased() {
	if (keyCode == ENTER || keyCode == RETURN) {
		edit_mode += 1;
		edit_mode %= 2;
	}
}

// update minimap buffer (so we don't compute the minimap rendering it at every frames)
void updateMinimap() {
	pg_minimap.beginDraw();
	pg_minimap.noStroke();
	pg_minimap.fill(255);
  for (int i = 0; i < board_size; i += int(board_width / minimap_width)) {
    //float w = boards[i];
		float w = brightness(pg_map.pixels[i]);
   
    if (w > 0.5) {
			int x = i % board_width;
			int y = int((float)i / board_width);

			x = int((float)x * minimap_scale_x);
			y = int((float)y * minimap_scale_y);
     
      pg_minimap.rect(x, y, 1, 1);
    }
  }
	pg_minimap.endDraw();
}

void render_minimap() {
	int minimap_offset_x = width - minimap_width_m1;

	image(pg_minimap, minimap_offset_x, 0);
	
	// player FOV on the minimap from all the latest rays casted (fast but not pixel perfect)
	stroke(255, 0, 0);
	for (int i = 0; i < width; i += minimap_fov_step) {
		PVector ray = latest_rays[i];
		line(player.position.x * minimap_scale_x + minimap_offset_x,
				 player.position.y * minimap_scale_y,
				 ray.x * minimap_scale_x + minimap_offset_x,
				 ray.y * minimap_scale_y);
	}
	noStroke();
	
	// player position
	fill(255, 255, 0);
	ellipse(player.position.x * minimap_scale_x + minimap_offset_x,
			 player.position.y * minimap_scale_y, 6, 6);
}"
"597773","Patchwork","mySketch","/*
  The oldschool fire/smoke/cloud effect using feedback and perlin noise
*/

// speed / quality control
int step_x = 8;
int step_y = 8;

float xmotion = 8.8;
float ymotion = 2.2;

void draw_func() {
	noStroke();
	
  fill(0, 0, 0, 2);
  rect(0, 0, width, height);

	for (int x = 0; x < width; x += step_x) {
		for (int y = 0; y < height; y += step_y) {
			float norm_y = y / height;
			
			// convection is done by moving 3d noise
			noiseDetail(7, 0.75);
			float pn = noise(x / width, y / height + xmotion, ymotion / 8);
			// we subtract it with another to make it more interesting
			noiseDetail(3, 0.45);
			pn -= noise((width - x) / width, (height - y) / height - xmotion / 2, ymotion / 2) * 1.5;
			
			// make the noise more interesting
			float n = abs(max(pow(11 * pn, pn) * 38 * ((y - (height / 2 - (height / 2))) / (height)), 1.));
			
			// hue palette range is 0 / 60, saturation is adjusted from the height so that plasma turn into regular smoke
			fill(min(n / 10, 60), 255 * (0.25 + norm_y / 1.5), n, 32);
			rect(x, y, step_x, step_y);
			
			// smooth it out by adding randomness, this improve quality and is used to counter the high stepping effect
			rect(x + random(-8, 8), y + random(-8, 8), step_x, step_y);
			rect(x + random(-8, 8), y + random(-8, 8), step_x, step_y);
			rect(x + random(-8, 8), y + random(-8, 8), step_x, step_y);
			rect(x + random(-8, 8), y + random(-8, 8), step_x, step_y);
		}
	}
	
	xmotion += 0.005;
	ymotion += 0.008;
}

void setup() {
  size(800, 400);

  frameRate(60); 

  background(0);
	
	//smooth();
	
	colorMode(HSB, 360, 256, 256);
}

void draw() {
	draw_func();
}"
"597773","Patchwork","mySketch","/*
  Oldschool pixel effects
*/

// speed / quality control
int step_x = 6;
int step_y = 6;

float xmotion = 8.8;
float ymotion = 2.2;

void draw_func() {
	noStroke();
	
	int draw_width = width;
	int draw_height = height;
	
  fill(0, 0, 0, 2);
  rect(0, 0, width, height);
	
	int offx = 8;
	int offy = 8;

	for (int x = -offx; x < draw_width; x += step_x) {
		float norm_x = x / width;
		
		float pnxc = cos(PI / 2 + x / width * PI * 3);
		float pnx = abs(pnxc);
		
		for (int y = -offy; y < draw_height; y += step_y) {
			float norm_y = y / height;
			
			float pny = abs(sin(y / height * PI * 4 - round(pnxc * 4) * 4 * xmotion * round((0.5 - norm_y) * 2)));
			float pny2 = abs(sin(y / height * PI * 4 + round(pnxc * 4) * 4 * -xmotion));
			
			noiseDetail(3, 0.5);
			float pn = (0.5 - noise(x / width + pnx, y / height + pny, abs(pnx - pny) + ymotion / 2)) * 2;
			
			fill(24 + abs(pnxc - pny) * 8 + abs(cos(xmotion * 4) * 8),
					 255 * max(0, abs(pnx - pny - round(pnxc * 3) / 3)),
					 max(0, abs(pnx - pny * tan(pnx)) * 255) * (abs(0.5 - norm_y) * 4),
					 128 + round(pnxc) * 128); 
			
			int xx = x + pnx * offx + pn * 16;
			int yy = y + pny * offy + pn * 16;
			int yy2 = y + pny2 * offy + pn * 16;
			rect(xx, yy, step_x * 2, step_y * 2);
			rect(yy2, xx, step_x * 2, step_y * 2);
			
			/*rect(xx, yy + draw_height, step_x * 2, step_y * 2);*/
		}
	}
	
	xmotion += 0.008;
	ymotion += 0.001;
}

void setup() {
  size(400, 400);

  frameRate(60); 

  background(0);
	
	//smooth();
	
	colorMode(HSB, 360, 256, 256);
}

void draw() {
	draw_func();
}"
"597773","Patchwork","mySketch","/*
  Oldschool pixel effects
*/

// speed / quality control
int step_x = 6;
int step_y = 6;

float xmotion = 8.8;
float ymotion = 2.2;

void draw_func() {
	noStroke();
	
	int draw_width = width;
	int draw_height = height;
	
  fill(0, 0, 0, 2);
  rect(0, 0, width, height);
	
	int offx = 8;
	int offy = 8;

	for (int x = -offx; x < draw_width; x += step_x) {
		float norm_x = x / width;
		
		float pnxc = cos(PI / 2 + x / width * PI * 3);
		float pnx = abs(pnxc);
		
		for (int y = -offy; y < draw_height; y += step_y) {
			float norm_y = y / height;
			
			float pny = abs(sin(y / height * PI * 4 - round(pnxc * 4) * 4 * xmotion * round((0.5 - norm_y) * 2)));
			float pny2 = abs(sin(y / height * PI * 4 + round(pnxc * 4) * 4 * -xmotion));
			
			noiseDetail(3, 0.5);
			float pn = (0.5 - noise(x / width + pnx, y / height + pny, abs(pnx - pny) + ymotion / 2)) * 2;
			
			fill(24 + abs(pnxc - pny) * 8 + abs(cos(xmotion * 4) * 8),
					 255 * max(0, abs(pnx - pny - round(pnxc * 3) / 3)),
					 max(0, abs(pnx - pny * tan(pnx)) * 255) * (abs(0.5 - norm_y) * 4),
					 128 + round(pnxc) * 128); 
			
			int xx = x + pnx * offx + pn * 16;
			int yy = y + pny * offy + pn * 16;
			int yy2 = y + pny2 * offy + pn * 16;
			rect(xx, yy, step_x * 2, step_y * 2);
			rect(yy2, xx, step_x * 2, step_y * 2);
			
			/*rect(xx, yy + draw_height, step_x * 2, step_y * 2);*/
		}
	}
	
	xmotion += 0.008;
	ymotion += 0.001;
}

void setup() {
  size(400, 400);

  frameRate(60); 

  background(0);
	
	//smooth();
	
	colorMode(HSB, 360, 256, 256);
}

void draw() {
	draw_func();
}"
"597773","Patchwork","mySketch","/*
  Oldschool pixel effects
*/

// speed / quality control
int step_x = 6;
int step_y = 6;

float xmotion = 8.8;
float ymotion = 2.2;

void draw_func() {
	noStroke();
	
	int draw_width = width;
	int draw_height = height;
	
  fill(0, 0, 0, 1);
  rect(0, 0, width, height);
	
	int offx = 8;
	int offy = 8;

	for (int x = -offx; x < draw_width; x += step_x) {
		float norm_x = x / width;
		
		float pnxc = cos(PI * 2 + x / width * PI * 8 + xmotion * 8);
		float pnx = abs(pnxc);
		
		for (int y = -offy; y < draw_height; y += step_y) {
			float norm_y = y / height;
			
			float pny = abs(sin(y / height * PI * 4 + round(pnxc * 2) * 2 * xmotion * round((0.5 - pnxc / 8) * 16)));
			float pny2 = abs(cos(y / height * PI * 4 + round(pnxc * 2) * 2 * -xmotion));
			
			fill(12 + abs(pnxc - pny) * 16 + abs(cos(xmotion * 4) * 64),
					 255 * max(0, abs(pnx - pny - round(pnxc * 8) / 2)),
					 max(0, abs(pnx / tan(pny)) * 255),
					 128 + round(pnxc) * 128); 
			stroke(12 * 4 + abs(pnxc - pny) * 16 + abs(cos(xmotion * 4) * 64),
					 255 * max(0, abs(pnx - pny - round(pnxc * 8) / 2)),
					 max(0, abs(pnx / tan(pny)) * 255),
					 128 + round(pnxc) * 128); 
			
			int xx = x;
			int yy = y;
			rect(xx, yy, step_x, step_y);
			rect(yy, xx, step_x, step_y);
		}
	}
	
	xmotion += 0.008;
	ymotion += 0.001;
}

void setup() {
  size(400, 400);

  frameRate(60); 

  background(0);
	
	//smooth();
	
	colorMode(HSB, 360, 256, 256);
}

void draw() {
	draw_func();
}"
"597773","Patchwork","mySketch","/*
  Oldschool pixel effects
*/

// speed / quality control
int step_x = 6;
int step_y = 6;

float xmotion = 8.8;
float ymotion = 2.2;

void draw_func() {
	noStroke();
	
	int draw_width = width;
	int draw_height = height;
	
  fill(0, 0, 0, 1);
  rect(0, 0, width, height);
	
	int offx = 8;
	int offy = 8;

	for (int x = -offx; x < draw_width; x += step_x) {
		float norm_x = x / width;
		
		float pnxc = cos(PI * 2 + x / width * PI * 8 + xmotion * 8);
		float pnx = abs(pnxc);
		
		for (int y = -offy; y < draw_height; y += step_y) {
			float norm_y = y / height;
			
			float pny = abs(sin(y / height * PI * 4 + round(pnxc * 2) * 2 * xmotion * round((0.5 - pnxc / 8) * 16)));
			float pny2 = abs(cos(y / height * PI * 4 + round(pnxc * 2) * 2 * -xmotion));
			
			fill(12 + abs(pnxc - pny) * 16 + abs(cos(xmotion * 4) * 64),
					 255 * max(0, abs(pnx - pny - round(pnxc * 8) / 2)),
					 max(0, abs(pnx / tan(pny)) * 255),
					 128 + round(pnxc) * 128); 
			stroke(12 * 4 + abs(pnxc - pny) * 16 + abs(cos(xmotion * 4) * 64),
					 255 * max(0, abs(pnx - pny - round(pnxc * 8) / 2)),
					 max(0, abs(pnx / tan(pny)) * 255),
					 128 + round(pnxc) * 128); 
			
			int xx = x;
			int yy = y;
			rect(xx, yy, step_x, step_y);
			rect(yy, xx, step_x, step_y);
		}
	}
	
	xmotion += 0.008;
	ymotion += 0.001;
}

void setup() {
  size(400, 400);

  frameRate(60); 

  background(0);
	
	//smooth();
	
	colorMode(HSB, 360, 256, 256);
}

void draw() {
	draw_func();
}"
"591286","Smoking fields","mySketch","/*
  The oldschool fire/smoke/cloud effect using feedback and perlin noise
*/

// speed / quality control
int step_x = 4;
int step_y = 4;

float xmotion = 8.8;
float ymotion = 2.2;

void draw_func() {
	noStroke();
	
  fill(0, 0, 0, 32);
  rect(0, 0, width, height);

	for (int x = 0; x < width; x += step_x) {
		for (int y = 0; y < height; y += step_y) {
			float norm_y = y / height;
			
			// convection is done by moving 3d noise
			noiseDetail(7, 0.75);
			float pn = noise(x / width - xmotion / 4, y / height + xmotion, ymotion / 8);
			// we subtract it with another to make it more interesting
			noiseDetail(2, 0.5);
			pn *= noise((width - x) / width, (height - y) / height - xmotion / 2, ymotion / 2) * 1.5;
			
			// make the noise more interesting
			float n = abs(max(pow(14 * pn, pn) * 38 * ((y - (height / 2 - (height / 2))) / (height)), 1.));
			
			// hue palette range is 0 / 60, saturation is adjusted from the height so that plasma turn into regular smoke
			fill(min(n / 20, 160), 255 * (0.25 + norm_y / 1.5), n / (norm_y), 255 * (1.-norm_y));
			rect(x, y, step_x, step_y);
			
			// smooth it out by adding randomness, this improve quality and is used to counter the high stepping effect
			rect(x + random(4, 4), y + random(-4, 4), 4, 4);
			rect(x + random(-4, 4), y + random(-4, 4), 4, 4);
		}
	}
	
	xmotion += 0.005;
	ymotion += 0.008;
}

void setup() {
  size(400, 400);

  frameRate(60); 

  background(0);
	
	//smooth();
	
	colorMode(HSB, 360, 256, 256);
}

void draw() {
	draw_func();
}"
"591286","Smoking fields","mySketch","/*
  The oldschool fire/smoke/cloud effect using feedback and perlin noise
*/

// speed / quality control
int step_x = 4;
int step_y = 4;

float xmotion = 8.8;
float ymotion = 2.2;

void draw_func() {
	noStroke();
	
  fill(0, 0, 0, 32);
  rect(0, 0, width, height);

	for (int x = 0; x < width; x += step_x) {
		for (int y = 0; y < height; y += step_y) {
			float norm_y = y / height;
			
			// convection is done by moving 3d noise
			noiseDetail(7, 0.75);
			float pn = noise(x / width - xmotion / 2, y / height + xmotion, ymotion / 8);
			// we subtract it with another to make it more interesting
			noiseDetail(2, 0.5);
			pn *= noise((width - x) / width, (height - y) / height - xmotion / 2, ymotion / 2) * 1.5;
			
			// make the noise more interesting
			float n = abs(max(pow(14 * pn, pn) * 38 * ((y - (height / 2 - (height / 2))) / (height)), 1.));
			
			// hue palette range is 0 / 60, saturation is adjusted from the height so that plasma turn into regular smoke
			fill(min(n / 20, 160), 255 * (0.25 + norm_y / 1.5), n / (norm_y), 255 * (1.-norm_y));
			rect(x, y, step_x, step_y);
			
			// smooth it out by adding randomness, this improve quality and is used to counter the high stepping effect
			rect(x + random(4, 4), y + random(-4, 4), 4, 4);
			rect(x + random(-4, 4), y + random(-4, 4), 4, 4);
		}
	}
	
	xmotion += 0.005;
	ymotion += 0.008;
}

void setup() {
  size(400, 400);

  frameRate(60); 

  background(0);
	
	//smooth();
	
	colorMode(HSB, 360, 256, 256);
}

void draw() {
	draw_func();
}"
"591266","Fire/Smoke","mySketch","// speed / quality control
int step_x = 8;
int step_y = 8;

float xmotion = 8.8;
float ymotion = 2.2;

void draw_func() {
	noStroke();
	
  fill(0, 0, 0, 2);
  rect(0, 0, width, height);

	int centered_rect_size = 92;
	
	noiseDetail(7, 0.75);
	
	for (int x = 0; x < width; x += 4) {
		for (int y = 0; y < height; y += 4) {
			float norm_y = y / height;
			float pn = noise(x / width, y / height + xmotion, ymotion / 8);
			
			float n = abs(max(pow(10 * pn, pn) * 16 * ((y - (height / 2 - (height / 4))) / (height)), 1.));
			
			fill(min(n / 12, 60), 255, n, 32);
			rect(x, y, 4, 4);
		}
	}
	
	loadPixels();
	for (int x = 0; x < width; x += 8) {
		for (int y = 0; y < height; y += 8) {
			color p = pixels[y * width + x];
			
			float b = brightness(p);
			
			if (b <= 128) {
				float norm_x = x / height;
				float norm_y = y / height;
				
				fill(hue(p), saturation(p), brightness(p), 32);
				
				for (int i = 0; i < 2; i += 1) {
					rect(x + random(-4, 4), y + random(-4, 4), 4, 4);	
				}
			}
		}
	}
	
	xmotion += 0.005;
	ymotion += 0.008;
}

void setup() {
  size(400, 400);

  frameRate(60); 

  background(0);
	
	//smooth();
	
	colorMode(HSB, 360, 256, 256);
}

void draw() {
	draw_func();
}"
"591266","Fire/Smoke","mySketch","/*
  The oldschool fire/smoke/cloud effect using feedback and perlin noise
*/

// speed / quality control
int step_x = 8;
int step_y = 8;

float xmotion = 8.8;
float ymotion = 2.2;

void draw_func() {
	noStroke();
	
  fill(0, 0, 0, 2);
  rect(0, 0, width, height);

	for (int x = 0; x < width; x += step_x) {
		for (int y = 0; y < height; y += step_y) {
			float norm_y = y / height;
			
			// convection is done by moving 3d noise
			noiseDetail(7, 0.75);
			float pn = noise(x / width, y / height + xmotion, ymotion / 8);
			// we subtract it with another to make it more interesting
			noiseDetail(3, 0.45);
			pn -= noise((width - x) / width, (height - y) / height - xmotion / 2, ymotion / 2) * 1.5;
			
			// make the noise more interesting
			float n = abs(max(pow(11 * pn, pn) * 38 * ((y - (height / 2 - (height / 2))) / (height)), 1.));
			
			// hue palette range is 0 / 60, saturation is adjusted from the height so that plasma turn into regular smoke
			fill(min(n / 10, 60), 255 * (0.25 + norm_y / 1.5), n, 32);
			rect(x, y, step_x, step_y);
			
			// smooth it out by adding randomness, this improve quality and is used to counter the high stepping effect
			rect(x + random(-8, 8), y + random(-8, 8), step_x, step_y);
			rect(x + random(-8, 8), y + random(-8, 8), step_x, step_y);
			rect(x + random(-8, 8), y + random(-8, 8), step_x, step_y);
			rect(x + random(-8, 8), y + random(-8, 8), step_x, step_y);
		}
	}
	
	xmotion += 0.005;
	ymotion += 0.008;
}

void setup() {
  size(800, 400);

  frameRate(60); 

  background(0);
	
	//smooth();
	
	colorMode(HSB, 360, 256, 256);
}

void draw() {
	draw_func();
}"
"585319","Window","mySketch","/**
  * Same principle as ""Star time"" but with a bit more edges/shading play
	*/

float xmotion = 8.8;
float ymotion = 2.2;

float rxmotion = 0;
float rymotion = 0;
float rzmotion = 0;

void draw_func() {
	noStroke();
	
  fill(0, 0, 0, 20);
  rect(0, 0, width, height);

	stroke(0, 100, 100, 255);

  int offy_s1 = width * 2;
	int offy_s2 = height;
	
	int roty = 2 + sin(xmotion / 1) * 240;
	int roty2 = 40 + cos(ymotion / 2) * 240;
	
	for (int x = 0; x < 12; x += 1) {
		float norm_x = (float)x / 4;
		fill(abs(sin(xmotion / 4 + radians(norm_x * 180))) * 50, 100, 100 * norm_x, 50);
		stroke(20 * norm_x, 100, 10 * norm_x, 32);
		for (int i = 0; i < 16; i += 1) {
			quad(0, offy_s1 + i, width, offy_s1 - roty + i, width, offy_s2 - 5 + i, 0, offy_s2 + roty2 + i);
			quad(offy_s1 + i, 0, offy_s1 - roty + i, width, offy_s2 - 5 + i, width, offy_s2 + roty2 + i, 0);
			quad(width, height - offy_s1 + i, 0, height - offy_s1 - roty + i, 0, height - offy_s2 - 5 + i, width, height - offy_s2 + roty2 + i);
			quad(width - offy_s1 + i, height, width - offy_s1 - roty + i, 0, width - offy_s2 - 5 + i, 0, width - offy_s2 + roty2 + i, height);
		}
		
		offy_s1 += (float)x / 4 + cos(xmotion + x / 8) * 30;
		offy_s2 += (float)x / 8 + sin(ymotion + x / 8) * 16;
	}
	
	xmotion += 0.04;
	ymotion += 0.05;
	
	rxmotion += 0.04;
	rymotion += 0;
	rzmotion += 0;
}

void setup() {
  size(800, 600);

  frameRate(60); 

  background(0);
	
	colorMode(HSB, 100);
	
	smooth();
}

void draw() {
  //background(0);

  draw_func();
}"
"585319","Window","mySketch","/**
  * Same principle as ""Star time"" but with a bit more edges/shading play
	*/

float xmotion = 8.8;
float ymotion = 2.2;

float rxmotion = 0;
float rymotion = 0;
float rzmotion = 0;

void draw_func() {
	noStroke();
	
  fill(0, 0, 0, 1);
  rect(0, 0, width, height);

	stroke(0, 100, 100, 255);

  int offy_s1 = width * 2;
	int offy_s2 = height;
	
	int roty = 2 + sin(xmotion / 1) * 240;
	int roty2 = 40 + cos(ymotion / 2) * 240;
	
	for (int x = 0; x < 12; x += 1) {
		float norm_x = (float)x / 4;
		fill(abs(sin(xmotion / 4 + radians(norm_x * 180))) * 50, 100, 100 * norm_x, 50);
		stroke(20 * norm_x, 100, 10 * norm_x, 32);
		for (int i = 0; i < 16; i += 1) {
			quad(0, offy_s1 + i, width, offy_s1 - roty + i, width, offy_s2 - 5 + i, 0, offy_s2 + roty2 + i);
			quad(offy_s1 + i, 0, offy_s1 - roty + i, width, offy_s2 - 5 + i, width, offy_s2 + roty2 + i, 0);
			quad(width, height - offy_s1 + i, 0, height - offy_s1 - roty + i, 0, height - offy_s2 - 5 + i, width, height - offy_s2 + roty2 + i);
			quad(width - offy_s1 + i, height, width - offy_s1 - roty + i, 0, width - offy_s2 - 5 + i, 0, width - offy_s2 + roty2 + i, height);
		}
		
		offy_s1 += (float)x / 4 + cos(xmotion + x / 8) * 30;
		offy_s2 += (float)x / 8 + sin(ymotion + x / 8) * 16;
	}
	
	noStroke();
	
	float noise_size = abs(sin(xmotion * 4)) * 8;
	
	loadPixels();
	for (int x = 0; x < width; x += 8) {
		for (int y = 0; y < height; y += 8) {
			color p = pixels[y * width + x];
			
			if (brightness(p) < 8) {
				fill(abs(cos(xmotion + hue(p))) * 100, 100, 100, 32);
				ellipse(x + random(-8, 8), y + random(-8, 8), 2, 2);	
				
				fill(0, 0, 0, 2);
				rect(x + random(-8, 8), y + random(-8, 8), noise_size, noise_size);	
			}
		}
	}
	
	xmotion += 0.04;
	ymotion += 0.05;
	
	rxmotion += 0.04;
	rymotion += 0;
	rzmotion += 0;
}

void setup() {
  size(800, 600);

  frameRate(60); 

  background(0);
	
	colorMode(HSB, 100);
	
	smooth();
}

void draw() {
  //background(0);

  draw_func();
}"
"585317","Quad","mySketch","/**
  * Same principle as ""Star time"" but with a bit more edges/shading play
	*/

float xmotion = 8.8;
float ymotion = 2.2;

float rxmotion = 0;
float rymotion = 0;
float rzmotion = 0;

void draw_func() {
	noStroke();
	
  fill(0, 0, 0, 1);
  rect(0, 0, width, height);

	stroke(0, 100, 100, 255);

  int offy_s1 = width;
	int offy_s2 = height / 2;
	
	int roty = 2 + sin(xmotion / 1) * 240;
	int roty2 = 40 + cos(ymotion / 2) * 240;
	
	for (int x = 0; x < 8; x += 1) {
		float norm_x = (float)x / 8;
		fill(abs(sin(xmotion / 4 + radians(norm_x * 180))) * 50, 100, 100, 20);
		stroke(20 * norm_x, 100, 10 * norm_x, 32);
		for (int i = 0; i < 16; i += 1) {
			quad(0, offy_s1 + i, width, offy_s1 - roty + i, width, offy_s2 - 5 + i, 0, offy_s2 + roty2 + i);
			quad(offy_s1 + i, 0, offy_s1 - roty + i, width, offy_s2 - 5 + i, width, offy_s2 + roty2 + i, 0);
			quad(width, height - offy_s1 + i, 0, height - offy_s1 - roty + i, 0, height - offy_s2 - 5 + i, width, height - offy_s2 + roty2 + i);
			quad(width - offy_s1 + i, height, width - offy_s1 - roty + i, 0, width - offy_s2 - 5 + i, 0, width - offy_s2 + roty2 + i, height);
		}
		
		offy_s1 += x * 10 + cos(xmotion + x / 8) * 30;
		offy_s2 += x * 20 + sin(ymotion + x / 8) * 30;
	}
	
	xmotion += 0.04;
	ymotion += 0.05;
	
	rxmotion += 0.04;
	rymotion += 0;
	rzmotion += 0;
}

void setup() {
  size(800, 600);

  frameRate(60); 

  background(0);
	
	colorMode(HSB, 100);
	
	smooth();
}

void draw() {
  //background(0);

  draw_func();
}"
"584838","Star time","mySketch","/**
  * Composition, begun as a ""raw"" remake of Squarepusher EP album cover : https://www.youtube.com/watch?v=fxj0RvyWmQg
	* Ended with a different result (altough the goal was kinda reached in-between :P), shading is done by applying ""feedback"" noise.
	*/

float xmotion = 8.8;
float ymotion = 2.2;

float rxmotion = 0;
float rymotion = 0;
float rzmotion = 0;

int center_sphere_stroke_weight = 1;
int new_center_sphere_stroke_weight = random(24);
int frame_switch_stroke = 120;

int frame = 0;

void draw_func() {
	noStroke();
	
  fill(0, 0, 0, 2);
  rect(0, 0, width, height);

	stroke(0, 100, 100, 255);
	//noStroke();
  int offy_s1 = 0;
	int offy_s2 = 0;
	
	int roty = 30 + sin(xmotion / 5) * 24;
	int roty2 = 20 + cos(xmotion / 3) * 8;
	
	for (int x = 0; x < 10; x += 1) {
		float norm_x = (float)x / 9;
		fill(abs(sin(xmotion / 4 + radians(norm_x * 180))) * 50, 100, 100, 24);
		stroke(20 * norm_x, 100, 10 * norm_x, 128);
		for (int i = 0; i < 8; i += 1) {
			quad(0, offy_s1 + i, width, offy_s1 - roty + i, width, offy_s2 - 5 + i, 0, offy_s2 + roty2 + i);
		}

		stroke(abs(sin(xmotion / 4 + radians(norm_x * 180))) * 50, 100, 100, 255);
		
		int offx = -558;
		float offy = 0;
		for (int y = 0; y < 8; y += 1) {
			float norm_y = (float)y / 8.0;
			
			fill(20 + 60 * norm_x, 100, 25 * norm_y, 255 * norm_y);
			
			int yo = 400;
			for (int i = -16; i < 16; i += 2) {
				// playing with -/+ i * 2 is fun to change moving shapes :)
				quad(offy_s1 + offx - i * 2, 0 + offy_s1 - offy * (norm_x * 64 * norm_y + sin(i / 8 + xmotion * 2) * 8) + 24 * norm_x,
						 offy_s1 - roty + offx - i * 2, yo + offy_s1,
						 offy_s2 + offx - i * 2, yo + offy_s2,
						 offy_s2 + roty + offx - i * 2, offy_s2 + roty2);
			}
			
			offx += 200 + (float)y * (0.25) + sin(4 + xmotion + x) * 16;
			offy += 0.05 + sin(radians(norm_x * 180)) / 8;
		}
		
		offy_s1 += x * 16 + sin(xmotion + x / 8) * 8;
		offy_s2 += x * 32 + sin(xmotion + x / 8) * 8;
	}
	
	// fake shading :)
	float noise_size = abs(sin(xmotion / 4)) * 64;
	
	noStroke();
	
	loadPixels();
	for (int x = 0; x < width; x += 8) {
		for (int y = 0; y < height; y += 8) {
			color p = pixels[y * width + x];
			
			if (brightness(p) < 32) {
				fill(0, 0, 0, 2);
				rect(x + random(8), y + random(8), noise_size, noise_size);	
			}
		}
	}
	
	xmotion += 0.05;
	ymotion += 0.008;
	
	rxmotion += 0.05;
	rymotion += 0;
	rzmotion += 0;
}

void setup() {
  size(800, 600);

  frameRate(60); 

  background(0);
	
	colorMode(HSB, 100);
	
	smooth();
}

void draw() {
  //background(0);

  draw_func();
}"
"582787","Image rotation","mySketch","/**
  * Flags of the world made of discrete rectangles.
  */

PImage heightmap;

float xmotion = 0;
float ymotion = 0;

void draw_landscape() {
  int xoff = 64;
  int yoff = 128;
  
  float mx = mouseX / 1024.0 * 4;
  float my = mouseY / 1024.0 * 2;
  
  // change the flag discrete resolution = quality
  int rect_size = 1 + (int)mx;
  float x_step_size = 6 + (int)my;
  float y_step_size = 6 + (int)my;
  //
  
  float x_end = 1024 - xoff;
  float y_end = 700 - yoff;
  
	// some blur
  fill(0, 0, 0, 64);
  rect(0, 0, 1024, 700);
  
  noStroke();
  for (int y = yoff; y < y_end; y += y_step_size) {
      float ys = (y_end - yoff);
      float yo = (y - yoff);
      float yy = yo / ys;
      int yyd = (int)(yy * heightmap.height) * heightmap.width;
      float yyy = yy - 0.5;
      
      for (int x = xoff; x < x_end; x += x_step_size) {
        float xs = (x_end - xoff);
        float xo = (x - xoff);
        float xx = xo / xs;
        
        float xxd = xx * heightmap.width;
        
        int cl = (int)xxd + yyd;
        
        int r = (int)red(heightmap.pixels[cl]);
        int g = (int)green(heightmap.pixels[cl]);
        int b = (int)blue(heightmap.pixels[cl]);
        
        fill(r, g , b);
        
        float xxx = xx - 0.5;

        rect(x + cos(xxx*yyy * PI * 4 + xmotion) * 24, y + sin(xxx*yyy * PI * 7 + ymotion) * 24, rect_size, rect_size);
      }
  }
  
  xmotion += 0.0075;
  ymotion += 0.05;
}

void setup() {
  size(1024, 700);

  frameRate(60); 
  
  heightmap = loadImage(""flags.png"");

  background(0);
}

void draw() {
  //background(0);
 
  draw_landscape();
}"
"582787","Image rotation","mySketch","/**
  * Images transforms, scaling and rotations
  */

PImage heightmap;

float xmotion = 0;
float ymotion = 0;

void draw_landscape() {
  int xoff = 64;
  int yoff = 128;
  
  float mx = mouseX / 1024.0 * 4;
  float my = mouseY / 1024.0 * 2;
  
  // change the flag discrete resolution = quality
  int rect_size = 1 + (int)mx;
  float x_step_size = 6 + (int)my;
  float y_step_size = 6 + (int)my;
  //
  
  float x_end = 1024 - xoff;
  float y_end = 700 - yoff;
  
	// some blur
	noStroke();
  fill(0, 0, 0, 2);
  rect(0, 0, width, height);
	
	float cx = cos(xmotion);
	float sx = sin(xmotion);
  
  for (int y = 0; y < heightmap.height; y += 4) {
      int yyd = y * heightmap.width;
      
      for (int x = 0; x < heightmap.width; x += 4) {
        float xxd = x;
        
        int cl = (int)xxd + yyd;
        
        int r = (int)red(heightmap.pixels[cl]);
        int g = (int)green(heightmap.pixels[cl]);
        int b = (int)blue(heightmap.pixels[cl]);
        
				stroke(255 - r, 255 - g, 255 - b, 2);
        fill(r, g, b, 192);
				
				// translation of origin to image center
				float xt = x - heightmap.width / 2;
				float yt = y - heightmap.height / 2;
				
				// apply rotation
				xx = xt * cx + yt * sx;
				yy = xt * sx - yt * cx;
				
				// translation to display center
				xx = xx + width / 2;
				yy = yy + height / 2;
        
        ellipse(xx + random(-2, 2), yy + random(-2, 2), 2, 2);
				//line(xx, yy, xx + 4, yy);
      }
  }
	
	strokeWeight(8);
	for (int i = 0; i < 16; i += 1) {
		stroke(0, 0, 0);
		noFill();
		ellipse(width / 2, height / 2, heightmap.width + i * 8, heightmap.height + i * 8, 255);
	}
  
  xmotion += 0.00275;
  ymotion += 0.05;
}

void setup() {
  size(1024, 700);

  frameRate(60); 
  
  heightmap = loadImage(""sea.jpg"");

  background(0);
}

void draw() {
	//background(0);
 
  draw_landscape();
}"
"582787","Image rotation","mySketch","/**
  * Images transforms, scaling and rotations
  */

PImage heightmap;

float xmotion = 0;
float ymotion = 0;

void draw_landscape() {
  int xoff = 64;
  int yoff = 128;
  
  float mx = mouseX / 1024.0 * 4;
  float my = mouseY / 1024.0 * 2;
  
  // change the flag discrete resolution = quality
  int rect_size = 1 + (int)mx;
  float x_step_size = 6 + (int)my;
  float y_step_size = 6 + (int)my;
  //
  
  float x_end = 1024 - xoff;
  float y_end = 700 - yoff;
  
	// some blur
	noStroke();
  fill(0, 0, 0, 2);
  rect(0, 0, width, height);
	
	float cx = cos(xmotion);
	float sx = sin(xmotion);
	
	strokeWeight(2);
  
  for (int y = 0; y < heightmap.height; y += 4) {
      int yyd = y * heightmap.width;
      
      for (int x = 0; x < heightmap.width; x += 4) {
        float xxd = x;
        
        int cl = (int)xxd + yyd;
        
        int r = (int)red(heightmap.pixels[cl]);
        int g = (int)green(heightmap.pixels[cl]);
        int b = (int)blue(heightmap.pixels[cl]);
        
        fill(r, g, b, 224);
				
				// translation of origin to image center
				float xt = x - heightmap.width / 2;
				float yt = y - heightmap.height / 2;
				
				// apply rotation
				xx = xt * cx + yt * sx;
				yy = xt * sx - yt * cx;
				
				// translation to display center
				xx = xx + width / 2;
				yy = yy + height / 2;
        
        ellipse(xx + random(-1, 1), yy + random(-1, 1), 2, 2);
				//line(xx, yy, xx + 4, yy);
      }
  }
	
	strokeWeight(8);
	for (int i = 0; i < 14; i += 1) {
		stroke(0, 0, 0, 128);
		noFill();
		ellipse(width / 2, height / 2, heightmap.width + 64 + i * 8, heightmap.height + 64 + i * 8, 255);
	}
	
	/*
	float noise_size = abs(sin(xmotion / 4)) * 2;
	
	noStroke();
	
	loadPixels();
	for (int x = 0; x < width; x += 16) {
		for (int y = 0; y < height; y += 16) {
			color p = pixels[y * width + x];
			
			if (brightness(p) < 2) {
				fill(255, 255, 255, 92);
				rect(x + random(16), y + random(16), noise_size, noise_size);	
				fill(0, 0, 0, 2);
				rect(x + random(16), y + random(16), noise_size, noise_size);	
			}
		}
	}*/
  
  xmotion += 0.0175;
  ymotion += 0.05;
}

void setup() {
  size(640, 480);

  frameRate(60); 
  
  heightmap = loadImage(""sea.jpg"");

  background(0);
}

void draw() {
	//background(0);
 
  draw_landscape();
}"
"582787","Image rotation","mySketch","/**
  * Image rotation
  */

PImage heightmap;

float xmotion = 0;
float ymotion = 0;

void draw_landscape() {
  int xoff = 64;
  int yoff = 128;
  
  float mx = mouseX / 1024.0 * 4;
  float my = mouseY / 1024.0 * 2;
  
  // change the flag discrete resolution = quality
  int rect_size = 1 + (int)mx;
  float x_step_size = 6 + (int)my;
  float y_step_size = 6 + (int)my;
  //
  
  float x_end = 1024 - xoff;
  float y_end = 700 - yoff;
  
	// some blur
	noStroke();
  fill(0, 0, 0, 2);
  rect(0, 0, width, height);
	
	float cx = cos(xmotion);
	float sx = sin(xmotion);
	
	strokeWeight(2);
	
  for (int y = 0; y < heightmap.height; y += 4) {
      int yyd = y * heightmap.width;
      
      for (int x = 0; x < heightmap.width; x += 4) {
        float xxd = x;
        
        int cl = (int)xxd + yyd;
        
        int r = (int)red(heightmap.pixels[cl]);
        int g = (int)green(heightmap.pixels[cl]);
        int b = (int)blue(heightmap.pixels[cl]);
        
        fill(r, g, b, 224);
				
				// translation of origin to image center
				float xt = x - heightmap.width / 2;
				float yt = y - heightmap.height / 2;
				
				// apply rotation
				xx = xt * cx + yt * sx;
				yy = xt * sx - yt * cx;
				
				// translation to display center
				xx = xx + width / 2;
				yy = yy + height / 2;
        
        ellipse(xx + random(-1, 1), yy + random(-1, 1), 2, 2);
				//line(xx, yy, xx + 4, yy);
      }
  }
	
	for (int i = 0; i < 32; i += 4) {
		float norm_i = 1 - i / 32;
		
		strokeWeight(16 * norm_i);
		
		stroke(0, 0, 0, 128 * norm_i);
		noFill();
		ellipse(width / 2, height / 2, heightmap.width + 8 * norm_i + i * 8, heightmap.height + 8 * norm_i + i * 8, 255);
	}
  
  xmotion += 0.0175;
  ymotion += 0.05;
}

void setup() {
  size(640, 480);

  frameRate(60); 
  
  heightmap = loadImage(""03.jpg"");

  background(0);
}

void draw() {
	//background(0);
 
  draw_landscape();
}"
"582787","Image rotation","mySketch","/**
  * Image rotation
  */

PImage heightmap;

float xmotion = 0;
float ymotion = 0;

void draw_landscape() {
  int xoff = 64;
  int yoff = 128;
  
  float mx = mouseX / 1024.0 * 4;
  float my = mouseY / 1024.0 * 2;
  
  // change the flag discrete resolution = quality
  int rect_size = 1 + (int)mx;
  float x_step_size = 6 + (int)my;
  float y_step_size = 6 + (int)my;
  //
  
  float x_end = 1024 - xoff;
  float y_end = 700 - yoff;
  
	// some blur
	noStroke();
  fill(0, 0, 0, 2);
  rect(0, 0, width, height);
	
	float cx = cos(xmotion);
	float sx = sin(xmotion);
	
	strokeWeight(2);
	
  for (int y = 0; y < heightmap.height; y += 4) {
      int yyd = y * heightmap.width;
      
      for (int x = 0; x < heightmap.width; x += 4) {
        float xxd = x;
        
        int cl = (int)xxd + yyd;
        
        int r = (int)red(heightmap.pixels[cl]);
        int g = (int)green(heightmap.pixels[cl]);
        int b = (int)blue(heightmap.pixels[cl]);
        
        fill(r, g, b, 224);
				
				// translation of origin to image center
				float xt = x - heightmap.width / 2;
				float yt = y - heightmap.height / 2;
				
				// apply rotation
				xx = xt * cx + yt * sx;
				yy = xt * sx - yt * cx;
				
				// translation to display center
				xx = xx + width / 2;
				yy = yy + height / 2;
        
        ellipse(xx + random(-1, 1), yy + random(-1, 1), 2, 2);
				//line(xx, yy, xx + 4, yy);
      }
  }
	
	for (int i = 0; i < 32; i += 4) {
		float norm_i = 1 - i / 32;
		
		strokeWeight(16 * norm_i);
		
		stroke(0, 0, 0, 128 * norm_i);
		noFill();
		ellipse(width / 2, height / 2, heightmap.width + 8 * norm_i + i * 8, heightmap.height + 8 * norm_i + i * 8, 255);
	}
  
  xmotion += 0.0175;
  ymotion += 0.05;
}

void setup() {
  size(640, 480);

  frameRate(60); 
  
  heightmap = loadImage(""03.jpg"");

  background(0);
}

void draw() {
	//background(0);
 
  draw_landscape();
}"
"582787","Image rotation","mySketch","/**
  * Image rotation
  */

PImage heightmap;

float xmotion = 0;
float ymotion = 0;

void draw_landscape() {
  int xoff = 64;
  int yoff = 128;
  
  float mx = mouseX / 1024.0 * 4;
  float my = mouseY / 1024.0 * 2;
  
  // change the flag discrete resolution = quality
  int rect_size = 1 + (int)mx;
  float x_step_size = 6 + (int)my;
  float y_step_size = 6 + (int)my;
  //
  
  float x_end = 1024 - xoff;
  float y_end = 700 - yoff;
  
	// some blur
	noStroke();
  fill(0, 0, 0, 2);
  rect(0, 0, width, height);
	
	float cx = cos(xmotion);
	float sx = sin(xmotion);
	
	strokeWeight(2);
	
  for (int y = 0; y < heightmap.height; y += 2) {
      int yyd = y * heightmap.width;
      
      for (int x = 0; x < heightmap.width; x += 4) {
        float xxd = x;
        
        int cl = (int)xxd + yyd;
        
        int r = (int)red(heightmap.pixels[cl]);
        int g = (int)green(heightmap.pixels[cl]);
        int b = (int)blue(heightmap.pixels[cl]);
        
        fill(r, g, b, 224);
				
				// translation of origin to image center
				float xt = x - heightmap.width / 2;
				float yt = y - heightmap.height / 2;
				
				// apply rotation
				xx = xt * cx + yt * sx;
				yy = xt * sx - yt * cx;
				
				// translation to display center
				xx = xx + width / 2;
				yy = yy + height / 2;
        
        ellipse(xx + random(-1, 1), yy + random(-1, 1), 2, 2);
				//line(xx, yy, xx + 4, yy);
      }
  }
	
	for (int i = 0; i < 32; i += 4) {
		float norm_i = 1 - i / 32;
		
		strokeWeight(16 * norm_i);
		
		stroke(0, 0, 0, 128 * norm_i);
		noFill();
		ellipse(width / 2, height / 2, heightmap.width + 8 * norm_i + i * 8, heightmap.height + 8 * norm_i + i * 8, 255);
	}
  
  xmotion += 0.0175;
  ymotion += 0.05;
}

void setup() {
  size(640, 480);

  frameRate(60); 
  
  heightmap = loadImage(""03.jpg"");

  background(0);
}

void draw() {
	//background(0);
 
  draw_landscape();
}"
"582787","Image rotation","mySketch","/**
  * Image rotation
  */

PImage heightmap;

float xmotion = 0;
float ymotion = 0;

void draw_landscape() {
	// some blur
	noStroke();
  fill(0, 0, 0, 2);
  rect(0, 0, width, height);
	
	float cx = cos(xmotion);
	float sx = sin(xmotion);
	
	strokeWeight(2);
	
  for (int y = 0; y < heightmap.height; y += 2) {
      int yyd = y * heightmap.width;
      
      for (int x = 0; x < heightmap.width; x += 4) {
        float xxd = x;
        
        int cl = (int)xxd + yyd;
        
        int r = (int)red(heightmap.pixels[cl]);
        int g = (int)green(heightmap.pixels[cl]);
        int b = (int)blue(heightmap.pixels[cl]);
        
        fill(r, g, b, 224);
				
				// translation of origin to image center
				float xt = x - heightmap.width / 2;
				float yt = y - heightmap.height / 2;
				
				// apply rotation
				xx = xt * cx + yt * sx;
				yy = xt * sx - yt * cx;
				
				// translation to display center
				xx = xx + width / 2;
				yy = yy + height / 2;
        
        ellipse(xx + random(-1, 1), yy + random(-1, 1), 2, 2);
				//line(xx, yy, xx + 4, yy);
      }
  }
	
	for (int i = 0; i < 32; i += 4) {
		float norm_i = 1 - i / 32;
		
		strokeWeight(16 * norm_i);
		
		stroke(0, 0, 0, 128 * norm_i);
		noFill();
		ellipse(width / 2, height / 2, heightmap.width + 8 * norm_i + i * 8, heightmap.height + 8 * norm_i + i * 8, 255);
	}
  
  xmotion += 0.0175;
  ymotion += 0.05;
}

void setup() {
  size(640, 480);

  frameRate(60); 
  
  heightmap = loadImage(""03.jpg"");

  background(0);
}

void draw() {
	//background(0);
 
  draw_landscape();
}"
"582188","Patterns 5","mySketch","float xmotion = 8.8;
float ymotion = 2.2;

float rxmotion = 0;
float rymotion = 0;
float rzmotion = 0;

void draw_func() {
	noStroke();
	
  fill(0, 0, 0, 2);
  rect(0, 0, width, height);
	
	int count = 8;
	
	int kcount = 64;
	
	for (int k = 0; k < kcount; k += 1) {
		float norm_k = k / kcount;
		for (int i = 0; i < count; i += 1) {
			float norm_i = i / count;

			float norm_i_abs = (0.5 - abs(0.5 - norm_i)) * 2;

			float sign_change_k = (k%2 * 2 - 1);
			float sign_change_i = (i%2 * 2 - 1);
			
			float leading_length = norm_k * (i * (80 + sin(radians(norm_i * 360) + xmotion) * 2));
			float minor_length = leading_length * ((1 + sqrt(5)) / 2) - leading_length;
			
			float cl = cos(radians(norm_k * 360 * sign_change_i + norm_i * 360) * norm_i + xmotion) * (leading_length * norm_k + minor_length * norm_i + sin(radians(norm_i * 360) + xmotion) * 128);
			float sl = sin(radians(norm_k * 360 * sign_change_i + norm_i * 360) * norm_i + xmotion) * (leading_length * norm_k + minor_length * norm_i + cos(radians(norm_i * 360) + ymotion) * 128);
			float cml = cos(radians(norm_k * 360 * sign_change_i + norm_i * 360) * norm_i + xmotion) * (minor_length * norm_k + leading_length * norm_i);
			float sml = sin(radians(norm_k * 360 * sign_change_i + norm_i * 360) * norm_i + xmotion) * (minor_length * norm_k + leading_length * norm_i);

			stroke(sml * 1, sml * 1, sl * 2, norm_i_abs * 8);
			line(width / 2 - cl, height / 2 - sl, width / 2 + cl * sign_change_i, height / 2 - sl);
			line(width / 2 - cl, height / 2 + sl, width / 2 + cl * sign_change_i, height / 2 + sl);
			ellipse(width / 2 + cl, height / 2 - sl, 2, 2);
			ellipse(width / 2 - cl, height / 2 - sl, 2, 2);
			ellipse(width / 2 - cl, height / 2 + sl, 2, 2);
			ellipse(width / 2 + cl, height / 2 + sl, 2, 2);
			fill(sml * 1, sml * 3, sl * 3, norm_i_abs * 255);
			line(width / 2 + cml, height / 2 - sml, width / 2 - cml, height / 2 - sml);
			line(width / 2 - cml, height / 2 + sml, width / 2 + cml, height / 2 + sml);
			//ellipse(width / 2 + cml, height / 2 - sml, 2, 2);
			//ellipse(width / 2 - cml, height / 2 - sml, 2, 2);
			//ellipse(width / 2 - cml, height / 2 + sml, 2, 2);
			//ellipse(width / 2 + cml, height / 2 + sml, 2, 2);
		}
	}
	
	noStroke();

	float noise_size = abs(sin(xmotion * 4)) * 8;
	
	loadPixels();
	for (int x = 0; x < width; x += 4) {
		for (int y = 0; y < height; y += 4) {
			color p = pixels[y * width + x];
			
			float b = brightness(p);
			
			if (b >= 192) {
				float norm_x = x / height;
				float norm_x_abs = (0.5 - abs(0.5 - norm_x)) * 2;
				
				float norm_y = y / height;
				float norm_y_abs = (0.5 - abs(0.5 - norm_y)) * 2;
			
				fill(red(p), green(p), blue(p), 255);
				rect(x + random(-8, 8), y + random(-8, 8), 1, 1);	

				fill(red(p), green(p), blue(p), 128);
				rect(x + random(-32, 32), y + random(-32, 32), 1, 1);	
				
				fill(0, 0, 0, 2);
				rect(x + random(-16, 16), y + random(-16, 16), noise_size * norm_x_abs * norm_y_abs, noise_size * norm_x_abs * norm_y_abs);
			}
		}
	}
	
	xmotion += 0.005;
	ymotion += 0.0028 + random(0, 0.01);
	
	rxmotion += 0.05;
	rymotion += 0;
	rzmotion += 0;
}

void setup() {
  size(400, 400);

  frameRate(60); 

  background(0);
	
	smooth();
}

void draw() {
  //background(0);

  draw_func();
}"
"581081","Patterns 4","mySketch","float xmotion = 8.8;
float ymotion = 2.2;

float rxmotion = 0;
float rymotion = 0;
float rzmotion = 0;

void draw_func() {
	noStroke();
	
  fill(0, 0, 0, 2);
  rect(0, 0, width, height);
	
	int count = 8;
	
	int kcount = 64;
	
	for (int k = 0; k < kcount; k += 1) {
		float norm_k = k / kcount;
		for (int i = 0; i < count; i += 1) {
			float norm_i = i / count;

			float norm_i_abs = (0.5 - abs(0.5 - norm_i)) * 2;

			float sign_change_k = (k%2 * 2 - 1);
			float sign_change_i = (i%2 * 2 - 1);
			
			float leading_length = norm_k * (i * (8 + sin(radians(norm_i * 360) + xmotion) * 2));
			float minor_length = leading_length * ((1 + sqrt(5)) / 2) - leading_length;
			
			float cl = atan(radians(norm_k * 360 * sign_change_i + norm_i * 360 ) * norm_i + xmotion) * (leading_length * norm_k + minor_length * norm_i + sin(radians(norm_i * 360) + xmotion) * 128);
			float sl = atan(radians(norm_k * 360 * sign_change_i + norm_i * 360) * norm_i + xmotion) * (leading_length * norm_k + minor_length * norm_i + cos(radians(norm_i * 360) + ymotion) * 128);
			float cml = cos(radians(norm_k * 360 * sign_change_i + norm_i * 360) * norm_i + xmotion) * (minor_length * norm_k + leading_length * norm_i);
			float sml = sin(radians(norm_k * 360 * sign_change_i + norm_i * 360) * norm_i + xmotion) * (minor_length * norm_k + leading_length * norm_i);

			fill(cl * 3, sml * 2, sl * 2, norm_i_abs * 255);
			ellipse(width / 2 + cl, height / 2 - sl, 2, 2);
			ellipse(width / 2 - cl, height / 2 - sl, 2, 2);
			ellipse(width / 2 - cl, height / 2 + sl, 2, 2);
			ellipse(width / 2 + cl, height / 2 + sl, 2, 2);
			fill(cl * 3, sml * 2, sl * 2, norm_i_abs * 255);
			ellipse(width / 2 + cml, height / 2 - sml, 2, 2);
			ellipse(width / 2 - cml, height / 2 - sml, 2, 2);
			ellipse(width / 2 - cml, height / 2 + sml, 2, 2);
			ellipse(width / 2 + cml, height / 2 + sml, 2, 2);
		}
	}
	
	noStroke();

	float noise_size = abs(sin(xmotion * 4)) * 8;
	
	loadPixels();
	for (int x = 0; x < width; x += 8) {
		for (int y = 0; y < height; y += 8) {
			color p = pixels[y * width + x];
			
			float b = brightness(p);
			
			if (b <= 8) {
				float norm_x = x / height;
				float norm_x_abs = (0.5 - abs(0.5 - norm_x)) * 2;
				
				float norm_y = y / height;
				float norm_y_abs = (0.5 - abs(0.5 - norm_y)) * 2;
				
				fill(255 * norm_y_abs, 255 * norm_y_abs, 255 * norm_y_abs, 16);
				rect(x + random(-2, 2), y + random(-2, 2), 4, 4);	
				
				fill(red(p), green(p), blue(p), 128);
				rect(x + random(-32, 32), y + random(-32, 32), 1, 1);	
				
				fill(0, 0, 0, 48);
				rect(x + random(-16, 16), y + random(-16, 16), noise_size * norm_x_abs * norm_y_abs, noise_size * norm_x_abs * norm_y_abs);
			}
		}
	}
	
	xmotion += 0.005;
	ymotion += 0.0028 + random(0, 0.01);
	
	rxmotion += 0.05;
	rymotion += 0;
	rzmotion += 0;
}

void setup() {
  size(400, 400);

  frameRate(60); 

  background(0);
	
	smooth();
}

void draw() {
  //background(0);

  draw_func();
}"
"581081","Patterns 4","mySketch","float xmotion = 8.8;
float ymotion = 2.2;

float rxmotion = 0;
float rymotion = 0;
float rzmotion = 0;

void draw_func() {
	noStroke();
	
  fill(0, 0, 0, 2);
  rect(0, 0, width, height);
	
	int count = 8;
	
	int kcount = 64;
	
	for (int k = 0; k < kcount; k += 1) {
		float norm_k = k / kcount;
		for (int i = 0; i < count; i += 1) {
			float norm_i = i / count;

			float norm_i_abs = (0.5 - abs(0.5 - norm_i)) * 2;

			float sign_change_k = (k%2 * 2 - 1);
			float sign_change_i = (i%2 * 2 - 1);
			
			float leading_length = norm_k * (i * (8 + sin(radians(norm_i * 360) + xmotion) * 2));
			float minor_length = leading_length * ((1 + sqrt(5)) / 2) - leading_length;
			
			float cl = atan(radians(norm_k * 360 * sign_change_i + norm_i * 360 ) * norm_i + xmotion) * (leading_length * norm_k + minor_length * norm_i + sin(radians(norm_i * 360) + xmotion) * 128);
			float sl = atan(radians(norm_k * 360 * sign_change_i + norm_i * 360) * norm_i + xmotion) * (leading_length * norm_k + minor_length * norm_i + cos(radians(norm_i * 360) + ymotion) * 128);
			float cml = cos(radians(norm_k * 360 * sign_change_i + norm_i * 360) * norm_i + xmotion) * (minor_length * norm_k + leading_length * norm_i);
			float sml = sin(radians(norm_k * 360 * sign_change_i + norm_i * 360) * norm_i + xmotion) * (minor_length * norm_k + leading_length * norm_i);

			fill(cl * 3, sml * 2, sl * 2, norm_i_abs * 255);
			ellipse(width / 2 + cl, height / 2 - sl, 2, 2);
			ellipse(width / 2 - cl, height / 2 - sl, 2, 2);
			ellipse(width / 2 - cl, height / 2 + sl, 2, 2);
			ellipse(width / 2 + cl, height / 2 + sl, 2, 2);
			fill(cl * 3, sml * 2, sl * 2, norm_i_abs * 255);
			ellipse(width / 2 + cml, height / 2 - sml, 2, 2);
			ellipse(width / 2 - cml, height / 2 - sml, 2, 2);
			ellipse(width / 2 - cml, height / 2 + sml, 2, 2);
			ellipse(width / 2 + cml, height / 2 + sml, 2, 2);
		}
	}
	
	noStroke();

	float noise_size = abs(sin(xmotion * 4)) * 8;
	
	loadPixels();
	for (int x = 0; x < width; x += 8) {
		for (int y = 0; y < height; y += 8) {
			color p = pixels[y * width + x];
			
			float b = brightness(p);
			
			if (b <= 8) {
				float norm_x = x / height;
				float norm_x_abs = (0.5 - abs(0.5 - norm_x)) * 2;
				
				float norm_y = y / height;
				float norm_y_abs = (0.5 - abs(0.5 - norm_y)) * 2;
				
				fill(255 * norm_y_abs, 255 * norm_y_abs, 255 * norm_y_abs, 16);
				rect(x + random(-2, 2), y + random(-2, 2), 4, 4);	
				
				fill(red(p), green(p), blue(p), 128);
				rect(x + random(-32, 32), y + random(-32, 32), 1, 1);	
				
				fill(0, 0, 0, 48);
				rect(x + random(-16, 16), y + random(-16, 16), noise_size * norm_x_abs * norm_y_abs, noise_size * norm_x_abs * norm_y_abs);
			}
		}
	}
	
	xmotion += 0.005;
	ymotion += 0.0028 + random(0, 0.01);
	
	rxmotion += 0.05;
	rymotion += 0;
	rzmotion += 0;
}

void setup() {
  size(400, 400);

  frameRate(60); 

  background(0);
	
	smooth();
}

void draw() {
  //background(0);

  draw_func();
}"
"580650","1D Cellular automaton","mySketch","/**
  * Old Processing port of 1D Cellular automaton
	*/

class CA {
  int[] cells;
  int currLine;
  int scl;
  int[] rules;
  PImage scrollBuffer;

  float currLineVel = 1;

  CA(int[] r) {
    rules = r;
    init();
  }
  
  CA(int r) {
    init();
    rules = new int[8];
    setRule(r);
  }
  
  CA() {
    init();
    rules = new int[8];
    randomize();
  }
  
  void init() {
    scl = 1;
    cells = new int[width/scl];
    restart();
    scrollBuffer = createImage(width, height, ARGB);
  }
  
  // Set the rules of the CA
  void setRules(int[] r) {
    rules = r;
  }
  
  void setRule(int r) {
    String binRepresentation = binary(r, 8);
    for (int i = 0; i < 8; i++) {
      rules[i] = int(str(binRepresentation.charAt(i)));
    }
  }

  void randomize() {
    for (int i = 0; i < 8; i++) {
      rules[i] = int(random(2));
    }
  }
  
  void restart() {
    for (int i = 0; i < cells.length; i++) {
      cells[i] = 0;
    }
    cells[cells.length/2] = 1;
    currLine = 0;
  }

  void generate() {
    int[] nextgen = new int[cells.length];
    for (int i = 1; i < cells.length-1; i++) {
      int left = cells[i-1];
      int me = cells[i];
      int right = cells[i+1];
      nextgen[i] = arules(left,me,right);
    }
    
    cells = new int[cells.length];
		for (int i = 1; i < cells.length-1; i++) {
			cells[i] = nextgen[i];
		}
  }
  
  void render() {
		render_img.beginDraw();
		render_img.noStroke();
		render_img.strokeWeight(2);
		
		//render_img.loadPixels();
    int col;
    for (int i = 0; i < cells.length; i++) {
			float norm_i = abs(0.5 - (i / cells.length)) * 2;
			
      if (cells[i] == 1) {
				col=255;//fill(255);
			} else if (cells[i] == 2) {
				col=128;//fill(255);
				render_img.noStroke();
			} else {
				col=0;//fill(0);
				render_img.noStroke();
		  }
      //noStroke();
			
			int x = i*scl;
			int y = currLine*scl;
			/*
			if (currLineVel < 0 && currLine >= (height-1)/scl/2) {
				render_img.fill(0, 0, 0, 128);
			} else {
			*/
				render_img.fill(col, col, col, col / 32);	
			//}
			
			render_img.noStroke();
			render_img.ellipse(i*scl,currLine*scl/* + cos(radians(norm_i * 360) + xmotion * 2) * currLine*/, 2, 2);
			render_img.ellipse(width - i*scl, height - currLine*scl/* - cos(radians(norm_i * 360) + xmotion * 2) * currLine*/, 2, 2);
      //if(random(1.0f)>0.25f)
			//render_img.pixels[x + y * width] = color(col, col, col);
      //set(i*scl,currLine*scl,color(col,col,col));
      //rect(i*scl,generation*scl, scl,scl);
    }
		//render_img.updatePixels();
		
		if (currLineVel < 0 && currLine == 0) {
			//render_img = createGraphics(width, height, P2D);
			//background(0);
			render_img.fill(0, 0, 0, 64);
			render_img.rect(0, 0, width, height);
			fill(0, 0, 0, 64);
			rect(0, 0, width, height);
		}
		render_img.endDraw();
    
		//loadPixels();
    if (currLine >= (height-1)/scl || currLine < 0) {
			/*
       render_img.loadPixels();
       for (int i = width; i < render_img.pixels.length; i++) {
         render_img.pixels[i-width] = render_img.pixels[i];
       }
			 render_img.updatePixels();
			 */
			currLineVel = -currLineVel;
    }// else { currLine++; }
		
		currLine += currLineVel;
  }
  
  int arules (int a, int b, int c) {
    if (a == 1 && b == 1 && c == 1) return rules[0];
    if (a == 1 && b == 1 && c == 0) return rules[1];
    if (a == 1 && b == 0 && c == 1) return rules[2];
    if (a == 1 && b == 0 && c == 0) return rules[3];
    if (a == 0 && b == 1 && c == 1) return rules[4];
    if (a == 0 && b == 1 && c == 0) return rules[5];
    if (a == 0 && b == 0 && c == 1) return rules[6];
    if (a == 0 && b == 0 && c == 0) return rules[7];

    return 0;
  }
}

PGraphics render_img;
int currRule = 18;

CA ca;

void setup() {
  size(640, 480, P2D);
  background(0);
  
  frameRate(60);

  ca = new CA(currRule);
	
	render_img = createGraphics(width, height, P2D);
}

float xmotion = 0;

void draw() {
  ca.render();
  ca.generate();
  
  fill(0);
  rect(0,0,64,12);
  fill(255);
  text(""Rule: ""+str(currRule),0,10);
  
  currRule = currRule%256;
	
	image(render_img, 0, 0);
	
	float noise_size = abs(sin(xmotion * 2)) * 8;
	
	noStroke();
	
	loadPixels();
	for (int x = 0; x < width; x += 8) {
		for (int y = 0; y < height; y += 8) {
			color p = pixels[y * width + x];
			
			float b = brightness(p);
			
			if (b < 8) {//(b >= 32 && b <= 128) {
				float norm_x = x / height;
				float norm_x_abs = (0.5 - abs(0.5 - norm_x)) * 2;
				
				float norm_y = y / height;
				float norm_y_abs = (0.5 - abs(0.5 - norm_y)) * 2;
				
				fill(255 * norm_y_abs, 255 * norm_y_abs, 255 * norm_y_abs, 16);
				rect(x + random(-8, 8), y + random(-8, 8), 2, 2);	
				
				fill(0, 0, 0, 48);
				rect(x + random(-8, 8), y + random(-8, 8), noise_size * norm_x_abs * norm_y_abs, noise_size * norm_x_abs * norm_y_abs);	
			}
		}
	}
	
	xmotion += 0.01;
}

void mousePressed() {
  background(0, 0, 0, 2);
	render_img = createGraphics(width, height, P2D);
  ca.setRule(++currRule);
  ca.restart();
}"
"580564","1D Cellular automaton","mySketch","/* @pjs crisp=true; 
preload=""sea.jpg""; 
 */

PImage img, original;
int pixels_length = 0;
int histogram_channel = 0;

class Histogram {
  int[] r, g, b, intensity;
  int max_r = 0, max_g = 0, max_b = 0, max_i = 0;
  
  Histogram() {
    r = new int[256];
    g = new int[256];
    b = new int[256];
    intensity = new int[256];
    
    clear();
  }
  
  void add(int r, int g, int b) {
    this.r[r]++;
    this.g[g]++;
    this.b[b]++;
    
    if (this.r[r] > max_r) {
      max_r = this.r[r];
    }
    
    if (this.g[g] > max_g) {
      max_g = this.g[g];
    }
    
    if (this.b[b] > max_b) {
      max_b = this.b[b];
    }
    
    int i = (r+g+b)/3;
    this.intensity[i]++;
    if (this.intensity[i] > max_i) {
      max_i = this.intensity[i];
    }
  }
  
  void clear() {
    for (int i = 0; i < 256; i++) {
      r[i] = g[i] = b[i] = intensity[i] = 0;
    }
    max_r = max_g = max_b = max_i = 0;
  }
}

Histogram histogram = new Histogram();

boolean show_original = true;

void copyImage() {
  img.copy(original, 0, 0, original.width, original.height, 0, 0, original.width, original.height);
}

void setup() {
  size(640, 360);
  noFill();
  stroke(255);
  frameRate(30);
  original = loadImage(""sea.jpg"");
  img = createImage(original.width, original.height, RGB);
  pixels_length = original.pixels.length;
  copyImage();
  if (show_original) {
    pixels_length /= 2;
  }
  
  posterize(img, 2);
}

void horizontalMosaic(PImage source, int bloc_length) {
  if (bloc_length%3 == 0)
    bloc_length++;
  source.loadPixels();
  for (int i = 0; i < pixels_length; i += bloc_length) {
    source.pixels[i] &= 0xff*((int)pow(256, (i%3)));
    
    for (int j = 1; j < bloc_length; j++) {
      source.pixels[i+j] = source.pixels[i];
    }
  }
  source.updatePixels();
}

void colorStore(PImage source, int lines) {
  int bloc_length = source.width*lines;
  
  source.loadPixels();
  for (int i = 0; i < pixels_length-bloc_length; i += bloc_length) {
    for (int j = 0; j < bloc_length; j++) {
      int index = i+j;
      // << 3 -> * 8
      source.pixels[index] = source.pixels[index]&0xff<<((i%3) << 3);
    }
  }
  source.updatePixels();
}

void toGreyscale(PImage source, float luminosity) {
  source.loadPixels();
  for (int i = 0; i < pixels_length; i++) {
    int r = source.pixels[i]>>16&0xff;
    int g = source.pixels[i]>>8&0xff;
    int b = source.pixels[i]&0xff;
    int intensity = (int)((r+g+b)/luminosity);
    if (intensity > 255) {
      intensity = 255;
    }
    source.pixels[i] = intensity<<16 |
                       intensity<<8 |
                       intensity;
  }
  source.updatePixels();
}

void applyFunction(PImage source, float level, int notchRange) {
  source.loadPixels();
  for (int i = 0; i < pixels_length; i++) {
    int r = source.pixels[i]>>16&0xff;
    int g = source.pixels[i]>>8&0xff;
    int b = source.pixels[i]&0xff;
    int mean = (r+g+b)/3;
    if (mean < notchRange && mean > 255-notchRange) {
    /*r = (int)(1/(log(r)/log(level)))*255;
    g = (int)(1/(log(g)/log(level)))*255;
    b = (int)(1/(log(b)/log(level)))*255;
    */
    
   /* r = (int)(cos(level)*r);
    g = (int)(sin(level)*g);
    b = (int)(tan(level)*b);
    */
    
    r = (int)pow(r, level);
    g = (int)pow(g, level);
    b = (int)pow(b, level);
    
    r = constrain(r, 0, 255);
    g = constrain(g, 0, 255);
    b = constrain(b, 0, 255);
    
    /*r = 255-r;
    g = 255-g;
    b = 255-b;*/
    }
    source.pixels[i] = r<<16 |
                       g<<8 |
                       b;
  }
  source.updatePixels();
}

void posterize(PImage source, int level) {
  source.loadPixels();
  for (int i = 0; i < pixels_length; i++) {
    int r = source.pixels[i]>>16&0xff;
    int g = source.pixels[i]>>8&0xff;
    int b = source.pixels[i]&0xff;
    
    int lr = 255-r;
    int lg = 255-g;
    int lb = 255-b;
   
    r = round(r/level)*level;
    g = round(g/level)*level;
    b = round(b/level)*level;
   
    /*
    r+= round(lr/level);
    g+= round(lg/level);
    b+= round(lb/level);
    */
    source.pixels[i] = r<<16 |
                       g<<8 |
                       b;
  }
  source.updatePixels();
}

void scroll(PImage source) {
  source.loadPixels();
  for (int i = 0; i < pixels_length; i++) {
    int index = (floor(i/source.width)*source.width);
    int value = source.pixels[index];
    source.pixels[index] = source.pixels[i];
    source.pixels[i] = value;
  }
  source.updatePixels();
}

void flip(PImage source) {
  source.loadPixels();
  for (int i = 0; i < pixels_length; i++) {
    int flipped_index = pixels_length-i%1;
    int value = source.pixels[flipped_index];
    source.pixels[flipped_index] = source.pixels[i];
    source.pixels[i] = value;
  }
  source.updatePixels();
}

void applyNoise(PImage source, int type, int seed, float amount, int intensity) {
  randomSeed(seed);
  
  int intensity_d2 = intensity/2;
  
  source.loadPixels();
  for (int i = 0; i < pixels_length; i++) {
    int r = source.pixels[i]>>16&0xff;
    int g = source.pixels[i]>>8&0xff;
    int b = source.pixels[i]&0xff;
    
    if (random(1.0) > amount) {
      int n = 0;
      if (type == 0) // uniform
      {
        n = (int)(intensity_d2-random(intensity));
        r += n;
        g += n;
        b += n;
      }
      else // salt&pepper
      {
        n = (int)round((random(255)/255))*255;
        r = n;
        g = n;
        b = n;
      }
    }
    
    if (r > 255) r = 255;
    if (g > 255) g = 255;
    if (b > 255) b = 255;
    if (r < 0) r = 0;
    if (g < 0) g = 0;
    if (b < 0) b = 0;
    
    source.pixels[i] = r<<16 | g<<8 | b;;
  }
  source.updatePixels();
}

void convolution(PImage source, int filter_width, int filter_height) {
  int image_height = pixels_length/source.width;
  
  int filter_size = filter_width * filter_height;
  
  int[] rr = new int[filter_size];
  int[] gg = new int[filter_size];
  int[] bb = new int[filter_size];
  int filter_sized2 = floor(filter_size/2);
      
  source.loadPixels();
  for (int x = 0; x < source.width; x++) {
    for (int y = 0; y < image_height; y++) {
      int rm = 0, gm = 0, bm = 0;
      
      for (int i = 0; i < filter_width; i++) {
        for (int j = 0; j < filter_height; j++) { 
          int index = ((x - filter_width / 2 + i + source.width)%source.width)+((y - filter_height / 2 + j + image_height) % image_height)*source.width;
          int r = source.pixels[index]>>16&0xff;
          int g = source.pixels[index]>>8&0xff;
          int b = source.pixels[index]&0xff;
          
          rm += r;
          gm += g;
          bm += b;
          
          int f_index = i+j*filter_width;
          rr[f_index] = r;
          gg[f_index] = g;
          bb[f_index] = b;
        }
      }
      /*
      rm /= filter_size;
      gm /= filter_size;
      bm /= filter_size;
      */
      
      rr = sort(rr);
      gg = sort(gg);
      bb = sort(bb);
      
      rm = rr[filter_sized2];
      gm = gg[filter_sized2];
      bm = bb[filter_sized2];
      
      int index = x+y*source.width;
      source.pixels[index] = rm<<16 | gm<<8 | bm;
    }
  }
  source.updatePixels();
}

void non_local_filter(PImage source, int filter_width, int filter_height, int max_search, int search_window_size) {
  PImage source_clone = source.get();
  int image_height = pixels_length/source.width;
  
  int filter_size = filter_width * filter_height;
  
  int filter_sized2 = floor(filter_size/2);

  source.loadPixels();
  source_clone.loadPixels();
  for (int x = 0; x < source.width; x++) {
    for (int y = 0; y < image_height; y++) {
      int rm = 0, gm = 0, bm = 0;
      int main_index = x+y*source.width;
      
      for (int i = 0; i < filter_width; i++) {
        for (int j = 0; j < filter_height; j++) { 
          int index = ((x - filter_width / 2 + i + source.width)%source.width)+((y - filter_height / 2 + j + image_height) % image_height)*source.width;
          int r = source_clone.pixels[index]>>16&0xff;
          int g = source_clone.pixels[index]>>8&0xff;
          int b = source_clone.pixels[index]&0xff;
          
          rm += r;
          gm += g;
          bm += b;
        }
      }
      

  
      rm /= filter_size;
      gm /= filter_size;
      bm /= filter_size;
      
      //int om = (rm+gm+bm)/3;
      
        int mr = 32;
        int mg = 32;
        int mb = 32;
      for (int s = 0; s < max_search; s++) {
        int xx = x + search_window_size-(int)random(search_window_size+search_window_size);
        int yy = y + search_window_size-(int)random(search_window_size+search_window_size);
        if (xx > source.width) xx = source.width-1;
        if (yy > image_height) yy = image_height-1;
        if (xx < 0) xx = 0;
        if (yy < 0) yy = 0;
        int tnrr = 0, tngg = 0, tnbb = 0;
        int ind = xx+yy*source.width;
        int tr = source_clone.pixels[ind]>>16&0xff;
        int tg = source_clone.pixels[ind]>>8&0xff;
        int tb = source_clone.pixels[ind]&0xff;
           
        for (int i = 0; i < filter_width; i++) {
          for (int j = 0; j < filter_height; j++) { 
            int index = ((xx - filter_width / 2 + i + source.width)%source.width)+((yy - filter_height / 2 + j + image_height) % image_height)*source.width;
            int r = source_clone.pixels[index]>>16&0xff;
            int g = source_clone.pixels[index]>>8&0xff;
            int b = source_clone.pixels[index]&0xff;
            
            tnrr += r;
            tngg += g;
            tnbb += b;
          }
        }
        
        tnrr /= filter_size;
        tngg /= filter_size;
        tnbb /= filter_size;
    
        if (abs(rm-tnrr) < mr) {
          if (abs(gm-tngg) < mg) {
            if (abs(bm-tnbb) < mb) {
        
         mr = abs(rm-tnrr);
         mg = abs(gm-tngg);
         mb = abs(bm-tnbb);

         rm = tr;
         gm = tg;
         bm = tb;
 
            }
          }
        }
      }

      source.pixels[main_index] = rm<<16 | gm<<8 | bm;
    }
  }
  source.updatePixels();
}

void buildHistogram(PImage source, int precision) {
  histogram.clear();
  
  source.loadPixels();
  for (int i = 0; i < pixels_length; i+=precision) {
    int r = source.pixels[i]>>16&0xff;
    int g = source.pixels[i]>>8&0xff;
    int b = source.pixels[i]&0xff;
    
    histogram.add(r, g, b);
  }
}

void displayHistogram(int opacity, int histoHeight, int histoChannel) {
  noStroke();
  int middle = width/2-256;
  
  int opacity_r = 0;
  int opacity_g = 0;
  int opacity_b = 0;
  int opacity_i = 0;
  
  if (histoChannel == 0 || histoChannel == 1) {
    opacity_r = opacity;
  } 
  if (histoChannel == 0 || histoChannel == 2) {
    opacity_g = opacity;   
  }
  if (histoChannel == 0 || histoChannel == 3) {
    opacity_b = opacity;   
  }
  if (histoChannel == 4) {
    opacity_i = opacity;   
  }
  
  for (int i = 0; i < 256; i++) {
    fill(255, 0, 0, opacity_r);
    rect(i*2+middle, height, 3, -(round((float)histogram.r[i]/(float)histogram.max_r*histoHeight)));
    fill(0, 255, 0, opacity_g);
    rect(i*2+middle, height, 3, -(round((float)histogram.g[i]/(float)histogram.max_g*histoHeight)));
    fill(0, 0, 255, opacity_b);
    rect(i*2+middle, height, 3, -(round((float)histogram.b[i]/(float)histogram.max_b*histoHeight)));
    fill(255, 255, 255, opacity_i);
    rect(i*2+middle, height, 3, -(round((float)histogram.intensity[i]/(float)histogram.max_i*histoHeight)));
  }
  noFill();
}

int effect = 0;
int scroll_timer = millis();

String effectName = ""posterize"";
void draw() {
  background(0);
  
  copyImage();
  if (effect == 0) {
    posterize(img, (int)map(mouseX, 0, width, 1, 255));
    effectName = ""posterize"";
  } else if (effect == 1){
    toGreyscale(img, map(mouseX, 0, width, 0.0001, 2.0));
    effectName = ""greyscale"";
  } else if (effect == 2) {
    colorStore(img, (int)map(mouseX, 0, width, 1, 3));
    effectName = ""store"";
  } else if (effect == 3) {
    horizontalMosaic(img, (int)map(mouseX, 0, width, 1, 32));
    effectName = ""horizontal mosaic"";
  } else if (effect == 4) {
    applyFunction(img, map(mouseX, 0, width, 0.5, 1.5), (int)map(mouseY, 0, height, 0, 255));
    effectName = ""function (notch filter)"";
  } else if (effect == 5) {
    applyNoise(img, 0, 0, 0.5, 255);
    convolution(img, 3, 3);
    effectName = ""convolution (denoise)"";
  } else if (effect == 6) {
    applyNoise(img, 0, 0, 0.5, 255);
    non_local_filter(img, 3, 3, 4, 32);
    effectName = ""non local mean filter"";
  }
  
  if (millis() - scroll_timer > 2) {
    scroll(original);
    scroll_timer = millis();
  }
  
  image(img, 0, 0);
  
  buildHistogram(img, 16);
  displayHistogram((int)map(mouseY, height, 0, 64, 255), height-img.height/2, histogram_channel);
  
  fill(255);
  textSize(32);
  text(effectName,2,height-6);
}

void mouseReleased() {
  effect++;
  effect%=7;
}

void keyPressed() {
  if (keyCode == DOWN) {
    applyNoise(img, 0, 0, 2, 255);
    image(img, 0, 0);
  }
}

void keyReleased() {
  if (keyCode == RIGHT) {
    histogram_channel++;
    histogram_channel%=5;
  } else if(keyCode == LEFT) {
    histogram_channel--;
    if (histogram_channel < 0) {
      histogram_channel = 4;
    }
  } else if(keyCode == UP) {
    flip(original);
  }
}
"
"580564","1D Cellular automaton","mySketch","/* @pjs crisp=true; 
preload=""sea.jpg""; 
 */

PImage img, original;
int pixels_length = 0;
int histogram_channel = 0;

class Histogram {
  int[] r, g, b, intensity;
  int max_r = 0, max_g = 0, max_b = 0, max_i = 0;
  
  Histogram() {
    r = new int[256];
    g = new int[256];
    b = new int[256];
    intensity = new int[256];
    
    clear();
  }
  
  void add(int r, int g, int b) {
    this.r[r]++;
    this.g[g]++;
    this.b[b]++;
    
    if (this.r[r] > max_r) {
      max_r = this.r[r];
    }
    
    if (this.g[g] > max_g) {
      max_g = this.g[g];
    }
    
    if (this.b[b] > max_b) {
      max_b = this.b[b];
    }
    
    int i = (r+g+b)/3;
    this.intensity[i]++;
    if (this.intensity[i] > max_i) {
      max_i = this.intensity[i];
    }
  }
  
  void clear() {
    for (int i = 0; i < 256; i++) {
      r[i] = g[i] = b[i] = intensity[i] = 0;
    }
    max_r = max_g = max_b = max_i = 0;
  }
}

Histogram histogram = new Histogram();

boolean show_original = true;

void copyImage() {
  img.copy(original, 0, 0, original.width, original.height, 0, 0, original.width, original.height);
}

void setup() {
  size(640, 360);
  noFill();
  stroke(255);
  frameRate(30);
  original = loadImage(""sea.jpg"");
  img = createImage(original.width, original.height, RGB);
  pixels_length = original.pixels.length;
  copyImage();
	
  if (show_original) {
    pixels_length /= 2;
  }
  
  posterize(img, 2);
}

void horizontalMosaic(PImage source, int bloc_length) {
  if (bloc_length%3 == 0)
    bloc_length++;
  source.loadPixels();
  for (int i = 0; i < pixels_length; i += bloc_length) {
    source.pixels[i] &= 0xff*((int)pow(256, (i%3)));
    
    for (int j = 1; j < bloc_length; j++) {
      source.pixels[i+j] = source.pixels[i];
    }
  }
  source.updatePixels();
}

void colorStore(PImage source, int lines) {
  int bloc_length = source.width*lines;
  
  source.loadPixels();
  for (int i = 0; i < pixels_length-bloc_length; i += bloc_length) {
    for (int j = 0; j < bloc_length; j++) {
      int index = i+j;
      // << 3 -> * 8
      source.pixels[index] = source.pixels[index]&0xff<<((i%3) << 3);
    }
  }
  source.updatePixels();
}

void toGreyscale(PImage source, float luminosity) {
  source.loadPixels();
  for (int i = 0; i < pixels_length; i++) {
    int r = red(source.pixels[i]);//source.pixels[i]>>16&0xff;
    int g = green(source.pixels[i]);//source.pixels[i]>>8&0xff;
    int b = blue(source.pixels[i]);//source.pixels[i]&0xff;
    int intensity = (int)((r+g+b)/luminosity);
    if (intensity > 255) {
      intensity = 255;
    }
    source.pixels[i] = color(intensity<<16, intensity<<8, intensity, 255);/*intensity<<16 |
                       intensity<<8 |
                       intensity;*/
  }
  source.updatePixels();
}

void applyFunction(PImage source, float level, int notchRange) {
  source.loadPixels();
  for (int i = 0; i < pixels_length; i++) {
    int r = red(source.pixels[i]);//source.pixels[i]>>16&0xff;
    int g = green(source.pixels[i]);//source.pixels[i]>>8&0xff;
    int b = blue(source.pixels[i]);//source.pixels[i]&0xff;
    int mean = (r+g+b)/3;
    if (mean < notchRange && mean > 255-notchRange) {
    /*r = (int)(1/(log(r)/log(level)))*255;
    g = (int)(1/(log(g)/log(level)))*255;
    b = (int)(1/(log(b)/log(level)))*255;
    */
    
   /* r = (int)(cos(level)*r);
    g = (int)(sin(level)*g);
    b = (int)(tan(level)*b);
    */
    
    r = (int)pow(r, level);
    g = (int)pow(g, level);
    b = (int)pow(b, level);
    
    r = constrain(r, 0, 255);
    g = constrain(g, 0, 255);
    b = constrain(b, 0, 255);
    
    /*r = 255-r;
    g = 255-g;
    b = 255-b;*/
    }
    source.pixels[i] = color(r, g, b, 255);/*r<<16 |
                       g<<8 |
                       b;*/
  }
  source.updatePixels();
}

void posterize(PImage source, int level) {
  source.loadPixels();
  for (int i = 0; i < pixels_length; i++) {
    int r = red(source.pixels[i]);//source.pixels[i]>>16&0xff;
    int g = green(source.pixels[i]);//source.pixels[i]>>8&0xff;
    int b = blue(source.pixels[i]);//source.pixels[i]&0xff;
    
    int lr = 255-r;
    int lg = 255-g;
    int lb = 255-b;
   
    r = round(r/level)*level;
    g = round(g/level)*level;
    b = round(b/level)*level;
   
    /*
    r+= round(lr/level);
    g+= round(lg/level);
    b+= round(lb/level);
    */
    source.pixels[i] = color(r, g, b, 255);/*r<<16 |
                       g<<8 |
                       b;*/
  }
  source.updatePixels();
}

void scroll(PImage source) {
  source.loadPixels();
  for (int i = 0; i < pixels_length; i++) {
    int index = (floor(i/source.width)*source.width);
    int value = source.pixels[index];
    source.pixels[index] = source.pixels[i];
    source.pixels[i] = value;
  }
  source.updatePixels();
}

void flip(PImage source) {
  source.loadPixels();
  for (int i = 0; i < pixels_length; i++) {
    int flipped_index = pixels_length-i%1;
    int value = source.pixels[flipped_index];
    source.pixels[flipped_index] = source.pixels[i];
    source.pixels[i] = value;
  }
  source.updatePixels();
}

void applyNoise(PImage source, int type, int seed, float amount, int intensity) {
  randomSeed(seed);
  
  int intensity_d2 = intensity/2;
  
  source.loadPixels();
  for (int i = 0; i < pixels_length; i++) {
    int r = red(source.pixels[i]);//source.pixels[i]>>16&0xff;
    int g = green(source.pixels[i]);//source.pixels[i]>>8&0xff;
    int b = blue(source.pixels[i]);//source.pixels[i]&0xff;
    
    if (random(1.0) > amount) {
      int n = 0;
      if (type == 0) // uniform
      {
        n = (int)(intensity_d2-random(intensity));
        r += n;
        g += n;
        b += n;
      }
      else // salt&pepper
      {
        n = (int)round((random(255)/255))*255;
        r = n;
        g = n;
        b = n;
      }
    }
    
    if (r > 255) r = 255;
    if (g > 255) g = 255;
    if (b > 255) b = 255;
    if (r < 0) r = 0;
    if (g < 0) g = 0;
    if (b < 0) b = 0;
    
    source.pixels[i] = r<<16 | g<<8 | b;;
  }
  source.updatePixels();
}

void convolution(PImage source, int filter_width, int filter_height) {
  int image_height = pixels_length/source.width;
  
  int filter_size = filter_width * filter_height;
  
  int[] rr = new int[filter_size];
  int[] gg = new int[filter_size];
  int[] bb = new int[filter_size];
  int filter_sized2 = floor(filter_size/2);
      
  source.loadPixels();
  for (int x = 0; x < source.width; x++) {
    for (int y = 0; y < image_height; y++) {
      int rm = 0, gm = 0, bm = 0;
      
      for (int i = 0; i < filter_width; i++) {
        for (int j = 0; j < filter_height; j++) { 
          int index = ((x - filter_width / 2 + i + source.width)%source.width)+((y - filter_height / 2 + j + image_height) % image_height)*source.width;
					int r = red(source.pixels[i]);//source.pixels[i]>>16&0xff;
					int g = green(source.pixels[i]);//source.pixels[i]>>8&0xff;
					int b = blue(source.pixels[i]);//source.pixels[i]&0xff;
          
          rm += r;
          gm += g;
          bm += b;
          
          int f_index = i+j*filter_width;
          rr[f_index] = r;
          gg[f_index] = g;
          bb[f_index] = b;
        }
      }
      /*
      rm /= filter_size;
      gm /= filter_size;
      bm /= filter_size;
      */
      
      rr = sort(rr);
      gg = sort(gg);
      bb = sort(bb);
      
      rm = rr[filter_sized2];
      gm = gg[filter_sized2];
      bm = bb[filter_sized2];
      
      int index = x+y*source.width;
      source.pixels[index] = rm<<16 | gm<<8 | bm;
    }
  }
  source.updatePixels();
}

void non_local_filter(PImage source, int filter_width, int filter_height, int max_search, int search_window_size) {
  PImage source_clone = source.get();
  int image_height = pixels_length/source.width;
  
  int filter_size = filter_width * filter_height;
  
  int filter_sized2 = floor(filter_size/2);

  source.loadPixels();
  source_clone.loadPixels();
  for (int x = 0; x < source.width; x++) {
    for (int y = 0; y < image_height; y++) {
      int rm = 0, gm = 0, bm = 0;
      int main_index = x+y*source.width;
      
      for (int i = 0; i < filter_width; i++) {
        for (int j = 0; j < filter_height; j++) { 
          int index = ((x - filter_width / 2 + i + source.width)%source.width)+((y - filter_height / 2 + j + image_height) % image_height)*source.width;
					int r = red(source_clone.pixels[i]);//source.pixels[i]>>16&0xff;
					int g = green(source_clone.pixels[i]);//source.pixels[i]>>8&0xff;
					int b = blue(source_clone.pixels[i]);//source.pixels[i]&0xff;
					/*
					int r = source_clone.pixels[index]>>16&0xff;
          int g = source_clone.pixels[index]>>8&0xff;
          int b = source_clone.pixels[index]&0xff;
          */
					
          rm += r;
          gm += g;
          bm += b;
        }
      }
      

  
      rm /= filter_size;
      gm /= filter_size;
      bm /= filter_size;
      
      //int om = (rm+gm+bm)/3;
      
        int mr = 32;
        int mg = 32;
        int mb = 32;
      for (int s = 0; s < max_search; s++) {
        int xx = x + search_window_size-(int)random(search_window_size+search_window_size);
        int yy = y + search_window_size-(int)random(search_window_size+search_window_size);
        if (xx > source.width) xx = source.width-1;
        if (yy > image_height) yy = image_height-1;
        if (xx < 0) xx = 0;
        if (yy < 0) yy = 0;
        int tnrr = 0, tngg = 0, tnbb = 0;
        int ind = xx+yy*source.width;
        int tr = source_clone.pixels[ind]>>16&0xff;
        int tg = source_clone.pixels[ind]>>8&0xff;
        int tb = source_clone.pixels[ind]&0xff;
           
        for (int i = 0; i < filter_width; i++) {
          for (int j = 0; j < filter_height; j++) { 
            int index = ((xx - filter_width / 2 + i + source.width)%source.width)+((yy - filter_height / 2 + j + image_height) % image_height)*source.width;
            int r = source_clone.pixels[index]>>16&0xff;
            int g = source_clone.pixels[index]>>8&0xff;
            int b = source_clone.pixels[index]&0xff;
            
            tnrr += r;
            tngg += g;
            tnbb += b;
          }
        }
        
        tnrr /= filter_size;
        tngg /= filter_size;
        tnbb /= filter_size;
    
        if (abs(rm-tnrr) < mr) {
          if (abs(gm-tngg) < mg) {
            if (abs(bm-tnbb) < mb) {
        
         mr = abs(rm-tnrr);
         mg = abs(gm-tngg);
         mb = abs(bm-tnbb);

         rm = tr;
         gm = tg;
         bm = tb;
 
            }
          }
        }
      }

      source.pixels[main_index] = rm<<16 | gm<<8 | bm;
    }
  }
  source.updatePixels();
}

void buildHistogram(PImage source, int precision) {
  histogram.clear();
  
  source.loadPixels();
  for (int i = 0; i < pixels_length; i+=precision) {
    int r = red(source.pixels[i]);//source.pixels[i]>>16&0xff;
    int g = green(source.pixels[i]);//source.pixels[i]>>8&0xff;
    int b = blue(source.pixels[i]);//source.pixels[i]&0xff;
    
    histogram.add(r, g, b);
  }
}

void displayHistogram(int opacity, int histoHeight, int histoChannel) {
  noStroke();
  int middle = width/2-256;
  
  int opacity_r = 0;
  int opacity_g = 0;
  int opacity_b = 0;
  int opacity_i = 0;
  
  if (histoChannel == 0 || histoChannel == 1) {
    opacity_r = opacity;
  } 
  if (histoChannel == 0 || histoChannel == 2) {
    opacity_g = opacity;   
  }
  if (histoChannel == 0 || histoChannel == 3) {
    opacity_b = opacity;   
  }
  if (histoChannel == 4) {
    opacity_i = opacity;   
  }
  
  for (int i = 0; i < 256; i++) {
    fill(255, 0, 0, opacity_r);
    rect(i*2+middle, height, 3, -(round((float)histogram.r[i]/(float)histogram.max_r*histoHeight)));
    fill(0, 255, 0, opacity_g);
    rect(i*2+middle, height, 3, -(round((float)histogram.g[i]/(float)histogram.max_g*histoHeight)));
    fill(0, 0, 255, opacity_b);
    rect(i*2+middle, height, 3, -(round((float)histogram.b[i]/(float)histogram.max_b*histoHeight)));
    fill(255, 255, 255, opacity_i);
    rect(i*2+middle, height, 3, -(round((float)histogram.intensity[i]/(float)histogram.max_i*histoHeight)));
  }
  noFill();
}

int effect = 0;
int scroll_timer = millis();

String effectName = ""posterize"";
void draw() {
  background(0);
  
  copyImage();
  if (effect == 0) {
    posterize(img, (int)map(mouseX, 0, width, 1, 255));
    effectName = ""posterize"";
  } else if (effect == 1){
    toGreyscale(img, map(mouseX, 0, width, 0.0001, 2.0));
    effectName = ""greyscale"";
  } else if (effect == 2) {
    colorStore(img, (int)map(mouseX, 0, width, 1, 3));
    effectName = ""store"";
  } else if (effect == 3) {
    horizontalMosaic(img, (int)map(mouseX, 0, width, 1, 32));
    effectName = ""horizontal mosaic"";
  } else if (effect == 4) {
    applyFunction(img, map(mouseX, 0, width, 0.5, 1.5), (int)map(mouseY, 0, height, 0, 255));
    effectName = ""function (notch filter)"";
  } else if (effect == 5) {
    applyNoise(img, 0, 0, 0.5, 255);
    convolution(img, 3, 3);
    effectName = ""convolution (denoise)"";
  } else if (effect == 6) {
    applyNoise(img, 0, 0, 0.5, 255);
    non_local_filter(img, 3, 3, 4, 32);
    effectName = ""non local mean filter"";
  }
  
  if (millis() - scroll_timer > 2) {
    scroll(original);
    scroll_timer = millis();
  }
  
  image(img, 0, 0);
  
  buildHistogram(img, 16);
  displayHistogram((int)map(mouseY, height, 0, 64, 255), height-img.height/2, histogram_channel);
  
  fill(255);
  textSize(32);
  text(effectName,2,height-6);
}

void mouseReleased() {
  effect++;
  effect%=7;
}

void keyPressed() {
  if (keyCode == DOWN) {
    applyNoise(img, 0, 0, 2, 255);
    image(img, 0, 0);
  }
}

void keyReleased() {
  if (keyCode == RIGHT) {
    histogram_channel++;
    histogram_channel%=5;
  } else if(keyCode == LEFT) {
    histogram_channel--;
    if (histogram_channel < 0) {
      histogram_channel = 4;
    }
  } else if(keyCode == UP) {
    flip(original);
  }
}"
"580564","1D Cellular automaton","mySketch","class CA {
  int[] cells;
  int currLine;
  int scl;
  int[] rules;
  PImage scrollBuffer;

  CA(int[] r) {
    rules = r;
    init();
  }
  
  CA(int r) {
    init();
    rules = new int[8];
    setRule(r);
  }
  
  CA() {
    init();
    rules = new int[8];
    randomize();
  }
  
  void init() {
    scl = 1;
    cells = new int[width/scl];
    restart();
    scrollBuffer = createImage(width, height, ARGB);
  }
  
  // Set the rules of the CA
  void setRules(int[] r) {
    rules = r;
  }
  
  void setRule(int r) {
    String binRepresentation = binary(r, 8);
    for (int i = 0; i < 8; i++) {
      rules[i] = int(str(binRepresentation.charAt(i)));
    }
  }

  void randomize() {
    for (int i = 0; i < 8; i++) {
      rules[i] = int(random(2));
    }
  }
  
  void restart() {
    for (int i = 0; i < cells.length; i++) {
      cells[i] = 0;
    }
    cells[cells.length/2] = 1;
    currLine = 0;
  }

  void generate() {
    int[] nextgen = new int[cells.length];
    for (int i = 1; i < cells.length-1; i++) {
      int left = cells[i-1];
      int me = cells[i];
      int right = cells[i+1];
      nextgen[i] = rules(left,me,right);
    }
    
    cells = (int[]) nextgen.clone();
  }
  
  void render() {
    int col;
    for (int i = 0; i < cells.length; i++) {
      if (cells[i] == 1) col=255;//fill(255);
      else if (cells[i] == 2) col=128;//fill(255);
      else               col=0;//fill(0);
      noStroke();
      //if(random(1.0f)>0.25f)
      set(i*scl,currLine*scl,color(col,col,col));
      //rect(i*scl,generation*scl, scl,scl);
    }
    
    if (currLine >= (height-1)/scl) {
       scrollBuffer.loadPixels();
       loadPixels();
       for (int i = width; i < scrollBuffer.pixels.length; i++) {
         scrollBuffer.pixels[i-width] = pixels[i];
       }
       scrollBuffer.updatePixels();
       image(scrollBuffer,0,0);
    } else { currLine++; }
  }
  
  int rules (int a, int b, int c) {
    if (a == 1 && b == 1 && c == 1) return rules[0];
    if (a == 1 && b == 1 && c == 0) return rules[1];
    if (a == 1 && b == 0 && c == 1) return rules[2];
    if (a == 1 && b == 0 && c == 0) return rules[3];
    if (a == 0 && b == 1 && c == 1) return rules[4];
    if (a == 0 && b == 1 && c == 0) return rules[5];
    if (a == 0 && b == 0 && c == 1) return rules[6];
    if (a == 0 && b == 0 && c == 0) return rules[7];

    return 0;
  }
}

int currRule = 18;

CA ca;

void setup() {
  size(640, 480, P2D);
  background(0);
  
  frameRate(60);

  ca = new CA(currRule);
}

void draw() {
  ca.render();
  ca.generate();
  
  fill(0);
  rect(0,0,64,12);
  fill(255);
  text(""Rule: ""+str(currRule),0,10);
  
  currRule = currRule%256;
}

void mousePressed() {
  background(0);
  ca.setRule(++currRule);
  ca.restart();
}"
"580564","1D Cellular automaton","mySketch","/**
  * Old Processing port of 1D Cellular automaton
	*/

class CA {
  int[] cells;
  int currLine;
  int scl;
  int[] rules;
  PImage scrollBuffer;

  CA(int[] r) {
    rules = r;
    init();
  }
  
  CA(int r) {
    init();
    rules = new int[8];
    setRule(r);
  }
  
  CA() {
    init();
    rules = new int[8];
    randomize();
  }
  
  void init() {
    scl = 1;
    cells = new int[width/scl];
    restart();
    scrollBuffer = createImage(width, height, ARGB);
  }
  
  // Set the rules of the CA
  void setRules(int[] r) {
    rules = r;
  }
  
  void setRule(int r) {
    String binRepresentation = binary(r, 8);
    for (int i = 0; i < 8; i++) {
      rules[i] = int(str(binRepresentation.charAt(i)));
    }
  }

  void randomize() {
    for (int i = 0; i < 8; i++) {
      rules[i] = int(random(2));
    }
  }
  
  void restart() {
    for (int i = 0; i < cells.length; i++) {
      cells[i] = 0;
    }
    cells[cells.length/2] = 1;
    currLine = 0;
  }

  void generate() {
    int[] nextgen = new int[cells.length];
    for (int i = 1; i < cells.length-1; i++) {
      int left = cells[i-1];
      int me = cells[i];
      int right = cells[i+1];
      nextgen[i] = arules(left,me,right);
    }
    
    cells = new int[cells.length];
		for (int i = 1; i < cells.length-1; i++) {
			cells[i] = nextgen[i];
		}
  }
  
  void render() {
    int col;
    for (int i = 0; i < cells.length; i++) {
      if (cells[i] == 1) col=255;//fill(255);
      else if (cells[i] == 2) col=128;//fill(255);
      else               col=0;//fill(0);
      noStroke();
      //if(random(1.0f)>0.25f)
      set(i*scl,currLine*scl,color(col,col,col));
      //rect(i*scl,generation*scl, scl,scl);
    }
    
		loadPixels();
    if (currLine >= (height-1)/scl) {
       scrollBuffer.loadPixels();
       loadPixels();
       for (int i = width; i < scrollBuffer.pixels.length; i++) {
         scrollBuffer.pixels[i-width] = pixels[i];
       }
       scrollBuffer.updatePixels();
       image(scrollBuffer,0,0);
    } else { currLine++; }
  }
  
  int arules (int a, int b, int c) {
    if (a == 1 && b == 1 && c == 1) return rules[0];
    if (a == 1 && b == 1 && c == 0) return rules[1];
    if (a == 1 && b == 0 && c == 1) return rules[2];
    if (a == 1 && b == 0 && c == 0) return rules[3];
    if (a == 0 && b == 1 && c == 1) return rules[4];
    if (a == 0 && b == 1 && c == 0) return rules[5];
    if (a == 0 && b == 0 && c == 1) return rules[6];
    if (a == 0 && b == 0 && c == 0) return rules[7];

    return 0;
  }
}

int currRule = 18;

CA ca;

void setup() {
  size(640, 480, P2D);
  background(0);
  
  frameRate(60);

  ca = new CA(currRule);
}

void draw() {
  ca.render();
  ca.generate();
  
  fill(0);
  rect(0,0,64,12);
  fill(255);
  text(""Rule: ""+str(currRule),0,10);
  
  currRule = currRule%256;
}

void mousePressed() {
  background(0);
  ca.setRule(++currRule);
  ca.restart();
}"
"580526","JPEG algorithm","mySketch","PImage img;

// tables from http://www.impulseadventure.com/photo/jpeg-quantization.html
int[] defaultQLuminance = {16, 11, 10, 16, 24,  40,  51,  61,
                           12, 12, 14, 19, 26,  58,  60,  55,
                           14, 13, 16, 24, 40,  57,  69,  56,
                           14, 17, 22, 29, 51,  87,  80,  62,
                           18, 22, 37, 56, 68,  109, 103, 77,
                           24, 35, 55, 64, 81,  104, 113, 92,
                           49, 64, 78, 87, 103, 121, 120, 101,
                           72, 92, 95, 98, 112, 100, 103, 99,
                         
                           16, 11, 10, 16, 24,  40,  51,  61, // 8x8 matrix for 16x16
                           12, 12, 14, 19, 26,  58,  60,  55,
                           14, 13, 16, 24, 40,  57,  69,  56,
                           14, 17, 22, 29, 51,  87,  80,  62,
                           18, 22, 37, 56, 68,  109, 103, 77,
                           24, 35, 55, 64, 81,  104, 113, 92,
                           49, 64, 78, 87, 103, 121, 120, 101,
                           72, 92, 95, 98, 112, 100, 103, 99};
                           
int[] defaultQChrominance = {17, 18, 24, 47, 99, 99, 99, 99,
                             18, 21, 26, 66, 99, 99, 99, 99,
                             24, 26, 56, 99, 99, 99, 99, 99,
                             47, 66, 99, 99, 99, 99, 99, 99,
                             99, 99, 99, 99, 99, 99, 99, 99,
                             99, 99, 99, 99, 99, 99, 99, 99,
                             99, 99, 99, 99, 99, 99, 99, 99,
                             99, 99, 99, 99, 99, 99, 99, 99,
                           
                             17, 18, 24, 47, 99, 99, 99, 99, // 8x8 matrix for 16x16
                             18, 21, 26, 66, 99, 99, 99, 99,
                             24, 26, 56, 99, 99, 99, 99, 99,
                             47, 66, 99, 99, 99, 99, 99, 99,
                             99, 99, 99, 99, 99, 99, 99, 99,
                             99, 99, 99, 99, 99, 99, 99, 99,
                             99, 99, 99, 99, 99, 99, 99, 99,
                             99, 99, 99, 99, 99, 99, 99, 99};

class Pixel {
  int y, cb, cr;
  int r, g , b;
  double cy, ccb, ccr; // dct coefficients for ycbcr
  
  Pixel(int r, int g, int b) {
    this.r = r;
    this.g = g;
    this.b = b;
    
    y  = (int)( 0.299   * r + 0.587   * g + 0.114   * b);
    cb = (int)(-0.16874 * r - 0.33126 * g + 0.50000 * b);
    cr = (int)( 0.50000 * r - 0.41869 * g - 0.08131 * b);
  }
  
  void toRgb() {
    r = (int)(y + 1.402 * cr); 
    g = (int)(y - 0.344 * cb - 0.714 * cr); 
    b = (int)(y + 1.772 * cb); 
    
    /*r = constrain(abs((int)(cy + 1.402 * ccr)), 0, 255); 
    g = constrain(abs((int)(cy - 0.344 * ccb - 0.714 * ccr)), 0, 255); 
    b = constrain(abs((int)(cy + 1.772 * ccb)), 0, 255); */
  }
}
  
class ImageBlock {
  Pixel[] pixels;
  
  ImageBlock(Pixel[] pixels) {
    this.pixels = pixels;
  }
}

// not used, this is a min priority queue initially done for the entropy coding stage with huffman algorithm
class MinPQ
{
  private int maxSize;
  private long[] queue;
  private int nItems;
  
  MinPQ(int s)
  {
    maxSize = s;
    queue = new long[maxSize];
    nItems = 0;
  }
  
  void insert(long item)
  {
    int i;
    if (nItems == 0) {
      queue[nItems++] = item;
    } else {
      for (i = nItems - 1; i >= 0; i--) {
        if (item > queue[i]) {
          queue[i + 1] = queue[i];
        } else {
          break;
        }
      }
        
      queue[i + 1] = item;
      nItems++;
    }
  }
  
  long remove()
  {
    return queue[--nItems];
  }
  
  long peekMin()
  {
    return queue[nItems - 1];
  }
  
  boolean isEmpty()
  {
    return (nItems == 0);
  }
  
  boolean isFull()
  {
    return (nItems == maxSize);
  }
}

void setup() {
  img = loadImage(""sea.jpg"");
  
  size(512, 256);
  noFill();
  stroke(255);
  frameRate(30);
  
  int blockSize = 8;
  
  ImageBlock[] blocks = buildBlocks(img, blockSize);
  ImageBlock[] transformedBlocks = discreteCosineTransform(blocks, blockSize);
  
  double jpeg_quality_degradation_luminance = 1.0;
  double jpeg_quality_degradation_chrominance = 1.0;
  for (int i = 0; i < defaultQLuminance.length; i++) {
    defaultQLuminance[i] *= jpeg_quality_degradation_luminance;
    defaultQChrominance[i] *= jpeg_quality_degradation_chrominance;
  }
  
  ImageBlock[] quantizedBlocks = quantizer(transformedBlocks, blockSize, defaultQLuminance, defaultQChrominance);
  ImageBlock[] finalImage = inverseDiscreteCosineTransform(quantizedBlocks, blockSize);
  displayBlocks(finalImage, blockSize);
  
  image(img, img.width, 0);

/*
  MinPQ hufftree = new MinPQ(10);
*/
}

ImageBlock[] buildBlocks(PImage img, int blockLength) {
  ImageBlock[] blocks = new ImageBlock[ceil((img.width/blockLength) * (img.height/blockLength))];
  int blockSize = blockLength*blockLength;
  
  //Pixel[] pixels = new Pixel[blockSize];
  
  int start_x = 0;
  int start_y = 0;
  
  img.loadPixels();
  for (int i = 0; i < blocks.length; i++) {
    Pixel[] pixels_ = new Pixel[blockSize];
    for(int e = start_x; e < start_x+blockLength; e++) {
      int off_x = e-start_x;
      
      for(int j = start_y; j < start_y+blockLength; j++) {
        int index = e+j*img.width;
        int r = (img.pixels[index]>>16)&0xff;
        int g = (img.pixels[index]>>8)&0xff;
        int b = img.pixels[index]&0xff;
       
        pixels_[off_x+(j-start_y)*blockLength] = new Pixel(r, g, b);
      }
    }
    
    start_x += blockLength;
    if (start_x%img.width == 0) {
      start_x = 0;
      start_y += blockLength;
    }
    
    blocks[i] = new ImageBlock(pixels_);
  }
  
  return blocks;
}

void displayBlocks(ImageBlock[] blocks, int blockLength) {
  int start_x = 0, start_y = 0;
  PImage imge = createImage(img.width, img.height, RGB);
  imge.loadPixels();
  for (int i = 0; i < blocks.length; i++) {
    for(int e = 0; e < blockLength; e++) {
      int off_x = e+start_x;
      
      for(int j = 0; j < blockLength; j++) {
        int index = e+j*blockLength;

        blocks[i].pixels[index].toRgb();
        imge.pixels[off_x+(j+start_y)*imge.width] = color(blocks[i].pixels[index].r, blocks[i].pixels[index].g, blocks[i].pixels[index].b, 255); 
      }
    }
    
    start_x += blockLength;
    if (start_x%imge.width == 0) {
      start_x = 0;
      start_y += blockLength;
    }
  }
  imge.updatePixels();
  
  image(imge, 0, 0);
}

ImageBlock[] discreteCosineTransform(ImageBlock[] blocks, int blockLength) {
  int start_x = 0, start_y = 0;
  for (int i = 0; i < blocks.length; i++) {
    double o = 0, p = 0;
    int N = blockLength;
    double sqrt_rec_N = 1/sqrt(2); // 1/sqrt(n)
    double sqrt_rec2_N = 2/sqrt(N);
    double tmpy, tmpcb, tmpcr;
    
    for(int k=0;k<blockLength;k++) {
      o=0;

        if (k == 0) {
          o = sqrt_rec_N;
        } else {
          o = 1;
        }
        
      for(int l=0;l<blockLength;l++) {
        p=0;
        tmpy=tmpcb=tmpcr=0;

        if (l == 0) {
          p = sqrt_rec_N;
        } else {
          p = 1;
        }
        
        double mul = 0.25*(o*p);
            
        for (int m=0;m<blockLength;m++) {
          double xx_dct = cos(((2.0*m+1)*PI*k) /(2*N));
          
          for(int n=0;n<blockLength;n++) { 
            double dct = xx_dct * (cos(((2.0*n+1)*PI*l)/(2*N)));
            int index = m+n*blockLength;
            
            tmpy+= blocks[i].pixels[index].y*dct*mul; 
            tmpcb+= blocks[i].pixels[index].cb*dct*mul; 
            tmpcr+= blocks[i].pixels[index].cr*dct*mul; 
          }
        }
        
        int index = k+l*blockLength;
        
        blocks[i].pixels[index].cy = tmpy;
        blocks[i].pixels[index].ccb = tmpcb;
        blocks[i].pixels[index].ccr = tmpcr;
      }
    }
    
    start_x += blockLength;
    if (start_x%img.width == 0) {
      start_x = 0;
      start_y += blockLength;
    }
  }
  
  return blocks;
}

ImageBlock[] inverseDiscreteCosineTransform(ImageBlock[] blocks, int blockLength) {
  int start_x = 0, start_y = 0;
  for (int i = 0; i < blocks.length; i++) {
    double o = 0, p = 0;
    int N = blockLength;
    double sqrt_rec_N = 1/sqrt(2);
    double sqrt_rec2_N = 2/sqrt(N);
    double tmpy, tmpcb, tmpcr;
    for(int k=0;k<blockLength;k++) {
      for(int l=0;l<blockLength;l++) {
        tmpy=tmpcb=tmpcr=0;
  
        for (int m=0;m<blockLength;m++) {
          for(int n=0;n<blockLength;n++) { 
            o=0;p=0;
            if (m == 0) {
              o = sqrt_rec_N;
            } else {
              o = 1;
            }
            
            if (n == 0) {
              p = sqrt_rec_N;
            } else {
              p = 1;
            }
            
            double mul = 0.25*(o*p);
        
            double dct = (cos( ((2.0*k+1)*PI*m) /(2*N))) * (cos(((2.0*l+1)*PI*n)/(2*N)));
            int index = m+n*blockLength;
            
            tmpy+= mul*blocks[i].pixels[index].cy*dct;  
            tmpcb+= mul*blocks[i].pixels[index].ccb*dct; 
            tmpcr+= mul*blocks[i].pixels[index].ccr*dct; 
          }
        }
        
        int index = k+l*blockLength;
        blocks[i].pixels[index].y = (int)tmpy;
        blocks[i].pixels[index].cb = (int)tmpcb;
        blocks[i].pixels[index].cr = (int)tmpcr;
      }
    }
    
    start_x += blockLength;
    if (start_x%img.width == 0) {
      start_x = 0;
      start_y += blockLength;
    }
  }
  
  return blocks;
}

ImageBlock[] quantizer(ImageBlock[] blocks, int blockLength, int[] QLuminance, int[] QChrominance) {
  int start_x = 0, start_y = 0;
  for (int i = 0; i < blocks.length; i++) {
    double tmpy, tmpcb, tmpcr;
    
    for(int e=0;e<blockLength;e++) {
      for(int j=0;j<blockLength;j++) {
        int index = e+j*blockLength;
        
        blocks[i].pixels[index].cy = round((float)(blocks[i].pixels[index].cy/QChrominance[index]))*QChrominance[index];
        blocks[i].pixels[index].ccb = round((float)(blocks[i].pixels[index].ccb/QLuminance[index]))*QLuminance[index];
        blocks[i].pixels[index].ccr = round((float)(blocks[i].pixels[index].ccr/QLuminance[index]))*QLuminance[index];
      }
    }
    
    start_x += blockLength;
    if (start_x%img.width == 0) {
      start_x = 0;
      start_y += blockLength;
    }
  }
  
  return blocks;
}

void draw() {
  
}
"
"580526","JPEG algorithm","mySketch","PImage img;
PImage imge;

// tables from http://www.impulseadventure.com/photo/jpeg-quantization.html
int[] defaultQLuminance = {16, 11, 10, 16, 24,  40,  51,  61,
                           12, 12, 14, 19, 26,  58,  60,  55,
                           14, 13, 16, 24, 40,  57,  69,  56,
                           14, 17, 22, 29, 51,  87,  80,  62,
                           18, 22, 37, 56, 68,  109, 103, 77,
                           24, 35, 55, 64, 81,  104, 113, 92,
                           49, 64, 78, 87, 103, 121, 120, 101,
                           72, 92, 95, 98, 112, 100, 103, 99,
                         
                           16, 11, 10, 16, 24,  40,  51,  61, // 8x8 matrix for 16x16
                           12, 12, 14, 19, 26,  58,  60,  55,
                           14, 13, 16, 24, 40,  57,  69,  56,
                           14, 17, 22, 29, 51,  87,  80,  62,
                           18, 22, 37, 56, 68,  109, 103, 77,
                           24, 35, 55, 64, 81,  104, 113, 92,
                           49, 64, 78, 87, 103, 121, 120, 101,
                           72, 92, 95, 98, 112, 100, 103, 99};
                           
int[] defaultQChrominance = {17, 18, 24, 47, 99, 99, 99, 99,
                             18, 21, 26, 66, 99, 99, 99, 99,
                             24, 26, 56, 99, 99, 99, 99, 99,
                             47, 66, 99, 99, 99, 99, 99, 99,
                             99, 99, 99, 99, 99, 99, 99, 99,
                             99, 99, 99, 99, 99, 99, 99, 99,
                             99, 99, 99, 99, 99, 99, 99, 99,
                             99, 99, 99, 99, 99, 99, 99, 99,
                           
                             17, 18, 24, 47, 99, 99, 99, 99, // 8x8 matrix for 16x16
                             18, 21, 26, 66, 99, 99, 99, 99,
                             24, 26, 56, 99, 99, 99, 99, 99,
                             47, 66, 99, 99, 99, 99, 99, 99,
                             99, 99, 99, 99, 99, 99, 99, 99,
                             99, 99, 99, 99, 99, 99, 99, 99,
                             99, 99, 99, 99, 99, 99, 99, 99,
                             99, 99, 99, 99, 99, 99, 99, 99};

class Pixel {
  int y, cb, cr;
  int pr, pg , pb;
  double cy, ccb, ccr; // dct coefficients for ycbcr
  
  Pixel(int r, int g, int b) {
    pr = r;
    pg = g;
    pb = b;
    
    y  = (int)( 0.299   * r + 0.587   * g + 0.114   * b);
    cb = (int)(-0.16874 * r - 0.33126 * g + 0.50000 * b);
    cr = (int)( 0.50000 * r - 0.41869 * g - 0.08131 * b);
  }
  
  void toRgb() {
    pr = (int)(y + 1.402 * cr); 
    pg = (int)(y - 0.344 * cb - 0.714 * cr); 
    pb = (int)(y + 1.772 * cb); 
    
    /*r = constrain(abs((int)(cy + 1.402 * ccr)), 0, 255); 
    g = constrain(abs((int)(cy - 0.344 * ccb - 0.714 * ccr)), 0, 255); 
    b = constrain(abs((int)(cy + 1.772 * ccb)), 0, 255); */
  }
}
  
class ImageBlock {
  Pixel[] pxs;
  
  ImageBlock(Pixel[] px) {
    pxs = px;
  }
}

// not used, this is a min priority queue initially done for the entropy coding stage with huffman algorithm
class MinPQ
{
  private int maxSize;
  private long[] queue;
  private int nItems;
  
  MinPQ(int s)
  {
    maxSize = s;
    queue = new long[maxSize];
    nItems = 0;
  }
  
  void insert(long item)
  {
    int i;
    if (nItems == 0) {
      queue[nItems++] = item;
    } else {
      for (i = nItems - 1; i >= 0; i--) {
        if (item > queue[i]) {
          queue[i + 1] = queue[i];
        } else {
          break;
        }
      }
        
      queue[i + 1] = item;
      nItems++;
    }
  }
  
  long remove()
  {
    return queue[--nItems];
  }
  
  long peekMin()
  {
    return queue[nItems - 1];
  }
  
  boolean isEmpty()
  {
    return (nItems == 0);
  }
  
  boolean isFull()
  {
    return (nItems == maxSize);
  }
}

ImageBlock[] blocks;
ImageBlock[] transformedBlocks;
ImageBlock[] quantizedBlocks;
ImageBlock[] finalImage;
int blockSize = 8;

int[] QLum;
int[] QChrom;

void computeImage() {
  blocks = buildBlocks(img, blockSize);
  transformedBlocks = discreteCosineTransform(blocks, blockSize);
	
  double jpeg_quality_degradation_luminance = mouseX / width * 4;
  double jpeg_quality_degradation_chrominance = mouseY / height * 4;
	
  for (int i = 0; i < defaultQLuminance.length; i++) {
		QLum[i] = defaultQLuminance[i];
		QChrom[i] = defaultQChrominance[i];
		
    QLum[i] *= jpeg_quality_degradation_luminance;
    QChrom[i] *= jpeg_quality_degradation_chrominance;
  }
  
  quantizedBlocks = quantizer(transformedBlocks, blockSize, QLum, QChrom);
  finalImage = inverseDiscreteCosineTransform(quantizedBlocks, blockSize);
}

void setup() {
  size(512, 256);
  noFill();
  stroke(255);
  frameRate(12);
	background(0);
	
	img = loadImage(""sea.jpg"");
	
	QLum = new int[defaultQLuminance.length()];
	QChrom = new int[defaultQChrominance.length()];

	computeImage();
	
	updateBlocks(finalImage, blockSize);
/*
  MinPQ hufftree = new MinPQ(10);
*/
}

ImageBlock[] buildBlocks(PImage src_img, int blockLength) {
  ImageBlock[] dst_blocks = new ImageBlock[ceil((src_img.width/blockLength) * (src_img.height/blockLength))];
  int dst_blockSize = blockLength*blockLength;
  
  //Pixel[] pixels = new Pixel[dst_blockSize];
  
  int start_x = 0;
  int start_y = 0;
  
  src_img.loadPixels();
  for (int i = 0; i < dst_blocks.length(); i++) {
    Pixel[] pxs = new Pixel[dst_blockSize];
    for(int e = start_x; e < start_x+blockLength; e++) {
      int off_x = e-start_x;
      
      for(int j = start_y; j < start_y+blockLength; j++) {
        int index = e+j*src_img.width;
				color c = src_img.pixels[index];
        int r = red(c);//(img.pixels[index]>>16)&0xff;
        int g = green(c);//(img.pixels[index]>>8)&0xff;
        int b = blue(c);//img.pixels[index]&0xff;
       
        pxs[off_x+(j-start_y)*blockLength] = new Pixel(r, g, b);
      }
    }
    
    start_x += blockLength;
    if (start_x%src_img.width == 0) {
      start_x = 0;
      start_y += blockLength;
    }
    
    dst_blocks[i] = new ImageBlock(pxs);
  }
  
  return dst_blocks;
}

void updateBlocks(ImageBlock[] src_blocks, int blockLength) {
  int start_x = 0, start_y = 0;
  imge = createImage(img.width, img.height, RGB);
  imge.loadPixels();
  for (int i = 0; i < src_blocks.length(); i++) {
    for(int e = 0; e < blockLength; e++) {
      int off_x = e+start_x;
      
      for(int j = 0; j < blockLength; j++) {
        int index = e+j*blockLength;

        src_blocks[i].pxs[index].toRgb();
        imge.pixels[off_x+(j+start_y)*imge.width] = color(src_blocks[i].pxs[index].pr, src_blocks[i].pxs[index].pg, src_blocks[i].pxs[index].pb, 255); 
      }
    }
    
    start_x += blockLength;
    if (start_x%imge.width == 0) {
      start_x = 0;
      start_y += blockLength;
    }
  }

  imge.updatePixels();
}

ImageBlock[] discreteCosineTransform(ImageBlock[] src_blocks, int blockLength) {
  int start_x = 0, start_y = 0;
  for (int i = 0; i < src_blocks.length(); i++) {
    double o = 0, p = 0;
    int N = blockLength;
    double sqrt_rec_N = 1/sqrt(2); // 1/sqrt(n)
    double sqrt_rec2_N = 2/sqrt(N);
    double tmpy, tmpcb, tmpcr;
    
    for(int k=0;k<blockLength;k++) {
      o=0;

        if (k == 0) {
          o = sqrt_rec_N;
        } else {
          o = 1;
        }
        
      for(int l=0;l<blockLength;l++) {
        p=0;
        tmpy=tmpcb=tmpcr=0;

        if (l == 0) {
          p = sqrt_rec_N;
        } else {
          p = 1;
        }
        
        double mul = 0.25*(o*p);
            
        for (int m=0;m<blockLength;m++) {
          double xx_dct = cos(((2.0*m+1)*PI*k) /(2*N));
          
          for(int n=0;n<blockLength;n++) { 
            double dct = xx_dct * (cos(((2.0*n+1)*PI*l)/(2*N)));
            int index = m+n*blockLength;
            
            tmpy+= src_blocks[i].pxs[index].y*dct*mul; 
            tmpcb+= src_blocks[i].pxs[index].cb*dct*mul; 
            tmpcr+= src_blocks[i].pxs[index].cr*dct*mul; 
          }
        }
        
        int index = k+l*blockLength;
        
        src_blocks[i].pxs[index].cy = tmpy;
        src_blocks[i].pxs[index].ccb = tmpcb;
        src_blocks[i].pxs[index].ccr = tmpcr;
      }
    }
    
    start_x += blockLength;
    if (start_x%img.width == 0) {
      start_x = 0;
      start_y += blockLength;
    }
  }
  
  return src_blocks;
}

ImageBlock[] inverseDiscreteCosineTransform(ImageBlock[] src_blocks, int blockLength) {
  int start_x = 0, start_y = 0;
  for (int i = 0; i < src_blocks.length(); i++) {
    double o = 0, p = 0;
    int N = blockLength;
    double sqrt_rec_N = 1/sqrt(2);
    double sqrt_rec2_N = 2/sqrt(N);
    double tmpy, tmpcb, tmpcr;
    for(int k=0;k<blockLength;k++) {
      for(int l=0;l<blockLength;l++) {
        tmpy=tmpcb=tmpcr=0;
  
        for (int m=0;m<blockLength;m++) {
          for(int n=0;n<blockLength;n++) { 
            o=0;p=0;
            if (m == 0) {
              o = sqrt_rec_N;
            } else {
              o = 1;
            }
            
            if (n == 0) {
              p = sqrt_rec_N;
            } else {
              p = 1;
            }
            
            double mul = 0.25*(o*p);
        
            double dct = (cos( ((2.0*k+1)*PI*m) /(2*N))) * (cos(((2.0*l+1)*PI*n)/(2*N)));
            int index = m+n*blockLength;
            
            tmpy+= mul*src_blocks[i].pxs[index].cy*dct;  
            tmpcb+= mul*src_blocks[i].pxs[index].ccb*dct; 
            tmpcr+= mul*src_blocks[i].pxs[index].ccr*dct; 
          }
        }
        
        int index = k+l*blockLength;
        src_blocks[i].pxs[index].y = (int)tmpy;
        src_blocks[i].pxs[index].cb = (int)tmpcb;
        src_blocks[i].pxs[index].cr = (int)tmpcr;
      }
    }
    
    start_x += blockLength;
    if (start_x%img.width == 0) {
      start_x = 0;
      start_y += blockLength;
    }
  }
  
  return src_blocks;
}

ImageBlock[] quantizer(ImageBlock[] src_blocks, int blockLength, int[] QLuminance, int[] QChrominance) {
  int start_x = 0, start_y = 0;
  for (int i = 0; i < src_blocks.length(); i++) {
    double tmpy, tmpcb, tmpcr;
    
    for(int e=0;e<blockLength;e++) {
      for(int j=0;j<blockLength;j++) {
        int index = e+j*blockLength;
        
        src_blocks[i].pxs[index].cy = round((float)(src_blocks[i].pxs[index].cy/QChrominance[index]))*QChrominance[index];
        src_blocks[i].pxs[index].ccb = round((float)(src_blocks[i].pxs[index].ccb/QLuminance[index]))*QLuminance[index];
        src_blocks[i].pxs[index].ccr = round((float)(src_blocks[i].pxs[index].ccr/QLuminance[index]))*QLuminance[index];
      }
    }
    
    start_x += blockLength;
    if (start_x%img.width == 0) {
      start_x = 0;
      start_y += blockLength;
    }
  }
  
  return src_blocks;
}

int pmx = 0;
int pmy = 0;

void draw() {  
	background(0);
	
	image(imge, 0, 0);

	image(img, img.width, 0);
	
	if (pmx != mouseX || pmy != mouseY) {
		pmx = mouseX;
		pmy = mouseY;
		
		fill(255, 255, 255, 255);
		textSize(48);
		text(""JPEG processing..."", 16, 16);

		computeImage();

		updateBlocks(finalImage, blockSize);
	}
}"
"580526","JPEG algorithm","mySketch","PImage img;
PImage imge;

// tables from http://www.impulseadventure.com/photo/jpeg-quantization.html
int[] defaultQLuminance = {16, 11, 10, 16, 24,  40,  51,  61,
                           12, 12, 14, 19, 26,  58,  60,  55,
                           14, 13, 16, 24, 40,  57,  69,  56,
                           14, 17, 22, 29, 51,  87,  80,  62,
                           18, 22, 37, 56, 68,  109, 103, 77,
                           24, 35, 55, 64, 81,  104, 113, 92,
                           49, 64, 78, 87, 103, 121, 120, 101,
                           72, 92, 95, 98, 112, 100, 103, 99,
                         
                           16, 11, 10, 16, 24,  40,  51,  61, // 8x8 matrix for 16x16
                           12, 12, 14, 19, 26,  58,  60,  55,
                           14, 13, 16, 24, 40,  57,  69,  56,
                           14, 17, 22, 29, 51,  87,  80,  62,
                           18, 22, 37, 56, 68,  109, 103, 77,
                           24, 35, 55, 64, 81,  104, 113, 92,
                           49, 64, 78, 87, 103, 121, 120, 101,
                           72, 92, 95, 98, 112, 100, 103, 99};
                           
int[] defaultQChrominance = {17, 18, 24, 47, 99, 99, 99, 99,
                             18, 21, 26, 66, 99, 99, 99, 99,
                             24, 26, 56, 99, 99, 99, 99, 99,
                             47, 66, 99, 99, 99, 99, 99, 99,
                             99, 99, 99, 99, 99, 99, 99, 99,
                             99, 99, 99, 99, 99, 99, 99, 99,
                             99, 99, 99, 99, 99, 99, 99, 99,
                             99, 99, 99, 99, 99, 99, 99, 99,
                           
                             17, 18, 24, 47, 99, 99, 99, 99, // 8x8 matrix for 16x16
                             18, 21, 26, 66, 99, 99, 99, 99,
                             24, 26, 56, 99, 99, 99, 99, 99,
                             47, 66, 99, 99, 99, 99, 99, 99,
                             99, 99, 99, 99, 99, 99, 99, 99,
                             99, 99, 99, 99, 99, 99, 99, 99,
                             99, 99, 99, 99, 99, 99, 99, 99,
                             99, 99, 99, 99, 99, 99, 99, 99};

class Pixel {
  int y, cb, cr;
  int pr, pg , pb;
  double cy, ccb, ccr; // dct coefficients for ycbcr
  
  Pixel(int r, int g, int b) {
    pr = r;
    pg = g;
    pb = b;
    
    y  = (int)( 0.299   * r + 0.587   * g + 0.114   * b);
    cb = (int)(-0.16874 * r - 0.33126 * g + 0.50000 * b);
    cr = (int)( 0.50000 * r - 0.41869 * g - 0.08131 * b);
  }
  
  void toRgb() {
    pr = (int)(y + 1.402 * cr); 
    pg = (int)(y - 0.344 * cb - 0.714 * cr); 
    pb = (int)(y + 1.772 * cb); 
    
    /*r = constrain(abs((int)(cy + 1.402 * ccr)), 0, 255); 
    g = constrain(abs((int)(cy - 0.344 * ccb - 0.714 * ccr)), 0, 255); 
    b = constrain(abs((int)(cy + 1.772 * ccb)), 0, 255); */
  }
}
  
class ImageBlock {
  Pixel[] pxs;
  
  ImageBlock(Pixel[] px) {
    pxs = px;
  }
}

// not used, this is a min priority queue initially done for the entropy coding stage with huffman algorithm
class MinPQ
{
  private int maxSize;
  private long[] queue;
  private int nItems;
  
  MinPQ(int s)
  {
    maxSize = s;
    queue = new long[maxSize];
    nItems = 0;
  }
  
  void insert(long item)
  {
    int i;
    if (nItems == 0) {
      queue[nItems++] = item;
    } else {
      for (i = nItems - 1; i >= 0; i--) {
        if (item > queue[i]) {
          queue[i + 1] = queue[i];
        } else {
          break;
        }
      }
        
      queue[i + 1] = item;
      nItems++;
    }
  }
  
  long remove()
  {
    return queue[--nItems];
  }
  
  long peekMin()
  {
    return queue[nItems - 1];
  }
  
  boolean isEmpty()
  {
    return (nItems == 0);
  }
  
  boolean isFull()
  {
    return (nItems == maxSize);
  }
}

ImageBlock[] blocks;
ImageBlock[] transformedBlocks;
ImageBlock[] quantizedBlocks;
ImageBlock[] finalImage;
int blockSize = 8;

int[] QLum;
int[] QChrom;

double jpeg_quality_degradation_luminance = 1.0;
double jpeg_quality_degradation_chrominance = 1.0;

void computeImage() {
  blocks = buildBlocks(img, blockSize);
  transformedBlocks = discreteCosineTransform(blocks, blockSize);

  for (int i = 0; i < defaultQLuminance.length; i++) {
		QLum[i] = defaultQLuminance[i];
		QChrom[i] = defaultQChrominance[i];
		
    QLum[i] *= jpeg_quality_degradation_luminance;
    QChrom[i] *= jpeg_quality_degradation_chrominance;
  }
  
  quantizedBlocks = quantizer(transformedBlocks, blockSize, QLum, QChrom);
  finalImage = inverseDiscreteCosineTransform(quantizedBlocks, blockSize);
}

void setup() {
  size(512, 300);
  noFill();
  stroke(255);
  frameRate(12);
	background(0);
	
	img = loadImage(""sea.jpg"");
	
	QLum = new int[defaultQLuminance.length()];
	QChrom = new int[defaultQChrominance.length()];

	computeImage();
	
	updateBlocks(finalImage, blockSize);
/*
  MinPQ hufftree = new MinPQ(10);
*/
}

ImageBlock[] buildBlocks(PImage src_img, int blockLength) {
  ImageBlock[] dst_blocks = new ImageBlock[ceil((src_img.width/blockLength) * (src_img.height/blockLength))];
  int dst_blockSize = blockLength*blockLength;
  
  //Pixel[] pixels = new Pixel[dst_blockSize];
  
  int start_x = 0;
  int start_y = 0;
  
  src_img.loadPixels();
  for (int i = 0; i < dst_blocks.length(); i++) {
    Pixel[] pxs = new Pixel[dst_blockSize];
    for(int e = start_x; e < start_x+blockLength; e++) {
      int off_x = e-start_x;
      
      for(int j = start_y; j < start_y+blockLength; j++) {
        int index = e+j*src_img.width;
				color c = src_img.pixels[index];
        int r = red(c);//(img.pixels[index]>>16)&0xff;
        int g = green(c);//(img.pixels[index]>>8)&0xff;
        int b = blue(c);//img.pixels[index]&0xff;
       
        pxs[off_x+(j-start_y)*blockLength] = new Pixel(r, g, b);
      }
    }
    
    start_x += blockLength;
    if (start_x%src_img.width == 0) {
      start_x = 0;
      start_y += blockLength;
    }
    
    dst_blocks[i] = new ImageBlock(pxs);
  }
  
  return dst_blocks;
}

void updateBlocks(ImageBlock[] src_blocks, int blockLength) {
  int start_x = 0, start_y = 0;
  imge = createImage(img.width, img.height, RGB);
  imge.loadPixels();
  for (int i = 0; i < src_blocks.length(); i++) {
    for(int e = 0; e < blockLength; e++) {
      int off_x = e+start_x;
      
      for(int j = 0; j < blockLength; j++) {
        int index = e+j*blockLength;

        src_blocks[i].pxs[index].toRgb();
        imge.pixels[off_x+(j+start_y)*imge.width] = color(src_blocks[i].pxs[index].pr, src_blocks[i].pxs[index].pg, src_blocks[i].pxs[index].pb, 255); 
      }
    }
    
    start_x += blockLength;
    if (start_x%imge.width == 0) {
      start_x = 0;
      start_y += blockLength;
    }
  }

  imge.updatePixels();
}

ImageBlock[] discreteCosineTransform(ImageBlock[] src_blocks, int blockLength) {
  int start_x = 0, start_y = 0;
  for (int i = 0; i < src_blocks.length(); i++) {
    double o = 0, p = 0;
    int N = blockLength;
    double sqrt_rec_N = 1/sqrt(2); // 1/sqrt(n)
    double sqrt_rec2_N = 2/sqrt(N);
    double tmpy, tmpcb, tmpcr;
    
    for(int k=0;k<blockLength;k++) {
      o=0;

        if (k == 0) {
          o = sqrt_rec_N;
        } else {
          o = 1;
        }
        
      for(int l=0;l<blockLength;l++) {
        p=0;
        tmpy=tmpcb=tmpcr=0;

        if (l == 0) {
          p = sqrt_rec_N;
        } else {
          p = 1;
        }
        
        double mul = 0.25*(o*p);
            
        for (int m=0;m<blockLength;m++) {
          double xx_dct = cos(((2.0*m+1)*PI*k) /(2*N));
          
          for(int n=0;n<blockLength;n++) { 
            double dct = xx_dct * (cos(((2.0*n+1)*PI*l)/(2*N)));
            int index = m+n*blockLength;
            
            tmpy+= src_blocks[i].pxs[index].y*dct*mul; 
            tmpcb+= src_blocks[i].pxs[index].cb*dct*mul; 
            tmpcr+= src_blocks[i].pxs[index].cr*dct*mul; 
          }
        }
        
        int index = k+l*blockLength;
        
        src_blocks[i].pxs[index].cy = tmpy;
        src_blocks[i].pxs[index].ccb = tmpcb;
        src_blocks[i].pxs[index].ccr = tmpcr;
      }
    }
    
    start_x += blockLength;
    if (start_x%img.width == 0) {
      start_x = 0;
      start_y += blockLength;
    }
  }
  
  return src_blocks;
}

ImageBlock[] inverseDiscreteCosineTransform(ImageBlock[] src_blocks, int blockLength) {
  int start_x = 0, start_y = 0;
  for (int i = 0; i < src_blocks.length(); i++) {
    double o = 0, p = 0;
    int N = blockLength;
    double sqrt_rec_N = 1/sqrt(2);
    double sqrt_rec2_N = 2/sqrt(N);
    double tmpy, tmpcb, tmpcr;
    for(int k=0;k<blockLength;k++) {
      for(int l=0;l<blockLength;l++) {
        tmpy=tmpcb=tmpcr=0;
  
        for (int m=0;m<blockLength;m++) {
          for(int n=0;n<blockLength;n++) { 
            o=0;p=0;
            if (m == 0) {
              o = sqrt_rec_N;
            } else {
              o = 1;
            }
            
            if (n == 0) {
              p = sqrt_rec_N;
            } else {
              p = 1;
            }
            
            double mul = 0.25*(o*p);
        
            double dct = (cos( ((2.0*k+1)*PI*m) /(2*N))) * (cos(((2.0*l+1)*PI*n)/(2*N)));
            int index = m+n*blockLength;
            
            tmpy+= mul*src_blocks[i].pxs[index].cy*dct;  
            tmpcb+= mul*src_blocks[i].pxs[index].ccb*dct; 
            tmpcr+= mul*src_blocks[i].pxs[index].ccr*dct; 
          }
        }
        
        int index = k+l*blockLength;
        src_blocks[i].pxs[index].y = (int)tmpy;
        src_blocks[i].pxs[index].cb = (int)tmpcb;
        src_blocks[i].pxs[index].cr = (int)tmpcr;
      }
    }
    
    start_x += blockLength;
    if (start_x%img.width == 0) {
      start_x = 0;
      start_y += blockLength;
    }
  }
  
  return src_blocks;
}

ImageBlock[] quantizer(ImageBlock[] src_blocks, int blockLength, int[] QLuminance, int[] QChrominance) {
  int start_x = 0, start_y = 0;
  for (int i = 0; i < src_blocks.length(); i++) {
    double tmpy, tmpcb, tmpcr;
    
    for(int e=0;e<blockLength;e++) {
      for(int j=0;j<blockLength;j++) {
        int index = e+j*blockLength;
        
        src_blocks[i].pxs[index].cy = round((float)(src_blocks[i].pxs[index].cy/QChrominance[index]))*QChrominance[index];
        src_blocks[i].pxs[index].ccb = round((float)(src_blocks[i].pxs[index].ccb/QLuminance[index]))*QLuminance[index];
        src_blocks[i].pxs[index].ccr = round((float)(src_blocks[i].pxs[index].ccr/QLuminance[index]))*QLuminance[index];
      }
    }
    
    start_x += blockLength;
    if (start_x%img.width == 0) {
      start_x = 0;
      start_y += blockLength;
    }
  }
  
  return src_blocks;
}

int pmx = mouseX;
int pmy = mouseY;

void draw() {  
	background(0);
	
	image(imge, 0, 0);

	image(img, img.width, 0);
	
	if (pmx != mouseX || pmy != mouseY) {
		background(0);
		
		pmx = mouseX;
		pmy = mouseY;
		
		jpeg_quality_degradation_luminance = mouseX / width * 2;
		jpeg_quality_degradation_chrominance = mouseY / height * 2;
		
		fill(255, 255, 255, 255);
		textSize(24);
		text(""JPEG processing..."", 8, 32);

		computeImage();

		updateBlocks(finalImage, blockSize);
	}
	
	textSize(16);
	text(""luminance degradation : "" + jpeg_quality_degradation_luminance, 8, 278);
	textSize(16);
	text(""chrominance degradation : "" + jpeg_quality_degradation_chrominance, 8, 278 + 16);
}"
"580526","JPEG algorithm","mySketch","PImage img;
PImage imge;

// tables from http://www.impulseadventure.com/photo/jpeg-quantization.html
int[] defaultQLuminance = {16, 11, 10, 16, 24,  40,  51,  61,
                           12, 12, 14, 19, 26,  58,  60,  55,
                           14, 13, 16, 24, 40,  57,  69,  56,
                           14, 17, 22, 29, 51,  87,  80,  62,
                           18, 22, 37, 56, 68,  109, 103, 77,
                           24, 35, 55, 64, 81,  104, 113, 92,
                           49, 64, 78, 87, 103, 121, 120, 101,
                           72, 92, 95, 98, 112, 100, 103, 99,
                         
                           16, 11, 10, 16, 24,  40,  51,  61, // 8x8 matrix for 16x16
                           12, 12, 14, 19, 26,  58,  60,  55,
                           14, 13, 16, 24, 40,  57,  69,  56,
                           14, 17, 22, 29, 51,  87,  80,  62,
                           18, 22, 37, 56, 68,  109, 103, 77,
                           24, 35, 55, 64, 81,  104, 113, 92,
                           49, 64, 78, 87, 103, 121, 120, 101,
                           72, 92, 95, 98, 112, 100, 103, 99};
                           
int[] defaultQChrominance = {17, 18, 24, 47, 99, 99, 99, 99,
                             18, 21, 26, 66, 99, 99, 99, 99,
                             24, 26, 56, 99, 99, 99, 99, 99,
                             47, 66, 99, 99, 99, 99, 99, 99,
                             99, 99, 99, 99, 99, 99, 99, 99,
                             99, 99, 99, 99, 99, 99, 99, 99,
                             99, 99, 99, 99, 99, 99, 99, 99,
                             99, 99, 99, 99, 99, 99, 99, 99,
                           
                             17, 18, 24, 47, 99, 99, 99, 99, // 8x8 matrix for 16x16
                             18, 21, 26, 66, 99, 99, 99, 99,
                             24, 26, 56, 99, 99, 99, 99, 99,
                             47, 66, 99, 99, 99, 99, 99, 99,
                             99, 99, 99, 99, 99, 99, 99, 99,
                             99, 99, 99, 99, 99, 99, 99, 99,
                             99, 99, 99, 99, 99, 99, 99, 99,
                             99, 99, 99, 99, 99, 99, 99, 99};

class Pixel {
  int y, cb, cr;
  int pr, pg , pb;
  double cy, ccb, ccr; // dct coefficients for ycbcr
  
  Pixel(int r, int g, int b) {
    pr = r;
    pg = g;
    pb = b;
    
    y  = (int)( 0.299   * r + 0.587   * g + 0.114   * b);
    cb = (int)(-0.16874 * r - 0.33126 * g + 0.50000 * b);
    cr = (int)( 0.50000 * r - 0.41869 * g - 0.08131 * b);
  }
  
  void toRgb() {
    pr = (int)(y + 1.402 * cr); 
    pg = (int)(y - 0.344 * cb - 0.714 * cr); 
    pb = (int)(y + 1.772 * cb); 
    
    /*r = constrain(abs((int)(cy + 1.402 * ccr)), 0, 255); 
    g = constrain(abs((int)(cy - 0.344 * ccb - 0.714 * ccr)), 0, 255); 
    b = constrain(abs((int)(cy + 1.772 * ccb)), 0, 255); */
  }
}
  
class ImageBlock {
  Pixel[] pxs;
  
  ImageBlock(Pixel[] px) {
    pxs = px;
  }
}

// not used, this is a min priority queue initially done for the entropy coding stage with huffman algorithm
class MinPQ
{
  private int maxSize;
  private long[] queue;
  private int nItems;
  
  MinPQ(int s)
  {
    maxSize = s;
    queue = new long[maxSize];
    nItems = 0;
  }
  
  void insert(long item)
  {
    int i;
    if (nItems == 0) {
      queue[nItems++] = item;
    } else {
      for (i = nItems - 1; i >= 0; i--) {
        if (item > queue[i]) {
          queue[i + 1] = queue[i];
        } else {
          break;
        }
      }
        
      queue[i + 1] = item;
      nItems++;
    }
  }
  
  long remove()
  {
    return queue[--nItems];
  }
  
  long peekMin()
  {
    return queue[nItems - 1];
  }
  
  boolean isEmpty()
  {
    return (nItems == 0);
  }
  
  boolean isFull()
  {
    return (nItems == maxSize);
  }
}

ImageBlock[] blocks;
ImageBlock[] transformedBlocks;
ImageBlock[] quantizedBlocks;
ImageBlock[] finalImage;
int blockSize = 8;

int[] QLum;
int[] QChrom;

double jpeg_quality_degradation_luminance = 1.0;
double jpeg_quality_degradation_chrominance = 1.0;

void computeImage() {
  blocks = buildBlocks(img, blockSize);
  transformedBlocks = discreteCosineTransform(blocks, blockSize);

  for (int i = 0; i < defaultQLuminance.length; i++) {
		QLum[i] = defaultQLuminance[i];
		QChrom[i] = defaultQChrominance[i];
		
    QLum[i] *= jpeg_quality_degradation_luminance;
    QChrom[i] *= jpeg_quality_degradation_chrominance;
  }
  
  quantizedBlocks = quantizer(transformedBlocks, blockSize, QLum, QChrom);
  finalImage = inverseDiscreteCosineTransform(quantizedBlocks, blockSize);
}

void setup() {
  size(512, 300);
  noFill();
  stroke(255);
  frameRate(12);
	background(0);
	
	img = loadImage(""sea.jpg"");
	
	QLum = new int[defaultQLuminance.length()];
	QChrom = new int[defaultQChrominance.length()];

	computeImage();
	
	updateBlocks(finalImage, blockSize);
/*
  MinPQ hufftree = new MinPQ(10);
*/
}

ImageBlock[] buildBlocks(PImage src_img, int blockLength) {
  ImageBlock[] dst_blocks = new ImageBlock[ceil((src_img.width/blockLength) * (src_img.height/blockLength))];
  int dst_blockSize = blockLength*blockLength;
  
  //Pixel[] pixels = new Pixel[dst_blockSize];
  
  int start_x = 0;
  int start_y = 0;
  
  src_img.loadPixels();
  for (int i = 0; i < dst_blocks.length(); i++) {
    Pixel[] pxs = new Pixel[dst_blockSize];
    for(int e = start_x; e < start_x+blockLength; e++) {
      int off_x = e-start_x;
      
      for(int j = start_y; j < start_y+blockLength; j++) {
        int index = e+j*src_img.width;
				color c = src_img.pixels[index];
        int r = red(c);//(img.pixels[index]>>16)&0xff;
        int g = green(c);//(img.pixels[index]>>8)&0xff;
        int b = blue(c);//img.pixels[index]&0xff;
       
        pxs[off_x+(j-start_y)*blockLength] = new Pixel(r, g, b);
      }
    }
    
    start_x += blockLength;
    if (start_x%src_img.width == 0) {
      start_x = 0;
      start_y += blockLength;
    }
    
    dst_blocks[i] = new ImageBlock(pxs);
  }
  
  return dst_blocks;
}

void updateBlocks(ImageBlock[] src_blocks, int blockLength) {
  int start_x = 0, start_y = 0;
  imge = createImage(img.width, img.height, RGB);
  imge.loadPixels();
  for (int i = 0; i < src_blocks.length(); i++) {
    for(int e = 0; e < blockLength; e++) {
      int off_x = e+start_x;
      
      for(int j = 0; j < blockLength; j++) {
        int index = e+j*blockLength;

        src_blocks[i].pxs[index].toRgb();
        imge.pixels[off_x+(j+start_y)*imge.width] = color(src_blocks[i].pxs[index].pr, src_blocks[i].pxs[index].pg, src_blocks[i].pxs[index].pb, 255); 
      }
    }
    
    start_x += blockLength;
    if (start_x%imge.width == 0) {
      start_x = 0;
      start_y += blockLength;
    }
  }

  imge.updatePixels();
}

ImageBlock[] discreteCosineTransform(ImageBlock[] src_blocks, int blockLength) {
  int start_x = 0, start_y = 0;
  for (int i = 0; i < src_blocks.length(); i++) {
    double o = 0, p = 0;
    int N = blockLength;
    double sqrt_rec_N = 1/sqrt(2); // 1/sqrt(n)
    double sqrt_rec2_N = 2/sqrt(N);
    double tmpy, tmpcb, tmpcr;
    
    for(int k=0;k<blockLength;k++) {
      o=0;

        if (k == 0) {
          o = sqrt_rec_N;
        } else {
          o = 1;
        }
        
      for(int l=0;l<blockLength;l++) {
        p=0;
        tmpy=tmpcb=tmpcr=0;

        if (l == 0) {
          p = sqrt_rec_N;
        } else {
          p = 1;
        }
        
        double mul = 0.25*(o*p);
            
        for (int m=0;m<blockLength;m++) {
          double xx_dct = cos(((2.0*m+1)*PI*k) /(2*N));
          
          for(int n=0;n<blockLength;n++) { 
            double dct = xx_dct * (cos(((2.0*n+1)*PI*l)/(2*N)));
            int index = m+n*blockLength;
            
            tmpy+= src_blocks[i].pxs[index].y*dct*mul; 
            tmpcb+= src_blocks[i].pxs[index].cb*dct*mul; 
            tmpcr+= src_blocks[i].pxs[index].cr*dct*mul; 
          }
        }
        
        int index = k+l*blockLength;
        
        src_blocks[i].pxs[index].cy = tmpy;
        src_blocks[i].pxs[index].ccb = tmpcb;
        src_blocks[i].pxs[index].ccr = tmpcr;
      }
    }
    
    start_x += blockLength;
    if (start_x%img.width == 0) {
      start_x = 0;
      start_y += blockLength;
    }
  }
  
  return src_blocks;
}

ImageBlock[] inverseDiscreteCosineTransform(ImageBlock[] src_blocks, int blockLength) {
  int start_x = 0, start_y = 0;
  for (int i = 0; i < src_blocks.length(); i++) {
    double o = 0, p = 0;
    int N = blockLength;
    double sqrt_rec_N = 1/sqrt(2);
    double sqrt_rec2_N = 2/sqrt(N);
    double tmpy, tmpcb, tmpcr;
    for(int k=0;k<blockLength;k++) {
      for(int l=0;l<blockLength;l++) {
        tmpy=tmpcb=tmpcr=0;
  
        for (int m=0;m<blockLength;m++) {
          for(int n=0;n<blockLength;n++) { 
            o=0;p=0;
            if (m == 0) {
              o = sqrt_rec_N;
            } else {
              o = 1;
            }
            
            if (n == 0) {
              p = sqrt_rec_N;
            } else {
              p = 1;
            }
            
            double mul = 0.25*(o*p);
        
            double dct = (cos( ((2.0*k+1)*PI*m) /(2*N))) * (cos(((2.0*l+1)*PI*n)/(2*N)));
            int index = m+n*blockLength;
            
            tmpy+= mul*src_blocks[i].pxs[index].cy*dct;  
            tmpcb+= mul*src_blocks[i].pxs[index].ccb*dct; 
            tmpcr+= mul*src_blocks[i].pxs[index].ccr*dct; 
          }
        }
        
        int index = k+l*blockLength;
        src_blocks[i].pxs[index].y = (int)tmpy;
        src_blocks[i].pxs[index].cb = (int)tmpcb;
        src_blocks[i].pxs[index].cr = (int)tmpcr;
      }
    }
    
    start_x += blockLength;
    if (start_x%img.width == 0) {
      start_x = 0;
      start_y += blockLength;
    }
  }
  
  return src_blocks;
}

ImageBlock[] quantizer(ImageBlock[] src_blocks, int blockLength, int[] QLuminance, int[] QChrominance) {
  int start_x = 0, start_y = 0;
  for (int i = 0; i < src_blocks.length(); i++) {
    double tmpy, tmpcb, tmpcr;
    
    for(int e=0;e<blockLength;e++) {
      for(int j=0;j<blockLength;j++) {
        int index = e+j*blockLength;
        
        src_blocks[i].pxs[index].cy = round((float)(src_blocks[i].pxs[index].cy/QChrominance[index]))*QChrominance[index];
        src_blocks[i].pxs[index].ccb = round((float)(src_blocks[i].pxs[index].ccb/QLuminance[index]))*QLuminance[index];
        src_blocks[i].pxs[index].ccr = round((float)(src_blocks[i].pxs[index].ccr/QLuminance[index]))*QLuminance[index];
      }
    }
    
    start_x += blockLength;
    if (start_x%img.width == 0) {
      start_x = 0;
      start_y += blockLength;
    }
  }
  
  return src_blocks;
}

int pmx = mouseX;
int pmy = mouseY;

void draw() {  
	background(0);
	
	image(imge, 0, 0);

	image(img, img.width, 0);
	
	if (pmx != mouseX || pmy != mouseY) {
		background(0);
		
		pmx = mouseX;
		pmy = mouseY;
		
		jpeg_quality_degradation_luminance = mouseX / width * 10;
		jpeg_quality_degradation_chrominance = mouseY / height * 10;
		
		fill(255, 255, 255, 255);
		textSize(24);
		text(""JPEG processing..."", 8, 32);

		computeImage();

		updateBlocks(finalImage, blockSize);
	}
	
	textSize(16);
	text(""luminance degradation : "" + jpeg_quality_degradation_luminance, 8, 278);
	textSize(16);
	text(""chrominance degradation : "" + jpeg_quality_degradation_chrominance, 8, 278 + 16);
}"
"580526","JPEG algorithm","mySketch","PImage img;
PImage imge;

// tables from http://www.impulseadventure.com/photo/jpeg-quantization.html
int[] defaultQLuminance = {16, 11, 10, 16, 24,  40,  51,  61,
                           12, 12, 14, 19, 26,  58,  60,  55,
                           14, 13, 16, 24, 40,  57,  69,  56,
                           14, 17, 22, 29, 51,  87,  80,  62,
                           18, 22, 37, 56, 68,  109, 103, 77,
                           24, 35, 55, 64, 81,  104, 113, 92,
                           49, 64, 78, 87, 103, 121, 120, 101,
                           72, 92, 95, 98, 112, 100, 103, 99,
                         
                           16, 11, 10, 16, 24,  40,  51,  61, // 8x8 matrix for 16x16
                           12, 12, 14, 19, 26,  58,  60,  55,
                           14, 13, 16, 24, 40,  57,  69,  56,
                           14, 17, 22, 29, 51,  87,  80,  62,
                           18, 22, 37, 56, 68,  109, 103, 77,
                           24, 35, 55, 64, 81,  104, 113, 92,
                           49, 64, 78, 87, 103, 121, 120, 101,
                           72, 92, 95, 98, 112, 100, 103, 99};
                           
int[] defaultQChrominance = {17, 18, 24, 47, 99, 99, 99, 99,
                             18, 21, 26, 66, 99, 99, 99, 99,
                             24, 26, 56, 99, 99, 99, 99, 99,
                             47, 66, 99, 99, 99, 99, 99, 99,
                             99, 99, 99, 99, 99, 99, 99, 99,
                             99, 99, 99, 99, 99, 99, 99, 99,
                             99, 99, 99, 99, 99, 99, 99, 99,
                             99, 99, 99, 99, 99, 99, 99, 99,
                           
                             17, 18, 24, 47, 99, 99, 99, 99, // 8x8 matrix for 16x16
                             18, 21, 26, 66, 99, 99, 99, 99,
                             24, 26, 56, 99, 99, 99, 99, 99,
                             47, 66, 99, 99, 99, 99, 99, 99,
                             99, 99, 99, 99, 99, 99, 99, 99,
                             99, 99, 99, 99, 99, 99, 99, 99,
                             99, 99, 99, 99, 99, 99, 99, 99,
                             99, 99, 99, 99, 99, 99, 99, 99};

class Pixel {
  int y, cb, cr;
  int pr, pg , pb;
  double cy, ccb, ccr; // dct coefficients for ycbcr
  
  Pixel(int r, int g, int b) {
    pr = r;
    pg = g;
    pb = b;
    
    y  = (int)( 0.299   * r + 0.587   * g + 0.114   * b);
    cb = (int)(-0.16874 * r - 0.33126 * g + 0.50000 * b);
    cr = (int)( 0.50000 * r - 0.41869 * g - 0.08131 * b);
  }
  
  void toRgb() {
    pr = (int)(y + 1.402 * cr); 
    pg = (int)(y - 0.344 * cb - 0.714 * cr); 
    pb = (int)(y + 1.772 * cb); 
    
    /*r = constrain(abs((int)(cy + 1.402 * ccr)), 0, 255); 
    g = constrain(abs((int)(cy - 0.344 * ccb - 0.714 * ccr)), 0, 255); 
    b = constrain(abs((int)(cy + 1.772 * ccb)), 0, 255); */
  }
}
  
class ImageBlock {
  Pixel[] pxs;
  
  ImageBlock(Pixel[] px) {
    pxs = px;
  }
}

// not used, this is a min priority queue initially done for the entropy coding stage with huffman algorithm
class MinPQ
{
  private int maxSize;
  private long[] queue;
  private int nItems;
  
  MinPQ(int s)
  {
    maxSize = s;
    queue = new long[maxSize];
    nItems = 0;
  }
  
  void insert(long item)
  {
    int i;
    if (nItems == 0) {
      queue[nItems++] = item;
    } else {
      for (i = nItems - 1; i >= 0; i--) {
        if (item > queue[i]) {
          queue[i + 1] = queue[i];
        } else {
          break;
        }
      }
        
      queue[i + 1] = item;
      nItems++;
    }
  }
  
  long remove()
  {
    return queue[--nItems];
  }
  
  long peekMin()
  {
    return queue[nItems - 1];
  }
  
  boolean isEmpty()
  {
    return (nItems == 0);
  }
  
  boolean isFull()
  {
    return (nItems == maxSize);
  }
}

ImageBlock[] blocks;
ImageBlock[] transformedBlocks;
ImageBlock[] quantizedBlocks;
ImageBlock[] finalImage;
int blockSize = 8; // buggy

int[] QLum;
int[] QChrom;

double jpeg_quality_degradation_luminance = 1.0;
double jpeg_quality_degradation_chrominance = 1.0;

void computeImage() {
  blocks = buildBlocks(img, blockSize);
  transformedBlocks = discreteCosineTransform(blocks, blockSize);

  for (int i = 0; i < defaultQLuminance.length; i++) {
		QLum[i] = defaultQLuminance[i];
		QChrom[i] = defaultQChrominance[i];
		
    QLum[i] *= jpeg_quality_degradation_luminance;
    QChrom[i] *= jpeg_quality_degradation_chrominance;
  }
  
  quantizedBlocks = quantizer(transformedBlocks, blockSize, QLum, QChrom);
  finalImage = inverseDiscreteCosineTransform(quantizedBlocks, blockSize);
}

void setup() {
  size(512, 300);
  noFill();
  stroke(255);
  frameRate(12);
	background(0);
	
	img = loadImage(""sea.jpg"");
	
	QLum = new int[defaultQLuminance.length()];
	QChrom = new int[defaultQChrominance.length()];

	computeImage();
	
	updateBlocks(finalImage, blockSize);
/*
  MinPQ hufftree = new MinPQ(10);
*/
}

ImageBlock[] buildBlocks(PImage src_img, int blockLength) {
  ImageBlock[] dst_blocks = new ImageBlock[ceil((src_img.width/blockLength) * (src_img.height/blockLength))];
  int dst_blockSize = blockLength*blockLength;
  
  //Pixel[] pixels = new Pixel[dst_blockSize];
  
  int start_x = 0;
  int start_y = 0;
  
  src_img.loadPixels();
  for (int i = 0; i < dst_blocks.length(); i++) {
    Pixel[] pxs = new Pixel[dst_blockSize];
    for(int e = start_x; e < start_x+blockLength; e++) {
      int off_x = e-start_x;
      
      for(int j = start_y; j < start_y+blockLength; j++) {
        int index = e+j*src_img.width;
				color c = src_img.pixels[index];
        int r = red(c);//(img.pixels[index]>>16)&0xff;
        int g = green(c);//(img.pixels[index]>>8)&0xff;
        int b = blue(c);//img.pixels[index]&0xff;
       
        pxs[off_x+(j-start_y)*blockLength] = new Pixel(r, g, b);
      }
    }
    
    start_x += blockLength;
    if (start_x%src_img.width == 0) {
      start_x = 0;
      start_y += blockLength;
    }
    
    dst_blocks[i] = new ImageBlock(pxs);
  }
  
  return dst_blocks;
}

void updateBlocks(ImageBlock[] src_blocks, int blockLength) {
  int start_x = 0, start_y = 0;
  imge = createImage(img.width, img.height, RGB);
  imge.loadPixels();
  for (int i = 0; i < src_blocks.length(); i++) {
    for(int e = 0; e < blockLength; e++) {
      int off_x = e+start_x;
      
      for(int j = 0; j < blockLength; j++) {
        int index = e+j*blockLength;

        src_blocks[i].pxs[index].toRgb();
        imge.pixels[off_x+(j+start_y)*imge.width] = color(src_blocks[i].pxs[index].pr, src_blocks[i].pxs[index].pg, src_blocks[i].pxs[index].pb, 255); 
      }
    }
    
    start_x += blockLength;
    if (start_x%imge.width == 0) {
      start_x = 0;
      start_y += blockLength;
    }
  }

  imge.updatePixels();
}

ImageBlock[] discreteCosineTransform(ImageBlock[] src_blocks, int blockLength) {
  int start_x = 0, start_y = 0;
  for (int i = 0; i < src_blocks.length(); i++) {
    double o = 0, p = 0;
    int N = blockLength;
    double sqrt_rec_N = 1/sqrt(2); // 1/sqrt(n)
    double sqrt_rec2_N = 2/sqrt(N);
    double tmpy, tmpcb, tmpcr;
    
    for(int k=0;k<blockLength;k++) {
      o=0;

        if (k == 0) {
          o = sqrt_rec_N;
        } else {
          o = 1;
        }
        
      for(int l=0;l<blockLength;l++) {
        p=0;
        tmpy=tmpcb=tmpcr=0;

        if (l == 0) {
          p = sqrt_rec_N;
        } else {
          p = 1;
        }
        
        double mul = 0.25*(o*p);
            
        for (int m=0;m<blockLength;m++) {
          double xx_dct = cos(((2.0*m+1)*PI*k) /(2*N));
          
          for(int n=0;n<blockLength;n++) { 
            double dct = xx_dct * (cos(((2.0*n+1)*PI*l)/(2*N)));
            int index = m+n*blockLength;
            
            tmpy+= src_blocks[i].pxs[index].y*dct*mul; 
            tmpcb+= src_blocks[i].pxs[index].cb*dct*mul; 
            tmpcr+= src_blocks[i].pxs[index].cr*dct*mul; 
          }
        }
        
        int index = k+l*blockLength;
        
        src_blocks[i].pxs[index].cy = tmpy;
        src_blocks[i].pxs[index].ccb = tmpcb;
        src_blocks[i].pxs[index].ccr = tmpcr;
      }
    }
    
    start_x += blockLength;
    if (start_x%img.width == 0) {
      start_x = 0;
      start_y += blockLength;
    }
  }
  
  return src_blocks;
}

ImageBlock[] inverseDiscreteCosineTransform(ImageBlock[] src_blocks, int blockLength) {
  int start_x = 0, start_y = 0;
  for (int i = 0; i < src_blocks.length(); i++) {
    double o = 0, p = 0;
    int N = blockLength;
    double sqrt_rec_N = 1/sqrt(2);
    double sqrt_rec2_N = 2/sqrt(N);
    double tmpy, tmpcb, tmpcr;
    for(int k=0;k<blockLength;k++) {
      for(int l=0;l<blockLength;l++) {
        tmpy=tmpcb=tmpcr=0;
  
        for (int m=0;m<blockLength;m++) {
          for(int n=0;n<blockLength;n++) { 
            o=0;p=0;
            if (m == 0) {
              o = sqrt_rec_N;
            } else {
              o = 1;
            }
            
            if (n == 0) {
              p = sqrt_rec_N;
            } else {
              p = 1;
            }
            
            double mul = 0.25*(o*p);
        
            double dct = (cos( ((2.0*k+1)*PI*m) /(2*N))) * (cos(((2.0*l+1)*PI*n)/(2*N)));
            int index = m+n*blockLength;
            
            tmpy+= mul*src_blocks[i].pxs[index].cy*dct;  
            tmpcb+= mul*src_blocks[i].pxs[index].ccb*dct; 
            tmpcr+= mul*src_blocks[i].pxs[index].ccr*dct; 
          }
        }
        
        int index = k+l*blockLength;
        src_blocks[i].pxs[index].y = (int)tmpy;
        src_blocks[i].pxs[index].cb = (int)tmpcb;
        src_blocks[i].pxs[index].cr = (int)tmpcr;
      }
    }
    
    start_x += blockLength;
    if (start_x%img.width == 0) {
      start_x = 0;
      start_y += blockLength;
    }
  }
  
  return src_blocks;
}

ImageBlock[] quantizer(ImageBlock[] src_blocks, int blockLength, int[] QLuminance, int[] QChrominance) {
  int start_x = 0, start_y = 0;
  for (int i = 0; i < src_blocks.length(); i++) {
    double tmpy, tmpcb, tmpcr;
    
    for(int e=0;e<blockLength;e++) {
      for(int j=0;j<blockLength;j++) {
        int index = e+j*blockLength;
        
        src_blocks[i].pxs[index].cy = round((float)(src_blocks[i].pxs[index].cy/QChrominance[index]))*QChrominance[index];
        src_blocks[i].pxs[index].ccb = round((float)(src_blocks[i].pxs[index].ccb/QLuminance[index]))*QLuminance[index];
        src_blocks[i].pxs[index].ccr = round((float)(src_blocks[i].pxs[index].ccr/QLuminance[index]))*QLuminance[index];
      }
    }
    
    start_x += blockLength;
    if (start_x%img.width == 0) {
      start_x = 0;
      start_y += blockLength;
    }
  }
  
  return src_blocks;
}

int pmx = mouseX;
int pmy = mouseY;

void draw() {  
	background(0);
	
	image(imge, 0, 0);

	image(img, img.width, 0);
	
	if (pmx != mouseX || pmy != mouseY) {
		background(0);
		
		pmx = mouseX;
		pmy = mouseY;
		
		jpeg_quality_degradation_luminance = mouseX / width * 10;
		jpeg_quality_degradation_chrominance = mouseY / height * 10;
		
		fill(255, 255, 255, 255);
		textSize(24);
		text(""JPEG processing..."", 8, 32);

		computeImage();

		updateBlocks(finalImage, blockSize);
	}
	
	textSize(16);
	text(""luminance degradation : "" + jpeg_quality_degradation_luminance, 8, 278);
	textSize(16);
	text(""chrominance degradation : "" + jpeg_quality_degradation_chrominance, 8, 278 + 16);
}"
"580526","JPEG algorithm","mySketch","PImage img;
PImage imge;

// tables from http://www.impulseadventure.com/photo/jpeg-quantization.html
int[] defaultQLuminance = {16, 11, 10, 16, 24,  40,  51,  61,
                           12, 12, 14, 19, 26,  58,  60,  55,
                           14, 13, 16, 24, 40,  57,  69,  56,
                           14, 17, 22, 29, 51,  87,  80,  62,
                           18, 22, 37, 56, 68,  109, 103, 77,
                           24, 35, 55, 64, 81,  104, 113, 92,
                           49, 64, 78, 87, 103, 121, 120, 101,
                           72, 92, 95, 98, 112, 100, 103, 99,
                         
                           16, 11, 10, 16, 24,  40,  51,  61, // 8x8 matrix for 16x16
                           12, 12, 14, 19, 26,  58,  60,  55,
                           14, 13, 16, 24, 40,  57,  69,  56,
                           14, 17, 22, 29, 51,  87,  80,  62,
                           18, 22, 37, 56, 68,  109, 103, 77,
                           24, 35, 55, 64, 81,  104, 113, 92,
                           49, 64, 78, 87, 103, 121, 120, 101,
                           72, 92, 95, 98, 112, 100, 103, 99};
                           
int[] defaultQChrominance = {17, 18, 24, 47, 99, 99, 99, 99,
                             18, 21, 26, 66, 99, 99, 99, 99,
                             24, 26, 56, 99, 99, 99, 99, 99,
                             47, 66, 99, 99, 99, 99, 99, 99,
                             99, 99, 99, 99, 99, 99, 99, 99,
                             99, 99, 99, 99, 99, 99, 99, 99,
                             99, 99, 99, 99, 99, 99, 99, 99,
                             99, 99, 99, 99, 99, 99, 99, 99,
                           
                             17, 18, 24, 47, 99, 99, 99, 99, // 8x8 matrix for 16x16
                             18, 21, 26, 66, 99, 99, 99, 99,
                             24, 26, 56, 99, 99, 99, 99, 99,
                             47, 66, 99, 99, 99, 99, 99, 99,
                             99, 99, 99, 99, 99, 99, 99, 99,
                             99, 99, 99, 99, 99, 99, 99, 99,
                             99, 99, 99, 99, 99, 99, 99, 99,
                             99, 99, 99, 99, 99, 99, 99, 99};

class Pixel {
  int y, cb, cr;
  int pr, pg , pb;
  double cy, ccb, ccr; // dct coefficients for ycbcr
  
  Pixel(int r, int g, int b) {
    pr = r;
    pg = g;
    pb = b;
    
    y  = (int)( 0.299   * r + 0.587   * g + 0.114   * b);
    cb = (int)(-0.16874 * r - 0.33126 * g + 0.50000 * b);
    cr = (int)( 0.50000 * r - 0.41869 * g - 0.08131 * b);
  }
  
  void toRgb() {
    pr = (int)(y + 1.402 * cr); 
    pg = (int)(y - 0.344 * cb - 0.714 * cr); 
    pb = (int)(y + 1.772 * cb); 
    
    /*r = constrain(abs((int)(cy + 1.402 * ccr)), 0, 255); 
    g = constrain(abs((int)(cy - 0.344 * ccb - 0.714 * ccr)), 0, 255); 
    b = constrain(abs((int)(cy + 1.772 * ccb)), 0, 255); */
  }
}
  
class ImageBlock {
  Pixel[] pxs;
  
  ImageBlock(Pixel[] px) {
    pxs = px;
  }
}

// not used, this is a min priority queue initially done for the entropy coding stage with huffman algorithm
class MinPQ
{
  private int maxSize;
  private long[] queue;
  private int nItems;
  
  MinPQ(int s)
  {
    maxSize = s;
    queue = new long[maxSize];
    nItems = 0;
  }
  
  void insert(long item)
  {
    int i;
    if (nItems == 0) {
      queue[nItems++] = item;
    } else {
      for (i = nItems - 1; i >= 0; i--) {
        if (item > queue[i]) {
          queue[i + 1] = queue[i];
        } else {
          break;
        }
      }
        
      queue[i + 1] = item;
      nItems++;
    }
  }
  
  long remove()
  {
    return queue[--nItems];
  }
  
  long peekMin()
  {
    return queue[nItems - 1];
  }
  
  boolean isEmpty()
  {
    return (nItems == 0);
  }
  
  boolean isFull()
  {
    return (nItems == maxSize);
  }
}

ImageBlock[] blocks;
ImageBlock[] transformedBlocks;
ImageBlock[] quantizedBlocks;
ImageBlock[] finalImage;
int blockSize = 8; // buggy

int[] QLum;
int[] QChrom;

double jpeg_quality_degradation_luminance = 1.0;
double jpeg_quality_degradation_chrominance = 1.0;

void computeImage() {
  blocks = buildBlocks(img, blockSize);
  transformedBlocks = discreteCosineTransform(blocks, blockSize);

  for (int i = 0; i < defaultQLuminance.length; i++) {
		QLum[i] = defaultQLuminance[i];
		QChrom[i] = defaultQChrominance[i];
		
    QLum[i] *= jpeg_quality_degradation_luminance;
    QChrom[i] *= jpeg_quality_degradation_chrominance;
  }
  
  quantizedBlocks = quantizer(transformedBlocks, blockSize, QLum, QChrom);
  finalImage = inverseDiscreteCosineTransform(quantizedBlocks, blockSize);
}

void setup() {
  size(512, 300);
  noFill();
  stroke(255);
  frameRate(12);
	background(0);
	
	img = loadImage(""sea.jpg"");
	
	QLum = new int[defaultQLuminance.length()];
	QChrom = new int[defaultQChrominance.length()];

	computeImage();

	updateBlocks(finalImage, blockSize);
/*
  MinPQ hufftree = new MinPQ(10);
*/
}

ImageBlock[] buildBlocks(PImage src_img, int blockLength) {
  ImageBlock[] dst_blocks = new ImageBlock[ceil((src_img.width/blockLength) * (src_img.height/blockLength))];
  int dst_blockSize = blockLength*blockLength;
  
  //Pixel[] pixels = new Pixel[dst_blockSize];
  
  int start_x = 0;
  int start_y = 0;
  
  src_img.loadPixels();
  for (int i = 0; i < dst_blocks.length(); i++) {
    Pixel[] pxs = new Pixel[dst_blockSize];
    for(int e = start_x; e < start_x+blockLength; e++) {
      int off_x = e-start_x;
      
      for(int j = start_y; j < start_y+blockLength; j++) {
        int index = e+j*src_img.width;
				color c = src_img.pixels[index];
        int r = red(c);//(img.pixels[index]>>16)&0xff;
        int g = green(c);//(img.pixels[index]>>8)&0xff;
        int b = blue(c);//img.pixels[index]&0xff;
       
        pxs[off_x+(j-start_y)*blockLength] = new Pixel(r, g, b);
      }
    }
    
    start_x += blockLength;
    if (start_x%src_img.width == 0) {
      start_x = 0;
      start_y += blockLength;
    }
    
    dst_blocks[i] = new ImageBlock(pxs);
  }
  
  return dst_blocks;
}

void updateBlocks(ImageBlock[] src_blocks, int blockLength) {
  int start_x = 0, start_y = 0;
  imge = createImage(img.width, img.height, RGB);
  imge.loadPixels();
  for (int i = 0; i < src_blocks.length(); i++) {
    for(int e = 0; e < blockLength; e++) {
      int off_x = e+start_x;
      
      for(int j = 0; j < blockLength; j++) {
        int index = e+j*blockLength;

        src_blocks[i].pxs[index].toRgb();
        imge.pixels[off_x+(j+start_y)*imge.width] = color(src_blocks[i].pxs[index].pr, src_blocks[i].pxs[index].pg, src_blocks[i].pxs[index].pb, 255); 
      }
    }
    
    start_x += blockLength;
    if (start_x%imge.width == 0) {
      start_x = 0;
      start_y += blockLength;
    }
  }

  imge.updatePixels();
}

ImageBlock[] discreteCosineTransform(ImageBlock[] src_blocks, int blockLength) {
  int start_x = 0, start_y = 0;
  for (int i = 0; i < src_blocks.length(); i++) {
    double o = 0, p = 0;
    int N = blockLength;
    double sqrt_rec_N = 1/sqrt(2); // 1/sqrt(n)
    double sqrt_rec2_N = 2/sqrt(N);
    double tmpy, tmpcb, tmpcr;
    
    for(int k=0;k<blockLength;k++) {
      o=0;

        if (k == 0) {
          o = sqrt_rec_N;
        } else {
          o = 1;
        }
        
      for(int l=0;l<blockLength;l++) {
        p=0;
        tmpy=tmpcb=tmpcr=0;

        if (l == 0) {
          p = sqrt_rec_N;
        } else {
          p = 1;
        }
        
        double mul = 0.25*(o*p);
            
        for (int m=0;m<blockLength;m++) {
          double xx_dct = cos(((2.0*m+1)*PI*k) /(2*N));
          
          for(int n=0;n<blockLength;n++) { 
            double dct = xx_dct * (cos(((2.0*n+1)*PI*l)/(2*N)));
            int index = m+n*blockLength;
            
            tmpy+= src_blocks[i].pxs[index].y*dct*mul; 
            tmpcb+= src_blocks[i].pxs[index].cb*dct*mul; 
            tmpcr+= src_blocks[i].pxs[index].cr*dct*mul; 
          }
        }
        
        int index = k+l*blockLength;
        
        src_blocks[i].pxs[index].cy = tmpy;
        src_blocks[i].pxs[index].ccb = tmpcb;
        src_blocks[i].pxs[index].ccr = tmpcr;
      }
    }
    
    start_x += blockLength;
    if (start_x%img.width == 0) {
      start_x = 0;
      start_y += blockLength;
    }
  }
  
  return src_blocks;
}

ImageBlock[] inverseDiscreteCosineTransform(ImageBlock[] src_blocks, int blockLength) {
  int start_x = 0, start_y = 0;
  for (int i = 0; i < src_blocks.length(); i++) {
    double o = 0, p = 0;
    int N = blockLength;
    double sqrt_rec_N = 1/sqrt(2);
    double sqrt_rec2_N = 2/sqrt(N);
    double tmpy, tmpcb, tmpcr;
    for(int k=0;k<blockLength;k++) {
      for(int l=0;l<blockLength;l++) {
        tmpy=tmpcb=tmpcr=0;
  
        for (int m=0;m<blockLength;m++) {
          for(int n=0;n<blockLength;n++) { 
            o=0;p=0;
            if (m == 0) {
              o = sqrt_rec_N;
            } else {
              o = 1;
            }
            
            if (n == 0) {
              p = sqrt_rec_N;
            } else {
              p = 1;
            }
            
            double mul = 0.25*(o*p);
        
            double dct = (cos( ((2.0*k+1)*PI*m) /(2*N))) * (cos(((2.0*l+1)*PI*n)/(2*N)));
            int index = m+n*blockLength;
            
            tmpy+= mul*src_blocks[i].pxs[index].cy*dct;  
            tmpcb+= mul*src_blocks[i].pxs[index].ccb*dct; 
            tmpcr+= mul*src_blocks[i].pxs[index].ccr*dct; 
          }
        }
        
        int index = k+l*blockLength;
        src_blocks[i].pxs[index].y = (int)tmpy;
        src_blocks[i].pxs[index].cb = (int)tmpcb;
        src_blocks[i].pxs[index].cr = (int)tmpcr;
      }
    }
    
    start_x += blockLength;
    if (start_x%img.width == 0) {
      start_x = 0;
      start_y += blockLength;
    }
  }
  
  return src_blocks;
}

ImageBlock[] quantizer(ImageBlock[] src_blocks, int blockLength, int[] QLuminance, int[] QChrominance) {
  int start_x = 0, start_y = 0;
  for (int i = 0; i < src_blocks.length(); i++) {
    double tmpy, tmpcb, tmpcr;
    
    for(int e=0;e<blockLength;e++) {
      for(int j=0;j<blockLength;j++) {
        int index = e+j*blockLength;
        
        src_blocks[i].pxs[index].cy = round((float)(src_blocks[i].pxs[index].cy/QChrominance[index]))*QChrominance[index];
        src_blocks[i].pxs[index].ccb = round((float)(src_blocks[i].pxs[index].ccb/QLuminance[index]))*QLuminance[index];
        src_blocks[i].pxs[index].ccr = round((float)(src_blocks[i].pxs[index].ccr/QLuminance[index]))*QLuminance[index];
      }
    }
    
    start_x += blockLength;
    if (start_x%img.width == 0) {
      start_x = 0;
      start_y += blockLength;
    }
  }
  
  return src_blocks;
}

int pmx = 8;
int pmy = 8;

void draw() {  
	background(0);
	
	image(imge, 0, 0);

	image(img, img.width, 0);
	
	if (pmx != mouseX || pmy != mouseY) {
		background(0);
		
		pmx = mouseX;
		pmy = mouseY;
		
		jpeg_quality_degradation_luminance = mouseX / width * 10;
		jpeg_quality_degradation_chrominance = mouseY / height * 10;
		
		if (jpeg_quality_degradation_luminance == 0 && jpeg_quality_degradation_chrominance == 0) {
			jpeg_quality_degradation_luminance = 1;
			jpeg_quality_degradation_chrominance = 1;
		}
		
		fill(255, 255, 255, 255);
		textSize(24);
		text(""JPEG processing..."", 8, 32);

		computeImage();

		updateBlocks(finalImage, blockSize);
	}
	
	textSize(16);
	text(""luminance degradation : "" + jpeg_quality_degradation_luminance, 8, 278);
	textSize(16);
	text(""chrominance degradation : "" + jpeg_quality_degradation_chrominance, 8, 278 + 16);
}"
"580526","JPEG algorithm","mySketch","/**
  * Old processing code ported to Processing.js; JPEG encoder / decoder done for an online course.
  */

PImage img;
PImage imge;

// tables from http://www.impulseadventure.com/photo/jpeg-quantization.html
int[] defaultQLuminance = {16, 11, 10, 16, 24,  40,  51,  61,
                           12, 12, 14, 19, 26,  58,  60,  55,
                           14, 13, 16, 24, 40,  57,  69,  56,
                           14, 17, 22, 29, 51,  87,  80,  62,
                           18, 22, 37, 56, 68,  109, 103, 77,
                           24, 35, 55, 64, 81,  104, 113, 92,
                           49, 64, 78, 87, 103, 121, 120, 101,
                           72, 92, 95, 98, 112, 100, 103, 99,
                         
                           16, 11, 10, 16, 24,  40,  51,  61, // 8x8 matrix for 16x16
                           12, 12, 14, 19, 26,  58,  60,  55,
                           14, 13, 16, 24, 40,  57,  69,  56,
                           14, 17, 22, 29, 51,  87,  80,  62,
                           18, 22, 37, 56, 68,  109, 103, 77,
                           24, 35, 55, 64, 81,  104, 113, 92,
                           49, 64, 78, 87, 103, 121, 120, 101,
                           72, 92, 95, 98, 112, 100, 103, 99};
                           
int[] defaultQChrominance = {17, 18, 24, 47, 99, 99, 99, 99,
                             18, 21, 26, 66, 99, 99, 99, 99,
                             24, 26, 56, 99, 99, 99, 99, 99,
                             47, 66, 99, 99, 99, 99, 99, 99,
                             99, 99, 99, 99, 99, 99, 99, 99,
                             99, 99, 99, 99, 99, 99, 99, 99,
                             99, 99, 99, 99, 99, 99, 99, 99,
                             99, 99, 99, 99, 99, 99, 99, 99,
                           
                             17, 18, 24, 47, 99, 99, 99, 99, // 8x8 matrix for 16x16
                             18, 21, 26, 66, 99, 99, 99, 99,
                             24, 26, 56, 99, 99, 99, 99, 99,
                             47, 66, 99, 99, 99, 99, 99, 99,
                             99, 99, 99, 99, 99, 99, 99, 99,
                             99, 99, 99, 99, 99, 99, 99, 99,
                             99, 99, 99, 99, 99, 99, 99, 99,
                             99, 99, 99, 99, 99, 99, 99, 99};

class Pixel {
  int y, cb, cr;
  int pr, pg , pb;
  double cy, ccb, ccr; // dct coefficients for ycbcr
  
  Pixel(int r, int g, int b) {
    pr = r;
    pg = g;
    pb = b;
    
    y  = (int)( 0.299   * r + 0.587   * g + 0.114   * b);
    cb = (int)(-0.16874 * r - 0.33126 * g + 0.50000 * b);
    cr = (int)( 0.50000 * r - 0.41869 * g - 0.08131 * b);
  }
  
  void toRgb() {
    pr = (int)(y + 1.402 * cr); 
    pg = (int)(y - 0.344 * cb - 0.714 * cr); 
    pb = (int)(y + 1.772 * cb); 
    
    /*r = constrain(abs((int)(cy + 1.402 * ccr)), 0, 255); 
    g = constrain(abs((int)(cy - 0.344 * ccb - 0.714 * ccr)), 0, 255); 
    b = constrain(abs((int)(cy + 1.772 * ccb)), 0, 255); */
  }
}
  
class ImageBlock {
  Pixel[] pxs;
  
  ImageBlock(Pixel[] px) {
    pxs = px;
  }
}

// not used, this is a min priority queue initially done for the entropy coding stage with huffman algorithm
class MinPQ
{
  private int maxSize;
  private long[] queue;
  private int nItems;
  
  MinPQ(int s)
  {
    maxSize = s;
    queue = new long[maxSize];
    nItems = 0;
  }
  
  void insert(long item)
  {
    int i;
    if (nItems == 0) {
      queue[nItems++] = item;
    } else {
      for (i = nItems - 1; i >= 0; i--) {
        if (item > queue[i]) {
          queue[i + 1] = queue[i];
        } else {
          break;
        }
      }
        
      queue[i + 1] = item;
      nItems++;
    }
  }
  
  long remove()
  {
    return queue[--nItems];
  }
  
  long peekMin()
  {
    return queue[nItems - 1];
  }
  
  boolean isEmpty()
  {
    return (nItems == 0);
  }
  
  boolean isFull()
  {
    return (nItems == maxSize);
  }
}

ImageBlock[] blocks;
ImageBlock[] transformedBlocks;
ImageBlock[] quantizedBlocks;
ImageBlock[] finalImage;
int blockSize = 8; // buggy

int[] QLum;
int[] QChrom;

double jpeg_quality_degradation_luminance = 1.0;
double jpeg_quality_degradation_chrominance = 1.0;

void computeImage() {
  blocks = buildBlocks(img, blockSize);
  transformedBlocks = discreteCosineTransform(blocks, blockSize);

  for (int i = 0; i < defaultQLuminance.length; i++) {
		QLum[i] = defaultQLuminance[i];
		QChrom[i] = defaultQChrominance[i];
		
    QLum[i] *= jpeg_quality_degradation_luminance;
    QChrom[i] *= jpeg_quality_degradation_chrominance;
  }
  
  quantizedBlocks = quantizer(transformedBlocks, blockSize, QLum, QChrom);
  finalImage = inverseDiscreteCosineTransform(quantizedBlocks, blockSize);
}

void setup() {
  size(512, 300);
  noFill();
  stroke(255);
  frameRate(12);
	background(0);
	
	img = loadImage(""sea.jpg"");
	
	QLum = new int[defaultQLuminance.length()];
	QChrom = new int[defaultQChrominance.length()];

	computeImage();

	updateBlocks(finalImage, blockSize);
/*
  MinPQ hufftree = new MinPQ(10);
*/
}

ImageBlock[] buildBlocks(PImage src_img, int blockLength) {
  ImageBlock[] dst_blocks = new ImageBlock[ceil((src_img.width/blockLength) * (src_img.height/blockLength))];
  int dst_blockSize = blockLength*blockLength;
  
  //Pixel[] pixels = new Pixel[dst_blockSize];
  
  int start_x = 0;
  int start_y = 0;
  
  src_img.loadPixels();
  for (int i = 0; i < dst_blocks.length(); i++) {
    Pixel[] pxs = new Pixel[dst_blockSize];
    for(int e = start_x; e < start_x+blockLength; e++) {
      int off_x = e-start_x;
      
      for(int j = start_y; j < start_y+blockLength; j++) {
        int index = e+j*src_img.width;
				color c = src_img.pixels[index];
        int r = red(c);//(img.pixels[index]>>16)&0xff;
        int g = green(c);//(img.pixels[index]>>8)&0xff;
        int b = blue(c);//img.pixels[index]&0xff;
       
        pxs[off_x+(j-start_y)*blockLength] = new Pixel(r, g, b);
      }
    }
    
    start_x += blockLength;
    if (start_x%src_img.width == 0) {
      start_x = 0;
      start_y += blockLength;
    }
    
    dst_blocks[i] = new ImageBlock(pxs);
  }
  
  return dst_blocks;
}

void updateBlocks(ImageBlock[] src_blocks, int blockLength) {
  int start_x = 0, start_y = 0;
  imge = createImage(img.width, img.height, RGB);
  imge.loadPixels();
  for (int i = 0; i < src_blocks.length(); i++) {
    for(int e = 0; e < blockLength; e++) {
      int off_x = e+start_x;
      
      for(int j = 0; j < blockLength; j++) {
        int index = e+j*blockLength;

        src_blocks[i].pxs[index].toRgb();
        imge.pixels[off_x+(j+start_y)*imge.width] = color(src_blocks[i].pxs[index].pr, src_blocks[i].pxs[index].pg, src_blocks[i].pxs[index].pb, 255); 
      }
    }
    
    start_x += blockLength;
    if (start_x%imge.width == 0) {
      start_x = 0;
      start_y += blockLength;
    }
  }

  imge.updatePixels();
}

ImageBlock[] discreteCosineTransform(ImageBlock[] src_blocks, int blockLength) {
  int start_x = 0, start_y = 0;
  for (int i = 0; i < src_blocks.length(); i++) {
    double o = 0, p = 0;
    int N = blockLength;
    double sqrt_rec_N = 1/sqrt(2); // 1/sqrt(n)
    double sqrt_rec2_N = 2/sqrt(N);
    double tmpy, tmpcb, tmpcr;
    
    for(int k=0;k<blockLength;k++) {
      o=0;

        if (k == 0) {
          o = sqrt_rec_N;
        } else {
          o = 1;
        }
        
      for(int l=0;l<blockLength;l++) {
        p=0;
        tmpy=tmpcb=tmpcr=0;

        if (l == 0) {
          p = sqrt_rec_N;
        } else {
          p = 1;
        }
        
        double mul = 0.25*(o*p);
            
        for (int m=0;m<blockLength;m++) {
          double xx_dct = cos(((2.0*m+1)*PI*k) /(2*N));
          
          for(int n=0;n<blockLength;n++) { 
            double dct = xx_dct * (cos(((2.0*n+1)*PI*l)/(2*N)));
            int index = m+n*blockLength;
            
            tmpy+= src_blocks[i].pxs[index].y*dct*mul; 
            tmpcb+= src_blocks[i].pxs[index].cb*dct*mul; 
            tmpcr+= src_blocks[i].pxs[index].cr*dct*mul; 
          }
        }
        
        int index = k+l*blockLength;
        
        src_blocks[i].pxs[index].cy = tmpy;
        src_blocks[i].pxs[index].ccb = tmpcb;
        src_blocks[i].pxs[index].ccr = tmpcr;
      }
    }
    
    start_x += blockLength;
    if (start_x%img.width == 0) {
      start_x = 0;
      start_y += blockLength;
    }
  }
  
  return src_blocks;
}

ImageBlock[] inverseDiscreteCosineTransform(ImageBlock[] src_blocks, int blockLength) {
  int start_x = 0, start_y = 0;
  for (int i = 0; i < src_blocks.length(); i++) {
    double o = 0, p = 0;
    int N = blockLength;
    double sqrt_rec_N = 1/sqrt(2);
    double sqrt_rec2_N = 2/sqrt(N);
    double tmpy, tmpcb, tmpcr;
    for(int k=0;k<blockLength;k++) {
      for(int l=0;l<blockLength;l++) {
        tmpy=tmpcb=tmpcr=0;
  
        for (int m=0;m<blockLength;m++) {
          for(int n=0;n<blockLength;n++) { 
            o=0;p=0;
            if (m == 0) {
              o = sqrt_rec_N;
            } else {
              o = 1;
            }
            
            if (n == 0) {
              p = sqrt_rec_N;
            } else {
              p = 1;
            }
            
            double mul = 0.25*(o*p);
        
            double dct = (cos( ((2.0*k+1)*PI*m) /(2*N))) * (cos(((2.0*l+1)*PI*n)/(2*N)));
            int index = m+n*blockLength;
            
            tmpy+= mul*src_blocks[i].pxs[index].cy*dct;  
            tmpcb+= mul*src_blocks[i].pxs[index].ccb*dct; 
            tmpcr+= mul*src_blocks[i].pxs[index].ccr*dct; 
          }
        }
        
        int index = k+l*blockLength;
        src_blocks[i].pxs[index].y = (int)tmpy;
        src_blocks[i].pxs[index].cb = (int)tmpcb;
        src_blocks[i].pxs[index].cr = (int)tmpcr;
      }
    }
    
    start_x += blockLength;
    if (start_x%img.width == 0) {
      start_x = 0;
      start_y += blockLength;
    }
  }
  
  return src_blocks;
}

ImageBlock[] quantizer(ImageBlock[] src_blocks, int blockLength, int[] QLuminance, int[] QChrominance) {
  int start_x = 0, start_y = 0;
  for (int i = 0; i < src_blocks.length(); i++) {
    double tmpy, tmpcb, tmpcr;
    
    for(int e=0;e<blockLength;e++) {
      for(int j=0;j<blockLength;j++) {
        int index = e+j*blockLength;
        
        src_blocks[i].pxs[index].cy = round((float)(src_blocks[i].pxs[index].cy/QChrominance[index]))*QChrominance[index];
        src_blocks[i].pxs[index].ccb = round((float)(src_blocks[i].pxs[index].ccb/QLuminance[index]))*QLuminance[index];
        src_blocks[i].pxs[index].ccr = round((float)(src_blocks[i].pxs[index].ccr/QLuminance[index]))*QLuminance[index];
      }
    }
    
    start_x += blockLength;
    if (start_x%img.width == 0) {
      start_x = 0;
      start_y += blockLength;
    }
  }
  
  return src_blocks;
}

int pmx = 8;
int pmy = 8;

void draw() {  
	background(0);
	
	image(imge, 0, 0);

	image(img, img.width, 0);
	
	if (pmx != mouseX || pmy != mouseY) {
		background(0);
		
		pmx = mouseX;
		pmy = mouseY;
		
		jpeg_quality_degradation_luminance = mouseX / width * 10;
		jpeg_quality_degradation_chrominance = mouseY / height * 10;
		
		if (jpeg_quality_degradation_luminance == 0 && jpeg_quality_degradation_chrominance == 0) {
			jpeg_quality_degradation_luminance = 1;
			jpeg_quality_degradation_chrominance = 1;
		}
		
		fill(255, 255, 255, 255);
		textSize(24);
		text(""JPEG processing..."", 8, 32);

		computeImage();

		updateBlocks(finalImage, blockSize);
	}
	
	textSize(16);
	text(""luminance degradation : "" + jpeg_quality_degradation_luminance, 8, 278);
	textSize(16);
	text(""chrominance degradation : "" + jpeg_quality_degradation_chrominance, 8, 278 + 16);
}"
"580526","JPEG algorithm","mySketch","/**
  * Old processing code ported to Processing.js; JPEG encoder / decoder done for an online course.
  */

PImage img;
PImage imge;

// tables from http://www.impulseadventure.com/photo/jpeg-quantization.html
int[] defaultQLuminance = {16, 11, 10, 16, 24,  40,  51,  61,
                           12, 12, 14, 19, 26,  58,  60,  55,
                           14, 13, 16, 24, 40,  57,  69,  56,
                           14, 17, 22, 29, 51,  87,  80,  62,
                           18, 22, 37, 56, 68,  109, 103, 77,
                           24, 35, 55, 64, 81,  104, 113, 92,
                           49, 64, 78, 87, 103, 121, 120, 101,
                           72, 92, 95, 98, 112, 100, 103, 99,
                         
                           16, 11, 10, 16, 24,  40,  51,  61, // 8x8 matrix for 16x16
                           12, 12, 14, 19, 26,  58,  60,  55,
                           14, 13, 16, 24, 40,  57,  69,  56,
                           14, 17, 22, 29, 51,  87,  80,  62,
                           18, 22, 37, 56, 68,  109, 103, 77,
                           24, 35, 55, 64, 81,  104, 113, 92,
                           49, 64, 78, 87, 103, 121, 120, 101,
                           72, 92, 95, 98, 112, 100, 103, 99};
                           
int[] defaultQChrominance = {17, 18, 24, 47, 99, 99, 99, 99,
                             18, 21, 26, 66, 99, 99, 99, 99,
                             24, 26, 56, 99, 99, 99, 99, 99,
                             47, 66, 99, 99, 99, 99, 99, 99,
                             99, 99, 99, 99, 99, 99, 99, 99,
                             99, 99, 99, 99, 99, 99, 99, 99,
                             99, 99, 99, 99, 99, 99, 99, 99,
                             99, 99, 99, 99, 99, 99, 99, 99,
                           
                             17, 18, 24, 47, 99, 99, 99, 99, // 8x8 matrix for 16x16
                             18, 21, 26, 66, 99, 99, 99, 99,
                             24, 26, 56, 99, 99, 99, 99, 99,
                             47, 66, 99, 99, 99, 99, 99, 99,
                             99, 99, 99, 99, 99, 99, 99, 99,
                             99, 99, 99, 99, 99, 99, 99, 99,
                             99, 99, 99, 99, 99, 99, 99, 99,
                             99, 99, 99, 99, 99, 99, 99, 99};

class Pixel {
  int y, cb, cr;
  int pr, pg , pb;
  double cy, ccb, ccr; // dct coefficients for ycbcr
  
  Pixel(int r, int g, int b) {
    pr = r;
    pg = g;
    pb = b;
    
    y  = (int)( 0.299   * r + 0.587   * g + 0.114   * b);
    cb = (int)(-0.16874 * r - 0.33126 * g + 0.50000 * b);
    cr = (int)( 0.50000 * r - 0.41869 * g - 0.08131 * b);
  }
  
  void toRgb() {
    pr = (int)(y + 1.402 * cr); 
    pg = (int)(y - 0.344 * cb - 0.714 * cr); 
    pb = (int)(y + 1.772 * cb); 
    
    /*r = constrain(abs((int)(cy + 1.402 * ccr)), 0, 255); 
    g = constrain(abs((int)(cy - 0.344 * ccb - 0.714 * ccr)), 0, 255); 
    b = constrain(abs((int)(cy + 1.772 * ccb)), 0, 255); */
  }
}
  
class ImageBlock {
  Pixel[] pxs;
  
  ImageBlock(Pixel[] px) {
    pxs = px;
  }
}

// not used, this is a min priority queue initially done for the entropy coding stage with huffman algorithm
class MinPQ
{
  private int maxSize;
  private long[] queue;
  private int nItems;
  
  MinPQ(int s)
  {
    maxSize = s;
    queue = new long[maxSize];
    nItems = 0;
  }
  
  void insert(long item)
  {
    int i;
    if (nItems == 0) {
      queue[nItems++] = item;
    } else {
      for (i = nItems - 1; i >= 0; i--) {
        if (item > queue[i]) {
          queue[i + 1] = queue[i];
        } else {
          break;
        }
      }
        
      queue[i + 1] = item;
      nItems++;
    }
  }
  
  long remove()
  {
    return queue[--nItems];
  }
  
  long peekMin()
  {
    return queue[nItems - 1];
  }
  
  boolean isEmpty()
  {
    return (nItems == 0);
  }
  
  boolean isFull()
  {
    return (nItems == maxSize);
  }
}

ImageBlock[] blocks;
ImageBlock[] transformedBlocks;
ImageBlock[] quantizedBlocks;
ImageBlock[] finalImage;
int blockSize = 8; // buggy

int[] QLum;
int[] QChrom;

double jpeg_quality_degradation_luminance = 1.0;
double jpeg_quality_degradation_chrominance = 1.0;

void computeImage() {
  blocks = buildBlocks(img, blockSize);
  transformedBlocks = discreteCosineTransform(blocks, blockSize);

  for (int i = 0; i < defaultQLuminance.length; i++) {
		QLum[i] = defaultQLuminance[i];
		QChrom[i] = defaultQChrominance[i];
		
    QLum[i] *= jpeg_quality_degradation_luminance;
    QChrom[i] *= jpeg_quality_degradation_chrominance;
  }
  
  quantizedBlocks = quantizer(transformedBlocks, blockSize, QLum, QChrom);
  finalImage = inverseDiscreteCosineTransform(quantizedBlocks, blockSize);
}

void setup() {
  size(512, 300);
  noFill();
  stroke(255);
  frameRate(12);
	background(0);
	
	img = loadImage(""sea.jpg"");
	
	QLum = new int[defaultQLuminance.length()];
	QChrom = new int[defaultQChrominance.length()];

	computeImage();

	updateBlocks(finalImage, blockSize);
/*
  MinPQ hufftree = new MinPQ(10);
*/
}

ImageBlock[] buildBlocks(PImage src_img, int blockLength) {
  ImageBlock[] dst_blocks = new ImageBlock[ceil((src_img.width/blockLength) * (src_img.height/blockLength))];
  int dst_blockSize = blockLength*blockLength;
  
  //Pixel[] pixels = new Pixel[dst_blockSize];
  
  int start_x = 0;
  int start_y = 0;
  
  src_img.loadPixels();
  for (int i = 0; i < dst_blocks.length(); i++) {
    Pixel[] pxs = new Pixel[dst_blockSize];
    for(int e = start_x; e < start_x+blockLength; e++) {
      int off_x = e-start_x;
      
      for(int j = start_y; j < start_y+blockLength; j++) {
        int index = e+j*src_img.width;
				color c = src_img.pixels[index];
        int r = red(c);//(img.pixels[index]>>16)&0xff;
        int g = green(c);//(img.pixels[index]>>8)&0xff;
        int b = blue(c);//img.pixels[index]&0xff;
       
        pxs[off_x+(j-start_y)*blockLength] = new Pixel(r, g, b);
      }
    }
    
    start_x += blockLength;
    if (start_x%src_img.width == 0) {
      start_x = 0;
      start_y += blockLength;
    }
    
    dst_blocks[i] = new ImageBlock(pxs);
  }
  
  return dst_blocks;
}

void updateBlocks(ImageBlock[] src_blocks, int blockLength) {
  int start_x = 0, start_y = 0;
  imge = createImage(img.width, img.height, RGB);
  imge.loadPixels();
  for (int i = 0; i < src_blocks.length(); i++) {
    for(int e = 0; e < blockLength; e++) {
      int off_x = e+start_x;
      
      for(int j = 0; j < blockLength; j++) {
        int index = e+j*blockLength;

        src_blocks[i].pxs[index].toRgb();
        imge.pixels[off_x+(j+start_y)*imge.width] = color(src_blocks[i].pxs[index].pr, src_blocks[i].pxs[index].pg, src_blocks[i].pxs[index].pb, 255); 
      }
    }
    
    start_x += blockLength;
    if (start_x%imge.width == 0) {
      start_x = 0;
      start_y += blockLength;
    }
  }

  imge.updatePixels();
}

ImageBlock[] discreteCosineTransform(ImageBlock[] src_blocks, int blockLength) {
  int start_x = 0, start_y = 0;
  for (int i = 0; i < src_blocks.length(); i++) {
    double o = 0, p = 0;
    int N = blockLength;
    double sqrt_rec_N = 1/sqrt(2); // 1/sqrt(n)
    double sqrt_rec2_N = 2/sqrt(N);
    double tmpy, tmpcb, tmpcr;
    
    for(int k=0;k<blockLength;k++) {
      o=0;

        if (k == 0) {
          o = sqrt_rec_N;
        } else {
          o = 1;
        }
        
      for(int l=0;l<blockLength;l++) {
        p=0;
        tmpy=tmpcb=tmpcr=0;

        if (l == 0) {
          p = sqrt_rec_N;
        } else {
          p = 1;
        }
        
        double mul = 0.25*(o*p);
            
        for (int m=0;m<blockLength;m++) {
          double xx_dct = cos(((2.0*m+1)*PI*k) /(2*N));
          
          for(int n=0;n<blockLength;n++) { 
            double dct = xx_dct * (cos(((2.0*n+1)*PI*l)/(2*N)));
            int index = m+n*blockLength;
            
            tmpy+= src_blocks[i].pxs[index].y*dct*mul; 
            tmpcb+= src_blocks[i].pxs[index].cb*dct*mul; 
            tmpcr+= src_blocks[i].pxs[index].cr*dct*mul; 
          }
        }
        
        int index = k+l*blockLength;
        
        src_blocks[i].pxs[index].cy = tmpy;
        src_blocks[i].pxs[index].ccb = tmpcb;
        src_blocks[i].pxs[index].ccr = tmpcr;
      }
    }
    
    start_x += blockLength;
    if (start_x%img.width == 0) {
      start_x = 0;
      start_y += blockLength;
    }
  }
  
  return src_blocks;
}

ImageBlock[] inverseDiscreteCosineTransform(ImageBlock[] src_blocks, int blockLength) {
  int start_x = 0, start_y = 0;
  for (int i = 0; i < src_blocks.length(); i++) {
    double o = 0, p = 0;
    int N = blockLength;
    double sqrt_rec_N = 1/sqrt(2);
    double sqrt_rec2_N = 2/sqrt(N);
    double tmpy, tmpcb, tmpcr;
    for(int k=0;k<blockLength;k++) {
      for(int l=0;l<blockLength;l++) {
        tmpy=tmpcb=tmpcr=0;
  
        for (int m=0;m<blockLength;m++) {
          for(int n=0;n<blockLength;n++) { 
            o=0;p=0;
            if (m == 0) {
              o = sqrt_rec_N;
            } else {
              o = 1;
            }
            
            if (n == 0) {
              p = sqrt_rec_N;
            } else {
              p = 1;
            }
            
            double mul = 0.25*(o*p);
        
            double dct = (cos( ((2.0*k+1)*PI*m) /(2*N))) * (cos(((2.0*l+1)*PI*n)/(2*N)));
            int index = m+n*blockLength;
            
            tmpy+= mul*src_blocks[i].pxs[index].cy*dct;  
            tmpcb+= mul*src_blocks[i].pxs[index].ccb*dct; 
            tmpcr+= mul*src_blocks[i].pxs[index].ccr*dct; 
          }
        }
        
        int index = k+l*blockLength;
        src_blocks[i].pxs[index].y = (int)tmpy;
        src_blocks[i].pxs[index].cb = (int)tmpcb;
        src_blocks[i].pxs[index].cr = (int)tmpcr;
      }
    }
    
    start_x += blockLength;
    if (start_x%img.width == 0) {
      start_x = 0;
      start_y += blockLength;
    }
  }
  
  return src_blocks;
}

ImageBlock[] quantizer(ImageBlock[] src_blocks, int blockLength, int[] QLuminance, int[] QChrominance) {
  int start_x = 0, start_y = 0;
  for (int i = 0; i < src_blocks.length(); i++) {
    double tmpy, tmpcb, tmpcr;
    
    for(int e=0;e<blockLength;e++) {
      for(int j=0;j<blockLength;j++) {
        int index = e+j*blockLength;
        
        src_blocks[i].pxs[index].cy = round((float)(src_blocks[i].pxs[index].cy/QChrominance[index]))*QChrominance[index];
        src_blocks[i].pxs[index].ccb = round((float)(src_blocks[i].pxs[index].ccb/QLuminance[index]))*QLuminance[index];
        src_blocks[i].pxs[index].ccr = round((float)(src_blocks[i].pxs[index].ccr/QLuminance[index]))*QLuminance[index];
      }
    }
    
    start_x += blockLength;
    if (start_x%img.width == 0) {
      start_x = 0;
      start_y += blockLength;
    }
  }
  
  return src_blocks;
}

int pmx = 8;
int pmy = 8;

void draw() {  
	background(0);
	
	image(imge, 0, 0);

	image(img, img.width, 0);
	
	if (pmx != mouseX || pmy != mouseY) {
		background(0);
		
		pmx = mouseX;
		pmy = mouseY;
		
		jpeg_quality_degradation_luminance = mouseX / width * 10;
		jpeg_quality_degradation_chrominance = mouseY / height * 10;
		
		if (jpeg_quality_degradation_luminance == 0 && jpeg_quality_degradation_chrominance == 0) {
			jpeg_quality_degradation_luminance = 1;
			jpeg_quality_degradation_chrominance = 1;
		}
		
		fill(255, 255, 255, 255);
		textSize(24);
		text(""JPEG processing..."", 8, 32);

		computeImage();

		updateBlocks(finalImage, blockSize);
	}
	
	textSize(16);
	text(""luminance degradation : "" + jpeg_quality_degradation_luminance, 8, 278);
	textSize(16);
	text(""chrominance degradation : "" + jpeg_quality_degradation_chrominance, 8, 278 + 16);
}"
"580526","JPEG algorithm","mySketch","/**
  * Old processing code ported to Processing.js; JPEG encoder / decoder done for an online course.
  */

PImage img;
PImage imge;

// tables from http://www.impulseadventure.com/photo/jpeg-quantization.html
int[] defaultQLuminance = {16, 11, 10, 16, 24,  40,  51,  61,
                           12, 12, 14, 19, 26,  58,  60,  55,
                           14, 13, 16, 24, 40,  57,  69,  56,
                           14, 17, 22, 29, 51,  87,  80,  62,
                           18, 22, 37, 56, 68,  109, 103, 77,
                           24, 35, 55, 64, 81,  104, 113, 92,
                           49, 64, 78, 87, 103, 121, 120, 101,
                           72, 92, 95, 98, 112, 100, 103, 99,
                         
                           16, 11, 10, 16, 24,  40,  51,  61, // 8x8 matrix for 16x16
                           12, 12, 14, 19, 26,  58,  60,  55,
                           14, 13, 16, 24, 40,  57,  69,  56,
                           14, 17, 22, 29, 51,  87,  80,  62,
                           18, 22, 37, 56, 68,  109, 103, 77,
                           24, 35, 55, 64, 81,  104, 113, 92,
                           49, 64, 78, 87, 103, 121, 120, 101,
                           72, 92, 95, 98, 112, 100, 103, 99};
                           
int[] defaultQChrominance = {17, 18, 24, 47, 99, 99, 99, 99,
                             18, 21, 26, 66, 99, 99, 99, 99,
                             24, 26, 56, 99, 99, 99, 99, 99,
                             47, 66, 99, 99, 99, 99, 99, 99,
                             99, 99, 99, 99, 99, 99, 99, 99,
                             99, 99, 99, 99, 99, 99, 99, 99,
                             99, 99, 99, 99, 99, 99, 99, 99,
                             99, 99, 99, 99, 99, 99, 99, 99,
                           
                             17, 18, 24, 47, 99, 99, 99, 99, // 8x8 matrix for 16x16
                             18, 21, 26, 66, 99, 99, 99, 99,
                             24, 26, 56, 99, 99, 99, 99, 99,
                             47, 66, 99, 99, 99, 99, 99, 99,
                             99, 99, 99, 99, 99, 99, 99, 99,
                             99, 99, 99, 99, 99, 99, 99, 99,
                             99, 99, 99, 99, 99, 99, 99, 99,
                             99, 99, 99, 99, 99, 99, 99, 99};

class Pixel {
  int y, cb, cr;
  int pr, pg , pb;
  double cy, ccb, ccr; // dct coefficients for ycbcr
  
  Pixel(int r, int g, int b) {
    pr = r;
    pg = g;
    pb = b;
    
    y  = (int)( 0.299   * r + 0.587   * g + 0.114   * b);
    cb = (int)(-0.16874 * r - 0.33126 * g + 0.50000 * b);
    cr = (int)( 0.50000 * r - 0.41869 * g - 0.08131 * b);
  }
  
  void toRgb() {
    pr = (int)(y + 1.402 * cr); 
    pg = (int)(y - 0.344 * cb - 0.714 * cr); 
    pb = (int)(y + 1.772 * cb); 
    
    /*r = constrain(abs((int)(cy + 1.402 * ccr)), 0, 255); 
    g = constrain(abs((int)(cy - 0.344 * ccb - 0.714 * ccr)), 0, 255); 
    b = constrain(abs((int)(cy + 1.772 * ccb)), 0, 255); */
  }
}
  
class ImageBlock {
  Pixel[] pxs;
  
  ImageBlock(Pixel[] px) {
    pxs = px;
  }
}

// not used, this is a min priority queue initially done for the entropy coding stage with huffman algorithm
class MinPQ
{
  private int maxSize;
  private long[] queue;
  private int nItems;
  
  MinPQ(int s)
  {
    maxSize = s;
    queue = new long[maxSize];
    nItems = 0;
  }
  
  void insert(long item)
  {
    int i;
    if (nItems == 0) {
      queue[nItems++] = item;
    } else {
      for (i = nItems - 1; i >= 0; i--) {
        if (item > queue[i]) {
          queue[i + 1] = queue[i];
        } else {
          break;
        }
      }
        
      queue[i + 1] = item;
      nItems++;
    }
  }
  
  long remove()
  {
    return queue[--nItems];
  }
  
  long peekMin()
  {
    return queue[nItems - 1];
  }
  
  boolean isEmpty()
  {
    return (nItems == 0);
  }
  
  boolean isFull()
  {
    return (nItems == maxSize);
  }
}

ImageBlock[] blocks;
ImageBlock[] transformedBlocks;
ImageBlock[] quantizedBlocks;
ImageBlock[] finalImage;
int blockSize = 8; // buggy

int[] QLum;
int[] QChrom;

double jpeg_quality_degradation_luminance = 1.0;
double jpeg_quality_degradation_chrominance = 1.0;

void computeImage() {
  blocks = buildBlocks(img, blockSize);
  transformedBlocks = discreteCosineTransform(blocks, blockSize);

  for (int i = 0; i < defaultQLuminance.length; i++) {
		QLum[i] = defaultQLuminance[i];
		QChrom[i] = defaultQChrominance[i];
		
    QLum[i] *= jpeg_quality_degradation_luminance;
    QChrom[i] *= jpeg_quality_degradation_chrominance;
  }
  
  quantizedBlocks = quantizer(transformedBlocks, blockSize, QLum, QChrom);
  finalImage = inverseDiscreteCosineTransform(quantizedBlocks, blockSize);
}

void setup() {
  size(512, 300);
  noFill();
  stroke(255);
  frameRate(12);
	background(0);
	
	img = loadImage(""sea.jpg"");
	
	QLum = new int[defaultQLuminance.length()];
	QChrom = new int[defaultQChrominance.length()];

	computeImage();

	updateBlocks(finalImage, blockSize);
/*
  MinPQ hufftree = new MinPQ(10);
*/
}

ImageBlock[] buildBlocks(PImage src_img, int blockLength) {
  ImageBlock[] dst_blocks = new ImageBlock[ceil((src_img.width/blockLength) * (src_img.height/blockLength))];
  int dst_blockSize = blockLength*blockLength;
  
  //Pixel[] pixels = new Pixel[dst_blockSize];
  
  int start_x = 0;
  int start_y = 0;
  
  src_img.loadPixels();
  for (int i = 0; i < dst_blocks.length(); i++) {
    Pixel[] pxs = new Pixel[dst_blockSize];
    for(int e = start_x; e < start_x+blockLength; e++) {
      int off_x = e-start_x;
      
      for(int j = start_y; j < start_y+blockLength; j++) {
        int index = e+j*src_img.width;
				color c = src_img.pixels[index];
        int r = red(c);//(img.pixels[index]>>16)&0xff;
        int g = green(c);//(img.pixels[index]>>8)&0xff;
        int b = blue(c);//img.pixels[index]&0xff;
       
        pxs[off_x+(j-start_y)*blockLength] = new Pixel(r, g, b);
      }
    }
    
    start_x += blockLength;
    if (start_x%src_img.width == 0) {
      start_x = 0;
      start_y += blockLength;
    }
    
    dst_blocks[i] = new ImageBlock(pxs);
  }
  
  return dst_blocks;
}

void updateBlocks(ImageBlock[] src_blocks, int blockLength) {
  int start_x = 0, start_y = 0;
  imge = createImage(img.width, img.height, RGB);
  imge.loadPixels();
  for (int i = 0; i < src_blocks.length(); i++) {
    for(int e = 0; e < blockLength; e++) {
      int off_x = e+start_x;
      
      for(int j = 0; j < blockLength; j++) {
        int index = e+j*blockLength;

        src_blocks[i].pxs[index].toRgb();
        imge.pixels[off_x+(j+start_y)*imge.width] = color(src_blocks[i].pxs[index].pr, src_blocks[i].pxs[index].pg, src_blocks[i].pxs[index].pb, 255); 
      }
    }
    
    start_x += blockLength;
    if (start_x%imge.width == 0) {
      start_x = 0;
      start_y += blockLength;
    }
  }

  imge.updatePixels();
}

ImageBlock[] discreteCosineTransform(ImageBlock[] src_blocks, int blockLength) {
  int start_x = 0, start_y = 0;
  for (int i = 0; i < src_blocks.length(); i++) {
    double o = 0, p = 0;
    int N = blockLength;
    double sqrt_rec_N = 1/sqrt(2); // 1/sqrt(n)
    double sqrt_rec2_N = 2/sqrt(N);
    double tmpy, tmpcb, tmpcr;
    
    for(int k=0;k<blockLength;k++) {
      o=0;

        if (k == 0) {
          o = sqrt_rec_N;
        } else {
          o = 1;
        }
        
      for(int l=0;l<blockLength;l++) {
        p=0;
        tmpy=tmpcb=tmpcr=0;

        if (l == 0) {
          p = sqrt_rec_N;
        } else {
          p = 1;
        }
        
        double mul = 0.25*(o*p);
            
        for (int m=0;m<blockLength;m++) {
          double xx_dct = cos(((2.0*m+1)*PI*k) /(2*N));
          
          for(int n=0;n<blockLength;n++) { 
            double dct = xx_dct * (cos(((2.0*n+1)*PI*l)/(2*N)));
            int index = m+n*blockLength;
            
            tmpy+= src_blocks[i].pxs[index].y*dct*mul; 
            tmpcb+= src_blocks[i].pxs[index].cb*dct*mul; 
            tmpcr+= src_blocks[i].pxs[index].cr*dct*mul; 
          }
        }
        
        int index = k+l*blockLength;
        
        src_blocks[i].pxs[index].cy = tmpy;
        src_blocks[i].pxs[index].ccb = tmpcb;
        src_blocks[i].pxs[index].ccr = tmpcr;
      }
    }
    
    start_x += blockLength;
    if (start_x%img.width == 0) {
      start_x = 0;
      start_y += blockLength;
    }
  }
  
  return src_blocks;
}

ImageBlock[] inverseDiscreteCosineTransform(ImageBlock[] src_blocks, int blockLength) {
  int start_x = 0, start_y = 0;
  for (int i = 0; i < src_blocks.length(); i++) {
    double o = 0, p = 0;
    int N = blockLength;
    double sqrt_rec_N = 1/sqrt(2);
    double sqrt_rec2_N = 2/sqrt(N);
    double tmpy, tmpcb, tmpcr;
    for(int k=0;k<blockLength;k++) {
      for(int l=0;l<blockLength;l++) {
        tmpy=tmpcb=tmpcr=0;
  
        for (int m=0;m<blockLength;m++) {
          for(int n=0;n<blockLength;n++) { 
            o=0;p=0;
            if (m == 0) {
              o = sqrt_rec_N;
            } else {
              o = 1;
            }
            
            if (n == 0) {
              p = sqrt_rec_N;
            } else {
              p = 1;
            }
            
            double mul = 0.25*(o*p);
        
            double dct = (cos( ((2.0*k+1)*PI*m) /(2*N))) * (cos(((2.0*l+1)*PI*n)/(2*N)));
            int index = m+n*blockLength;
            
            tmpy+= mul*src_blocks[i].pxs[index].cy*dct;  
            tmpcb+= mul*src_blocks[i].pxs[index].ccb*dct; 
            tmpcr+= mul*src_blocks[i].pxs[index].ccr*dct; 
          }
        }
        
        int index = k+l*blockLength;
        src_blocks[i].pxs[index].y = (int)tmpy;
        src_blocks[i].pxs[index].cb = (int)tmpcb;
        src_blocks[i].pxs[index].cr = (int)tmpcr;
      }
    }
    
    start_x += blockLength;
    if (start_x%img.width == 0) {
      start_x = 0;
      start_y += blockLength;
    }
  }
  
  return src_blocks;
}

ImageBlock[] quantizer(ImageBlock[] src_blocks, int blockLength, int[] QLuminance, int[] QChrominance) {
  int start_x = 0, start_y = 0;
  for (int i = 0; i < src_blocks.length(); i++) {
    double tmpy, tmpcb, tmpcr;
    
    for(int e=0;e<blockLength;e++) {
      for(int j=0;j<blockLength;j++) {
        int index = e+j*blockLength;
        
        src_blocks[i].pxs[index].cy = round((float)(src_blocks[i].pxs[index].cy/QChrominance[index]))*QChrominance[index];
        src_blocks[i].pxs[index].ccb = round((float)(src_blocks[i].pxs[index].ccb/QLuminance[index]))*QLuminance[index];
        src_blocks[i].pxs[index].ccr = round((float)(src_blocks[i].pxs[index].ccr/QLuminance[index]))*QLuminance[index];
      }
    }
    
    start_x += blockLength;
    if (start_x%img.width == 0) {
      start_x = 0;
      start_y += blockLength;
    }
  }
  
  return src_blocks;
}

int pmx = 8;
int pmy = 8;

void draw() {  
	background(0);
	
	image(imge, 0, 0);

	image(img, img.width, 0);
	
	if (pmx != mouseX || pmy != mouseY) {
		background(0);
		
		pmx = mouseX;
		pmy = mouseY;
		
		jpeg_quality_degradation_luminance = mouseX / width * 10;
		jpeg_quality_degradation_chrominance = mouseY / height * 10;
		
		if (jpeg_quality_degradation_luminance == 0 && jpeg_quality_degradation_chrominance == 0) {
			jpeg_quality_degradation_luminance = 1;
			jpeg_quality_degradation_chrominance = 1;
		}
		
		fill(255, 255, 255, 255);
		textSize(24);
		text(""JPEG processing..."", 8, 32);

		computeImage();

		updateBlocks(finalImage, blockSize);
	}
	
	textSize(16);
	text(""luminance degradation : "" + jpeg_quality_degradation_luminance, 8, 278);
	textSize(16);
	text(""chrominance degradation : "" + jpeg_quality_degradation_chrominance, 8, 278 + 16);
}"
"579955","Patterns 3","mySketch","float xmotion = 8.8;
float ymotion = 2.2;

float rxmotion = 0;
float rymotion = 0;
float rzmotion = 0;

void draw_func() {
	noStroke();
	
  fill(0, 0, 0, 2);
  rect(0, 0, width, height);

	int centered_rect_size = 92;
	
	// circles
	int count = 32;
	
	for (int k = 0; k < 64; k += 1) {
		float norm_k = k / 64;
		for (int i = 0; i < count; i += 1) {
			float norm_i = i / count;

			float norm_i_abs = (0.5 - abs(0.5 - norm_i)) * 2;

			float sign_change_k = (k%2 * 2 - 1);
			float sign_change_i = (i%2 * 2 - 1);
			
			float wa = radians(norm_k * 360 * sign_change_k) + xmotion / 2;
			float ha = radians(norm_k * 360 * sign_change_k) + ymotion / 2;
			float wo = cos(wa) * 3;
			float ho = sin(ha) * 3;

			float pll = ((wa%(PI * 2)) + (ha%(PI * 2))) / 2;
			float pl = abs(0.5 - pll / (PI * 2));
			
			if (pll > PI * 1.5) {
				fill(pl * 255, pl * 255, pl * 255, 255);	
				stroke(pl * 255, pl * 255, pl * 255, pl * 255.);
			} else {
				noFill();
				stroke(255, 255, 255, pl * 64);
				
				sign_change_i *= sign_change_k * (norm_k / 4);
			}
			
			rect(width / 2 + sin(radians(norm_i * 360) + xmotion * sign_change_k * sign_change_i) * (wo * 64),
					 height / 2 + cos(radians(norm_i * 360) + xmotion * sign_change_k * sign_change_i) * (wo * 64),
					 1 + norm_k, 1 + norm_k);
			
			stroke(255, 255, 255, pl * 24);
			
			line(width / 2 + sin(radians(norm_i * 360) + xmotion * sign_change_k * sign_change_i) * (192 + abs(wo) * 32),
					 height / 2 + cos(radians(norm_i * 360) + xmotion * sign_change_k * sign_change_i) * (192 + abs(ho) * 32),
					 width / 2 + sin(radians(norm_i * 360) + xmotion * sign_change_k * sign_change_i) * (256 + abs(wo) * 32),
					 height / 2 + cos(radians(norm_i * 360) + xmotion * sign_change_k * sign_change_i) * (256 + abs(ho) * 32));
		}
	}
	
	noStroke();
	
	fill(0, 0, 0, 8);
	ellipse(width / 2, height / 2, centered_rect_size, centered_rect_size);
	
	float noise_size = abs(sin(xmotion * 4)) * 16;
	
	loadPixels();
	for (int x = 0; x < width; x += 8) {
		for (int y = 0; y < height; y += 8) {
			color p = pixels[y * width + x];
			
			float b = brightness(p);
			
			if (b <= 64) {
				float norm_x = x / height;
				float norm_x_abs = (0.5 - abs(0.5 - norm_x)) * 2;
				
				float norm_y = y / height;
				float norm_y_abs = (0.5 - abs(0.5 - norm_y)) * 2;
				
				fill(255 * norm_y_abs, 255 * norm_y_abs, 255 * norm_y_abs, 16);
				rect(x + random(-8, 8), y + random(-8, 8), 2, 2);	
				
				fill(0, 0, 0, 24);
				rect(x + random(-16, 16), y + random(-16, 16), noise_size * norm_x_abs * norm_y_abs, noise_size * norm_x_abs * norm_y_abs);	
			}
		}
	}
	
	xmotion += 0.005;
	ymotion += 0.008;
	
	rxmotion += 0.05;
	rymotion += 0;
	rzmotion += 0;
}

void setup() {
  size(400, 400);

  frameRate(60); 

  background(0);
	
	smooth();
}

void draw() {
  //background(0);

  draw_func();
}"
"579597","Beacon 2","mySketch","/**
  * Andres circles
	*/

float xmotion = 8.8;
float ymotion = 2.2;

void andres_circle(int x_centre, int y_centre, int r) {
	int x = 0;
	int y = r;
	int d = r - 1;
	
	while (y >= x) {
		rect(x_centre + x, y_centre + y, 1, 1);
		rect(x_centre + y, y_centre + x, 1, 1);
		rect(x_centre - x, y_centre + y, 1, 1);
		rect(x_centre - y, y_centre + x, 1, 1);
		rect(x_centre + x, y_centre - y, 1, 1);
		rect(x_centre + y, y_centre - x, 1, 1);
		rect(x_centre - x, y_centre - y, 1, 1);
		rect(x_centre - y, y_centre - x, 1, 1);

		if (d >= 2 * x) { 
			d = d - 2 * x - 1;
			x = x + 1;
		} else if (d < 2 * (r - y)) {
			d = d + 2 * y - 1;
			y = y - 1;
		} else { 
			d = d + 2 * (y - x - 1);
			y = y - 0.5;
			x = x + 1.5;
		}
	}
}

float rxmotion = 0;
float rymotion = 0;
float rzmotion = 0;

void draw_func() {
	noStroke();
	
  fill(0, 0, 0, 2);
  rect(0, 0, width, height);

	//stroke(255, 255, 255, 255);

	int centered_rect_size = 128;
	
	// circles
	int count = 16;
	
	for (int k = 0; k < 4; k += 1) {
		float norm_k = (0.5 - abs(0.5 - (k / 4))) * 2;
		for (int i = 0; i < count; i += 1) {
			float norm_i = i / count;

			float norm_i_abs = (0.5 - abs(0.5 - norm_i)) * 2;

			//float osc_x = sin((norm_i_abs * 360) * (3.1415 / 180) + xmotion) * 32;
			float osc_y = cos((norm_i_abs * 360) * (3.1415 / 180) + ymotion / 2) * (64 * k);

			float osc_w = abs(cos((norm_i_abs * 360) * (3.1415 / 180) + ymotion * 2));

			if ((i%2) == 0) {
				fill(norm_i * 255, norm_i * 255, 255, norm_i * osc_w * 28.);
				stroke(norm_i * 255, norm_i * 255, 255, norm_i * osc_w * 64.);
			} else {
				noFill();
				stroke(norm_i * 255, 0, 255, norm_i_abs * osc_w * 16);
			}
			
			float cx = sin(radians(norm_k * 360) + xmotion) * 2;
			float cy = cos(radians(norm_k * 360) + xmotion) * 2;

			if (k == 0) {
				cx = 0;
				cy = 0;
			}
			
			andres_circle(width / 2 + cx, height / 2 + cy, 1 + i + osc_y);

			stroke(norm_i_abs * 255, norm_i_abs * 255, norm_i_abs * 255, 192);
			line(width / 2 + cx, height / 2 + cy, width / 2 + sin(radians(norm_i * 360) + xmotion * 2) * 20 * k + cx, height / 2 + cos(radians(norm_i * 360) + xmotion * 2) * 20 * k + cy);
		}
	}
	
	noStroke();

	fill(0, 0, 0, 24);
	ellipse(width / 2, height / 2, centered_rect_size, centered_rect_size);
	
	float noise_size = abs(sin(xmotion * 4)) * 8;
	
	loadPixels();
	for (int x = 0; x < width; x += 8) {
		for (int y = 0; y < height; y += 8) {
			color p = pixels[y * width + x];
			
			float b = brightness(p);
			
			if (b <= 0 || b >= 128) {
				float norm_x = x / height;
				float norm_x_abs = (0.5 - abs(0.5 - norm_x)) * 2;
				
				float norm_y = y / height;
				float norm_y_abs = (0.5 - abs(0.5 - norm_y)) * 2;
				
				fill(255, 255, 255, 24);
				rect(x + random(-8, 8), y + random(-8, 8), 1, 1);	
				fill(0, 0, 0, 32);
				rect(x + random(-16, 16), y + random(-16, 16), noise_size * norm_x_abs * norm_y_abs, noise_size * norm_x_abs * norm_y_abs);	
			}
		}
	}
	
	xmotion += 0.005;
	ymotion += 0.008;
	
	rxmotion += 0.05;
	rymotion += 0;
	rzmotion += 0;
}

void setup() {
  size(400, 400);

  frameRate(60); 

  background(0);
	
	smooth();
}

void draw() {
  //background(0);

  draw_func();
}"
"579597","Beacon 2","mySketch","/**
  * Andres circles
	*/

float xmotion = 8.8;
float ymotion = 2.2;

void andres_circle(int x_centre, int y_centre, int r) {
	int x = 0;
	int y = r;
	int d = r - 1;
	
	while (y >= x) {
		rect(x_centre + x, y_centre + y, 1, 1);
		rect(x_centre + y, y_centre + x, 1, 1);
		rect(x_centre - x, y_centre + y, 1, 1);
		rect(x_centre - y, y_centre + x, 1, 1);
		rect(x_centre + x, y_centre - y, 1, 1);
		rect(x_centre + y, y_centre - x, 1, 1);
		rect(x_centre - x, y_centre - y, 1, 1);
		rect(x_centre - y, y_centre - x, 1, 1);

		if (d >= 2 * x) { 
			d = d - 2 * x - 1;
			x = x + 1;
		} else if (d < 2 * (r - y)) {
			d = d + 2 * y - 1;
			y = y - 1;
		} else { 
			d = d + 2 * (y - x - 1);
			y = y - 0.5;
			x = x + 1.5;
		}
	}
}

float rxmotion = 0;
float rymotion = 0;
float rzmotion = 0;

void draw_func() {
	noStroke();
	
  fill(0, 0, 0, 2);
  rect(0, 0, width, height);

	//stroke(255, 255, 255, 255);

	int centered_rect_size = 128;
	
	// circles
	int count = 16;
	
	for (int k = 0; k < 4; k += 1) {
		float norm_k = (0.5 - abs(0.5 - (k / 4))) * 2;
		for (int i = 0; i < count; i += 1) {
			float norm_i = i / count;

			float norm_i_abs = (0.5 - abs(0.5 - norm_i)) * 2;

			//float osc_x = sin((norm_i_abs * 360) * (3.1415 / 180) + xmotion) * 32;
			float osc_y = cos((norm_i_abs * 360) * (3.1415 / 180) + ymotion / 2) * (64 * k);

			float osc_w = abs(cos((norm_i_abs * 360) * (3.1415 / 180) + ymotion * 2));

			if ((i%2) == 0) {
				fill(norm_i * 255, norm_i * 255, 255, norm_i * osc_w * 28.);
				stroke(norm_i * 255, norm_i * 255, 255, norm_i * osc_w * 64.);
			} else {
				noFill();
				stroke(norm_i * 255, 0, 255, norm_i_abs * osc_w * 16);
			}
			
			float cx = sin(radians(norm_k * 360) + xmotion) * 2;
			float cy = cos(radians(norm_k * 360) + xmotion) * 2;

			if (k == 0) {
				cx = 0;
				cy = 0;
			}
			
			andres_circle(width / 2 + cx, height / 2 + cy, 1 + i + osc_y);

			stroke(norm_i_abs * 255, norm_i_abs * 255, norm_i_abs * 255, 192);
			line(width / 2 + cx, height / 2 + cy, width / 2 + sin(radians(norm_i * 360) + xmotion * 2) * 20 * k + cx, height / 2 + cos(radians(norm_i * 360) + xmotion * 2) * 20 * k + cy);
		}
	}
	
	noStroke();

	fill(0, 0, 0, 24);
	ellipse(width / 2, height / 2, centered_rect_size, centered_rect_size);
	
	float noise_size = abs(sin(xmotion * 4)) * 8;
	
	loadPixels();
	for (int x = 0; x < width; x += 8) {
		for (int y = 0; y < height; y += 8) {
			color p = pixels[y * width + x];
			
			float b = brightness(p);
			
			if (b <= 0 || b >= 128) {
				float norm_x = x / height;
				float norm_x_abs = (0.5 - abs(0.5 - norm_x)) * 2;
				
				float norm_y = y / height;
				float norm_y_abs = (0.5 - abs(0.5 - norm_y)) * 2;
				
				fill(255, 255, 255, 24);
				rect(x + random(-8, 8), y + random(-8, 8), 1, 1);	
				fill(0, 0, 0, 32);
				rect(x + random(-16, 16), y + random(-16, 16), noise_size * norm_x_abs * norm_y_abs, noise_size * norm_x_abs * norm_y_abs);	
			}
		}
	}
	
	xmotion += 0.005;
	ymotion += 0.008;
	
	rxmotion += 0.05;
	rymotion += 0;
	rzmotion += 0;
}

void setup() {
  size(400, 400);

  frameRate(60); 

  background(0);
	
	smooth();
}

void draw() {
  //background(0);

  draw_func();
}"
"579597","Beacon 2","mySketch","/**
  * Andres circles
	*/

float xmotion = 8.8;
float ymotion = 2.2;

void andres_circle(int x_centre, int y_centre, int r) {
	int x = 0;
	int y = r;
	int d = r - 1;
	
	while (y >= x) {
		rect(x_centre + x, y_centre + y, 1, 1);
		rect(x_centre + y, y_centre + x, 1, 1);
		rect(x_centre - x, y_centre + y, 1, 1);
		rect(x_centre - y, y_centre + x, 1, 1);
		rect(x_centre + x, y_centre - y, 1, 1);
		rect(x_centre + y, y_centre - x, 1, 1);
		rect(x_centre - x, y_centre - y, 1, 1);
		rect(x_centre - y, y_centre - x, 1, 1);

		if (d >= 2 * x) { 
			d = d - 2 * x - 1;
			x = x + 1;
		} else if (d < 2 * (r - y)) {
			d = d + 2 * y - 1;
			y = y - 1;
		} else { 
			d = d + 2 * (y - x - 1);
			y = y - 0.05;
			x = x + 1.5;
		}
	}
}

float rxmotion = 0;
float rymotion = 0;
float rzmotion = 0;

void draw_func() {
	noStroke();
	
  fill(0, 0, 0, 2);
  rect(0, 0, width, height);

	//stroke(255, 255, 255, 255);

	int centered_rect_size = 128;
	
	// circles
	int count = 16;
	
	for (int k = 0; k < 4; k += 1) {
		float norm_k = (0.5 - abs(0.5 - (k / 4))) * 2;
		for (int i = 0; i < count; i += 1) {
			float sign_change_k = (k%2 * 2 - 1);
			float sign_change_i = (i%2 * 2 - 1);
			
			float norm_i = i / count;

			float norm_i_abs = (0.5 - abs(0.5 - norm_i)) * 2;

			//float osc_x = sin((norm_i_abs * 360) * (3.1415 / 180) + xmotion) * 32;
			float osc_y = cos((norm_i_abs * 360 * sign_change_i) * (3.1415 / 180) + ymotion / 2) * (64 * k * sign_change_i * sign_change_k);

			float osc_w = abs(cos((norm_i_abs * 360) * (3.1415 / 180) + ymotion * 2));

			if ((i%2) == 0) {
				fill(norm_i * 255, norm_i * 255, 255, norm_i * osc_w * 28.);
				stroke(norm_i * 255, norm_i * 255, 255, norm_i * osc_w * 64.);
			} else {
				noFill();
				stroke(norm_i * 255, 0, 255, norm_i_abs * osc_w * 16);
			}
			
			float cx = sin(radians(norm_k * 360) + xmotion) * 2;
			float cy = cos(radians(norm_k * 360) + xmotion) * 2;

			if (k == 0) {
				cx = 0;
				cy = 0;
			}
			
			andres_circle(width / 2 + cx, height / 2 + cy, 1 + i + osc_y + sign_change_i * 12);

			stroke(norm_i_abs * 255, norm_i_abs * 255, norm_i_abs * 255, 192);
			rect(width / 2 + sin(radians(norm_i * 360) + xmotion * 4) * 20 * k + cx,
					 height / 2 + cos(radians(norm_i * 360) + xmotion * 4 * sign_change_i) * 20 * k + cy,
					 2, 2);
		}
	}
	
	noStroke();

	fill(0, 0, 0, 8);
	ellipse(width / 2, height / 2, centered_rect_size, centered_rect_size);
	
	float noise_size = abs(sin(xmotion * 4)) * 8;

	loadPixels();
	for (int x = 0; x < width; x += 8) {
		for (int y = 0; y < height; y += 8) {
			color p = pixels[y * width + x];
			
			float b = brightness(p);
			
			if (b <= 0 || b >= 128) {
				float norm_x = x / height;
				float norm_x_abs = (0.5 - abs(0.5 - norm_x)) * 2;
				
				float norm_y = y / height;
				float norm_y_abs = (0.5 - abs(0.5 - norm_y)) * 2;
				
				fill(255, 255, 255, 24);
				rect(x + random(-8, 8), y + random(-8, 8), 1, 1);	
				fill(0, 0, 0, 32);
				rect(x + random(-16, 16), y + random(-16, 16), noise_size * norm_x_abs * norm_y_abs, noise_size * norm_x_abs * norm_y_abs);	
			}
		}
	}
	
	xmotion += 0.005;
	ymotion += 0.008;
	
	rxmotion += 0.05;
	rymotion += 0;
	rzmotion += 0;
}

void setup() {
  size(400, 400);

  frameRate(60); 

  background(0);
	
	smooth();
}

void draw() {
  //background(0);

  draw_func();
}"
"579597","Beacon 2","mySketch","/**
  * Andres circles
	*/

float xmotion = 8.8;
float ymotion = 2.2;

void andres_circle(int x_centre, int y_centre, int r) {
	int x = 0;
	int y = r;
	int d = r - 1;
	
	while (y >= x) {
		rect(x_centre + x, y_centre + y, 1, 1);
		rect(x_centre + y, y_centre + x, 1, 1);
		rect(x_centre - x, y_centre + y, 1, 1);
		rect(x_centre - y, y_centre + x, 1, 1);
		rect(x_centre + x, y_centre - y, 1, 1);
		rect(x_centre + y, y_centre - x, 1, 1);
		rect(x_centre - x, y_centre - y, 1, 1);
		rect(x_centre - y, y_centre - x, 1, 1);

		if (d >= 2 * x) { 
			d = d - 2 * x - 1;
			x = x + 1;
		} else if (d < 2 * (r - y)) {
			d = d + 2 * y - 1;
			y = y - 1;
		} else { 
			d = d + 2 * (y - x - 1);
			y = y - 0.05;
			x = x + 1.5;
		}
	}
}

float rxmotion = 0;
float rymotion = 0;
float rzmotion = 0;

void draw_func() {
	noStroke();
	
  fill(0, 0, 0, 2);
  rect(0, 0, width, height);

	//stroke(255, 255, 255, 255);

	int centered_rect_size = 128;
	
	// circles
	int count = 16;
	
	for (int k = 0; k < 4; k += 1) {
		float norm_k = (0.5 - abs(0.5 - (k / 4))) * 2;
		for (int i = 0; i < count; i += 1) {
			float sign_change_k = (k%2 * 2 - 1);
			float sign_change_i = (i%2 * 2 - 1);
			
			float norm_i = i / count;

			float norm_i_abs = (0.5 - abs(0.5 - norm_i)) * 2;

			//float osc_x = sin((norm_i_abs * 360) * (3.1415 / 180) + xmotion) * 32;
			float osc_y = cos((norm_i_abs * 360 * sign_change_i) * (3.1415 / 180) + ymotion / 2) * (64 * k * sign_change_i * sign_change_k);

			float osc_w = abs(cos((norm_i_abs * 360) * (3.1415 / 180) + ymotion * 2));

			if ((i%2) == 0) {
				fill(norm_i * 255, norm_i * 255, 255, norm_i * osc_w * 28.);
				stroke(norm_i * 255, norm_i * 255, 255, norm_i * osc_w * 64.);
			} else {
				noFill();
				stroke(norm_i * 255, 0, 255, norm_i_abs * osc_w * 16);
			}
			
			float cx = sin(radians(norm_k * 360) + xmotion) * 2;
			float cy = cos(radians(norm_k * 360) + xmotion) * 2;

			if (k == 0) {
				cx = 0;
				cy = 0;
			}
			
			andres_circle(width / 2 + cx, height / 2 + cy, 1 + i + osc_y + sign_change_i * 12);

			stroke(norm_i_abs * 255, norm_i_abs * 255, norm_i_abs * 255, 192);
			rect(width / 2 + sin(radians(norm_i * 360) + xmotion * 4) * 20 * k + cx,
					 height / 2 + cos(radians(norm_i * 360) + xmotion * 4 * sign_change_i) * 20 * k + cy,
					 2, 2);
		}
	}
	
	noStroke();

	fill(0, 0, 0, 8);
	ellipse(width / 2, height / 2, centered_rect_size, centered_rect_size);
	
	float noise_size = abs(sin(xmotion * 4)) * 8;

	loadPixels();
	for (int x = 0; x < width; x += 8) {
		for (int y = 0; y < height; y += 8) {
			color p = pixels[y * width + x];
			
			float b = brightness(p);
			
			if (b <= 0 || b >= 128) {
				float norm_x = x / height;
				float norm_x_abs = (0.5 - abs(0.5 - norm_x)) * 2;
				
				float norm_y = y / height;
				float norm_y_abs = (0.5 - abs(0.5 - norm_y)) * 2;
				
				fill(255, 255, 255, 24);
				rect(x + random(-8, 8), y + random(-8, 8), 1, 1);	
				fill(0, 0, 0, 32);
				rect(x + random(-16, 16), y + random(-16, 16), noise_size * norm_x_abs * norm_y_abs, noise_size * norm_x_abs * norm_y_abs);	
			}
		}
	}
	
	xmotion += 0.005;
	ymotion += 0.008;
	
	rxmotion += 0.05;
	rymotion += 0;
	rzmotion += 0;
}

void setup() {
  size(400, 400);

  frameRate(60); 

  background(0);
	
	smooth();
}

void draw() {
  //background(0);

  draw_func();
}"
"579571","Andres circle","mySketch","/**
  * Technically the same as ""Beacon"" but let's have some fun with Andres circle algorithm by messing it up :)
	*/

float xmotion = 8.8;
float ymotion = 2.2;

void andres_circle(int x_centre, int y_centre, int r) {
	int x = 0;
	int y = r;
	int d = r - 1;
	
	while (y >= x) {
		float norm_r = abs(0.5 - y / r);
		
		float norm_r_abs = (0.5 - abs(0.5 - y / r)) * 2;
		
		float rot_x = tan(norm_r_abs * 360 * (3.1415 / 180) + xmotion + cos(radians(norm_r * 360))) * norm_r_abs * 8;
		float rot_y = tan(norm_r_abs * 360 * (3.1415 / 180) + ymotion + sin(radians(norm_r * 360))) * norm_r_abs * 8;
		
		rect(x_centre + x + rot_y, y_centre + y + rot_x, 1, 1);
		rect(x_centre + y + rot_x, y_centre + x + rot_y, 1, 1);
		rect(x_centre - x - rot_y, y_centre + y + rot_x, 1, 1);
		rect(x_centre - y - rot_x, y_centre + x + rot_y, 1, 1);
		rect(x_centre + x + rot_y, y_centre - y - rot_x, 1, 1);
		rect(x_centre + y + rot_x, y_centre - x - rot_y, 1, 1);
		rect(x_centre - x - rot_y, y_centre - y - rot_x, 1, 1);
		rect(x_centre - y - rot_x, y_centre - x - rot_y, 1, 1);

		if (d >= 2 * x) { 
			d = d - 2 * x - 1 - norm_r * d;
			x = x + 1;
		} else if (d < 2 * (r - y)) {
			d = d + 2 * y - 1 - norm_r * d;
			y = y - 1;
		} else { 
			d = d + 2 * (y - x - 1) - norm_r * d;
			y = y - 1;
			x = x + 1;
		}
	}
}

float rxmotion = 0;
float rymotion = 0;
float rzmotion = 0;

void draw_func() {
	noStroke();
	
  fill(0, 0, 0, 2);
  rect(0, 0, width, height);

	//stroke(255, 255, 255, 255);

	int centered_rect_size = 128;
	
	// circles
	int count = 32;
	
	for (int i = 0; i < count; i += 1) {
		float norm_i = i / count;
		
		float norm_i_abs = (0.5 - abs(0.5 - norm_i)) * 2;
		
		float osc_x = sin((norm_i_abs * 360) * (3.1415 / 180) + xmotion) * 32;
		float osc_y = cos((norm_i_abs * 360) * (3.1415 / 180) + ymotion / 2) * (centered_rect_size - count + 64);
		
		float osc_w = abs(cos((norm_i * 360) * (3.1415 / 180) + ymotion * 2));
		
		if ((i%2) == 0) {
			fill(norm_i_abs * 255, norm_i_abs * 255, 255, norm_i_abs * osc_w * 255.);
			stroke(255, 255, 255, norm_i_abs * osc_w * 4.);
		} else {
			noFill();
			stroke(norm_i_abs * 255, 0, 0, norm_i_abs * osc_w * 4);
		}
			
		andres_circle(width / 2, height / 2, 1 + i + osc_y);
	}
	
	noStroke();
	
	fill(0, 0, 0, 4);
	ellipse(width / 2, height / 2, centered_rect_size, centered_rect_size);
	
	float noise_size = abs(sin(xmotion / 4)) * 32;
	
	loadPixels();
	for (int x = 0; x < width; x += 16) {
		for (int y = 0; y < height; y += 16) {
			color p = pixels[y * width + x];
			
			float b = brightness(p);
			
			if (b > 32 && b < 255) {
				float norm_x = x / height;
				float norm_x_abs = (0.5 - abs(0.5 - norm_x)) * 2;
				
				float norm_y = y / height;
				float norm_y_abs = (0.5 - abs(0.5 - norm_y)) * 2;
				
				fill(255, 255, 255, 4);
				rect(x + random(-8, 8), y + random(-8, 8), 2, 2);	
				fill(0, 0, 0, 8);
				rect(x + random(-16, 16), y + random(-16, 16), noise_size * norm_x_abs * norm_y_abs, noise_size * norm_x_abs * norm_y_abs);	
			}
		}
	}
	
	for (int x = 0; x < 64; x += 1) {
		fill(0, 0, 0, 32);
		ellipse(random(0, width), random(0, height), 12, 12);
	}
	
	xmotion += 0.005;
	ymotion += 0.008;
	
	rxmotion += 0.05;
	rymotion += 0;
	rzmotion += 0;
}

void setup() {
  size(400, 400);

  frameRate(60); 

  background(0);
	
	smooth();
}

void draw() {
  //background(0);

  draw_func();
}"
"579557","Beacon","mySketch","/**
  * Andres circles
	*/

void andres_circle(int x_centre, int y_centre, int r) {
	int x = 0;
	int y = r;
	int d = r - 1;
	
	while (y >= x) {
		rect(x_centre + x, y_centre + y, 1, 1);
		rect(x_centre + y, y_centre + x, 1, 1);
		rect(x_centre - x, y_centre + y, 1, 1);
		rect(x_centre - y, y_centre + x, 1, 1);
		rect(x_centre + x, y_centre - y, 1, 1);
		rect(x_centre + y, y_centre - x, 1, 1);
		rect(x_centre - x, y_centre - y, 1, 1);
		rect(x_centre - y, y_centre - x, 1, 1);

		if (d >= 2 * x) { 
			d = d - 2 * x - 1;
			x = x + 1;
		} else if (d < 2 * (r - y)) {
			d = d + 2 * y - 1;
			y = y - 1;
		} else { 
			d = d + 2 * (y - x - 1);
			y = y - 1;
			x = x + 1;
		}
	}
}

float xmotion = 8.8;
float ymotion = 2.2;

float rxmotion = 0;
float rymotion = 0;
float rzmotion = 0;

void draw_func() {
	noStroke();
	
  fill(0, 0, 0, 2);
  rect(0, 0, width, height);

	//stroke(255, 255, 255, 255);

	int centered_rect_size = 128;
	
	// circles
	int count = 32;
	
	for (int i = 0; i < count; i += 1) {
		float norm_i = i / count;
		
		float norm_i_abs = (0.5 - abs(0.5 - norm_i)) * 2;
		
		float osc_x = sin((norm_i_abs * 360) * (3.1415 / 180) + xmotion) * 32;
		float osc_y = cos((norm_i_abs * 360) * (3.1415 / 180) + ymotion / 2) * (centered_rect_size - count + 64);
		
		float osc_w = abs(cos((norm_i_abs * 360) * (3.1415 / 180) + ymotion * 2));
		
		if ((i%2) == 0) {
			fill(norm_i_abs * 255, norm_i_abs * 255, 255, norm_i_abs * osc_w * 255.);
			stroke(255, 255, 255, norm_i_abs * osc_w * 8.);
		} else {
			noFill();
			stroke(0, 0, 0, norm_i_abs * osc_w * 16);
		}
			
		andres_circle(width / 2, height / 2, 1 + i + osc_y);
		
		stroke(norm_i_abs * 255, norm_i_abs * 255, norm_i_abs * 255, 128);
		line(width / 2, height / 2, width / 2 + sin(radians(norm_i * 360) + xmotion * 8) * 128, height / 2 + cos(radians(norm_i * 360) + xmotion * 8) * 128)
	}
	
	noStroke();
	
	fill(0, 0, 0, 2);
	ellipse(width / 2, height / 2, centered_rect_size, centered_rect_size);
	
	float noise_size = abs(sin(xmotion / 4)) * 16;
	
	loadPixels();
	for (int x = 0; x < width; x += 8) {
		for (int y = 0; y < height; y += 8) {
			color p = pixels[y * width + x];
			
			float b = brightness(p);
			
			if (b > 64 && b < 192) {
				float norm_x = x / height;
				float norm_x_abs = (0.5 - abs(0.5 - norm_x)) * 2;
				
				float norm_y = y / height;
				float norm_y_abs = (0.5 - abs(0.5 - norm_y)) * 2;
				
				fill(255, 255, 255, 24);
				rect(x + random(-8, 8), y + random(-8, 8), 2, 2);	
				fill(0, 0, 0, 32);
				rect(x + random(-16, 16), y + random(-16, 16), noise_size * norm_x_abs * norm_y_abs, noise_size * norm_x_abs * norm_y_abs);	
			}
		}
	}
	
	xmotion += 0.005;
	ymotion += 0.008;
	
	rxmotion += 0.05;
	rymotion += 0;
	rzmotion += 0;
}

void setup() {
  size(400, 400);

  frameRate(60); 

  background(0);
	
	smooth();
}

void draw() {
  //background(0);

  draw_func();
}"
"579183","Feedback texturing","mySketch","/**
  * ""Unstable become stable"" texturing through simple feedback mechanisms, this produce a displacement akin to dunes or water by carefully tuning feedback
	* This can also produce ""old stone erosion"" with others constant.
	*/

float xmotion = 8.8;
float ymotion = 2.2;

float rxmotion = 0;
float rymotion = 0;
float rzmotion = 0;

PImage sand;

void draw_func() {
  fill(0, 0, 0, 2);
  rect(0, 0, width, height);

	noStroke();
	
	loadPixels();
	for (int x = 0; x < width; x += 2) {
		int xxd = ((int)((x / width) * (sand.width * crepeat)) % sand.width);
		
		float noise_sizex = abs(sin(xmotion / 4)) * 48;
		float noise_sizey = abs(cos(ymotion / 4)) * 48;
		
		for (int y = 0; y < height; y += 2) {
			color p = pixels[y * width + x];
			
			if (brightness(p) < 32) {
				float crepeat = 1.;

				int yyd = (((int)((y / height) * (sand.height * crepeat)) % sand.height)) * sand.width;
				
				int cl = (int)xxd + yyd;

				int r = (int)(red(sand.pixels[cl]));
				int g = (int)(green(sand.pixels[cl]));
				int b = (int)(blue(sand.pixels[cl]));
				
				fill(r, g, b, noise_sizex);
				rect(x + random(8) - 12, y + random(8) - 12, 2, 2);	
				fill(0, 0, 0, 2);
				rect(x + random(8) - 12, y + random(8) - 12, noise_sizex, noise_sizey);	
			}
		}
	}
	
	xmotion += 0.005;
	ymotion += 0.008;
	
	rxmotion += 0.05;
	rymotion += 0;
	rzmotion += 0;
}

void setup() {
  size(400, 400);

  frameRate(30); 

  background(0);
	
	smooth();
	
	sand = loadImage(""sand.jpg"");
}

void draw() {
  //background(0);

  draw_func();
}"
"579183","Feedback texturing","mySketch","/**
  * ""Unstable become stable"" texturing through simple feedback mechanisms, this produce a displacement akin to dunes or water by carefully tuning feedback
	* This can also produce ""old stone erosion"" with others constant.
	*/

float xmotion = 8.8;
float ymotion = 2.2;

float rxmotion = 0;
float rymotion = 0;
float rzmotion = 0;

PImage sand;

void draw_func() {
  fill(0, 0, 0, 2);
  rect(0, 0, width, height);

	noStroke();
	
	loadPixels();
	for (int x = 0; x < width; x += 2) {
		int xxd = ((int)((x / width) * (sand.width * crepeat)) % sand.width);
		
		float noise_sizex = abs(sin(xmotion / 4)) * 48;
		float noise_sizey = abs(cos(ymotion / 4)) * 48;
		
		for (int y = 0; y < height; y += 2) {
			color p = pixels[y * width + x];
			
			if (brightness(p) < 32) {
				float crepeat = 1.;

				int yyd = (((int)((y / height) * (sand.height * crepeat)) % sand.height)) * sand.width;
				
				int cl = (int)xxd + yyd;

				int r = (int)(red(sand.pixels[cl]));
				int g = (int)(green(sand.pixels[cl]));
				int b = (int)(blue(sand.pixels[cl]));
				
				fill(r, g, b, noise_sizex);
				rect(x + random(8) - 12, y + random(8) - 12, 2, 2);	
				fill(0, 0, 0, 2);
				rect(x + random(8) - 12, y + random(8) - 12, noise_sizex, noise_sizey);	
			}
		}
	}
	
	xmotion += 0.005;
	ymotion += 0.008;
	
	rxmotion += 0.05;
	rymotion += 0;
	rzmotion += 0;
}

void setup() {
  size(400, 400);

  frameRate(30); 

  background(0);
	
	smooth();
	
	sand = loadImage(""sand.jpg"");
}

void draw() {
  //background(0);

  draw_func();
}"
"579183","Feedback texturing","mySketch","/**
  * ""Unstable become stable"" texturing through simple feedback mechanisms, this produce a displacement akin to dunes or water by carefully tuning feedback
	* This can also produce ""old stone erosion"" with others constant.
	*/

float xmotion = 8.8;
float ymotion = 2.2;

float rxmotion = 0;
float rymotion = 0;
float rzmotion = 0;

PImage sand;

void draw_func() {
  fill(0, 0, 0, 2);
  rect(0, 0, width, height);

	noStroke();
	
	loadPixels();
	for (int x = 0; x < width; x += 2) {
		int xxd = ((int)((x / width) * (sand.width * crepeat)) % sand.width);
		
		float noise_sizex = abs(sin(xmotion / 4)) * 48;
		float noise_sizey = abs(cos(ymotion / 4)) * 48;
		
		for (int y = 0; y < height; y += 2) {
			color p = pixels[y * width + x];
			
			if (brightness(p) < 32) {
				float crepeat = 1.;

				int yyd = (((int)((y / height) * (sand.height * crepeat)) % sand.height)) * sand.width;
				
				int cl = (int)xxd + yyd;

				int r = (int)(red(sand.pixels[cl]));
				int g = (int)(green(sand.pixels[cl]));
				int b = (int)(blue(sand.pixels[cl]));
				
				fill(r, g, b, noise_sizex);
				rect(x + random(8) - 12, y + random(8) - 12, 2, 2);	
				fill(0, 0, 0, 2);
				rect(x + random(8) - 12, y + random(8) - 12, noise_sizex, noise_sizey);	
			}
		}
	}
	
	xmotion += 0.005;
	ymotion += 0.008;
	
	rxmotion += 0.05;
	rymotion += 0;
	rzmotion += 0;
}

void setup() {
  size(400, 400);

  frameRate(30); 

  background(0);
	
	smooth();
	
	sand = loadImage(""sand.jpg"");
}

void draw() {
  //background(0);

  draw_func();
}"
"579183","Feedback texturing","mySketch","/**
  * ""Unstable become stable"" texturing through simple feedback mechanisms, this produce a displacement akin to dunes or water by carefully tuning feedback
	* This can also produce ""old stone erosion"" with others constant.
	*/

float xmotion = 8.8;
float ymotion = 2.2;

float rxmotion = 0;
float rymotion = 0;
float rzmotion = 0;

PImage sand;

void draw_func() {
  //fill(0, 0, 0, 2);
  //rect(0, 0, width, height);

	noStroke();
	
	loadPixels();
	for (int x = 0; x < width; x += 2) {
		float norm_x = x / width;
		
		float crepeat = 2.;
		
		int xxd = ((int)((x / width) * (sand.width * crepeat)) % sand.width);
		
		float noise_sizex = abs(sin(xmotion / 4)) * random(24, 48);
		
		for (int y = 0; y < height; y += 2) {
			color p = pixels[y * width + x];
			
			if (brightness(p) < 32 * norm_x) {
				float norm_y = y / height;
				
				float noise_sizey = abs(cos(ymotion / 4)) * random(24, 48);

				int yyd = (((int)((y / height) * (sand.height * crepeat)) % sand.height)) * sand.width;
				
				int cl = (int)xxd + yyd;

				int r = (int)(red(sand.pixels[cl]));
				int g = (int)(green(sand.pixels[cl]));
				int b = (int)(blue(sand.pixels[cl]));
				
				fill(r, g, b, 48);
				rect(x + random(8) - 12, y + random(8) - 12, 2, 2);
				rect(y + random(8) - 12, x + random(8) - 12, 2, 2);	
				fill(0, 0, 0, 1);
				rect(x + random(8) - 12, y + random(8) - 12, noise_sizex, noise_sizey);
				rect(y + random(8) - 12, x + random(8) - 12, noise_sizex, noise_sizey);
			}
		}
	}
	
	xmotion += 0.005;
	ymotion += 0.008;
	
	rxmotion += 0.05;
	rymotion += 0;
	rzmotion += 0;
}

void setup() {
  size(400, 400);

  background(0);
	
	smooth();
	
	sand = loadImage(""sand.jpg"");
}

void draw() {
  //background(0);

  draw_func();
}"
"579183","Feedback texturing","mySketch","/**
  * ""Unstable become stable"" texturing through simple feedback mechanisms, this produce a displacement akin to dunes or water by carefully tuning feedback
	* This can also produce ""old stone erosion"" with others constant.
	*/

float xmotion = 8.8;
float ymotion = 2.2;

float rxmotion = 0;
float rymotion = 0;
float rzmotion = 0;

PImage sand;

void draw_func() {
  //fill(0, 0, 0, 2);
  //rect(0, 0, width, height);

	noStroke();
	
	loadPixels();
	for (int x = 0; x < width; x += 2) {
		float norm_x = x / width;
		
		float crepeat = 2.;
		
		int xxd = ((int)((x / width) * (sand.width * crepeat)) % sand.width);
		
		float noise_sizex = abs(sin(xmotion / 4)) * random(24, 48);
		
		for (int y = 0; y < height; y += 2) {
			color p = pixels[y * width + x];
			
			if (brightness(p) < 32 * norm_x) {
				float norm_y = y / height;
				
				float noise_sizey = abs(cos(ymotion / 4)) * random(24, 48);

				int yyd = (((int)((y / height) * (sand.height * crepeat)) % sand.height)) * sand.width;
				
				int cl = (int)xxd + yyd;

				int r = (int)(red(sand.pixels[cl]));
				int g = (int)(green(sand.pixels[cl]));
				int b = (int)(blue(sand.pixels[cl]));
				
				fill(r, g, b, 48);
				rect(x + random(8) - 12, y + random(8) - 12, 2, 2);
				rect(y + random(8) - 12, x + random(8) - 12, 2, 2);	
				fill(0, 0, 0, 1);
				rect(x + random(8) - 12, y + random(8) - 12, noise_sizex, noise_sizey);
				rect(y + random(8) - 12, x + random(8) - 12, noise_sizex, noise_sizey);
			}
		}
	}
	
	xmotion += 0.005;
	ymotion += 0.008;
	
	rxmotion += 0.05;
	rymotion += 0;
	rzmotion += 0;
}

void setup() {
  size(400, 400);

  background(0);
	
	smooth();
	
	sand = loadImage(""sand.jpg"");
}

void draw() {
  //background(0);

  draw_func();
}"
"579183","Feedback texturing","mySketch","
float xmotion = 8.8;
float ymotion = 2.2;

float rxmotion = 0;
float rymotion = 0;
float rzmotion = 0;

int center_sphere_stroke_weight = 1;
int new_center_sphere_stroke_weight = random(24);
int frame_switch_stroke = 120;

int frame = 0;

void draw_func() {
	noStroke();
	
  fill(0, 0, 0, 2);
  rect(0, 0, width, height);

	//stroke(255, 255, 255, 255);
	
	int lcount = 4;
	
	int rect_size_x = 64;
	int rect_size_y = 48;
	
	int cx = width / rect_size_x;
	int cy = height / rect_size_y;
	
	/*
	// background
	for (int i = 0; i < cy; i += 1) {
		float norm_i = abs(0.5 - i / cy);
		for (int j = 0; j < cx; j += 1) {
			float norm_j = (0.5 - abs(0.5 - j / cx)) * 2;//abs(0.5 - j / cx);
			float norm_ij = abs(norm_i - norm_j + random(-1, 1));
			
			fill(0, 0, 0, random(16, 24));
			rect(j * rect_size_x, i * rect_size_y, random(1, rect_size_x), random(1, rect_size_y));
			
			for (int k = 0; k < lcount; k += 1) {
				float norm_k = (0.5 - abs(0.5 - k / lcount)) * 2;
				
				int ly = i * rect_size_y + (rect_size_y / lcount) * k;
				
				float osc_x, osc_y;
				
				if ((k % 2) == 0) {
					osc_x = sin(norm_k * 360 * (3.1415 / 180) + xmotion) * 32;
					osc_y = cos(norm_k * 360 * (3.1415 / 180) - ymotion) * 32;
					
					stroke(255, 0, 255 * norm_i, 255 * norm_i * norm_k);
				} else {
					osc_x = sin(norm_k * 360 * (3.1415 / 180) - xmotion) * 32;
					osc_y = cos(norm_k * 360 * (3.1415 / 180) + ymotion) * 32;
					
					stroke(255 * norm_i, 0, 255, 255 * norm_i * norm_k);
				}
				
				int hcount = 8;
				
				//line(0, ly + osc_y, width, ly - osc_y);
				line(0, ly + osc_y * 8, width, height / 2);
				line(width - 1, ly + osc_y * 8, 0, height / 2);
				//line(ly + osc_x, 0, ly - osc_x, 0);
				//line(ly + osc_x, 0, ly - osc_x, height);
				
				noStroke();
				
				for (int h = 0; h < hcount; h += 1) {
					int xh = h - hcount / 8;
					
					fill(0, 0, 0, 8);
					rect(osc_x + xh * 128, ly + osc_y, 64, 64);
				}
			}
			noStroke();
		}
	}
	
	int centered_rect_size = 256;
	
	// support	
	int tx = width / 2 - centered_rect_size / 2 + 16;
	int ty1 = height / 2 + 132;
	int ty2 = height / 2 + 32 + centered_rect_size / 2;
	
	// see between sphere & stroke sphere
	//
	
	// center sphere 
	center_sphere_stroke_weight = lerp(center_sphere_stroke_weight, new_center_sphere_stroke_weight, (frame%frame_switch_stroke) / frame_switch_stroke);
	int ssize = center_sphere_stroke_weight;
	
	noFill();
	strokeWeight(ssize);
	stroke(224, 224, 224, ssize / 200 * 225);
	ellipse(width / 2, height / 2, centered_rect_size * 1.05, centered_rect_size * 1.05);
	
	strokeWeight(1);
	fill(0, 0, 0, 255);
	stroke(92, 92, 92, 255);
	triangle(tx, ty1, width / 2, height * 1.5 - ty2, width - tx, ty1);
	
	fill(0, 0, 0, 255);
	stroke(0, 0, 0, 128);
	triangle(tx, ty1, width - tx, ty1, width / 2, ty2);
	
	fill(0, 0, 0, 240);
	noStroke();
	ellipse(width / 2, height / 2, centered_rect_size, centered_rect_size);
	
	noStroke();
	*/
	
	int centered_rect_size = 256;
	
	// circles
	int count = 24;
	
	float yy = 0;
	
	for (int i = 0; i < count; i += 1) {
		float norm_i = i / count;
		
		float norm_i_abs = (0.5 - abs(0.5 - norm_i)) * 2;
		
		float osc_x = sin((norm_i_abs * 360) * (3.1415 / 180) + xmotion / 2) * (centered_rect_size - count + 12);
		float osc_y = cos((norm_i_abs * 360) * (3.1415 / 180) + ymotion / 2) * (centered_rect_size - count + 12);
		
		float osc_w = abs(cos((norm_i_abs * 360) * (3.1415 / 180) + ymotion * 2));
		
		/*
		float abs_osc_x = abs(osc_x);
		float abs_osc_y = abs(osc_y);
		
		if (osc_x > 0 && osc_y > 0) {
			fill(norm_i_abs * 255, 255, 255, norm_i_abs * 255);
			stroke(norm_i_abs * 255, 255, 255, norm_i_abs * 255);
		} else if (osc_x > 0 && osc_y < 0) {
			fill(255, norm_i_abs * 255, 255, norm_i_abs * 255);
			stroke(255, norm_i_abs * 255, 255, norm_i_abs * 255);
		} else if (osc_x < 0 && osc_y > 0) {
			fill(255, 255, norm_i_abs * 255, norm_i_abs * 255);
			stroke(255, 255, norm_i_abs * 255, norm_i_abs * 255);
		} else if (osc_x < 0 && osc_y < 0) {
			fill(255, 255, 255, norm_i_abs * 255);
			stroke(255, 255, 255, norm_i_abs * 255);
		}
		*/

		if ((i%2) == 0) {
			fill(norm_i_abs * 255, norm_i_abs * 255, 255, norm_i_abs * osc_w * 8);
			stroke(255, 255, 255, norm_i_abs * osc_w * 232);
		} else {
			noFill();
			stroke(norm_i_abs * 255, 255, 255, norm_i_abs * osc_w * 128);
		}
			
		//andres_circle(width / 2 + osc_x * 8, height / 2 + osc_y * 8, 1 + i + osc_x);
		//noFill();
		//ellipse(width / 2 /*+ osc_x * 8*/, height / 2/* + osc_y * 6*/, 1 + i / 4 + osc_x, 1 + i / 4 - osc_y);
		//ellipse(width / 2 /*+ osc_x * 8*/, height / 2/* + osc_y * 6*/, 1 + i + osc_x, 1 + i + osc_y);
		//ellipse(i * 32, yy * 32, 24, 16);
						
		yy += 0.25;
	}
	
	noStroke();
	
	loadPixels();
	for (int x = 0; x < width; x += 2) {
		for (int y = 0; y < height; y += 2) {
			color p = pixels[y * width + x];
			
			if (brightness(p) < 32) {
				float noise_size = abs(sin(xmotion / 4)) * 48;
				fill(255, 255, 255, noise_size);
				rect(x + random(8), y + random(8), 2, 2);	
				fill(0, 0, 0, 2);
				rect(x + random(8), y + random(8), noise_size, noise_size);	
			}
		}
	}
	
	xmotion += 0.005;
	ymotion += 0.008;
	
	rxmotion += 0.05;
	rymotion += 0;
	rzmotion += 0;
	
	frame += 1;
	
	if (frame%frame_switch_stroke == 0) {
		new_center_sphere_stroke_weight = 1 + random(42);
	}
}

void setup() {
  size(400, 400);

  frameRate(60); 

  background(0);
	
	smooth();
}

void draw() {
  //background(0);

  draw_func();
}"
"579071","Glitch space","mySketch","void andres_circle(int x_centre, int y_centre, int r) {
	int x = 0;
	int y = r;
	int d = r - 1;
	
	while (y >= x) {
		fill(255, 255, 255, 255);
		rect(x_centre + x , y_centre + y, 1, 1);
		fill(255, 255, 255, 0);
		rect(x_centre + y , y_centre + x, 1, 1);
		fill(255, 255, 255, 0);
		rect(x_centre - x , y_centre + y, 1, 1);
		fill(255, 255, 255, 255);
		rect(x_centre - y , y_centre + x, 1, 1);
		fill(255, 255, 255, 0);
		rect(x_centre + x , y_centre - y, 1, 1);
		fill(255, 255, 255, 255);
		rect(x_centre + y , y_centre - x, 1, 1);
		fill(255, 255, 255, 0);
		rect(x_centre - x , y_centre - y, 1, 1);
		fill(255, 255, 255, 255);
		rect(x_centre - y , y_centre - x, 1, 1);

		if (d >= 2 * x) { 
			d = d - 2 * x - 1;
			x = x + 1;
		} else if (d < 2 * (r - y)) {
			d = d + 2 * y - 1;
			y = y - 1;
		} else { 
			d = d + 2 * (y - x - 1);
			y = y - 1;
			x = x + 1;
		}
	}
}

float xmotion = 0;
float ymotion = 0;

void draw_func() {
	noStroke();
	
  fill(0, 0, 0, 32);
  rect(0, 0, 640, 480);

	//stroke(255, 255, 255, 255);
	
	for (int i = 0; i < 32; i += 1) {
		float norm_i = i / 32;
		
		float osc_x = sin(norm_i * 360 * (3.1415 / 180) + xmotion) * 32;
		float osc_y = cos(norm_i * 360 * (3.1415 / 180) + ymotion) * 32;
		
		float abs_osc_x = abs(osc_x);
		float abs_osc_y = abs(osc_y);
		
		if (osc_x > 0 && osc_y > 0) {
			fill(255, 255, 255, norm_i * 255);
		} else if (osc_x > 0 && osc_y < 0) {
			fill(255, 255, 255, norm_i * 255);
		} else if (osc_x < 0 && osc_y > 0) {
			fill(255, 255, 255, norm_i * 255);
		} else if (osc_x < 0 && osc_y < 0) {
			fill(255, 255, 255, norm_i * 255);
		}
		
		andres_circle(640 / 2 + osc_x, 480 / 2 + osc_y, 32 + i * 6);
	}
	
	xmotion += 0.1;
	ymotion += 0.05;
}

void setup() {
  size(640, 480);

  frameRate(60); 

  background(0);
}

void draw() {
  //background(0);

  draw_func();
}"
"579071","Glitch space","mySketch","void andres_circle(int x_centre, int y_centre, int r) {
	int x = 0;
	int y = r;
	int d = r - 1;
	
	while (y >= x) {
		fill(255, 255, 255, 255);
		rect(x_centre + x , y_centre + y, 1, 1);
		//fill(255, 255, 255, 0);
		//rect(x_centre + y , y_centre + x, 1, 1);
		//fill(255, 255, 255, 255);
		//rect(x_centre - x , y_centre + y, 1, 1);
		fill(255, 255, 255, 255);
		rect(x_centre - y , y_centre + x, 1, 1);
		//fill(255, 255, 255, 255);
		//rect(x_centre + x , y_centre - y, 1, 1);
		fill(255, 255, 255, 255);
		rect(x_centre + y , y_centre - x, 1, 1);
		fill(255, 255, 255, 255);
		rect(x_centre - x , y_centre - y, 1, 1);
		//fill(255, 255, 255, 0);
		//rect(x_centre - y , y_centre - x, 1, 1);

		if (d >= 2 * x) { 
			d = d - 2 * x - 1;
			x = x + 1;
		} else if (d < 2 * (r - y)) {
			d = d + 2 * y - 1;
			y = y - 1;
		} else { 
			d = d + 2 * (y - x - 1);
			y = y - 1;
			x = x + 1;
		}
	}
}

float xmotion = 0;
float ymotion = 0;

float rxmotion = 0;
float rymotion = 0;
float rzmotion = 0;

void draw_func() {
	noStroke();
	
  fill(0, 0, 0, 32);
  rect(0, 0, width, height);

	//stroke(255, 255, 255, 255);
	
	for (int i = 0; i < 32; i += 1) {
		float norm_i = i / 32;
		
		float osc_x = sin(norm_i * 360 * (3.1415 / 180) + xmotion) * 32;
		float osc_y = cos(norm_i * 360 * (3.1415 / 180) + ymotion) * 32;
		
		float abs_osc_x = abs(osc_x);
		float abs_osc_y = abs(osc_y);
		
		if (osc_x > 0 && osc_y > 0) {
			fill(255, 255, 255, norm_i * 255);
		} else if (osc_x > 0 && osc_y < 0) {
			fill(255, 255, 255, norm_i * 255);
		} else if (osc_x < 0 && osc_y > 0) {
			fill(255, 255, 255, norm_i * 255);
		} else if (osc_x < 0 && osc_y < 0) {
			fill(255, 255, 255, norm_i * 255);
		}
		
		pushMatrix();
		
		translate(width / 2, height / 2);
		rotate(rxmotion, rymotion, rzmotion);
		
		andres_circle(width / 2 + osc_x, height / 2 + osc_y, 32 + i * 6);
		
		popMatrix();
	}
	
	xmotion += 0.1;
	ymotion += 0.05;
	
	rxmotion += 0.5;
	rymotion += 0;
	rzmotion += 0;
}

void setup() {
  size(640, 480);

  frameRate(60); 

  background(0);
}

void draw() {
  //background(0);

  draw_func();
}"
"579071","Glitch space","mySketch","void andres_circle(int x_centre, int y_centre, int r) {
	int x = 0;
	int y = r;
	int d = r - 1;
	
	while (y >= x) {
		fill(255, 255, 255, 255);
		rect(x_centre + x , y_centre + y, 1, 1);
		//fill(255, 255, 255, 0);
		//rect(x_centre + y , y_centre + x, 1, 1);
		//fill(255, 255, 255, 255);
		//rect(x_centre - x , y_centre + y, 1, 1);
		fill(255, 255, 255, 255);
		rect(x_centre - y , y_centre + x, 1, 1);
		//fill(255, 255, 255, 255);
		//rect(x_centre + x , y_centre - y, 1, 1);
		fill(255, 255, 255, 255);
		rect(x_centre + y , y_centre - x, 1, 1);
		fill(255, 255, 255, 255);
		rect(x_centre - x , y_centre - y, 1, 1);
		//fill(255, 255, 255, 0);
		//rect(x_centre - y , y_centre - x, 1, 1);

		if (d >= 2 * x) { 
			d = d - 2 * x - 1;
			x = x + 1;
		} else if (d < 2 * (r - y)) {
			d = d + 2 * y - 1;
			y = y - 1;
		} else { 
			d = d + 2 * (y - x - 1);
			y = y - 1;
			x = x + 1;
		}
	}
}

float xmotion = 0;
float ymotion = 0;

float rxmotion = 0;
float rymotion = 0;
float rzmotion = 0;

void draw_func() {
	noStroke();
	
  fill(0, 0, 0, 32);
  rect(0, 0, width, height);

	//stroke(255, 255, 255, 255);
	
	for (int i = 0; i < 32; i += 1) {
		float norm_i = i / 32;
		
		float osc_x = sin(norm_i * 360 * (3.1415 / 180) + xmotion) * 32;
		float osc_y = cos(norm_i * 360 * (3.1415 / 180) + ymotion) * 32;
		
		float abs_osc_x = abs(osc_x);
		float abs_osc_y = abs(osc_y);
		
		if (osc_x > 0 && osc_y > 0) {
			fill(255, 255, 255, norm_i * 255);
		} else if (osc_x > 0 && osc_y < 0) {
			fill(255, 255, 255, norm_i * 255);
		} else if (osc_x < 0 && osc_y > 0) {
			fill(255, 255, 255, norm_i * 255);
		} else if (osc_x < 0 && osc_y < 0) {
			fill(255, 255, 255, norm_i * 255);
		}
		
		pushMatrix();
		
		translate(width / 2, height / 2);
		rotate(rxmotion, rymotion, rzmotion);
		
		andres_circle(width / 2 + osc_x, height / 2 + osc_y, 32 + i * 6);
		
		popMatrix();
	}
	
	xmotion += 0.1;
	ymotion += 0.05;
	
	rxmotion += 0.5;
	rymotion += 0;
	rzmotion += 0;
}

void setup() {
  size(640, 480);

  frameRate(60); 

  background(0);
}

void draw() {
  //background(0);

  draw_func();
}"
"579071","Glitch space","mySketch","void andres_circle(int x_centre, int y_centre, int r) {
	int x = 0;
	int y = r;
	int d = r - 1;
	
	while (y >= x) {
		float norm_r = y / r;
		
		float rot_y = cos(norm_r * 360 * (3.1415 / 180) + xmotion) * 32;
		
		fill(255, 255, 255, 255);
		rect(x_centre + x, y_centre + y, 1, 1);
		//fill(255, 255, 255, 0);
		//rect(x_centre + y , y_centre + x, 1, 1);
		//fill(255, 255, 255, 255);
		//rect(x_centre - x , y_centre + y, 1, 1);
		fill(255, 255, 255, 255);
		rect(x_centre - y , y_centre + x, 1, 1);
		//fill(255, 255, 255, 255);
		//rect(x_centre + x , y_centre - y, 1, 1);
		fill(255, 255, 255, 255);
		rect(x_centre + y , y_centre - x, 1, 1);
		fill(255, 255, 255, 255);
		rect(x_centre - x, y_centre - y, 1, 1);
		//fill(255, 255, 255, 0);
		//rect(x_centre - y , y_centre - x, 1, 1);

		if (d >= 2 * x) { 
			d = d - 2 * x - 1;
			x = x + 1;
		} else if (d < 2 * (r - y)) {
			d = d + 2 * y - 1;
			y = y - 1;
		} else { 
			d = d + 2 * (y - x - 1);
			y = y - 1;
			x = x + 1;
		}
	}
}

float xmotion = 0;
float ymotion = 0;

float rxmotion = 0;
float rymotion = 0;
float rzmotion = 0;

void draw_func() {
	noStroke();
	
  fill(0, 0, 0, 32);
  rect(0, 0, width, height);

	//stroke(255, 255, 255, 255);
	
	for (int i = 0; i < 32; i += 1) {
		float norm_i = i / 32;
		
		float osc_x = sin(norm_i * 360 * (3.1415 / 180) + xmotion) * 32;
		float osc_y = cos(norm_i * 360 * (3.1415 / 180) + ymotion) * 32;
		
		float abs_osc_x = abs(osc_x);
		float abs_osc_y = abs(osc_y);
		
		if (osc_x > 0 && osc_y > 0) {
			fill(255, 255, 255, norm_i * 255);
		} else if (osc_x > 0 && osc_y < 0) {
			fill(255, 255, 255, norm_i * 255);
		} else if (osc_x < 0 && osc_y > 0) {
			fill(255, 255, 255, norm_i * 255);
		} else if (osc_x < 0 && osc_y < 0) {
			fill(255, 255, 255, norm_i * 255);
		}
			
		andres_circle(width / 2 + osc_x, height / 2 + osc_y, 32 + i * 6);
	}
	
	for (int i = 0; i < 32; i += 1) {
		fill(0, 0, 0, 64);
		rect(random(0, width), random(0, height), 16, 16);
	}
	
	xmotion += 0.1;
	ymotion += 0.05;
	
	rxmotion += 10.5;
	rymotion += 0;
	rzmotion += 0;
}

void setup() {
  size(640, 480);

  frameRate(60); 

  background(0);
}

void draw() {
  //background(0);

  draw_func();
}"
"579071","Glitch space","mySketch","void andres_circle(int x_centre, int y_centre, int r) {
	int x = 0;
	int y = r;
	int d = r - 1;
	
	while (y >= x) {
		//float norm_r = abs(0.5 - y / r);
		
		//float rot_y = cos(norm_r * 360 * (3.1415 / 180) + xmotion) * 32;
		
		rect(x_centre + x, y_centre + y, 1, 1);
		rect(x_centre + y , y_centre + x, 1, 1);
		rect(x_centre - x , y_centre + y, 1, 1);
		rect(x_centre - y , y_centre + x, 1, 1);
		rect(x_centre + x , y_centre - y, 1, 1);
		rect(x_centre + y , y_centre - x, 1, 1);
		rect(x_centre - x, y_centre - y, 1, 1);
		rect(x_centre - y , y_centre - x, 1, 1);

		if (d >= 2 * x) { 
			d = d - 2 * x - 1;
			x = x + 1;
		} else if (d < 2 * (r - y)) {
			d = d + 2 * y - 1;
			y = y - 1;
		} else { 
			d = d + 2 * (y - x - 1);
			y = y - 1;
			x = x + 1;
		}
	}
}

float xmotion = 0;
float ymotion = 0;

float rxmotion = 0;
float rymotion = 0;
float rzmotion = 0;

void draw_func() {
	noStroke();
	
  fill(0, 0, 0, 2);
  rect(0, 0, width, height);

	//stroke(255, 255, 255, 255);
	
	int count = 16;
	
	for (int i = 0; i < count; i += 1) {
		float norm_i = i / count;
		
		float norm_i_abs = (0.5 - abs(0.5 - norm_i)) * 2.;
		
		float osc_x = sin(norm_i_abs * 360 * (3.1415 / 180) + xmotion) * 32;
		float osc_y = cos(norm_i_abs * 360 * (3.1415 / 180) + ymotion) * 32;
		
		float abs_osc_x = abs(osc_x);
		float abs_osc_y = abs(osc_y);
		
		if (osc_x > 0 && osc_y > 0) {
			fill(255, 255, 255, norm_i_abs * 255);
		} else if (osc_x > 0 && osc_y < 0) {
			fill(255, 255, 255, norm_i_abs * 255);
		} else if (osc_x < 0 && osc_y > 0) {
			fill(255, 255, 255, norm_i_abs * 255);
		} else if (osc_x < 0 && osc_y < 0) {
			fill(255, 255, 255, norm_i_abs * 255);
		}
			
		andres_circle(width / 2 + osc_x, height / 2 + osc_y, 128 + (i * 4) * norm_i_abs);
	}
	
	int rect_size_x = 32;
	int rect_size_y = 32;
	
	int cx = width / rect_size_x;
	int cy = height / rect_size_y;
	
	for (int i = 0; i < cy; i += 1) {
		float norm_i = abs(0.5 - i / cy);
		for (int j = 0; j < cx; j += 1) {
			float norm_j = abs(0.5 - j / cx);
			float norm_ij = abs(norm_i - norm_j + random(-1, 1));
			
			fill(0, 0, 0, random(0, 32));
			rect(j * rect_size_x, i * rect_size_y, rect_size_x, rect_size_y);
		}
	}
	
	xmotion += 0.1;
	ymotion += 0.05;
	
	rxmotion += 10.5;
	rymotion += 0;
	rzmotion += 0;
}

void setup() {
  size(400, 400);

  frameRate(60); 

  background(0);
}

void draw() {
  //background(0);

  draw_func();
}"
"579071","Glitch space","mySketch","void andres_circle(int x_centre, int y_centre, int r) {
	int x = 0;
	int y = r;
	int d = r - 1;
	
	while (y >= x) {
		//float norm_r = abs(0.5 - y / r);
		
		//float rot_y = cos(norm_r * 360 * (3.1415 / 180) + xmotion) * 32;
		
		rect(x_centre + x, y_centre + y, 1, 1);
		rect(x_centre + y , y_centre + x, 1, 1);
		rect(x_centre - x , y_centre + y, 1, 1);
		rect(x_centre - y , y_centre + x, 1, 1);
		rect(x_centre + x , y_centre - y, 1, 1);
		rect(x_centre + y , y_centre - x, 1, 1);
		rect(x_centre - x, y_centre - y, 1, 1);
		rect(x_centre - y , y_centre - x, 1, 1);

		if (d >= 2 * x) { 
			d = d - 2 * x - 1;
			x = x + 1;
		} else if (d < 2 * (r - y)) {
			d = d + 2 * y - 1;
			y = y - 1;
		} else { 
			d = d + 2 * (y - x - 1);
			y = y - 1;
			x = x + 1;
		}
	}
}

float xmotion = 0;
float ymotion = 0;

float rxmotion = 0;
float rymotion = 0;
float rzmotion = 0;

void draw_func() {
	noStroke();
	
  fill(0, 0, 0, 2);
  rect(0, 0, width, height);

	//stroke(255, 255, 255, 255);
	
	int lcount = 4;
	
	int rect_size_x = 64;
	int rect_size_y = 64;
	
	int cx = width / rect_size_x;
	int cy = height / rect_size_y;
	
	for (int i = 0; i < cy; i += 1) {
		float norm_i = abs(0.5 - i / cy);
		for (int j = 0; j < cx; j += 1) {
			float norm_j = (0.5 - abs(0.5 - j / cx)) * 2;//abs(0.5 - j / cx);
			float norm_ij = abs(norm_i - norm_j + random(-1, 1));
			
			fill(0, 0, 0, random(16, 24));
			rect(j * rect_size_x, i * rect_size_y, random(1, rect_size_x), random(1, rect_size_y));
			
			for (int k = 0; k < lcount; k += 1) {
				float norm_k = (0.5 - abs(0.5 - k / lcount)) * 2;
				
				int ly = i * rect_size_y + (rect_size_y / lcount) * k;
				
				float osc_x, osc_y;
				
				if ((k % 2) == 0) {
					osc_x = sin(norm_k * 360 * (3.1415 / 180) + xmotion) * 32;
					osc_y = cos(norm_k * 360 * (3.1415 / 180) - ymotion) * 32;
					
					stroke(255, 0, 255 * norm_i, 255 * norm_i * norm_k);
				} else {
					osc_x = sin(norm_k * 360 * (3.1415 / 180) - xmotion) * 32;
					osc_y = cos(norm_k * 360 * (3.1415 / 180) + ymotion) * 32;
					
					stroke(255 * norm_i, 0, 255, 255 * norm_i * norm_k);
				}
				
				int hcount = 8;
				
				//line(0, ly + osc_y, width, ly - osc_y);
				line(0, ly + osc_y * 8, width, height / 2);
				line(width - 1, ly + osc_y * 8, 0, height / 2);
				//line(ly + osc_x, 0, ly - osc_x, 0);
				//line(ly + osc_x, 0, ly - osc_x, height);
				
				noStroke();
				
				for (int h = 0; h < hcount; h += 1) {
					int xh = h - hcount / 2;
					
					fill(0, 0, 0, 8);
					rect(osc_x + xh * 128, ly + osc_y, 64, 64);
				}
			}
			noStroke();
		}
	}
	
	int centered_rect_size = 256;
	
	// support
	fill(0, 0, 0, 255);
	//noFill();
	stroke(255, 255, 255, 255);
	
	int tx = width / 2 - centered_rect_size / 2 - 8;
	int ty1 = height / 2;
	int ty2 = height / 2 + centered_rect_size / 2 + 32;
	
	triangle(tx, ty1, width - tx, ty1, width / 2, ty2);
	triangle(width / 2, height - ty1, width - tx, ty2, width / 2, ty2);
	//
	
	stroke(255, 255, 255, 255);
	
	fill(0, 0, 0, 228);
	ellipse(width / 2, height / 2, centered_rect_size, centered_rect_size);
	
	noStroke();
	
	int count = 24;
	
	for (int i = 0; i < count; i += 1) {
		float norm_i = i / count;
		
		float osc_x = sin(norm_i_abs * 360 * (3.1415 / 180) + xmotion) * 10;
		float osc_y = cos(norm_i_abs * 360 * (3.1415 / 180) + ymotion) * 10;
		
		float norm_i_abs = (0.5 - abs(0.5 - norm_i)) * 2;
		
		float abs_osc_x = abs(osc_x);
		float abs_osc_y = abs(osc_y);
		
		if (osc_x > 0 && osc_y > 0) {
			fill(norm_i_abs * 255, 255, 255, norm_i_abs * 255);
		} else if (osc_x > 0 && osc_y < 0) {
			fill(255, norm_i_abs * 255, 255, norm_i_abs * 255);
		} else if (osc_x < 0 && osc_y > 0) {
			fill(255, 255, norm_i_abs * 255, norm_i_abs * 255);
		} else if (osc_x < 0 && osc_y < 0) {
			fill(255, 255, 255, norm_i_abs * 255);
		}
			
		andres_circle(width / 2 + osc_x * 8, height / 2 + osc_y * 6, 1 + i + osc_x);
		ellipse(width / 2 + osc_x * 8, height / 2 + osc_y * 6, 1 + i + osc_x, 1 + i + osc_x);
	}
	
	xmotion += 0.05;
	ymotion += 0.008;
	
	rxmotion += 10.5;
	rymotion += 0;
	rzmotion += 0;
}

void setup() {
  size(400, 400);

  frameRate(60); 

  background(0);
}

void draw() {
  //background(0);

  draw_func();
}"
"579071","Glitch space","mySketch","void andres_circle(int x_centre, int y_centre, int r) {
	int x = 0;
	int y = r;
	int d = r - 1;
	
	while (y >= x) {
		//float norm_r = abs(0.5 - y / r);
		
		//float rot_y = cos(norm_r * 360 * (3.1415 / 180) + xmotion) * 32;
		
		rect(x_centre + x, y_centre + y, 1, 1);
		rect(x_centre + y , y_centre + x, 1, 1);
		rect(x_centre - x , y_centre + y, 1, 1);
		rect(x_centre - y , y_centre + x, 1, 1);
		rect(x_centre + x , y_centre - y, 1, 1);
		rect(x_centre + y , y_centre - x, 1, 1);
		rect(x_centre - x, y_centre - y, 1, 1);
		rect(x_centre - y , y_centre - x, 1, 1);

		if (d >= 2 * x) { 
			d = d - 2 * x - 1;
			x = x + 1;
		} else if (d < 2 * (r - y)) {
			d = d + 2 * y - 1;
			y = y - 1;
		} else { 
			d = d + 2 * (y - x - 1);
			y = y - 1;
			x = x + 1;
		}
	}
}

float xmotion = 0;
float ymotion = 0;

float rxmotion = 0;
float rymotion = 0;
float rzmotion = 0;

void draw_func() {
	noStroke();
	
  fill(0, 0, 0, 2);
  rect(0, 0, width, height);

	//stroke(255, 255, 255, 255);
	
	int lcount = 4;
	
	int rect_size_x = 64;
	int rect_size_y = 64;
	
	int cx = width / rect_size_x;
	int cy = height / rect_size_y;
	
	for (int i = 0; i < cy; i += 1) {
		float norm_i = abs(0.5 - i / cy);
		for (int j = 0; j < cx; j += 1) {
			float norm_j = (0.5 - abs(0.5 - j / cx)) * 2;//abs(0.5 - j / cx);
			float norm_ij = abs(norm_i - norm_j + random(-1, 1));
			
			fill(0, 0, 0, random(16, 24));
			rect(j * rect_size_x, i * rect_size_y, random(1, rect_size_x), random(1, rect_size_y));
			
			for (int k = 0; k < lcount; k += 1) {
				float norm_k = (0.5 - abs(0.5 - k / lcount)) * 2;
				
				int ly = i * rect_size_y + (rect_size_y / lcount) * k;
				
				float osc_x, osc_y;
				
				if ((k % 2) == 0) {
					osc_x = sin(norm_k * 360 * (3.1415 / 180) + xmotion) * 32;
					osc_y = cos(norm_k * 360 * (3.1415 / 180) - ymotion) * 32;
					
					stroke(255, 0, 255 * norm_i, 255 * norm_i * norm_k);
				} else {
					osc_x = sin(norm_k * 360 * (3.1415 / 180) - xmotion) * 32;
					osc_y = cos(norm_k * 360 * (3.1415 / 180) + ymotion) * 32;
					
					stroke(255 * norm_i, 0, 255, 255 * norm_i * norm_k);
				}
				
				int hcount = 8;
				
				//line(0, ly + osc_y, width, ly - osc_y);
				line(0, ly + osc_y * 8, width, height / 2);
				line(width - 1, ly + osc_y * 8, 0, height / 2);
				//line(ly + osc_x, 0, ly - osc_x, 0);
				//line(ly + osc_x, 0, ly - osc_x, height);
				
				noStroke();
				
				for (int h = 0; h < hcount; h += 1) {
					int xh = h - hcount / 2;
					
					fill(0, 0, 0, 8);
					rect(osc_x + xh * 128, ly + osc_y, 64, 64);
				}
			}
			noStroke();
		}
	}
	
	int centered_rect_size = 256;
	
	// support
	fill(0, 0, 0, 255);
	//noFill();
	stroke(255, 255, 255, 255);
	
	int tx = width / 2 - centered_rect_size / 2 - 8;
	int ty1 = height / 2 + 192;
	int ty2 = height / 2 + 192 + centered_rect_size / 2;
	
	triangle(tx, ty1, width - tx, ty1, width / 2, ty2);
	triangle(tx, ty1, width / 2, height * 1.125 - ty2, width - tx, ty1);
	//
	
	stroke(255, 255, 255, 255);
	
	fill(0, 0, 0, 228);
	ellipse(width / 2, height / 2, centered_rect_size, centered_rect_size);
	
	noStroke();
	
	int count = 24;
	
	for (int i = 0; i < count; i += 1) {
		float norm_i = i / count;
		
		float osc_x = sin(norm_i_abs * 360 * (3.1415 / 180) + xmotion) * 10;
		float osc_y = cos(norm_i_abs * 360 * (3.1415 / 180) + ymotion) * 10;
		
		float norm_i_abs = (0.5 - abs(0.5 - norm_i)) * 2;
		
		float abs_osc_x = abs(osc_x);
		float abs_osc_y = abs(osc_y);
		
		if (osc_x > 0 && osc_y > 0) {
			fill(norm_i_abs * 255, 255, 255, norm_i_abs * 255);
		} else if (osc_x > 0 && osc_y < 0) {
			fill(255, norm_i_abs * 255, 255, norm_i_abs * 255);
		} else if (osc_x < 0 && osc_y > 0) {
			fill(255, 255, norm_i_abs * 255, norm_i_abs * 255);
		} else if (osc_x < 0 && osc_y < 0) {
			fill(255, 255, 255, norm_i_abs * 255);
		}
			
		andres_circle(width / 2 + osc_x * 8, height / 2 + osc_y * 6, 1 + i + osc_x);
		ellipse(width / 2 + osc_x * 8, height / 2 + osc_y * 6, 1 + i + osc_x, 1 + i + osc_x);
	}
	
	xmotion += 0.05;
	ymotion += 0.008;
	
	rxmotion += 10.5;
	rymotion += 0;
	rzmotion += 0;
}

void setup() {
  size(400, 400);

  frameRate(60); 

  background(0);
}

void draw() {
  //background(0);

  draw_func();
}"
"579071","Glitch space","mySketch","void andres_circle(int x_centre, int y_centre, int r) {
	int x = 0;
	int y = r;
	int d = r - 1;
	
	while (y >= x) {
		//float norm_r = abs(0.5 - y / r);
		
		//float rot_y = cos(norm_r * 360 * (3.1415 / 180) + xmotion) * 32;
		
		rect(x_centre + x, y_centre + y, 1, 1);
		rect(x_centre + y , y_centre + x, 1, 1);
		rect(x_centre - x , y_centre + y, 1, 1);
		rect(x_centre - y , y_centre + x, 1, 1);
		rect(x_centre + x , y_centre - y, 1, 1);
		rect(x_centre + y , y_centre - x, 1, 1);
		rect(x_centre - x, y_centre - y, 1, 1);
		rect(x_centre - y , y_centre - x, 1, 1);

		if (d >= 2 * x) { 
			d = d - 2 * x - 1;
			x = x + 1;
		} else if (d < 2 * (r - y)) {
			d = d + 2 * y - 1;
			y = y - 1;
		} else { 
			d = d + 2 * (y - x - 1);
			y = y - 1;
			x = x + 1;
		}
	}
}

float xmotion = 0;
float ymotion = 0;

float rxmotion = 0;
float rymotion = 0;
float rzmotion = 0;

void draw_func() {
	noStroke();
	
  fill(0, 0, 0, 2);
  rect(0, 0, width, height);

	//stroke(255, 255, 255, 255);
	
	int lcount = 4;
	
	int rect_size_x = 64;
	int rect_size_y = 64;
	
	int cx = width / rect_size_x;
	int cy = height / rect_size_y;
	
	for (int i = 0; i < cy; i += 1) {
		float norm_i = abs(0.5 - i / cy);
		for (int j = 0; j < cx; j += 1) {
			float norm_j = (0.5 - abs(0.5 - j / cx)) * 2;//abs(0.5 - j / cx);
			float norm_ij = abs(norm_i - norm_j + random(-1, 1));
			
			fill(0, 0, 0, random(16, 24));
			rect(j * rect_size_x, i * rect_size_y, random(1, rect_size_x), random(1, rect_size_y));
			
			for (int k = 0; k < lcount; k += 1) {
				float norm_k = (0.5 - abs(0.5 - k / lcount)) * 2;
				
				int ly = i * rect_size_y + (rect_size_y / lcount) * k;
				
				float osc_x, osc_y;
				
				if ((k % 2) == 0) {
					osc_x = sin(norm_k * 360 * (3.1415 / 180) + xmotion) * 32;
					osc_y = cos(norm_k * 360 * (3.1415 / 180) - ymotion) * 32;
					
					stroke(255, 0, 255 * norm_i, 255 * norm_i * norm_k);
				} else {
					osc_x = sin(norm_k * 360 * (3.1415 / 180) - xmotion) * 32;
					osc_y = cos(norm_k * 360 * (3.1415 / 180) + ymotion) * 32;
					
					stroke(255 * norm_i, 0, 255, 255 * norm_i * norm_k);
				}
				
				int hcount = 8;
				
				//line(0, ly + osc_y, width, ly - osc_y);
				line(0, ly + osc_y * 8, width, height / 2);
				line(width - 1, ly + osc_y * 8, 0, height / 2);
				//line(ly + osc_x, 0, ly - osc_x, 0);
				//line(ly + osc_x, 0, ly - osc_x, height);
				
				noStroke();
				
				for (int h = 0; h < hcount; h += 1) {
					int xh = h - hcount / 2;
					
					fill(0, 0, 0, 8);
					rect(osc_x + xh * 128, ly + osc_y, 64, 64);
				}
			}
			noStroke();
		}
	}
	
	int centered_rect_size = 256;
	
	// support	
	int tx = width / 2 - centered_rect_size / 2 + 16;
	int ty1 = height / 2 + 132;
	int ty2 = height / 2 + 40 + centered_rect_size / 2;

	fill(0, 0, 0, 255);
	stroke(24, 24, 24, 255);
	triangle(tx, ty1, width - tx, ty1, width / 2, ty2);
	
	fill(0, 0, 0, 255);
	stroke(255, 255, 255, 255);
	triangle(tx, ty1, width / 2, height * 1.5 - ty2, width - tx, ty1);
	//
	
	stroke(255, 255, 255, 255);
	
	fill(0, 0, 0, 228);
	ellipse(width / 2, height / 2, centered_rect_size, centered_rect_size);
	
	noStroke();
	
	int count = 24;
	
	for (int i = 0; i < count; i += 1) {
		float norm_i = i / count;
		
		float osc_x = sin(norm_i_abs * 360 * (3.1415 / 180) + xmotion) * 10;
		float osc_y = cos(norm_i_abs * 360 * (3.1415 / 180) + ymotion) * 10;
		
		float norm_i_abs = (0.5 - abs(0.5 - norm_i)) * 2;
		
		float abs_osc_x = abs(osc_x);
		float abs_osc_y = abs(osc_y);
		
		if (osc_x > 0 && osc_y > 0) {
			fill(norm_i_abs * 255, 255, 255, norm_i_abs * 255);
		} else if (osc_x > 0 && osc_y < 0) {
			fill(255, norm_i_abs * 255, 255, norm_i_abs * 255);
		} else if (osc_x < 0 && osc_y > 0) {
			fill(255, 255, norm_i_abs * 255, norm_i_abs * 255);
		} else if (osc_x < 0 && osc_y < 0) {
			fill(255, 255, 255, norm_i_abs * 255);
		}
			
		andres_circle(width / 2 + osc_x * 8, height / 2 + osc_y * 6, 1 + i + osc_x);
		ellipse(width / 2 + osc_x * 8, height / 2 + osc_y * 6, 1 + i + osc_x, 1 + i + osc_x);
	}
	
	xmotion += 0.05;
	ymotion += 0.008;
	
	rxmotion += 0.05;
	rymotion += 0;
	rzmotion += 0;
}

void setup() {
  size(400, 400);

  frameRate(60); 

  background(0);
}

void draw() {
  //background(0);

  draw_func();
}"
"579071","Glitch space","mySketch","/**
  * Composition which begun with Andres circle drawing algorithm for fun and ended with regular shapes. :)
	*/

void andres_circle(int x_centre, int y_centre, int r) {
	int x = 0;
	int y = r;
	int d = r - 1;
	
	while (y >= x) {
		//float norm_r = abs(0.5 - y / r);
		
		//float rot_y = cos(norm_r * 360 * (3.1415 / 180) + xmotion) * 32;
		
		rect(x_centre + x, y_centre + y, 1, 1);
		rect(x_centre + y , y_centre + x, 1, 1);
		rect(x_centre - x , y_centre + y, 1, 1);
		rect(x_centre - y , y_centre + x, 1, 1);
		rect(x_centre + x , y_centre - y, 1, 1);
		rect(x_centre + y , y_centre - x, 1, 1);
		rect(x_centre - x, y_centre - y, 1, 1);
		rect(x_centre - y , y_centre - x, 1, 1);

		if (d >= 2 * x) { 
			d = d - 2 * x - 1;
			x = x + 1;
		} else if (d < 2 * (r - y)) {
			d = d + 2 * y - 1;
			y = y - 1;
		} else { 
			d = d + 2 * (y - x - 1);
			y = y - 1;
			x = x + 1;
		}
	}
}

float xmotion = 0;
float ymotion = 0;

float rxmotion = 0;
float rymotion = 0;
float rzmotion = 0;

void draw_func() {
	noStroke();
	
  fill(0, 0, 0, 2);
  rect(0, 0, width, height);

	//stroke(255, 255, 255, 255);
	
	int lcount = 4;
	
	int rect_size_x = 64;
	int rect_size_y = 64;
	
	int cx = width / rect_size_x;
	int cy = height / rect_size_y;
	
	for (int i = 0; i < cy; i += 1) {
		float norm_i = abs(0.5 - i / cy);
		for (int j = 0; j < cx; j += 1) {
			float norm_j = (0.5 - abs(0.5 - j / cx)) * 2;//abs(0.5 - j / cx);
			float norm_ij = abs(norm_i - norm_j + random(-1, 1));
			
			fill(0, 0, 0, random(16, 24));
			rect(j * rect_size_x, i * rect_size_y, random(1, rect_size_x), random(1, rect_size_y));
			
			for (int k = 0; k < lcount; k += 1) {
				float norm_k = (0.5 - abs(0.5 - k / lcount)) * 2;
				
				int ly = i * rect_size_y + (rect_size_y / lcount) * k;
				
				float osc_x, osc_y;
				
				if ((k % 2) == 0) {
					osc_x = sin(norm_k * 360 * (3.1415 / 180) + xmotion) * 32;
					osc_y = cos(norm_k * 360 * (3.1415 / 180) - ymotion) * 32;
					
					stroke(255, 0, 255 * norm_i, 255 * norm_i * norm_k);
				} else {
					osc_x = sin(norm_k * 360 * (3.1415 / 180) - xmotion) * 32;
					osc_y = cos(norm_k * 360 * (3.1415 / 180) + ymotion) * 32;
					
					stroke(255 * norm_i, 0, 255, 255 * norm_i * norm_k);
				}
				
				int hcount = 8;
				
				//line(0, ly + osc_y, width, ly - osc_y);
				line(0, ly + osc_y * 8, width, height / 2);
				line(width - 1, ly + osc_y * 8, 0, height / 2);
				//line(ly + osc_x, 0, ly - osc_x, 0);
				//line(ly + osc_x, 0, ly - osc_x, height);
				
				noStroke();
				
				for (int h = 0; h < hcount; h += 1) {
					int xh = h - hcount / 2;
					
					fill(0, 0, 0, 8);
					rect(osc_x + xh * 128, ly + osc_y, 64, 64);
				}
			}
			noStroke();
		}
	}
	
	int centered_rect_size = 256;
	
	// support	
	int tx = width / 2 - centered_rect_size / 2 + 16;
	int ty1 = height / 2 + 132;
	int ty2 = height / 2 + 40 + centered_rect_size / 2;

	fill(0, 0, 0, 255);
	stroke(24, 24, 24, 255);
	triangle(tx, ty1, width - tx, ty1, width / 2, ty2);
	
	fill(0, 0, 0, 255);
	stroke(255, 255, 255, 255);
	triangle(tx, ty1, width / 2, height * 1.5 - ty2, width - tx, ty1);
	//
	
	stroke(255, 255, 255, 255);
	
	fill(0, 0, 0, 228);
	ellipse(width / 2, height / 2, centered_rect_size, centered_rect_size);
	
	noStroke();
	
	int count = 48;
	
	for (int i = 0; i < count; i += 1) {
		float norm_i = i / count;
		
		float norm_i_abs = (0.5 - abs(0.5 - norm_i)) * 2;
		
		float osc_x = sin((norm_i_abs * 360) * (3.1415 / 180) + xmotion / 20) * (centered_rect_size - 32);
		float osc_y = cos((norm_i_abs * 360) * (3.1415 / 180) + ymotion / 20) * (centered_rect_size - 32);
		
		float abs_osc_x = abs(osc_x);
		float abs_osc_y = abs(osc_y);
		
		if (osc_x > 0 && osc_y > 0) {
			fill(norm_i_abs * 255, 255, 255, norm_i_abs * 255);
			stroke(norm_i_abs * 255, 255, 255, norm_i_abs * 255);
		} else if (osc_x > 0 && osc_y < 0) {
			fill(255, norm_i_abs * 255, 255, norm_i_abs * 255);
			stroke(255, norm_i_abs * 255, 255, norm_i_abs * 255);
		} else if (osc_x < 0 && osc_y > 0) {
			fill(255, 255, norm_i_abs * 255, norm_i_abs * 255);
			stroke(255, 255, norm_i_abs * 255, norm_i_abs * 255);
		} else if (osc_x < 0 && osc_y < 0) {
			fill(255, 255, 255, norm_i_abs * 255);
			stroke(255, 255, 255, norm_i_abs * 255);
		}
			
		//andres_circle(width / 2 + osc_x * 8, height / 2 + osc_y * 8, 1 + i + osc_x);
		noFill();
		ellipse(width / 2 /*+ osc_x * 8*/, height / 2/* + osc_y * 6*/, 1 + i + osc_x, 1 + i + osc_x);
	}
	
	xmotion += 0.05;
	ymotion += 0.008;
	
	rxmotion += 0.05;
	rymotion += 0;
	rzmotion += 0;
}

void setup() {
  size(400, 400);

  frameRate(60); 

  background(0);
}

void draw() {
  //background(0);

  draw_func();
}"
"579071","Glitch space","mySketch","/**
  * Composition which begun with Andres circle drawing algorithm for fun and ended with regular shapes. :)
	*/

void andres_circle(int x_centre, int y_centre, int r) {
	int x = 0;
	int y = r;
	int d = r - 1;
	
	while (y >= x) {
		//float norm_r = abs(0.5 - y / r);
		
		//float rot_y = cos(norm_r * 360 * (3.1415 / 180) + xmotion) * 32;
		
		rect(x_centre + x, y_centre + y, 1, 1);
		rect(x_centre + y , y_centre + x, 1, 1);
		rect(x_centre - x , y_centre + y, 1, 1);
		rect(x_centre - y , y_centre + x, 1, 1);
		rect(x_centre + x , y_centre - y, 1, 1);
		rect(x_centre + y , y_centre - x, 1, 1);
		rect(x_centre - x, y_centre - y, 1, 1);
		rect(x_centre - y , y_centre - x, 1, 1);

		if (d >= 2 * x) { 
			d = d - 2 * x - 1;
			x = x + 1;
		} else if (d < 2 * (r - y)) {
			d = d + 2 * y - 1;
			y = y - 1;
		} else { 
			d = d + 2 * (y - x - 1);
			y = y - 1;
			x = x + 1;
		}
	}
}

float xmotion = 0;
float ymotion = 0;

float rxmotion = 0;
float rymotion = 0;
float rzmotion = 0;

void draw_func() {
	noStroke();
	
  fill(0, 0, 0, 2);
  rect(0, 0, width, height);

	//stroke(255, 255, 255, 255);
	
	int lcount = 4;
	
	int rect_size_x = 64;
	int rect_size_y = 64;
	
	int cx = width / rect_size_x;
	int cy = height / rect_size_y;
	
	// background
	for (int i = 0; i < cy; i += 1) {
		float norm_i = abs(0.5 - i / cy);
		for (int j = 0; j < cx; j += 1) {
			float norm_j = (0.5 - abs(0.5 - j / cx)) * 2;//abs(0.5 - j / cx);
			float norm_ij = abs(norm_i - norm_j + random(-1, 1));
			
			fill(0, 0, 0, random(16, 24));
			rect(j * rect_size_x, i * rect_size_y, random(1, rect_size_x), random(1, rect_size_y));
			
			for (int k = 0; k < lcount; k += 1) {
				float norm_k = (0.5 - abs(0.5 - k / lcount)) * 2;
				
				int ly = i * rect_size_y + (rect_size_y / lcount) * k;
				
				float osc_x, osc_y;
				
				if ((k % 2) == 0) {
					osc_x = sin(norm_k * 360 * (3.1415 / 180) + xmotion) * 32;
					osc_y = cos(norm_k * 360 * (3.1415 / 180) - ymotion) * 32;
					
					stroke(255, 0, 255 * norm_i, 255 * norm_i * norm_k);
				} else {
					osc_x = sin(norm_k * 360 * (3.1415 / 180) - xmotion) * 32;
					osc_y = cos(norm_k * 360 * (3.1415 / 180) + ymotion) * 32;
					
					stroke(255 * norm_i, 0, 255, 255 * norm_i * norm_k);
				}
				
				int hcount = 8;
				
				//line(0, ly + osc_y, width, ly - osc_y);
				line(0, ly + osc_y * 8, width, height / 2);
				line(width - 1, ly + osc_y * 8, 0, height / 2);
				//line(ly + osc_x, 0, ly - osc_x, 0);
				//line(ly + osc_x, 0, ly - osc_x, height);
				
				noStroke();
				
				for (int h = 0; h < hcount; h += 1) {
					int xh = h - hcount / 2;
					
					fill(0, 0, 0, 8);
					rect(osc_x + xh * 128, ly + osc_y, 64, 64);
				}
			}
			noStroke();
		}
	}
	
	int centered_rect_size = 256;
	
	// support	
	int tx = width / 2 - centered_rect_size / 2 + 16;
	int ty1 = height / 2 + 132;
	int ty2 = height / 2 + 40 + centered_rect_size / 2;

	fill(0, 0, 0, 255);
	stroke(24, 24, 24, 255);
	triangle(tx, ty1, width - tx, ty1, width / 2, ty2);
	
	fill(0, 0, 0, 255);
	stroke(255, 255, 255, 255);
	triangle(tx, ty1, width / 2, height * 1.5 - ty2, width - tx, ty1);
	//
	
	// center sphere
	stroke(255, 255, 255, 255);
	
	fill(0, 0, 0, 228);
	ellipse(width / 2, height / 2, centered_rect_size, centered_rect_size);
	
	noStroke();
	//
	
	// circles
	int count = 48;
	
	for (int i = 0; i < count; i += 1) {
		float norm_i = i / count;
		
		float norm_i_abs = (0.5 - abs(0.5 - norm_i)) * 2;
		
		float osc_x = sin((norm_i_abs * 360) * (3.1415 / 180) + xmotion / 20) * (centered_rect_size - 32);
		float osc_y = cos((norm_i_abs * 360) * (3.1415 / 180) + ymotion / 20) * (centered_rect_size - 32);
		
		float abs_osc_x = abs(osc_x);
		float abs_osc_y = abs(osc_y);
		
		if (osc_x > 0 && osc_y > 0) {
			fill(norm_i_abs * 255, 255, 255, norm_i_abs * 255);
			stroke(norm_i_abs * 255, 255, 255, norm_i_abs * 255);
		} else if (osc_x > 0 && osc_y < 0) {
			fill(255, norm_i_abs * 255, 255, norm_i_abs * 255);
			stroke(255, norm_i_abs * 255, 255, norm_i_abs * 255);
		} else if (osc_x < 0 && osc_y > 0) {
			fill(255, 255, norm_i_abs * 255, norm_i_abs * 255);
			stroke(255, 255, norm_i_abs * 255, norm_i_abs * 255);
		} else if (osc_x < 0 && osc_y < 0) {
			fill(255, 255, 255, norm_i_abs * 255);
			stroke(255, 255, 255, norm_i_abs * 255);
		}
			
		//andres_circle(width / 2 + osc_x * 8, height / 2 + osc_y * 8, 1 + i + osc_x);
		noFill();
		ellipse(width / 2 /*+ osc_x * 8*/, height / 2/* + osc_y * 6*/, 1 + i / 4 + osc_x, 1 + i / 4 - osc_y);
	}
	
	xmotion += 0.05;
	ymotion += 0.008;
	
	rxmotion += 0.05;
	rymotion += 0;
	rzmotion += 0;
}

void setup() {
  size(400, 400);

  frameRate(60); 

  background(0);
}

void draw() {
  //background(0);

  draw_func();
}"
"579071","Glitch space","mySketch","/**
  * Composition which begun with Andres circle drawing algorithm for fun and ended with regular shapes. :)
	*/

void andres_circle(int x_centre, int y_centre, int r) {
	int x = 0;
	int y = r;
	int d = r - 1;
	
	while (y >= x) {
		//float norm_r = abs(0.5 - y / r);
		
		//float rot_y = cos(norm_r * 360 * (3.1415 / 180) + xmotion) * 32;
		
		rect(x_centre + x, y_centre + y, 1, 1);
		rect(x_centre + y , y_centre + x, 1, 1);
		rect(x_centre - x , y_centre + y, 1, 1);
		rect(x_centre - y , y_centre + x, 1, 1);
		rect(x_centre + x , y_centre - y, 1, 1);
		rect(x_centre + y , y_centre - x, 1, 1);
		rect(x_centre - x, y_centre - y, 1, 1);
		rect(x_centre - y , y_centre - x, 1, 1);

		if (d >= 2 * x) { 
			d = d - 2 * x - 1;
			x = x + 1;
		} else if (d < 2 * (r - y)) {
			d = d + 2 * y - 1;
			y = y - 1;
		} else { 
			d = d + 2 * (y - x - 1);
			y = y - 1;
			x = x + 1;
		}
	}
}

float xmotion = 0;
float ymotion = 0;

float rxmotion = 0;
float rymotion = 0;
float rzmotion = 0;

void draw_func() {
	noStroke();
	
  fill(0, 0, 0, 2);
  rect(0, 0, width, height);

	//stroke(255, 255, 255, 255);
	
	int lcount = 4;
	
	int rect_size_x = 64;
	int rect_size_y = 64;
	
	int cx = width / rect_size_x;
	int cy = height / rect_size_y;
	
	// background
	for (int i = 0; i < cy; i += 1) {
		float norm_i = abs(0.5 - i / cy);
		for (int j = 0; j < cx; j += 1) {
			float norm_j = (0.5 - abs(0.5 - j / cx)) * 2;//abs(0.5 - j / cx);
			float norm_ij = abs(norm_i - norm_j + random(-1, 1));
			
			fill(0, 0, 0, random(16, 24));
			rect(j * rect_size_x, i * rect_size_y, random(1, rect_size_x), random(1, rect_size_y));
			
			for (int k = 0; k < lcount; k += 1) {
				float norm_k = (0.5 - abs(0.5 - k / lcount)) * 2;
				
				int ly = i * rect_size_y + (rect_size_y / lcount) * k;
				
				float osc_x, osc_y;
				
				if ((k % 2) == 0) {
					osc_x = sin(norm_k * 360 * (3.1415 / 180) + xmotion) * 32;
					osc_y = cos(norm_k * 360 * (3.1415 / 180) - ymotion) * 32;
					
					stroke(255, 0, 255 * norm_i, 255 * norm_i * norm_k);
				} else {
					osc_x = sin(norm_k * 360 * (3.1415 / 180) - xmotion) * 32;
					osc_y = cos(norm_k * 360 * (3.1415 / 180) + ymotion) * 32;
					
					stroke(255 * norm_i, 0, 255, 255 * norm_i * norm_k);
				}
				
				int hcount = 8;
				
				//line(0, ly + osc_y, width, ly - osc_y);
				line(0, ly + osc_y * 8, width, height / 2);
				line(width - 1, ly + osc_y * 8, 0, height / 2);
				//line(ly + osc_x, 0, ly - osc_x, 0);
				//line(ly + osc_x, 0, ly - osc_x, height);
				
				noStroke();
				
				for (int h = 0; h < hcount; h += 1) {
					int xh = h - hcount / 2;
					
					fill(0, 0, 0, 8);
					rect(osc_x + xh * 128, ly + osc_y, 64, 64);
				}
			}
			noStroke();
		}
	}
	
	int centered_rect_size = 256;
	
	// support	
	int tx = width / 2 - centered_rect_size / 2 + 16;
	int ty1 = height / 2 + 132;
	int ty2 = height / 2 + 40 + centered_rect_size / 2;

	fill(0, 0, 0, 255);
	stroke(24, 24, 24, 255);
	triangle(tx, ty1, width - tx, ty1, width / 2, ty2);
	
	fill(0, 0, 0, 255);
	stroke(255, 255, 255, 255);
	triangle(tx, ty1, width / 2, height * 1.5 - ty2, width - tx, ty1);
	//
	
	// center sphere
	stroke(255, 255, 255, 255);
	
	fill(0, 0, 0, 228);
	ellipse(width / 2, height / 2, centered_rect_size, centered_rect_size);
	
	noStroke();
	//
	
	// circles
	int count = 48;
	
	for (int i = 0; i < count; i += 1) {
		float norm_i = i / count;
		
		float norm_i_abs = (0.5 - abs(0.5 - norm_i)) * 2;
		
		float osc_x = sin((norm_i_abs * 360) * (3.1415 / 180) + xmotion / 20) * (centered_rect_size - 32);
		float osc_y = cos((norm_i_abs * 360) * (3.1415 / 180) + ymotion / 20) * (centered_rect_size - 32);
		
		float abs_osc_x = abs(osc_x);
		float abs_osc_y = abs(osc_y);
		
		if (osc_x > 0 && osc_y > 0) {
			fill(norm_i_abs * 255, 255, 255, norm_i_abs * 255);
			stroke(norm_i_abs * 255, 255, 255, norm_i_abs * 255);
		} else if (osc_x > 0 && osc_y < 0) {
			fill(255, norm_i_abs * 255, 255, norm_i_abs * 255);
			stroke(255, norm_i_abs * 255, 255, norm_i_abs * 255);
		} else if (osc_x < 0 && osc_y > 0) {
			fill(255, 255, norm_i_abs * 255, norm_i_abs * 255);
			stroke(255, 255, norm_i_abs * 255, norm_i_abs * 255);
		} else if (osc_x < 0 && osc_y < 0) {
			fill(255, 255, 255, norm_i_abs * 255);
			stroke(255, 255, 255, norm_i_abs * 255);
		}
			
		//andres_circle(width / 2 + osc_x * 8, height / 2 + osc_y * 8, 1 + i + osc_x);
		noFill();
		//ellipse(width / 2 /*+ osc_x * 8*/, height / 2/* + osc_y * 6*/, 1 + i / 4 + osc_x, 1 + i / 4 - osc_y);
		ellipse(width / 2 /*+ osc_x * 8*/, height / 2/* + osc_y * 6*/, 1 + i + osc_x, 1 + i + osc_y);
	}
	
	xmotion += 0.05;
	ymotion += 0.008;
	
	rxmotion += 0.05;
	rymotion += 0;
	rzmotion += 0;
}

void setup() {
  size(400, 400);

  frameRate(60); 

  background(0);
}

void draw() {
  //background(0);

  draw_func();
}"
"579071","Glitch space","mySketch","/**
  * Composition which begun with Andres circle drawing algorithm for fun and ended with regular shapes and a kind of vaporwave aesthetics. :)
	*/

int[] vapor_palette = new int[6 * 3];

void andres_circle(int x_centre, int y_centre, int r) {
	int x = 0;
	int y = r;
	int d = r - 1;
	
	while (y >= x) {
		//float norm_r = abs(0.5 - y / r);
		
		//float rot_y = cos(norm_r * 360 * (3.1415 / 180) + xmotion) * 32;
		
		rect(x_centre + x, y_centre + y, 1, 1);
		rect(x_centre + y , y_centre + x, 1, 1);
		rect(x_centre - x , y_centre + y, 1, 1);
		rect(x_centre - y , y_centre + x, 1, 1);
		rect(x_centre + x , y_centre - y, 1, 1);
		rect(x_centre + y , y_centre - x, 1, 1);
		rect(x_centre - x, y_centre - y, 1, 1);
		rect(x_centre - y , y_centre - x, 1, 1);

		if (d >= 2 * x) { 
			d = d - 2 * x - 1;
			x = x + 1;
		} else if (d < 2 * (r - y)) {
			d = d + 2 * y - 1;
			y = y - 1;
		} else { 
			d = d + 2 * (y - x - 1);
			y = y - 1;
			x = x + 1;
		}
	}
}

float xmotion = 0;
float ymotion = 0;

float rxmotion = 0;
float rymotion = 0;
float rzmotion = 0;

void draw_func() {
	noStroke();
	
  fill(0, 0, 0, 2);
  rect(0, 0, width, height);

	//stroke(255, 255, 255, 255);
	
	int lcount = 4;
	
	int rect_size_x = 64;
	int rect_size_y = 64;
	
	int cx = width / rect_size_x;
	int cy = height / rect_size_y;
	
	// background
	for (int i = 0; i < cy; i += 1) {
		float norm_i = abs(0.5 - i / cy);
		for (int j = 0; j < cx; j += 1) {
			float norm_j = (0.5 - abs(0.5 - j / cx)) * 2;//abs(0.5 - j / cx);
			float norm_ij = abs(norm_i - norm_j + random(-1, 1));
			
			fill(0, 0, 0, random(16, 24));
			rect(j * rect_size_x, i * rect_size_y, random(1, rect_size_x), random(1, rect_size_y));
			
			for (int k = 0; k < lcount; k += 1) {
				float norm_k = (0.5 - abs(0.5 - k / lcount)) * 2;
				
				int ly = i * rect_size_y + (rect_size_y / lcount) * k;
				
				float osc_x, osc_y;
				
				if ((k % 2) == 0) {
					osc_x = sin(norm_k * 360 * (3.1415 / 180) + xmotion) * 32;
					osc_y = cos(norm_k * 360 * (3.1415 / 180) - ymotion) * 32;
					
					stroke(255, 0, 255 * norm_i, 255 * norm_i * norm_k);
				} else {
					osc_x = sin(norm_k * 360 * (3.1415 / 180) - xmotion) * 32;
					osc_y = cos(norm_k * 360 * (3.1415 / 180) + ymotion) * 32;
					
					stroke(255 * norm_i, 0, 255, 255 * norm_i * norm_k);
				}
				
				int hcount = 8;
				
				//line(0, ly + osc_y, width, ly - osc_y);
				line(0, ly + osc_y * 8, width, height / 2);
				line(width - 1, ly + osc_y * 8, 0, height / 2);
				//line(ly + osc_x, 0, ly - osc_x, 0);
				//line(ly + osc_x, 0, ly - osc_x, height);
				
				noStroke();
				
				for (int h = 0; h < hcount; h += 1) {
					int xh = h - hcount / 2;
					
					fill(0, 0, 0, 8);
					rect(osc_x + xh * 128, ly + osc_y, 64, 64);
				}
			}
			noStroke();
		}
	}
	
	int centered_rect_size = 256;
	
	// support	
	int tx = width / 2 - centered_rect_size / 2 + 16;
	int ty1 = height / 2 + 132;
	int ty2 = height / 2 + 40 + centered_rect_size / 2;

	fill(0, 0, 0, 255);
	stroke(24, 24, 24, 255);
	triangle(tx, ty1, width - tx, ty1, width / 2, ty2);
	
	fill(0, 0, 0, 255);
	stroke(255, 255, 255, 255);
	triangle(tx, ty1, width / 2, height * 1.5 - ty2, width - tx, ty1);
	//
	
	// center sphere
	stroke(255, 255, 255, 255);
	
	fill(0, 0, 0, 228);
	ellipse(width / 2, height / 2, centered_rect_size, centered_rect_size);
	
	noStroke();
	//
	
	// circles
	int count = 48;
	
	for (int i = 0; i < count; i += 1) {
		float norm_i = i / count;
		
		float norm_i_abs = (0.5 - abs(0.5 - norm_i)) * 2;
		
		float osc_x = sin((norm_i_abs * 360) * (3.1415 / 180) + xmotion / 20) * (centered_rect_size - 32);
		float osc_y = cos((norm_i_abs * 360) * (3.1415 / 180) + ymotion / 20) * (centered_rect_size - 32);
		
		float abs_osc_x = abs(osc_x);
		float abs_osc_y = abs(osc_y);
		
		if (osc_x > 0 && osc_y > 0) {
			fill(norm_i_abs * 255, 255, 255, norm_i_abs * 255);
			stroke(norm_i_abs * 255, 255, 255, norm_i_abs * 255);
		} else if (osc_x > 0 && osc_y < 0) {
			fill(255, norm_i_abs * 255, 255, norm_i_abs * 255);
			stroke(255, norm_i_abs * 255, 255, norm_i_abs * 255);
		} else if (osc_x < 0 && osc_y > 0) {
			fill(255, 255, norm_i_abs * 255, norm_i_abs * 255);
			stroke(255, 255, norm_i_abs * 255, norm_i_abs * 255);
		} else if (osc_x < 0 && osc_y < 0) {
			fill(255, 255, 255, norm_i_abs * 255);
			stroke(255, 255, 255, norm_i_abs * 255);
		}
			
		//andres_circle(width / 2 + osc_x * 8, height / 2 + osc_y * 8, 1 + i + osc_x);
		noFill();
		//ellipse(width / 2 /*+ osc_x * 8*/, height / 2/* + osc_y * 6*/, 1 + i / 4 + osc_x, 1 + i / 4 - osc_y);
		ellipse(width / 2 /*+ osc_x * 8*/, height / 2/* + osc_y * 6*/, 1 + i + osc_x, 1 + i + osc_y);
	}
	
	fill(24, 16, 75, 255);
	textSize(28);
	text(""Vapor"", width / 2, height / 2 + centered_rect_size / 2 + 28);
	
	xmotion += 0.05;
	ymotion += 0.008;
	
	rxmotion += 0.05;
	rymotion += 0;
	rzmotion += 0;
}

void setup() {
  size(400, 400);

  frameRate(60); 

  background(0);
	
	textAlign(CENTER);
	
	vapor_palette[0] = 24;   vapor_palette[1] = 16;   vapor_palette[2] = 75;
	vapor_palette[3] = 57;   vapor_palette[4] = 39;   vapor_palette[5] = 5;
	vapor_palette[6] = 181;  vapor_palette[7] = 28;   vapor_palette[8] = 204;
	vapor_palette[9] = 218;  vapor_palette[10] = 90;  vapor_palette[11] = 209;
	vapor_palette[12] = 220; vapor_palette[13] = 148; vapor_palette[14] = 186;
	vapor_palette[15] = 242; vapor_palette[16] = 207; vapor_palette[17] = 6;
}

void draw() {
  //background(0);

  draw_func();
}"
"579071","Glitch space","mySketch","/**
  * Composition which begun with Andres circle drawing algorithm for fun and ended with regular shapes and a kind of vaporwave aesthetics. :)
	*/

int[] vapor_palette = new int[6 * 3];

void andres_circle(int x_centre, int y_centre, int r) {
	int x = 0;
	int y = r;
	int d = r - 1;
	
	while (y >= x) {
		//float norm_r = abs(0.5 - y / r);
		
		//float rot_y = cos(norm_r * 360 * (3.1415 / 180) + xmotion) * 32;
		
		rect(x_centre + x, y_centre + y, 1, 1);
		rect(x_centre + y , y_centre + x, 1, 1);
		rect(x_centre - x , y_centre + y, 1, 1);
		rect(x_centre - y , y_centre + x, 1, 1);
		rect(x_centre + x , y_centre - y, 1, 1);
		rect(x_centre + y , y_centre - x, 1, 1);
		rect(x_centre - x, y_centre - y, 1, 1);
		rect(x_centre - y , y_centre - x, 1, 1);

		if (d >= 2 * x) { 
			d = d - 2 * x - 1;
			x = x + 1;
		} else if (d < 2 * (r - y)) {
			d = d + 2 * y - 1;
			y = y - 1;
		} else { 
			d = d + 2 * (y - x - 1);
			y = y - 1;
			x = x + 1;
		}
	}
}

float xmotion = 0;
float ymotion = 0;

float rxmotion = 0;
float rymotion = 0;
float rzmotion = 0;

void draw_func() {
	noStroke();
	
  fill(0, 0, 0, 2);
  rect(0, 0, width, height);

	//stroke(255, 255, 255, 255);
	
	int lcount = 4;
	
	int rect_size_x = 64;
	int rect_size_y = 64;
	
	int cx = width / rect_size_x;
	int cy = height / rect_size_y;
	
	// background
	for (int i = 0; i < cy; i += 1) {
		float norm_i = abs(0.5 - i / cy);
		for (int j = 0; j < cx; j += 1) {
			float norm_j = (0.5 - abs(0.5 - j / cx)) * 2;//abs(0.5 - j / cx);
			float norm_ij = abs(norm_i - norm_j + random(-1, 1));
			
			fill(0, 0, 0, random(16, 24));
			rect(j * rect_size_x, i * rect_size_y, random(1, rect_size_x), random(1, rect_size_y));
			
			for (int k = 0; k < lcount; k += 1) {
				float norm_k = (0.5 - abs(0.5 - k / lcount)) * 2;
				
				int ly = i * rect_size_y + (rect_size_y / lcount) * k;
				
				float osc_x, osc_y;
				
				if ((k % 2) == 0) {
					osc_x = sin(norm_k * 360 * (3.1415 / 180) + xmotion) * 32;
					osc_y = cos(norm_k * 360 * (3.1415 / 180) - ymotion) * 32;
					
					stroke(255, 0, 255 * norm_i, 255 * norm_i * norm_k);
				} else {
					osc_x = sin(norm_k * 360 * (3.1415 / 180) - xmotion) * 32;
					osc_y = cos(norm_k * 360 * (3.1415 / 180) + ymotion) * 32;
					
					stroke(255 * norm_i, 0, 255, 255 * norm_i * norm_k);
				}
				
				int hcount = 8;
				
				//line(0, ly + osc_y, width, ly - osc_y);
				line(0, ly + osc_y * 8, width, height / 2);
				line(width - 1, ly + osc_y * 8, 0, height / 2);
				//line(ly + osc_x, 0, ly - osc_x, 0);
				//line(ly + osc_x, 0, ly - osc_x, height);
				
				noStroke();
				
				for (int h = 0; h < hcount; h += 1) {
					int xh = h - hcount / 2;
					
					fill(0, 0, 0, 8);
					rect(osc_x + xh * 128, ly + osc_y, 64, 64);
				}
			}
			noStroke();
		}
	}
	
	int centered_rect_size = 256;
	
	// support	
	int tx = width / 2 - centered_rect_size / 2 + 16;
	int ty1 = height / 2 + 132;
	int ty2 = height / 2 + 40 + centered_rect_size / 2;

	fill(0, 0, 0, 255);
	stroke(24, 24, 24, 255);
	triangle(tx, ty1, width - tx, ty1, width / 2, ty2);
	
	fill(0, 0, 0, 255);
	stroke(255, 255, 255, 255);
	triangle(tx, ty1, width / 2, height * 1.5 - ty2, width - tx, ty1);
	//
	
	// center sphere
	stroke(255, 255, 255, 255);
	
	fill(0, 0, 0, 228);
	ellipse(width / 2, height / 2, centered_rect_size, centered_rect_size);
	
	noStroke();
	//
	
	// circles
	int count = 48;
	
	for (int i = 0; i < count; i += 1) {
		float norm_i = i / count;
		
		float norm_i_abs = (0.5 - abs(0.5 - norm_i)) * 2;
		
		float osc_x = sin((norm_i_abs * 360) * (3.1415 / 180) + xmotion / 20) * (centered_rect_size - 32);
		float osc_y = cos((norm_i_abs * 360) * (3.1415 / 180) + ymotion / 20) * (centered_rect_size - 32);
		
		float abs_osc_x = abs(osc_x);
		float abs_osc_y = abs(osc_y);
		
		if (osc_x > 0 && osc_y > 0) {
			fill(norm_i_abs * 255, 255, 255, norm_i_abs * 255);
			stroke(norm_i_abs * 255, 255, 255, norm_i_abs * 255);
		} else if (osc_x > 0 && osc_y < 0) {
			fill(255, norm_i_abs * 255, 255, norm_i_abs * 255);
			stroke(255, norm_i_abs * 255, 255, norm_i_abs * 255);
		} else if (osc_x < 0 && osc_y > 0) {
			fill(255, 255, norm_i_abs * 255, norm_i_abs * 255);
			stroke(255, 255, norm_i_abs * 255, norm_i_abs * 255);
		} else if (osc_x < 0 && osc_y < 0) {
			fill(255, 255, 255, norm_i_abs * 255);
			stroke(255, 255, 255, norm_i_abs * 255);
		}
			
		//andres_circle(width / 2 + osc_x * 8, height / 2 + osc_y * 8, 1 + i + osc_x);
		noFill();
		//ellipse(width / 2 /*+ osc_x * 8*/, height / 2/* + osc_y * 6*/, 1 + i / 4 + osc_x, 1 + i / 4 - osc_y);
		ellipse(width / 2 /*+ osc_x * 8*/, height / 2/* + osc_y * 6*/, 1 + i + osc_x, 1 + i + osc_y);
	}
	
	fill(255, 255, 255, 255);
	textSize(42);
	text(""Vapor"", width / 2, height / 2 + centered_rect_size / 2 + 64);
	
	xmotion += 0.05;
	ymotion += 0.008;
	
	rxmotion += 0.05;
	rymotion += 0;
	rzmotion += 0;
}

void setup() {
  size(400, 400);

  frameRate(60); 

  background(0);
	
	textAlign(CENTER);
	
	vapor_palette[0] = 24;   vapor_palette[1] = 16;   vapor_palette[2] = 75;
	vapor_palette[3] = 57;   vapor_palette[4] = 39;   vapor_palette[5] = 5;
	vapor_palette[6] = 181;  vapor_palette[7] = 28;   vapor_palette[8] = 204;
	vapor_palette[9] = 218;  vapor_palette[10] = 90;  vapor_palette[11] = 209;
	vapor_palette[12] = 220; vapor_palette[13] = 148; vapor_palette[14] = 186;
	vapor_palette[15] = 242; vapor_palette[16] = 207; vapor_palette[17] = 6;
}

void draw() {
  //background(0);

  draw_func();
}"
"579071","Glitch space","mySketch","/**
  * Composition which begun with Andres circle drawing algorithm for fun and ended with regular shapes and a kind of vaporwave aesthetics. :)
	*/

int[] vapor_palette = new int[6 * 3];

void andres_circle(int x_centre, int y_centre, int r) {
	int x = 0;
	int y = r;
	int d = r - 1;
	
	while (y >= x) {
		//float norm_r = abs(0.5 - y / r);
		
		//float rot_y = cos(norm_r * 360 * (3.1415 / 180) + xmotion) * 32;
		
		rect(x_centre + x, y_centre + y, 1, 1);
		rect(x_centre + y , y_centre + x, 1, 1);
		rect(x_centre - x , y_centre + y, 1, 1);
		rect(x_centre - y , y_centre + x, 1, 1);
		rect(x_centre + x , y_centre - y, 1, 1);
		rect(x_centre + y , y_centre - x, 1, 1);
		rect(x_centre - x, y_centre - y, 1, 1);
		rect(x_centre - y , y_centre - x, 1, 1);

		if (d >= 2 * x) { 
			d = d - 2 * x - 1;
			x = x + 1;
		} else if (d < 2 * (r - y)) {
			d = d + 2 * y - 1;
			y = y - 1;
		} else { 
			d = d + 2 * (y - x - 1);
			y = y - 1;
			x = x + 1;
		}
	}
}

float xmotion = 0;
float ymotion = 0;

float rxmotion = 0;
float rymotion = 0;
float rzmotion = 0;

void draw_func() {
	noStroke();
	
  fill(0, 0, 0, 2);
  rect(0, 0, width, height);

	//stroke(255, 255, 255, 255);
	
	int lcount = 4;
	
	int rect_size_x = 64;
	int rect_size_y = 64;
	
	int cx = width / rect_size_x;
	int cy = height / rect_size_y;
	
	// background
	for (int i = 0; i < cy; i += 1) {
		float norm_i = abs(0.5 - i / cy);
		for (int j = 0; j < cx; j += 1) {
			float norm_j = (0.5 - abs(0.5 - j / cx)) * 2;//abs(0.5 - j / cx);
			float norm_ij = abs(norm_i - norm_j + random(-1, 1));
			
			fill(0, 0, 0, random(16, 24));
			rect(j * rect_size_x, i * rect_size_y, random(1, rect_size_x), random(1, rect_size_y));
			
			for (int k = 0; k < lcount; k += 1) {
				float norm_k = (0.5 - abs(0.5 - k / lcount)) * 2;
				
				int ly = i * rect_size_y + (rect_size_y / lcount) * k;
				
				float osc_x, osc_y;
				
				if ((k % 2) == 0) {
					osc_x = sin(norm_k * 360 * (3.1415 / 180) + xmotion) * 32;
					osc_y = cos(norm_k * 360 * (3.1415 / 180) - ymotion) * 32;
					
					stroke(255, 0, 255 * norm_i, 255 * norm_i * norm_k);
				} else {
					osc_x = sin(norm_k * 360 * (3.1415 / 180) - xmotion) * 32;
					osc_y = cos(norm_k * 360 * (3.1415 / 180) + ymotion) * 32;
					
					stroke(255 * norm_i, 0, 255, 255 * norm_i * norm_k);
				}
				
				int hcount = 8;
				
				//line(0, ly + osc_y, width, ly - osc_y);
				line(0, ly + osc_y * 8, width, height / 2);
				line(width - 1, ly + osc_y * 8, 0, height / 2);
				//line(ly + osc_x, 0, ly - osc_x, 0);
				//line(ly + osc_x, 0, ly - osc_x, height);
				
				noStroke();
				
				for (int h = 0; h < hcount; h += 1) {
					int xh = h - hcount / 2;
					
					fill(0, 0, 0, 8);
					rect(osc_x + xh * 128, ly + osc_y, 64, 64);
				}
			}
			noStroke();
		}
	}
	
	int centered_rect_size = 256;
	
	// support	
	int tx = width / 2 - centered_rect_size / 2 + 16;
	int ty1 = height / 2 + 132;
	int ty2 = height / 2 + 40 + centered_rect_size / 2;

	fill(0, 0, 0, 255);
	stroke(24, 24, 24, 255);
	triangle(tx, ty1, width - tx, ty1, width / 2, ty2);
	
	fill(0, 0, 0, 255);
	stroke(255, 255, 255, 255);
	triangle(tx, ty1, width / 2, height * 1.5 - ty2, width - tx, ty1);
	//
	
	// center sphere
	stroke(255, 255, 255, 255);
	
	fill(0, 0, 0, 228);
	ellipse(width / 2, height / 2, centered_rect_size, centered_rect_size);
	
	noStroke();
	//
	
	// circles
	int count = 48;
	
	for (int i = 0; i < count; i += 1) {
		float norm_i = i / count;
		
		float norm_i_abs = (0.5 - abs(0.5 - norm_i)) * 2;
		
		float osc_x = sin((norm_i_abs * 360) * (3.1415 / 180) + xmotion / 20) * (centered_rect_size - 32);
		float osc_y = cos((norm_i_abs * 360) * (3.1415 / 180) + ymotion / 20) * (centered_rect_size - 32);
		
		float abs_osc_x = abs(osc_x);
		float abs_osc_y = abs(osc_y);
		
		if (osc_x > 0 && osc_y > 0) {
			fill(norm_i_abs * 255, 255, 255, norm_i_abs * 255);
			stroke(norm_i_abs * 255, 255, 255, norm_i_abs * 255);
		} else if (osc_x > 0 && osc_y < 0) {
			fill(255, norm_i_abs * 255, 255, norm_i_abs * 255);
			stroke(255, norm_i_abs * 255, 255, norm_i_abs * 255);
		} else if (osc_x < 0 && osc_y > 0) {
			fill(255, 255, norm_i_abs * 255, norm_i_abs * 255);
			stroke(255, 255, norm_i_abs * 255, norm_i_abs * 255);
		} else if (osc_x < 0 && osc_y < 0) {
			fill(255, 255, 255, norm_i_abs * 255);
			stroke(255, 255, 255, norm_i_abs * 255);
		}
			
		//andres_circle(width / 2 + osc_x * 8, height / 2 + osc_y * 8, 1 + i + osc_x);
		noFill();
		//ellipse(width / 2 /*+ osc_x * 8*/, height / 2/* + osc_y * 6*/, 1 + i / 4 + osc_x, 1 + i / 4 - osc_y);
		ellipse(width / 2 /*+ osc_x * 8*/, height / 2/* + osc_y * 6*/, 1 + i + osc_x, 1 + i + osc_y);
	}
	
	int text_y = height / 2 + centered_rect_size / 2 + 64;
	
	fill(255, 255, 255, 255);
	textSize(42);
	text(""Vapor"", width / 2, text_y);
	
	float vapor_width = textWidth(""Vapor"");
	
	int off_x = width / 2 - vaport_width / 2;
	int off_y = text_y;
	
	noStroke();
	
	loadPixels();
	for (int x = 0; x < vapor_width; x += 4) {
		for (int y = 0; y < 42; y += 4) {
			color p = pixels[(y + off_y) * width + (x + off_x)];
			
			if (red(p) == 255) {
					int c = random(0, 6);
					fill(vapor_palette[c], vapor_palette[c + 1], vapor_palette[c + 2], 32);
					rect(x + off_x, y + off_y, 4, 4);
			}
		}
	}
	//updatePixels();
	
	xmotion += 0.05;
	ymotion += 0.008;
	
	rxmotion += 0.05;
	rymotion += 0;
	rzmotion += 0;
}

void setup() {
  size(400, 400);

  frameRate(60); 

  background(0);
	
	textAlign(CENTER);
	
	vapor_palette[0] = 24;   vapor_palette[1] = 16;   vapor_palette[2] = 75;
	vapor_palette[3] = 57;   vapor_palette[4] = 39;   vapor_palette[5] = 5;
	vapor_palette[6] = 181;  vapor_palette[7] = 28;   vapor_palette[8] = 204;
	vapor_palette[9] = 218;  vapor_palette[10] = 90;  vapor_palette[11] = 209;
	vapor_palette[12] = 220; vapor_palette[13] = 148; vapor_palette[14] = 186;
	vapor_palette[15] = 242; vapor_palette[16] = 207; vapor_palette[17] = 6;
}

void draw() {
  //background(0);

  draw_func();
}"
"579071","Glitch space","mySketch","/**
  * Composition which begun with Andres circle drawing algorithm for fun and ended with regular shapes and a kind of vaporwave aesthetics. :)
	*/

int[] vapor_palette = new int[6 * 3];

void andres_circle(int x_centre, int y_centre, int r) {
	int x = 0;
	int y = r;
	int d = r - 1;
	
	while (y >= x) {
		//float norm_r = abs(0.5 - y / r);
		
		//float rot_y = cos(norm_r * 360 * (3.1415 / 180) + xmotion) * 32;
		
		rect(x_centre + x, y_centre + y, 1, 1);
		rect(x_centre + y , y_centre + x, 1, 1);
		rect(x_centre - x , y_centre + y, 1, 1);
		rect(x_centre - y , y_centre + x, 1, 1);
		rect(x_centre + x , y_centre - y, 1, 1);
		rect(x_centre + y , y_centre - x, 1, 1);
		rect(x_centre - x, y_centre - y, 1, 1);
		rect(x_centre - y , y_centre - x, 1, 1);

		if (d >= 2 * x) { 
			d = d - 2 * x - 1;
			x = x + 1;
		} else if (d < 2 * (r - y)) {
			d = d + 2 * y - 1;
			y = y - 1;
		} else { 
			d = d + 2 * (y - x - 1);
			y = y - 1;
			x = x + 1;
		}
	}
}

float xmotion = 0;
float ymotion = 0;

float rxmotion = 0;
float rymotion = 0;
float rzmotion = 0;

void draw_func() {
	noStroke();
	
  fill(0, 0, 0, 2);
  rect(0, 0, width, height);

	//stroke(255, 255, 255, 255);
	
	int lcount = 4;
	
	int rect_size_x = 64;
	int rect_size_y = 64;
	
	int cx = width / rect_size_x;
	int cy = height / rect_size_y;
	
	// background
	for (int i = 0; i < cy; i += 1) {
		float norm_i = abs(0.5 - i / cy);
		for (int j = 0; j < cx; j += 1) {
			float norm_j = (0.5 - abs(0.5 - j / cx)) * 2;//abs(0.5 - j / cx);
			float norm_ij = abs(norm_i - norm_j + random(-1, 1));
			
			fill(0, 0, 0, random(16, 24));
			rect(j * rect_size_x, i * rect_size_y, random(1, rect_size_x), random(1, rect_size_y));
			
			for (int k = 0; k < lcount; k += 1) {
				float norm_k = (0.5 - abs(0.5 - k / lcount)) * 2;
				
				int ly = i * rect_size_y + (rect_size_y / lcount) * k;
				
				float osc_x, osc_y;
				
				if ((k % 2) == 0) {
					osc_x = sin(norm_k * 360 * (3.1415 / 180) + xmotion) * 32;
					osc_y = cos(norm_k * 360 * (3.1415 / 180) - ymotion) * 32;
					
					stroke(255, 0, 255 * norm_i, 255 * norm_i * norm_k);
				} else {
					osc_x = sin(norm_k * 360 * (3.1415 / 180) - xmotion) * 32;
					osc_y = cos(norm_k * 360 * (3.1415 / 180) + ymotion) * 32;
					
					stroke(255 * norm_i, 0, 255, 255 * norm_i * norm_k);
				}
				
				int hcount = 8;
				
				//line(0, ly + osc_y, width, ly - osc_y);
				line(0, ly + osc_y * 8, width, height / 2);
				line(width - 1, ly + osc_y * 8, 0, height / 2);
				//line(ly + osc_x, 0, ly - osc_x, 0);
				//line(ly + osc_x, 0, ly - osc_x, height);
				
				noStroke();
				
				for (int h = 0; h < hcount; h += 1) {
					int xh = h - hcount / 2;
					
					fill(0, 0, 0, 8);
					rect(osc_x + xh * 128, ly + osc_y, 64, 64);
				}
			}
			noStroke();
		}
	}
	
	int centered_rect_size = 256;
	
	// support	
	int tx = width / 2 - centered_rect_size / 2 + 16;
	int ty1 = height / 2 + 132;
	int ty2 = height / 2 + 40 + centered_rect_size / 2;

	fill(0, 0, 0, 255);
	stroke(24, 24, 24, 255);
	triangle(tx, ty1, width - tx, ty1, width / 2, ty2);
	
	fill(0, 0, 0, 255);
	stroke(255, 255, 255, 255);
	triangle(tx, ty1, width / 2, height * 1.5 - ty2, width - tx, ty1);
	//
	
	// center sphere
	stroke(255, 255, 255, 255);
	
	fill(0, 0, 0, 228);
	ellipse(width / 2, height / 2, centered_rect_size, centered_rect_size);
	
	noStroke();
	//
	
	// circles
	int count = 48;
	
	for (int i = 0; i < count; i += 1) {
		float norm_i = i / count;
		
		float norm_i_abs = (0.5 - abs(0.5 - norm_i)) * 2;
		
		float osc_x = sin((norm_i_abs * 360) * (3.1415 / 180) + xmotion / 20) * (centered_rect_size - 32);
		float osc_y = cos((norm_i_abs * 360) * (3.1415 / 180) + ymotion / 20) * (centered_rect_size - 32);
		
		float abs_osc_x = abs(osc_x);
		float abs_osc_y = abs(osc_y);
		
		if (osc_x > 0 && osc_y > 0) {
			fill(norm_i_abs * 255, 255, 255, norm_i_abs * 255);
			stroke(norm_i_abs * 255, 255, 255, norm_i_abs * 255);
		} else if (osc_x > 0 && osc_y < 0) {
			fill(255, norm_i_abs * 255, 255, norm_i_abs * 255);
			stroke(255, norm_i_abs * 255, 255, norm_i_abs * 255);
		} else if (osc_x < 0 && osc_y > 0) {
			fill(255, 255, norm_i_abs * 255, norm_i_abs * 255);
			stroke(255, 255, norm_i_abs * 255, norm_i_abs * 255);
		} else if (osc_x < 0 && osc_y < 0) {
			fill(255, 255, 255, norm_i_abs * 255);
			stroke(255, 255, 255, norm_i_abs * 255);
		}
			
		//andres_circle(width / 2 + osc_x * 8, height / 2 + osc_y * 8, 1 + i + osc_x);
		noFill();
		//ellipse(width / 2 /*+ osc_x * 8*/, height / 2/* + osc_y * 6*/, 1 + i / 4 + osc_x, 1 + i / 4 - osc_y);
		ellipse(width / 2 /*+ osc_x * 8*/, height / 2/* + osc_y * 6*/, 1 + i + osc_x, 1 + i + osc_y);
	}
	
	int text_y = height / 2 + centered_rect_size / 2 + 64;
	
	fill(255, 255, 255, 255);
	textSize(42);
	text(""Vapor"", width / 2, text_y);
	
	float vapor_width = textWidth(""Vapor"");
	
	int off_x = width / 2 - vapor_width / 2;
	int off_y = text_y;
	
	noStroke();
	
	loadPixels();
	for (int x = 0; x < vapor_width; x += 4) {
		for (int y = 0; y < 42; y += 4) {
			color p = pixels[(y + off_y) * width + (x + off_x)];
			
			if (red(p) == 255) {
					int c = random(0, 6);
					fill(vapor_palette[c], vapor_palette[c + 1], vapor_palette[c + 2], 32);
					rect(x + off_x, y + off_y, 4, 4);
			}
		}
	}
	//updatePixels();
	
	xmotion += 0.05;
	ymotion += 0.008;
	
	rxmotion += 0.05;
	rymotion += 0;
	rzmotion += 0;
}

void setup() {
  size(400, 400);

  frameRate(60); 

  background(0);
	
	textAlign(CENTER);
	
	vapor_palette[0] = 24;   vapor_palette[1] = 16;   vapor_palette[2] = 75;
	vapor_palette[3] = 57;   vapor_palette[4] = 39;   vapor_palette[5] = 5;
	vapor_palette[6] = 181;  vapor_palette[7] = 28;   vapor_palette[8] = 204;
	vapor_palette[9] = 218;  vapor_palette[10] = 90;  vapor_palette[11] = 209;
	vapor_palette[12] = 220; vapor_palette[13] = 148; vapor_palette[14] = 186;
	vapor_palette[15] = 242; vapor_palette[16] = 207; vapor_palette[17] = 6;
}

void draw() {
  //background(0);

  draw_func();
}"
"579071","Glitch space","mySketch","/**
  * Composition which begun with Andres circle drawing algorithm for fun and ended with regular shapes and a kind of vaporwave aesthetics. :)
	*/

void andres_circle(int x_centre, int y_centre, int r) {
	int x = 0;
	int y = r;
	int d = r - 1;
	
	while (y >= x) {
		//float norm_r = abs(0.5 - y / r);
		
		//float rot_y = cos(norm_r * 360 * (3.1415 / 180) + xmotion) * 32;
		
		rect(x_centre + x, y_centre + y, 1, 1);
		rect(x_centre + y , y_centre + x, 1, 1);
		rect(x_centre - x , y_centre + y, 1, 1);
		rect(x_centre - y , y_centre + x, 1, 1);
		rect(x_centre + x , y_centre - y, 1, 1);
		rect(x_centre + y , y_centre - x, 1, 1);
		rect(x_centre - x, y_centre - y, 1, 1);
		rect(x_centre - y , y_centre - x, 1, 1);

		if (d >= 2 * x) { 
			d = d - 2 * x - 1;
			x = x + 1;
		} else if (d < 2 * (r - y)) {
			d = d + 2 * y - 1;
			y = y - 1;
		} else { 
			d = d + 2 * (y - x - 1);
			y = y - 1;
			x = x + 1;
		}
	}
}

float xmotion = 0;
float ymotion = 0;

float rxmotion = 0;
float rymotion = 0;
float rzmotion = 0;

void draw_func() {
	noStroke();
	
  fill(0, 0, 0, 2);
  rect(0, 0, width, height);

	//stroke(255, 255, 255, 255);
	
	int lcount = 4;
	
	int rect_size_x = 64;
	int rect_size_y = 64;
	
	int cx = width / rect_size_x;
	int cy = height / rect_size_y;
	
	// background
	for (int i = 0; i < cy; i += 1) {
		float norm_i = abs(0.5 - i / cy);
		for (int j = 0; j < cx; j += 1) {
			float norm_j = (0.5 - abs(0.5 - j / cx)) * 2;//abs(0.5 - j / cx);
			float norm_ij = abs(norm_i - norm_j + random(-1, 1));
			
			fill(0, 0, 0, random(16, 24));
			rect(j * rect_size_x, i * rect_size_y, random(1, rect_size_x), random(1, rect_size_y));
			
			for (int k = 0; k < lcount; k += 1) {
				float norm_k = (0.5 - abs(0.5 - k / lcount)) * 2;
				
				int ly = i * rect_size_y + (rect_size_y / lcount) * k;
				
				float osc_x, osc_y;
				
				if ((k % 2) == 0) {
					osc_x = sin(norm_k * 360 * (3.1415 / 180) + xmotion) * 32;
					osc_y = cos(norm_k * 360 * (3.1415 / 180) - ymotion) * 32;
					
					stroke(255, 0, 255 * norm_i, 255 * norm_i * norm_k);
				} else {
					osc_x = sin(norm_k * 360 * (3.1415 / 180) - xmotion) * 32;
					osc_y = cos(norm_k * 360 * (3.1415 / 180) + ymotion) * 32;
					
					stroke(255 * norm_i, 0, 255, 255 * norm_i * norm_k);
				}
				
				int hcount = 8;
				
				//line(0, ly + osc_y, width, ly - osc_y);
				line(0, ly + osc_y * 8, width, height / 2);
				line(width - 1, ly + osc_y * 8, 0, height / 2);
				//line(ly + osc_x, 0, ly - osc_x, 0);
				//line(ly + osc_x, 0, ly - osc_x, height);
				
				noStroke();
				
				for (int h = 0; h < hcount; h += 1) {
					int xh = h - hcount / 2;
					
					fill(0, 0, 0, 8);
					rect(osc_x + xh * 128, ly + osc_y, 64, 64);
				}
			}
			noStroke();
		}
	}
	
	int centered_rect_size = 256;
	
	// support	
	int tx = width / 2 - centered_rect_size / 2 + 16;
	int ty1 = height / 2 + 132;
	int ty2 = height / 2 + 40 + centered_rect_size / 2;

	fill(0, 0, 0, 255);
	stroke(24, 24, 24, 255);
	triangle(tx, ty1, width - tx, ty1, width / 2, ty2);
	
	fill(0, 0, 0, 255);
	stroke(255, 255, 255, 255);
	triangle(tx, ty1, width / 2, height * 1.5 - ty2, width - tx, ty1);
	//
	
	// center sphere
	stroke(255, 255, 255, 255);
	
	fill(0, 0, 0, 228);
	ellipse(width / 2, height / 2, centered_rect_size, centered_rect_size);
	
	noStroke();
	//
	
	// circles
	int count = 48;
	
	for (int i = 0; i < count; i += 1) {
		float norm_i = i / count;
		
		float norm_i_abs = (0.5 - abs(0.5 - norm_i)) * 2;
		
		float osc_x = sin((norm_i_abs * 360) * (3.1415 / 180) + xmotion / 20) * (centered_rect_size - 32);
		float osc_y = cos((norm_i_abs * 360) * (3.1415 / 180) + ymotion / 20) * (centered_rect_size - 32);
		
		float abs_osc_x = abs(osc_x);
		float abs_osc_y = abs(osc_y);
		
		if (osc_x > 0 && osc_y > 0) {
			fill(norm_i_abs * 255, 255, 255, norm_i_abs * 255);
			stroke(norm_i_abs * 255, 255, 255, norm_i_abs * 255);
		} else if (osc_x > 0 && osc_y < 0) {
			fill(255, norm_i_abs * 255, 255, norm_i_abs * 255);
			stroke(255, norm_i_abs * 255, 255, norm_i_abs * 255);
		} else if (osc_x < 0 && osc_y > 0) {
			fill(255, 255, norm_i_abs * 255, norm_i_abs * 255);
			stroke(255, 255, norm_i_abs * 255, norm_i_abs * 255);
		} else if (osc_x < 0 && osc_y < 0) {
			fill(255, 255, 255, norm_i_abs * 255);
			stroke(255, 255, 255, norm_i_abs * 255);
		}
			
		//andres_circle(width / 2 + osc_x * 8, height / 2 + osc_y * 8, 1 + i + osc_x);
		noFill();
		//ellipse(width / 2 /*+ osc_x * 8*/, height / 2/* + osc_y * 6*/, 1 + i / 4 + osc_x, 1 + i / 4 - osc_y);
		ellipse(width / 2 /*+ osc_x * 8*/, height / 2/* + osc_y * 6*/, 1 + i + osc_x, 1 + i + osc_y);
	}
	
	xmotion += 0.05;
	ymotion += 0.008;
	
	rxmotion += 0.05;
	rymotion += 0;
	rzmotion += 0;
}

void setup() {
  size(400, 400);

  frameRate(60); 

  background(0);
}

void draw() {
  //background(0);

  draw_func();
}"
"579071","Glitch space","mySketch","/**
  * Composition which begun with Andres circle drawing algorithm for fun and ended with regular shapes and a kind of vaporwave aesthetics. :)
	*/

void andres_circle(int x_centre, int y_centre, int r) {
	int x = 0;
	int y = r;
	int d = r - 1;
	
	while (y >= x) {
		//float norm_r = abs(0.5 - y / r);
		
		//float rot_y = cos(norm_r * 360 * (3.1415 / 180) + xmotion) * 32;
		
		rect(x_centre + x, y_centre + y, 1, 1);
		rect(x_centre + y , y_centre + x, 1, 1);
		rect(x_centre - x , y_centre + y, 1, 1);
		rect(x_centre - y , y_centre + x, 1, 1);
		rect(x_centre + x , y_centre - y, 1, 1);
		rect(x_centre + y , y_centre - x, 1, 1);
		rect(x_centre - x, y_centre - y, 1, 1);
		rect(x_centre - y , y_centre - x, 1, 1);

		if (d >= 2 * x) { 
			d = d - 2 * x - 1;
			x = x + 1;
		} else if (d < 2 * (r - y)) {
			d = d + 2 * y - 1;
			y = y - 1;
		} else { 
			d = d + 2 * (y - x - 1);
			y = y - 1;
			x = x + 1;
		}
	}
}

float xmotion = 0;
float ymotion = 0;

float rxmotion = 0;
float rymotion = 0;
float rzmotion = 0;

void draw_func() {
	noStroke();
	
  fill(0, 0, 0, 2);
  rect(0, 0, width, height);

	//stroke(255, 255, 255, 255);
	
	int lcount = 4;
	
	int rect_size_x = 64;
	int rect_size_y = 64;
	
	int cx = width / rect_size_x;
	int cy = height / rect_size_y;
	
	// background
	for (int i = 0; i < cy; i += 1) {
		float norm_i = abs(0.5 - i / cy);
		for (int j = 0; j < cx; j += 1) {
			float norm_j = (0.5 - abs(0.5 - j / cx)) * 2;//abs(0.5 - j / cx);
			float norm_ij = abs(norm_i - norm_j + random(-1, 1));
			
			fill(0, 0, 0, random(16, 24));
			rect(j * rect_size_x, i * rect_size_y, random(1, rect_size_x), random(1, rect_size_y));
			
			for (int k = 0; k < lcount; k += 1) {
				float norm_k = (0.5 - abs(0.5 - k / lcount)) * 2;
				
				int ly = i * rect_size_y + (rect_size_y / lcount) * k;
				
				float osc_x, osc_y;
				
				if ((k % 2) == 0) {
					osc_x = sin(norm_k * 360 * (3.1415 / 180) + xmotion) * 32;
					osc_y = cos(norm_k * 360 * (3.1415 / 180) - ymotion) * 32;
					
					stroke(255, 0, 255 * norm_i, 255 * norm_i * norm_k);
				} else {
					osc_x = sin(norm_k * 360 * (3.1415 / 180) - xmotion) * 32;
					osc_y = cos(norm_k * 360 * (3.1415 / 180) + ymotion) * 32;
					
					stroke(255 * norm_i, 0, 255, 255 * norm_i * norm_k);
				}
				
				int hcount = 8;
				
				//line(0, ly + osc_y, width, ly - osc_y);
				line(0, ly + osc_y * 8, width, height / 2);
				line(width - 1, ly + osc_y * 8, 0, height / 2);
				//line(ly + osc_x, 0, ly - osc_x, 0);
				//line(ly + osc_x, 0, ly - osc_x, height);
				
				noStroke();
				
				for (int h = 0; h < hcount; h += 1) {
					int xh = h - hcount / 2;
					
					fill(0, 0, 0, 8);
					rect(osc_x + xh * 128, ly + osc_y, 64, 64);
				}
			}
			noStroke();
		}
	}
	
	int centered_rect_size = 256;
	
	// support	
	int tx = width / 2 - centered_rect_size / 2 + 16;
	int ty1 = height / 2 + 132;
	int ty2 = height / 2 + 40 + centered_rect_size / 2;

	fill(0, 0, 0, 255);
	stroke(24, 24, 24, 255);
	triangle(tx, ty1, width - tx, ty1, width / 2, ty2);
	
	fill(0, 0, 0, 255);
	stroke(255, 255, 255, 255);
	triangle(tx, ty1, width / 2, height * 1.5 - ty2, width - tx, ty1);
	//
	
	// center sphere 
	stroke(255, 255, 255, 255);
	
	fill(0, 0, 0, 228);
	ellipse(width / 2, height / 2, centered_rect_size, centered_rect_size);
	
	noStroke();
	//
	
	// circles
	int count = 48;
	
	for (int i = 0; i < count; i += 1) {
		float norm_i = i / count;
		
		float norm_i_abs = (0.5 - abs(0.5 - norm_i)) * 2;
		
		float osc_x = sin((norm_i_abs * 360) * (3.1415 / 180) + xmotion / 20) * (centered_rect_size - 42);
		float osc_y = cos((norm_i_abs * 360) * (3.1415 / 180) + ymotion / 20) * (centered_rect_size - 42);
		
		/*
		float abs_osc_x = abs(osc_x);
		float abs_osc_y = abs(osc_y);
		
		if (osc_x > 0 && osc_y > 0) {
			fill(norm_i_abs * 255, 255, 255, norm_i_abs * 255);
			stroke(norm_i_abs * 255, 255, 255, norm_i_abs * 255);
		} else if (osc_x > 0 && osc_y < 0) {
			fill(255, norm_i_abs * 255, 255, norm_i_abs * 255);
			stroke(255, norm_i_abs * 255, 255, norm_i_abs * 255);
		} else if (osc_x < 0 && osc_y > 0) {
			fill(255, 255, norm_i_abs * 255, norm_i_abs * 255);
			stroke(255, 255, norm_i_abs * 255, norm_i_abs * 255);
		} else if (osc_x < 0 && osc_y < 0) {
			fill(255, 255, 255, norm_i_abs * 255);
			stroke(255, 255, 255, norm_i_abs * 255);
		}
		*/
		
		stroke(255, 255, 255, norm_i_abs * 16);
		fill(255, 255, 255, norm_i_abs * 32);
			
		//andres_circle(width / 2 + osc_x * 8, height / 2 + osc_y * 8, 1 + i + osc_x);
		//noFill();
		//ellipse(width / 2 /*+ osc_x * 8*/, height / 2/* + osc_y * 6*/, 1 + i / 4 + osc_x, 1 + i / 4 - osc_y);
		ellipse(width / 2 /*+ osc_x * 8*/, height / 2/* + osc_y * 6*/, 1 + i + osc_x, 1 + i + osc_y);
	}
	
	xmotion += 0.05;
	ymotion += 0.008;
	
	rxmotion += 0.05;
	rymotion += 0;
	rzmotion += 0;
}

void setup() {
  size(400, 400);

  frameRate(60); 

  background(0);
	
	smooth();
}

void draw() {
  //background(0);

  draw_func();
}"
"579071","Glitch space","mySketch","/**
  * Composition which begun with Andres circle drawing algorithm for fun and ended with regular shapes and a kind of vaporwave aesthetics. :)
	*/

void andres_circle(int x_centre, int y_centre, int r) {
	int x = 0;
	int y = r;
	int d = r - 1;
	
	while (y >= x) {
		//float norm_r = abs(0.5 - y / r);
		
		//float rot_y = cos(norm_r * 360 * (3.1415 / 180) + xmotion) * 32;
		
		rect(x_centre + x, y_centre + y, 1, 1);
		rect(x_centre + y , y_centre + x, 1, 1);
		rect(x_centre - x , y_centre + y, 1, 1);
		rect(x_centre - y , y_centre + x, 1, 1);
		rect(x_centre + x , y_centre - y, 1, 1);
		rect(x_centre + y , y_centre - x, 1, 1);
		rect(x_centre - x, y_centre - y, 1, 1);
		rect(x_centre - y , y_centre - x, 1, 1);

		if (d >= 2 * x) { 
			d = d - 2 * x - 1;
			x = x + 1;
		} else if (d < 2 * (r - y)) {
			d = d + 2 * y - 1;
			y = y - 1;
		} else { 
			d = d + 2 * (y - x - 1);
			y = y - 1;
			x = x + 1;
		}
	}
}

float xmotion = 4.8;
float ymotion = 2.2;

float rxmotion = 0;
float rymotion = 0;
float rzmotion = 0;

int center_sphere_stroke_weight = 1;
int new_center_sphere_stroke_weight = random(24);
int frame_switch_stroke = 12;

int frame = 0;

void draw_func() {
	noStroke();
	
  fill(0, 0, 0, 2);
  rect(0, 0, width, height);

	//stroke(255, 255, 255, 255);
	
	int lcount = 4;
	
	int rect_size_x = 64;
	int rect_size_y = 48;
	
	int cx = width / rect_size_x;
	int cy = height / rect_size_y;
	
	// background
	for (int i = 0; i < cy; i += 1) {
		float norm_i = abs(0.5 - i / cy);
		for (int j = 0; j < cx; j += 1) {
			float norm_j = (0.5 - abs(0.5 - j / cx)) * 2;//abs(0.5 - j / cx);
			float norm_ij = abs(norm_i - norm_j + random(-1, 1));
			
			fill(0, 0, 0, random(16, 24));
			rect(j * rect_size_x, i * rect_size_y, random(1, rect_size_x), random(1, rect_size_y));
			
			for (int k = 0; k < lcount; k += 1) {
				float norm_k = (0.5 - abs(0.5 - k / lcount)) * 2;
				
				int ly = i * rect_size_y + (rect_size_y / lcount) * k;
				
				float osc_x, osc_y;
				
				if ((k % 2) == 0) {
					osc_x = sin(norm_k * 360 * (3.1415 / 180) + xmotion) * 32;
					osc_y = cos(norm_k * 360 * (3.1415 / 180) - ymotion) * 32;
					
					stroke(255, 0, 255 * norm_i, 255 * norm_i * norm_k);
				} else {
					osc_x = sin(norm_k * 360 * (3.1415 / 180) - xmotion) * 32;
					osc_y = cos(norm_k * 360 * (3.1415 / 180) + ymotion) * 32;
					
					stroke(255 * norm_i, 0, 255, 255 * norm_i * norm_k);
				}
				
				int hcount = 8;
				
				//line(0, ly + osc_y, width, ly - osc_y);
				line(0, ly + osc_y * 8, width, height / 2);
				line(width - 1, ly + osc_y * 8, 0, height / 2);
				//line(ly + osc_x, 0, ly - osc_x, 0);
				//line(ly + osc_x, 0, ly - osc_x, height);
				
				noStroke();
				
				for (int h = 0; h < hcount; h += 1) {
					int xh = h - hcount / 2;
					
					fill(0, 0, 0, 8);
					rect(osc_x + xh * 128, ly + osc_y, 64, 64);
				}
			}
			noStroke();
		}
	}
	
	int centered_rect_size = 256;
	
	// support	
	int tx = width / 2 - centered_rect_size / 2 + 16;
	int ty1 = height / 2 + 132;
	int ty2 = height / 2 + 32 + centered_rect_size / 2;
	
	// see between sphere & stroke sphere
	//
	
	// center sphere 
	int ssize = lerp(center_sphere_stroke_weight, new_center_sphere_stroke_weight, (frame%frame_switch_stroke) / frame_switch_stroke);
	
	noFill();
	strokeWeight(ssize);
	stroke(224, 224, 224, ssize / 200 * 225);
	ellipse(width / 2, height / 2, centered_rect_size * 1.05, centered_rect_size * 1.05);
	
	strokeWeight(1);
	fill(0, 0, 0, 255);
	stroke(92, 92, 92, 255);
	triangle(tx, ty1, width / 2, height * 1.5 - ty2, width - tx, ty1);
	
	fill(0, 0, 0, 255);
	stroke(0, 0, 0, 128);
	triangle(tx, ty1, width - tx, ty1, width / 2, ty2);
	
	fill(0, 0, 0, 240);
	noStroke();
	ellipse(width / 2, height / 2, centered_rect_size, centered_rect_size);
	
	noStroke();
	//
	
	// circles
	int count = 92;
	
	for (int i = 0; i < count; i += 1) {
		float norm_i = i / count;
		
		float norm_i_abs = (0.5 - abs(0.5 - norm_i)) * 2;
		
		float osc_x = sin((norm_i_abs * 360) * (3.1415 / 180) + xmotion / 2) * (centered_rect_size - count + 12);
		float osc_y = cos((norm_i_abs * 360) * (3.1415 / 180) + ymotion / 2) * (centered_rect_size - count + 12);
		
		float osc_w = abs(cos((norm_i_abs * 360) * (3.1415 / 180) + ymotion * 2));
		
		/*
		float abs_osc_x = abs(osc_x);
		float abs_osc_y = abs(osc_y);
		
		if (osc_x > 0 && osc_y > 0) {
			fill(norm_i_abs * 255, 255, 255, norm_i_abs * 255);
			stroke(norm_i_abs * 255, 255, 255, norm_i_abs * 255);
		} else if (osc_x > 0 && osc_y < 0) {
			fill(255, norm_i_abs * 255, 255, norm_i_abs * 255);
			stroke(255, norm_i_abs * 255, 255, norm_i_abs * 255);
		} else if (osc_x < 0 && osc_y > 0) {
			fill(255, 255, norm_i_abs * 255, norm_i_abs * 255);
			stroke(255, 255, norm_i_abs * 255, norm_i_abs * 255);
		} else if (osc_x < 0 && osc_y < 0) {
			fill(255, 255, 255, norm_i_abs * 255);
			stroke(255, 255, 255, norm_i_abs * 255);
		}
		*/

		if ((i%2) == 0) {
			fill(norm_i_abs * 255, norm_i_abs * 255, 255, norm_i_abs * osc_w * 64);
			stroke(255, 255, 255, norm_i_abs * osc_w * 32);
		} else {
			noFill();
			stroke(norm_i_abs * 255, 255, 255, norm_i_abs * osc_w * 128);
		}
			
		//andres_circle(width / 2 + osc_x * 8, height / 2 + osc_y * 8, 1 + i + osc_x);
		//noFill();
		//ellipse(width / 2 /*+ osc_x * 8*/, height / 2/* + osc_y * 6*/, 1 + i / 4 + osc_x, 1 + i / 4 - osc_y);
		ellipse(width / 2 /*+ osc_x * 8*/, height / 2/* + osc_y * 6*/, 1 + i + osc_x, 1 + i + osc_y);
	}
	
	fill(0, 0, 0, 8);
	ellipse(width / 2, height / 2, 64, 32);
	
	xmotion += 0.005;
	ymotion += 0.008;
	
	rxmotion += 0.05;
	rymotion += 0;
	rzmotion += 0;
	
	frame += 1;
	
	if (frame%frame_switch_stroke == 0) {
		new_center_sphere_stroke_weight = 1 + random(42);
	}
}

void setup() {
  size(400, 400);

  frameRate(60); 

  background(0);
	
	smooth();
}

void draw() {
  //background(0);

  draw_func();
}"
"579071","Glitch space","mySketch","/**
  * Composition which begun with Andres circle drawing algorithm for fun and ended with regular shapes and a kind of vaporwave aesthetics. :)
	*/

void andres_circle(int x_centre, int y_centre, int r) {
	int x = 0;
	int y = r;
	int d = r - 1;
	
	while (y >= x) {
		//float norm_r = abs(0.5 - y / r);
		
		//float rot_y = cos(norm_r * 360 * (3.1415 / 180) + xmotion) * 32;
		
		rect(x_centre + x, y_centre + y, 1, 1);
		rect(x_centre + y , y_centre + x, 1, 1);
		rect(x_centre - x , y_centre + y, 1, 1);
		rect(x_centre - y , y_centre + x, 1, 1);
		rect(x_centre + x , y_centre - y, 1, 1);
		rect(x_centre + y , y_centre - x, 1, 1);
		rect(x_centre - x, y_centre - y, 1, 1);
		rect(x_centre - y , y_centre - x, 1, 1);

		if (d >= 2 * x) { 
			d = d - 2 * x - 1;
			x = x + 1;
		} else if (d < 2 * (r - y)) {
			d = d + 2 * y - 1;
			y = y - 1;
		} else { 
			d = d + 2 * (y - x - 1);
			y = y - 1;
			x = x + 1;
		}
	}
}

float xmotion = 4.8;
float ymotion = 2.2;

float rxmotion = 0;
float rymotion = 0;
float rzmotion = 0;

int center_sphere_stroke_weight = 1;
int new_center_sphere_stroke_weight = random(24);
int frame_switch_stroke = 120;

int frame = 0;

void draw_func() {
	noStroke();
	
  fill(0, 0, 0, 2);
  rect(0, 0, width, height);

	//stroke(255, 255, 255, 255);
	
	int lcount = 4;
	
	int rect_size_x = 64;
	int rect_size_y = 48;
	
	int cx = width / rect_size_x;
	int cy = height / rect_size_y;
	
	// background
	for (int i = 0; i < cy; i += 1) {
		float norm_i = abs(0.5 - i / cy);
		for (int j = 0; j < cx; j += 1) {
			float norm_j = (0.5 - abs(0.5 - j / cx)) * 2;//abs(0.5 - j / cx);
			float norm_ij = abs(norm_i - norm_j + random(-1, 1));
			
			fill(0, 0, 0, random(16, 24));
			rect(j * rect_size_x, i * rect_size_y, random(1, rect_size_x), random(1, rect_size_y));
			
			for (int k = 0; k < lcount; k += 1) {
				float norm_k = (0.5 - abs(0.5 - k / lcount)) * 2;
				
				int ly = i * rect_size_y + (rect_size_y / lcount) * k;
				
				float osc_x, osc_y;
				
				if ((k % 2) == 0) {
					osc_x = sin(norm_k * 360 * (3.1415 / 180) + xmotion) * 32;
					osc_y = cos(norm_k * 360 * (3.1415 / 180) - ymotion) * 32;
					
					stroke(255, 0, 255 * norm_i, 255 * norm_i * norm_k);
				} else {
					osc_x = sin(norm_k * 360 * (3.1415 / 180) - xmotion) * 32;
					osc_y = cos(norm_k * 360 * (3.1415 / 180) + ymotion) * 32;
					
					stroke(255 * norm_i, 0, 255, 255 * norm_i * norm_k);
				}
				
				int hcount = 8;
				
				//line(0, ly + osc_y, width, ly - osc_y);
				line(0, ly + osc_y * 8, width, height / 2);
				line(width - 1, ly + osc_y * 8, 0, height / 2);
				//line(ly + osc_x, 0, ly - osc_x, 0);
				//line(ly + osc_x, 0, ly - osc_x, height);
				
				noStroke();
				
				for (int h = 0; h < hcount; h += 1) {
					int xh = h - hcount / 8;
					
					fill(0, 0, 0, 8);
					rect(osc_x + xh * 128, ly + osc_y, 64, 64);
				}
			}
			noStroke();
		}
	}
	
	int centered_rect_size = 256;
	
	// support	
	int tx = width / 2 - centered_rect_size / 2 + 16;
	int ty1 = height / 2 + 132;
	int ty2 = height / 2 + 32 + centered_rect_size / 2;
	
	// see between sphere & stroke sphere
	//
	
	// center sphere 
	center_sphere_stroke_weight = lerp(center_sphere_stroke_weight, new_center_sphere_stroke_weight, (frame%frame_switch_stroke) / frame_switch_stroke);
	int ssize = center_sphere_stroke_weight;
	
	noFill();
	strokeWeight(ssize);
	stroke(224, 224, 224, ssize / 200 * 225);
	ellipse(width / 2, height / 2, centered_rect_size * 1.05, centered_rect_size * 1.05);
	
	strokeWeight(1);
	fill(0, 0, 0, 255);
	stroke(92, 92, 92, 255);
	triangle(tx, ty1, width / 2, height * 1.5 - ty2, width - tx, ty1);
	
	fill(0, 0, 0, 255);
	stroke(0, 0, 0, 128);
	triangle(tx, ty1, width - tx, ty1, width / 2, ty2);
	
	fill(0, 0, 0, 240);
	noStroke();
	ellipse(width / 2, height / 2, centered_rect_size, centered_rect_size);
	
	noStroke();
	//
	
	// circles
	int count = 92;
	
	for (int i = 0; i < count; i += 1) {
		float norm_i = i / count;
		
		float norm_i_abs = (0.5 - abs(0.5 - norm_i)) * 2;
		
		float osc_x = sin((norm_i_abs * 360) * (3.1415 / 180) + xmotion / 2) * (centered_rect_size - count + 12);
		float osc_y = cos((norm_i_abs * 360) * (3.1415 / 180) + ymotion / 2) * (centered_rect_size - count + 12);
		
		float osc_w = abs(cos((norm_i_abs * 360) * (3.1415 / 180) + ymotion * 2));
		
		/*
		float abs_osc_x = abs(osc_x);
		float abs_osc_y = abs(osc_y);
		
		if (osc_x > 0 && osc_y > 0) {
			fill(norm_i_abs * 255, 255, 255, norm_i_abs * 255);
			stroke(norm_i_abs * 255, 255, 255, norm_i_abs * 255);
		} else if (osc_x > 0 && osc_y < 0) {
			fill(255, norm_i_abs * 255, 255, norm_i_abs * 255);
			stroke(255, norm_i_abs * 255, 255, norm_i_abs * 255);
		} else if (osc_x < 0 && osc_y > 0) {
			fill(255, 255, norm_i_abs * 255, norm_i_abs * 255);
			stroke(255, 255, norm_i_abs * 255, norm_i_abs * 255);
		} else if (osc_x < 0 && osc_y < 0) {
			fill(255, 255, 255, norm_i_abs * 255);
			stroke(255, 255, 255, norm_i_abs * 255);
		}
		*/

		if ((i%2) == 0) {
			fill(norm_i_abs * 255, norm_i_abs * 255, 255, norm_i_abs * osc_w * 64);
			stroke(255, 255, 255, norm_i_abs * osc_w * 232);
		} else {
			noFill();
			stroke(norm_i_abs * 255, 255, 255, norm_i_abs * osc_w * 128);
		}
			
		//andres_circle(width / 2 + osc_x * 8, height / 2 + osc_y * 8, 1 + i + osc_x);
		//noFill();
		//ellipse(width / 2 /*+ osc_x * 8*/, height / 2/* + osc_y * 6*/, 1 + i / 4 + osc_x, 1 + i / 4 - osc_y);
		ellipse(width / 2 /*+ osc_x * 8*/, height / 2/* + osc_y * 6*/, 1 + i + osc_x, 1 + i + osc_y);
	}
	
	fill(0, 0, 0, 8);
	ellipse(width / 2, height / 2, 64, 32);
	
	float noise_size = abs(sin(xmotion / 4)) * 48;
	
	loadPixels();
	for (int x = 0; x < width; x += 8) {
		for (int y = 0; y < height; y += 8) {
			color p = pixels[y * width + x];
			
			if (brightness(p) < 32) {
				fill(255, 255, 255, 48);
				rect(x + random(8), y + random(8), 2, 2);	
				fill(0, 0, 0, 2);
				rect(x + random(8), y + random(8), noise_size, noise_size);	
			}
		}
	}
	
	xmotion += 0.005;
	ymotion += 0.008;
	
	rxmotion += 0.05;
	rymotion += 0;
	rzmotion += 0;
	
	frame += 1;
	
	if (frame%frame_switch_stroke == 0) {
		new_center_sphere_stroke_weight = 1 + random(42);
	}
}

void setup() {
  size(400, 400);

  frameRate(60); 

  background(0);
	
	smooth();
}

void draw() {
  //background(0);

  draw_func();
}"
"579071","Glitch space","mySketch","/**
  * Composition which begun with Andres circle drawing algorithm for fun and ended with regular shapes. :)
	*/

void andres_circle(int x_centre, int y_centre, int r) {
	int x = 0;
	int y = r;
	int d = r - 1;
	
	while (y >= x) {
		//float norm_r = abs(0.5 - y / r);
		
		//float rot_y = cos(norm_r * 360 * (3.1415 / 180) + xmotion) * 32;
		
		rect(x_centre + x, y_centre + y, 1, 1);
		rect(x_centre + y , y_centre + x, 1, 1);
		rect(x_centre - x , y_centre + y, 1, 1);
		rect(x_centre - y , y_centre + x, 1, 1);
		rect(x_centre + x , y_centre - y, 1, 1);
		rect(x_centre + y , y_centre - x, 1, 1);
		rect(x_centre - x, y_centre - y, 1, 1);
		rect(x_centre - y , y_centre - x, 1, 1);

		if (d >= 2 * x) { 
			d = d - 2 * x - 1;
			x = x + 1;
		} else if (d < 2 * (r - y)) {
			d = d + 2 * y - 1;
			y = y - 1;
		} else { 
			d = d + 2 * (y - x - 1);
			y = y - 1;
			x = x + 1;
		}
	}
}

float xmotion = 8.8;
float ymotion = 2.2;

float rxmotion = 0;
float rymotion = 0;
float rzmotion = 0;

int center_sphere_stroke_weight = 1;
int new_center_sphere_stroke_weight = random(24);
int frame_switch_stroke = 120;

int frame = 0;

void draw_func() {
	noStroke();
	
  fill(0, 0, 0, 2);
  rect(0, 0, width, height);

	//stroke(255, 255, 255, 255);
	
	int lcount = 4;
	
	int rect_size_x = 64;
	int rect_size_y = 48;
	
	int cx = width / rect_size_x;
	int cy = height / rect_size_y;
	
	// background
	for (int i = 0; i < cy; i += 1) {
		float norm_i = abs(0.5 - i / cy);
		for (int j = 0; j < cx; j += 1) {
			float norm_j = (0.5 - abs(0.5 - j / cx)) * 2;//abs(0.5 - j / cx);
			float norm_ij = abs(norm_i - norm_j + random(-1, 1));
			
			fill(0, 0, 0, random(16, 24));
			rect(j * rect_size_x, i * rect_size_y, random(1, rect_size_x), random(1, rect_size_y));
			
			for (int k = 0; k < lcount; k += 1) {
				float norm_k = (0.5 - abs(0.5 - k / lcount)) * 2;
				
				int ly = i * rect_size_y + (rect_size_y / lcount) * k;
				
				float osc_x, osc_y;
				
				if ((k % 2) == 0) {
					osc_x = sin(norm_k * 360 * (3.1415 / 180) + xmotion) * 32;
					osc_y = cos(norm_k * 360 * (3.1415 / 180) - ymotion) * 32;
					
					stroke(255, 0, 255 * norm_i, 255 * norm_i * norm_k);
				} else {
					osc_x = sin(norm_k * 360 * (3.1415 / 180) - xmotion) * 32;
					osc_y = cos(norm_k * 360 * (3.1415 / 180) + ymotion) * 32;
					
					stroke(255 * norm_i, 0, 255, 255 * norm_i * norm_k);
				}
				
				int hcount = 8;
				
				//line(0, ly + osc_y, width, ly - osc_y);
				line(0, ly + osc_y * 8, width, height / 2);
				line(width - 1, ly + osc_y * 8, 0, height / 2);
				//line(ly + osc_x, 0, ly - osc_x, 0);
				//line(ly + osc_x, 0, ly - osc_x, height);
				
				noStroke();
				
				for (int h = 0; h < hcount; h += 1) {
					int xh = h - hcount / 8;
					
					fill(0, 0, 0, 8);
					rect(osc_x + xh * 128, ly + osc_y, 64, 64);
				}
			}
			noStroke();
		}
	}
	
	int centered_rect_size = 256;
	
	// support	
	int tx = width / 2 - centered_rect_size / 2 + 16;
	int ty1 = height / 2 + 132;
	int ty2 = height / 2 + 32 + centered_rect_size / 2;
	
	// see between sphere & stroke sphere
	//
	
	// center sphere 
	center_sphere_stroke_weight = lerp(center_sphere_stroke_weight, new_center_sphere_stroke_weight, (frame%frame_switch_stroke) / frame_switch_stroke);
	int ssize = center_sphere_stroke_weight;
	
	noFill();
	strokeWeight(ssize);
	stroke(224, 224, 224, ssize / 200 * 225);
	ellipse(width / 2, height / 2, centered_rect_size * 1.05, centered_rect_size * 1.05);
	
	strokeWeight(1);
	fill(0, 0, 0, 255);
	stroke(92, 92, 92, 255);
	triangle(tx, ty1, width / 2, height * 1.5 - ty2, width - tx, ty1);
	
	fill(0, 0, 0, 255);
	stroke(0, 0, 0, 128);
	triangle(tx, ty1, width - tx, ty1, width / 2, ty2);
	
	fill(0, 0, 0, 240);
	noStroke();
	ellipse(width / 2, height / 2, centered_rect_size, centered_rect_size);
	
	noStroke();
	//
	
	// circles
	int count = 92;
	
	for (int i = 0; i < count; i += 1) {
		float norm_i = i / count;
		
		float norm_i_abs = (0.5 - abs(0.5 - norm_i)) * 2;
		
		float osc_x = sin((norm_i_abs * 360) * (3.1415 / 180) + xmotion / 2) * (centered_rect_size - count + 12);
		float osc_y = cos((norm_i_abs * 360) * (3.1415 / 180) + ymotion / 2) * (centered_rect_size - count + 12);
		
		float osc_w = abs(cos((norm_i_abs * 360) * (3.1415 / 180) + ymotion * 2));
		
		/*
		float abs_osc_x = abs(osc_x);
		float abs_osc_y = abs(osc_y);
		
		if (osc_x > 0 && osc_y > 0) {
			fill(norm_i_abs * 255, 255, 255, norm_i_abs * 255);
			stroke(norm_i_abs * 255, 255, 255, norm_i_abs * 255);
		} else if (osc_x > 0 && osc_y < 0) {
			fill(255, norm_i_abs * 255, 255, norm_i_abs * 255);
			stroke(255, norm_i_abs * 255, 255, norm_i_abs * 255);
		} else if (osc_x < 0 && osc_y > 0) {
			fill(255, 255, norm_i_abs * 255, norm_i_abs * 255);
			stroke(255, 255, norm_i_abs * 255, norm_i_abs * 255);
		} else if (osc_x < 0 && osc_y < 0) {
			fill(255, 255, 255, norm_i_abs * 255);
			stroke(255, 255, 255, norm_i_abs * 255);
		}
		*/

		if ((i%2) == 0) {
			fill(norm_i_abs * 255, norm_i_abs * 255, 255, norm_i_abs * osc_w * 64);
			stroke(255, 255, 255, norm_i_abs * osc_w * 232);
		} else {
			noFill();
			stroke(norm_i_abs * 255, 255, 255, norm_i_abs * osc_w * 128);
		}
			
		//andres_circle(width / 2 + osc_x * 8, height / 2 + osc_y * 8, 1 + i + osc_x);
		//noFill();
		//ellipse(width / 2 /*+ osc_x * 8*/, height / 2/* + osc_y * 6*/, 1 + i / 4 + osc_x, 1 + i / 4 - osc_y);
		ellipse(width / 2 /*+ osc_x * 8*/, height / 2/* + osc_y * 6*/, 1 + i + osc_x, 1 + i + osc_y);
	}
	
	fill(0, 0, 0, 8);
	ellipse(width / 2, height / 2, 64, 32);
	
	float noise_size = abs(sin(xmotion / 4)) * 48;
	
	loadPixels();
	for (int x = 0; x < width; x += 8) {
		for (int y = 0; y < height; y += 8) {
			color p = pixels[y * width + x];
			
			if (brightness(p) < 32) {
				fill(255, 255, 255, 48);
				rect(x + random(8), y + random(8), 2, 2);	
				fill(0, 0, 0, 2);
				rect(x + random(8), y + random(8), noise_size, noise_size);	
			}
		}
	}
	
	xmotion += 0.005;
	ymotion += 0.008;
	
	rxmotion += 0.05;
	rymotion += 0;
	rzmotion += 0;
	
	frame += 1;
	
	if (frame%frame_switch_stroke == 0) {
		new_center_sphere_stroke_weight = 1 + random(42);
	}
}

void setup() {
  size(400, 400);

  frameRate(60); 

  background(0);
	
	smooth();
}

void draw() {
  //background(0);

  draw_func();
}"
"579071","Glitch space","mySketch","/**
  * Composition which begun with Andres circle drawing algorithm for fun and ended with regular shapes. :)
	*/

void andres_circle(int x_centre, int y_centre, int r) {
	int x = 0;
	int y = r;
	int d = r - 1;
	
	while (y >= x) {
		//float norm_r = abs(0.5 - y / r);
		
		//float rot_y = cos(norm_r * 360 * (3.1415 / 180) + xmotion) * 32;
		
		rect(x_centre + x, y_centre + y, 1, 1);
		rect(x_centre + y , y_centre + x, 1, 1);
		rect(x_centre - x , y_centre + y, 1, 1);
		rect(x_centre - y , y_centre + x, 1, 1);
		rect(x_centre + x , y_centre - y, 1, 1);
		rect(x_centre + y , y_centre - x, 1, 1);
		rect(x_centre - x, y_centre - y, 1, 1);
		rect(x_centre - y , y_centre - x, 1, 1);

		if (d >= 2 * x) { 
			d = d - 2 * x - 1;
			x = x + 1;
		} else if (d < 2 * (r - y)) {
			d = d + 2 * y - 1;
			y = y - 1;
		} else { 
			d = d + 2 * (y - x - 1);
			y = y - 1;
			x = x + 1;
		}
	}
}

float xmotion = 8.8;
float ymotion = 2.2;

float rxmotion = 0;
float rymotion = 0;
float rzmotion = 0;

int center_sphere_stroke_weight = 1;
int new_center_sphere_stroke_weight = random(24);
int frame_switch_stroke = 120;

int frame = 0;

void draw_func() {
	noStroke();
	
  fill(0, 0, 0, 2);
  rect(0, 0, width, height);

	//stroke(255, 255, 255, 255);
	
	int lcount = 4;
	
	int rect_size_x = 64;
	int rect_size_y = 48;
	
	int cx = width / rect_size_x;
	int cy = height / rect_size_y;
	
	// background
	for (int i = 0; i < cy; i += 1) {
		float norm_i = abs(0.5 - i / cy);
		for (int j = 0; j < cx; j += 1) {
			float norm_j = (0.5 - abs(0.5 - j / cx)) * 2;//abs(0.5 - j / cx);
			float norm_ij = abs(norm_i - norm_j + random(-1, 1));
			
			fill(0, 0, 0, random(16, 24));
			rect(j * rect_size_x, i * rect_size_y, random(1, rect_size_x), random(1, rect_size_y));
			
			for (int k = 0; k < lcount; k += 1) {
				float norm_k = (0.5 - abs(0.5 - k / lcount)) * 2;
				
				int ly = i * rect_size_y + (rect_size_y / lcount) * k;
				
				float osc_x, osc_y;
				
				if ((k % 2) == 0) {
					osc_x = sin(norm_k * 360 * (3.1415 / 180) + xmotion) * 32;
					osc_y = cos(norm_k * 360 * (3.1415 / 180) - ymotion) * 32;
					
					stroke(255, 0, 255 * norm_i, 255 * norm_i * norm_k);
				} else {
					osc_x = sin(norm_k * 360 * (3.1415 / 180) - xmotion) * 32;
					osc_y = cos(norm_k * 360 * (3.1415 / 180) + ymotion) * 32;
					
					stroke(255 * norm_i, 0, 255, 255 * norm_i * norm_k);
				}
				
				int hcount = 8;
				
				//line(0, ly + osc_y, width, ly - osc_y);
				line(0, ly + osc_y * 8, width, height / 2);
				line(width - 1, ly + osc_y * 8, 0, height / 2);
				//line(ly + osc_x, 0, ly - osc_x, 0);
				//line(ly + osc_x, 0, ly - osc_x, height);
				
				noStroke();
				
				for (int h = 0; h < hcount; h += 1) {
					int xh = h - hcount / 8;
					
					fill(0, 0, 0, 8);
					rect(osc_x + xh * 128, ly + osc_y, 64, 64);
				}
			}
			noStroke();
		}
	}
	
	int centered_rect_size = 256;
	
	// support	
	int tx = width / 2 - centered_rect_size / 2 + 16;
	int ty1 = height / 2 + 132;
	int ty2 = height / 2 + 32 + centered_rect_size / 2;
	
	// see between sphere & stroke sphere
	//
	
	// center sphere 
	center_sphere_stroke_weight = lerp(center_sphere_stroke_weight, new_center_sphere_stroke_weight, (frame%frame_switch_stroke) / frame_switch_stroke);
	int ssize = center_sphere_stroke_weight;
	
	noFill();
	strokeWeight(ssize);
	stroke(224, 224, 224, ssize / 200 * 225);
	ellipse(width / 2, height / 2, centered_rect_size * 1.05, centered_rect_size * 1.05);
	
	strokeWeight(1);
	fill(0, 0, 0, 255);
	stroke(92, 92, 92, 255);
	triangle(tx, ty1, width / 2, height * 1.5 - ty2, width - tx, ty1);
	
	fill(0, 0, 0, 255);
	stroke(0, 0, 0, 128);
	triangle(tx, ty1, width - tx, ty1, width / 2, ty2);
	
	fill(0, 0, 0, 240);
	noStroke();
	ellipse(width / 2, height / 2, centered_rect_size, centered_rect_size);
	
	noStroke();
	//
	
	// circles
	int count = 92;
	
	for (int i = 0; i < count; i += 1) {
		float norm_i = i / count;
		
		float norm_i_abs = (0.5 - abs(0.5 - norm_i)) * 2;
		
		float osc_x = sin((norm_i_abs * 360) * (3.1415 / 180) + xmotion / 2) * (centered_rect_size - count + 12);
		float osc_y = cos((norm_i_abs * 360) * (3.1415 / 180) + ymotion / 2) * (centered_rect_size - count + 12);
		
		float osc_w = abs(cos((norm_i_abs * 360) * (3.1415 / 180) + ymotion * 2));
		
		/*
		float abs_osc_x = abs(osc_x);
		float abs_osc_y = abs(osc_y);
		
		if (osc_x > 0 && osc_y > 0) {
			fill(norm_i_abs * 255, 255, 255, norm_i_abs * 255);
			stroke(norm_i_abs * 255, 255, 255, norm_i_abs * 255);
		} else if (osc_x > 0 && osc_y < 0) {
			fill(255, norm_i_abs * 255, 255, norm_i_abs * 255);
			stroke(255, norm_i_abs * 255, 255, norm_i_abs * 255);
		} else if (osc_x < 0 && osc_y > 0) {
			fill(255, 255, norm_i_abs * 255, norm_i_abs * 255);
			stroke(255, 255, norm_i_abs * 255, norm_i_abs * 255);
		} else if (osc_x < 0 && osc_y < 0) {
			fill(255, 255, 255, norm_i_abs * 255);
			stroke(255, 255, 255, norm_i_abs * 255);
		}
		*/

		if ((i%2) == 0) {
			fill(norm_i_abs * 255, norm_i_abs * 255, 255, norm_i_abs * osc_w * 64);
			stroke(255, 255, 255, norm_i_abs * osc_w * 232);
		} else {
			noFill();
			stroke(norm_i_abs * 255, 255, 255, norm_i_abs * osc_w * 128);
		}
			
		//andres_circle(width / 2 + osc_x * 8, height / 2 + osc_y * 8, 1 + i + osc_x);
		//noFill();
		//ellipse(width / 2 /*+ osc_x * 8*/, height / 2/* + osc_y * 6*/, 1 + i / 4 + osc_x, 1 + i / 4 - osc_y);
		ellipse(width / 2 /*+ osc_x * 8*/, height / 2/* + osc_y * 6*/, 1 + i + osc_x, 1 + i + osc_y);
	}
	
	fill(0, 0, 0, 8);
	ellipse(width / 2, height / 2, 64, 32);
	
	float noise_size = abs(sin(xmotion / 4)) * 48;
	
	loadPixels();
	for (int x = 0; x < width; x += 8) {
		for (int y = 0; y < height; y += 8) {
			color p = pixels[y * width + x];
			
			if (brightness(p) < 32) {
				fill(255, 255, 255, 48);
				rect(x + random(8), y + random(8), 2, 2);	
				fill(0, 0, 0, 2);
				rect(x + random(8), y + random(8), noise_size, noise_size);	
			}
		}
	}
	
	xmotion += 0.005;
	ymotion += 0.008;
	
	rxmotion += 0.05;
	rymotion += 0;
	rzmotion += 0;
	
	frame += 1;
	
	if (frame%frame_switch_stroke == 0) {
		new_center_sphere_stroke_weight = 1 + random(42);
	}
}

void setup() {
  size(400, 400);

  frameRate(60); 

  background(0);
	
	smooth();
}

void draw() {
  //background(0);

  draw_func();
}"
"579071","Glitch space","mySketch","/**
  * Composition which begun with Andres circle drawing algorithm for fun and ended with regular shapes. :)
	*/

void andres_circle(int x_centre, int y_centre, int r) {
	int x = 0;
	int y = r;
	int d = r - 1;
	
	while (y >= x) {
		//float norm_r = abs(0.5 - y / r);
		
		//float rot_y = cos(norm_r * 360 * (3.1415 / 180) + xmotion) * 32;
		
		rect(x_centre + x, y_centre + y, 1, 1);
		rect(x_centre + y , y_centre + x, 1, 1);
		rect(x_centre - x , y_centre + y, 1, 1);
		rect(x_centre - y , y_centre + x, 1, 1);
		rect(x_centre + x , y_centre - y, 1, 1);
		rect(x_centre + y , y_centre - x, 1, 1);
		rect(x_centre - x, y_centre - y, 1, 1);
		rect(x_centre - y , y_centre - x, 1, 1);

		if (d >= 2 * x) { 
			d = d - 2 * x - 1;
			x = x + 1;
		} else if (d < 2 * (r - y)) {
			d = d + 2 * y - 1;
			y = y - 1;
		} else { 
			d = d + 2 * (y - x - 1);
			y = y - 1;
			x = x + 1;
		}
	}
}

float xmotion = 8.8;
float ymotion = 2.2;

float rxmotion = 0;
float rymotion = 0;
float rzmotion = 0;

int center_sphere_stroke_weight = 1;
int new_center_sphere_stroke_weight = random(24);
int frame_switch_stroke = 120;

int frame = 0;

void draw_func() {
	noStroke();
	
  fill(0, 0, 0, 2);
  rect(0, 0, width, height);

	//stroke(255, 255, 255, 255);
	
	int lcount = 4;
	
	int rect_size_x = 64;
	int rect_size_y = 48;
	
	int cx = width / rect_size_x;
	int cy = height / rect_size_y;
	
	// background
	for (int i = 0; i < cy; i += 1) {
		float norm_i = abs(0.5 - i / cy);
		for (int j = 0; j < cx; j += 1) {
			float norm_j = (0.5 - abs(0.5 - j / cx)) * 2;//abs(0.5 - j / cx);
			float norm_ij = abs(norm_i - norm_j + random(-1, 1));
			
			fill(0, 0, 0, random(16, 24));
			rect(j * rect_size_x, i * rect_size_y, random(1, rect_size_x), random(1, rect_size_y));
			
			for (int k = 0; k < lcount; k += 1) {
				float norm_k = (0.5 - abs(0.5 - k / lcount)) * 2;
				
				int ly = i * rect_size_y + (rect_size_y / lcount) * k;
				
				float osc_x, osc_y;
				
				if ((k % 2) == 0) {
					osc_x = sin(norm_k * 360 * (3.1415 / 180) + xmotion) * 32;
					osc_y = cos(norm_k * 360 * (3.1415 / 180) - ymotion) * 32;
					
					stroke(255, 0, 255 * norm_i, 255 * norm_i * norm_k);
				} else {
					osc_x = sin(norm_k * 360 * (3.1415 / 180) - xmotion) * 32;
					osc_y = cos(norm_k * 360 * (3.1415 / 180) + ymotion) * 32;
					
					stroke(255 * norm_i, 0, 255, 255 * norm_i * norm_k);
				}
				
				int hcount = 8;
				
				//line(0, ly + osc_y, width, ly - osc_y);
				line(0, ly + osc_y * 8, width, height / 2);
				line(width - 1, ly + osc_y * 8, 0, height / 2);
				//line(ly + osc_x, 0, ly - osc_x, 0);
				//line(ly + osc_x, 0, ly - osc_x, height);
				
				noStroke();
				
				for (int h = 0; h < hcount; h += 1) {
					int xh = h - hcount / 8;
					
					fill(0, 0, 0, 8);
					rect(osc_x + xh * 128, ly + osc_y, 64, 64);
				}
			}
			noStroke();
		}
	}
	
	int centered_rect_size = 256;
	
	// support	
	int tx = width / 2 - centered_rect_size / 2 + 16;
	int ty1 = height / 2 + 132;
	int ty2 = height / 2 + 32 + centered_rect_size / 2;
	
	// see between sphere & stroke sphere
	//
	
	// center sphere 
	center_sphere_stroke_weight = lerp(center_sphere_stroke_weight, new_center_sphere_stroke_weight, (frame%frame_switch_stroke) / frame_switch_stroke);
	int ssize = center_sphere_stroke_weight;
	
	noFill();
	strokeWeight(ssize);
	stroke(224, 224, 224, ssize / 200 * 225);
	ellipse(width / 2, height / 2, centered_rect_size * 1.05, centered_rect_size * 1.05);
	
	strokeWeight(1);
	fill(0, 0, 0, 255);
	stroke(92, 92, 92, 255);
	triangle(tx, ty1, width / 2, height * 1.5 - ty2, width - tx, ty1);
	
	fill(0, 0, 0, 255);
	stroke(0, 0, 0, 128);
	triangle(tx, ty1, width - tx, ty1, width / 2, ty2);
	
	fill(0, 0, 0, 240);
	noStroke();
	ellipse(width / 2, height / 2, centered_rect_size, centered_rect_size);
	
	noStroke();
	//
	
	// circles
	int count = 92;
	
	for (int i = 0; i < count; i += 1) {
		float norm_i = i / count;
		
		float norm_i_abs = (0.5 - abs(0.5 - norm_i)) * 2;
		
		float osc_x = sin((norm_i_abs * 360) * (3.1415 / 180) + xmotion / 2) * (centered_rect_size - count + 12);
		float osc_y = cos((norm_i_abs * 360) * (3.1415 / 180) + ymotion / 2) * (centered_rect_size - count + 12);
		
		float osc_w = abs(cos((norm_i_abs * 360) * (3.1415 / 180) + ymotion * 2));
		
		/*
		float abs_osc_x = abs(osc_x);
		float abs_osc_y = abs(osc_y);
		
		if (osc_x > 0 && osc_y > 0) {
			fill(norm_i_abs * 255, 255, 255, norm_i_abs * 255);
			stroke(norm_i_abs * 255, 255, 255, norm_i_abs * 255);
		} else if (osc_x > 0 && osc_y < 0) {
			fill(255, norm_i_abs * 255, 255, norm_i_abs * 255);
			stroke(255, norm_i_abs * 255, 255, norm_i_abs * 255);
		} else if (osc_x < 0 && osc_y > 0) {
			fill(255, 255, norm_i_abs * 255, norm_i_abs * 255);
			stroke(255, 255, norm_i_abs * 255, norm_i_abs * 255);
		} else if (osc_x < 0 && osc_y < 0) {
			fill(255, 255, 255, norm_i_abs * 255);
			stroke(255, 255, 255, norm_i_abs * 255);
		}
		*/

		if ((i%2) == 0) {
			fill(norm_i_abs * 255, norm_i_abs * 255, 255, norm_i_abs * osc_w * 64);
			stroke(255, 255, 255, norm_i_abs * osc_w * 232);
		} else {
			noFill();
			stroke(norm_i_abs * 255, 255, 255, norm_i_abs * osc_w * 128);
		}
			
		//andres_circle(width / 2 + osc_x * 8, height / 2 + osc_y * 8, 1 + i + osc_x);
		//noFill();
		//ellipse(width / 2 /*+ osc_x * 8*/, height / 2/* + osc_y * 6*/, 1 + i / 4 + osc_x, 1 + i / 4 - osc_y);
		ellipse(width / 2 /*+ osc_x * 8*/, height / 2/* + osc_y * 6*/, 1 + i + osc_x, 1 + i + osc_y);
	}
	
	fill(0, 0, 0, 8);
	ellipse(width / 2, height / 2, 64, 32);
	
	float noise_size = abs(sin(xmotion / 4)) * 48;
	
	loadPixels();
	for (int x = 0; x < width; x += 8) {
		for (int y = 0; y < height; y += 8) {
			color p = pixels[y * width + x];
			
			if (brightness(p) < 32) {
				fill(255, 255, 255, 48);
				rect(x + random(8), y + random(8), 2, 2);	
				fill(0, 0, 0, 2);
				rect(x + random(8), y + random(8), noise_size, noise_size);	
			}
		}
	}
	
	xmotion += 0.005;
	ymotion += 0.008;
	
	rxmotion += 0.05;
	rymotion += 0;
	rzmotion += 0;
	
	frame += 1;
	
	if (frame%frame_switch_stroke == 0) {
		new_center_sphere_stroke_weight = 1 + random(42);
	}
}

void setup() {
  size(400, 400);

  frameRate(60); 

  background(0);
	
	smooth();
}

void draw() {
  //background(0);

  draw_func();
}"
"577480","Crystal Realism","mySketch","PImage colormap;

// quality control
int dots_step = 2;
int elems_step = 1;

// same but look below, these are adjusted in real-time to increase rendering quality by abusing motion blur :)
int elems = 192;
int rect_size = 4;

float xmotion = 0;
float ymotion = 0;
float rmotion = 0;

float xmotvel = 0.01;
float ymotvel = 0.05;
float rmotvel = 0.25;

int bottom_elems_x = 110;
int left_elems_x = 110;
int elems_y = 112 / 2;
int elems_x_step = 1;
int elems_y_step = 1;
float yy = 0;
float xx = 640 / 2;

int iter_step_x = 16;
int iter_step_y = 16;

int rect_size = 4;
int rect_size2 = 1;

float xm_speed = 1.;

void draw_func() {
  fill(0, 0, 0, 2);
  rect(0, 0, 640, 480);

  noStroke();
  
	for (int y = 0; y < 640/2; y += 1) {
		float off = y/16 + sin((((y + rmotion) / 32) * 360) * (PI / 180) + xmotion * xm_speed) + rmotion;

		float off3 = sin(((y / 32 + rmotion) * 360) * (PI / 180) + xmotion);
		
		if (y%2 == 0) {
			fill(255 - off3 * 255, 255 - off3 * 255, 255 - off3 * 255, 255);
		} else {
			fill(0, 0, 0, 128);
		}

		ellipse(xx/8 - (y/32 + off) * rect_size2, yy - (y/16.) * rect_size2, rect_size, rect_size);
		ellipse((xx - 640/2) + (y + off) * rect_size2, yy - y * rect_size2, rect_size, rect_size);
		ellipse(xx - (y/32 + off) * rect_size2, 480 / 2 - yy - y * rect_size2, rect_size, rect_size);
		ellipse((xx - 640/2) + (y + off) * rect_size2, 480 / 2 - yy - (y/16.) * rect_size2, rect_size, rect_size);
	}
	
	// kaleido
  loadPixels();
  for (int y = 0; y < 480 / 2; y++) {
    int iy = y * 640;
    int line_index = (480 - y - 1) * 640;
    
    for (int x = 0; x < 640 / 2; x++) {
      int ix = 640 - x - 1;
      
      int index = ((int(x) & 255) + (int(y) & 255) * 640);
     
      // flip images
      pixels[x + iy]          = pixels[index];
      pixels[ix + line_index] = pixels[index];
      pixels[ x + line_index] = pixels[index];
      pixels[ix + iy]         = pixels[index];
    }
  }
	updatePixels();
	
	int i = 0;
  for (int y = 0; y < 480; y += iter_step_y) {
		float yn = y / 480;
		int yi = y * 480;
		
		for (int x = 0; x < 640; x += iter_step_x) {
			int p = pixels[x + yi];
			
			float pbr = brightness(p);

			if (pbr > 254) {
				float pr = red(p);
				float pg = green(p);
				float pb = blue(p);
				
				float xn = x / 640;
				float inn = i / (640 * 480);
				
				float pbn = pbr / 255;
				
				float r = pr * (abs(sin(((pr / 255) * 360) * (PI / 180) * PI + xmotion * pbn)));
				float g = pg * (abs(sin(((pg / 255) * 360) * (PI / 180) * PI + xmotion)));
				float b = pb * (abs(cos(((pb / 255) * 360) * (PI / 180) * PI + ymotion)));

				fill(r, g, b, pr);
				ellipse(x + cos((pbn * 360) * (PI / 180) + xmotion) * (640/2 * pbn), y + sin((pbn * 360) * (PI / 180) * PI + ymotion) * (480/2 * pbn), 1 + random(8) + pbn, 1 + random(8));
			} else {
				fill(0, 0, 0, 32);
				rect(x, y, random(24), random(24))
			}
			
			i += 1;
		}
	}

  xmotion += xmotvel;
  ymotion += ymotvel;
  rmotion += rmotvel;
	
	if (rmotion > 32) {
			rmotion = -rmotion;
	}
	
	yy += rect_size / 4;
	
	rect_size += 0.05;
	
	if (yy >= 480) {
		rect_size = 1 + random(16);
	
		xmotvel = random(0.001, 1);
		ymotvel = random(0.001, 1);
		rmotvel = random(0.001, 1)
		
		xm_speed = random(0.01, 1);
		rect_size2 = 2 + random(8);
		
		yy = -rect_size;	
		
		xx += rect_size;
		
		if (xx > 640/2) {
			xx = 640/2;	
		}
		
		if (xx < 0) {
			xx = 640/2;	
		}
	}
	
  
  float xoff = 800 / 2;
  
  float sphere_radius = 292;
  float yoff = 600 / 2 - sphere_radius;
  
  for (int s = 0; s < elems; s += elems_step) {
    float de = (float)s / elems;
    
    float bd = max((0.5-abs(de - 0.5)) * 4, 0.05);
    
    float yrepeat = 1;
    int yyd = (((int)(de * (colormap.height * yrepeat))%colormap.height)) * colormap.width;
		
		float tyrepeat = 3;

    // cartesian circle equation
    float sphere_radius_squared = sphere_radius * sphere_radius;
    float sh_radius = de * (sphere_radius * 2) - sphere_radius;
    float xc_off = sqrt(sphere_radius_squared - sh_radius*sh_radius);
    
    float final_x;
    float final_y = yoff + de * (sphere_radius * 2); //+ sin((de * 360 + 180) * (PI / 180) + xmotion / 24.) * 4;
    
    for (int e = 0; e < (int)xc_off; e += dots_step) {
      float dd = (float)e / xc_off;

      final_x = xoff - xc_off + xc_off * dd * 2;// + cos((de * 360 + 180) * (PI / 180) + xmotion / 24.) * 4;
      
      float yc_off;
      
      // compute UV texels for the colormap
      if (dd > 0.5) {
        yc_off = sqrt(1 - dd*dd) + 1.270;
      } else {
        float dd2 = 1 - dd;
        
        yc_off = 1-sqrt(1 - dd2*dd2);
      }
      
      // apply colormaps
      float xrepeat = 0.5;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + xmotion)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      float final_r = r;
      float final_g = g;
      float final_b = b;
      
      // some compositing 
      fill(final_r, final_g, final_b, 48);//r * (r2 / 255) + r * bright, g * (g2 / 255) + g * bright, b * (b2 / 255) + b * bright);
      
      //rect(final_x, final_y, rect_size, rect_size);
      // slower but look good!
      ellipse(final_x, final_y, rect_size, rect_size);

/*
      // can improve the look with some kind of ""dithering""
      fill(r, g, b, 255);
      
      float rect_size2 = rect_size / 2;
      rect(final_x - rect_size2, final_y, rect_size2, rect_size2);
      rect(final_x + rect_size2, final_y, rect_size2, rect_size2);
      rect(final_x, final_y - rect_size2, rect_size2, rect_size2);
      rect(final_x, final_y + rect_size2, rect_size2, rect_size2);
*/
    }
  }
}

void setup() {
  size(640, 480);

  frameRate(60); 
	
	colormap = loadImage(""data.jpg"");

  background(0);
}

void draw() {
  //background(0);

  draw_func();
}"
"577480","Crystal Realism","mySketch","/**
 * A mix of ""Patterns"" and ""Blue planet"" sketchs with some try at doing some crystal ball things
 * allier.jpg is a vacation photo i took in 2017 at Monétay-sur-Allier, France
 */

PImage colormap;

// quality control
int dots_step = 2;
int elems_step = 1;

// same but look below, these are adjusted in real-time to increase rendering quality by abusing motion blur :)
int elems = 128;

float xmotion = 0;
float ymotion = 0;
float rmotion = 0;

float xmotvel = 0.01;
float ymotvel = 0.05;
float rmotvel = 0.25;

int bottom_elems_x = 110;
int left_elems_x = 110;
int elems_y = 112 / 2;
int elems_x_step = 1;
int elems_y_step = 1;
float yy = 0;
float xx = 640 / 2;

int iter_step_x = 16;
int iter_step_y = 16;

int rect_size = 4;
int rect_size2 = 1;

float xm_speed = 1.;

void draw_func() {
  fill(0, 0, 0, 2);
  rect(0, 0, 640, 480);

  noStroke();
  
	for (int y = 0; y < 640/2; y += 1) {
		float off = y/16 + sin((((y + rmotion) / 32) * 360) * (PI / 180) + xmotion * xm_speed) + rmotion;

		float off3 = sin(((y / 32 + rmotion) * 360) * (PI / 180) + xmotion);
		
		if (y%2 == 0) {
			fill(255 - off3 * 255, 255 - off3 * 255, 255 - off3 * 255, 255);
		} else {
			fill(0, 0, 0, 128);
		}

		ellipse(xx/8 - (y/32 + off) * rect_size2, yy - (y/16.) * rect_size2, rect_size, rect_size);
		ellipse((xx - 640/2) + (y + off) * rect_size2, yy - y * rect_size2, rect_size, rect_size);
		ellipse(xx - (y/32 + off) * rect_size2, 480 / 2 - yy - y * rect_size2, rect_size, rect_size);
		ellipse((xx - 640/2) + (y + off) * rect_size2, 480 / 2 - yy - (y/16.) * rect_size2, rect_size, rect_size);
	}
	
	// kaleido
  loadPixels();
  for (int y = 0; y < 480 / 2; y++) {
    int iy = y * 640;
    int line_index = (480 - y - 1) * 640;
    
    for (int x = 0; x < 640 / 2; x++) {
      int ix = 640 - x - 1;
      
      int index = ((int(x) & 255) + (int(y) & 255) * 640);
     
      // flip images
      pixels[x + iy]          = pixels[index];
      pixels[ix + line_index] = pixels[index];
      pixels[ x + line_index] = pixels[index];
      pixels[ix + iy]         = pixels[index];
    }
  }
	updatePixels();
	
  float xoff = 640 / 2;
  
  float sphere_radius = 224;
  float yoff = 480 / 2 - sphere_radius;
	
  for (int s = 0; s < elems; s += elems_step) {
    float de = (float)s / elems;
		
    float bd = max((0.5-abs(de - 0.5)) * 4, 0.05);
    
    float yrepeat = 1;
    int yyd = (((int)(de * (colormap.height * yrepeat))%colormap.height)) * colormap.width;
		
		float tyrepeat = 1;

    // cartesian circle equation
    float sphere_radius_squared = sphere_radius * sphere_radius;
    float sh_radius = de * (sphere_radius * 2) - sphere_radius;
    float xc_off = sqrt(sphere_radius_squared - sh_radius*sh_radius);
    
    float final_x;
    float final_y = yoff + de * (sphere_radius * 2); //+ sin((de * 360 + 180) * (PI / 180) + xmotion / 24.) * 4;
    
    for (int e = 0; e < (int)xc_off; e += dots_step) {
      float dd = (float)e / xc_off;
			
			float ddd = sin((dd * 180) * (PI / 180));

      final_x = xoff - xc_off + xc_off * dd * 2;// + cos((de * 360 + 180) * (PI / 180) + xmotion / 24.) * 4;
      
      float yc_off;
      
      // compute UV texels for the colormap
      if (dd > 0.5) {
        yc_off = sqrt(1 - dd*dd) + 1.270;
      } else {
        float dd2 = 1 - dd;
        
        yc_off = 1-sqrt(1 - dd2*dd2);
      }
      
      // apply colormaps
      float xrepeat = 0.5;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + 180)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      float final_r = r;
      float final_g = g;
      float final_b = b;
      
      // some compositing 
      fill(final_r, final_g, final_b, random(0, 255) * ddd);//r * (r2 / 255) + r * bright, g * (g2 / 255) + g * bright, b * (b2 / 255) + b * bright);
      
      //rect(final_x, final_y, rect_size, rect_size);
      rect(final_x, final_y, rect_size + 4 * ddd, rect_size + random(4, 40) * ddd);
    }
  }
	
	int i = 0;
  for (int y = 0; y < 480; y += iter_step_y) {
		float yn = y / 480;
		int yi = y * 480;
		
		for (int x = 0; x < 640; x += iter_step_x) {
			int p = pixels[x + yi];
			
			float pbr = brightness(p);

			if (pbr > 0) {
				float pr = red(p);
				float pg = green(p);
				float pb = blue(p);
				
				float xn = x / 640;
				float inn = i / (640 * 480);
				
				float pbn = pbr / 255;
				
				float r = pr * (abs(sin(((pr / 255) * 360) * (PI / 180) * PI + xmotion * pbn)));
				float g = pg * (abs(sin(((pg / 255) * 360) * (PI / 180) * PI + xmotion)));
				float b = pb * (abs(cos(((pb / 255) * 360) * (PI / 180) * PI + ymotion)));

				fill(r, g, b, pr);
				ellipse(x + cos((pbn * 360) * (PI / 180) + xmotion) * (640/2 * pbn), y + sin((pbn * 360) * (PI / 180) * PI + ymotion) * (480/2 * pbn), 1 + random(8) + pbn, 1 + random(8));
			} else {
				fill(0, 0, 0, 8);
				rect(x, y, random(24), random(24))
			}
			
			i += 1;
		}
	}

  xmotion += xmotvel;
  ymotion += ymotvel;
  rmotion += rmotvel;
	
	if (rmotion > 32) {
			rmotion = -rmotion;
	}
	
	yy += rect_size / 4;
	
	rect_size += 0.05;
	
	if (yy >= 480) {
		rect_size = 1 + random(16);
	
		xmotvel = random(0.001, 1);
		ymotvel = random(0.001, 1);
		rmotvel = random(0.001, 1)
		
		xm_speed = random(0.01, 1);
		rect_size2 = 2 + random(8);
		
		yy = -rect_size;	
		
		xx += rect_size;
		
		if (xx > 640/2) {
			xx = 640/2;	
		}
		
		if (xx < 0) {
			xx = 640/2;	
		}
	}
}

void setup() {
  size(640, 480);

  frameRate(60); 
	
	colormap = loadImage(""allier.jpg"");

  background(0);
}

void draw() {
  //background(0);

  draw_func();
}"
"577480","Crystal Realism","mySketch","/**
 * A mix of ""Patterns"" and ""Blue planet"" sketchs with some try at doing some crystal ball things
 * allier.jpg is a vacation photo i took in 2017 at Monétay-sur-Allier, France
 */

PImage colormap;

// quality control
int dots_step = 2;
int elems_step = 1;

// same but look below, these are adjusted in real-time to increase rendering quality by abusing motion blur :)
int elems = 128;

float xmotion = 0;
float ymotion = 0;
float rmotion = 0;

float xmotvel = 0.01;
float ymotvel = 0.05;
float rmotvel = 0.25;

int bottom_elems_x = 110;
int left_elems_x = 110;
int elems_y = 112 / 2;
int elems_x_step = 1;
int elems_y_step = 1;
float yy = 0;
float xx = 640 / 2;

int iter_step_x = 16;
int iter_step_y = 16;

int rect_size = 4;
int rect_size2 = 1;

float xm_speed = 1.;

void draw_func() {
  fill(0, 0, 0, 2);
  rect(0, 0, 640, 480);

  noStroke();
  
	for (int y = 0; y < 640/2; y += 1) {
		float off = y/16 + sin((((y + rmotion) / 32) * 360) * (PI / 180) + xmotion * xm_speed) + rmotion;

		float off3 = sin(((y / 32 + rmotion) * 360) * (PI / 180) + xmotion);
		
		if (y%2 == 0) {
			fill(255 - off3 * 255, 255 - off3 * 255, 255 - off3 * 255, 255);
		} else {
			fill(0, 0, 0, 128);
		}

		ellipse(xx/8 - (y/32 + off) * rect_size2, yy - (y/16.) * rect_size2, rect_size, rect_size);
		ellipse((xx - 640/2) + (y + off) * rect_size2, yy - y * rect_size2, rect_size, rect_size);
		ellipse(xx - (y/32 + off) * rect_size2, 480 / 2 - yy - y * rect_size2, rect_size, rect_size);
		ellipse((xx - 640/2) + (y + off) * rect_size2, 480 / 2 - yy - (y/16.) * rect_size2, rect_size, rect_size);
	}
	
	// kaleido
  loadPixels();
  for (int y = 0; y < 480 / 2; y++) {
    int iy = y * 640;
    int line_index = (480 - y - 1) * 640;
    
    for (int x = 0; x < 640 / 2; x++) {
      int ix = 640 - x - 1;
      
      int index = ((int(x) & 255) + (int(y) & 255) * 640);
     
      // flip images
      pixels[x + iy]          = pixels[index];
      pixels[ix + line_index] = pixels[index];
      pixels[ x + line_index] = pixels[index];
      pixels[ix + iy]         = pixels[index];
    }
  }
	updatePixels();
	
  float xoff = 640 / 2;
  
  float sphere_radius = 224;
  float yoff = 480 / 2 - sphere_radius;
	
  for (int s = 0; s < elems; s += elems_step) {
    float de = (float)s / elems;
		
    float bd = max((0.5-abs(de - 0.5)) * 4, 0.05);
    
    float yrepeat = 1;
    int yyd = (((int)(de * (colormap.height * yrepeat))%colormap.height)) * colormap.width;
		
		float tyrepeat = 1;

    // cartesian circle equation
    float sphere_radius_squared = sphere_radius * sphere_radius;
    float sh_radius = de * (sphere_radius * 2) - sphere_radius;
    float xc_off = sqrt(sphere_radius_squared - sh_radius*sh_radius);
    
    float final_x;
    float final_y = yoff + de * (sphere_radius * 2); //+ sin((de * 360 + 180) * (PI / 180) + xmotion / 24.) * 4;
    
    for (int e = 0; e < (int)xc_off; e += dots_step) {
      float dd = (float)e / xc_off;
			
			float ddd = sin((dd * 180) * (PI / 180));

      final_x = xoff - xc_off + xc_off * dd * 2;// + cos((de * 360 + 180) * (PI / 180) + xmotion / 24.) * 4;
      
      float yc_off;
      
      // compute UV texels for the colormap
      if (dd > 0.5) {
        yc_off = sqrt(1 - dd*dd) + 1.270;
      } else {
        float dd2 = 1 - dd;
        
        yc_off = 1-sqrt(1 - dd2*dd2);
      }
      
      // apply colormaps
      float xrepeat = 0.5;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + 180)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      float final_r = r;
      float final_g = g;
      float final_b = b;
      
      // some compositing 
      fill(final_r, final_g, final_b, random(0, 255) * ddd);//r * (r2 / 255) + r * bright, g * (g2 / 255) + g * bright, b * (b2 / 255) + b * bright);
      
      //rect(final_x, final_y, rect_size, rect_size);
      rect(final_x, final_y, rect_size + 4 * ddd, rect_size + random(4, 40) * ddd);
    }
  }
	
	int i = 0;
  for (int y = 0; y < 480; y += iter_step_y) {
		float yn = y / 480;
		int yi = y * 480;
		
		for (int x = 0; x < 640; x += iter_step_x) {
			int p = pixels[x + yi];
			
			float pbr = brightness(p);

			if (pbr > 0) {
				float pr = red(p);
				float pg = green(p);
				float pb = blue(p);
				
				float xn = x / 640;
				float inn = i / (640 * 480);
				
				float pbn = pbr / 255;
				
				float r = pr * (abs(sin(((pr / 255) * 360) * (PI / 180) * PI + xmotion * pbn)));
				float g = pg * (abs(sin(((pg / 255) * 360) * (PI / 180) * PI + xmotion)));
				float b = pb * (abs(cos(((pb / 255) * 360) * (PI / 180) * PI + ymotion)));

				fill(r, g, b, pr);
				ellipse(x + cos((pbn * 360) * (PI / 180) + xmotion) * (640/2 * pbn), y + sin((pbn * 360) * (PI / 180) * PI + ymotion) * (480/2 * pbn), 1 + random(8) + pbn, 1 + random(8));
			} else {
				fill(0, 0, 0, 8);
				rect(x, y, random(24), random(24))
			}
			
			i += 1;
		}
	}

  xmotion += xmotvel;
  ymotion += ymotvel;
  rmotion += rmotvel;
	
	if (rmotion > 32) {
			rmotion = -rmotion;
	}
	
	yy += rect_size / 4;
	
	rect_size += 0.05;
	
	if (yy >= 480) {
		rect_size = 1 + random(16);
	
		xmotvel = random(0.001, 1);
		ymotvel = random(0.001, 1);
		rmotvel = random(0.001, 1)
		
		xm_speed = random(0.01, 1);
		rect_size2 = 2 + random(8);
		
		yy = -rect_size;	
		
		xx += rect_size;
		
		if (xx > 640/2) {
			xx = 640/2;	
		}
		
		if (xx < 0) {
			xx = 640/2;	
		}
	}
}

void setup() {
  size(640, 480);

  frameRate(60); 
	
	colormap = loadImage(""allier.jpg"");

  background(0);
}

void draw() {
  //background(0);

  draw_func();
}"
"577480","Crystal Realism","mySketch","/**
 * A mix of ""Patterns"" and ""Blue planet"" sketchs with some try at doing some crystal ball things
 * allier.jpg is a vacation photo i took in 2017 at Monétay-sur-Allier, France
 */

PImage colormap;

// quality control
int dots_step = 2;
int elems_step = 1;

// same but look below, these are adjusted in real-time to increase rendering quality by abusing motion blur :)
int elems = 128;

float xmotion = 0;
float ymotion = 0;
float rmotion = 0;

float xmotvel = 0.01;
float ymotvel = 0.05;
float rmotvel = 0.25;

int bottom_elems_x = 110;
int left_elems_x = 110;
int elems_y = 112 / 2;
int elems_x_step = 1;
int elems_y_step = 1;
float yy = 0;
float xx = 640 / 2;

int iter_step_x = 16;
int iter_step_y = 16;

int rect_size = 4;
int rect_size2 = 1;

float xm_speed = 1.;

void draw_func() {
  fill(0, 0, 0, 2);
  rect(0, 0, 640, 480);

  noStroke();
  
	for (int y = 0; y < 640/2; y += 1) {
		float off = y/16 + sin((((y + rmotion) / 32) * 360) * (PI / 180) + xmotion * xm_speed) + rmotion;

		float off3 = sin(((y / 32 + rmotion) * 360) * (PI / 180) + xmotion);
		
		if (y%2 == 0) {
			fill(255 - off3 * 255, 255 - off3 * 255, 255 - off3 * 255, 255);
		} else {
			fill(0, 0, 0, 128);
		}

		ellipse(xx/8 - (y/32 + off) * rect_size2, yy - (y/16.) * rect_size2, rect_size, rect_size);
		ellipse((xx - 640/2) + (y + off) * rect_size2, yy - y * rect_size2, rect_size, rect_size);
		ellipse(xx - (y/32 + off) * rect_size2, 480 / 2 - yy - y * rect_size2, rect_size, rect_size);
		ellipse((xx - 640/2) + (y + off) * rect_size2, 480 / 2 - yy - (y/16.) * rect_size2, rect_size, rect_size);
	}
	
	// kaleido
  loadPixels();
  for (int y = 0; y < 480 / 2; y++) {
    int iy = y * 640;
    int line_index = (480 - y - 1) * 640;
    
    for (int x = 0; x < 640 / 2; x++) {
      int ix = 640 - x - 1;
      
      int index = ((int(x) & 255) + (int(y) & 255) * 640);
     
      // flip images
      pixels[x + iy]          = pixels[index];
      pixels[ix + line_index] = pixels[index];
      pixels[ x + line_index] = pixels[index];
      pixels[ix + iy]         = pixels[index];
    }
  }
	updatePixels();
	
  float xoff = 640 / 2;
  
  float sphere_radius = 224;
  float yoff = 480 / 2 - sphere_radius;
	
  for (int s = 0; s < elems; s += elems_step) {
    float de = (float)s / elems;
		
    float bd = max((0.5-abs(de - 0.5)) * 4, 0.05);
    
    float yrepeat = 1;
    int yyd = (((int)(de * (colormap.height * yrepeat))%colormap.height)) * colormap.width;
		
		float tyrepeat = 1;

    // cartesian circle equation
    float sphere_radius_squared = sphere_radius * sphere_radius;
    float sh_radius = de * (sphere_radius * 2) - sphere_radius;
    float xc_off = sqrt(sphere_radius_squared - sh_radius*sh_radius);
    
    float final_x;
    float final_y = yoff + de * (sphere_radius * 2); //+ sin((de * 360 + 180) * (PI / 180) + xmotion / 24.) * 4;
    
    for (int e = 0; e < (int)xc_off; e += dots_step) {
      float dd = (float)e / xc_off;
			
			float ddd = sin((dd * 180) * (PI / 180));

      final_x = xoff - xc_off + xc_off * dd * 2;// + cos((de * 360 + 180) * (PI / 180) + xmotion / 24.) * 4;
      
      float yc_off;
      
      // compute UV texels for the colormap
      if (dd > 0.5) {
        yc_off = sqrt(1 - dd*dd) + 1.270;
      } else {
        float dd2 = 1 - dd;
        
        yc_off = 1-sqrt(1 - dd2*dd2);
      }
      
      // apply colormaps
      float xrepeat = 0.5;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + 180)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      float final_r = r;
      float final_g = g;
      float final_b = b;
      
      // some compositing 
      fill(final_r, final_g, final_b, random(0, 255) * ddd);//r * (r2 / 255) + r * bright, g * (g2 / 255) + g * bright, b * (b2 / 255) + b * bright);
      
      //rect(final_x, final_y, rect_size, rect_size);
      rect(final_x, final_y, rect_size + 4 * ddd, rect_size + random(4, 40) * ddd);
    }
  }
	
	int i = 0;
  for (int y = 0; y < 480; y += iter_step_y) {
		float yn = y / 480;
		int yi = y * 480;
		
		for (int x = 0; x < 640; x += iter_step_x) {
			int p = pixels[x + yi];
			
			float pbr = brightness(p);

			if (pbr > 0) {
				float pr = red(p);
				float pg = green(p);
				float pb = blue(p);
				
				float xn = x / 640;
				float inn = i / (640 * 480);
				
				float pbn = pbr / 255;
				
				float r = pr * (abs(sin(((pr / 255) * 360) * (PI / 180) * PI + xmotion * pbn)));
				float g = pg * (abs(sin(((pg / 255) * 360) * (PI / 180) * PI + xmotion)));
				float b = pb * (abs(cos(((pb / 255) * 360) * (PI / 180) * PI + ymotion)));

				fill(r, g, b, pr);
				ellipse(x + cos((pbn * 360) * (PI / 180) + xmotion) * (640/2 * pbn), y + sin((pbn * 360) * (PI / 180) * PI + ymotion) * (480/2 * pbn), 1 + random(8) + pbn, 1 + random(8));
			} else {
				fill(0, 0, 0, 8);
				rect(x, y, random(24), random(24))
			}
			
			i += 1;
		}
	}

  xmotion += xmotvel;
  ymotion += ymotvel;
  rmotion += rmotvel;
	
	if (rmotion > 32) {
			rmotion = -rmotion;
	}
	
	yy += rect_size / 4;
	
	rect_size += 0.05;
	
	if (yy >= 480) {
		rect_size = 1 + random(16);
	
		xmotvel = random(0.001, 1);
		ymotvel = random(0.001, 1);
		rmotvel = random(0.001, 1)
		
		xm_speed = random(0.01, 1);
		rect_size2 = 2 + random(8);
		
		yy = -rect_size;	
		
		xx += rect_size;
		
		if (xx > 640/2) {
			xx = 640/2;	
		}
		
		if (xx < 0) {
			xx = 640/2;	
		}
	}
}

void setup() {
  size(640, 480);

  frameRate(60); 
	
	colormap = loadImage(""allier.jpg"");

  background(0);
}

void draw() {
  //background(0);

  draw_func();
}"
"577480","Crystal Realism","mySketch","/**
 * A mix of ""Patterns"" and ""Blue planet"" sketchs with some try at doing some crystal ball things
 * allier.jpg is a vacation photo i took in 2017 at Monétay-sur-Allier, France
 */

PImage colormap;

// quality control
int dots_step = 2; // decrease this for photo quality
int elems_step = 1;

// increase this for photo quality
int elems = 128;

float xmotion = 0;
float ymotion = 0;
float rmotion = 0;

float xmotvel = 0.01;
float ymotvel = 0.05;
float rmotvel = 0.25;

int bottom_elems_x = 110;
int left_elems_x = 110;
int elems_y = 112 / 2;
int elems_x_step = 1;
int elems_y_step = 1;
float yy = 0;
float xx = 640 / 2;

int iter_step_x = 16;
int iter_step_y = 16;

int rect_size = 4;
int rect_size2 = 1;

float xm_speed = 1.;

void draw_func() {
  fill(0, 0, 0, 2);
  rect(0, 0, 640, 480);

  noStroke();
  
	for (int y = 0; y < 640/2; y += 1) {
		float off = y/16 + sin((((y + rmotion) / 32) * 360) * (PI / 180) + xmotion * xm_speed) + rmotion;

		float off3 = sin(((y / 32 + rmotion) * 360) * (PI / 180) + xmotion);
		
		if (y%2 == 0) {
			fill(255 - off3 * 255, 255 - off3 * 255, 255 - off3 * 255, 255);
		} else {
			fill(0, 0, 0, 128);
		}

		ellipse(xx/8 - (y/32 + off) * rect_size2, yy - (y/16.) * rect_size2, rect_size, rect_size);
		ellipse((xx - 640/2) + (y + off) * rect_size2, yy - y * rect_size2, rect_size, rect_size);
		ellipse(xx - (y/32 + off) * rect_size2, 480 / 2 - yy - y * rect_size2, rect_size, rect_size);
		ellipse((xx - 640/2) + (y + off) * rect_size2, 480 / 2 - yy - (y/16.) * rect_size2, rect_size, rect_size);
	}
	
	// kaleido
  loadPixels();
  for (int y = 0; y < 480 / 2; y++) {
    int iy = y * 640;
    int line_index = (480 - y - 1) * 640;
    
    for (int x = 0; x < 640 / 2; x++) {
      int ix = 640 - x - 1;
      
      int index = ((int(x) & 255) + (int(y) & 255) * 640);
     
      // flip images
      pixels[x + iy]          = pixels[index];
      pixels[ix + line_index] = pixels[index];
      pixels[ x + line_index] = pixels[index];
      pixels[ix + iy]         = pixels[index];
    }
  }
	updatePixels();
	
  float xoff = 640 / 2;
  
  float sphere_radius = 224;
  float yoff = 480 / 2 - sphere_radius;
	
  for (int s = 0; s < elems; s += elems_step) {
    float de = (float)s / elems;
		
    float bd = max((0.5-abs(de - 0.5)) * 4, 0.05);
    
    float yrepeat = 1;
    int yyd = (((int)(de * (colormap.height * yrepeat))%colormap.height)) * colormap.width;
		
		float tyrepeat = 1;

    // cartesian circle equation
    float sphere_radius_squared = sphere_radius * sphere_radius;
    float sh_radius = de * (sphere_radius * 2) - sphere_radius;
    float xc_off = sqrt(sphere_radius_squared - sh_radius*sh_radius);
    
    float final_x;
    float final_y = yoff + de * (sphere_radius * 2); //+ sin((de * 360 + 180) * (PI / 180) + xmotion / 24.) * 4;
    
    for (int e = 0; e < (int)xc_off; e += dots_step) {
      float dd = (float)e / xc_off;
			
			float ddd = sin((dd * 180) * (PI / 180));

      final_x = xoff - xc_off + xc_off * dd * 2;// + cos((de * 360 + 180) * (PI / 180) + xmotion / 24.) * 4;
      
      float yc_off;
      
      // compute UV texels for the colormap
      if (dd > 0.5) {
        yc_off = sqrt(1 - dd*dd) + 1.270;
      } else {
        float dd2 = 1 - dd;
        
        yc_off = 1-sqrt(1 - dd2*dd2);
      }
      
      // apply colormaps
      float xrepeat = 0.5;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + 180)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      float final_r = r;
      float final_g = g;
      float final_b = b;
      
      // some compositing 
      fill(final_r, final_g, final_b, random(0, 255) * ddd);//r * (r2 / 255) + r * bright, g * (g2 / 255) + g * bright, b * (b2 / 255) + b * bright);
      
      //rect(final_x, final_y, rect_size, rect_size);
      rect(final_x, final_y, rect_size + 4 * ddd, rect_size + random(4, 40) * ddd);
    }
  }
	
	int i = 0;
  for (int y = 0; y < 480; y += iter_step_y) {
		float yn = y / 480;
		int yi = y * 480;
		
		for (int x = 0; x < 640; x += iter_step_x) {
			int p = pixels[x + yi];
			
			float pbr = brightness(p);

			if (pbr > 0) {
				float pr = red(p);
				float pg = green(p);
				float pb = blue(p);
				
				float xn = x / 640;
				float inn = i / (640 * 480);
				
				float pbn = pbr / 255;
				
				float r = pr * (abs(sin(((pr / 255) * 360) * (PI / 180) * PI + xmotion * pbn)));
				float g = pg * (abs(sin(((pg / 255) * 360) * (PI / 180) * PI + xmotion)));
				float b = pb * (abs(cos(((pb / 255) * 360) * (PI / 180) * PI + ymotion)));

				fill(r, g, b, pr);
				ellipse(x + cos((pbn * 360) * (PI / 180) + xmotion) * (640/2 * pbn), y + sin((pbn * 360) * (PI / 180) * PI + ymotion) * (480/2 * pbn), 1 + random(8) + pbn, 1 + random(8));
			} else {
				fill(0, 0, 0, 8);
				rect(x, y, random(24), random(24))
			}
			
			i += 1;
		}
	}

  xmotion += xmotvel;
  ymotion += ymotvel;
  rmotion += rmotvel;
	
	if (rmotion > 32) {
			rmotion = -rmotion;
	}
	
	yy += rect_size / 4;
	
	rect_size += 0.05;
	
	if (yy >= 480) {
		rect_size = 1 + random(16);
	
		xmotvel = random(0.001, 1);
		ymotvel = random(0.001, 1);
		rmotvel = random(0.001, 1)
		
		xm_speed = random(0.01, 1);
		rect_size2 = 2 + random(8);
		
		yy = -rect_size;	
		
		xx += rect_size;
		
		if (xx > 640/2) {
			xx = 640/2;	
		}
		
		if (xx < 0) {
			xx = 640/2;	
		}
	}
}

void setup() {
  size(640, 480);

  frameRate(60); 
	
	colormap = loadImage(""allier.jpg"");

  background(0);
}

void draw() {
  //background(0);

  draw_func();
}"
"577480","Crystal Realism","mySketch","/**
 * A mix of ""Patterns"" and ""Blue planet"" sketchs with some try at doing some crystal ball things
 * allier.jpg is a vacation photo i took in 2017 at Monétay-sur-Allier, France
 */

PImage colormap;

// quality control
int dots_step = 2; // decrease this for photo quality
int elems_step = 1;

// increase this for photo quality
int elems = 128;

float xmotion = 0;
float ymotion = 0;
float rmotion = 0;

float xmotvel = 0.01;
float ymotvel = 0.05;
float rmotvel = 0.25;

int bottom_elems_x = 110;
int left_elems_x = 110;
int elems_y = 112 / 2;
int elems_x_step = 1;
int elems_y_step = 1;
float yy = 0;
float xx = 640 / 2;

int iter_step_x = 16;
int iter_step_y = 16;

int rect_size = 4;
int rect_size2 = 1;

float xm_speed = 1.;

void draw_func() {
  fill(0, 0, 0, 4);
  rect(0, 0, 640, 480);

  noStroke();
  
	for (int y = 0; y < 640/2; y += 1) {
		float off = y/16 + sin((((y + rmotion) / 32) * 360) * (PI / 180) + xmotion * xm_speed) + rmotion;

		float off3 = sin(((y / 32 + rmotion) * 360) * (PI / 180) + xmotion);
		
		if (y%2 == 0) {
			fill(255 - off3 * 255, 255 - off3 * 255, 255 - off3 * 255, 255);
		} else {
			fill(0, 0, 0, 128);
		}

		ellipse(xx/8 - (y/32 + off) * rect_size2, yy - (y/16.) * rect_size2, rect_size, rect_size);
		ellipse((xx - 640/2) + (y + off) * rect_size2, yy - y * rect_size2, rect_size, rect_size);
		ellipse(xx - (y/32 + off) * rect_size2, 480 / 2 - yy - y * rect_size2, rect_size, rect_size);
		ellipse((xx - 640/2) + (y + off) * rect_size2, 480 / 2 - yy - (y/16.) * rect_size2, rect_size, rect_size);
	}
	
	// kaleido
  loadPixels();
  for (int y = 0; y < 480 / 2; y++) {
    int iy = y * 640;
    int line_index = (480 - y - 1) * 640;
    
    for (int x = 0; x < 640 / 2; x++) {
      int ix = 640 - x - 1;
      
      int index = ((int(x) & 255) + (int(y) & 255) * 640);
     
      // flip images
      pixels[x + iy]          = pixels[index];
      pixels[ix + line_index] = pixels[index];
      pixels[ x + line_index] = pixels[index];
      pixels[ix + iy]         = pixels[index];
    }
  }
	updatePixels();
	
  float xoff = 640 / 2;
  
  float sphere_radius = 224;
  float yoff = 480 / 2 - sphere_radius;
	
  for (int s = 0; s < elems; s += elems_step) {
    float de = (float)s / elems;
		
    float bd = max((0.5-abs(de - 0.5)) * 4, 0.05);
    
    float yrepeat = 1;
    int yyd = (((int)(de * (colormap.height * yrepeat))%colormap.height)) * colormap.width;
		
		float tyrepeat = 1;

    // cartesian circle equation
    float sphere_radius_squared = sphere_radius * sphere_radius;
    float sh_radius = de * (sphere_radius * 2) - sphere_radius;
    float xc_off = sqrt(sphere_radius_squared - sh_radius*sh_radius);
    
    float final_x;
    float final_y = yoff + de * (sphere_radius * 2); //+ sin((de * 360 + 180) * (PI / 180) + xmotion / 24.) * 4;
    
    for (int e = 0; e < (int)xc_off; e += dots_step) {
      float dd = (float)e / xc_off;
			
			float ddd = sin((dd * 180) * (PI / 180));

      final_x = xoff - xc_off + xc_off * dd * 2;// + cos((de * 360 + 180) * (PI / 180) + xmotion / 24.) * 4;
      
      float yc_off;
      
      // compute UV texels for the colormap
      if (dd > 0.5) {
        yc_off = sqrt(1 - dd*dd) + 1.270;
      } else {
        float dd2 = 1 - dd;
        
        yc_off = 1-sqrt(1 - dd2*dd2);
      }
      
      // apply colormaps
      float xrepeat = 0.5;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + 180)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      float final_r = r;
      float final_g = g;
      float final_b = b;
      
      // some compositing 
      fill(final_r, final_g, final_b, random(0, 255) * ddd);//r * (r2 / 255) + r * bright, g * (g2 / 255) + g * bright, b * (b2 / 255) + b * bright);
      
      //rect(final_x, final_y, rect_size, rect_size);
      rect(final_x, final_y, rect_size + 4 * ddd, rect_size + random(4, 40) * ddd);
    }
  }
	
	int i = 0;
  for (int y = 0; y < 480; y += iter_step_y) {
		float yn = y / 480;
		int yi = y * 480;
		
		for (int x = 0; x < 640; x += iter_step_x) {
			int p = pixels[x + yi];
			
			float pbr = brightness(p);

			if (pbr > 0) {
				float pr = red(p);
				float pg = green(p);
				float pb = blue(p);
				
				float xn = x / 640;
				float inn = i / (640 * 480);
				
				float pbn = pbr / 255;
				
				float r = pr * (abs(sin(((pr / 255) * 360) * (PI / 180) * PI + xmotion * pbn)));
				float g = pg * (abs(sin(((pg / 255) * 360) * (PI / 180) * PI + xmotion)));
				float b = pb * (abs(cos(((pb / 255) * 360) * (PI / 180) * PI + ymotion)));

				fill(r, g, b, pr);
				ellipse(x + cos((pbn * 360) * (PI / 180) + xmotion) * (640/2 * pbn), y + sin((pbn * 360) * (PI / 180) * PI + ymotion) * (480/2 * pbn), 1 + random(8) + pbn, 1 + random(8));
			} else {
				fill(0, 0, 0, 8);
				rect(x, y, random(24), random(24))
			}
			
			i += 1;
		}
	}

  xmotion += xmotvel;
  ymotion += ymotvel;
  rmotion += rmotvel;
	
	if (rmotion > 32) {
			rmotion = -rmotion;
	}
	
	yy += rect_size / 4;
	
	rect_size += 0.05;
	
	if (yy >= 480) {
		rect_size = 1 + random(16);
	
		xmotvel = random(0.001, 1);
		ymotvel = random(0.001, 1);
		rmotvel = random(0.001, 1)
		
		xm_speed = random(0.01, 1);
		rect_size2 = 2 + random(8);
		
		yy = -rect_size;	
		
		xx += rect_size;
		
		if (xx > 640/2) {
			xx = 640/2;	
		}
		
		if (xx < 0) {
			xx = 640/2;	
		}
	}
}

void setup() {
  size(640, 480);

  frameRate(60); 
	
	colormap = loadImage(""allier.jpg"");

  background(0);
}

void draw() {
  //background(0);

  draw_func();
}"
"576965","Tight patterns","mySketch","PImage colormap;
PImage door_texture;

float xmotion = 0;
float ymotion = 0;
float rmotion = 0;

float xmotvel = 0.01;
float ymotvel = 0.05;
float rmotvel = 0.25;

int bottom_elems_x = 110;
int left_elems_x = 110;
int elems_y = 112 / 2;
int elems_x_step = 1;
int elems_y_step = 1;
float yy = 0;
float xx = 640 / 2;

int iter_step_x = 16;
int iter_step_y = 16;

int rect_size = 4;
int rect_size2 = 1;

float xm_speed = 1.;

void draw_func() {
  fill(0, 0, 0, 1);
  rect(0, 0, 640, 480);

  noStroke();
  
	for (int y = 0; y < 640/2; y += 1) {
		float off = y/16 + sin((((y + rmotion) / 32) * 360) * (PI / 180) + xmotion * xm_speed) + rmotion;

		float off3 = sin(((y / 32 + rmotion) * 360) * (PI / 180) + xmotion);
		
		if (y%2 == 0) {
			fill(255 - off3 * 255, 255 - off3 * 255, 255 - off3 * 255, 255);
		} else {
			fill(0, 0, 0, 128);
		}

		ellipse(xx - (y/32 + off) * rect_size2, yy - (y/16.) * rect_size2, rect_size, rect_size);
		ellipse((xx - 640/2) + (y + off) * rect_size2, yy - y * rect_size2, rect_size, rect_size);
		ellipse(xx - (y/32 + off) * rect_size2, 480 / 2 - yy - y * rect_size2, rect_size, rect_size);
		ellipse((xx - 640/2) + (y + off) * rect_size2, 480 / 2 - yy - (y/16.) * rect_size2, rect_size, rect_size);
	}
	
	// kaleido
  loadPixels();
  for (int y = 0; y < 480 / 2; y++) {
    int iy = y * 640;
    int line_index = (480 - y - 1) * 640;
    
    for (int x = 0; x < 640 / 2; x++) {
      int ix = 640 - x - 1;
      
      int index = ((int(x) & 255) + (int(y) & 255) * 640);
     
      // flip images
      pixels[x + iy]          = pixels[index];
      pixels[ix + line_index] = pixels[index];
      pixels[ x + line_index] = pixels[index];
      pixels[ix + iy]         = pixels[index];
    }
  }
	updatePixels();
	
	int i = 0;
  for (int y = 0; y < 480; y += iter_step_y) {
		float yn = y / 480;
		int yi = y * 480;
		
		for (int x = 0; x < 640; x += iter_step_x) {
			int p = pixels[x + yi];
			
			float pbr = brightness(p);

			if (pbr > 16) {
				float pr = red(p);
				float pg = green(p);
				float pb = blue(p);
				
				float xn = x / 640;
				float inn = i / (640 * 480);
				
				float pbn = pbr / 255;
				
				float r = pr * (abs(sin(((pr / 255) * 360) * (PI / 180) * PI + xmotion * pbn)));
				float g = pg * (abs(sin(((pg / 255) * 360) * (PI / 180) * PI + xmotion)));
				float b = pb * (abs(cos(((pb / 255) * 360) * (PI / 180) * PI + ymotion)));

				fill(r, g, b, pr);
				ellipse(x + cos((pbn * 360) * (PI / 180) + xmotion) * (640/2 * pbn), y + sin((pbn * 360) * (PI / 180) * PI + ymotion) * (480/2 * pbn), 1 + random(8) + pbn, 1 + random(8));
			} else {
				fill(0, 0, 0, 32);
				rect(x, y, random(24), random(24))
			}
			
			i += 1;
		}
	}

  xmotion += xmotvel;
  ymotion += ymotvel;
  rmotion += rmotvel;
	
	if (rmotion > 32) {
			rmotion = -rmotion;
	}
	
	yy += rect_size / 4;
	
	rect_size += 0.05;
	
	if (yy >= 480) {
		rect_size = 1 + random(16);
	
		xmotvel = random(0.001, 1);
		ymotvel = random(0.001, 1);
		rmotvel = random(0.001, 1)
		
		xm_speed = random(0.01, 1);
		rect_size2 = 2 + random(8);
		
		yy = -rect_size;	
		
		xx += rect_size;
		
		if (xx > 640/2) {
			xx = 640/2;	
		}
		
		if (xx < 0) {
			xx = 640/2;	
		}
	}
}

void setup() {
  size(640, 480);

  frameRate(60); 

  background(0);
}

void draw() {
  //background(0);

  draw_func();
}"
"576965","Tight patterns","mySketch","PImage colormap;
PImage door_texture;

float xmotion = 0;
float ymotion = 0;
float rmotion = 0;

float xmotvel = 0.01;
float ymotvel = 0.05;
float rmotvel = 0.25;

int bottom_elems_x = 110;
int left_elems_x = 110;
int elems_y = 112 / 2;
int elems_x_step = 1;
int elems_y_step = 1;
float yy = 0;
float xx = 640 / 2;

int iter_step_x = 16;
int iter_step_y = 16;

int rect_size = 4;
int rect_size2 = 1;

float xm_speed = 1.;

void draw_func() {
  fill(0, 0, 0, 2);
  rect(0, 0, 640, 480);

  noStroke();
  
	for (int y = 0; y < 640/2; y += 1) {
		float off = y/16 + sin((((y + rmotion) / 32) * 360) * (PI / 180) + xmotion * xm_speed) + rmotion;

		float off3 = sin(((y / 32 + rmotion) * 360) * (PI / 180) + xmotion);
		
		if (y%2 == 0) {
			fill(255 - off3 * 255, 255 - off3 * 255, 255 - off3 * 255, 255);
		} else {
			fill(0, 0, 0, 128);
		}

		ellipse(xx - (y/32 + off) * rect_size2, yy - (y/16.) * rect_size2, rect_size, rect_size);
		ellipse((xx - 640/2) + (y + off) * rect_size2, yy - y * rect_size2, rect_size, rect_size);
		ellipse(xx - (y/32 + off) * rect_size2, 480 / 2 - yy - y * rect_size2, rect_size, rect_size);
		ellipse((xx - 640/2) + (y + off) * rect_size2, 480 / 2 - yy - (y/16.) * rect_size2, rect_size, rect_size);
	}
	
	// kaleido
  loadPixels();
  for (int y = 0; y < 480 / 2; y++) {
    int iy = y * 640;
    int line_index = (480 - y - 1) * 640;
    
    for (int x = 0; x < 640 / 2; x++) {
      int ix = 640 - x - 1;
      
      int index = ((int(x) & 255) + (int(y) & 255) * 640);
     
      // flip images
      pixels[x + iy]          = pixels[index];
      pixels[ix + line_index] = pixels[index];
      pixels[ x + line_index] = pixels[index];
      pixels[ix + iy]         = pixels[index];
    }
  }
	updatePixels();
	
	int i = 0;
  for (int y = 0; y < 480; y += iter_step_y) {
		float yn = y / 480;
		int yi = y * 480;
		
		for (int x = 0; x < 640; x += iter_step_x) {
			int p = pixels[x + yi];
			
			float pbr = brightness(p);

			if (pbr > 254) {
				float pr = red(p);
				float pg = green(p);
				float pb = blue(p);
				
				float xn = x / 640;
				float inn = i / (640 * 480);
				
				float pbn = pbr / 255;
				
				float r = pr * (abs(sin(((pr / 255) * 360) * (PI / 180) * PI + xmotion * pbn)));
				float g = pg * (abs(sin(((pg / 255) * 360) * (PI / 180) * PI + xmotion)));
				float b = pb * (abs(cos(((pb / 255) * 360) * (PI / 180) * PI + ymotion)));

				fill(r, g, b, pr);
				ellipse(x + cos((pbn * 360) * (PI / 180) + xmotion) * (640/2 * pbn), y + sin((pbn * 360) * (PI / 180) * PI + ymotion) * (480/2 * pbn), 1 + random(8) + pbn, 1 + random(8));
			} else {
				fill(0, 0, 0, 32);
				rect(x, y, random(24), random(24))
			}
			
			i += 1;
		}
	}

  xmotion += xmotvel;
  ymotion += ymotvel;
  rmotion += rmotvel;
	
	if (rmotion > 32) {
			rmotion = -rmotion;
	}
	
	yy += rect_size / 4;
	
	rect_size += 0.05;
	
	if (yy >= 480) {
		rect_size = 1 + random(16);
	
		xmotvel = random(0.001, 1);
		ymotvel = random(0.001, 1);
		rmotvel = random(0.001, 1)
		
		xm_speed = random(0.01, 1);
		rect_size2 = 2 + random(8);
		
		yy = -rect_size;	
		
		xx += rect_size;
		
		if (xx > 640/2) {
			xx = 640/2;	
		}
		
		if (xx < 0) {
			xx = 640/2;	
		}
	}
}

void setup() {
  size(640, 480);

  frameRate(60); 

  background(0);
}

void draw() {
  //background(0);

  draw_func();
}"
"576965","Tight patterns","mySketch","PImage colormap;
PImage door_texture;

float xmotion = 0;
float ymotion = 0;
float rmotion = 0;

float xmotvel = 0.01;
float ymotvel = 0.05;
float rmotvel = 0.25;

int bottom_elems_x = 110;
int left_elems_x = 110;
int elems_y = 112 / 2;
int elems_x_step = 1;
int elems_y_step = 1;
float yy = 0;
float xx = 640 / 2;

int iter_step_x = 16;
int iter_step_y = 16;

int rect_size = 4;
int rect_size2 = 1;

float xm_speed = 1.;

void draw_func() {
  fill(0, 0, 0, 2);
  rect(0, 0, 640, 480);

  noStroke();
  
	for (int y = 0; y < 640/2; y += 1) {
		float off = y/16 + sin((((y + rmotion) / 32) * 360) * (PI / 180) + xmotion * xm_speed) + rmotion;

		float off3 = sin(((y / 32 + rmotion) * 360) * (PI / 180) + xmotion);
		
		if (y%2 == 0) {
			fill(255 - off3 * 255, 255 - off3 * 255, 255 - off3 * 255, 255);
		} else {
			fill(0, 0, 0, 128);
		}

		ellipse(xx - (y/32 + off) * rect_size2, yy - (y/16.) * rect_size2, rect_size, rect_size);
		ellipse((xx - 640/2) + (y + off) * rect_size2, yy - y * rect_size2, rect_size, rect_size);
		ellipse(xx - (y/32 + off) * rect_size2, 480 / 2 - yy - y * rect_size2, rect_size, rect_size);
		ellipse((xx - 640/2) + (y + off) * rect_size2, 480 / 2 - yy - (y/16.) * rect_size2, rect_size, rect_size);
	}
	
	// kaleido
  loadPixels();
  for (int y = 0; y < 480 / 2; y++) {
    int iy = y * 640;
    int line_index = (480 - y - 1) * 640;
    
    for (int x = 0; x < 640 / 2; x++) {
      int ix = 640 - x - 1;
      
      int index = ((int(x) & 255) + (int(y) & 255) * 640);
     
      // flip images
      pixels[x + iy]          = pixels[index];
      pixels[ix + line_index] = pixels[index];
      pixels[ x + line_index] = pixels[index];
      pixels[ix + iy]         = pixels[index];
    }
  }
	updatePixels();
	
	int i = 0;
  for (int y = 0; y < 480; y += iter_step_y) {
		float yn = y / 480;
		int yi = y * 480;
		
		for (int x = 0; x < 640; x += iter_step_x) {
			int p = pixels[x + yi];
			
			float pbr = brightness(p);

			if (pbr > 254) {
				float pr = red(p);
				float pg = green(p);
				float pb = blue(p);
				
				float xn = x / 640;
				float inn = i / (640 * 480);
				
				float pbn = pbr / 255;
				
				float r = pr * (abs(sin(((pr / 255) * 360) * (PI / 180) * PI + xmotion * pbn)));
				float g = pg * (abs(sin(((pg / 255) * 360) * (PI / 180) * PI + xmotion)));
				float b = pb * (abs(cos(((pb / 255) * 360) * (PI / 180) * PI + ymotion)));

				fill(r, g, b, pr);
				ellipse(x + cos((pbn * 360) * (PI / 180) + xmotion) * (640/2 * pbn), y + sin((pbn * 360) * (PI / 180) * PI + ymotion) * (480/2 * pbn), 1 + random(8) + pbn, 1 + random(8));
			} else {
				fill(0, 0, 0, 32);
				rect(x, y, random(24), random(24))
			}
			
			i += 1;
		}
	}

  xmotion += xmotvel;
  ymotion += ymotvel;
  rmotion += rmotvel;
	
	if (rmotion > 32) {
			rmotion = -rmotion;
	}
	
	yy += rect_size / 4;
	
	rect_size += 0.05;
	
	if (yy >= 480) {
		rect_size = 1 + random(16);
	
		xmotvel = random(0.001, 1);
		ymotvel = random(0.001, 1);
		rmotvel = random(0.001, 1)
		
		xm_speed = random(0.01, 1);
		rect_size2 = 2 + random(8);
		
		yy = -rect_size;	
		
		xx += rect_size;
		
		if (xx > 640/2) {
			xx = 640/2;	
		}
		
		if (xx < 0) {
			xx = 640/2;	
		}
	}
}

void setup() {
  size(640, 480);

  frameRate(60); 

  background(0);
}

void draw() {
  //background(0);

  draw_func();
}"
"576965","Tight patterns","mySketch","PImage colormap;
PImage door_texture;

float xmotion = 0;
float ymotion = 0;
float rmotion = 0;

float xmotvel = 0.01;
float ymotvel = 0.05;
float rmotvel = 0.25;

int bottom_elems_x = 110;
int left_elems_x = 110;
int elems_y = 112 / 2;
int elems_x_step = 1;
int elems_y_step = 1;
float yy = 0;
float xx = 640 / 2;

int iter_step_x = 16;
int iter_step_y = 16;

int rect_size = 4;
int rect_size2 = 1;

float xm_speed = 1.;

void draw_func() {
  fill(0, 0, 0, 2);
  rect(0, 0, 640, 480);

  noStroke();
  
	for (int y = 0; y < 640/2; y += 1) {
		float off = y/16 + sin((((y + rmotion) / 32) * 360) * (PI / 180) + xmotion * xm_speed) + rmotion;

		float off3 = sin(((y / 32 + rmotion) * 360) * (PI / 180) + xmotion);
		
		if (y%2 == 0) {
			fill(255 - off3 * 255, 255 - off3 * 255, 255 - off3 * 255, 255);
		} else {
			fill(0, 0, 0, 128);
		}

		ellipse(xx/8 - (y/32 + off) * rect_size2, yy - (y/16.) * rect_size2, rect_size, rect_size);
		ellipse((xx - 640/2) + (y + off) * rect_size2, yy - y * rect_size2, rect_size, rect_size);
		ellipse(xx - (y/32 + off) * rect_size2, 480 / 2 - yy - y * rect_size2, rect_size, rect_size);
		ellipse((xx - 640/2) + (y + off) * rect_size2, 480 / 2 - yy - (y/16.) * rect_size2, rect_size, rect_size);
	}
	
	// kaleido
  loadPixels();
  for (int y = 0; y < 480 / 2; y++) {
    int iy = y * 640;
    int line_index = (480 - y - 1) * 640;
    
    for (int x = 0; x < 640 / 2; x++) {
      int ix = 640 - x - 1;
      
      int index = ((int(x) & 255) + (int(y) & 255) * 640);
     
      // flip images
      pixels[x + iy]          = pixels[index];
      pixels[ix + line_index] = pixels[index];
      pixels[ x + line_index] = pixels[index];
      pixels[ix + iy]         = pixels[index];
    }
  }
	updatePixels();
	
	int i = 0;
  for (int y = 0; y < 480; y += iter_step_y) {
		float yn = y / 480;
		int yi = y * 480;
		
		for (int x = 0; x < 640; x += iter_step_x) {
			int p = pixels[x + yi];
			
			float pbr = brightness(p);

			if (pbr > 254) {
				float pr = red(p);
				float pg = green(p);
				float pb = blue(p);
				
				float xn = x / 640;
				float inn = i / (640 * 480);
				
				float pbn = pbr / 255;
				
				float r = pr * (abs(sin(((pr / 255) * 360) * (PI / 180) * PI + xmotion * pbn)));
				float g = pg * (abs(sin(((pg / 255) * 360) * (PI / 180) * PI + xmotion)));
				float b = pb * (abs(cos(((pb / 255) * 360) * (PI / 180) * PI + ymotion)));

				fill(r, g, b, pr);
				ellipse(x + cos((pbn * 360) * (PI / 180) + xmotion) * (640/2 * pbn), y + sin((pbn * 360) * (PI / 180) * PI + ymotion) * (480/2 * pbn), 1 + random(8) + pbn, 1 + random(8));
			} else {
				fill(0, 0, 0, 32);
				rect(x, y, random(24), random(24))
			}
			
			i += 1;
		}
	}

  xmotion += xmotvel;
  ymotion += ymotvel;
  rmotion += rmotvel;
	
	if (rmotion > 32) {
			rmotion = -rmotion;
	}
	
	yy += rect_size / 4;
	
	rect_size += 0.05;
	
	if (yy >= 480) {
		rect_size = 1 + random(16);
	
		xmotvel = random(0.001, 1);
		ymotvel = random(0.001, 1);
		rmotvel = random(0.001, 1)
		
		xm_speed = random(0.01, 1);
		rect_size2 = 2 + random(8);
		
		yy = -rect_size;	
		
		xx += rect_size;
		
		if (xx > 640/2) {
			xx = 640/2;	
		}
		
		if (xx < 0) {
			xx = 640/2;	
		}
	}
}

void setup() {
  size(640, 480);

  frameRate(60); 

  background(0);
}

void draw() {
  //background(0);

  draw_func();
}"
"576818","Patterns","mySketch","PImage colormap;
PImage door_texture;

float xmotion = 0;
float ymotion = 0;
float rmotion = 0;

int bottom_elems_x = 110;
int left_elems_x = 110;
int elems_y = 112 / 2;
int elems_x_step = 1;
int elems_y_step = 1;
float yy = 0;
float xx = 0;

int iter_step_x = 4;
int iter_step_y = 4;

int rect_size = 4;
int rect_size2 = 16;

void draw_func() {
  fill(0, 0, 0, 2);
  rect(0, 0, 640, 480);

  noStroke();

  int tri_min_distance_center = 0;

  float bottom_part_x_start;
  float bottom_part_y_start = 480 / 2 + tri_min_distance_center;
  float bottom_part_x_step_inc = 0;
  float bottom_part_rect_size = 4;

  float left_part_x_start;
  float left_part_y_start;
  float left_part_y_step = 0;
  float left_part_x_step_inc = 0;
  float left_part_rect_size = 1;
  
  float y_offset = 172 / 2;
 
	fill(255, 255, 255, 255);
	for (int y = 0; y < 32; y += 1) {
		ellipse(xx + y * rect_size2, yy, rect_size, rect_size);
		ellipse(yy, xx + y * rect_size2, rect_size, rect_size);
		ellipse(640/2 - (xx + y * rect_size2), 480 - yy, rect_size, rect_size);
		ellipse(640/2 - yy, 480 - (xx + y * rect_size2), rect_size, rect_size);
	}
	
  loadPixels();
  for (int y = 0; y < 480; y += 1) {
    for (int x = 0; x < 640 / 2; x += 1) {
      int isrc = x + y * 640;
      int idst = (639 - x) + y * 640;
      pixels[idst] = pixels[isrc];
    }
  }
	updatePixels();

	int i = 0;
  for (int y = 0; y < 480; y += iter_step_y) {
		float yn = y / 480;
		int yi = y * 480;
		
		for (int x = 0; x < 640; x += iter_step_x) {
			int p = pixels[x + yi];
			
			float pbr = brightness(p);

			if (pbr == 255) {
				float pr = red(p);
				float pg = green(p);
				float pb = blue(p);
				
				float xn = x / 640;
				float inn = i / (640 * 480);
				
				float pbn = pbr / 255;
				
				float r = pr * (abs(sin(yn * PI + xmotion * pbn)));
				float g = pg * (abs(sin(xn * PI + xmotion)));
				float b = pb * (abs(cos(inn * PI + ymotion)));

				fill(r, g, b, pr);
				ellipse(x + cos((inn * 360) * (PI / 180) + xmotion) * random(-16, 16), y + sin((inn * 360) * (PI / 180) * PI + ymotion) * random(-16, 16), 8 + random(2), 8 + random(20));
			}
			
			i += 1;
		}
	}
  

  xmotion += 0.1;
  ymotion += 0.1;
  rmotion += 0.08;
	
	if (rmotion > 32) {
			rmotion = -rmotion;
	}
	
	yy += rect_size / 4;
	
	if (yy >= 480) {
		yy = -rect_size;	
		
		xx += rect_size;
		
		if (xx > 640/2) {
			xx = 0;	
		}
	}
}

void setup() {
  size(640, 480);

  frameRate(60); 

  colormap = loadImage(""data.jpg"");
  door_texture = loadImage(""door.jpg"");

  background(0);
}

void draw() {
  //background(0);

  draw_func();
}"
"576818","Patterns","mySketch","PImage colormap;
PImage door_texture;

float xmotion = 0;
float ymotion = 0;
float rmotion = 0;

float xmotvel = 0.01;
float ymotvel = 0.05;
float rmotvel = 0.25;

int bottom_elems_x = 110;
int left_elems_x = 110;
int elems_y = 112 / 2;
int elems_x_step = 1;
int elems_y_step = 1;
float yy = 0;
float xx = 640 / 2;

int iter_step_x = 16;
int iter_step_y = 16;

int rect_size = 4;
int rect_size2 = 1;

float xm_speed = 1.;

void draw_func() {
  fill(0, 0, 0, 1);
  rect(0, 0, 640, 480);

  noStroke();
  
	for (int y = 0; y < 32; y += 1) {
		float off = y + sin((((y + rmotion) / 32) * 360) * (PI / 180) + xmotion * xm_speed) + rmotion;

		float off3 = sin(((y / 32 + rmotion) * 360) * (PI / 180) + xmotion);
		
		if (y%2 == 0) {
			fill(255 - off3 * 255, 255 - off3 * 255, 255 - off3 * 255, 255);
		} else {
			fill(0, 0, 0, 128);
		}

		ellipse(xx - (y + off) * rect_size2, yy - y * rect_size2, rect_size, rect_size);
		ellipse((xx - 640/2) + (y + off) * rect_size2, yy - y * rect_size2, rect_size, rect_size);
		ellipse(xx - (y + off) * rect_size2, 480 / 2 - yy - y * rect_size2, rect_size, rect_size);
		ellipse((xx - 640/2) + (y + off) * rect_size2, 480 / 2 - yy - y * rect_size2, rect_size, rect_size);
	}
	
	// kaleido
  loadPixels();
  for (int y = 0; y < 480 / 2; y++) {
    int iy = y * 640;
    int line_index = (480 - y - 1) * 640;
    
    for (int x = 0; x < 640 / 2; x++) {
      int ix = 640 - x - 1;
      
      int index = ((int(x) & 255) + (int(y) & 255) * 640);
     
      // flip images
      pixels[x + iy]          = pixels[index];
      pixels[ix + line_index] = pixels[index];
      pixels[ x + line_index] = pixels[index];
      pixels[ix + iy]         = pixels[index];
    }
  }
	updatePixels();
	
	int i = 0;
  for (int y = 0; y < 480; y += iter_step_y) {
		float yn = y / 480;
		int yi = y * 480;
		
		for (int x = 0; x < 640; x += iter_step_x) {
			int p = pixels[x + yi];
			
			float pbr = brightness(p);

			if (pbr > 16) {
				float pr = red(p);
				float pg = green(p);
				float pb = blue(p);
				
				float xn = x / 640;
				float inn = i / (640 * 480);
				
				float pbn = pbr / 255;
				
				float r = pr * (abs(sin(((pr / 255) * 360) * (PI / 180) * PI + xmotion * pbn)));
				float g = pg * (abs(sin(((pg / 255) * 360) * (PI / 180) * PI + xmotion)));
				float b = pb * (abs(cos(((pb / 255) * 360) * (PI / 180) * PI + ymotion)));

				fill(r, g, b, pr);
				ellipse(x + cos((pbn * 360) * (PI / 180) + xmotion) * (640/2 * pbn), y + sin((pbn * 360) * (PI / 180) * PI + ymotion) * (480/2 * pbn), 1 + random(8) + pbn, 1 + random(8));
			} else {
				fill(0, 0, 0, 32);
				rect(x, y, random(24), random(24))
			}
			
			i += 1;
		}
	}

  xmotion += xmotvel;
  ymotion += ymotvel;
  rmotion += rmotvel;
	
	if (rmotion > 32) {
			rmotion = -rmotion;
	}
	
	yy += rect_size / 4;
	
	rect_size += 0.05;
	
	if (yy >= 480) {
		rect_size = 1 + random(16);
	
		xmotvel = random(0.001, 1);
		ymotvel = random(0.001, 1);
		rmotvel = random(0.001, 1)
		
		xm_speed = random(0.01, 1);
		rect_size2 = 2 + random(8);
		
		yy = -rect_size;	
		
		xx += rect_size;
		
		if (xx > 640/2) {
			xx = 640/2;	
		}
		
		if (xx < 0) {
			xx = 640/2;	
		}
	}
}

void setup() {
  size(640, 480);

  frameRate(60); 

  background(0);
}

void draw() {
  //background(0);

  draw_func();
}"
"576818","Patterns","mySketch","PImage colormap;
PImage door_texture;

float xmotion = 0;
float ymotion = 0;
float rmotion = 0;

float xmotvel = 0.01;
float ymotvel = 0.05;
float rmotvel = 0.25;

int bottom_elems_x = 110;
int left_elems_x = 110;
int elems_y = 112 / 2;
int elems_x_step = 1;
int elems_y_step = 1;
float yy = 0;
float xx = 640 / 2;

int iter_step_x = 16;
int iter_step_y = 16;

int rect_size = 4;
int rect_size2 = 1;

float xm_speed = 1.;

void draw_func() {
  fill(0, 0, 0, 1);
  rect(0, 0, 640, 480);

  noStroke();
  
	for (int y = 0; y < 32; y += 1) {
		float off = y + sin((((y + rmotion) / 32) * 360) * (PI / 180) + xmotion * xm_speed) + rmotion;

		float off3 = sin(((y / 32 + rmotion) * 360) * (PI / 180) + xmotion);
		
		if (y%2 == 0) {
			fill(255 - off3 * 255, 255 - off3 * 255, 255 - off3 * 255, 255);
		} else {
			fill(0, 0, 0, 128);
		}

		ellipse(xx - (y + off) * rect_size2, yy - y * rect_size2, rect_size, rect_size);
		ellipse((xx - 640/2) + (y + off) * rect_size2, yy - y * rect_size2, rect_size, rect_size);
		ellipse(xx - (y + off) * rect_size2, 480 / 2 - yy - y * rect_size2, rect_size, rect_size);
		ellipse((xx - 640/2) + (y + off) * rect_size2, 480 / 2 - yy - y * rect_size2, rect_size, rect_size);
	}
	
	// kaleido
  loadPixels();
  for (int y = 0; y < 480 / 2; y++) {
    int iy = y * 640;
    int line_index = (480 - y - 1) * 640;
    
    for (int x = 0; x < 640 / 2; x++) {
      int ix = 640 - x - 1;
      
      int index = ((int(x) & 255) + (int(y) & 255) * 640);
     
      // flip images
      pixels[x + iy]          = pixels[index];
      pixels[ix + line_index] = pixels[index];
      pixels[ x + line_index] = pixels[index];
      pixels[ix + iy]         = pixels[index];
    }
  }
	updatePixels();
	
	int i = 0;
  for (int y = 0; y < 480; y += iter_step_y) {
		float yn = y / 480;
		int yi = y * 480;
		
		for (int x = 0; x < 640; x += iter_step_x) {
			int p = pixels[x + yi];
			
			float pbr = brightness(p);

			if (pbr > 16) {
				float pr = red(p);
				float pg = green(p);
				float pb = blue(p);
				
				float xn = x / 640;
				float inn = i / (640 * 480);
				
				float pbn = pbr / 255;
				
				float r = pr * (abs(sin(((pr / 255) * 360) * (PI / 180) * PI + xmotion * pbn)));
				float g = pg * (abs(sin(((pg / 255) * 360) * (PI / 180) * PI + xmotion)));
				float b = pb * (abs(cos(((pb / 255) * 360) * (PI / 180) * PI + ymotion)));

				fill(r, g, b, pr);
				ellipse(x + cos((pbn * 360) * (PI / 180) + xmotion) * (640/2 * pbn), y + sin((pbn * 360) * (PI / 180) * PI + ymotion) * (480/2 * pbn), 1 + random(8) + pbn, 1 + random(8));
			} else {
				fill(0, 0, 0, 32);
				rect(x, y, random(24), random(24))
			}
			
			i += 1;
		}
	}

  xmotion += xmotvel;
  ymotion += ymotvel;
  rmotion += rmotvel;
	
	if (rmotion > 32) {
			rmotion = -rmotion;
	}
	
	yy += rect_size / 4;
	
	rect_size += 0.05;
	
	if (yy >= 480) {
		rect_size = 1 + random(16);
	
		xmotvel = random(0.001, 1);
		ymotvel = random(0.001, 1);
		rmotvel = random(0.001, 1)
		
		xm_speed = random(0.01, 1);
		rect_size2 = 2 + random(8);
		
		yy = -rect_size;	
		
		xx += rect_size;
		
		if (xx > 640/2) {
			xx = 640/2;	
		}
		
		if (xx < 0) {
			xx = 640/2;	
		}
	}
}

void setup() {
  size(640, 480);

  frameRate(60); 

  background(0);
}

void draw() {
  //background(0);

  draw_func();
}"
"576818","Patterns","mySketch","PImage colormap;
PImage door_texture;

float xmotion = 0;
float ymotion = 0;
float rmotion = 0;

float xmotvel = 0.01;
float ymotvel = 0.05;
float rmotvel = 0.25;

int bottom_elems_x = 110;
int left_elems_x = 110;
int elems_y = 112 / 2;
int elems_x_step = 1;
int elems_y_step = 1;
float yy = 0;
float xx = 640 / 2;

int iter_step_x = 16;
int iter_step_y = 16;

int rect_size = 4;
int rect_size2 = 1;

float xm_speed = 1.;

void draw_func() {
  fill(0, 0, 0, 1);
  rect(0, 0, 640, 480);

  noStroke();
  
	for (int y = 0; y < 32; y += 1) {
		float off = y + sin((((y + rmotion) / 32) * 360) * (PI / 180) + xmotion * xm_speed) + rmotion;

		float off3 = sin(((y / 32 + rmotion) * 360) * (PI / 180) + xmotion);
		
		if (y%2 == 0) {
			fill(255 - off3 * 255, 255 - off3 * 255, 255 - off3 * 255, 255);
		} else {
			fill(0, 0, 0, 128);
		}

		ellipse(xx - (y + off) * rect_size2, yy - y * rect_size2, rect_size, rect_size);
		ellipse((xx - 640/2) + (y + off) * rect_size2, yy - y * rect_size2, rect_size, rect_size);
		ellipse(xx - (y + off) * rect_size2, 480 / 2 - yy - y * rect_size2, rect_size, rect_size);
		ellipse((xx - 640/2) + (y + off) * rect_size2, 480 / 2 - yy - y * rect_size2, rect_size, rect_size);
	}
	
	// kaleido
  loadPixels();
  for (int y = 0; y < 480 / 2; y++) {
    int iy = y * 640;
    int line_index = (480 - y - 1) * 640;
    
    for (int x = 0; x < 640 / 2; x++) {
      int ix = 640 - x - 1;
      
      int index = ((int(x) & 255) + (int(y) & 255) * 640);
     
      // flip images
      pixels[x + iy]          = pixels[index];
      pixels[ix + line_index] = pixels[index];
      pixels[ x + line_index] = pixels[index];
      pixels[ix + iy]         = pixels[index];
    }
  }
	updatePixels();
	
	int i = 0;
  for (int y = 0; y < 480; y += iter_step_y) {
		float yn = y / 480;
		int yi = y * 480;
		
		for (int x = 0; x < 640; x += iter_step_x) {
			int p = pixels[x + yi];
			
			float pbr = brightness(p);

			if (pbr > 16) {
				float pr = red(p);
				float pg = green(p);
				float pb = blue(p);
				
				float xn = x / 640;
				float inn = i / (640 * 480);
				
				float pbn = pbr / 255;
				
				float r = pr * (abs(sin(((pr / 255) * 360) * (PI / 180) * PI + xmotion * pbn)));
				float g = pg * (abs(sin(((pg / 255) * 360) * (PI / 180) * PI + xmotion)));
				float b = pb * (abs(cos(((pb / 255) * 360) * (PI / 180) * PI + ymotion)));

				fill(r, g, b, pr);
				ellipse(x + cos((pbn * 360) * (PI / 180) + xmotion) * (640/2 * pbn), y + sin((pbn * 360) * (PI / 180) * PI + ymotion) * (480/2 * pbn), 1 + random(8) + pbn, 1 + random(8));
			} else {
				fill(0, 0, 0, 32);
				rect(x, y, random(24), random(24))
			}
			
			i += 1;
		}
	}

  xmotion += xmotvel;
  ymotion += ymotvel;
  rmotion += rmotvel;
	
	if (rmotion > 32) {
			rmotion = -rmotion;
	}
	
	yy += rect_size / 4;
	
	rect_size += 0.05;
	
	if (yy >= 480) {
		rect_size = 1 + random(16);
	
		xmotvel = random(0.001, 1);
		ymotvel = random(0.001, 1);
		rmotvel = random(0.001, 1)
		
		xm_speed = random(0.01, 1);
		rect_size2 = 2 + random(8);
		
		yy = -rect_size;	
		
		xx += rect_size;
		
		if (xx > 640/2) {
			xx = 640/2;	
		}
		
		if (xx < 0) {
			xx = 640/2;	
		}
	}
}

void setup() {
  size(640, 480);

  frameRate(60); 

  background(0);
}

void draw() {
  //background(0);

  draw_func();
}"
"576818","Patterns","mySketch","PImage colormap;
PImage door_texture;

float xmotion = 0;
float ymotion = 0;
float rmotion = 0;

float xmotvel = 0.01;
float ymotvel = 0.05;
float rmotvel = 0.25;

int bottom_elems_x = 110;
int left_elems_x = 110;
int elems_y = 112 / 2;
int elems_x_step = 1;
int elems_y_step = 1;
float yy = 0;
float xx = 640 / 2;

int iter_step_x = 16;
int iter_step_y = 16;

int rect_size = 4;
int rect_size2 = 1;

float xm_speed = 1.;

void draw_func() {
  fill(0, 0, 0, 1);
  rect(0, 0, 640, 480);

  noStroke();
  
	for (int y = 0; y < 32; y += 1) {
		float off = y + sin((((y + rmotion) / 32) * 360) * (PI / 180) + xmotion * xm_speed) + rmotion;

		float off3 = sin(((y / 32 + rmotion) * 360) * (PI / 180) + xmotion);
		
		if (y%2 == 0) {
			fill(255 - off3 * 255, 255 - off3 * 255, 255 - off3 * 255, 255);
		} else {
			fill(0, 0, 0, 128);
		}

		ellipse(xx - (y + off) * rect_size2, yy - y * rect_size2, rect_size, rect_size);
		ellipse((xx - 640/2) + (y + off) * rect_size2, yy - y * rect_size2, rect_size, rect_size);
		ellipse(xx - (y + off) * rect_size2, 480 / 2 - yy - y * rect_size2, rect_size, rect_size);
		ellipse((xx - 640/2) + (y + off) * rect_size2, 480 / 2 - yy - y * rect_size2, rect_size, rect_size);
	}
	
	// kaleido
  loadPixels();
  for (int y = 0; y < 480 / 2; y++) {
    int iy = y * 640;
    int line_index = (480 - y - 1) * 640;
    
    for (int x = 0; x < 640 / 2; x++) {
      int ix = 640 - x - 1;
      
      int index = ((int(x) & 255) + (int(y) & 255) * 640);
     
      // flip images
      pixels[x + iy]          = pixels[index];
      pixels[ix + line_index] = pixels[index];
      pixels[ x + line_index] = pixels[index];
      pixels[ix + iy]         = pixels[index];
    }
  }
	updatePixels();
	
	int i = 0;
  for (int y = 0; y < 480; y += iter_step_y) {
		float yn = y / 480;
		int yi = y * 480;
		
		for (int x = 0; x < 640; x += iter_step_x) {
			int p = pixels[x + yi];
			
			float pbr = brightness(p);

			if (pbr > 16) {
				float pr = red(p);
				float pg = green(p);
				float pb = blue(p);
				
				float xn = x / 640;
				float inn = i / (640 * 480);
				
				float pbn = pbr / 255;
				
				float r = pr * (abs(sin(((pr / 255) * 360) * (PI / 180) * PI + xmotion * pbn)));
				float g = pg * (abs(sin(((pg / 255) * 360) * (PI / 180) * PI + xmotion)));
				float b = pb * (abs(cos(((pb / 255) * 360) * (PI / 180) * PI + ymotion)));

				fill(r, g, b, pr);
				ellipse(x + cos((pbn * 360) * (PI / 180) + xmotion) * (640/2 * pbn), y + sin((pbn * 360) * (PI / 180) * PI + ymotion) * (480/2 * pbn), 1 + random(8) + pbn, 1 + random(8));
			} else {
				fill(0, 0, 0, 32);
				rect(x, y, random(24), random(24))
			}
			
			i += 1;
		}
	}

  xmotion += xmotvel;
  ymotion += ymotvel;
  rmotion += rmotvel;
	
	if (rmotion > 32) {
			rmotion = -rmotion;
	}
	
	yy += rect_size / 4;
	
	rect_size += 0.05;
	
	if (yy >= 480) {
		rect_size = 1 + random(16);
	
		xmotvel = random(0.001, 1);
		ymotvel = random(0.001, 1);
		rmotvel = random(0.001, 1)
		
		xm_speed = random(0.01, 1);
		rect_size2 = 2 + random(8);
		
		yy = -rect_size;	
		
		xx += rect_size;
		
		if (xx > 640/2) {
			xx = 640/2;	
		}
		
		if (xx < 0) {
			xx = 640/2;	
		}
	}
}

void setup() {
  size(640, 480);

  frameRate(60); 

  background(0);
}

void draw() {
  //background(0);

  draw_func();
}"
"570733","Spherical disintegration","mySketch","/**
  * Same approach as dots planet billboard snippet with ""correct"" rendering this time by splitting the filled circle in half and inverting the second half
  * There is one issue with gaps in the middle if let as-is, it is fixed by increasing the dot density as they approach the center, this however make the edges more blurry.
  */

PImage colormap;
PImage funmap;
PImage nightmap;
PImage cyclemap;

float xmotion = 0;
float ymotion = 0;

// quality control
int dots_step = 1;
int elems_step = 4;

// same but look below, these are adjusted in real-time to increase rendering quality by abusing motion blur :)
int elems = 292;
int rect_size = 4;

float atoms_enable_start = millis();
float atoms_enable_end = millis();

float[] atoms_y_vel = new float[800 * 600];
float[] atoms_y_offset = new float[800 * 600];
float[] atoms_y_base = new float[800 * 600];

void draw_planet() {
  float mx = mouseX / 1024.0;
  float my = mouseY / 1024.0;
  
  //elems_step = (int)(2.0 - mx * 1.0);
  //dots_step = (int)(1.0 + my * 1.0);

  // add some motion blur / brightness
  fill(0, 0, 0, 32);
  rect(0, 0, 800, 800);
  
  // here we take advantage of the motion blur to ""fill in the gap"" by adjusting each slices / frames, this increase rendering quality (altough it look hazy)
  //elems = (int)(92 + sin(xmotion / 24.) * 36);
  //rect_size = (int)(2 + abs(sin(xmotion / 84.)) * 4);
  
  noStroke();
  
  float xoff = 800 / 2;
  
  float sphere_radius = 292;
  float yoff = 600 / 2 - sphere_radius;
	
	int atom_index = 0;
  
  for (int s = 0; s < elems; s += elems_step) {
    float de = (float)s / elems;
    
    float bd = max((0.5-abs(de - 0.5)) * 4, 0.05);
    
    float yrepeat = 1;
    int yyd = (((int)(de * (colormap.height * yrepeat))%colormap.height)) * colormap.width;
    
    float tyrepeat = 4;

    int yydc = (((int)(de * (cyclemap.height * yrepeat))%cyclemap.height)) * cyclemap.width;
    
    // cartesian circle equation
    float sphere_radius_squared = sphere_radius * sphere_radius;
    float sh_radius = de * (sphere_radius * 2) - sphere_radius;
    float xc_off = sqrt(sphere_radius_squared - sh_radius*sh_radius);
    
    float final_x;
    float final_y = yoff + de * (sphere_radius * 2); // flabby planet bonus : + sin((de * 360 + 180) * (PI / 180) + ymotion / 24.) * 4;
    
    for (int e = 0; e <= (int)xc_off / 2; e += dots_step) {
      float dd = (float)e / xc_off;

			// / (dd+0.5) : shrinking near the center (otherwise : equal distribution of the dots)
      final_x = xoff - (xc_off) + (xc_off / (dd+0.5)) * abs(0.5-(dd+0.5)) * 2 ;
      
      float yc_off;
      
      // compute UV texels for the colormap
      float dd2 = 1 - dd;
        
      yc_off = 1-sqrt(1 - dd2*dd2);
      
      // apply colormaps
      float xrepeat = 0.5;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + xmotion)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      // second texture (text mask)
      float txrepeat = 1.;

      // third texture (night version), reuse the first texture UV since they are the same width/height
      int rn = (int)(red(nightmap.pixels[cl]));
      int gn = (int)(green(nightmap.pixels[cl]));
      int bn = (int)(blue(nightmap.pixels[cl]));
      
      // fourth texture (cycle mask), only use single component since it is black/white
      int xxdc = ((cyclemap.width - 1) - (int)(yc_off * (cyclemap.width * xrepeat) + xmotion * 4)%cyclemap.width);
      int clc = (int)xxdc + yydc;
      float rc = red(cyclemap.pixels[clc]) / 255;
      
      float final_r = r * rc + rn * (1 - rc);
      float final_g = g * rc + gn * (1 - rc);
      float final_b = b * rc + bn * (1 - rc);
      
      // some compositing 
      fill(final_r, final_g, final_b);
      
      rect(final_x, final_y + atoms_y_offset[atom_index], rect_size, rect_size);
			
			atom_index += 1;
    }
    
    for (int e = 0; e <= (int)xc_off / 2; e += dots_step) {
      float dd = (float)e / xc_off;

      final_x = xoff - (xc_off) + (xc_off-(xc_off / (dd+0.5)) * abs(0.5-(dd+0.5))) * 2;
      
      float yc_off;
      
      // compute UV texels for the colormap
      float dd2 = 1 - dd;
        
      yc_off = sqrt(1 - dd2*dd2) + 1.270;
      
      // apply colormaps
      float xrepeat = 0.5;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + xmotion)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      // second texture (text mask)
      float txrepeat = 1.;
      
      // third texture (night version), reuse the first texture UV since they are the same width/height
      int rn = (int)(red(nightmap.pixels[cl]));
      int gn = (int)(green(nightmap.pixels[cl]));
      int bn = (int)(blue(nightmap.pixels[cl]));
      
      // fourth texture (cycle mask), only use single component since it is black/white
      int xxdc = ((cyclemap.width - 1) - (int)(yc_off * (cyclemap.width * xrepeat) + xmotion * 4)%cyclemap.width);
      int clc = (int)xxdc + yydc;
      float rc = red(cyclemap.pixels[clc]) / 255;
      
      float final_r = r * rc + rn * (1 - rc);
      float final_g = g  * rc + gn * (1 - rc);
      float final_b = b * rc + bn * (1 - rc);
      
      // some compositing 
      fill(final_r, final_g, final_b);
      
      rect(final_x, final_y + atoms_y_offset[atom_index], rect_size, rect_size);
			
			atom_index += 1;
    }
  }
  
  xmotion += 0.5;
  ymotion -= 0.25;
	
	// select/enable atoms; displace them
	atoms_enable_end = millis();
	if ((atoms_enable_end - atoms_enable_start) > 10) {
		atoms_enable_start = millis();
		
		int enabled_atoms = (int)round(random(1, 800));
		for (int i = 0; i < enabled_atoms; i += 1) {
			int index_selection = round(random(0, 800*800));
			atoms_y_vel[index_selection] = random(0.5, 10);
		}
	}
	
	for (int i = 0; i < 800*800; i += 1) {
		if (atoms_y_vel[i] > 0.0 || atoms_y_vel[i] < 0.0) {
			if (atoms_y_offset[i] > sphere_radius) {
				atoms_y_vel[i] = -random(0.5, 10);
			}	
			
			if (atoms_y_offset[i] < 0) {
				atoms_y_vel[i] = random(0.5, 10);
			}	
			
			atoms_y_offset[i] += atoms_y_vel[i];
			
			atoms_y_vel[i] += pow(atoms_y_base[i], 2);
		
			atoms_y_base[i] += 0.01;
		}
	}
}

void setup() {
  size(800, 800);

  frameRate(60); 
  
  colormap = loadImage(""data.jpg"");
  funmap = loadImage(""data2.jpg"");
  nightmap = loadImage(""data_night.jpg"");
  cyclemap = loadImage(""data_cycle.jpg"");
	
	for (int i = 0; i < 800*800; i += 1) {
			atoms_y_offset[i] = 0;
			atoms_y_vel[i] = 0; //random(0, 0.25);
	}
  
  background(0);
}

void draw() {
  //background(0);
 
  draw_planet();
}"
"570733","Spherical disintegration","mySketch","/**
  * Same approach as dots planet billboard snippet with ""correct"" rendering this time by splitting the filled circle in half and inverting the second half
  * There is one issue with gaps in the middle if let as-is, it is fixed by increasing the dot density as they approach the center, this however make the edges more blurry.
  */

PImage colormap;
PImage cyclemap;

float xmotion = 0;
float ymotion = 0;

// quality control
int dots_step = 1;
int elems_step = 4;

// same but look below, these are adjusted in real-time to increase rendering quality by abusing motion blur :)
int elems = 292;
int rect_size = 4;

float atoms_enable_start = millis();
float atoms_enable_end = millis();

float[] atoms_y_vel = new float[800 * 600];
float[] atoms_y_offset = new float[800 * 600];
float[] atoms_y_base = new float[800 * 600];

void draw_planet() {
  float mx = mouseX / 1024.0;
  float my = mouseY / 1024.0;
  
  //elems_step = (int)(2.0 - mx * 1.0);
  //dots_step = (int)(1.0 + my * 1.0);

  // add some motion blur / brightness
  fill(0, 0, 0, 16);
  rect(0, 0, 800, 800);
  
  // here we take advantage of the motion blur to ""fill in the gap"" by adjusting each slices / frames, this increase rendering quality (altough it look hazy)
  //elems = (int)(92 + sin(xmotion / 24.) * 36);
  //rect_size = (int)(2 + abs(sin(xmotion / 84.)) * 4);
  
  noStroke();
  
  float xoff = 800 / 2;
  
  float sphere_radius = 292;
  float yoff = 600 / 2 - sphere_radius;
	
	int atom_index = 0;
  
  for (int s = 0; s < elems; s += elems_step) {
    float de = (float)s / elems;
    
    float bd = max((0.5-abs(de - 0.5)) * 4, 0.05);
    
    float yrepeat = 1;
    int yyd = (((int)(de * (colormap.height * yrepeat))%colormap.height)) * colormap.width;
    
    float tyrepeat = 1;

    int yydc = (((int)(de * (cyclemap.height * yrepeat))%cyclemap.height)) * cyclemap.width;
    
    // cartesian circle equation
    float sphere_radius_squared = sphere_radius * sphere_radius;
    float sh_radius = de * (sphere_radius * 2) - sphere_radius;
    float xc_off = sqrt(sphere_radius_squared - sh_radius*sh_radius);
    
    float final_x;
    float final_y = yoff + de * (sphere_radius * 2); // flabby planet bonus : + sin((de * 360 + 180) * (PI / 180) + ymotion / 24.) * 4;
    
    for (int e = 0; e <= (int)xc_off / 2; e += dots_step) {
      float dd = (float)e / xc_off;

			// / (dd+0.5) : shrinking near the center (otherwise : equal distribution of the dots)
      final_x = xoff - (xc_off) + (xc_off / (dd+0.5)) * abs(0.5-(dd+0.5)) * 2 ;
      
      float yc_off;
      
      // compute UV texels for the colormap
      float dd2 = 1 - dd;
        
      yc_off = 1-sqrt(1 - dd2*dd2);
      
      // apply colormaps
      float xrepeat = 0.5;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + xmotion)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      // second texture (text mask)
      float txrepeat = 1.;
      
      // fourth texture (cycle mask), only use single component since it is black/white
      int xxdc = ((cyclemap.width - 1) - (int)(yc_off * (cyclemap.width * xrepeat) + xmotion * 4)%cyclemap.width);
      int clc = (int)xxdc + yydc;
      float rc = red(cyclemap.pixels[clc]) / 255;
      
      float final_r = r * rc;
      float final_g = g * rc;
      float final_b = b * rc;
      
      // some compositing 
      fill(final_r, final_g, final_b);
      
      rect(final_x, final_y + atoms_y_offset[atom_index], rect_size, rect_size);
			
			atom_index += 1;
    }
    
    for (int e = 0; e <= (int)xc_off / 2; e += dots_step) {
      float dd = (float)e / xc_off;

      final_x = xoff - (xc_off) + (xc_off-(xc_off / (dd+0.5)) * abs(0.5-(dd+0.5))) * 2;
      
      float yc_off;
      
      // compute UV texels for the colormap
      float dd2 = 1 - dd;
        
      yc_off = sqrt(1 - dd2*dd2) + 1.270;
      
      // apply colormaps
      float xrepeat = 0.5;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + xmotion)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      // second texture (text mask)
      float txrepeat = 1.;
      
      // fourth texture (cycle mask), only use single component since it is black/white
      int xxdc = ((cyclemap.width - 1) - (int)(yc_off * (cyclemap.width * xrepeat) + xmotion * 4)%cyclemap.width);
      int clc = (int)xxdc + yydc;
      float rc = red(cyclemap.pixels[clc]) / 255;
      
      float final_r = r * rc;
      float final_g = g * rc;
      float final_b = b * rc;
      
      // some compositing 
      fill(final_r, final_g, final_b);
      
      rect(final_x, final_y + atoms_y_offset[atom_index], rect_size, rect_size);
			
			atom_index += 1;
    }
  }
  
  xmotion += 0.5;
  ymotion -= 0.25;
	
	// select/enable atoms; displace them
	atoms_enable_end = millis();
	if ((atoms_enable_end - atoms_enable_start) > 10) {
		atoms_enable_start = millis();
		
		int enabled_atoms = (int)round(random(1, 800));
		for (int i = 0; i < enabled_atoms; i += 1) {
			int index_selection = round(random(0, 800*800));
			atoms_y_vel[index_selection] = random(0.5, 10);
		}
	}
	
	for (int i = 0; i < 800*800; i += 1) {
		if (atoms_y_vel[i] > 0.0 || atoms_y_vel[i] < 0.0) {
			if (atoms_y_offset[i] > sphere_radius) {
				atoms_y_vel[i] = -random(0.5, 10);
			}	
			
			if (atoms_y_offset[i] < 0) {
				atoms_y_vel[i] = random(0.5, 10);
			}	
			
			atoms_y_offset[i] += atoms_y_vel[i];
			
			atoms_y_vel[i] += pow(atoms_y_base[i], 2);
		
			atoms_y_base[i] += 0.01;
		}
	}
}

void setup() {
  size(800, 800);

  frameRate(60); 
  
  colormap = loadImage(""data.jpg"");
  cyclemap = loadImage(""data_cycle.jpg"");
	
	for (int i = 0; i < 800*800; i += 1) {
			atoms_y_offset[i] = 0;
			atoms_y_vel[i] = 0; //random(0, 0.25);
	}
  
  background(0);
}

void draw() {
  //background(0);
 
  draw_planet();
}"
"570733","Spherical disintegration","mySketch","/**
  * Same approach as dots planet billboard snippet with ""correct"" rendering this time by splitting the filled circle in half and inverting the second half
  * There is one issue with gaps in the middle if let as-is, it is fixed by increasing the dot density as they approach the center, this however make the edges more blurry.
  */

PImage colormap;
PImage cyclemap;

float xmotion = 0;
float ymotion = 0;

// quality control
int dots_step = 1;
int elems_step = 4;

// same but look below, these are adjusted in real-time to increase rendering quality by abusing motion blur :)
int elems = 292;
int rect_size = 4;

float atoms_enable_start = millis();
float atoms_enable_end = millis();

float[] atoms_y_vel = new float[800 * 600];
float[] atoms_y_offset = new float[800 * 600];
float[] atoms_y_base = new float[800 * 600];

void draw_planet() {
  float mx = mouseX / 1024.0;
  float my = mouseY / 1024.0;
  
  //elems_step = (int)(2.0 - mx * 1.0);
  //dots_step = (int)(1.0 + my * 1.0);

  // add some motion blur / brightness
  fill(0, 0, 0, 64);
  rect(0, 0, 800, 900);
  
  // here we take advantage of the motion blur to ""fill in the gap"" by adjusting each slices / frames, this increase rendering quality (altough it look hazy)
  //elems = (int)(92 + sin(xmotion / 24.) * 36);
  //rect_size = (int)(2 + abs(sin(xmotion / 84.)) * 4);
  
  noStroke();
  
  float xoff = 800 / 2;
  
  float sphere_radius = 242;
  float yoff = 600 / 2 - sphere_radius;
	
	int atom_index = 0;
  
  for (int s = 0; s < elems; s += elems_step) {
    float de = (float)s / elems;
    
    float bd = max((0.5-abs(de - 0.5)) * 4, 0.05);
    
    float yrepeat = 1;
    int yyd = (((int)(de * (colormap.height * yrepeat))%colormap.height)) * colormap.width;
    
    float tyrepeat = 1;

    int yydc = (((int)(de * (cyclemap.height * yrepeat))%cyclemap.height)) * cyclemap.width;
    
    // cartesian circle equation
    float sphere_radius_squared = sphere_radius * sphere_radius;
    float sh_radius = de * (sphere_radius * 2) - sphere_radius;
    float xc_off = sqrt(sphere_radius_squared - sh_radius*sh_radius);
    
    float final_x;
    float final_y = yoff + de * (sphere_radius * 2); // flabby planet bonus : + sin((de * 360 + 180) * (PI / 180) + ymotion / 24.) * 4;
    
    for (int e = 0; e <= (int)xc_off / 2; e += dots_step) {
      float dd = (float)e / xc_off;

			// / (dd+0.5) : shrinking near the center (otherwise : equal distribution of the dots)
      final_x = xoff - (xc_off) + (xc_off / (dd+0.5)) * abs(0.5-(dd+0.5)) * 2 ;
      
      float yc_off;
      
      // compute UV texels for the colormap
      float dd2 = 1 - dd;
        
      yc_off = 1-sqrt(1 - dd2*dd2);
      
      // apply colormaps
      float xrepeat = 0.5;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + xmotion)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      // second texture (text mask)
      float txrepeat = 1.;
      
      // fourth texture (cycle mask), only use single component since it is black/white
      int xxdc = ((cyclemap.width - 1) - (int)(yc_off * (cyclemap.width * xrepeat) + ymotion * 4)%cyclemap.width);
      int clc = (int)xxdc + yydc;
      float rc = red(cyclemap.pixels[clc]) / 255;
      
      float final_r = r * rc * 2;
      float final_g = g * rc * 2;
      float final_b = b * rc * 2;
      
      // some compositing 
      fill(final_r, final_g, final_b);
      
      ellipse(final_x - atoms_y_offset[atom_index], final_y + atoms_y_offset[atom_index], rect_size, rect_size);
			
			atom_index += 1;
    }
    
    for (int e = 0; e <= (int)xc_off / 2; e += dots_step) {
      float dd = (float)e / xc_off;

      final_x = xoff - (xc_off) + (xc_off-(xc_off / (dd+0.5)) * abs(0.5-(dd+0.5))) * 2;
      
      float yc_off;
      
      // compute UV texels for the colormap
      float dd2 = 1 - dd;
        
      yc_off = sqrt(1 - dd2*dd2) + 1.270;
      
      // apply colormaps
      float xrepeat = 0.5;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + xmotion)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      // second texture (text mask)
      float txrepeat = 1.;
      
      // fourth texture (cycle mask), only use single component since it is black/white
      int xxdc = ((cyclemap.width - 1) - (int)(yc_off * (cyclemap.width * xrepeat) + (ymotion * 4))%cyclemap.width);
      int clc = (int)xxdc + yydc;
      float rc = red(cyclemap.pixels[clc]) / 255;
      
      float final_r = r * rc * 2;
      float final_g = g * rc * 2;
      float final_b = b * rc * 2;
      
      // some compositing 
      fill(final_r, final_g, final_b);
      
      ellipse(final_x + atoms_y_offset[atom_index], final_y + atoms_y_offset[atom_index], rect_size, rect_size);
			
			atom_index += 1;
    }
  }
  
  xmotion += 0.5;
  ymotion -= 1.25;
	
	// select/enable atoms; displace them
	atoms_enable_end = millis();
	if ((atoms_enable_end - atoms_enable_start) > 10) {
		atoms_enable_start = millis();
		
		int enabled_atoms = (int)round(random(1, 800));
		for (int i = 0; i < enabled_atoms; i += 1) {
			int index_selection = round(random(0, 800*800));
			atoms_y_vel[index_selection] = random(0.5, 10);
		}
	}
	
	for (int i = 0; i < 800*800; i += 1) {
		if (atoms_y_vel[i] > 0.0 || atoms_y_vel[i] < 0.0) {
			if (atoms_y_offset[i] > (sphere_radius * 1.5)) {
				atoms_y_vel[i] = -random(0.5, 10);
				atoms_y_base[i] = 0;
			}	
			
			if (atoms_y_offset[i] < 0) {
				atoms_y_vel[i] = random(0.5, 10);
				atoms_y_base[i] = 0;
			}	
			
			atoms_y_offset[i] += atoms_y_vel[i];
			
			atoms_y_vel[i] += pow(atoms_y_base[i], 2);
		
			atoms_y_base[i] += 0.01;
		}
	}
}

void setup() {
  size(800, 900);

  frameRate(60); 
  
  colormap = loadImage(""data.jpg"");
  cyclemap = loadImage(""data_cycle.jpg"");
	
	for (int i = 0; i < 800*800; i += 1) {
			atoms_y_offset[i] = 0;
			atoms_y_vel[i] = 0; //random(0, 0.25);
	}
  
  background(0);
}

void draw() {
  //background(0);
 
  draw_planet();
}"
"570733","Spherical disintegration","mySketch","/**
  * Same approach as dots planet billboard snippet with elements memory.
  */

PImage colormap;
PImage cyclemap;

float xmotion = 0;
float ymotion = 0;

// quality control
int dots_step = 1;
int elems_step = 2;

// same but look below, these are adjusted in real-time to increase rendering quality by abusing motion blur :)
int elems = 128;
int rect_size = 8;

float atoms_enable_start = millis();
float atoms_enable_end = millis();

float[] atoms_x_vel = new float[800 * 600];
float[] atoms_y_vel = new float[800 * 600];
float[] atoms_x_offset = new float[800 * 600];
float[] atoms_y_offset = new float[800 * 600];
float[] atoms_y_base = new float[800 * 600];

void draw_planet() {
  float mx = mouseX / 1024.0;
  float my = mouseY / 1024.0;
  
  //elems_step = (int)(2.0 - mx * 1.0);
  //dots_step = (int)(1.0 + my * 1.0);

  // add some motion blur / brightness
  fill(0, 0, 0, 8);
  rect(0, 0, 800, 900);
  
  // here we take advantage of the motion blur to ""fill in the gap"" by adjusting each slices / frames, this increase rendering quality (altough it look hazy)
  //elems = (int)(92 + sin(xmotion / 24.) * 36);
  //rect_size = (int)(2 + abs(sin(xmotion / 84.)) * 4);
  
  noStroke();
  
  float xoff = 800 / 2;
  
  float sphere_radius = 242;
  float yoff = 600 / 2 - sphere_radius;
	
	int atom_index = 0;
  
  for (int s = 0; s < elems; s += elems_step) {
    float de = (float)s / elems;
    
    float bd = max((0.5-abs(de - 0.5)) * 4, 0.05);
    
    float yrepeat = 1;
    int yyd = (((int)(de * (colormap.height * yrepeat))%colormap.height)) * colormap.width;
    
    float tyrepeat = 1;

    int yydc = (((int)(de * (cyclemap.height * yrepeat))%cyclemap.height)) * cyclemap.width;
    
    // cartesian circle equation
    float sphere_radius_squared = sphere_radius * sphere_radius;
    float sh_radius = de * (sphere_radius * 2) - sphere_radius;
    float xc_off = sqrt(sphere_radius_squared - sh_radius*sh_radius);
    
    float final_x;
    float final_y = yoff + de * (sphere_radius * 2); // flabby planet bonus : + sin((de * 360 + 180) * (PI / 180) + ymotion / 24.) * 4;
    
    for (int e = 0; e <= (int)xc_off / 2; e += dots_step) {
      float dd = (float)e / xc_off;

			// / (dd+0.5) : shrinking near the center (otherwise : equal distribution of the dots)
      final_x = xoff - (xc_off) + (xc_off / (dd+0.5)) * abs(0.5-(dd+0.5)) * 2 ;
      
      float yc_off;
      
      // compute UV texels for the colormap
      float dd2 = 1 - dd;
        
      yc_off = 1-sqrt(1 - dd2*dd2);
      
      // apply colormaps
      float xrepeat = 0.5;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + xmotion)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      // second texture (text mask)
      float txrepeat = 1.;
      
      // fourth texture (cycle mask), only use single component since it is black/white
      int xxdc = ((cyclemap.width - 1) - (int)(yc_off * (cyclemap.width * xrepeat) + ymotion * 4)%cyclemap.width);
      int clc = (int)xxdc + yydc;
      float rc = red(cyclemap.pixels[clc]) / 255;
      
      float final_r = r * rc * 2;
      float final_g = g * rc * 2;
      float final_b = b * rc * 2;
      
      // some compositing 
      fill(final_r, final_g, final_b);
      
			int rect_size2 = rect_size + ((atoms_x_offset[atom_index] * atoms_y_offset[atom_index]) / 16 / sphere_radius);
			
      ellipse(final_x - atoms_x_offset[atom_index], final_y + atoms_y_offset[atom_index], rect_size2, rect_size2);
			
			atom_index += 1;
    }
    
    for (int e = 0; e <= (int)xc_off / 2; e += dots_step) {
      float dd = (float)e / xc_off;

      final_x = xoff - (xc_off) + (xc_off-(xc_off / (dd+0.5)) * abs(0.5-(dd+0.5))) * 2;
      
      float yc_off;
      
      // compute UV texels for the colormap
      float dd2 = 1 - dd;
        
      yc_off = sqrt(1 - dd2*dd2) + 1.270;
      
      // apply colormaps
      float xrepeat = 0.5;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + xmotion)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      float txrepeat = 1;
      
      // fourth texture (cycle mask), only use single component since it is black/white
      int xxdc = ((cyclemap.width - 1) - (int)(yc_off * (cyclemap.width * xrepeat) + (ymotion * 4))%cyclemap.width);
      int clc = (int)xxdc + yydc;
      float rc = red(cyclemap.pixels[clc]) / 255;
      
      float final_r = r * rc * 2;
      float final_g = g * rc * 2;
      float final_b = b * rc * 2;
      
      // some compositing 
      fill(final_r, final_g, final_b);
			
			int rect_size2 = rect_size + ((atoms_x_offset[atom_index] * atoms_y_offset[atom_index]) / 16 / sphere_radius);
      
      ellipse(final_x + atoms_x_offset[atom_index], final_y + atoms_y_offset[atom_index], rect_size2, rect_size2);
			
			atom_index += 1;
    }
  }
  
  xmotion += 0.5;
  ymotion -= 1.25;
	
	// select/enable atoms; displace them
	atoms_enable_end = millis();
	if ((atoms_enable_end - atoms_enable_start) > 10) {
		atoms_enable_start = millis();
		
		// change this for desintegration factor
		int enabled_atoms = (int)round(random(1, 20000));
		for (int i = 0; i < enabled_atoms; i += 1) {
			int index_selection = round(random(0, 800*800));
			atoms_y_vel[index_selection] = random(0.5, 10);
			atoms_x_vel[index_selection] = random(1, 10);
		}
	}
	
	for (int i = 0; i < 800*800; i += 1) {
		if (atoms_y_vel[i] > 0.0 || atoms_y_vel[i] < 0.0) {
			if (atoms_y_offset[i] > sphere_radius / 2.5) {
				atoms_y_vel[i] = -random(1, 8);
				atoms_x_vel[i] = -random(0, 8);
			}	
			
			if (atoms_y_base[i] > 0.001) {
				atoms_y_vel[i] = random(0.5, 8);
				atoms_x_vel[index_selection] = random(0, 8);
				atoms_x_offset[i] = 0;
				atoms_y_offset[i] = 0;
				atoms_x_vel[i] = 0;
				atoms_y_vel[i] = 0;
			}	
			
			atoms_y_offset[i] += atoms_y_vel[i];
			atoms_x_offset[i] -= atoms_x_vel[i];
			
			atoms_y_vel[i] += pow(atoms_y_base[i], 2);
			atoms_x_vel[i] += pow(atoms_y_base[i], 2);
		
			atoms_y_base[i] += 0.00001;
		}
	}
}

void setup() {
  size(800, 800);

  frameRate(60); 
  
  colormap = loadImage(""data.jpg"");
  cyclemap = loadImage(""data_cycle.jpg"");
	
	for (int i = 0; i < 800*800; i += 1) {
			atoms_y_offset[i] = 0;
			atoms_y_vel[i] = 0; //random(0, 0.25);
	}
  
  background(0);
}

void draw() {
  //background(0);
 
  draw_planet();
}"
"570733","Spherical disintegration","mySketch","/**
  * Same approach as dots planet billboard snippet with elements memory.
  */

PImage colormap;
PImage cyclemap;

float xmotion = 0;
float ymotion = 0;

// quality control
int dots_step = 1;
int elems_step = 2;

// same but look below, these are adjusted in real-time to increase rendering quality by abusing motion blur :)
int elems = 128;
int rect_size = 8;

float atoms_enable_start = millis();
float atoms_enable_end = millis();

float[] atoms_x_vel = new float[800 * 600];
float[] atoms_y_vel = new float[800 * 600];
float[] atoms_x_offset = new float[800 * 600];
float[] atoms_y_offset = new float[800 * 600];
float[] atoms_y_base = new float[800 * 600];

void draw_planet() {
  float mx = mouseX / 1024.0;
  float my = mouseY / 1024.0;
  
  //elems_step = (int)(2.0 - mx * 1.0);
  //dots_step = (int)(1.0 + my * 1.0);

  // add some motion blur / brightness
  fill(0, 0, 0, 8);
  rect(0, 0, 800, 900);
  
  // here we take advantage of the motion blur to ""fill in the gap"" by adjusting each slices / frames, this increase rendering quality (altough it look hazy)
  //elems = (int)(92 + sin(xmotion / 24.) * 36);
  //rect_size = (int)(2 + abs(sin(xmotion / 84.)) * 4);
  
  noStroke();
  
  float xoff = 800 / 2;
  
  float sphere_radius = 242;
  float yoff = 600 / 2 - sphere_radius;
	
	int atom_index = 0;
  
  for (int s = 0; s < elems; s += elems_step) {
    float de = (float)s / elems;
    
    float bd = max((0.5-abs(de - 0.5)) * 4, 0.05);
    
    float yrepeat = 1;
    int yyd = (((int)(de * (colormap.height * yrepeat))%colormap.height)) * colormap.width;
    
    float tyrepeat = 1;

    int yydc = (((int)(de * (cyclemap.height * yrepeat))%cyclemap.height)) * cyclemap.width;
    
    // cartesian circle equation
    float sphere_radius_squared = sphere_radius * sphere_radius;
    float sh_radius = de * (sphere_radius * 2) - sphere_radius;
    float xc_off = sqrt(sphere_radius_squared - sh_radius*sh_radius);
    
    float final_x;
    float final_y = yoff + de * (sphere_radius * 2); // flabby planet bonus : + sin((de * 360 + 180) * (PI / 180) + ymotion / 24.) * 4;
    
    for (int e = 0; e <= (int)xc_off / 2; e += dots_step) {
      float dd = (float)e / xc_off;

			// / (dd+0.5) : shrinking near the center (otherwise : equal distribution of the dots)
      final_x = xoff - (xc_off) + (xc_off / (dd+0.5)) * abs(0.5-(dd+0.5)) * 2 ;
      
      float yc_off;
      
      // compute UV texels for the colormap
      float dd2 = 1 - dd;
        
      yc_off = 1-sqrt(1 - dd2*dd2);
      
      // apply colormaps
      float xrepeat = 0.5;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + xmotion)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      // second texture (text mask)
      float txrepeat = 1.;
      
      // fourth texture (cycle mask), only use single component since it is black/white
      int xxdc = ((cyclemap.width - 1) - (int)(yc_off * (cyclemap.width * xrepeat) + ymotion * 4)%cyclemap.width);
      int clc = (int)xxdc + yydc;
      float rc = red(cyclemap.pixels[clc]) / 255;
      
      float final_r = r * rc * 2;
      float final_g = g * rc * 2;
      float final_b = b * rc * 2;
      
      // some compositing 
      fill(final_r, final_g, final_b);
      
			int rect_size2 = rect_size + ((atoms_x_offset[atom_index] * atoms_y_offset[atom_index]) / 16 / sphere_radius);
			
      ellipse(final_x - atoms_x_offset[atom_index], final_y + atoms_y_offset[atom_index], rect_size2, rect_size2);
			
			atom_index += 1;
    }
    
    for (int e = 0; e <= (int)xc_off / 2; e += dots_step) {
      float dd = (float)e / xc_off;

      final_x = xoff - (xc_off) + (xc_off-(xc_off / (dd+0.5)) * abs(0.5-(dd+0.5))) * 2;
      
      float yc_off;
      
      // compute UV texels for the colormap
      float dd2 = 1 - dd;
        
      yc_off = sqrt(1 - dd2*dd2) + 1.270;
      
      // apply colormaps
      float xrepeat = 0.5;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + xmotion)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      float txrepeat = 1;
      
      // fourth texture (cycle mask), only use single component since it is black/white
      int xxdc = ((cyclemap.width - 1) - (int)(yc_off * (cyclemap.width * xrepeat) + (ymotion * 4))%cyclemap.width);
      int clc = (int)xxdc + yydc;
      float rc = red(cyclemap.pixels[clc]) / 255;
      
      float final_r = r * rc * 2;
      float final_g = g * rc * 2;
      float final_b = b * rc * 2;
      
      // some compositing 
      fill(final_r, final_g, final_b);
			
			int rect_size2 = rect_size + ((atoms_x_offset[atom_index] * atoms_y_offset[atom_index]) / 16 / sphere_radius);
      
      ellipse(final_x + atoms_x_offset[atom_index], final_y + atoms_y_offset[atom_index], rect_size2, rect_size2);
			
			atom_index += 1;
    }
  }
  
  xmotion += 0.5;
  ymotion -= 1.25;
	
	// select/enable atoms; displace them
	atoms_enable_end = millis();
	if ((atoms_enable_end - atoms_enable_start) > 10) {
		atoms_enable_start = millis();
		
		// change this for desintegration factor
		int enabled_atoms = (int)round(random(1, 20000));
		for (int i = 0; i < enabled_atoms; i += 1) {
			int index_selection = round(random(0, 800*800));
			atoms_y_vel[index_selection] = random(0.5, 10);
			atoms_x_vel[index_selection] = random(1, 10);
		}
	}
	
	for (int i = 0; i < 800*800; i += 1) {
		if (atoms_y_vel[i] > 0.0 || atoms_y_vel[i] < 0.0) {
			if (atoms_y_offset[i] > sphere_radius / 2.5) {
				atoms_y_vel[i] = -random(1, 8);
				atoms_x_vel[i] = -random(0, 8);
			}	
			
			if (atoms_y_base[i] > 0.001) {
				atoms_x_offset[i] = 0;
				atoms_y_offset[i] = 0;
				atoms_x_vel[i] = 0;
				atoms_y_vel[i] = 0;
			}	
			
			atoms_y_offset[i] += atoms_y_vel[i];
			atoms_x_offset[i] -= atoms_x_vel[i];
			
			atoms_y_vel[i] += pow(atoms_y_base[i], 2);
			atoms_x_vel[i] += pow(atoms_y_base[i], 2);
		
			atoms_y_base[i] += 0.00001;
		}
	}
}

void setup() {
  size(800, 800);

  frameRate(60); 
  
  colormap = loadImage(""data.jpg"");
  cyclemap = loadImage(""data_cycle.jpg"");
	
	for (int i = 0; i < 800*800; i += 1) {
			atoms_y_offset[i] = 0;
			atoms_y_vel[i] = 0; //random(0, 0.25);
	}
  
  background(0);
}

void draw() {
  //background(0);
 
  draw_planet();
}"
"570733","Spherical disintegration","mySketch","/**
  * Same approach as dots planet billboard snippet with elements memory.
  */

PImage colormap;
PImage cyclemap;

float xmotion = 0;
float ymotion = 0;

// quality control
int dots_step = 1;
int elems_step = 2;

// same but look below, these are adjusted in real-time to increase rendering quality by abusing motion blur :)
int elems = 128;
int rect_size = 8;

float atoms_enable_start = millis();
float atoms_enable_end = millis();

float[] atoms_x_vel = new float[800 * 600];
float[] atoms_y_vel = new float[800 * 600];
float[] atoms_x_offset = new float[800 * 600];
float[] atoms_y_offset = new float[800 * 600];
float[] atoms_y_base = new float[800 * 600];

void draw_planet() {
  float mx = mouseX / 1024.0;
  float my = mouseY / 1024.0;
  
  //elems_step = (int)(2.0 - mx * 1.0);
  //dots_step = (int)(1.0 + my * 1.0);

  // add some motion blur / brightness
  fill(0, 0, 0, 8);
  rect(0, 0, 800, 900);
  
  // here we take advantage of the motion blur to ""fill in the gap"" by adjusting each slices / frames, this increase rendering quality (altough it look hazy)
  //elems = (int)(92 + sin(xmotion / 24.) * 36);
  //rect_size = (int)(2 + abs(sin(xmotion / 84.)) * 4);
  
  noStroke();
  
  float xoff = 800 / 2;
  
  float sphere_radius = 242;
  float yoff = 600 / 2 - sphere_radius;
	
	int atom_index = 0;
  
  for (int s = 0; s < elems; s += elems_step) {
    float de = (float)s / elems;
    
    float bd = max((0.5-abs(de - 0.5)) * 4, 0.05);
    
    float yrepeat = 1;
    int yyd = (((int)(de * (colormap.height * yrepeat))%colormap.height)) * colormap.width;
    
    float tyrepeat = 1;

    int yydc = (((int)(de * (cyclemap.height * yrepeat))%cyclemap.height)) * cyclemap.width;
    
    // cartesian circle equation
    float sphere_radius_squared = sphere_radius * sphere_radius;
    float sh_radius = de * (sphere_radius * 2) - sphere_radius;
    float xc_off = sqrt(sphere_radius_squared - sh_radius*sh_radius);
    
    float final_x;
    float final_y = yoff + de * (sphere_radius * 2); // flabby planet bonus : + sin((de * 360 + 180) * (PI / 180) + ymotion / 24.) * 4;
    
    for (int e = 0; e <= (int)xc_off / 2; e += dots_step) {
      float dd = (float)e / xc_off;

			// / (dd+0.5) : shrinking near the center (otherwise : equal distribution of the dots)
      final_x = xoff - (xc_off) + (xc_off / (dd+0.5)) * abs(0.5-(dd+0.5)) * 2 ;
      
      float yc_off;
      
      // compute UV texels for the colormap
      float dd2 = 1 - dd;
        
      yc_off = 1-sqrt(1 - dd2*dd2);
      
      // apply colormaps
      float xrepeat = 0.5;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + xmotion)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      // second texture (text mask)
      float txrepeat = 1.;
      
      // fourth texture (cycle mask), only use single component since it is black/white
      int xxdc = ((cyclemap.width - 1) - (int)(yc_off * (cyclemap.width * xrepeat) + ymotion * 4)%cyclemap.width);
      int clc = (int)xxdc + yydc;
      float rc = red(cyclemap.pixels[clc]) / 255;
      
      float final_r = r * rc * 2;
      float final_g = g * rc * 2;
      float final_b = b * rc * 2;
      
      // some compositing 
      fill(final_r, final_g, final_b);
      
			int rect_size2 = rect_size + ((atoms_x_offset[atom_index] * atoms_y_offset[atom_index]) / 16 / sphere_radius);
			
      ellipse(final_x - atoms_x_offset[atom_index], final_y + atoms_y_offset[atom_index], rect_size2, rect_size2);
			
			atom_index += 1;
    }
    
    for (int e = 0; e <= (int)xc_off / 2; e += dots_step) {
      float dd = (float)e / xc_off;

      final_x = xoff - (xc_off) + (xc_off-(xc_off / (dd+0.5)) * abs(0.5-(dd+0.5))) * 2;
      
      float yc_off;
      
      // compute UV texels for the colormap
      float dd2 = 1 - dd;
        
      yc_off = sqrt(1 - dd2*dd2) + 1.270;
      
      // apply colormaps
      float xrepeat = 0.5;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + xmotion)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      float txrepeat = 1;
      
      // fourth texture (cycle mask), only use single component since it is black/white
      int xxdc = ((cyclemap.width - 1) - (int)(yc_off * (cyclemap.width * xrepeat) + (ymotion * 4))%cyclemap.width);
      int clc = (int)xxdc + yydc;
      float rc = red(cyclemap.pixels[clc]) / 255;
      
      float final_r = r * rc * 2;
      float final_g = g * rc * 2;
      float final_b = b * rc * 2;
      
      // some compositing 
      fill(final_r, final_g, final_b);
			
			int rect_size2 = rect_size + ((atoms_x_offset[atom_index] * atoms_y_offset[atom_index]) / 16 / sphere_radius);
      
      ellipse(final_x + atoms_x_offset[atom_index], final_y + atoms_y_offset[atom_index], rect_size2, rect_size2);
			
			atom_index += 1;
    }
  }
  
  xmotion += 0.5;
  ymotion -= 1.25;
	
	// select/enable atoms; displace them
	atoms_enable_end = millis();
	if ((atoms_enable_end - atoms_enable_start) > 10) {
		atoms_enable_start = millis();
		
		// change this for desintegration factor
		int enabled_atoms = (int)round(random(1, 20000));
		for (int i = 0; i < enabled_atoms; i += 1) {
			int index_selection = round(random(0, 800*800));
			atoms_y_vel[index_selection] = random(0.5, 10);
			atoms_x_vel[index_selection] = random(1, 10);
		}
	}
	
	for (int i = 0; i < 800*800; i += 1) {
		if (atoms_y_vel[i] > 0.0 || atoms_y_vel[i] < 0.0) {
			if (atoms_y_offset[i] > sphere_radius / 2.5) {
				atoms_y_vel[i] = -random(1, 8);
				atoms_x_vel[i] = -random(0, 8);
			}	
			
			if (atoms_y_base[i] > 0.001) {
				atoms_x_offset[i] = 0;
				atoms_y_offset[i] = 0;
				atoms_x_vel[i] = 0;
				atoms_y_vel[i] = 0;
				atoms_y_base[i] = 0;
			}	
			
			atoms_y_offset[i] += atoms_y_vel[i];
			atoms_x_offset[i] -= atoms_x_vel[i];
			
			atoms_y_vel[i] += pow(atoms_y_base[i], 2);
			atoms_x_vel[i] += pow(atoms_y_base[i], 2);
		
			atoms_y_base[i] += 0.00001;
		}
	}
}

void setup() {
  size(800, 800);

  frameRate(60); 
  
  colormap = loadImage(""data.jpg"");
  cyclemap = loadImage(""data_cycle.jpg"");
	
	for (int i = 0; i < 800*800; i += 1) {
			atoms_y_offset[i] = 0;
			atoms_y_vel[i] = 0; //random(0, 0.25);
	}
  
  background(0);
}

void draw() {
  //background(0);
 
  draw_planet();
}"
"570733","Spherical disintegration","mySketch","/**
  * Same approach as dots planet billboard snippet with elements memory.
  */

PImage colormap;
PImage cyclemap;

float xmotion = 0;
float ymotion = 0;

// quality control
int dots_step = 1;
int elems_step = 2;

// same but look below, these are adjusted in real-time to increase rendering quality by abusing motion blur :)
int elems = 128;
int rect_size = 8;

float atoms_enable_start = millis();
float atoms_enable_end = millis();

float[] atoms_x_vel = new float[800 * 600];
float[] atoms_y_vel = new float[800 * 600];
float[] atoms_x_offset = new float[800 * 600];
float[] atoms_y_offset = new float[800 * 600];
float[] atoms_y_base = new float[800 * 600];

void draw_planet() {
  float mx = mouseX / 1024.0;
  float my = mouseY / 1024.0;
  
  //elems_step = (int)(2.0 - mx * 1.0);
  //dots_step = (int)(1.0 + my * 1.0);

  // add some motion blur / brightness
  fill(0, 0, 0, 8);
  rect(0, 0, 800, 900);
  
  // here we take advantage of the motion blur to ""fill in the gap"" by adjusting each slices / frames, this increase rendering quality (altough it look hazy)
  //elems = (int)(92 + sin(xmotion / 24.) * 36);
  //rect_size = (int)(2 + abs(sin(xmotion / 84.)) * 4);
  
  noStroke();
  
  float xoff = 800 / 2;
  
  float sphere_radius = 242;
  float yoff = 600 / 2 - sphere_radius;
	
	int atom_index = 0;
  
  for (int s = 0; s < elems; s += elems_step) {
    float de = (float)s / elems;
    
    float bd = max((0.5-abs(de - 0.5)) * 4, 0.05);
    
    float yrepeat = 1;
    int yyd = (((int)(de * (colormap.height * yrepeat))%colormap.height)) * colormap.width;
    
    float tyrepeat = 1;

    int yydc = (((int)(de * (cyclemap.height * yrepeat))%cyclemap.height)) * cyclemap.width;
    
    // cartesian circle equation
    float sphere_radius_squared = sphere_radius * sphere_radius;
    float sh_radius = de * (sphere_radius * 2) - sphere_radius;
    float xc_off = sqrt(sphere_radius_squared - sh_radius*sh_radius);
    
    float final_x;
    float final_y = yoff + de * (sphere_radius * 2); // flabby planet bonus : + sin((de * 360 + 180) * (PI / 180) + ymotion / 24.) * 4;
    
    for (int e = 0; e <= (int)xc_off / 2; e += dots_step) {
      float dd = (float)e / xc_off;

			// / (dd+0.5) : shrinking near the center (otherwise : equal distribution of the dots)
      final_x = xoff - (xc_off) + (xc_off / (dd+0.5)) * abs(0.5-(dd+0.5)) * 2 ;
      
      float yc_off;
      
      // compute UV texels for the colormap
      float dd2 = 1 - dd;
        
      yc_off = 1-sqrt(1 - dd2*dd2);
      
      // apply colormaps
      float xrepeat = 0.5;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + xmotion)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      // second texture (text mask)
      float txrepeat = 1.;
      
      // fourth texture (cycle mask), only use single component since it is black/white
      int xxdc = ((cyclemap.width - 1) - (int)(yc_off * (cyclemap.width * xrepeat) + ymotion * 4)%cyclemap.width);
      int clc = (int)xxdc + yydc;
      float rc = red(cyclemap.pixels[clc]) / 255;
      
      float final_r = r * rc * 2;
      float final_g = g * rc * 2;
      float final_b = b * rc * 2;
      
      // some compositing 
      fill(final_r, final_g, final_b);
      
			int rect_size2 = rect_size + ((atoms_x_offset[atom_index] * atoms_y_offset[atom_index]) / 16 / sphere_radius);
			
      ellipse(final_x - atoms_x_offset[atom_index], final_y + atoms_y_offset[atom_index], rect_size2, rect_size2);
			
			atom_index += 1;
    }
    
    for (int e = 0; e <= (int)xc_off / 2; e += dots_step) {
      float dd = (float)e / xc_off;

      final_x = xoff - (xc_off) + (xc_off-(xc_off / (dd+0.5)) * abs(0.5-(dd+0.5))) * 2;
      
      float yc_off;
      
      // compute UV texels for the colormap
      float dd2 = 1 - dd;
        
      yc_off = sqrt(1 - dd2*dd2) + 1.270;
      
      // apply colormaps
      float xrepeat = 0.5;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + xmotion)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      float txrepeat = 1;
      
      // fourth texture (cycle mask), only use single component since it is black/white
      int xxdc = ((cyclemap.width - 1) - (int)(yc_off * (cyclemap.width * xrepeat) + (ymotion * 4))%cyclemap.width);
      int clc = (int)xxdc + yydc;
      float rc = red(cyclemap.pixels[clc]) / 255;
      
      float final_r = r * rc * 2;
      float final_g = g * rc * 2;
      float final_b = b * rc * 2;
      
      // some compositing 
      fill(final_r, final_g, final_b);
			
			int rect_size2 = rect_size + ((atoms_x_offset[atom_index] * atoms_y_offset[atom_index]) / 16 / sphere_radius);
      
      ellipse(final_x + atoms_x_offset[atom_index], final_y + atoms_y_offset[atom_index], rect_size2, rect_size2);
			
			atom_index += 1;
    }
  }
  
  xmotion += 0.5;
  ymotion -= 1.25;
	
	// select/enable atoms; displace them
	atoms_enable_end = millis();
	if ((atoms_enable_end - atoms_enable_start) > 10) {
		atoms_enable_start = millis();
		
		// change this for desintegration factor
		int enabled_atoms = (int)round(random(1, 20000));
		for (int i = 0; i < enabled_atoms; i += 1) {
			int index_selection = round(random(0, 800*800));
			atoms_y_vel[index_selection] = random(0.5, 10);
			atoms_x_vel[index_selection] = random(1, 10);
		}
	}
	
	for (int i = 0; i < 800*800; i += 1) {
		if (atoms_y_vel[i] > 0.0 || atoms_y_vel[i] < 0.0) {
			if (atoms_y_offset[i] > sphere_radius / 2.5) {
				atoms_y_vel[i] = -random(1, 8);
				atoms_x_vel[i] = -random(0, 8);
			}	
			
			if (atoms_y_base[i] > 0.001) {
				atoms_x_offset[i] = 0;
				atoms_y_offset[i] = 0;
				atoms_x_vel[i] = 0;
				atoms_y_vel[i] = 0;
			}	
			
			atoms_y_offset[i] += atoms_y_vel[i];
			atoms_x_offset[i] -= atoms_x_vel[i];
			
			atoms_y_vel[i] += pow(atoms_y_base[i], 2);
			atoms_x_vel[i] += pow(atoms_y_base[i], 2);
		
			atoms_y_base[i] += 0.00001;
		}
	}
}

void setup() {
  size(800, 800);

  frameRate(60); 
  
  colormap = loadImage(""data.jpg"");
  cyclemap = loadImage(""data_cycle.jpg"");
	
	for (int i = 0; i < 800*800; i += 1) {
			atoms_y_offset[i] = 0;
			atoms_y_vel[i] = 0; //random(0, 0.25);
	}
  
  background(0);
}

void draw() {
  //background(0);
 
  draw_planet();
}"
"570733","Spherical disintegration","mySketch","/**
  * Same approach as dots planet billboard snippet with elements memory.
  */

PImage colormap;
PImage cyclemap;

float xmotion = 0;
float ymotion = 0;

// quality control
int dots_step = 1;
int elems_step = 2;

int elems = 128;
int rect_size = 8;

float atoms_enable_start = millis();
float atoms_enable_end = millis();

float[] atoms_x_vel = new float[800 * 600];
float[] atoms_y_vel = new float[800 * 600];
float[] atoms_x_offset = new float[800 * 600];
float[] atoms_y_offset = new float[800 * 600];
float[] atoms_y_base = new float[800 * 600];

void draw_planet() {
  float mx = mouseX / 1024.0;
  float my = mouseY / 1024.0;
  
  //elems_step = (int)(2.0 - mx * 1.0);
  //dots_step = (int)(1.0 + my * 1.0);

  // add some motion blur / brightness
  fill(0, 0, 0, 8);
  rect(0, 0, 800, 900);
  
  //elems = (int)(92 + sin(xmotion / 24.) * 36);
  //rect_size = (int)(2 + abs(sin(xmotion / 84.)) * 4);
  
  noStroke();
  
  float xoff = 800 / 2;
  
  float sphere_radius = 242;
  float yoff = 600 / 2 - sphere_radius;
	
	int atom_index = 0;
  
  for (int s = 0; s < elems; s += elems_step) {
    float de = (float)s / elems;
    
    float bd = max((0.5-abs(de - 0.5)) * 4, 0.05);
    
    float yrepeat = 1;
    int yyd = (((int)(de * (colormap.height * yrepeat))%colormap.height)) * colormap.width;
    
    float tyrepeat = 1;

    int yydc = (((int)(de * (cyclemap.height * yrepeat))%cyclemap.height)) * cyclemap.width;
    
    // cartesian circle equation
    float sphere_radius_squared = sphere_radius * sphere_radius;
    float sh_radius = de * (sphere_radius * 2) - sphere_radius;
    float xc_off = sqrt(sphere_radius_squared - sh_radius*sh_radius);
    
    float final_x;
    float final_y = yoff + de * (sphere_radius * 2); // flabby planet bonus : + sin((de * 360 + 180) * (PI / 180) + ymotion / 24.) * 4;
    
    for (int e = 0; e <= (int)xc_off / 2; e += dots_step) {
      float dd = (float)e / xc_off;

			// / (dd+0.5) : shrinking near the center (otherwise : equal distribution of the dots)
      final_x = xoff - (xc_off) + (xc_off / (dd+0.5)) * abs(0.5-(dd+0.5)) * 2 ;
      
      float yc_off;
      
      // compute UV texels for the colormap
      float dd2 = 1 - dd;
        
      yc_off = 1-sqrt(1 - dd2*dd2);
      
      // apply colormaps
      float xrepeat = 0.5;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + xmotion)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      // second texture (text mask)
      float txrepeat = 1.;
      
      // fourth texture (cycle mask), only use single component since it is black/white
      int xxdc = ((cyclemap.width - 1) - (int)(yc_off * (cyclemap.width * xrepeat) + ymotion * 4)%cyclemap.width);
      int clc = (int)xxdc + yydc;
      float rc = red(cyclemap.pixels[clc]) / 255;
      
      float final_r = r * rc * 2;
      float final_g = g * rc * 2;
      float final_b = b * rc * 2;
      
      // some compositing 
      fill(final_r, final_g, final_b);
      
			int rect_size2 = rect_size + ((atoms_x_offset[atom_index] * atoms_y_offset[atom_index]) / 16 / sphere_radius);
			
      ellipse(final_x - atoms_x_offset[atom_index], final_y + atoms_y_offset[atom_index], rect_size2, rect_size2);
			
			atom_index += 1;
    }
    
    for (int e = 0; e <= (int)xc_off / 2; e += dots_step) {
      float dd = (float)e / xc_off;

      final_x = xoff - (xc_off) + (xc_off-(xc_off / (dd+0.5)) * abs(0.5-(dd+0.5))) * 2;
      
      float yc_off;
      
      // compute UV texels for the colormap
      float dd2 = 1 - dd;
        
      yc_off = sqrt(1 - dd2*dd2) + 1.270;
      
      // apply colormaps
      float xrepeat = 0.5;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + xmotion)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      float txrepeat = 1;
      
      // fourth texture (cycle mask), only use single component since it is black/white
      int xxdc = ((cyclemap.width - 1) - (int)(yc_off * (cyclemap.width * xrepeat) + (ymotion * 4))%cyclemap.width);
      int clc = (int)xxdc + yydc;
      float rc = red(cyclemap.pixels[clc]) / 255;
      
      float final_r = r * rc * 2;
      float final_g = g * rc * 2;
      float final_b = b * rc * 2;
      
      // some compositing 
      fill(final_r, final_g, final_b);
			
			int rect_size2 = rect_size + ((atoms_x_offset[atom_index] * atoms_y_offset[atom_index]) / 16 / sphere_radius);
      
      ellipse(final_x + atoms_x_offset[atom_index], final_y + atoms_y_offset[atom_index], rect_size2, rect_size2);
			
			atom_index += 1;
    }
  }
  
  xmotion += 0.5;
  ymotion -= 1.25;
	
	// select/enable atoms; displace them
	atoms_enable_end = millis();
	if ((atoms_enable_end - atoms_enable_start) > 10) {
		atoms_enable_start = millis();
		
		// change this for desintegration factor
		int enabled_atoms = (int)round(random(1, 20000));
		for (int i = 0; i < enabled_atoms; i += 1) {
			int index_selection = round(random(0, 800*800));
			atoms_y_vel[index_selection] = random(0.5, 10);
			atoms_x_vel[index_selection] = random(1, 10);
		}
	}
	
	for (int i = 0; i < 800*800; i += 1) {
		if (atoms_y_vel[i] > 0.0 || atoms_y_vel[i] < 0.0) {
			if (atoms_y_offset[i] > sphere_radius / 2.5) {
				atoms_y_vel[i] = -random(1, 8);
				atoms_x_vel[i] = -random(0, 8);
			}	
			
			if (atoms_y_base[i] > 0.001) {
				atoms_x_offset[i] = 0;
				atoms_y_offset[i] = 0;
				atoms_x_vel[i] = 0;
				atoms_y_vel[i] = 0;
			}	
			
			atoms_y_offset[i] += atoms_y_vel[i];
			atoms_x_offset[i] -= atoms_x_vel[i];
			
			atoms_y_vel[i] += pow(atoms_y_base[i], 2);
			atoms_x_vel[i] += pow(atoms_y_base[i], 2);
		
			atoms_y_base[i] += 0.00001;
		}
	}
}

void setup() {
  size(800, 800);

  frameRate(60); 
  
  colormap = loadImage(""data.jpg"");
  cyclemap = loadImage(""data_cycle.jpg"");
	
	for (int i = 0; i < 800*800; i += 1) {
			atoms_y_offset[i] = 0;
			atoms_y_vel[i] = 0; //random(0, 0.25);
	}
  
  background(0);
}

void draw() {
  //background(0);
 
  draw_planet();
}"
"570733","Spherical disintegration","mySketch","/**
  * Same approach as dots planet billboard snippet with elements memory.
  */

PImage colormap;
PImage cyclemap;

float xmotion = 0;
float ymotion = 0;

// quality control
int dots_step = 1;
int elems_step = 1;

int elems = 128;
int rect_size = 6;

float atoms_enable_start = millis();
float atoms_enable_end = millis();

float[] atoms_x_vel = new float[600 * 600];
float[] atoms_y_vel = new float[600 * 600];
float[] atoms_x_offset = new float[600 * 600];
float[] atoms_y_offset = new float[600 * 600];
float[] atoms_y_base = new float[600 * 600];

void draw_planet() {
  float mx = mouseX / 1024.0;
  float my = mouseY / 1024.0;
  
  //elems_step = (int)(2.0 - mx * 1.0);
  //dots_step = (int)(1.0 + my * 1.0);

  // add some motion blur / brightness
  fill(0, 0, 0, 92);
  rect(0, 0, 600, 700);
  
  //elems = (int)(92 + sin(xmotion / 24.) * 36);
  //rect_size = (int)(2 + abs(sin(xmotion / 84.)) * 4);
  
  noStroke();
  
  float xoff = 600 / 2;
  
  float sphere_radius = 242/800*600;
  float yoff = 600 / 2 - sphere_radius;
	
	int atom_index = 0;
  
  for (int s = 0; s < elems; s += elems_step) {
    float de = (float)s / elems;
    
    float bd = max((0.5-abs(de - 0.5)) * 4, 0.05);
    
    float yrepeat = 1;
    int yyd = (((int)(de * (colormap.height * yrepeat))%colormap.height)) * colormap.width;
    
    float tyrepeat = 1;

    int yydc = (((int)(de * (cyclemap.height * yrepeat))%cyclemap.height)) * cyclemap.width;
    
    // cartesian circle equation
    float sphere_radius_squared = sphere_radius * sphere_radius;
    float sh_radius = de * (sphere_radius * 2) - sphere_radius;
    float xc_off = sqrt(sphere_radius_squared - sh_radius*sh_radius);
    
    float final_x;
    float final_y = yoff + de * (sphere_radius * 2); // flabby planet bonus : + sin((de * 360 + 180) * (PI / 180) + ymotion / 24.) * 4;
    
    for (int e = 0; e <= (int)xc_off / 2; e += dots_step) {
      float dd = (float)e / xc_off;

			// / (dd+0.5) : shrinking near the center (otherwise : equal distribution of the dots)
      final_x = xoff - (xc_off) + (xc_off / (dd+0.5)) * abs(0.5-(dd+0.5)) * 2 ;
      
      float yc_off;
      
      // compute UV texels for the colormap
      float dd2 = 1 - dd;
        
      yc_off = 1-sqrt(1 - dd2*dd2);
      
      // apply colormaps
      float xrepeat = 0.5;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + xmotion*3)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      // second texture (text mask)
      float txrepeat = 1.;
      
      // fourth texture (cycle mask), only use single component since it is black/white
      int xxdc = ((cyclemap.width - 1) - (int)(yc_off * (cyclemap.width * xrepeat) + ymotion * 4)%cyclemap.width);
      int clc = (int)xxdc + yydc;
      float rc = red(cyclemap.pixels[clc]) / 255;
      
      float final_r = r * rc * 2;
      float final_g = g * rc * 2;
      float final_b = b * rc * 2;
      
      // some compositing 
      fill(final_r, final_g, final_b);
      
			int rect_size2 = rect_size + ((atoms_x_offset[atom_index] * atoms_y_offset[atom_index]) / 16 / sphere_radius);
			
      ellipse(final_x - atoms_x_offset[atom_index], final_y + atoms_y_offset[atom_index], rect_size2, rect_size2);
			
			atom_index += 1;
    }
    
    for (int e = 0; e <= (int)xc_off / 2; e += dots_step) {
      float dd = (float)e / xc_off;

      final_x = xoff - (xc_off) + (xc_off-(xc_off / (dd+0.5)) * abs(0.5-(dd+0.5))) * 2;
      
      float yc_off;
      
      // compute UV texels for the colormap
      float dd2 = 1 - dd;
        
      yc_off = sqrt(1 - dd2*dd2) + 1.270;
      
      // apply colormaps
      float xrepeat = 0.5;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + xmotion*3)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      float txrepeat = 1;
      
      // fourth texture (cycle mask), only use single component since it is black/white
      int xxdc = ((cyclemap.width - 1) - (int)(yc_off * (cyclemap.width * xrepeat) + (ymotion * 4))%cyclemap.width);
      int clc = (int)xxdc + yydc;
      float rc = red(cyclemap.pixels[clc]) / 255;
      
      float final_r = r * rc * 2;
      float final_g = g * rc * 2;
      float final_b = b * rc * 2;
      
      // some compositing 
      fill(final_r, final_g, final_b);
			
			int rect_size2 = rect_size + ((atoms_x_offset[atom_index] * atoms_y_offset[atom_index]) / 16 / sphere_radius);
      
      ellipse(final_x + atoms_x_offset[atom_index], final_y + atoms_y_offset[atom_index], rect_size2, rect_size2);
			
			atom_index += 1;
    }
  }
  
  xmotion += 0.5;
  ymotion -= 1.25;
	
	// select/enable atoms; displace them
	atoms_enable_end = millis();
	if ((atoms_enable_end - atoms_enable_start) > 10) {
		atoms_enable_start = millis();
		
		// change this for desintegration factor
		int enabled_atoms = (int)round(random(1, 20000));
		for (int i = 0; i < enabled_atoms; i += 1) {
			int index_selection = round(random(0, 600*600));
			atoms_y_vel[index_selection] = random(0.5, 10);
			atoms_x_vel[index_selection] = random(1, 10);
		}
	}
	
	for (int i = 0; i < 600*600; i += 1) {
		if (atoms_y_vel[i] > 0.0 || atoms_y_vel[i] < 0.0) {
			if (atoms_y_offset[i] > sphere_radius / 2.5) {
				atoms_y_vel[i] = -random(1, 8);
				atoms_x_vel[i] = -random(0, 8);
			}	
			
			if (atoms_y_base[i] > 0.001) {
				atoms_x_offset[i] = 0;
				atoms_y_offset[i] = 0;
				atoms_x_vel[i] = 0;
				atoms_y_vel[i] = 0;
			}	
			
			atoms_y_offset[i] += atoms_y_vel[i];
			atoms_x_offset[i] -= atoms_x_vel[i];
			
			atoms_y_vel[i] += pow(atoms_y_base[i], 2);
			atoms_x_vel[i] += pow(atoms_y_base[i], 2);
		
			atoms_y_base[i] += 0.00001;
		}
	}
}

void setup() {
  size(600, 600);

  frameRate(60); 
  
  colormap = loadImage(""data.jpg"");
  cyclemap = loadImage(""data_cycle.jpg"");
	
	for (int i = 0; i < 600*600; i += 1) {
			atoms_y_offset[i] = 0;
			atoms_y_vel[i] = 0; //random(0, 0.25);
	}
  
  background(0);
}

void draw() {
  //background(0);
 
  draw_planet();
}"
"569939","Meshuggah","mySketch","/*
 * ""voxels"" (sort of) from 3D rendering, the idea is to first render 3D stuff (a cube) into a offscreen context
 * then iterate over all the pixels data of that offscreen context and draw 2D shapes on screen for some of them,
 * the 2D shapes position and size are modulated to make seemingly complex stuff, the cube faces look like they are displaced,
 * some motion blur is applied to both the offscreen context and the screen,
 * the grid background is just an image, this idea can be quite fun to play with with more complex shapes and lights...!
 */

float shape_size = 340;
float shape_angle_y;
float shape_z = -100;

float xmotion = 0.;
float ymotion = 0.;

PGraphics off;
PGraphics off_2d;

PImage img1;
PImage img2;

int w = 700;
int h = 700;

// control the rendering quality / speed (basically the resolution by which we scan the 3D offscreen pixels)
int iter_step_x = 8;
int iter_step_y = 8;

int[] buffer = new int[w * h];
 
void texturedCube(PGraphics dst, PImage tex) {
  dst.beginShape(QUADS);
  dst.texture(tex);
  
	dst.vertex(-1, -1,  1, 0, 0);
	dst.vertex( 1, -1,  1, 1, 0);
	dst.vertex( 1,  1,  1, 1, 1);
	dst.vertex(-1,  1,  1, 0, 1);

	// -Z ""back"" face
	dst.vertex( 1, -1, -1, 0, 0);
	dst.vertex(-1, -1, -1, 1, 0);
	dst.vertex(-1,  1, -1, 1, 1);
	dst.vertex( 1,  1, -1, 0, 1);

	// +Y ""bottom"" face
	dst.vertex(-1,  1,  1, 0, 0);
	dst.vertex( 1,  1,  1, 1, 0);
	dst.vertex( 1,  1, -1, 1, 1);
	dst.vertex(-1,  1, -1, 0, 1);

	// -Y ""top"" face
	dst.vertex(-1, -1, -1, 0, 0);
	dst.vertex( 1, -1, -1, 1, 0);
	dst.vertex( 1, -1,  1, 1, 1);
	dst.vertex(-1, -1,  1, 0, 1);

	// +X ""right"" face
	dst.vertex( 1, -1,  1, 0, 0);
	dst.vertex( 1, -1, -1, 1, 0);
	dst.vertex( 1,  1, -1, 1, 1);
	dst.vertex( 1,  1,  1, 0, 1);

	// -X ""left"" face
	dst.vertex(-1, -1, -1, 0, 0);
	dst.vertex(-1, -1,  1, 1, 0);
	dst.vertex(-1,  1,  1, 1, 1);
	dst.vertex(-1,  1, -1, 0, 1);

  dst.endShape(CLOSE);
}

void setup() {
  size(w, h, P2D);  
	
	frameRate(60);
	
	noStroke();
	
	// we need a 2D offscreen context to draw the 3D offscreen context and process the pixels data
	off_2d = createGraphics(w, h, P2D);
	off_2d.background(0);

	// 3d offscreen context
	off = createGraphics(w, h, P3D);
	off.textureMode(NORMALIZED);
	off.smooth();
	off.lights();
	off.ambientLight(0, 0, 0);
	off.directionalLight(255, 255, 255, -16, 8, -4);
	off.lightFalloff(0., 0.8, 0);
	off.lightSpecular(0, 0, 0);
	//off.noFill();
	
	img1 = loadImage(""data.jpg"");
	img2 = loadImage(""vapor.jpg"");
	
	background(0);
}
 
void draw() {
	//background(0);
  fill(0, 0, 0, 4);
  rect(0, 0, w, h);
	
	// draw a cube into the 3D offscreen context
	off.beginDraw(); 
	off.pushMatrix();
	off.fill(255);
	off.stroke(4);
	off.background(0, 0, 0, 1);
	off.translate(w / 2 + sin(xmotion) * 24, h / 2 - cos(ymotion) * 24, shape_z - sin(xmotion) * 148);
  off.rotateX(shape_angle_y + 2);
	off.rotateY(ymotion / 2 + 4);
	off.rotateZ(shape_angle_y + xmotion);
  off.box(shape_size);
	off.popMatrix();
	off.endDraw();
	
	off.beginDraw(); 
	off.pushMatrix();
	off.fill(255);
	off.stroke(4);
	off.translate(w / 2 + sin(xmotion) * 24, h / 2 - cos(ymotion) * 24, shape_z - sin(xmotion) * 148);
  off.rotateX(shape_angle_y + 90);
	off.rotateY(ymotion / 2 + 90);
	off.rotateZ(shape_angle_y + xmotion + 8);
  off.box(shape_size);
	off.popMatrix();
	off.endDraw();
	
	off.beginDraw(); 
	off.pushMatrix();
	off.fill(2);
	off.translate(w / 2 + sin(xmotion) * 24, h / 2 - cos(ymotion) * 24, shape_z - sin(xmotion) * 148);
  off.rotateX(shape_angle_y + 2);
	off.rotateY(ymotion / 2 + 4);
	off.rotateZ(shape_angle_y + xmotion);
	off.sphere(shape_size / 1.5);
	off.popMatrix();
	off.endDraw();
	
	/*
	// don't work and i don't know why (bug ?)
	off.pushMatrix();
	off.background(0, 0, 0, 255);
	//off.noStroke();
	off.fill(255);
	off.translate(w / 2, h / 2, shape_z);
  //off.rotateX(shape_angle_y);
	//off.rotateZ(shape_angle_y);
	off.scale(shape_size * 1.5);
	texturedCube(off, img1);
	off.popMatrix();
	*/
	shape_angle_y += .01;
	
	// draw the 3D offscreen context to the 2D offscreen context
	off_2d.image(off);
	
	// draw background
	//image(img2, 0, 256);
	
	// load 2D offscreen context pixels and iterate over all of them (by steps)
  off_2d.loadPixels();
	float i = 0;
  for (int y = 0; y < h; y += iter_step_y) {
		float yn = (float)y / h;
		int yi = y * h;
		
		for (int x = 0; x < w; x += iter_step_x) {
			int p = off_2d.pixels[x + yi];
			
			float pbr = brightness(p);

			if (pbr > 0) {
				float pr = red(p);
				float pg = green(p);
				float pb = blue(p);
				
				float xn = (float)x / w;
				float inn = (float)i / (w * h);
				
				float pbn = pbr / 255;
				
				// image lookup
				
				// can be fun, would be better with real texture mapping from the 3D context
				float xrepeat = 1;
				float yrepeat = 1;

				int xxd = ((int)(xn * (img1.width * xrepeat) - xmotion))%(img1.width);
				int yyd = (((int)((1.-yn) * (img1.height * yrepeat) - ymotion))%(img1.height)) * img1.width;

				xxd = abs(xxd);
				yyd = abs(yyd);

				int cl = (int)xxd + yyd;

				int r = (int)(red(img1.pixels[cl]) * (pbn * 2));
				int g = (int)(green(img1.pixels[cl]) * (pbn * 2));
				int b = (int)(blue(img1.pixels[cl]) * (pbn * 2));
				
				//
				
				float r = r + pr * (abs(sin(yn * PI + xmotion * pbn)));
				float g = g + pg * (abs(cos(xn * PI + xmotion)));
				float b = b + pb * (abs(sin(inn * PI + ymotion)));

				fill(r, g, b, pr);
				ellipse(x + cos(xn * PI + xmotion) * (yn * 128), y + sin(yn * PI + ymotion) * (xn * 148), 1 + random(24) * xn, 1 + random(24) * yn);
			}
			
			i += 1;
		}
  }
	
	// debug
	//image(off);
	
	xmotion += 0.05;
	ymotion += 0.09;
}"
"569939","Meshuggah","mySketch","/*
 * Technically similar to ""3D pixels smashing"" sketch but with a more interesting scene (2 cubes with black sphere)
 */

float shape_size = 340;
float shape_angle_y;
float shape_z = -100;

float xmotion = 0.;
float ymotion = 0.;

PGraphics off;
PGraphics off_2d;

PImage img1;
PImage img2;

int w = 700;
int h = 700;

// control the rendering quality / speed (basically the resolution by which we scan the 3D offscreen pixels)
int iter_step_x = 8;
int iter_step_y = 8;

int[] buffer = new int[w * h];
 
void texturedCube(PGraphics dst, PImage tex) {
  dst.beginShape(QUADS);
  dst.texture(tex);
  
	dst.vertex(-1, -1,  1, 0, 0);
	dst.vertex( 1, -1,  1, 1, 0);
	dst.vertex( 1,  1,  1, 1, 1);
	dst.vertex(-1,  1,  1, 0, 1);

	// -Z ""back"" face
	dst.vertex( 1, -1, -1, 0, 0);
	dst.vertex(-1, -1, -1, 1, 0);
	dst.vertex(-1,  1, -1, 1, 1);
	dst.vertex( 1,  1, -1, 0, 1);

	// +Y ""bottom"" face
	dst.vertex(-1,  1,  1, 0, 0);
	dst.vertex( 1,  1,  1, 1, 0);
	dst.vertex( 1,  1, -1, 1, 1);
	dst.vertex(-1,  1, -1, 0, 1);

	// -Y ""top"" face
	dst.vertex(-1, -1, -1, 0, 0);
	dst.vertex( 1, -1, -1, 1, 0);
	dst.vertex( 1, -1,  1, 1, 1);
	dst.vertex(-1, -1,  1, 0, 1);

	// +X ""right"" face
	dst.vertex( 1, -1,  1, 0, 0);
	dst.vertex( 1, -1, -1, 1, 0);
	dst.vertex( 1,  1, -1, 1, 1);
	dst.vertex( 1,  1,  1, 0, 1);

	// -X ""left"" face
	dst.vertex(-1, -1, -1, 0, 0);
	dst.vertex(-1, -1,  1, 1, 0);
	dst.vertex(-1,  1,  1, 1, 1);
	dst.vertex(-1,  1, -1, 0, 1);

  dst.endShape(CLOSE);
}

void setup() {
  size(w, h, P2D);  
	
	frameRate(60);
	
	noStroke();
	
	// we need a 2D offscreen context to draw the 3D offscreen context and process the pixels data
	off_2d = createGraphics(w, h, P2D);
	off_2d.background(0);

	// 3d offscreen context
	off = createGraphics(w, h, P3D);
	off.textureMode(NORMALIZED);
	off.smooth();
	off.lights();
	off.ambientLight(0, 0, 0);
	off.directionalLight(255, 255, 255, -16, 8, -4);
	off.lightFalloff(0., 0.8, 0);
	off.lightSpecular(0, 0, 0);
	//off.noFill();
	
	img1 = loadImage(""data.jpg"");
	img2 = loadImage(""vapor.jpg"");
	
	background(0);
}
 
void draw() {
	//background(0);
  fill(0, 0, 0, 16);
  rect(0, 0, w, h);
	
	// draw a cube into the 3D offscreen context
	off.beginDraw(); 
	off.pushMatrix();
	off.background(0, 0, 0, 1);
	off.fill(0, 255, 0);
	off.stroke(16);
	off.translate(w / 2 + sin(xmotion) * 24, h / 2 - cos(ymotion) * 24, shape_z - sin(xmotion) * 148);
  off.rotateX(shape_angle_y + 2);
	off.rotateY(ymotion / 2 + 4);
	off.rotateZ(shape_angle_y + xmotion);
  off.box(shape_size);
	off.popMatrix();
	off.endDraw();
	
	off.beginDraw(); 
	off.pushMatrix();
	off.fill(0, 255, 0);
	off.stroke(4);
	off.translate(w / 2 + sin(xmotion) * 24, h / 2 - cos(ymotion) * 24, shape_z - sin(xmotion) * 148);
  off.rotateX(-shape_angle_y + 2 + 90);
	off.rotateY(-ymotion / 2 + 4 + 90);
	off.rotateZ(shape_angle_y + xmotion + 8);
  off.box(shape_size);
	off.popMatrix();
	off.endDraw();
	
	off.beginDraw(); 
	off.pushMatrix();
	off.fill(256, 0, 0);
	off.translate(w / 2 + sin(xmotion) * 24, h / 2 - cos(ymotion) * 24, shape_z - sin(xmotion) * 148);
  off.rotateX(shape_angle_y + 2);
	off.rotateY(ymotion / 2 + 4);
	off.rotateZ(shape_angle_y + xmotion);
	off.sphere(shape_size / 1.5);
	off.popMatrix();
	off.endDraw();
	
	/*
	// don't work and i don't know why (bug ?)
	off.pushMatrix();
	off.background(0, 0, 0, 255);
	//off.noStroke();
	off.fill(255);
	off.translate(w / 2, h / 2, shape_z);
  //off.rotateX(shape_angle_y);
	//off.rotateZ(shape_angle_y);
	off.scale(shape_size * 1.5);
	texturedCube(off, img1);
	off.popMatrix();
	*/
	shape_angle_y += .01;
	
	// draw the 3D offscreen context to the 2D offscreen context
	off_2d.image(off);
	
	// load 2D offscreen context pixels and iterate over all of them (by steps)
  off_2d.loadPixels();
	float i = 0;
  for (int y = 0; y < h; y += iter_step_y) {
		float yn = (float)y / h;
		int yi = y * h;
		
		for (int x = 0; x < w; x += iter_step_x) {
			int p = off_2d.pixels[x + yi];
			
			float pbr = brightness(p);

			if (pbr > 0) {
				float pr = red(p);
				float pg = green(p);
				float pb = blue(p);
				
				float xn = (float)x / w;
				float inn = (float)i / (w * h);
				
				float pbn = pbr / 255;
				
				// image lookup
				
				// can be fun, would be better with real texture mapping from the 3D context
				float xrepeat = 1;
				float yrepeat = 1;

				int xxd = ((int)(xn * (img1.width * xrepeat) + xmotion * 2))%(img1.width);
				int yyd = (((int)((1.-yn) * (img1.height * yrepeat) - ymotion * 4))%(img1.height)) * img1.width;

				xxd = abs(xxd);
				yyd = abs(yyd);

				int cl = (int)xxd + yyd;

				int r = (int)(red(img1.pixels[cl]) * (pbn * 2));
				int g = (int)(green(img1.pixels[cl]) * (pbn * 2));
				int b = (int)(blue(img1.pixels[cl]) * (pbn * 2));
				int br = (int)(brightness(img1.pixels[cl]) * (pbn * 2));
				//
				
				float r = r + pr * (abs(sin(yn * PI + xmotion * pbn)));
				float g = g + pg * (abs(cos(xn * PI + xmotion)));
				float b = b + pb * (abs(sin(inn * PI + ymotion)));
				
				if (pr > 64) r = g = b = 255.;
				if (br < 8) pbr = 0;

				fill(r, g, b, pbr);
				ellipse(x + cos(xn * PI + xmotion) * (yn * 128), y + sin(yn * PI + ymotion) * (xn * 148), 1 + random(48) * xn, 1 + random(48) * yn);
			}
			
			i += 1;
		}
  }
	
	// debug
	//image(off);
	
	xmotion += 0.05;
	ymotion += 0.09;
}"
"569733","3D pixels smashing","mySketch","float shape_size = 300;
float shape_angle_y;
float shape_z = -130;

PGraphics off;
PImage off_image;

int buffer[512*512];
 
void setup() {
  size(512, 512, P2D);  
	
	frameRate(60);
	
	noStroke();

	off = createGraphics(512, 512, P3D);
	off.smooth();
	off.lights();
	off.noFill();
	off.stroke(1);
	
	off_image = createImage(512, 512, RGB);
	
	background(0);
}
 
void draw() {
	off.beginDraw(); 
	off.pushMatrix();
	off.background(0);
	off.translate(512 / 2, 512 / 2, shape_z);
  off.rotateY(shape_angle_y);
  off.box(shape_size);
	off.popMatrix();
	off.endDraw();
	
	shape_angle_y += .01;
	
	image(off);
	
  loadPixels();
  for (int i = 0; i < 512 * 512; i += 1) {
    int p = pixels[i];
		
		if (brightness(p) > 0) {
			int x = i & 511;
			int y = i >> 9;
			
			fill(255, 255, 255);
			rect(x, y, 24, 24);
		}
  }
}"
"569733","3D pixels smashing","mySketch","float shape_size = 300;
float shape_angle_y;
float shape_z = -100;

float xmotion = 0.;
float ymotion = 0.;

PGraphics off;
PGraphics off_2d;
PImage img1;

int w = 700;
int h = 700;

static int buffer[w*h];
 
void texturedCube(PGraphics dst, PImage tex) {
  dst.beginShape(QUADS);
  dst.texture(tex);
  
  // +Z ""front"" face
  dst.vertex(-1, -1,  1, 0, 0);
  dst.vertex( 1, -1,  1, 1, 0);
  dst.vertex( 1,  1,  1, 1, 1);
  dst.vertex(-1,  1,  1, 0, 1);

  // -Z ""back"" face
  dst.vertex( 1, -1, -1, 0, 0);
  dst.vertex(-1, -1, -1, 1, 0);
  dst.vertex(-1,  1, -1, 1, 1);
  dst.vertex( 1,  1, -1, 0, 1);

  // +Y ""bottom"" face
  dst.vertex(-1,  1,  1, 0, 0);
  dst.vertex( 1,  1,  1, 1, 0);
  dst.vertex( 1,  1, -1, 1, 1);
  dst.vertex(-1,  1, -1, 0, 1);

  // -Y ""top"" face
  dst.vertex(-1, -1, -1, 0, 0);
  dst.vertex( 1, -1, -1, 1, 0);
  dst.vertex( 1, -1,  1, 1, 1);
  dst.vertex(-1, -1,  1, 0, 1);

  // +X ""right"" face
  dst.vertex( 1, -1,  1, 0, 0);
  dst.vertex( 1, -1, -1, 1, 0);
  dst.vertex( 1,  1, -1, 1, 1);
  dst.vertex( 1,  1,  1, 0, 1);

  // -X ""left"" face
  dst.vertex(-1, -1, -1, 0, 0);
  dst.vertex(-1, -1,  1, 1, 0);
  dst.vertex(-1,  1,  1, 1, 1);
  dst.vertex(-1,  1, -1, 0, 1);

  dst.endShape();
}

void setup() {
  size(w, h, P2D);  
	
	frameRate(60);
	
	noStroke();
	
	off_2d = createGraphics(w, h, P2D);
	off_2d.background(0);

	off = createGraphics(w, h, P3D);
	off.textureMode(NORMAL);
	off.smooth();
	off.lights();
	off.ambientLight(128, 128, 128);
	off.directionalLight(128, 128, 128, 0, 0, -1);
	off.lightFalloff(1, 0.1, 0);
	off.lightSpecular(0, 0, 0);
	//off.noFill();
	
	img1 = loadImage(""door.jpg"");
	
	background(0);
}
 
void draw() {
	//background(0);
  fill(0, 0, 0, 64);
  rect(0, 0, w, h);
	/*
	off.beginDraw(); 
	off.pushMatrix();
	off.stroke(8);
	off.background(0, 0, 0, 255);
	off.translate(w / 2, h / 2, shape_z);
  off.rotateX(shape_angle_y);
	off.rotateZ(shape_angle_y);
  off.box(shape_size);
	off.popMatrix();
	off.endDraw();
	*/
	/*
	off.beginDraw(); 
	off.pushMatrix();
	off.translate(w - w / 4, h / 2, shape_z);
  off.rotateX(shape_angle_y);
	off.rotateZ(shape_angle_y);
	off.sphere(shape_size / 2);
	off.popMatrix();
	off.endDraw();
	*/
	
	off.pushMatrix();
	off.background(0, 0, 0, 255);
	off.noStroke();
	off.translate(w / 2, h / 2, shape_z);
  off.rotateX(shape_angle_y);
	off.rotateZ(shape_angle_y);
	off.scale(shape_size / 1.5);
	texturedCube(off, img1);
	off.popMatrix();
	
	shape_angle_y += .01;
	
	off_2d.image(off);
	
  off_2d.loadPixels();
	int i = 0;
  for (int y = 0; y < h; y += 6) {
		int yn = y / h;
		int yi = y * h;
		
		for (int x = 0; x < w; x += 4) {
			int p = off_2d.pixels[x + yi];
			
			int pbr = brightness(p);

			if (pbr > 0) {
				int pr = red(p);
				int pg = green(p);
				int pb = blue(p);
				
				int xn = x / w;
				int inn = i / (w * h);
				
				int pbn = pbr / 255;
				
				int r = pr + xn * 255;
				int g = pg + yn * 255;
				int b = pb + inn * 255;

				fill(r, g, b, pr);
				ellipse(x + cos(pbn * PI + xmotion) * (pbn * 128), y + sin(pbn * PI + ymotion) * (pbn * 32), 2 + random(16), 2 + random(16));
			}
			
			i += 1;
		}
  }
	
	//image(off);
	
	xmotion += 0.05;
	ymotion += 0.09;
}"
"569733","3D pixels smashing","mySketch","/*
 * ""voxels"" (sort of) from 3D rendering, the idea is to first render 3D stuff (a cube) into a offscreen context
 * then iterate over all the pixels data of that offscreen context and draw 2D shapes on screen for some of them,
 * the 2D shapes position and size are modulated to make seemingly complex stuff, the cube faces look like they are displaced,
 * some motion blur is applied to both the offscreen context and the screen,
 * the grid background is just an image, this idea can be quite fun to play with with more complex shapes and lights...!
 */

float shape_size = 300;
float shape_angle_y;
float shape_z = -100;

float xmotion = 0.;
float ymotion = 0.;

PGraphics off;
PGraphics off_2d;

PImage img1;
PImage img2;

int w = 700;
int h = 700;

// control the rendering quality / speed (basically the resolution by which we scan the 3D offscreen pixels)
int iter_step_x = 4;
int iter_step_y = 6;

static int buffer[w * h];
 
void texturedCube(PGraphics dst, PImage tex) {
  dst.beginShape(QUADS);
  dst.texture(tex);
  
	dst.vertex(-1, -1,  1, 0, 0);
	dst.vertex( 1, -1,  1, 1, 0);
	dst.vertex( 1,  1,  1, 1, 1);
	dst.vertex(-1,  1,  1, 0, 1);

	// -Z ""back"" face
	dst.vertex( 1, -1, -1, 0, 0);
	dst.vertex(-1, -1, -1, 1, 0);
	dst.vertex(-1,  1, -1, 1, 1);
	dst.vertex( 1,  1, -1, 0, 1);

	// +Y ""bottom"" face
	dst.vertex(-1,  1,  1, 0, 0);
	dst.vertex( 1,  1,  1, 1, 0);
	dst.vertex( 1,  1, -1, 1, 1);
	dst.vertex(-1,  1, -1, 0, 1);

	// -Y ""top"" face
	dst.vertex(-1, -1, -1, 0, 0);
	dst.vertex( 1, -1, -1, 1, 0);
	dst.vertex( 1, -1,  1, 1, 1);
	dst.vertex(-1, -1,  1, 0, 1);

	// +X ""right"" face
	dst.vertex( 1, -1,  1, 0, 0);
	dst.vertex( 1, -1, -1, 1, 0);
	dst.vertex( 1,  1, -1, 1, 1);
	dst.vertex( 1,  1,  1, 0, 1);

	// -X ""left"" face
	dst.vertex(-1, -1, -1, 0, 0);
	dst.vertex(-1, -1,  1, 1, 0);
	dst.vertex(-1,  1,  1, 1, 1);
	dst.vertex(-1,  1, -1, 0, 1);

  dst.endShape(CLOSE);
}

void setup() {
  size(w, h, P2D);  
	
	frameRate(60);
	
	noStroke();
	
	// we need a 2D offscreen context to draw the 3D offscreen context and process the pixels data
	off_2d = createGraphics(w, h, P2D);
	off_2d.background(0);

	// 3d offscreen context
	off = createGraphics(w, h, P3D);
	off.textureMode(NORMALIZED);
	off.smooth();
	off.lights();
	off.ambientLight(128, 128, 128);
	off.directionalLight(128, 128, 128, 0, 0, -1);
	off.lightFalloff(1, 0.1, 0.05);
	off.lightSpecular(0, 0, 0);
	//off.noFill();
	
	img1 = loadImage(""data.jpg"");
	img2 = loadImage(""vapor.jpg"");
	
	background(0);
}
 
void draw() {
	//background(0);
  fill(0, 0, 0, 64);
  rect(0, 0, w, h);
	
	// draw a cube into the 3D offscreen context
	off.beginDraw(); 
	off.pushMatrix();
	off.stroke(4);
	off.background(0, 0, 0, 4);
	off.translate(w / 2 + sin(xmotion) * 24, h / 2 - cos(ymotion) * 24, shape_z - sin(xmotion) * 48);
  off.rotateX(shape_angle_y + 2);
	off.rotateY(ymotion / 4 + 4);
	off.rotateZ(shape_angle_y + xmotion);
  off.box(shape_size);
	off.popMatrix();
	off.endDraw();
	
	/*
	off.beginDraw(); 
	off.pushMatrix();
	off.translate(w - w / 4, h / 2, shape_z);
  off.rotateX(shape_angle_y);
	off.rotateZ(shape_angle_y);
	off.sphere(shape_size / 2);
	off.popMatrix();
	off.endDraw();
	*/
	/*
	// don't work and i don't know why (bug ?)
	off.pushMatrix();
	off.background(0, 0, 0, 255);
	//off.noStroke();
	off.fill(255);
	off.translate(w / 2, h / 2, shape_z);
  //off.rotateX(shape_angle_y);
	//off.rotateZ(shape_angle_y);
	off.scale(shape_size * 1.5);
	texturedCube(off, img1);
	off.popMatrix();
	*/
	shape_angle_y += .01;
	
	// draw the 3D offscreen context to the 2D offscreen context
	off_2d.image(off);
	
	// draw background
	image(img2, 0, 256);
	
	// load 2D offscreen context pixels and iterate over all of them (by steps)
  off_2d.loadPixels();
	int i = 0;
  for (int y = 0; y < h; y += iter_step_y) {
		int yn = y / h;
		int yi = y * h;
		
		for (int x = 0; x < w; x += iter_step_x) {
			int p = off_2d.pixels[x + yi];
			
			int pbr = brightness(p);

			if (pbr > 0) {
				int pr = red(p);
				int pg = green(p);
				int pb = blue(p);
				
				int xn = x / w;
				int inn = i / (w * h);
				
				int pbn = pbr / 255;
				
				// image lookup
				/*
				// can be fun, would be better with real texture mapping from the 3D context
				float xrepeat = 1;
				float yrepeat = 1;

				int xxd = ((int)(xn * (img1.width * xrepeat) - xmotion))%(img1.width);
				int yyd = (((int)((1.-yn) * (img1.height * yrepeat) - ymotion))%(img1.height)) * img1.width;

				xxd = abs(xxd);
				yyd = abs(yyd);

				int cl = (int)xxd + yyd;

				int r = (int)(red(img1.pixels[cl]) * (pbn * 2));
				int g = (int)(green(img1.pixels[cl]) * (pbn * 2));
				int b = (int)(blue(img1.pixels[cl]) * (pbn * 2));
				*/
				//
				
				int r = pr * (abs(sin(yn * PI + xmotion * pbn)));
				int g = pg * (abs(cos(xn * PI + xmotion)));
				int b = pb * (abs(sin(inn * PI + ymotion)));

				fill(r, g, b, pr);
				ellipse(x + cos(pbn * PI + xmotion) * (pbn * 128), y + sin(pbn * PI + ymotion) * (pbn * 64), 2 + random(16), 2 + random(16));
			}
			
			i += 1;
		}
  }
	
	// debug
	//image(off);
	
	xmotion += 0.05;
	ymotion += 0.09;
}"
"569733","3D pixels smashing","mySketch","/*
 * ""voxels"" (sort of) from 3D rendering, the idea is to first render 3D stuff (a cube) into a offscreen context
 * then iterate over all the pixels data of that offscreen context and draw 2D shapes on screen for some of them,
 * the 2D shapes position and size are modulated to make seemingly complex stuff, the cube faces look like they are displaced,
 * some motion blur is applied to both the offscreen context and the screen,
 * the grid background is just an image, this idea can be quite fun to play with with more complex shapes and lights...!
 */

float shape_size = 300;
float shape_angle_y;
float shape_z = -100;

float xmotion = 0.;
float ymotion = 0.;

PGraphics off;
PGraphics off_2d;

PImage img1;
PImage img2;

int w = 700;
int h = 700;

// control the rendering quality / speed (basically the resolution by which we scan the 3D offscreen pixels)
int iter_step_x = 4;
int iter_step_y = 6;

static int buffer[w * h];
 
void texturedCube(PGraphics dst, PImage tex) {
  dst.beginShape(QUADS);
  dst.texture(tex);
  
	dst.vertex(-1, -1,  1, 0, 0);
	dst.vertex( 1, -1,  1, 1, 0);
	dst.vertex( 1,  1,  1, 1, 1);
	dst.vertex(-1,  1,  1, 0, 1);

	// -Z ""back"" face
	dst.vertex( 1, -1, -1, 0, 0);
	dst.vertex(-1, -1, -1, 1, 0);
	dst.vertex(-1,  1, -1, 1, 1);
	dst.vertex( 1,  1, -1, 0, 1);

	// +Y ""bottom"" face
	dst.vertex(-1,  1,  1, 0, 0);
	dst.vertex( 1,  1,  1, 1, 0);
	dst.vertex( 1,  1, -1, 1, 1);
	dst.vertex(-1,  1, -1, 0, 1);

	// -Y ""top"" face
	dst.vertex(-1, -1, -1, 0, 0);
	dst.vertex( 1, -1, -1, 1, 0);
	dst.vertex( 1, -1,  1, 1, 1);
	dst.vertex(-1, -1,  1, 0, 1);

	// +X ""right"" face
	dst.vertex( 1, -1,  1, 0, 0);
	dst.vertex( 1, -1, -1, 1, 0);
	dst.vertex( 1,  1, -1, 1, 1);
	dst.vertex( 1,  1,  1, 0, 1);

	// -X ""left"" face
	dst.vertex(-1, -1, -1, 0, 0);
	dst.vertex(-1, -1,  1, 1, 0);
	dst.vertex(-1,  1,  1, 1, 1);
	dst.vertex(-1,  1, -1, 0, 1);

  dst.endShape(CLOSE);
}

void setup() {
  size(w, h, P2D);  
	
	frameRate(60);
	
	noStroke();
	
	// we need a 2D offscreen context to draw the 3D offscreen context and process the pixels data
	off_2d = createGraphics(w, h, P2D);
	off_2d.background(0);

	// 3d offscreen context
	off = createGraphics(w, h, P3D);
	off.textureMode(NORMALIZED);
	off.smooth();
	off.lights();
	off.ambientLight(128, 128, 128);
	off.directionalLight(128, 128, 128, 0, 0, -1);
	off.lightFalloff(1, 0.1, 0.05);
	off.lightSpecular(0, 0, 0);
	//off.noFill();
	
	img1 = loadImage(""data.jpg"");
	img2 = loadImage(""vapor.jpg"");
	
	background(0);
}
 
void draw() {
	//background(0);
  fill(0, 0, 0, 64);
  rect(0, 0, w, h);
	
	// draw a cube into the 3D offscreen context
	off.beginDraw(); 
	off.pushMatrix();
	off.stroke(4);
	off.background(0, 0, 0, 4);
	off.translate(w / 2 + sin(xmotion) * 24, h / 2 - cos(ymotion) * 24, shape_z - sin(xmotion) * 48);
  off.rotateX(shape_angle_y + 2);
	off.rotateY(ymotion / 4 + 4);
	off.rotateZ(shape_angle_y + xmotion);
  off.box(shape_size);
	off.popMatrix();
	off.endDraw();
	
	/*
	off.beginDraw(); 
	off.pushMatrix();
	off.translate(w - w / 4, h / 2, shape_z);
  off.rotateX(shape_angle_y);
	off.rotateZ(shape_angle_y);
	off.sphere(shape_size / 2);
	off.popMatrix();
	off.endDraw();
	*/
	/*
	// don't work and i don't know why (bug ?)
	off.pushMatrix();
	off.background(0, 0, 0, 255);
	//off.noStroke();
	off.fill(255);
	off.translate(w / 2, h / 2, shape_z);
  //off.rotateX(shape_angle_y);
	//off.rotateZ(shape_angle_y);
	off.scale(shape_size * 1.5);
	texturedCube(off, img1);
	off.popMatrix();
	*/
	shape_angle_y += .01;
	
	// draw the 3D offscreen context to the 2D offscreen context
	off_2d.image(off);
	
	// draw background
	image(img2, 0, 256);
	
	// load 2D offscreen context pixels and iterate over all of them (by steps)
  off_2d.loadPixels();
	int i = 0;
  for (int y = 0; y < h; y += iter_step_y) {
		int yn = y / h;
		int yi = y * h;
		
		for (int x = 0; x < w; x += iter_step_x) {
			int p = off_2d.pixels[x + yi];
			
			int pbr = brightness(p);

			if (pbr > 0) {
				int pr = red(p);
				int pg = green(p);
				int pb = blue(p);
				
				int xn = x / w;
				int inn = i / (w * h);
				
				int pbn = pbr / 255;
				
				// image lookup
				/*
				// can be fun, would be better with real texture mapping from the 3D context
				float xrepeat = 1;
				float yrepeat = 1;

				int xxd = ((int)(xn * (img1.width * xrepeat) - xmotion))%(img1.width);
				int yyd = (((int)((1.-yn) * (img1.height * yrepeat) - ymotion))%(img1.height)) * img1.width;

				xxd = abs(xxd);
				yyd = abs(yyd);

				int cl = (int)xxd + yyd;

				int r = (int)(red(img1.pixels[cl]) * (pbn * 2));
				int g = (int)(green(img1.pixels[cl]) * (pbn * 2));
				int b = (int)(blue(img1.pixels[cl]) * (pbn * 2));
				*/
				//
				
				int r = pr * (abs(sin(yn * PI + xmotion * pbn)));
				int g = pg * (abs(cos(xn * PI + xmotion)));
				int b = pb * (abs(sin(inn * PI + ymotion)));

				fill(r, g, b, pr);
				ellipse(x + cos(pbn * PI + xmotion) * (pbn * 128), y + sin(pbn * PI + ymotion) * (pbn * 64), 2 + random(16), 2 + random(16));
			}
			
			i += 1;
		}
  }
	
	// debug
	//image(off);
	
	xmotion += 0.05;
	ymotion += 0.09;
}"
"569733","3D pixels smashing","mySketch","/*
 * ""voxels"" (sort of) from 3D rendering, the idea is to first render 3D stuff (a cube) into a offscreen context
 * then iterate over all the pixels data of that offscreen context and draw 2D shapes on screen for some of them,
 * the 2D shapes position and size are modulated to make seemingly complex stuff, the cube faces look like they are displaced,
 * some motion blur is applied to both the offscreen context and the screen,
 * the grid background is just an image, this idea can be quite fun to play with with more complex shapes and lights...!
 */

float shape_size = 300;
float shape_angle_y;
float shape_z = -100;

float xmotion = 0.;
float ymotion = 0.;

PGraphics off;
PGraphics off_2d;

PImage img1;
PImage img2;

int w = 700;
int h = 700;

// control the rendering quality / speed (basically the resolution by which we scan the 3D offscreen pixels)
int iter_step_x = 4;
int iter_step_y = 6;

int[] buffer = new int[w * h];
 
void texturedCube(PGraphics dst, PImage tex) {
  dst.beginShape(QUADS);
  dst.texture(tex);
  
	dst.vertex(-1, -1,  1, 0, 0);
	dst.vertex( 1, -1,  1, 1, 0);
	dst.vertex( 1,  1,  1, 1, 1);
	dst.vertex(-1,  1,  1, 0, 1);

	// -Z ""back"" face
	dst.vertex( 1, -1, -1, 0, 0);
	dst.vertex(-1, -1, -1, 1, 0);
	dst.vertex(-1,  1, -1, 1, 1);
	dst.vertex( 1,  1, -1, 0, 1);

	// +Y ""bottom"" face
	dst.vertex(-1,  1,  1, 0, 0);
	dst.vertex( 1,  1,  1, 1, 0);
	dst.vertex( 1,  1, -1, 1, 1);
	dst.vertex(-1,  1, -1, 0, 1);

	// -Y ""top"" face
	dst.vertex(-1, -1, -1, 0, 0);
	dst.vertex( 1, -1, -1, 1, 0);
	dst.vertex( 1, -1,  1, 1, 1);
	dst.vertex(-1, -1,  1, 0, 1);

	// +X ""right"" face
	dst.vertex( 1, -1,  1, 0, 0);
	dst.vertex( 1, -1, -1, 1, 0);
	dst.vertex( 1,  1, -1, 1, 1);
	dst.vertex( 1,  1,  1, 0, 1);

	// -X ""left"" face
	dst.vertex(-1, -1, -1, 0, 0);
	dst.vertex(-1, -1,  1, 1, 0);
	dst.vertex(-1,  1,  1, 1, 1);
	dst.vertex(-1,  1, -1, 0, 1);

  dst.endShape(CLOSE);
}

void setup() {
  size(w, h, P2D);  
	
	frameRate(60);
	
	noStroke();
	
	// we need a 2D offscreen context to draw the 3D offscreen context and process the pixels data
	off_2d = createGraphics(w, h, P2D);
	off_2d.background(0);

	// 3d offscreen context
	off = createGraphics(w, h, P3D);
	off.textureMode(NORMALIZED);
	off.smooth();
	off.lights();
	off.ambientLight(128, 128, 128);
	off.directionalLight(128, 128, 128, 0, 0, -1);
	off.lightFalloff(1, 0.1, 0.05);
	off.lightSpecular(0, 0, 0);
	//off.noFill();
	
	img1 = loadImage(""data.jpg"");
	img2 = loadImage(""vapor.jpg"");
	
	background(0);
}
 
void draw() {
	//background(0);
  fill(0, 0, 0, 64);
  rect(0, 0, w, h);
	
	// draw a cube into the 3D offscreen context
	off.beginDraw(); 
	off.pushMatrix();
	off.stroke(4);
	off.background(0, 0, 0, 4);
	off.translate(w / 2 + sin(xmotion) * 24, h / 2 - cos(ymotion) * 24, shape_z - sin(xmotion) * 48);
  off.rotateX(shape_angle_y + 2);
	off.rotateY(ymotion / 4 + 4);
	off.rotateZ(shape_angle_y + xmotion);
  off.box(shape_size);
	off.popMatrix();
	off.endDraw();
	
	/*
	off.beginDraw(); 
	off.pushMatrix();
	off.translate(w - w / 4, h / 2, shape_z);
  off.rotateX(shape_angle_y);
	off.rotateZ(shape_angle_y);
	off.sphere(shape_size / 2);
	off.popMatrix();
	off.endDraw();
	*/
	/*
	// don't work and i don't know why (bug ?)
	off.pushMatrix();
	off.background(0, 0, 0, 255);
	//off.noStroke();
	off.fill(255);
	off.translate(w / 2, h / 2, shape_z);
  //off.rotateX(shape_angle_y);
	//off.rotateZ(shape_angle_y);
	off.scale(shape_size * 1.5);
	texturedCube(off, img1);
	off.popMatrix();
	*/
	shape_angle_y += .01;
	
	// draw the 3D offscreen context to the 2D offscreen context
	off_2d.image(off);
	
	// draw background
	image(img2, 0, 256);
	
	// load 2D offscreen context pixels and iterate over all of them (by steps)
  off_2d.loadPixels();
	int i = 0;
  for (int y = 0; y < h; y += iter_step_y) {
		int yn = y / h;
		int yi = y * h;
		
		for (int x = 0; x < w; x += iter_step_x) {
			int p = off_2d.pixels[x + yi];
			
			int pbr = brightness(p);

			if (pbr > 0) {
				int pr = red(p);
				int pg = green(p);
				int pb = blue(p);
				
				int xn = x / w;
				int inn = i / (w * h);
				
				int pbn = pbr / 255;
				
				// image lookup
				/*
				// can be fun, would be better with real texture mapping from the 3D context
				float xrepeat = 1;
				float yrepeat = 1;

				int xxd = ((int)(xn * (img1.width * xrepeat) - xmotion))%(img1.width);
				int yyd = (((int)((1.-yn) * (img1.height * yrepeat) - ymotion))%(img1.height)) * img1.width;

				xxd = abs(xxd);
				yyd = abs(yyd);

				int cl = (int)xxd + yyd;

				int r = (int)(red(img1.pixels[cl]) * (pbn * 2));
				int g = (int)(green(img1.pixels[cl]) * (pbn * 2));
				int b = (int)(blue(img1.pixels[cl]) * (pbn * 2));
				*/
				//
				
				int r = pr * (abs(sin(yn * PI + xmotion * pbn)));
				int g = pg * (abs(cos(xn * PI + xmotion)));
				int b = pb * (abs(sin(inn * PI + ymotion)));

				fill(r, g, b, pr);
				ellipse(x + cos(pbn * PI + xmotion) * (pbn * 128), y + sin(pbn * PI + ymotion) * (pbn * 64), 2 + random(16), 2 + random(16));
			}
			
			i += 1;
		}
  }
	
	// debug
	//image(off);
	
	xmotion += 0.05;
	ymotion += 0.09;
}"
"569733","3D pixels smashing","mySketch","/*
 * ""voxels"" (sort of) from 3D rendering, the idea is to first render 3D stuff (a cube) into a offscreen context
 * then iterate over all the pixels data of that offscreen context and draw 2D shapes on screen for some of them,
 * the 2D shapes position and size are modulated to make seemingly complex stuff, the cube faces look like they are displaced,
 * some motion blur is applied to both the offscreen context and the screen,
 * the grid background is just an image, this idea can be quite fun to play with with more complex shapes and lights...!
 */

float shape_size = 300;
float shape_angle_y;
float shape_z = -100;

float xmotion = 0.;
float ymotion = 0.;

PGraphics off;
PGraphics off_2d;

PImage img1;
PImage img2;

int w = 700;
int h = 700;

// control the rendering quality / speed (basically the resolution by which we scan the 3D offscreen pixels)
int iter_step_x = 4;
int iter_step_y = 6;

int[] buffer = new int[w * h];
 
void texturedCube(PGraphics dst, PImage tex) {
  dst.beginShape(QUADS);
  dst.texture(tex);
  
	dst.vertex(-1, -1,  1, 0, 0);
	dst.vertex( 1, -1,  1, 1, 0);
	dst.vertex( 1,  1,  1, 1, 1);
	dst.vertex(-1,  1,  1, 0, 1);

	// -Z ""back"" face
	dst.vertex( 1, -1, -1, 0, 0);
	dst.vertex(-1, -1, -1, 1, 0);
	dst.vertex(-1,  1, -1, 1, 1);
	dst.vertex( 1,  1, -1, 0, 1);

	// +Y ""bottom"" face
	dst.vertex(-1,  1,  1, 0, 0);
	dst.vertex( 1,  1,  1, 1, 0);
	dst.vertex( 1,  1, -1, 1, 1);
	dst.vertex(-1,  1, -1, 0, 1);

	// -Y ""top"" face
	dst.vertex(-1, -1, -1, 0, 0);
	dst.vertex( 1, -1, -1, 1, 0);
	dst.vertex( 1, -1,  1, 1, 1);
	dst.vertex(-1, -1,  1, 0, 1);

	// +X ""right"" face
	dst.vertex( 1, -1,  1, 0, 0);
	dst.vertex( 1, -1, -1, 1, 0);
	dst.vertex( 1,  1, -1, 1, 1);
	dst.vertex( 1,  1,  1, 0, 1);

	// -X ""left"" face
	dst.vertex(-1, -1, -1, 0, 0);
	dst.vertex(-1, -1,  1, 1, 0);
	dst.vertex(-1,  1,  1, 1, 1);
	dst.vertex(-1,  1, -1, 0, 1);

  dst.endShape(CLOSE);
}

void setup() {
  size(w, h, P2D);  
	
	frameRate(60);
	
	noStroke();
	
	// we need a 2D offscreen context to draw the 3D offscreen context and process the pixels data
	off_2d = createGraphics(w, h, P2D);
	off_2d.background(0);

	// 3d offscreen context
	off = createGraphics(w, h, P3D);
	off.textureMode(NORMALIZED);
	off.smooth();
	off.lights();
	off.ambientLight(128, 128, 128);
	off.directionalLight(128, 128, 128, 0, 0, -1);
	off.lightFalloff(1, 0.1, 0.05);
	off.lightSpecular(0, 0, 0);
	//off.noFill();
	
	img1 = loadImage(""data.jpg"");
	img2 = loadImage(""vapor.jpg"");
	
	background(0);
}
 
void draw() {
	//background(0);
  fill(0, 0, 0, 64);
  rect(0, 0, w, h);
	
	// draw a cube into the 3D offscreen context
	off.beginDraw(); 
	off.pushMatrix();
	off.stroke(4);
	off.background(0, 0, 0, 4);
	off.translate(w / 2 + sin(xmotion) * 24, h / 2 - cos(ymotion) * 24, shape_z - sin(xmotion) * 48);
  off.rotateX(shape_angle_y + 2);
	off.rotateY(ymotion / 4 + 4);
	off.rotateZ(shape_angle_y + xmotion);
  off.box(shape_size);
	off.popMatrix();
	off.endDraw();
	
	/*
	off.beginDraw(); 
	off.pushMatrix();
	off.translate(w - w / 4, h / 2, shape_z);
  off.rotateX(shape_angle_y);
	off.rotateZ(shape_angle_y);
	off.sphere(shape_size / 2);
	off.popMatrix();
	off.endDraw();
	*/
	/*
	// don't work and i don't know why (bug ?)
	off.pushMatrix();
	off.background(0, 0, 0, 255);
	//off.noStroke();
	off.fill(255);
	off.translate(w / 2, h / 2, shape_z);
  //off.rotateX(shape_angle_y);
	//off.rotateZ(shape_angle_y);
	off.scale(shape_size * 1.5);
	texturedCube(off, img1);
	off.popMatrix();
	*/
	shape_angle_y += .01;
	
	// draw the 3D offscreen context to the 2D offscreen context
	off_2d.image(off);
	
	// draw background
	image(img2, 0, 256);
	
	// load 2D offscreen context pixels and iterate over all of them (by steps)
  off_2d.loadPixels();
	int i = 0;
  for (int y = 0; y < h; y += iter_step_y) {
		float yn = y / h;
		int yi = y * h;
		
		for (int x = 0; x < w; x += iter_step_x) {
			int p = off_2d.pixels[x + yi];
			
			float pbr = brightness(p);

			if (pbr > 0) {
				float pr = red(p);
				float pg = green(p);
				float pb = blue(p);
				
				float xn = x / w;
				float inn = i / (w * h);
				
				float pbn = pbr / 255;
				
				// image lookup
				/*
				// can be fun, would be better with real texture mapping from the 3D context
				float xrepeat = 1;
				float yrepeat = 1;

				int xxd = ((int)(xn * (img1.width * xrepeat) - xmotion))%(img1.width);
				int yyd = (((int)((1.-yn) * (img1.height * yrepeat) - ymotion))%(img1.height)) * img1.width;

				xxd = abs(xxd);
				yyd = abs(yyd);

				int cl = (int)xxd + yyd;

				int r = (int)(red(img1.pixels[cl]) * (pbn * 2));
				int g = (int)(green(img1.pixels[cl]) * (pbn * 2));
				int b = (int)(blue(img1.pixels[cl]) * (pbn * 2));
				*/
				//
				
				float r = pr * (abs(sin(yn * PI + xmotion * pbn)));
				float g = pg * (abs(cos(xn * PI + xmotion)));
				float b = pb * (abs(sin(inn * PI + ymotion)));

				fill(r, g, b, pr);
				ellipse(x + cos(pbn * PI + xmotion) * (pbn * 128), y + sin(pbn * PI + ymotion) * (pbn * 64), 2 + random(16), 2 + random(16));
			}
			
			i += 1;
		}
  }
	
	// debug
	//image(off);
	
	xmotion += 0.05;
	ymotion += 0.09;
}"
"568729","Triangle","mySketch","PImage colormap;
PImage door_texture;

float xmotion = 0;
float ymotion = 0;
float rmotion = 0;

int bottom_elems_x = 110;
int left_elems_x = 110;
int elems_y = 112;
int elems_x_step = 1;
int elems_y_step = 1;


void draw_func() {
  fill(0, 0, 0, 2);
  rect(0, 0, 1024, 700);

  noStroke();

  int tri_min_distance_center = 64;

  float bottom_part_x_start;
  float bottom_part_y_start = 700 / 2 + tri_min_distance_center;
  float bottom_part_x_step_inc = 0;
  float bottom_part_rect_size = 4;

  float left_part_x_start;
  float left_part_y_start;
  float left_part_y_step = 0;
  float left_part_x_step_inc = 0;
  float left_part_rect_size = 1;
  
  float y_offset = 172;
 

  for (int e = 0; e < elems_y; e += elems_y_step) {
    float normalized_e = (float)e / elems_y;
    
    float xxmotion = abs(sin(normalized_e / 2 * 360 * (PI / 180) + xmotion) * 2);

    bottom_part_x_start = 1024 / 2 - bottom_part_x_step_inc;
    left_part_x_start = 1024 / 2 - bottom_part_x_step_inc * 2 - left_elems_x * (0.8 + bottom_part_x_step_inc);
    left_part_y_start = 700 / 2 + tri_min_distance_center - left_part_x_step_inc * 2 + left_part_y_step + xxmotion;

    for (int j = 0; j < left_elems_x + left_part_y_step*2; j += elems_x_step) {
      float normalized_j = ((float)j / (left_elems_x + left_part_y_step));
      
      float yymotion = sin(normalized_j / 4 * 360 * (PI / 180) + ymotion / 4) * 0.05;
      float yymotion2 = -4 + cos(normalized_j * 2 * 360 * (PI / 180) + ymotion / 4) * 0.5;

      float xrepeat = 2;
      float yrepeat = 1;

      int xxd = ((int)(normalized_e * (door_texture.width * xrepeat) - xmotion * 200))%(door_texture.width);
      int yyd = (((int)((1.-normalized_j) * (door_texture.height * yrepeat) - ymotion*2))%(door_texture.height)) * door_texture.width;
      
      xxd = abs(xxd);
      yyd = abs(yyd);
      
      int cl = (int)xxd + yyd;

      int r = (int)(red(door_texture.pixels[cl]) * (normalized_e * 2));
      int g = (int)(green(door_texture.pixels[cl]) * (normalized_e * 2));
      int b = (int)(blue(door_texture.pixels[cl]) * (normalized_e * 2));
      
      if ((r + g + b) / 3 > 4) { 
        fill(r, g, b);
        
        rect(left_part_x_start + random(2.), left_part_y_start + y_offset + random(2.), left_part_rect_size, left_part_rect_size);
      }
      
      left_part_y_start -= 1.75 - left_part_x_step_inc+yymotion;
      left_part_x_start += 4.8 + yymotion2 + 2 * normalized_j;
    }
    
    for (int j = 0; j < bottom_elems_x; j += elems_x_step) {
      float normalized_j = ((float)j / bottom_elems_x);

      float xrepeat = 2.;
      float yrepeat = 1.;

      float yymotion = (sin(normalized_e * 360 * (PI / 180) + ymotion)) * 14. * (1.0-normalized_j);
      
      int xxd = ((int)(normalized_e * (colormap.width * xrepeat) - xmotion*200))%(colormap.width);
      int yyd = (((int)(normalized_j * (colormap.height * yrepeat - xxmotion)))%(colormap.height)) * colormap.width;
      
      xxd = abs(xxd);
      yyd = abs(yyd);
      
      int cl = (int)xxd + yyd;

      int r = (int)(red(colormap.pixels[cl]) * (normalized_e * 4));
      int g = (int)(green(colormap.pixels[cl]) * (normalized_e * 4));
      int b = (int)(blue(colormap.pixels[cl]) * (normalized_e * 4));
      
      fill(r, g, b);

      rect(bottom_part_x_start, bottom_part_y_start + y_offset + yymotion, bottom_part_rect_size, bottom_part_rect_size);

      bottom_part_x_start -= 0.5 + bottom_part_x_step_inc;
    }
    
    bottom_part_y_start += 1;
    bottom_part_x_start -= 2 + bottom_part_x_step_inc;

    bottom_part_x_step_inc += 0.045;
    left_part_x_step_inc -= 0.005;

    left_part_y_step += 1;

    bottom_part_rect_size += 0.0025 * xxmotion;
    left_part_rect_size += 0.0025 * xxmotion;
  }

  loadPixels();
  for (int y = 0; y < 700; y += 1) {
    for (int x = 0; x < 1024 / 2; x += 1) {
      int isrc = x + y * 1024;
      int idst = (1023 - x) + y * 1024;
      pixels[idst] = pixels[isrc];
    }
  }
  updatePixels();

  xmotion += 0.05;
  ymotion += 0.025;
  rmotion += 0.012;
}

void setup() {
  size(1024, 700);

  frameRate(60); 

  colormap = loadImage(""data.jpg"");
  door_texture = loadImage(""door.jpg"");

  background(0);
}

void draw() {
  //background(0);

  draw_func();
}
"
"568729","Triangle","mySketch","PImage colormap;
PImage door_texture;

float xmotion = 0;
float ymotion = 0;
float rmotion = 0;

int bottom_elems_x = 110;
int left_elems_x = 110;
int elems_y = 112 / 2;
int elems_x_step = 1;
int elems_y_step = 1;


void draw_func() {
  fill(0, 0, 0, 2);
  rect(0, 0, 640, 480);

  noStroke();

  int tri_min_distance_center = 0;

  float bottom_part_x_start;
  float bottom_part_y_start = 480 / 2 + tri_min_distance_center;
  float bottom_part_x_step_inc = 0;
  float bottom_part_rect_size = 4;

  float left_part_x_start;
  float left_part_y_start;
  float left_part_y_step = 0;
  float left_part_x_step_inc = 0;
  float left_part_rect_size = 1;
  
  float y_offset = 172 / 2;
 

  for (int e = 0; e < elems_y; e += elems_y_step) {
    float normalized_e = (float)e / elems_y;
    
    float xxmotion = abs(sin(normalized_e / 2 * 360 * (PI / 180) + xmotion) * 2);

    bottom_part_x_start = 640 / 2 - bottom_part_x_step_inc;
    left_part_x_start = 640 / 2 - bottom_part_x_step_inc * 2 - left_elems_x * (0.8 + bottom_part_x_step_inc);
    left_part_y_start = 480 / 2 + tri_min_distance_center - left_part_x_step_inc * 2 + left_part_y_step + xxmotion;

    for (int j = 0; j < left_elems_x + left_part_y_step*2; j += elems_x_step) {
      float normalized_j = ((float)j / (left_elems_x + left_part_y_step));
      
      float yymotion = sin(normalized_j / 4 * 360 * (PI / 180) + ymotion / 4) * 0.05;
      float yymotion2 = -4 + cos(normalized_j * 2 * 360 * (PI / 180) + ymotion / 4) * 0.5;

      float xrepeat = 2;
      float yrepeat = 1;

      int xxd = ((int)(normalized_e * (door_texture.width * xrepeat) - xmotion * 200))%(door_texture.width);
      int yyd = (((int)((1.-normalized_j) * (door_texture.height * yrepeat) - ymotion*2))%(door_texture.height)) * door_texture.width;
      
      xxd = abs(xxd);
      yyd = abs(yyd);
      
      int cl = (int)xxd + yyd;

      int r = (int)(red(door_texture.pixels[cl]) * (normalized_e * 2));
      int g = (int)(green(door_texture.pixels[cl]) * (normalized_e * 2));
      int b = (int)(blue(door_texture.pixels[cl]) * (normalized_e * 2));
      
      if ((r + g + b) / 3 > 4) { 
        fill(r, g, b);
        
        rect(left_part_x_start + random(2.), left_part_y_start + y_offset + random(2.), left_part_rect_size, left_part_rect_size);
      }
      
      left_part_y_start -= 1.75 - left_part_x_step_inc+yymotion;
      left_part_x_start += 4.8 + yymotion2 + 2 * normalized_j;
    }
    
    for (int j = 0; j < bottom_elems_x; j += elems_x_step) {
      float normalized_j = ((float)j / bottom_elems_x);

      float xrepeat = 2.;
      float yrepeat = 1;

      float yymotion = (sin(normalized_e * 360 * (PI / 180) + ymotion)) * 14. * (1.0-normalized_j);
      
      int xxd = ((int)(normalized_e * (colormap.width * xrepeat) - xmotion*800))%(colormap.width);
      int yyd = (((int)(normalized_j * (colormap.height * yrepeat - xxmotion)))%(colormap.height)) * colormap.width;
      
      xxd = abs(xxd);
      yyd = abs(yyd);
      
      int cl = (int)xxd + yyd;

      int r = (int)(red(colormap.pixels[cl]) * (normalized_e * 4));
      int g = (int)(green(colormap.pixels[cl]) * (normalized_e * 4));
      int b = (int)(blue(colormap.pixels[cl]) * (normalized_e * 4));
      
      fill(r, g, b);

      rect(bottom_part_x_start, bottom_part_y_start + y_offset + yymotion, bottom_part_rect_size, bottom_part_rect_size);

      bottom_part_x_start -= 0.5 + bottom_part_x_step_inc;
    }
    
    bottom_part_y_start += 1;
    bottom_part_x_start -= 2 + bottom_part_x_step_inc;

    bottom_part_x_step_inc += 0.045;
    left_part_x_step_inc -= 0.005;

    left_part_y_step += 1;

    bottom_part_rect_size += 0.0025 * xxmotion;
    left_part_rect_size += 0.0025 * xxmotion;
  }

  loadPixels();
  for (int y = 0; y < 480; y += 1) {
    for (int x = 0; x < 640 / 2; x += 1) {
      int isrc = x + y * 640;
      int idst = (639 - x) + y * 640;
      pixels[idst] = pixels[isrc];
    }
  }
  updatePixels();

  xmotion += 0.05;
  ymotion += 0.025;
  rmotion += 0.012;
}

void setup() {
  size(640, 480);

  frameRate(60); 

  colormap = loadImage(""data.jpg"");
  door_texture = loadImage(""door.jpg"");

  background(0);
}

void draw() {
  //background(0);

  draw_func();
}"
"568729","Triangle","mySketch","PImage colormap;
PImage door_texture;

float xmotion = 0;
float ymotion = 0;
float rmotion = 0;

int bottom_elems_x = 110;
int left_elems_x = 110;
int elems_y = 112 / 2;
int elems_x_step = 1;
int elems_y_step = 1;


void draw_func() {
  fill(0, 0, 0, 2);
  rect(0, 0, 640, 480);

  noStroke();

  int tri_min_distance_center = 0;

  float bottom_part_x_start;
  float bottom_part_y_start = 480 / 2 + tri_min_distance_center;
  float bottom_part_x_step_inc = 0;
  float bottom_part_rect_size = 4;

  float left_part_x_start;
  float left_part_y_start;
  float left_part_y_step = 0;
  float left_part_x_step_inc = 0;
  float left_part_rect_size = 1;
  
  float y_offset = 172 / 2;
 

  for (int e = 0; e < elems_y; e += elems_y_step) {
    float normalized_e = (float)e / elems_y;
    
    float xxmotion = abs(sin(normalized_e / 2 * 360 * (PI / 180) + xmotion) * 2);

    bottom_part_x_start = 640 / 2 - bottom_part_x_step_inc;
    left_part_x_start = 640 / 2 - bottom_part_x_step_inc * 2 - left_elems_x * (0.8 + bottom_part_x_step_inc);
    left_part_y_start = 480 / 2 + tri_min_distance_center - left_part_x_step_inc * 2 + left_part_y_step + xxmotion;

    for (int j = 0; j < left_elems_x + left_part_y_step*2; j += elems_x_step) {
      float normalized_j = ((float)j / (left_elems_x + left_part_y_step));
      
      float yymotion = sin(normalized_j / 4 * 360 * (PI / 180) + ymotion / 4) * 0.05;
      float yymotion2 = -4 + cos(normalized_j * 2 * 360 * (PI / 180) + ymotion / 4) * 0.5;

      float xrepeat = 2;
      float yrepeat = 1;

      int xxd = ((int)(normalized_e * (door_texture.width * xrepeat) - xmotion * 400))%(door_texture.width);
      int yyd = (((int)((1.-normalized_j) * (door_texture.height * yrepeat) - ymotion*2))%(door_texture.height)) * door_texture.width;
      
      xxd = abs(xxd);
      yyd = abs(yyd);
      
      int cl = (int)xxd + yyd;

      int r = (int)(red(door_texture.pixels[cl]) * (normalized_e * 2));
      int g = (int)(green(door_texture.pixels[cl]) * (normalized_e * 2));
      int b = (int)(blue(door_texture.pixels[cl]) * (normalized_e * 2));
      
      if ((r + g + b) / 3 > 4) { 
        fill(r, g, b);
        
        rect(left_part_x_start + random(2.), left_part_y_start + y_offset + random(2.), left_part_rect_size, left_part_rect_size);
      }
      
      left_part_y_start -= 1.75 - left_part_x_step_inc+yymotion;
      left_part_x_start += 4.8 + yymotion2 + 2 * normalized_j;
    }
    
    for (int j = 0; j < bottom_elems_x; j += elems_x_step) {
      float normalized_j = ((float)j / bottom_elems_x);

      float xrepeat = 2.;
      float yrepeat = 1;

      float yymotion = (sin(normalized_e * 360 * (PI / 180) + ymotion)) * 14. * (1.0-normalized_j);
      
      int xxd = ((int)(normalized_e * (colormap.width * xrepeat) - xmotion*800))%(colormap.width);
      int yyd = (((int)(normalized_j * (colormap.height * yrepeat - xxmotion)))%(colormap.height)) * colormap.width;
      
      xxd = abs(xxd);
      yyd = abs(yyd);
      
      int cl = (int)xxd + yyd;

      int r = (int)(red(colormap.pixels[cl]) * (normalized_e * 4));
      int g = (int)(green(colormap.pixels[cl]) * (normalized_e * 4));
      int b = (int)(blue(colormap.pixels[cl]) * (normalized_e * 4));
      
      fill(r, g, b);

      rect(bottom_part_x_start, bottom_part_y_start + y_offset + yymotion, bottom_part_rect_size, bottom_part_rect_size);

      bottom_part_x_start -= 0.5 + bottom_part_x_step_inc;
    }
    
    bottom_part_y_start += 1;
    bottom_part_x_start -= 2 + bottom_part_x_step_inc;

    bottom_part_x_step_inc += 0.045;
    left_part_x_step_inc -= 0.005;

    left_part_y_step += 1;

    bottom_part_rect_size += 0.0025 * xxmotion;
    left_part_rect_size += 0.0025 * xxmotion;
  }

  loadPixels();
  for (int y = 0; y < 480; y += 1) {
    for (int x = 0; x < 640 / 2; x += 1) {
      int isrc = x + y * 640;
      int idst = (639 - x) + y * 640;
      pixels[idst] = pixels[isrc];
    }
  }
  updatePixels();

  xmotion += 0.05;
  ymotion += 0.025;
  rmotion += 0.012;
}

void setup() {
  size(640, 480);

  frameRate(60); 

  colormap = loadImage(""data.jpg"");
  door_texture = loadImage(""door.jpg"");

  background(0);
}

void draw() {
  //background(0);

  draw_func();
}"
"568729","Triangle","mySketch","PImage colormap;
PImage door_texture;

float xmotion = 0;
float ymotion = 0;
float rmotion = 0;

int bottom_elems_x = 110;
int left_elems_x = 110;
int elems_y = 112 / 2;
int elems_x_step = 1;
int elems_y_step = 1;


void draw_func() {
  fill(0, 0, 0, 2);
  rect(0, 0, 640, 480);

  noStroke();

  int tri_min_distance_center = 0;

  float bottom_part_x_start;
  float bottom_part_y_start = 480 / 2 + tri_min_distance_center;
  float bottom_part_x_step_inc = 0;
  float bottom_part_rect_size = 4;

  float left_part_x_start;
  float left_part_y_start;
  float left_part_y_step = 0;
  float left_part_x_step_inc = 0;
  float left_part_rect_size = 1;
  
  float y_offset = 172 / 2;
 
  for (int e = 0; e < elems_y; e += elems_y_step) {
    float normalized_e = (float)e / elems_y;
    
    float xxmotion = abs(sin(normalized_e / 2 * 360 * (PI / 180) + xmotion) * 2);

    bottom_part_x_start = 640 / 2 - bottom_part_x_step_inc;
    left_part_x_start = 640 / 2 - bottom_part_x_step_inc * 2 - left_elems_x * (0.8 + bottom_part_x_step_inc);
    left_part_y_start = 480 / 2 + tri_min_distance_center - left_part_x_step_inc * 2 + left_part_y_step + xxmotion;

    for (int j = 0; j < left_elems_x + left_part_y_step*2; j += elems_x_step) {
      float normalized_j = ((float)j / (left_elems_x + left_part_y_step));
      
      float yymotion = sin(normalized_j / 4 * 360 * (PI / 180) + ymotion / 4) * 0.05;
      float yymotion2 = -4 + cos(normalized_j * 2 * 360 * (PI / 180) + ymotion / 4) * 0.5;

      float xrepeat = 4;
      float yrepeat = 2;

      int xxd = ((int)(normalized_e * (door_texture.width * xrepeat) - xmotion * 400))%(door_texture.width);
      int yyd = (((int)((1.-normalized_j) * (door_texture.height * yrepeat) - ymotion*2))%(door_texture.height)) * door_texture.width;
      
      xxd = abs(xxd);
      yyd = abs(yyd);
      
      int cl = (int)xxd + yyd;

      int r = (int)(red(door_texture.pixels[cl]) * (normalized_e * 2));
      int g = (int)(green(door_texture.pixels[cl]) * (normalized_e * 2));
      int b = (int)(blue(door_texture.pixels[cl]) * (normalized_e * 2));
      
      if ((r + g + b) / 3 > 4) { 
        fill(r, g, b, normalized_e * 255);
        
        rect(left_part_x_start + random(2.), left_part_y_start + y_offset + random(2.), left_part_rect_size, left_part_rect_size);
      }
      
      left_part_y_start -= 1.6 - left_part_x_step_inc+yymotion;
      left_part_x_start += 3.8 + yymotion2 + 2 * normalized_j;
    }
    
    for (int j = 0; j < bottom_elems_x; j += elems_x_step) {
      float normalized_j = ((float)j / bottom_elems_x);

      float xrepeat = 2.;
      float yrepeat = 1;

      float yymotion = (sin(normalized_e * 360 * (PI / 180) + ymotion)) * 14. * (1.0-normalized_j);
      
      int xxd = ((int)(normalized_e * (colormap.width * xrepeat) - xmotion*800))%(colormap.width);
      int yyd = (((int)(normalized_j * (colormap.height * yrepeat - xxmotion)))%(colormap.height)) * colormap.width;
      
      xxd = abs(xxd);
      yyd = abs(yyd);
      
      int cl = (int)xxd + yyd;

      int r = (int)(red(colormap.pixels[cl]) * (normalized_e * 4));
      int g = (int)(green(colormap.pixels[cl]) * (normalized_e * 4));
      int b = (int)(blue(colormap.pixels[cl]) * (normalized_e * 4));
      
      fill(r, g, b, 32);

      rect(bottom_part_x_start, bottom_part_y_start + y_offset + yymotion + 32, bottom_part_rect_size, bottom_part_rect_size);

      bottom_part_x_start -= 0.5 + bottom_part_x_step_inc;
    }
    
    bottom_part_y_start += 1;
    bottom_part_x_start -= 2 + bottom_part_x_step_inc;

    bottom_part_x_step_inc += 0.045;
    left_part_x_step_inc -= 0.005;

    left_part_y_step += 1.8;

    bottom_part_rect_size += 0.0025 * xxmotion;
    left_part_rect_size += 0.0025 * xxmotion;
  }

  loadPixels();
  for (int y = 0; y < 480; y += 1) {
    for (int x = 0; x < 640 / 2; x += 1) {
      int isrc = x + y * 640;
      int idst = (639 - x) + y * 640;
      pixels[idst] = pixels[isrc];
    }
  }
  updatePixels();

  xmotion += 0.05;
  ymotion += 0.025;
  rmotion += 0.012;
}

void setup() {
  size(640, 480);

  frameRate(60); 

  colormap = loadImage(""data.jpg"");
  door_texture = loadImage(""door.jpg"");

  background(0);
}

void draw() {
  //background(0);

  draw_func();
}"
"568729","Triangle","mySketch","PImage colormap;
PImage door_texture;

float xmotion = 0;
float ymotion = 0;
float rmotion = 0;

int bottom_elems_x = 110;
int left_elems_x = 110;
int elems_y = 112 / 2;
int elems_x_step = 1;
int elems_y_step = 1;


void draw_func() {
  fill(0, 0, 0, 2);
  rect(0, 0, 640, 480);

  noStroke();

  int tri_min_distance_center = 0;

  float bottom_part_x_start;
  float bottom_part_y_start = 480 / 2 + tri_min_distance_center;
  float bottom_part_x_step_inc = 0;
  float bottom_part_rect_size = 4;

  float left_part_x_start;
  float left_part_y_start;
  float left_part_y_step = 0;
  float left_part_x_step_inc = 0;
  float left_part_rect_size = 1;
  
  float y_offset = 172 / 2;
 
  for (int e = 0; e < elems_y; e += elems_y_step) {
    float normalized_e = (float)e / elems_y;
    
    float xxmotion = abs(sin(normalized_e / 2 * 360 * (PI / 180) + xmotion) * 2);

    bottom_part_x_start = 640 / 2 - bottom_part_x_step_inc;
    left_part_x_start = 640 / 2 - bottom_part_x_step_inc * 2 - left_elems_x * (0.8 + bottom_part_x_step_inc);
    left_part_y_start = 480 / 2 + tri_min_distance_center - left_part_x_step_inc * 2 + left_part_y_step + xxmotion;

    for (int j = 0; j < left_elems_x + left_part_y_step*2; j += elems_x_step) {
      float normalized_j = ((float)j / (left_elems_x + left_part_y_step));
      
      float yymotion = sin(normalized_j / 4 * 360 * (PI / 180) + ymotion / 4) * 0.05;
      float yymotion2 = -4 + cos(normalized_j * 2 * 360 * (PI / 180) + ymotion / 4) * 0.5;

      float xrepeat = 4;
      float yrepeat = 2;

      int xxd = ((int)(normalized_e * (door_texture.width * xrepeat) - xmotion * 400))%(door_texture.width);
      int yyd = (((int)((1.-normalized_j) * (door_texture.height * yrepeat) - ymotion*2))%(door_texture.height)) * door_texture.width;
      
      xxd = abs(xxd);
      yyd = abs(yyd);
      
      int cl = (int)xxd + yyd;

      int r = (int)(red(door_texture.pixels[cl]) * (normalized_e * 2));
      int g = (int)(green(door_texture.pixels[cl]) * (normalized_e * 2));
      int b = (int)(blue(door_texture.pixels[cl]) * (normalized_e * 2));
      
      if ((r + g + b) / 3 > 4) { 
        fill(r, g, b, normalized_e * 255);
        
        rect(left_part_x_start + random(2.), left_part_y_start + y_offset + random(2.), left_part_rect_size, left_part_rect_size);
      }
      
      left_part_y_start -= 1.6 - left_part_x_step_inc+yymotion;
      left_part_x_start += 3.8 + yymotion2 + 2 * normalized_j;
    }
    
    for (int j = 0; j < bottom_elems_x; j += elems_x_step) {
      float normalized_j = ((float)j / bottom_elems_x);

      float xrepeat = 2.;
      float yrepeat = 1;

      float yymotion = (sin(normalized_e * 360 * (PI / 180) + ymotion)) * 14. * (1.0-normalized_j);
      
      int xxd = ((int)(normalized_e * (colormap.width * xrepeat) - xmotion*800))%(colormap.width);
      int yyd = (((int)(normalized_j * (colormap.height * yrepeat - xxmotion)))%(colormap.height)) * colormap.width;
      
      xxd = abs(xxd);
      yyd = abs(yyd);
      
      int cl = (int)xxd + yyd;

      int r = (int)(red(colormap.pixels[cl]) * (normalized_e * 4));
      int g = (int)(green(colormap.pixels[cl]) * (normalized_e * 4));
      int b = (int)(blue(colormap.pixels[cl]) * (normalized_e * 4));
      
      fill(r, g, b, 32);

      rect(bottom_part_x_start, bottom_part_y_start + y_offset + yymotion + 32, bottom_part_rect_size, bottom_part_rect_size);

      bottom_part_x_start -= 0.5 + bottom_part_x_step_inc;
    }
    
    bottom_part_y_start += 1;
    bottom_part_x_start -= 2 + bottom_part_x_step_inc;

    bottom_part_x_step_inc += 0.045;
    left_part_x_step_inc -= 0.005;

    left_part_y_step += 1.8;

    bottom_part_rect_size += 0.0025 * xxmotion;
    left_part_rect_size += 0.0025 * xxmotion;
  }

  loadPixels();
  for (int y = 0; y < 480; y += 1) {
    for (int x = 0; x < 640 / 2; x += 1) {
      int isrc = x + y * 640;
      int idst = (639 - x) + y * 640;
      pixels[idst] = pixels[isrc];
    }
  }
  updatePixels();

  xmotion += 0.05;
  ymotion += 0.025;
  rmotion += 0.012;
}

void setup() {
  size(640, 480);

  frameRate(60); 

  colormap = loadImage(""data.jpg"");
  door_texture = loadImage(""door.jpg"");

  background(0);
}

void draw() {
  //background(0);

  draw_func();
}"
"561515","Satori","mySketch","/**
  * Mindf***
  */

PImage colormap;
PImage colormap2;

float xmotion = 0;
float ymotion = 0;
float rmotion = 0;
float tmotion = 0;
float tmotion2 = 0;

int elems = 92; // can improve the rendering quality by increasing it
int dots = 92; // improve rendering qualiy

float dots_step = 1;
float elems_step = 1;

float []ldmotion = new float[elems * dots];

void draw_landscape() {
  float mx = 1;
  
  int rect_size = 4;
  
  // apply motion blur
  fill(0, 0, 0, 48);
  rect(0, 0, 1024, 700);
  
  noStroke();
  
  float xoff = 1024 / 2.;
  float yoff = 700 / 2;
 
  float lelems = elems;
  float ldots = dots;
  
  float ws = 1;
  float hs = 700 - yoff * 2;
  
  float ow = 2.;
  
  for (float e = 0; e < lelems; e += elems_step) {
    float de = (float)e / lelems / 2;

    float bd = max((0.5-abs(de - 0.5)) * 4, 0.05);

    ws = 256 * de + cos((bd * 360 + 180) * (PI / 180) / 4 + xmotion) * 340;
    hs = 192 * de + sin((bd * 360 + 180) * (PI / 180) / 2 + ymotion) * 340;
    
    float xrepeat = 4;
    float yrepeat = 4;
    int yyd = (((int)((de+tmotion) * (colormap.height * yrepeat))))%colormap.height * colormap.width;
    int xxd2 = ((int)((de+tmotion2) * (colormap2.width * xrepeat))%colormap2.width);

    for (float d = 0; d < ldots; d += dots_step) {
      float dd = (float)d / ldots * 4;
      
      float final_x = xoff + ws * sin((dd * 360 + 180) * (PI / 180) * 2 - tmotion + ldmotion[d + e * dots] * de);
      float final_y = yoff + hs * cos((dd * 360 + 180) * (PI / 180) * 2 - tmotion + ldmotion[d + e * dots] * de);
      
      int xxd = ((int)((dd+tmotion) * (colormap.width * xrepeat))%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int yyd2 = (((int)((dd+tmotion2) * (colormap2.height * yrepeat))))%colormap2.height * colormap2.width;
      
      int cl2 = (int)xxd2 + yyd2;
			
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      int r2 = (int)(red(colormap2.pixels[cl2]) * bd);
      int g2 = (int)(green(colormap2.pixels[cl2]) * bd);
      int b2 = (int)(blue(colormap2.pixels[cl2]) * bd);
      
      fill((r + r2) / 2, (g + g2)/2, (b + b2)/2, min(bd * (abs(ow) * 8), 255.));

      rect(final_x, final_y, rect_size, rect_size);
      
      ow += cos(de * 360 * (PI / 180) + xmotion) / 64;
    }
    
    ow += 0.001;
  }
  
  xmotion += 0.05;
  ymotion += 0.0125;
  rmotion += 0.012;
  tmotion += 0.001;
  tmotion2 += 0.002;
}

void setup() {
  size(1024, 700);

  frameRate(60); 
  
  colormap = loadImage(""data.jpg"");
  colormap2 = loadImage(""data2.jpg"");
  
  for (int e = 0; e < elems; e += elems_step) {
    for (int d = 0; d < dots; d += dots_step) {
      ldmotion[d + e * dots] = random(0.5);
    }
  }

  background(0);
}

void draw() {
  //background(0);
 
  draw_landscape();
}"
"561515","Satori","mySketch","/**
  * Mindf***
  */

PImage colormap;
PImage colormap2;

float xmotion = 0;
float ymotion = 0;
float rmotion = 0;
float tmotion = 0;
float tmotion2 = 0;

int elems = 92; // can improve the rendering quality by increasing it
int dots = 92; // improve rendering qualiy

float dots_step = 1;
float elems_step = 1;

float []ldmotion = new float[elems * dots];

void draw_landscape() {
  float mx = 1;
  
  int rect_size = 4;
  
  // apply motion blur
  fill(0, 0, 0, 48);
  rect(0, 0, 1024, 700);
  
  noStroke();
  
  float xoff = 1024 / 2.;
  float yoff = 700 / 2;
 
  float lelems = elems;
  float ldots = dots;
  
  float ws = 1;
  float hs = 700 - yoff * 2;
  
  float ow = 2.;
  
  for (float e = 0; e < lelems; e += elems_step) {
    float de = (float)e / lelems / 2;

    float bd = max((0.5-abs(de - 0.5)) * 4, 0.05);

    ws = 256 * de + cos((bd * 360 + 180) * (PI / 180) / 4 + xmotion) * 340;
    hs = 192 * de + sin((bd * 360 + 180) * (PI / 180) / 2 + ymotion) * 340;
    
    float xrepeat = 4;
    float yrepeat = 4;
    int yyd = (((int)((de+tmotion) * (colormap.height * yrepeat))))%colormap.height * colormap.width;
    int xxd2 = ((int)((de+tmotion2) * (colormap2.width * xrepeat))%colormap2.width);

    for (float d = 0; d < ldots; d += dots_step) {
      float dd = (float)d / ldots * 4;
      
      float final_x = xoff + ws * sin((dd * 360 + 180) * (PI / 180) * 2 - tmotion + ldmotion[d + e * dots] * de);
      float final_y = yoff + hs * cos((dd * 360 + 180) * (PI / 180) * 2 - tmotion + ldmotion[d + e * dots] * de);
      
      int xxd = ((int)((dd+tmotion) * (colormap.width * xrepeat))%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int yyd2 = (((int)((dd+tmotion2) * (colormap2.height * yrepeat))))%colormap2.height * colormap2.width;
      
      int cl2 = (int)xxd2 + yyd2;
			
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      int r2 = (int)(red(colormap2.pixels[cl2]) * bd);
      int g2 = (int)(green(colormap2.pixels[cl2]) * bd);
      int b2 = (int)(blue(colormap2.pixels[cl2]) * bd);
      
      fill((r + r2) / 2, (g + g2)/2, (b + b2)/2, min(bd * (abs(ow) * 8), 255.));

      rect(final_x, final_y, rect_size, rect_size);
      
      ow += cos(de * 360 * (PI / 180) + xmotion) / 64;
    }
    
    ow += 0.001;
  }
  
  xmotion += 0.05;
  ymotion += 0.0125;
  rmotion += 0.012;
  tmotion += 0.001;
  tmotion2 += 0.002;
}

void setup() {
  size(1024, 700);

  frameRate(60); 
  
  colormap = loadImage(""data.jpg"");
  colormap2 = loadImage(""data2.jpg"");
  
  for (int e = 0; e < elems; e += elems_step) {
    for (int d = 0; d < dots; d += dots_step) {
      ldmotion[d + e * dots] = random(0.5);
    }
  }

  background(0);
}

void draw() {
  //background(0);
 
  draw_landscape();
}"
"561515","Satori","mySketch","/**
  * Mindf***
  */

PImage colormap;
PImage colormap2;
PImage satori;

float xmotion = 0;
float ymotion = 0;
float rmotion = 0;
float tmotion = 0;
float tmotion2 = 0;

int elems = 92; // can improve the rendering quality by increasing it
int dots = 92; // improve rendering qualiy

float dots_step = 1;
float elems_step = 1;

float []ldmotion = new float[elems * dots];

void draw_landscape() {
  float mx = 1;
  
  int rect_size = 4;
  
  // apply motion blur
  fill(0, 0, 0, 48);
  rect(0, 0, 1024, 700);
  
  noStroke();
  
  float xoff = 1024 / 2.;
  float yoff = 700 / 2;
 
  float lelems = elems;
  float ldots = dots;
  
  float ws = 1;
  float hs = 700 - yoff * 2;
  
  float ow = 2.;
	
	image(satori, 8, 8);
  
  for (float e = 0; e < lelems; e += elems_step) {
    float de = (float)e / lelems / 2;

    float bd = max((0.5-abs(de - 0.5)) * 4, 0.05);

    ws = 256 * de + cos((bd * 360 + 180) * (PI / 180) / 4 + xmotion) * 340;
    hs = 192 * de + sin((bd * 360 + 180) * (PI / 180) / 2 + ymotion) * 340;
    
    float xrepeat = 4;
    float yrepeat = 4;
    int yyd = (((int)((de+tmotion) * (colormap.height * yrepeat))))%colormap.height * colormap.width;
    int xxd2 = ((int)((de+tmotion2) * (colormap2.width * xrepeat))%colormap2.width);

    for (float d = 0; d < ldots; d += dots_step) {
      float dd = (float)d / ldots * 4;
      
      float final_x = xoff + ws * sin((dd * 360 + 180) * (PI / 180) * 2 - tmotion + ldmotion[d + e * dots] * de);
      float final_y = yoff + hs * cos((dd * 360 + 180) * (PI / 180) * 2 - tmotion + ldmotion[d + e * dots] * de);
      
      int xxd = ((int)((dd+tmotion) * (colormap.width * xrepeat))%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int yyd2 = (((int)((dd+tmotion2) * (colormap2.height * yrepeat))))%colormap2.height * colormap2.width;
      
      int cl2 = (int)xxd2 + yyd2;
			
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      int r2 = (int)(red(colormap2.pixels[cl2]) * bd);
      int g2 = (int)(green(colormap2.pixels[cl2]) * bd);
      int b2 = (int)(blue(colormap2.pixels[cl2]) * bd);
      
      fill((r + r2) / 2, (g + g2)/2, (b + b2)/2, min(bd * (abs(ow) * 8), 255.));

      rect(final_x, final_y, rect_size, rect_size);
      
      ow += cos(de * 360 * (PI / 180) + xmotion) / 64;
    }
    
    ow += 0.001;
  }
  
  xmotion += 0.05;
  ymotion += 0.0125;
  rmotion += 0.012;
  tmotion += 0.001;
  tmotion2 += 0.002;
}

void setup() {
  size(1024, 700);

  frameRate(60); 
  
  colormap = loadImage(""data.jpg"");
  colormap2 = loadImage(""data2.jpg"");
	satori = loadImage(""Satori.png"");
  
  for (int e = 0; e < elems; e += elems_step) {
    for (int d = 0; d < dots; d += dots_step) {
      ldmotion[d + e * dots] = random(0.5);
    }
  }

  background(0);
}

void draw() {
  //background(0);
 
  draw_landscape();
}"
"561515","Satori","mySketch","/**
  * Mindf***
  */

PImage colormap;
PImage colormap2;
PImage satori;

float xmotion = 0;
float ymotion = 0;
float rmotion = 0;
float tmotion = 0;
float tmotion2 = 0;

int elems = 128; // can improve the rendering quality by increasing it
int dots = 92; // improve rendering qualiy

float dots_step = 1;
float elems_step = 1;

float []ldmotion = new float[elems * dots];

void draw_landscape() {
  float mx = 1;
  
  int rect_size = 4;
  
  // apply motion blur
  fill(0, 0, 0, 48);
  rect(0, 0, 1024, 700);
  
  noStroke();
  
  float xoff = 1024 / 2.;
  float yoff = 700 / 2;
 
  float lelems = elems;
  float ldots = dots;
  
  float ws = 1;
  float hs = 700 - yoff * 2;
  
  float ow = 2.;
	
	image(satori, 8, 8);
  
  for (float e = 0; e < lelems; e += elems_step) {
    float de = (float)e / lelems / 2;

    float bd = max((0.5-abs(de - 0.5)) * 4, 0.05);

    ws = 256 * de + cos((bd * 360 + 180) * (PI / 180) / 4 + xmotion) * 340;
    hs = 192 * de + sin((bd * 360 + 180) * (PI / 180) / 2 + ymotion) * 340;
    
    float xrepeat = 4;
    float yrepeat = 4;
    int yyd = (((int)((de+tmotion) * (colormap.height * yrepeat))))%colormap.height * colormap.width;
    int xxd2 = ((int)((de+tmotion2) * (colormap2.width * xrepeat))%colormap2.width);

    for (float d = 0; d < ldots; d += dots_step) {
      float dd = (float)d / ldots * 4;
      
      float final_x = xoff + ws * sin((dd * 360 + 180) * (PI / 180) * 2 - tmotion + ldmotion[d + e * dots] * de);
      float final_y = yoff + hs * cos((dd * 360 + 180) * (PI / 180) * 2 - tmotion + ldmotion[d + e * dots] * de);
      
      int xxd = ((int)((dd+tmotion) * (colormap.width * xrepeat))%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int yyd2 = (((int)((dd+tmotion2) * (colormap2.height * yrepeat))))%colormap2.height * colormap2.width;
      
      int cl2 = (int)xxd2 + yyd2;
			
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      int r2 = (int)(red(colormap2.pixels[cl2]) * bd);
      int g2 = (int)(green(colormap2.pixels[cl2]) * bd);
      int b2 = (int)(blue(colormap2.pixels[cl2]) * bd);
      
      fill((r + r2) / 2, (g + g2)/2, (b + b2)/2, min(bd * (abs(ow) * 8), 255.));

      rect(final_x, final_y, rect_size, rect_size);
      
      ow += cos(de * 360 * (PI / 180) + xmotion) / 64;
    }
    
    ow += 0.001;
  }
  
  xmotion += 0.05;
  ymotion += 0.0125;
  rmotion += 0.012;
  tmotion += 0.001;
  tmotion2 += 0.002;
}

void setup() {
  size(1024, 700);

  frameRate(60); 
  
  colormap = loadImage(""data.jpg"");
  colormap2 = loadImage(""data2.jpg"");
	satori = loadImage(""Satori.png"");
  
  for (int e = 0; e < elems; e += elems_step) {
    for (int d = 0; d < dots; d += dots_step) {
      ldmotion[d + e * dots] = random(0.5);
    }
  }

  background(0);
}

void draw() {
  //background(0);
 
  draw_landscape();
}"
"561482","3D Terrain tunnel","mySketch","/**
  * 3D textured heightmap-based tunnel made of rectangles (sort of voxel rendering)
  */

PImage colormap;
PImage heightmap;
PImage water;

float xmotion = 0;
float ymotion = 0;
float rmotion = 0;

int elems = 240; // can improve the rendering quality by increasing it and lowering the xrad_step / yrad_step variable
int dots = 240; // improve tunnel quality (to be used with rect_size)

int dots_step = 1;
int elems_step = 1;

void draw_landscape() {
  int rect_size = 4;
  
  // apply motion blur
  fill(0, 0, 0, 8);
  rect(0, 0, 1024, 700);
  
  noStroke();
  
  // initial circle size
  int bsize = 80;
  
  int xoff = 1024 / 2;
  int yoff = 700 / 2;
  
  // the circles stepping
  int xrad_step = 4;
  int yrad_step = 4;
  
  // max motion deform.
  int xdeform = 80;
  int ydeform = 80;
  
  float crepeat = 1; // heightmap / colormap repeat
  int wrepeat = 16; // water texture repeat
  
  // we start by eliminating the blur effect at the end of the tunnel
  fill(0, 0, 0);
  ellipse(xoff + sin(360 * (PI / 180) + xmotion) * xdeform, yoff + cos(360 * (PI / 180) + ymotion) * xdeform, bsize * 1.5, bsize * 1.5);
  
  for (int e = 0; e < elems; e += elems_step) {
    float de = (float)e / elems;
    
    // fog computation
    float bd = 1.-max((0.5-abs(de - 0.5)) * 16, 0.05);
    
    float ex = sin(de * 360 * (PI / 180) + xmotion);
    float ey = cos(de * 360 * (PI / 180) + ymotion);
     
    float xrad = e * xrad_step + bsize + sin(de * 360 * (PI / 180) + xmotion) * 4;
    float yrad = e * yrad_step + bsize + cos(de * 360 * (PI / 180) + xmotion) * 4;
    
    float final_ex = xoff + ex * xdeform;
    
    float xpp = (de * 360 * (PI / 180)) / 2;
    
    // pre-computing textures lookup
    int hl = ((int)(de * heightmap.height * crepeat) % heightmap.height) * heightmap.width;
    
    int yyd = (((int)(de * (colormap.height * crepeat)) % colormap.height)) * colormap.width;
    int wyd = (((int)(de * (colormap.height * wrepeat)) % colormap.height)) * colormap.width; 

    for (int d = 0; d < dots; d += dots_step) {
      float dd = (float)d / dots;
      
      float xp = dd * 360 * (PI / 180);
      float yp = dd * 360 * (PI / 180);
      
      xp += xpp + rmotion;
      yp += xpp + rmotion;
      
      // compute height & apply it
      float normalized_height = (heightmap.pixels[(((int)(dd * heightmap.width * crepeat)) % heightmap.width) + hl] >> 16 & 0xFF) / 255.0;
      
      float h = 1.0 - normalized_height * (1.-de);
      
      float final_x = final_ex + sin(xp) * xrad * h;
      float final_y = yoff + ey * ydeform + cos(yp) * yrad * h;
      
      // do not compute outside boundary
      if (final_x >= 1040 || final_x < -16 || final_y >= 716 | final_y < -16) {
        continue;
      }
      
      // apply colormap / texture
      int xxd = ((int)(dd * (colormap.width * crepeat)) % colormap.width);

      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]));
      int g = (int)(green(colormap.pixels[cl]));
      int b = (int)(blue(colormap.pixels[cl]));
      
      // water map
      int wxd = ((int)(dd * (colormap.width * wrepeat)) % colormap.width);

      int wcl = (int)wxd + wyd;
      
      int wr = (int)(red(water.pixels[wcl]));
      int wg = (int)(green(water.pixels[wcl]));
      int wb = (int)(blue(water.pixels[wcl]));
      
      float finalr = r, finalg = g , finalb = b;
      float water_level = 0.2;
      if (normalized_height < water_level) {
        float wl = normalized_height * (1.0 / water_level);
        
        finalr = lerpColor(wr, r, wl);
        finalg = lerpColor(wg, g, wl);
        finalb = lerpColor(wb, b, wl);
      }
      
      float snow_level = 0.45;
      if (normalized_height > snow_level) {
        float wl = (normalized_height - snow_level) * (1.0 / snow_level);
        
        finalr = lerpColor(r, 255, wl);
        finalg = lerpColor(g, 255, wl);
        finalb = lerpColor(b, 255, wl);
      }
      
      finalr = lerpColor((int)finalr, 0, bd);
      finalg = lerpColor((int)finalg, 0, bd);
      finalb = lerpColor((int)finalb, 0, bd);
      
      fill(finalr, finalg, finalb);
      
      rect(final_x, final_y, rect_size, rect_size);
    }
  }
  
  xmotion += 0.05;
  ymotion += 0.025;
  rmotion += 0.012;
}

void setup() {
  size(1024, 700);

  frameRate(60); 
  
  colormap = loadImage(""colormap.jpg"");
  
  water = loadImage(""water.jpg"");
  
  heightmap = loadImage(""heightmap.jpg"");
  heightmap.loadPixels();

  background(0);
}

void draw() {
  //background(0);
 
  draw_landscape();
}"
"561482","3D Terrain tunnel","mySketch","/**
  * 3D textured heightmap-based tunnel made of rectangles (sort of voxel rendering)
  */

PImage colormap;
PImage heightmap;
PImage water;

float xmotion = 0;
float ymotion = 0;
float rmotion = 0;

int elems = 240; // can improve the rendering quality by increasing it and lowering the xrad_step / yrad_step variable
int dots = 240; // improve tunnel quality (to be used with rect_size)

int dots_step = 1;
int elems_step = 1;

void draw_landscape() {
  int rect_size = 4;
  
  // apply motion blur
  fill(0, 0, 0, 8);
  rect(0, 0, 1024, 700);
  
  noStroke();
  
  // initial circle size
  int bsize = 80;
  
  int xoff = 1024 / 2;
  int yoff = 700 / 2;
  
  // the circles stepping
  int xrad_step = 4;
  int yrad_step = 4;
  
  // max motion deform.
  int xdeform = 80;
  int ydeform = 80;
  
  float crepeat = 1; // heightmap / colormap repeat
  int wrepeat = 16; // water texture repeat
  
  // we start by eliminating the blur effect at the end of the tunnel
  fill(0, 0, 0);
  ellipse(xoff + sin(360 * (PI / 180) + xmotion) * xdeform, yoff + cos(360 * (PI / 180) + ymotion) * xdeform, bsize * 1.5, bsize * 1.5);
  
  for (int e = 0; e < elems; e += elems_step) {
    float de = (float)e / elems;
    
    // fog computation
    float bd = 1.-max((0.5-abs(de - 0.5)) * 16, 0.05);
    
    float ex = sin(de * 360 * (PI / 180) + xmotion);
    float ey = cos(de * 360 * (PI / 180) + ymotion);
     
    float xrad = e * xrad_step + bsize + sin(de * 360 * (PI / 180) + xmotion) * 4;
    float yrad = e * yrad_step + bsize + cos(de * 360 * (PI / 180) + xmotion) * 4;
    
    float final_ex = xoff + ex * xdeform;
    
    float xpp = (de * 360 * (PI / 180)) / 2;
    
    // pre-computing textures lookup
    int hl = ((int)(de * heightmap.height * crepeat) % heightmap.height) * heightmap.width;
    
    int yyd = (((int)(de * (colormap.height * crepeat)) % colormap.height)) * colormap.width;
    int wyd = (((int)(de * (colormap.height * wrepeat)) % colormap.height)) * colormap.width; 

    for (int d = 0; d < dots; d += dots_step) {
      float dd = (float)d / dots;
      
      float xp = dd * 360 * (PI / 180);
      float yp = dd * 360 * (PI / 180);
      
      xp += xpp + rmotion;
      yp += xpp + rmotion;
      
      // compute height & apply it
      float normalized_height = (heightmap.pixels[(((int)(dd * heightmap.width * crepeat)) % heightmap.width) + hl] >> 16 & 0xFF) / 255.0;
      
      float h = 1.0 - normalized_height * (1.-de);
      
      float final_x = final_ex + sin(xp) * xrad * h;
      float final_y = yoff + ey * ydeform + cos(yp) * yrad * h;
      
      // do not compute outside boundary
      if (final_x >= 1040 || final_x < -16 || final_y >= 716 | final_y < -16) {
        continue;
      }
      
      // apply colormap / texture
      int xxd = ((int)(dd * (colormap.width * crepeat)) % colormap.width);

      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]));
      int g = (int)(green(colormap.pixels[cl]));
      int b = (int)(blue(colormap.pixels[cl]));
      
      // water map
      int wxd = ((int)(dd * (colormap.width * wrepeat)) % colormap.width);

      int wcl = (int)wxd + wyd;
      
      int wr = (int)(red(water.pixels[wcl]));
      int wg = (int)(green(water.pixels[wcl]));
      int wb = (int)(blue(water.pixels[wcl]));
      
      float finalr = r, finalg = g , finalb = b;
      float water_level = 0.2;
      if (normalized_height < water_level) {
        float wl = normalized_height * (1.0 / water_level);
        
        finalr = lerpColor(wr, r, wl);
        finalg = lerpColor(wg, g, wl);
        finalb = lerpColor(wb, b, wl);
      }
      
      float snow_level = 0.45;
      if (normalized_height > snow_level) {
        float wl = (normalized_height - snow_level) * (1.0 / snow_level);
        
        finalr = lerpColor(r, 255, wl);
        finalg = lerpColor(g, 255, wl);
        finalb = lerpColor(b, 255, wl);
      }
      
      finalr = lerpColor((int)finalr, 0, bd);
      finalg = lerpColor((int)finalg, 0, bd);
      finalb = lerpColor((int)finalb, 0, bd);
      
      fill(finalr, finalg, finalb);
      
      rect(final_x, final_y, rect_size, rect_size);
    }
  }
  
  xmotion += 0.05;
  ymotion += 0.025;
  rmotion += 0.012;
}

void setup() {
  size(1024, 700);

  frameRate(60); 
  
  colormap = loadImage(""colormap.jpg"");
  
  water = loadImage(""water.jpg"");
  
  heightmap = loadImage(""heightmap.jpg"");

  background(0);
}

void draw() {
  //background(0);
 
  draw_landscape();
}"
"561482","3D Terrain tunnel","mySketch","/**
  * 3D textured heightmap-based tunnel made of rectangles (sort of voxel rendering)
  */

PImage colormap;
PImage heightmap;
PImage water;

float xmotion = 0;
float ymotion = 0;
float rmotion = 0;

int elems = 128; // can improve the rendering quality by increasing it and lowering the xrad_step / yrad_step variable
int dots = 192; // improve tunnel quality (to be used with rect_size)

int dots_step = 1;
int elems_step = 1;

void draw_landscape() {
  int rect_size = 4;
  
  // apply motion blur
  fill(0, 0, 0, 8);
  rect(0, 0, 800, 600);
  
  noStroke();
  
  // initial circle size
  int bsize = 80;
  
  int xoff = 800 / 2;
  int yoff = 600 / 2;
  
  // the circles stepping
  int xrad_step = 6;
  int yrad_step = 6;
  
  // max motion deform.
  int xdeform = 80;
  int ydeform = 80;
  
  float crepeat = 1; // heightmap / colormap repeat
  int wrepeat = 16; // water texture repeat
  
  // we start by eliminating the blur effect at the end of the tunnel
  fill(0, 0, 0);
  ellipse(xoff + sin(360 * (PI / 180) + xmotion) * xdeform, yoff + cos(360 * (PI / 180) + ymotion) * xdeform, bsize * 1.5, bsize * 1.5);
  
  for (int e = 0; e < elems; e += elems_step) {
    float de = (float)e / elems;
    
    // fog computation
    float bd = 1.-max(min((0.5-abs(de - 0.5)) * 16, 1), 0.05);
    
    float ex = sin(de * 360 * (PI / 180) + xmotion);
    float ey = cos(de * 360 * (PI / 180) + ymotion);
     
    float xrad = e * xrad_step + bsize + sin(de * 360 * (PI / 180) + xmotion) * 4;
    float yrad = e * yrad_step + bsize + cos(de * 360 * (PI / 180) + xmotion) * 4;
    
    float final_ex = xoff + ex * xdeform;
    
    float xpp = (de * 360 * (PI / 180)) / 2;
    
    // pre-computing textures lookup
    int hl = ((int)(de * heightmap.height * crepeat) % heightmap.height) * heightmap.width;
    
    int yyd = (((int)(de * (colormap.height * crepeat)) % colormap.height)) * colormap.width;
    int wyd = (((int)(de * (colormap.height * wrepeat)) % colormap.height)) * colormap.width; 

    for (int d = 0; d < dots; d += dots_step) {
      float dd = (float)d / dots;
      
      float xp = dd * 360 * (PI / 180);
      float yp = dd * 360 * (PI / 180);
      
      xp += xpp + rmotion;
      yp += xpp + rmotion;
      
      // compute height & apply it
      float normalized_height = (heightmap.pixels[(((int)(dd * heightmap.width * crepeat)) % heightmap.width) + hl] >> 16 & 0xFF) / 255.0;
      
      float h = 1.0 - normalized_height * (1.-de);
      
      float final_x = final_ex + sin(xp) * xrad * h;
      float final_y = yoff + ey * ydeform + cos(yp) * yrad * h;
      
      // do not compute outside boundary
      if (final_x >= 1040 || final_x < -16 || final_y >= 716 | final_y < -16) {
        continue;
      }
      
      // apply colormap / texture
      int xxd = ((int)(dd * (colormap.width * crepeat)) % colormap.width);

      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]));
      int g = (int)(green(colormap.pixels[cl]));
      int b = (int)(blue(colormap.pixels[cl]));
      
      // water map
      int wxd = ((int)(dd * (colormap.width * wrepeat)) % colormap.width);

      int wcl = (int)wxd + wyd;
      
      int wr = (int)(red(water.pixels[wcl]));
      int wg = (int)(green(water.pixels[wcl]));
      int wb = (int)(blue(water.pixels[wcl]));
      
      float finalr = r, finalg = g , finalb = b;
      float water_level = 0.2;
      if (normalized_height < water_level) {
        float wl = normalized_height * (1.0 / water_level);
        
        finalr = lerp(wr, r, wl);
        finalg = lerp(wg, g, wl);
        finalb = lerp(wb, b, wl);
      }
      
      float snow_level = 0.45;
      if (normalized_height > snow_level) {
        float wl = (normalized_height - snow_level) * (1.0 / snow_level);
        
        finalr = lerp(r, 255, wl);
        finalg = lerp(g, 255, wl);
        finalb = lerp(b, 255, wl);
      }
      
      finalr = lerp((int)finalr, 0, bd);
      finalg = lerp((int)finalg, 0, bd);
      finalb = lerp((int)finalb, 0, bd);
      
      fill(finalr, finalg, finalb);
      
      rect(final_x, final_y, rect_size, rect_size);
    }
  }
  
  xmotion += 0.05;
  ymotion += 0.025;
  rmotion += 0.012;
}

void setup() {
  size(800, 600);

  frameRate(60); 
  
  colormap = loadImage(""colormap.jpg"");
  
  water = loadImage(""water.jpg"");
  
  heightmap = loadImage(""heightmap.jpg"");

  background(0);
}

void draw() {
  //ckground(0);
 
  draw_landscape();
}"
"561482","3D Terrain tunnel","mySketch","/**
  * 3D textured heightmap-based tunnel made of rectangles (sort of voxel rendering)
  */

PImage colormap;
PImage heightmap;
PImage water;

float xmotion = 0;
float ymotion = 0;
float rmotion = 0;

int elems = 128; // can improve the rendering quality by increasing it and lowering the xrad_step / yrad_step variable
int dots = 192; // improve tunnel quality (to be used with rect_size)

int dots_step = 1;
int elems_step = 1;

void draw_landscape() {
  int rect_size = 4;
  
  // apply motion blur
  fill(0, 0, 0, 8);
  rect(0, 0, 800, 600);
  
  noStroke();
  
  // initial circle size
  int bsize = 80;
  
  int xoff = 800 / 2;
  int yoff = 600 / 2;
  
  // the circles stepping
  int xrad_step = 6;
  int yrad_step = 6;
  
  // max motion deform.
  int xdeform = 80;
  int ydeform = 80;
  
  float crepeat = 1; // heightmap / colormap repeat
  int wrepeat = 16; // water texture repeat
  
  // we start by eliminating the blur effect at the end of the tunnel
  fill(0, 0, 0);
  ellipse(xoff + sin(360 * (PI / 180) + xmotion) * xdeform, yoff + cos(360 * (PI / 180) + ymotion) * xdeform, bsize * 1.5, bsize * 1.5);
  
  for (int e = 0; e < elems; e += elems_step) {
    float de = (float)e / elems;
    
    // fog computation
    float bd = 1.-max(min((0.5-abs(de - 0.5)) * 16, 1), 0.05);
    
    float ex = sin(de * 360 * (PI / 180) + xmotion);
    float ey = cos(de * 360 * (PI / 180) + ymotion);
     
    float xrad = e * xrad_step + bsize + sin(de * 360 * (PI / 180) + xmotion) * 4;
    float yrad = e * yrad_step + bsize + cos(de * 360 * (PI / 180) + xmotion) * 4;
    
    float final_ex = xoff + ex * xdeform;
    
    float xpp = (de * 360 * (PI / 180)) / 2;
    
    // pre-computing textures lookup
    int hl = ((int)(de * heightmap.height * crepeat) % heightmap.height) * heightmap.width;
    
    int yyd = (((int)(de * (colormap.height * crepeat)) % colormap.height)) * colormap.width;
    int wyd = (((int)(de * (colormap.height * wrepeat)) % colormap.height)) * colormap.width; 

    for (int d = 0; d < dots; d += dots_step) {
      float dd = (float)d / dots;
      
      float xp = dd * 360 * (PI / 180);
      float yp = dd * 360 * (PI / 180);
      
      xp += xpp + rmotion;
      yp += xpp + rmotion;
      
      // compute height & apply it
      float normalized_height = (heightmap.pixels[(((int)(dd * heightmap.width * crepeat)) % heightmap.width) + hl] >> 16 & 0xFF) / 255.0;
      
      float h = 1.0 - normalized_height * (1.-de);
      
      float final_x = final_ex + sin(xp) * xrad * h;
      float final_y = yoff + ey * ydeform + cos(yp) * yrad * h;
      
      // do not compute outside boundary
      if (final_x >= 1040 || final_x < -16 || final_y >= 716 | final_y < -16) {
        continue;
      }
      
      // apply colormap / texture
      int xxd = ((int)(dd * (colormap.width * crepeat)) % colormap.width);

      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]));
      int g = (int)(green(colormap.pixels[cl]));
      int b = (int)(blue(colormap.pixels[cl]));
      
      // water map
      int wxd = ((int)(dd * (colormap.width * wrepeat)) % colormap.width);

      int wcl = (int)wxd + wyd;
      
      int wr = (int)(red(water.pixels[wcl]));
      int wg = (int)(green(water.pixels[wcl]));
      int wb = (int)(blue(water.pixels[wcl]));
      
      float finalr = r, finalg = g , finalb = b;
      float water_level = 0.2;
      if (normalized_height < water_level) {
        float wl = normalized_height * (1.0 / water_level);
        
        finalr = lerp(wr, r, wl);
        finalg = lerp(wg, g, wl);
        finalb = lerp(wb, b, wl);
      }
      
      float snow_level = 0.45;
      if (normalized_height > snow_level) {
        float wl = (normalized_height - snow_level) * (1.0 / snow_level);
        
        finalr = lerp(r, 255, wl);
        finalg = lerp(g, 255, wl);
        finalb = lerp(b, 255, wl);
      }
      
      finalr = lerp((int)finalr, 0, bd);
      finalg = lerp((int)finalg, 0, bd);
      finalb = lerp((int)finalb, 0, bd);
      
      fill(finalr, finalg, finalb);
      
      rect(final_x, final_y, rect_size, rect_size);
    }
  }
  
  xmotion += 0.05;
  ymotion += 0.025;
  rmotion += 0.012;
}

void setup() {
  size(800, 600);

  frameRate(60); 
  
  colormap = loadImage(""colormap.jpg"");
  
  water = loadImage(""water.jpg"");
  
  heightmap = loadImage(""heightmap.jpg"");

  background(0);
}

void draw() {
  //ckground(0);
 
  draw_landscape();
}"
"561482","3D Terrain tunnel","mySketch","/**
  * 3D textured heightmap-based tunnel made of rectangles (sort of voxel rendering)
  */

PImage colormap;
PImage heightmap;
PImage water;

float xmotion = 0;
float ymotion = 0;
float rmotion = 0;

int elems = 128; // can improve the rendering quality by increasing it and lowering the xrad_step / yrad_step variable
int dots = 192; // improve tunnel quality (to be used with rect_size)

int dots_step = 1;
int elems_step = 1;

void draw_landscape() {
  int rect_size = 4;
  
  // apply motion blur
  fill(0, 0, 0, 8);
  rect(0, 0, 800, 600);
  
  noStroke();
  
  // initial circle size
  int bsize = 80;
  
  int xoff = 800 / 2;
  int yoff = 600 / 2;
  
  // the circles stepping
  int xrad_step = 6;
  int yrad_step = 6;
  
  // max motion deform.
  int xdeform = 80;
  int ydeform = 80;
  
  float crepeat = 1; // heightmap / colormap repeat
  int wrepeat = 16; // water texture repeat
  
  // we start by eliminating the blur effect at the end of the tunnel
  fill(0, 0, 0);
  ellipse(xoff + sin(360 * (PI / 180) + xmotion) * xdeform, yoff + cos(360 * (PI / 180) + ymotion) * xdeform, bsize * 1.5, bsize * 1.5);
  
  for (int e = 0; e < elems; e += elems_step) {
    float de = (float)e / elems;
    
    // fog computation
    float bd = 1.-max(min((0.5-abs(de - 0.5)) * 16, 1), 0.05);
    
    float ex = sin(de * 360 * (PI / 180) + xmotion);
    float ey = cos(de * 360 * (PI / 180) + ymotion);
     
    float xrad = e * xrad_step + bsize + sin(de * 360 * (PI / 180) + xmotion) * 4;
    float yrad = e * yrad_step + bsize + cos(de * 360 * (PI / 180) + xmotion) * 4;
    
    float final_ex = xoff + ex * xdeform;
    
    float xpp = (de * 360 * (PI / 180)) / 2;
    
    // pre-computing textures lookup
    int hl = ((int)(de * heightmap.height * crepeat) % heightmap.height) * heightmap.width;
    
    int yyd = (((int)(de * (colormap.height * crepeat)) % colormap.height)) * colormap.width;
    int wyd = (((int)(de * (colormap.height * wrepeat)) % colormap.height)) * colormap.width; 

    for (int d = 0; d < dots; d += dots_step) {
      float dd = (float)d / dots;
      
      float xp = dd * 360 * (PI / 180);
      float yp = dd * 360 * (PI / 180);
      
      xp += xpp + rmotion;
      yp += xpp + rmotion;
      
      // compute height & apply it
      float normalized_height = (heightmap.pixels[(((int)(dd * heightmap.width * crepeat)) % heightmap.width) + hl] >> 16 & 0xFF) / 255.0;
      
      float h = 1.0 - normalized_height * (1.-de);
      
      float final_x = final_ex + sin(xp) * xrad * h;
      float final_y = yoff + ey * ydeform + cos(yp) * yrad * h;
      
      // do not compute outside boundary
      if (final_x >= 1040 || final_x < -16 || final_y >= 716 | final_y < -16) {
        continue;
      }
      
      // apply colormap / texture
      int xxd = ((int)(dd * (colormap.width * crepeat)) % colormap.width);

      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]));
      int g = (int)(green(colormap.pixels[cl]));
      int b = (int)(blue(colormap.pixels[cl]));
      
      // water map
      int wxd = ((int)(dd * (colormap.width * wrepeat)) % colormap.width);

      int wcl = (int)wxd + wyd;
      
      int wr = (int)(red(water.pixels[wcl]));
      int wg = (int)(green(water.pixels[wcl]));
      int wb = (int)(blue(water.pixels[wcl]));
      
      float finalr = r, finalg = g , finalb = b;
      float water_level = 0.2;
      if (normalized_height < water_level) {
        float wl = normalized_height * (1.0 / water_level);
        
        finalr = lerp(wr, r, wl);
        finalg = lerp(wg, g, wl);
        finalb = lerp(wb, b, wl);
      }
      
      float snow_level = 0.45;
      if (normalized_height > snow_level) {
        float wl = (normalized_height - snow_level) * (1.0 / snow_level);
        
        finalr = lerp(r, 255, wl);
        finalg = lerp(g, 255, wl);
        finalb = lerp(b, 255, wl);
      }
      
      finalr = lerp((int)finalr, 0, bd);
      finalg = lerp((int)finalg, 0, bd);
      finalb = lerp((int)finalb, 0, bd);
      
      fill(finalr, finalg, finalb);
      
      rect(final_x, final_y, rect_size, rect_size);
    }
  }
  
  xmotion += 0.05;
  ymotion += 0.025;
  rmotion += 0.012;
}

void setup() {
  size(800, 600);

  frameRate(60); 
  
  colormap = loadImage(""colormap.jpg"");
  
  water = loadImage(""water.jpg"");
  
  heightmap = loadImage(""heightmap.jpg"");

  background(0);
}

void draw() {
  //ckground(0);
 
  draw_landscape();
}"
"561255","Blue Planet Billboards (+ random)","mySketch","/**
  * Variant of Blue Planet Billboards with randomness, each point fluctuate which fill any gaps caused by stepping, this allow enhanced low quality rendering at the price os being blurry / jaggy
	* 
  */

PImage colormap;
PImage funmap;
PImage nightmap;
PImage cyclemap;

float xmotion = 0;
float ymotion = 0;

// quality control
int dots_step = 2;
int elems_step = 2;

int elems = 92;
int rect_size = 2;
int xrand_rect_size_max = 4;
int yrand_rect_size_max = 8;

void draw_planet() {
  float mx = mouseX / 1024.0;
  float my = mouseY / 1024.0;
  
  elems_step = (int)(1.0 + mx * 2.0);
  dots_step = (int)(1.0 + my * 2.0);

  // add some motion blur / brightness
  fill(0, 0, 0, 4);
  rect(0, 0, 800, 600);
  
  noStroke();
  
  float xoff = 800 / 2;
  
  float sphere_radius = 292;
  float yoff = 600 / 2 - sphere_radius;
  
  for (int s = 0; s < elems; s += elems_step) {
    float de = (float)s / elems;
    
    float bd = max((0.5-abs(de - 0.5)) * 4, 0.05);
    
    float yrepeat = 1;
    int yyd = (((int)(de * (colormap.height * yrepeat))%colormap.height)) * colormap.width;
    
    float tyrepeat = 4;
    int yyd2 = (((int)(de * (funmap.height * tyrepeat) + xmotion)%funmap.height)) * funmap.width;
    
    int yydc = (((int)(de * (cyclemap.height * yrepeat))%cyclemap.height)) * cyclemap.width;
    
    // cartesian circle equation
    float sphere_radius_squared = sphere_radius * sphere_radius;
    float sh_radius = de * (sphere_radius * 2) - sphere_radius;
    float xc_off = sqrt(sphere_radius_squared - sh_radius*sh_radius);
    
    float final_x;
    float final_y = yoff + de * (sphere_radius * 2); // flabby planet bonus : + sin((de * 360 + 180) * (PI / 180) + ymotion / 24.) * 4;
    
    for (int e = 0; e <= (int)xc_off / 2; e += dots_step) {
      float dd = (float)e / xc_off;

      final_x = xoff - (xc_off) + (xc_off  / (dd+0.5)) * abs(0.5-(dd+0.5)) * 2 ;
      
      float yc_off;
      
      // compute UV texels for the colormap
      float dd2 = 1 - dd;
        
      yc_off = 1-sqrt(1 - dd2*dd2);
      
      // apply colormaps
      float xrepeat = 0.5;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + xmotion)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      // second texture (text mask)
      float txrepeat = 1.;
      
      int xxd2 = max(0, ((funmap.width - 1) - (int)(yc_off * (funmap.width * txrepeat) + xmotion)%funmap.width));
 
      int cl2 = (int)xxd2 + yyd2;
      
      int r2 = (int)(red(funmap.pixels[cl2]) * bd);
      int g2 = (int)(green(funmap.pixels[cl2]) * bd);
      int b2 = (int)(blue(funmap.pixels[cl2]) * bd);
      
      // third texture (night version), reuse the first texture UV since they are the same width/height
      int rn = (int)(red(nightmap.pixels[cl]));
      int gn = (int)(green(nightmap.pixels[cl]));
      int bn = (int)(blue(nightmap.pixels[cl]));
      
      // fourth texture (cycle mask), only use single component since it is black/white
      int xxdc = ((cyclemap.width - 1) - (int)(yc_off * (cyclemap.width * xrepeat) + xmotion * 4)%cyclemap.width);
      int clc = (int)xxdc + yydc;
      float rc = red(cyclemap.pixels[clc]) / 255;
      
      float final_r = r * rc + rn * (1 - rc);
      float final_g = g * rc + gn * (1 - rc);
      float final_b = b * rc + bn * (1 - rc);
      
      // some compositing 
      fill(r * (r2 / 255) + final_r, g * (g2 / 255) + final_g, b * (b2 / 255) + final_b);//r * (r2 / 255) + r * bright, g * (g2 / 255) + g * bright, b * (b2 / 255) + b * bright);
      
      rect(final_x + (random(2.0) - 1.0) * xrand_rect_size_max, final_y + (random(2.0) - 1.0) * yrand_rect_size_max, rect_size, rect_size);
    }
    
    for (int e = 0; e <= (int)xc_off / 2; e += dots_step) {
      float dd = (float)e / xc_off;

      final_x = xoff - (xc_off) + (xc_off-(xc_off / (dd+0.5)) * abs(0.5-(dd+0.5))) * 2;
      
      float yc_off;
      
      // compute UV texels for the colormap
      float dd2 = 1 - dd;
        
      yc_off = sqrt(1 - dd2*dd2) + 1.270;
      
      // apply colormaps
      float xrepeat = 0.5;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + xmotion)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      // second texture (text mask)
      float txrepeat = 1.;
      
      int xxd2 = max(0, ((funmap.width - 1) - (int)(yc_off * (funmap.width * txrepeat) + xmotion)%funmap.width));
 
      int cl2 = (int)xxd2 + yyd2;
      
      int r2 = (int)(red(funmap.pixels[cl2]) * bd);
      int g2 = (int)(green(funmap.pixels[cl2]) * bd);
      int b2 = (int)(blue(funmap.pixels[cl2]) * bd);
      
      // third texture (night version), reuse the first texture UV since they are the same width/height
      int rn = (int)(red(nightmap.pixels[cl]));
      int gn = (int)(green(nightmap.pixels[cl]));
      int bn = (int)(blue(nightmap.pixels[cl]));
      
      // fourth texture (cycle mask), only use single component since it is black/white
      int xxdc = ((cyclemap.width - 1) - (int)(yc_off * (cyclemap.width * xrepeat) + xmotion * 4)%cyclemap.width);
      int clc = (int)xxdc + yydc;
      float rc = red(cyclemap.pixels[clc]) / 255;
      
      float final_r = r * rc + rn * (1 - rc);
      float final_g = g  * rc + gn * (1 - rc);
      float final_b = b * rc + bn * (1 - rc);
      
      // some compositing 
      fill(r * (r2 / 255) + final_r, g * (g2 / 255) + final_g, b * (b2 / 255) + final_b);//r * (r2 / 255) + r * bright, g * (g2 / 255) + g * bright, b * (b2 / 255) + b * bright);
      
      rect(final_x + (random(2.0) - 1.0) * xrand_rect_size_max, final_y + (random(2.0) - 1.0) * yrand_rect_size_max, rect_size, rect_size);
    }
  }
  
  xmotion += 0.5;
  ymotion -= 0.25;
}

void setup() {
  size(800, 600);

  frameRate(60); 
  
  colormap = loadImage(""data.jpg"");
  funmap = loadImage(""data2.jpg"");
  nightmap = loadImage(""data_night.jpg"");
  cyclemap = loadImage(""data_cycle.jpg"");
  
  background(0);
}

void draw() {
  //background(0);
 
  draw_planet();
}"
"561255","Blue Planet Billboards (+ random)","mySketch","/**
  * Variant of Blue Planet Billboards with randomness, each point fluctuate which fill any gaps caused by stepping, this allow enhanced low quality rendering at the price os being blurry / jaggy
	* 
  */

PImage colormap;
PImage funmap;
PImage nightmap;
PImage cyclemap;

float xmotion = 0;
float ymotion = 0;

// quality control
int dots_step = 2;
int elems_step = 2;

int elems = 92;
int rect_size = 2;
int xrand_rect_size_max = 4;
int yrand_rect_size_max = 8;

void draw_planet() {
  float mx = mouseX / 1024.0;
  float my = mouseY / 1024.0;
  
  elems_step = (int)(1.0 + mx * 2.0);
  dots_step = (int)(1.0 + my * 2.0);

  // add some motion blur / brightness
  fill(0, 0, 0, 4);
  rect(0, 0, 800, 600);
  
  noStroke();
  
  float xoff = 800 / 2;
  
  float sphere_radius = 292;
  float yoff = 600 / 2 - sphere_radius;
  
  for (int s = 0; s < elems; s += elems_step) {
    float de = (float)s / elems;
    
    float bd = max((0.5-abs(de - 0.5)) * 4, 0.05);
    
    float yrepeat = 1;
    int yyd = (((int)(de * (colormap.height * yrepeat))%colormap.height)) * colormap.width;
    
    float tyrepeat = 4;
    int yyd2 = (((int)(de * (funmap.height * tyrepeat) + xmotion)%funmap.height)) * funmap.width;
    
    int yydc = (((int)(de * (cyclemap.height * yrepeat))%cyclemap.height)) * cyclemap.width;
    
    // cartesian circle equation
    float sphere_radius_squared = sphere_radius * sphere_radius;
    float sh_radius = de * (sphere_radius * 2) - sphere_radius;
    float xc_off = sqrt(sphere_radius_squared - sh_radius*sh_radius);
    
    float final_x;
    float final_y = yoff + de * (sphere_radius * 2); // flabby planet bonus : + sin((de * 360 + 180) * (PI / 180) + ymotion / 24.) * 4;
    
    for (int e = 0; e <= (int)xc_off / 2; e += dots_step) {
      float dd = (float)e / xc_off;

      final_x = xoff - (xc_off) + (xc_off  / (dd+0.5)) * abs(0.5-(dd+0.5)) * 2 ;
      
      float yc_off;
      
      // compute UV texels for the colormap
      float dd2 = 1 - dd;
        
      yc_off = 1-sqrt(1 - dd2*dd2);
      
      // apply colormaps
      float xrepeat = 0.5;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + xmotion)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      // second texture (text mask)
      float txrepeat = 1.;
      
      int xxd2 = max(0, ((funmap.width - 1) - (int)(yc_off * (funmap.width * txrepeat) + xmotion)%funmap.width));
 
      int cl2 = (int)xxd2 + yyd2;
      
      int r2 = (int)(red(funmap.pixels[cl2]) * bd);
      int g2 = (int)(green(funmap.pixels[cl2]) * bd);
      int b2 = (int)(blue(funmap.pixels[cl2]) * bd);
      
      // third texture (night version), reuse the first texture UV since they are the same width/height
      int rn = (int)(red(nightmap.pixels[cl]));
      int gn = (int)(green(nightmap.pixels[cl]));
      int bn = (int)(blue(nightmap.pixels[cl]));
      
      // fourth texture (cycle mask), only use single component since it is black/white
      int xxdc = ((cyclemap.width - 1) - (int)(yc_off * (cyclemap.width * xrepeat) + xmotion * 4)%cyclemap.width);
      int clc = (int)xxdc + yydc;
      float rc = red(cyclemap.pixels[clc]) / 255;
      
      float final_r = r * rc + rn * (1 - rc);
      float final_g = g * rc + gn * (1 - rc);
      float final_b = b * rc + bn * (1 - rc);
      
      // some compositing 
      fill(r * (r2 / 255) + final_r, g * (g2 / 255) + final_g, b * (b2 / 255) + final_b);//r * (r2 / 255) + r * bright, g * (g2 / 255) + g * bright, b * (b2 / 255) + b * bright);
      
      rect(final_x + (random(2.0) - 1.0) * xrand_rect_size_max, final_y + (random(2.0) - 1.0) * yrand_rect_size_max, rect_size, rect_size);
    }
    
    for (int e = 0; e <= (int)xc_off / 2; e += dots_step) {
      float dd = (float)e / xc_off;

      final_x = xoff - (xc_off) + (xc_off-(xc_off / (dd+0.5)) * abs(0.5-(dd+0.5))) * 2;
      
      float yc_off;
      
      // compute UV texels for the colormap
      float dd2 = 1 - dd;
        
      yc_off = sqrt(1 - dd2*dd2) + 1.270;
      
      // apply colormaps
      float xrepeat = 0.5;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + xmotion)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      // second texture (text mask)
      float txrepeat = 1.;
      
      int xxd2 = max(0, ((funmap.width - 1) - (int)(yc_off * (funmap.width * txrepeat) + xmotion)%funmap.width));
 
      int cl2 = (int)xxd2 + yyd2;
      
      int r2 = (int)(red(funmap.pixels[cl2]) * bd);
      int g2 = (int)(green(funmap.pixels[cl2]) * bd);
      int b2 = (int)(blue(funmap.pixels[cl2]) * bd);
      
      // third texture (night version), reuse the first texture UV since they are the same width/height
      int rn = (int)(red(nightmap.pixels[cl]));
      int gn = (int)(green(nightmap.pixels[cl]));
      int bn = (int)(blue(nightmap.pixels[cl]));
      
      // fourth texture (cycle mask), only use single component since it is black/white
      int xxdc = ((cyclemap.width - 1) - (int)(yc_off * (cyclemap.width * xrepeat) + xmotion * 4)%cyclemap.width);
      int clc = (int)xxdc + yydc;
      float rc = red(cyclemap.pixels[clc]) / 255;
      
      float final_r = r * rc + rn * (1 - rc);
      float final_g = g  * rc + gn * (1 - rc);
      float final_b = b * rc + bn * (1 - rc);
      
      // some compositing 
      fill(r * (r2 / 255) + final_r, g * (g2 / 255) + final_g, b * (b2 / 255) + final_b);//r * (r2 / 255) + r * bright, g * (g2 / 255) + g * bright, b * (b2 / 255) + b * bright);
      
      rect(final_x + (random(2.0) - 1.0) * xrand_rect_size_max, final_y + (random(2.0) - 1.0) * yrand_rect_size_max, rect_size, rect_size);
    }
  }
  
  xmotion += 0.5;
  ymotion -= 0.25;
}

void setup() {
  size(800, 600);

  frameRate(60); 
  
  colormap = loadImage(""data.jpg"");
  funmap = loadImage(""data2.jpg"");
  nightmap = loadImage(""data_night.jpg"");
  cyclemap = loadImage(""data_cycle.jpg"");
  
  background(0);
}

void draw() {
  //background(0);
 
  draw_planet();
}"
"561255","Blue Planet Billboards (+ random)","mySketch","/**
  * Variant of Blue Planet Billboards with randomness, each point fluctuate which fill any gaps caused by stepping, this allow enhanced low quality rendering at the price os being blurry / jaggy
	* 
  */

PImage colormap;
PImage funmap;
PImage nightmap;
PImage cyclemap;

float xmotion = 0;
float ymotion = 0;

// quality control
int dots_step = 2;
int elems_step = 2;

int elems = 92;
int rect_size = 2;
int xrand_rect_size_max = 2;
int yrand_rect_size_max = 4;

void draw_planet() {
  float mx = mouseX / 1024.0;
  float my = mouseY / 1024.0;
  
  elems_step = (int)(1.0 + mx * 1.0);
  dots_step = (int)(1.0 + my * 1.0);

  // add some motion blur / brightness
  fill(0, 0, 0, 4);
  rect(0, 0, 800, 600);
  
  noStroke();
  
  float xoff = 800 / 2;
  
  float sphere_radius = 292;
  float yoff = 600 / 2 - sphere_radius;
  
  for (int s = 0; s < elems; s += elems_step) {
    float de = (float)s / elems;
    
    float bd = max((0.5-abs(de - 0.5)) * 4, 0.05);
    
    float yrepeat = 1;
    int yyd = (((int)(de * (colormap.height * yrepeat))%colormap.height)) * colormap.width;
    
    float tyrepeat = 4;
    int yyd2 = (((int)(de * (funmap.height * tyrepeat) + xmotion)%funmap.height)) * funmap.width;
    
    int yydc = (((int)(de * (cyclemap.height * yrepeat))%cyclemap.height)) * cyclemap.width;
    
    // cartesian circle equation
    float sphere_radius_squared = sphere_radius * sphere_radius;
    float sh_radius = de * (sphere_radius * 2) - sphere_radius;
    float xc_off = sqrt(sphere_radius_squared - sh_radius*sh_radius);
    
    float final_x;
    float final_y = yoff + de * (sphere_radius * 2); // flabby planet bonus : + sin((de * 360 + 180) * (PI / 180) + ymotion / 24.) * 4;
    
    for (int e = 0; e <= (int)xc_off / 2; e += dots_step) {
      float dd = (float)e / xc_off;

      final_x = xoff - (xc_off) + (xc_off  / (dd+0.5)) * abs(0.5-(dd+0.5)) * 2 ;
      
      float yc_off;
      
      // compute UV texels for the colormap
      float dd2 = 1 - dd;
        
      yc_off = 1-sqrt(1 - dd2*dd2);
      
      // apply colormaps
      float xrepeat = 0.5;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + xmotion)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      // second texture (text mask)
      float txrepeat = 1.;
      
      int xxd2 = max(0, ((funmap.width - 1) - (int)(yc_off * (funmap.width * txrepeat) + xmotion)%funmap.width));
 
      int cl2 = (int)xxd2 + yyd2;
      
      int r2 = (int)(red(funmap.pixels[cl2]) * bd);
      int g2 = (int)(green(funmap.pixels[cl2]) * bd);
      int b2 = (int)(blue(funmap.pixels[cl2]) * bd);
      
      // third texture (night version), reuse the first texture UV since they are the same width/height
      int rn = (int)(red(nightmap.pixels[cl]));
      int gn = (int)(green(nightmap.pixels[cl]));
      int bn = (int)(blue(nightmap.pixels[cl]));
      
      // fourth texture (cycle mask), only use single component since it is black/white
      int xxdc = ((cyclemap.width - 1) - (int)(yc_off * (cyclemap.width * xrepeat) + xmotion * 4)%cyclemap.width);
      int clc = (int)xxdc + yydc;
      float rc = red(cyclemap.pixels[clc]) / 255;
      
      float final_r = r * rc + rn * (1 - rc);
      float final_g = g * rc + gn * (1 - rc);
      float final_b = b * rc + bn * (1 - rc);
      
      // some compositing 
      fill(r * (r2 / 255) + final_r, g * (g2 / 255) + final_g, b * (b2 / 255) + final_b);//r * (r2 / 255) + r * bright, g * (g2 / 255) + g * bright, b * (b2 / 255) + b * bright);
      
      rect(final_x + (random(2.0) - 1.0) * xrand_rect_size_max, final_y + (random(2.0) - 1.0) * yrand_rect_size_max, rect_size, rect_size);
    }
    
    for (int e = 0; e <= (int)xc_off / 2; e += dots_step) {
      float dd = (float)e / xc_off;

      final_x = xoff - (xc_off) + (xc_off-(xc_off / (dd+0.5)) * abs(0.5-(dd+0.5))) * 2;
      
      float yc_off;
      
      // compute UV texels for the colormap
      float dd2 = 1 - dd;
        
      yc_off = sqrt(1 - dd2*dd2) + 1.270;
      
      // apply colormaps
      float xrepeat = 0.5;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + xmotion)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      // second texture (text mask)
      float txrepeat = 1.;
      
      int xxd2 = max(0, ((funmap.width - 1) - (int)(yc_off * (funmap.width * txrepeat) + xmotion)%funmap.width));
 
      int cl2 = (int)xxd2 + yyd2;
      
      int r2 = (int)(red(funmap.pixels[cl2]) * bd);
      int g2 = (int)(green(funmap.pixels[cl2]) * bd);
      int b2 = (int)(blue(funmap.pixels[cl2]) * bd);
      
      // third texture (night version), reuse the first texture UV since they are the same width/height
      int rn = (int)(red(nightmap.pixels[cl]));
      int gn = (int)(green(nightmap.pixels[cl]));
      int bn = (int)(blue(nightmap.pixels[cl]));
      
      // fourth texture (cycle mask), only use single component since it is black/white
      int xxdc = ((cyclemap.width - 1) - (int)(yc_off * (cyclemap.width * xrepeat) + xmotion * 4)%cyclemap.width);
      int clc = (int)xxdc + yydc;
      float rc = red(cyclemap.pixels[clc]) / 255;
      
      float final_r = r * rc + rn * (1 - rc);
      float final_g = g  * rc + gn * (1 - rc);
      float final_b = b * rc + bn * (1 - rc);
      
      // some compositing 
      fill(r * (r2 / 255) + final_r, g * (g2 / 255) + final_g, b * (b2 / 255) + final_b);//r * (r2 / 255) + r * bright, g * (g2 / 255) + g * bright, b * (b2 / 255) + b * bright);
      
      rect(final_x + (random(2.0) - 1.0) * xrand_rect_size_max, final_y + (random(2.0) - 1.0) * yrand_rect_size_max, rect_size, rect_size);
    }
  }
  
  xmotion += 0.5;
  ymotion -= 0.25;
}

void setup() {
  size(800, 600);

  frameRate(60); 
  
  colormap = loadImage(""data.jpg"");
  funmap = loadImage(""data2.jpg"");
  nightmap = loadImage(""data_night.jpg"");
  cyclemap = loadImage(""data_cycle.jpg"");
  
  background(0);
}

void draw() {
  //background(0);
 
  draw_planet();
}"
"561219","Waves","mySketch","/**
  * Same tech as my Planet Earth snippet, with lots of motion blur and object made of dots (rectangles), this look like a metaball / droplet!
  */

PImage colormap;

float xmotion = 0;
float ymotion = 0;

// quality control
int dots_step = 2;
int elems_step = 1;

// same but look below, these are adjusted in real-time to increase rendering quality by abusing motion blur :)
int elems = 128;
int rect_size = 12;

void draw_planet() {
  float mx = mouseX / 1024.0;
	float my = mouseY / 1024.0;

  // add some motion blur / brightness
  fill(0, 0, 0, 8);
  rect(0, 0, 800, 600);
	
	// here we take advantage of the motion blur to ""fill in the gap"" by adjusting each slices / frames, this increase rendering quality (altough it look hazy)
	//elems = 92 + sin(xmotion / 24.) * 36;
	rect_size = 12 + abs(sin(xmotion / 84.)) * 4;
  
  noStroke();
  
  float xoff = 800 / 2;
  
  float sphere_radius = 224;
  float yoff = 600 / 2 - sphere_radius;
  
  for (int s = 0; s <= elems; s += elems_step) {
    float de = (float)s / elems;
    
    float bd = max((0.5-abs(de - 0.5)) * 4, 0.5);
    
    float yrepeat = 2;
    int yyd = (((int)(de * (colormap.height * yrepeat))%colormap.height)) * colormap.width;
		
    // cartesian circle equation
    float sphere_radius_squared = sphere_radius * sphere_radius;
    float sh_radius = de * (sphere_radius * 2) - sphere_radius;
    float xc_off = sqrt(sphere_radius_squared - sh_radius*sh_radius);
    
    float final_x;
    float final_y = yoff + de * (sphere_radius * 2) - (sin((de * 360 * 2) * (PI / 180) + xmotion / 20.)) * 92;
		
		int xc_offd2 = (int)xc_off / 2;
    
    for (int e = 0; e <= xc_offd2; e += dots_step) {
      float dd = (float)e / xc_off;

      final_x = xoff - (xc_off) + (xc_off /* / (dd+0.5)*/) * abs(0.5-(dd+0.5)) * 2 + cos((de * 360 + 180) * (PI / 180) + xmotion / 14.) * 148;
      
      float yc_off;
      
      // compute UV texels for the colormap
        float dd2 = 1 - dd;
        
        yc_off = 1-sqrt(1 - dd2*dd2);
      
      // apply colormaps
      float xrepeat = 1.;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + xmotion)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      // some compositing 
      fill(r, g, b, 48);//r * (r2 / 255) + r * bright, g * (g2 / 255) + g * bright, b * (b2 / 255) + b * bright);
      
      //rect(final_x, final_y, rect_size, rect_size);
      // slower but look good!
      ellipse(final_x, final_y, rect_size, rect_size);

/*
      // can improve the look with some kind of ""dithering""
      fill(r, g, b, 255);
      
      float rect_size2 = rect_size / 2;
      rect(final_x - rect_size2, final_y, rect_size2, rect_size2);
      rect(final_x + rect_size2, final_y, rect_size2, rect_size2);
      rect(final_x, final_y - rect_size2, rect_size2, rect_size2);
      rect(final_x, final_y + rect_size2, rect_size2, rect_size2);
*/
    }
		
    for (int e = 0; e <= xc_offd2; e += dots_step) {
      float dd = (float)e / xc_off;

      final_x = xoff - (xc_off) + (xc_off-(xc_off/* / (dd+0.5)*/) * abs(0.5-(dd+0.5))) * 2  + 1.-cos((de * 360 + 180) * (PI / 180) + xmotion / 14.) * 148;
      
      float yc_off;
      
      // compute UV texels for the colormap
      float dd2 = 1 - dd;
        
      yc_off = sqrt(1 - dd2*dd2) + 1.270;
      
      // apply colormaps
      float xrepeat = 1.;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + xmotion)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      // some compositing 
      fill(r, g, b, 48);//r * (r2 / 255) + r * bright, g * (g2 / 255) + g * bright, b * (b2 / 255) + b * bright);
      
      //rect(final_x, final_y, rect_size, rect_size);
      // slower but look good!
      ellipse(final_x, final_y, rect_size, rect_size);

/*
      // can improve the look with some kind of ""dithering""
      fill(r, g, b, 255);
      
      float rect_size2 = rect_size / 2;
      rect(final_x - rect_size2, final_y, rect_size2, rect_size2);
      rect(final_x + rect_size2, final_y, rect_size2, rect_size2);
      rect(final_x, final_y - rect_size2, rect_size2, rect_size2);
      rect(final_x, final_y + rect_size2, rect_size2, rect_size2);
*/
    }
  }
  
  xmotion += 0.5;
	ymotion += 0.25;
}

void setup() {
  size(800, 600);

  frameRate(60); 
  
  colormap = loadImage(""wattex-1.jpg"");
  
  background(0);
}

void draw() {
  //background(0);
 
  draw_planet();
}"
"561219","Waves","mySketch","/**
  * Same tech as my Planet Earth snippet, with lots of motion blur and object made of dots (rectangles), this look like a metaball / droplet!
  */

PImage colormap;

float xmotion = 0;
float ymotion = 0;

// quality control
int dots_step = 4;
int elems_step = 1;

// same but look below, these are adjusted in real-time to increase rendering quality by abusing motion blur :)
int elems = 128;
int rect_size = 12;

void draw_planet() {
  float mx = mouseX / 1024.0;
	float my = mouseY / 1024.0;

  // add some motion blur / brightness
  fill(0, 0, 0, 1);
  rect(0, 0, 800, 600);
	
	// here we take advantage of the motion blur to ""fill in the gap"" by adjusting each slices / frames, this increase rendering quality (altough it look hazy)
	//elems = 92 + sin(xmotion / 24.) * 36;
	rect_size = 12 + abs(sin(xmotion / 84.)) * 4;
  
  noStroke();
  
  float xoff = 800 / 2;
  
  float sphere_radius = 224;
  float yoff = 600 / 2 - sphere_radius;
  
  for (int s = 0; s <= elems; s += elems_step) {
    float de = (float)s / elems;
    
    float bd = max((0.5-abs(de - 0.5)) * 4, 0.5);
    
    float yrepeat = 1;
    int yyd = (((int)(de * (colormap.height * yrepeat))%colormap.height)) * colormap.width;
		
    // cartesian circle equation
    float sphere_radius_squared = sphere_radius * sphere_radius;
    float sh_radius = de * (sphere_radius * 2) - sphere_radius;
    float xc_off = sqrt(sphere_radius_squared - sh_radius*sh_radius);
    
    float final_x;
    float final_y = yoff + de * (sphere_radius * 2) - (sin((de * 360 * 1.5) * (PI / 180) + xmotion / 20.)) * 92;
		
		int xc_offd2 = (int)xc_off / 2;
    
    for (int e = 0; e < xc_offd2; e += dots_step) {
      float dd = (float)e / xc_off;

      final_x = xoff - (xc_off) + (xc_off /* / (dd+0.5)*/) * abs(0.5-(dd+0.5)) * 2 + cos((de * 360 + 180) * (PI / 180) + xmotion / 14.) * 2;
      
      float yc_off;
      
      // compute UV texels for the colormap
        float dd2 = 1 - dd;
        
        yc_off = 1-sqrt(1 - dd2*dd2);
      
      // apply colormaps
      float xrepeat = 1.;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + xmotion)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      // some compositing 
      fill(r, g, b, 48);//r * (r2 / 255) + r * bright, g * (g2 / 255) + g * bright, b * (b2 / 255) + b * bright);
      
      //rect(final_x, final_y, rect_size, rect_size);
      // slower but look good!
      ellipse(final_x, final_y, rect_size, rect_size);

/*
      // can improve the look with some kind of ""dithering""
      fill(r, g, b, 255);
      
      float rect_size2 = rect_size / 2;
      rect(final_x - rect_size2, final_y, rect_size2, rect_size2);
      rect(final_x + rect_size2, final_y, rect_size2, rect_size2);
      rect(final_x, final_y - rect_size2, rect_size2, rect_size2);
      rect(final_x, final_y + rect_size2, rect_size2, rect_size2);
*/
    }
		
    for (int e = 0; e < xc_offd2; e += dots_step) {
      float dd = (float)e / xc_off;

      final_x = xoff - (xc_off) + (xc_off-(xc_off/* / (dd+0.5)*/) * abs(0.5-(dd+0.5))) * 2  + 1.-cos((de * 360 + 180) * (PI / 180) + xmotion / 14.) * 2;
      
      float yc_off;
      
      // compute UV texels for the colormap
      float dd2 = 1 - dd;
        
      yc_off = sqrt(1 - dd2*dd2) + 1.270;
      
      // apply colormaps
      float xrepeat = 1.;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + xmotion)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      // some compositing 
      fill(r, g, b, 48);//r * (r2 / 255) + r * bright, g * (g2 / 255) + g * bright, b * (b2 / 255) + b * bright);
      
      //rect(final_x, final_y, rect_size, rect_size);
      // slower but look good!
      ellipse(final_x, final_y, rect_size, rect_size);

/*
      // can improve the look with some kind of ""dithering""
      fill(r, g, b, 255);
      
      float rect_size2 = rect_size / 2;
      rect(final_x - rect_size2, final_y, rect_size2, rect_size2);
      rect(final_x + rect_size2, final_y, rect_size2, rect_size2);
      rect(final_x, final_y - rect_size2, rect_size2, rect_size2);
      rect(final_x, final_y + rect_size2, rect_size2, rect_size2);
*/
    }
  }
  
  xmotion += 0.5;
	ymotion += 0.25;
}

void setup() {
  size(800, 600);

  frameRate(60); 
  
  colormap = loadImage(""tongue.jpg"");
  
  background(0);
}

void draw() {
  //background(0);
 
  draw_planet();
}"
"561219","Waves","mySketch","/**
  * Same tech as droplet except with fixed rendering and more waves!
  */

PImage colormap;

float xmotion = 0;
float ymotion = 0;

// quality control
int dots_step = 4;
int elems_step = 1;

// same but look below, these are adjusted in real-time to increase rendering quality by abusing motion blur :)
int elems = 128;
int rect_size = 8;

void draw_planet() {
  float mx = mouseX / 1024.0;
	float my = mouseY / 1024.0;

  // add some motion blur / brightness
  fill(0, 0, 0, 8);
  rect(0, 0, 800, 600);
	
	// here we take advantage of the motion blur to ""fill in the gap"" by adjusting each slices / frames, this increase rendering quality (altough it look hazy)
	//elems = 92 + sin(xmotion / 24.) * 36;
	//rect_size = 12 + abs(sin(xmotion / 84.)) * 4;
  
  noStroke();
  
  float xoff = 800 / 2;
  
  float sphere_radius = 224;
  float yoff = 600 / 2 - sphere_radius;
  
  for (int s = 0; s <= elems; s += elems_step) {
    float de = (float)s / elems;
    
    float bd = max((0.5-abs(de - 0.5)) * 4, 0.5);
    
    float yrepeat = 1;
    int yyd = (((int)(de * (colormap.height * yrepeat))%colormap.height)) * colormap.width;
		
    // cartesian circle equation
    float sphere_radius_squared = sphere_radius * sphere_radius;
    float sh_radius = de * (sphere_radius * 2) - sphere_radius;
    float xc_off = sqrt(sphere_radius_squared - sh_radius*sh_radius);
    
    float final_x;
    float final_y = yoff + de * (sphere_radius * 2) - (sin((de * 360 * 1.5) * (PI / 180) + xmotion / 22.)) * 92;
		
		int xc_offd2 = (int)xc_off / 2;
    
    for (int e = 0; e < xc_offd2; e += dots_step) {
      float dd = (float)e / xc_off;

      final_x = xoff - (xc_off) + (xc_off /* / (dd+0.5)*/) * abs(0.5-(dd+0.5)) * 2 + cos((de * 360 + 180) * (PI / 180) + xmotion / 14.+dd) * 24;
      
      float yc_off;
      
      // compute UV texels for the colormap
        float dd2 = 1 - dd;
        
        yc_off = 1-sqrt(1 - dd2*dd2);
      
      // apply colormaps
      float xrepeat = 1.;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + xmotion)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      // some compositing 
      fill(r, g, b, 48);//r * (r2 / 255) + r * bright, g * (g2 / 255) + g * bright, b * (b2 / 255) + b * bright);
      
      //rect(final_x, final_y, rect_size, rect_size);
      // slower but look good!
      ellipse(final_x, final_y, rect_size, rect_size);

    }
		
    for (int e = 0; e < xc_offd2; e += dots_step) {
      float dd = (float)e / xc_off;

      final_x = xoff - (xc_off) + (xc_off-(xc_off/* / (dd+0.5)*/) * abs(0.5-(dd+0.5))) * 2  + 1.-cos((de * 360 + 180) * (PI / 180) + xmotion / 14.+dd) * 24;
      
      float yc_off;
      
      // compute UV texels for the colormap
      float dd2 = 1 - dd;
        
      yc_off = sqrt(1 - dd2*dd2) + 1.270;
      
      // apply colormaps
      float xrepeat = 1.;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + xmotion)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      // some compositing 
      fill(r, g, b, 48);//r * (r2 / 255) + r * bright, g * (g2 / 255) + g * bright, b * (b2 / 255) + b * bright);
      
      //rect(final_x, final_y, rect_size, rect_size);
      // slower but look good!
      ellipse(final_x, final_y, rect_size, rect_size);
    }
  }
  
  xmotion += 0.5;
	ymotion += 0.25;
}

void setup() {
  size(800, 600);

  frameRate(60); 
  
  colormap = loadImage(""wattex-18.jpg"");
  
  background(0);
}

void draw() {
  //background(0);
 
  draw_planet();
}"
"561219","Waves","mySketch","/**
  * Same tech as droplet except with fixed rendering and more waves!
  */

PImage colormap;

float xmotion = 0;
float ymotion = 0;

// quality control
int dots_step = 4;
int elems_step = 1;

// same but look below, these are adjusted in real-time to increase rendering quality by abusing motion blur :)
int elems = 128;
int rect_size = 8;

void draw_planet() {
  float mx = mouseX / 1024.0;
	float my = mouseY / 1024.0;

  // add some motion blur / brightness
  fill(0, 0, 0, 8);
  rect(0, 0, 800, 600);
	
	// here we take advantage of the motion blur to ""fill in the gap"" by adjusting each slices / frames, this increase rendering quality (altough it look hazy)
	//elems = 92 + sin(xmotion / 24.) * 36;
	//rect_size = 12 + abs(sin(xmotion / 84.)) * 4;
  
  noStroke();
  
  float xoff = 800 / 2;
  
  float sphere_radius = 224;
  float yoff = 600 / 2 - sphere_radius;
  
  for (int s = 0; s <= elems; s += elems_step) {
    float de = (float)s / elems;
    
    float bd = max((0.5-abs(de - 0.5)) * 4, 0.5);
    
    float yrepeat = 1;
    int yyd = (((int)(de * (colormap.height * yrepeat))%colormap.height)) * colormap.width;
		
    // cartesian circle equation
    float sphere_radius_squared = sphere_radius * sphere_radius;
    float sh_radius = de * (sphere_radius * 2) - sphere_radius;
    float xc_off = sqrt(sphere_radius_squared - sh_radius*sh_radius);
    
    float final_x;
    float final_y = yoff + de * (sphere_radius * 2) - (sin((de * 360 * 1.5) * (PI / 180) + xmotion / 22.)) * 92;
		
		int xc_offd2 = (int)xc_off / 2;
    
    for (int e = 0; e < xc_offd2; e += dots_step) {
      float dd = (float)e / xc_off;

      final_x = xoff - (xc_off) + (xc_off /* / (dd+0.5)*/) * abs(0.5-(dd+0.5)) * 2 + cos((de * 360 + 180) * (PI / 180) + xmotion / 14.+dd) * 24;
      
      float yc_off;
      
      // compute UV texels for the colormap
        float dd2 = 1 - dd;
        
        yc_off = 1-sqrt(1 - dd2*dd2);
      
      // apply colormaps
      float xrepeat = 1.;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + xmotion)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      // some compositing 
      fill(r, g, b, 48);//r * (r2 / 255) + r * bright, g * (g2 / 255) + g * bright, b * (b2 / 255) + b * bright);
      
      //rect(final_x, final_y, rect_size, rect_size);
      // slower but look good!
      ellipse(final_x, final_y, rect_size, rect_size);

    }
		
    for (int e = 0; e < xc_offd2; e += dots_step) {
      float dd = (float)e / xc_off;

      final_x = xoff - (xc_off) + (xc_off-(xc_off/* / (dd+0.5)*/) * abs(0.5-(dd+0.5))) * 2  + 1.-cos((de * 360 + 180) * (PI / 180) + xmotion / 14.+dd) * 24;
      
      float yc_off;
      
      // compute UV texels for the colormap
      float dd2 = 1 - dd;
        
      yc_off = sqrt(1 - dd2*dd2) + 1.270;
      
      // apply colormaps
      float xrepeat = 1.;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + xmotion)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      // some compositing 
      fill(r, g, b, 48);//r * (r2 / 255) + r * bright, g * (g2 / 255) + g * bright, b * (b2 / 255) + b * bright);
      
      //rect(final_x, final_y, rect_size, rect_size);
      // slower but look good!
      ellipse(final_x, final_y, rect_size, rect_size);
    }
  }
  
  xmotion += 0.5;
	ymotion += 0.25;
}

void setup() {
  size(800, 600);

  frameRate(60); 
  
  colormap = loadImage(""wattex-18.jpg"");
  
  background(0);
}

void draw() {
  //background(0);
 
  draw_planet();
}"
"561219","Waves","mySketch","/**
  * Same tech as droplet except with fixed rendering and more waves!
  */

PImage colormap;

float xmotion = 0;
float ymotion = 0;

// quality control
int dots_step = 4;
int elems_step = 1;

// same but look below, these are adjusted in real-time to increase rendering quality by abusing motion blur :)
int elems = 128;
int rect_size = 8;

void draw_planet() {
  float mx = mouseX / 1024.0;
	float my = mouseY / 1024.0;

  // add some motion blur / brightness
  fill(0, 0, 0, 8);
  rect(0, 0, 800, 600);
	
	// here we take advantage of the motion blur to ""fill in the gap"" by adjusting each slices / frames, this increase rendering quality (altough it look hazy)
	//elems = 92 + sin(xmotion / 24.) * 36;
	//rect_size = 12 + abs(sin(xmotion / 84.)) * 4;
  
  noStroke();
  
  float xoff = 800 / 2;
  
  float sphere_radius = 224;
  float yoff = 600 / 2 - sphere_radius;
  
  for (int s = 0; s <= elems; s += elems_step) {
    float de = (float)s / elems;
    
    float bd = max((0.5-abs(de - 0.5)) * 4, 0.5);
    
    float yrepeat = 1;
    int yyd = (((int)(de * (colormap.height * yrepeat))%colormap.height)) * colormap.width;
		
    // cartesian circle equation
    float sphere_radius_squared = sphere_radius * sphere_radius;
    float sh_radius = de * (sphere_radius * 2) - sphere_radius;
    float xc_off = sqrt(sphere_radius_squared - sh_radius*sh_radius);
    
    float final_x;
    float final_y = yoff + de * (sphere_radius * 2) - (sin((de * 360 * 1.5) * (PI / 180) + xmotion / 22.)) * 92;
		
		int xc_offd2 = (int)xc_off / 1.5;
    
    for (int e = 0; e < xc_offd2; e += dots_step) {
      float dd = (float)e / xc_off;

      final_x = xoff - (xc_off) + (xc_off /* / (dd+0.5)*/) * abs(0.5-(dd+0.5)) * 2 + cos((de * 360 + 180) * (PI / 180) + xmotion / 14.+dd) * 24;
      
      float yc_off;
      
      // compute UV texels for the colormap
        float dd2 = 1 - dd;
        
        yc_off = 1-sqrt(1 - dd2*dd2);
      
      // apply colormaps
      float xrepeat = 1.;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + xmotion)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      // some compositing 
      fill(r, g, b, 48);//r * (r2 / 255) + r * bright, g * (g2 / 255) + g * bright, b * (b2 / 255) + b * bright);
      
      //rect(final_x, final_y, rect_size, rect_size);
      // slower but look good!
      ellipse(final_x, final_y, rect_size, rect_size);

    }
		
    for (int e = 0; e < xc_offd2; e += dots_step) {
      float dd = (float)e / xc_off;

      final_x = xoff - (xc_off) + (xc_off-(xc_off/* / (dd+0.5)*/) * abs(0.5-(dd+0.5))) * 2  + 1.-cos((de * 360 + 180) * (PI / 180) + xmotion / 14.+dd) * 24;
      
      float yc_off;
      
      // compute UV texels for the colormap
      float dd2 = 1 - dd;
        
      yc_off = sqrt(1 - dd2*dd2) + 1.270;
      
      // apply colormaps
      float xrepeat = 1.;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + xmotion)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      // some compositing 
      fill(r, g, b, 48);//r * (r2 / 255) + r * bright, g * (g2 / 255) + g * bright, b * (b2 / 255) + b * bright);
      
      //rect(final_x, final_y, rect_size, rect_size);
      // slower but look good!
      ellipse(final_x, final_y, rect_size, rect_size);
    }
  }
  
  xmotion += 0.5;
	ymotion += 0.25;
}

void setup() {
  size(800, 600);

  frameRate(60); 
  
  colormap = loadImage(""wattex-18.jpg"");
  
  background(0);
}

void draw() {
  //background(0);
 
  draw_planet();
}"
"561193","Blue Planet Billboards","mySketch","/**
  * Same approach as dots planet billboard snippet with ""correct"" rendering this time by splitting the filled circle in half and inverting the second half,
  * dots density also increase as they are near the center which improve the quality (altough making it blurry on the edge).
  * 
  */

PImage colormap;
PImage funmap;
PImage nightmap;
PImage cyclemap;

float xmotion = 0;
float ymotion = 0;

// quality control
int dots_step = 1;
int elems_step = 1;

// same but look below, these are adjusted in real-time to increase rendering quality by abusing motion blur :)
int elems = 292;
int rect_size = 2;

void draw_planet() {
  float mx = mouseX / 1024.0;
  float my = mouseY / 1024.0;
  
  elems_step = (int)(1.0 + mx * 1.0);
  dots_step = (int)(1.0 + my * 1.0);

  // add some motion blur / brightness
  fill(0, 0, 0, 4);
  rect(0, 0, 800, 600);
  
  // here we take advantage of the motion blur to ""fill in the gap"" by adjusting each slices / frames, this increase rendering quality (altough it look hazy)
  elems = (int)(92 + sin(xmotion / 24.) * 36);
  rect_size = (int)(2 + abs(sin(xmotion / 84.)) * 4);
  
  noStroke();
  
  float xoff = 800 / 2;
  
  float sphere_radius = 292;
  float yoff = 600 / 2 - sphere_radius;
  
  for (int s = 0; s < elems; s += elems_step) {
    float de = (float)s / elems;
    
    float bd = max((0.5-abs(de - 0.5)) * 4, 0.05);
    
    float yrepeat = 1;
    int yyd = (((int)(de * (colormap.height * yrepeat))%colormap.height)) * colormap.width;
    
    float tyrepeat = 4;
    int yyd2 = (((int)(de * (funmap.height * tyrepeat) + xmotion)%funmap.height)) * funmap.width;
    
    int yydc = (((int)(de * (cyclemap.height * yrepeat))%cyclemap.height)) * cyclemap.width;
    
    // cartesian circle equation
    float sphere_radius_squared = sphere_radius * sphere_radius;
    float sh_radius = de * (sphere_radius * 2) - sphere_radius;
    float xc_off = sqrt(sphere_radius_squared - sh_radius*sh_radius);
    
    float final_x;
    float final_y = yoff + de * (sphere_radius * 2); // flabby planet bonus : + sin((de * 360 + 180) * (PI / 180) + ymotion / 24.) * 4;
    
    for (int e = 0; e <= (int)xc_off / 2; e += dots_step) {
      float dd = (float)e / xc_off;

      final_x = xoff - (xc_off) + (xc_off / (dd+0.5)) * abs(0.5-(dd+0.5)) * 2 ;
      
      float yc_off;
      
      // compute UV texels for the colormap
      float dd2 = 1 - dd;
        
      yc_off = 1-sqrt(1 - dd2*dd2);
      
      // apply colormaps
      float xrepeat = 0.5;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + xmotion)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      // second texture (text mask)
      float txrepeat = 1.;
      
      int xxd2 = max(0, ((funmap.width - 1) - (int)(yc_off * (funmap.width * txrepeat) + xmotion)%funmap.width));
 
      int cl2 = (int)xxd2 + yyd2;
      
      int r2 = (int)(red(funmap.pixels[cl2]) * bd);
      int g2 = (int)(green(funmap.pixels[cl2]) * bd);
      int b2 = (int)(blue(funmap.pixels[cl2]) * bd);
      
      // third texture (night version), reuse the first texture UV since they are the same width/height
      int rn = (int)(red(nightmap.pixels[cl]));
      int gn = (int)(green(nightmap.pixels[cl]));
      int bn = (int)(blue(nightmap.pixels[cl]));
      
      // fourth texture (cycle mask), only use single component since it is black/white
      int xxdc = ((cyclemap.width - 1) - (int)(yc_off * (cyclemap.width * xrepeat) + xmotion * 4)%cyclemap.width);
      int clc = (int)xxdc + yydc;
      float rc = red(cyclemap.pixels[clc]) / 255;
      
      float final_r = r * rc + rn * (1 - rc);
      float final_g = g * rc + gn * (1 - rc);
      float final_b = b * rc + bn * (1 - rc);
      
      // some compositing 
      fill(r * (r2 / 255) + final_r, g * (g2 / 255) + final_g, b * (b2 / 255) + final_b);//r * (r2 / 255) + r * bright, g * (g2 / 255) + g * bright, b * (b2 / 255) + b * bright);
      
      rect(final_x, final_y, rect_size, rect_size);
    }
    
    for (int e = 0; e <= (int)xc_off / 2; e += dots_step) {
      float dd = (float)e / xc_off;

      final_x = xoff - (xc_off) + (xc_off-(xc_off / (dd+0.5)) * abs(0.5-(dd+0.5))) * 2;
      
      float yc_off;
      
      // compute UV texels for the colormap
      float dd2 = 1 - dd;
        
      yc_off = sqrt(1 - dd2*dd2) + 1.270;
      
      // apply colormaps
      float xrepeat = 0.5;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + xmotion)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      // second texture (text mask)
      float txrepeat = 1.;
      
      int xxd2 = max(0, ((funmap.width - 1) - (int)(yc_off * (funmap.width * txrepeat) + xmotion)%funmap.width));
 
      int cl2 = (int)xxd2 + yyd2;
      
      int r2 = (int)(red(funmap.pixels[cl2]) * bd);
      int g2 = (int)(green(funmap.pixels[cl2]) * bd);
      int b2 = (int)(blue(funmap.pixels[cl2]) * bd);
      
      // third texture (night version), reuse the first texture UV since they are the same width/height
      int rn = (int)(red(nightmap.pixels[cl]));
      int gn = (int)(green(nightmap.pixels[cl]));
      int bn = (int)(blue(nightmap.pixels[cl]));
      
      // fourth texture (cycle mask), only use single component since it is black/white
      int xxdc = ((cyclemap.width - 1) - (int)(yc_off * (cyclemap.width * xrepeat) + xmotion * 4)%cyclemap.width);
      int clc = (int)xxdc + yydc;
      float rc = red(cyclemap.pixels[clc]) / 255;
      
      float final_r = r * rc + rn * (1 - rc);
      float final_g = g  * rc + gn * (1 - rc);
      float final_b = b * rc + bn * (1 - rc);
      
      // some compositing 
      fill(r * (r2 / 255) + final_r, g * (g2 / 255) + final_g, b * (b2 / 255) + final_b);//r * (r2 / 255) + r * bright, g * (g2 / 255) + g * bright, b * (b2 / 255) + b * bright);
      
      rect(final_x, final_y, rect_size, rect_size);
    }
  }
  
  xmotion += 0.5;
  ymotion -= 0.25;
}

void setup() {
  size(800, 600);

  frameRate(60); 
  
  colormap = loadImage(""data.jpg"");
  funmap = loadImage(""data2.jpg"");
  nightmap = loadImage(""data_night.jpg"");
  cyclemap = loadImage(""data_cycle.jpg"");
  
  background(0);
}

void draw() {
  //background(0);
 
  draw_planet();
}"
"561193","Blue Planet Billboards","mySketch","/**
  * Same approach as dots planet billboard snippet with ""correct"" rendering this time by splitting the filled circle in half and inverting the second half,
  * dots density also increase as they are near the center which improve the quality (altough making it blurry on the edge).
  * 
  */

PImage colormap;
PImage funmap;
PImage nightmap;
PImage cyclemap;

float xmotion = 0;
float ymotion = 0;

// quality control
int dots_step = 1;
int elems_step = 1;

// same but look below, these are adjusted in real-time to increase rendering quality by abusing motion blur :)
int elems = 292 / 2;
int rect_size = 4;

void draw_planet() {
  float mx = mouseX / 1024.0;
  float my = mouseY / 1024.0;
  
  elems_step = (int)(1.0 + mx * 1.0);
  dots_step = (int)(1.0 + my * 1.0);

  // add some motion blur / brightness
  fill(0, 0, 0, 4);
  rect(0, 0, 800, 600);
  
  // here we take advantage of the motion blur to ""fill in the gap"" by adjusting each slices / frames, this increase rendering quality (altough it look hazy)
  //elems = (int)(92 + sin(xmotion / 24.) * 36);
  //rect_size = (int)(2 + abs(sin(xmotion / 84.)) * 4);
  
  noStroke();
  
  float xoff = 800 / 2;
  
  float sphere_radius = 292;
  float yoff = 600 / 2 - sphere_radius;
  
  for (int s = 0; s < elems; s += elems_step) {
    float de = (float)s / elems;
    
    float bd = max((0.5-abs(de - 0.5)) * 4, 0.05);
    
    float yrepeat = 1;
    int yyd = (((int)(de * (colormap.height * yrepeat))%colormap.height)) * colormap.width;
    
    float tyrepeat = 4;
    int yyd2 = (((int)(de * (funmap.height * tyrepeat) + xmotion)%funmap.height)) * funmap.width;
    
    int yydc = (((int)(de * (cyclemap.height * yrepeat))%cyclemap.height)) * cyclemap.width;
    
    // cartesian circle equation
    float sphere_radius_squared = sphere_radius * sphere_radius;
    float sh_radius = de * (sphere_radius * 2) - sphere_radius;
    float xc_off = sqrt(sphere_radius_squared - sh_radius*sh_radius);
    
    float final_x;
    float final_y = yoff + de * (sphere_radius * 2); // flabby planet bonus : + sin((de * 360 + 180) * (PI / 180) + ymotion / 24.) * 4;
    
    for (int e = 0; e <= (int)xc_off / 2; e += dots_step) {
      float dd = (float)e / xc_off;

      final_x = xoff - (xc_off) + (xc_off / (dd+0.5)) * abs(0.5-(dd+0.5)) * 2 ;
      
      float yc_off;
      
      // compute UV texels for the colormap
      float dd2 = 1 - dd;
        
      yc_off = 1-sqrt(1 - dd2*dd2);
      
      // apply colormaps
      float xrepeat = 0.5;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + xmotion)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      // second texture (text mask)
      float txrepeat = 1.;
      
      int xxd2 = max(0, ((funmap.width - 1) - (int)(yc_off * (funmap.width * txrepeat) + xmotion)%funmap.width));
 
      int cl2 = (int)xxd2 + yyd2;
      
      int r2 = (int)(red(funmap.pixels[cl2]) * bd);
      int g2 = (int)(green(funmap.pixels[cl2]) * bd);
      int b2 = (int)(blue(funmap.pixels[cl2]) * bd);
      
      // third texture (night version), reuse the first texture UV since they are the same width/height
      int rn = (int)(red(nightmap.pixels[cl]));
      int gn = (int)(green(nightmap.pixels[cl]));
      int bn = (int)(blue(nightmap.pixels[cl]));
      
      // fourth texture (cycle mask), only use single component since it is black/white
      int xxdc = ((cyclemap.width - 1) - (int)(yc_off * (cyclemap.width * xrepeat) + xmotion * 4)%cyclemap.width);
      int clc = (int)xxdc + yydc;
      float rc = red(cyclemap.pixels[clc]) / 255;
      
      float final_r = r * rc + rn * (1 - rc);
      float final_g = g * rc + gn * (1 - rc);
      float final_b = b * rc + bn * (1 - rc);
      
      // some compositing 
      fill(r * (r2 / 255) + final_r, g * (g2 / 255) + final_g, b * (b2 / 255) + final_b);//r * (r2 / 255) + r * bright, g * (g2 / 255) + g * bright, b * (b2 / 255) + b * bright);
      
      rect(final_x, final_y, rect_size, rect_size);
    }
    
    for (int e = 0; e <= (int)xc_off / 2; e += dots_step) {
      float dd = (float)e / xc_off;

      final_x = xoff - (xc_off) + (xc_off-(xc_off / (dd+0.5)) * abs(0.5-(dd+0.5))) * 2;
      
      float yc_off;
      
      // compute UV texels for the colormap
      float dd2 = 1 - dd;
        
      yc_off = sqrt(1 - dd2*dd2) + 1.270;
      
      // apply colormaps
      float xrepeat = 0.5;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + xmotion)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      // second texture (text mask)
      float txrepeat = 1.;
      
      int xxd2 = max(0, ((funmap.width - 1) - (int)(yc_off * (funmap.width * txrepeat) + xmotion)%funmap.width));
 
      int cl2 = (int)xxd2 + yyd2;
      
      int r2 = (int)(red(funmap.pixels[cl2]) * bd);
      int g2 = (int)(green(funmap.pixels[cl2]) * bd);
      int b2 = (int)(blue(funmap.pixels[cl2]) * bd);
      
      // third texture (night version), reuse the first texture UV since they are the same width/height
      int rn = (int)(red(nightmap.pixels[cl]));
      int gn = (int)(green(nightmap.pixels[cl]));
      int bn = (int)(blue(nightmap.pixels[cl]));
      
      // fourth texture (cycle mask), only use single component since it is black/white
      int xxdc = ((cyclemap.width - 1) - (int)(yc_off * (cyclemap.width * xrepeat) + xmotion * 4)%cyclemap.width);
      int clc = (int)xxdc + yydc;
      float rc = red(cyclemap.pixels[clc]) / 255;
      
      float final_r = r * rc + rn * (1 - rc);
      float final_g = g  * rc + gn * (1 - rc);
      float final_b = b * rc + bn * (1 - rc);
      
      // some compositing 
      fill(r * (r2 / 255) + final_r, g * (g2 / 255) + final_g, b * (b2 / 255) + final_b);//r * (r2 / 255) + r * bright, g * (g2 / 255) + g * bright, b * (b2 / 255) + b * bright);
      
      rect(final_x, final_y, rect_size, rect_size);
    }
  }
  
  xmotion += 0.5;
  ymotion -= 0.25;
}

void setup() {
  size(800, 600);

  frameRate(60); 
  
  colormap = loadImage(""data.jpg"");
  funmap = loadImage(""data2.jpg"");
  nightmap = loadImage(""data_night.jpg"");
  cyclemap = loadImage(""data_cycle.jpg"");
  
  background(0);
}

void draw() {
  //background(0);
 
  draw_planet();
}"
"561193","Blue Planet Billboards","mySketch","/**
  * Same approach as dots planet billboard snippet with ""correct"" rendering this time by splitting the filled circle in half and inverting the second half,
  * dots density also increase as they are near the center (see comments in the code below) which improve the quality (altough making it blurry on the edge).
  * 
  */

PImage colormap;
PImage funmap;
PImage nightmap;
PImage cyclemap;

float xmotion = 0;
float ymotion = 0;

// quality control
int dots_step = 2;
int elems_step = 2;

// same but look below, these are adjusted in real-time to increase rendering quality by abusing motion blur :)
int elems = 292;
int rect_size = 12;

void draw_planet() {
  float mx = mouseX / 1024.0;
  float my = mouseY / 1024.0;
  
  elems_step = (int)(2.0 - mx * 1.0);
  dots_step = (int)(1.0 + my * 1.0);

  // add some motion blur / brightness
  fill(0, 0, 0, 4);
  rect(0, 0, 800, 600);
  
  // here we take advantage of the motion blur to ""fill in the gap"" by adjusting each slices / frames, this increase rendering quality (altough it look hazy)
  elems = (int)(92 + sin(xmotion / 24.) * 36);
  rect_size = (int)(2 + abs(sin(xmotion / 84.)) * 4);
  
  noStroke();
  
  float xoff = 800 / 2;
  
  float sphere_radius = 292;
  float yoff = 600 / 2 - sphere_radius;
  
  for (int s = 0; s < elems; s += elems_step) {
    float de = (float)s / elems;
    
    float bd = max((0.5-abs(de - 0.5)) * 4, 0.05);
    
    float yrepeat = 1;
    int yyd = (((int)(de * (colormap.height * yrepeat))%colormap.height)) * colormap.width;
    
    float tyrepeat = 4;
    int yyd2 = (((int)(de * (funmap.height * tyrepeat) + xmotion)%funmap.height)) * funmap.width;
    
    int yydc = (((int)(de * (cyclemap.height * yrepeat))%cyclemap.height)) * cyclemap.width;
    
    // cartesian circle equation
    float sphere_radius_squared = sphere_radius * sphere_radius;
    float sh_radius = de * (sphere_radius * 2) - sphere_radius;
    float xc_off = sqrt(sphere_radius_squared - sh_radius*sh_radius);
    
    float final_x;
    float final_y = yoff + de * (sphere_radius * 2); // flabby planet bonus : + sin((de * 360 + 180) * (PI / 180) + ymotion / 24.) * 4;
    
    for (int e = 0; e <= (int)xc_off / 2; e += dots_step) {
      float dd = (float)e / xc_off;

			// uncomment the code below to add the shrinking near the center (distributing the dots equality)
      final_x = xoff - (xc_off) + (xc_off /* / (dd+0.5)*/) * abs(0.5-(dd+0.5)) * 2 ;
      
      float yc_off;
      
      // compute UV texels for the colormap
      float dd2 = 1 - dd;
        
      yc_off = 1-sqrt(1 - dd2*dd2);
      
      // apply colormaps
      float xrepeat = 0.5;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + xmotion)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      // second texture (text mask)
      float txrepeat = 1.;
      
      int xxd2 = max(0, ((funmap.width - 1) - (int)(yc_off * (funmap.width * txrepeat) + xmotion)%funmap.width));
 
      int cl2 = (int)xxd2 + yyd2;
      
      int r2 = (int)(red(funmap.pixels[cl2]) * bd);
      int g2 = (int)(green(funmap.pixels[cl2]) * bd);
      int b2 = (int)(blue(funmap.pixels[cl2]) * bd);
      
      // third texture (night version), reuse the first texture UV since they are the same width/height
      int rn = (int)(red(nightmap.pixels[cl]));
      int gn = (int)(green(nightmap.pixels[cl]));
      int bn = (int)(blue(nightmap.pixels[cl]));
      
      // fourth texture (cycle mask), only use single component since it is black/white
      int xxdc = ((cyclemap.width - 1) - (int)(yc_off * (cyclemap.width * xrepeat) + xmotion * 4)%cyclemap.width);
      int clc = (int)xxdc + yydc;
      float rc = red(cyclemap.pixels[clc]) / 255;
      
      float final_r = r * rc + rn * (1 - rc);
      float final_g = g * rc + gn * (1 - rc);
      float final_b = b * rc + bn * (1 - rc);
      
      // some compositing 
      fill(r * (r2 / 255) + final_r, g * (g2 / 255) + final_g, b * (b2 / 255) + final_b);//r * (r2 / 255) + r * bright, g * (g2 / 255) + g * bright, b * (b2 / 255) + b * bright);
      
      rect(final_x, final_y, rect_size, rect_size);
    }
    
    for (int e = 0; e <= (int)xc_off / 2; e += dots_step) {
      float dd = (float)e / xc_off;

			// uncomment the code below to add the shrinking near the center (distributing the dots equality)
      final_x = xoff - (xc_off) + (xc_off-(xc_off/* / (dd+0.5)*/) * abs(0.5-(dd+0.5))) * 2;
      
      float yc_off;
      
      // compute UV texels for the colormap
      float dd2 = 1 - dd;
        
      yc_off = sqrt(1 - dd2*dd2) + 1.270;
      
      // apply colormaps
      float xrepeat = 0.5;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + xmotion)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      // second texture (text mask)
      float txrepeat = 1.;
      
      int xxd2 = max(0, ((funmap.width - 1) - (int)(yc_off * (funmap.width * txrepeat) + xmotion)%funmap.width));
 
      int cl2 = (int)xxd2 + yyd2;
      
      int r2 = (int)(red(funmap.pixels[cl2]) * bd);
      int g2 = (int)(green(funmap.pixels[cl2]) * bd);
      int b2 = (int)(blue(funmap.pixels[cl2]) * bd);
      
      // third texture (night version), reuse the first texture UV since they are the same width/height
      int rn = (int)(red(nightmap.pixels[cl]));
      int gn = (int)(green(nightmap.pixels[cl]));
      int bn = (int)(blue(nightmap.pixels[cl]));
      
      // fourth texture (cycle mask), only use single component since it is black/white
      int xxdc = ((cyclemap.width - 1) - (int)(yc_off * (cyclemap.width * xrepeat) + xmotion * 4)%cyclemap.width);
      int clc = (int)xxdc + yydc;
      float rc = red(cyclemap.pixels[clc]) / 255;
      
      float final_r = r * rc + rn * (1 - rc);
      float final_g = g  * rc + gn * (1 - rc);
      float final_b = b * rc + bn * (1 - rc);
      
      // some compositing 
      fill(r * (r2 / 255) + final_r, g * (g2 / 255) + final_g, b * (b2 / 255) + final_b);//r * (r2 / 255) + r * bright, g * (g2 / 255) + g * bright, b * (b2 / 255) + b * bright);
      
      rect(final_x, final_y, rect_size, rect_size);
    }
  }
  
  xmotion += 0.5;
  ymotion -= 0.25;
}

void setup() {
  size(800, 600);

  frameRate(60); 
  
  colormap = loadImage(""data.jpg"");
  funmap = loadImage(""data2.jpg"");
  nightmap = loadImage(""data_night.jpg"");
  cyclemap = loadImage(""data_cycle.jpg"");
  
  background(0);
}

void draw() {
  //background(0);
 
  draw_planet();
}"
"561193","Blue Planet Billboards","mySketch","/**
  * Same approach as dots planet billboard snippet with ""correct"" rendering this time by splitting the filled circle in half and inverting the second half,
  * dots density also increase as they are near the center (see comments in the code below) which improve the quality (altough making it blurry on the edge).
  * 
  */

PImage colormap;
PImage funmap;
PImage nightmap;
PImage cyclemap;

float xmotion = 0;
float ymotion = 0;

// quality control
int dots_step = 2;
int elems_step = 2;

// same but look below, these are adjusted in real-time to increase rendering quality by abusing motion blur :)
int elems = 292;
int rect_size = 12;

void draw_planet() {
  float mx = mouseX / 1024.0;
  float my = mouseY / 1024.0;
  
  elems_step = (int)(2.0 - mx * 1.0);
  dots_step = (int)(1.0 + my * 1.0);

  // add some motion blur / brightness
  fill(0, 0, 0, 4);
  rect(0, 0, 800, 600);
  
  // here we take advantage of the motion blur to ""fill in the gap"" by adjusting each slices / frames, this increase rendering quality (altough it look hazy)
  elems = (int)(92 + sin(xmotion / 24.) * 36);
  rect_size = (int)(2 + abs(sin(xmotion / 84.)) * 4);
  
  noStroke();
  
  float xoff = 800 / 2;
  
  float sphere_radius = 292;
  float yoff = 600 / 2 - sphere_radius;
  
  for (int s = 0; s < elems; s += elems_step) {
    float de = (float)s / elems;
    
    float bd = max((0.5-abs(de - 0.5)) * 4, 0.05);
    
    float yrepeat = 1;
    int yyd = (((int)(de * (colormap.height * yrepeat))%colormap.height)) * colormap.width;
    
    float tyrepeat = 4;
    int yyd2 = (((int)(de * (funmap.height * tyrepeat) + xmotion)%funmap.height)) * funmap.width;
    
    int yydc = (((int)(de * (cyclemap.height * yrepeat))%cyclemap.height)) * cyclemap.width;
    
    // cartesian circle equation
    float sphere_radius_squared = sphere_radius * sphere_radius;
    float sh_radius = de * (sphere_radius * 2) - sphere_radius;
    float xc_off = sqrt(sphere_radius_squared - sh_radius*sh_radius);
    
    float final_x;
    float final_y = yoff + de * (sphere_radius * 2); // flabby planet bonus : + sin((de * 360 + 180) * (PI / 180) + ymotion / 24.) * 4;
    
    for (int e = 0; e <= (int)xc_off / 2; e += dots_step) {
      float dd = (float)e / xc_off;

			// uncomment the code below to add the shrinking near the center (distributing the dots equality)
      final_x = xoff - (xc_off) + (xc_off /* / (dd+0.5)*/) * abs(0.5-(dd+0.5)) * 2 ;
      
      float yc_off;
      
      // compute UV texels for the colormap
      float dd2 = 1 - dd;
        
      yc_off = 1-sqrt(1 - dd2*dd2);
      
      // apply colormaps
      float xrepeat = 0.5;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + xmotion)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      // second texture (text mask)
      float txrepeat = 1.;
      
      int xxd2 = max(0, ((funmap.width - 1) - (int)(yc_off * (funmap.width * txrepeat) + xmotion)%funmap.width));
 
      int cl2 = (int)xxd2 + yyd2;
      
      int r2 = (int)(red(funmap.pixels[cl2]) * bd);
      int g2 = (int)(green(funmap.pixels[cl2]) * bd);
      int b2 = (int)(blue(funmap.pixels[cl2]) * bd);
      
      // third texture (night version), reuse the first texture UV since they are the same width/height
      int rn = (int)(red(nightmap.pixels[cl]));
      int gn = (int)(green(nightmap.pixels[cl]));
      int bn = (int)(blue(nightmap.pixels[cl]));
      
      // fourth texture (cycle mask), only use single component since it is black/white
      int xxdc = ((cyclemap.width - 1) - (int)(yc_off * (cyclemap.width * xrepeat) + xmotion * 4)%cyclemap.width);
      int clc = (int)xxdc + yydc;
      float rc = red(cyclemap.pixels[clc]) / 255;
      
      float final_r = r * rc + rn * (1 - rc);
      float final_g = g * rc + gn * (1 - rc);
      float final_b = b * rc + bn * (1 - rc);
      
      // some compositing 
      fill(r * (r2 / 255) + final_r, g * (g2 / 255) + final_g, b * (b2 / 255) + final_b);//r * (r2 / 255) + r * bright, g * (g2 / 255) + g * bright, b * (b2 / 255) + b * bright);
      
      rect(final_x, final_y, rect_size, rect_size);
    }
    
    for (int e = 0; e <= (int)xc_off / 2; e += dots_step) {
      float dd = (float)e / xc_off;

			// uncomment the code below to add the shrinking near the center (distributing the dots equality)
      final_x = xoff - (xc_off) + (xc_off-(xc_off/* / (dd+0.5)*/) * abs(0.5-(dd+0.5))) * 2;
      
      float yc_off;
      
      // compute UV texels for the colormap
      float dd2 = 1 - dd;
        
      yc_off = sqrt(1 - dd2*dd2) + 1.270;
      
      // apply colormaps
      float xrepeat = 0.5;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + xmotion)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      // second texture (text mask)
      float txrepeat = 1.;
      
      int xxd2 = max(0, ((funmap.width - 1) - (int)(yc_off * (funmap.width * txrepeat) + xmotion)%funmap.width));
 
      int cl2 = (int)xxd2 + yyd2;
      
      int r2 = (int)(red(funmap.pixels[cl2]) * bd);
      int g2 = (int)(green(funmap.pixels[cl2]) * bd);
      int b2 = (int)(blue(funmap.pixels[cl2]) * bd);
      
      // third texture (night version), reuse the first texture UV since they are the same width/height
      int rn = (int)(red(nightmap.pixels[cl]));
      int gn = (int)(green(nightmap.pixels[cl]));
      int bn = (int)(blue(nightmap.pixels[cl]));
      
      // fourth texture (cycle mask), only use single component since it is black/white
      int xxdc = ((cyclemap.width - 1) - (int)(yc_off * (cyclemap.width * xrepeat) + xmotion * 4)%cyclemap.width);
      int clc = (int)xxdc + yydc;
      float rc = red(cyclemap.pixels[clc]) / 255;
      
      float final_r = r * rc + rn * (1 - rc);
      float final_g = g  * rc + gn * (1 - rc);
      float final_b = b * rc + bn * (1 - rc);
      
      // some compositing 
      fill(r * (r2 / 255) + final_r, g * (g2 / 255) + final_g, b * (b2 / 255) + final_b);//r * (r2 / 255) + r * bright, g * (g2 / 255) + g * bright, b * (b2 / 255) + b * bright);
      
      rect(final_x, final_y, rect_size, rect_size);
    }
  }
  
  xmotion += 0.5;
  ymotion -= 0.25;
}

void setup() {
  size(800, 600);

  frameRate(60); 
  
  colormap = loadImage(""data.jpg"");
  funmap = loadImage(""data2.jpg"");
  nightmap = loadImage(""data_night.jpg"");
  cyclemap = loadImage(""data_cycle.jpg"");
  
  background(0);
}

void draw() {
  //background(0);
 
  draw_planet();
}"
"561193","Blue Planet Billboards","mySketch","/**
  * Same approach as dots planet billboard snippet with ""correct"" rendering this time by splitting the filled circle in half and inverting the second half,
  * dots density also increase as they are near the center (see comments in the code below) which improve the quality (altough making it blurry on the edge).
  * 
  */

PImage colormap;
PImage funmap;
PImage nightmap;
PImage cyclemap;

float xmotion = 0;
float ymotion = 0;

// quality control
int dots_step = 2;
int elems_step = 2;

// same but look below, these are adjusted in real-time to increase rendering quality by abusing motion blur :)
int elems = 292;
int rect_size = 12;

void draw_planet() {
  float mx = mouseX / 1024.0;
  float my = mouseY / 1024.0;
  
  elems_step = (int)(2.0 - mx * 1.0);
  dots_step = (int)(1.0 + my * 1.0);

  // add some motion blur / brightness
  fill(0, 0, 0, 4);
  rect(0, 0, 800, 600);
  
  // here we take advantage of the motion blur to ""fill in the gap"" by adjusting each slices / frames, this increase rendering quality (altough it look hazy)
  elems = (int)(92 + sin(xmotion / 24.) * 36);
  rect_size = (int)(2 + abs(sin(xmotion / 84.)) * 4);
  
  noStroke();
  
  float xoff = 800 / 2;
  
  float sphere_radius = 292;
  float yoff = 600 / 2 - sphere_radius;
  
  for (int s = 0; s < elems; s += elems_step) {
    float de = (float)s / elems;
    
    float bd = max((0.5-abs(de - 0.5)) * 4, 0.05);
    
    float yrepeat = 1;
    int yyd = (((int)(de * (colormap.height * yrepeat))%colormap.height)) * colormap.width;
    
    float tyrepeat = 4;
    int yyd2 = (((int)(de * (funmap.height * tyrepeat) + xmotion)%funmap.height)) * funmap.width;
    
    int yydc = (((int)(de * (cyclemap.height * yrepeat))%cyclemap.height)) * cyclemap.width;
    
    // cartesian circle equation
    float sphere_radius_squared = sphere_radius * sphere_radius;
    float sh_radius = de * (sphere_radius * 2) - sphere_radius;
    float xc_off = sqrt(sphere_radius_squared - sh_radius*sh_radius);
    
    float final_x;
    float final_y = yoff + de * (sphere_radius * 2); // flabby planet bonus : + sin((de * 360 + 180) * (PI / 180) + ymotion / 24.) * 4;
    
    for (int e = 0; e <= (int)xc_off / 2; e += dots_step) {
      float dd = (float)e / xc_off;

			// uncomment the code below to add the shrinking near the center (distributing the dots equality)
      final_x = xoff - (xc_off) + (xc_off /* / (dd+0.5)*/) * abs(0.5-(dd+0.5)) * 2 ;
      
      float yc_off;
      
      // compute UV texels for the colormap
      float dd2 = 1 - dd;
        
      yc_off = 1-sqrt(1 - dd2*dd2);
      
      // apply colormaps
      float xrepeat = 0.5;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + xmotion)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      // second texture (text mask)
      float txrepeat = 1.;
      
      int xxd2 = max(0, ((funmap.width - 1) - (int)(yc_off * (funmap.width * txrepeat) + xmotion)%funmap.width));
 
      int cl2 = (int)xxd2 + yyd2;
      
      int r2 = (int)(red(funmap.pixels[cl2]) * bd);
      int g2 = (int)(green(funmap.pixels[cl2]) * bd);
      int b2 = (int)(blue(funmap.pixels[cl2]) * bd);
      
      // third texture (night version), reuse the first texture UV since they are the same width/height
      int rn = (int)(red(nightmap.pixels[cl]));
      int gn = (int)(green(nightmap.pixels[cl]));
      int bn = (int)(blue(nightmap.pixels[cl]));
      
      // fourth texture (cycle mask), only use single component since it is black/white
      int xxdc = ((cyclemap.width - 1) - (int)(yc_off * (cyclemap.width * xrepeat) + xmotion * 4)%cyclemap.width);
      int clc = (int)xxdc + yydc;
      float rc = red(cyclemap.pixels[clc]) / 255;
      
      float final_r = r * rc + rn * (1 - rc);
      float final_g = g * rc + gn * (1 - rc);
      float final_b = b * rc + bn * (1 - rc);
      
      // some compositing 
      fill(r * (r2 / 255) + final_r, g * (g2 / 255) + final_g, b * (b2 / 255) + final_b);//r * (r2 / 255) + r * bright, g * (g2 / 255) + g * bright, b * (b2 / 255) + b * bright);
      
      rect(final_x, final_y, rect_size, rect_size);
    }
    
    for (int e = 0; e <= (int)xc_off / 2; e += dots_step) {
      float dd = (float)e / xc_off;

			// uncomment the code below to add the shrinking near the center (distributing the dots equality)
      final_x = xoff - (xc_off) + (xc_off-(xc_off/* / (dd+0.5)*/) * abs(0.5-(dd+0.5))) * 2;
      
      float yc_off;
      
      // compute UV texels for the colormap
      float dd2 = 1 - dd;
        
      yc_off = sqrt(1 - dd2*dd2) + 1.270;
      
      // apply colormaps
      float xrepeat = 0.5;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + xmotion)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      // second texture (text mask)
      float txrepeat = 1.;
      
      int xxd2 = max(0, ((funmap.width - 1) - (int)(yc_off * (funmap.width * txrepeat) + xmotion)%funmap.width));
 
      int cl2 = (int)xxd2 + yyd2;
      
      int r2 = (int)(red(funmap.pixels[cl2]) * bd);
      int g2 = (int)(green(funmap.pixels[cl2]) * bd);
      int b2 = (int)(blue(funmap.pixels[cl2]) * bd);
      
      // third texture (night version), reuse the first texture UV since they are the same width/height
      int rn = (int)(red(nightmap.pixels[cl]));
      int gn = (int)(green(nightmap.pixels[cl]));
      int bn = (int)(blue(nightmap.pixels[cl]));
      
      // fourth texture (cycle mask), only use single component since it is black/white
      int xxdc = ((cyclemap.width - 1) - (int)(yc_off * (cyclemap.width * xrepeat) + xmotion * 4)%cyclemap.width);
      int clc = (int)xxdc + yydc;
      float rc = red(cyclemap.pixels[clc]) / 255;
      
      float final_r = r * rc + rn * (1 - rc);
      float final_g = g  * rc + gn * (1 - rc);
      float final_b = b * rc + bn * (1 - rc);
      
      // some compositing 
      fill(r * (r2 / 255) + final_r, g * (g2 / 255) + final_g, b * (b2 / 255) + final_b);//r * (r2 / 255) + r * bright, g * (g2 / 255) + g * bright, b * (b2 / 255) + b * bright);
      
      rect(final_x, final_y, rect_size, rect_size);
    }
  }
  
  xmotion += 0.5;
  ymotion -= 0.25;
}

void setup() {
  size(800, 600);

  frameRate(60); 
  
  colormap = loadImage(""data.jpg"");
  funmap = loadImage(""data2.jpg"");
  nightmap = loadImage(""data_night.jpg"");
  cyclemap = loadImage(""data_cycle.jpg"");
  
  background(0);
}

void draw() {
  //background(0);
 
  draw_planet();
}"
"561193","Blue Planet Billboards","mySketch","/**
  * Same approach as dots planet billboard snippet with ""correct"" rendering this time by splitting the filled circle in half and inverting the second half,
  * dots density can also increase as they are near the center (see comments in the code below) which improve the quality (altough making it blurry on the edge).
  * There is one issue with gaps in the middle which can be fixed by drawing a rectangle a little bit above and below each time.
  */

PImage colormap;
PImage funmap;
PImage nightmap;
PImage cyclemap;

float xmotion = 0;
float ymotion = 0;

// quality control
int dots_step = 2;
int elems_step = 2;

// same but look below, these are adjusted in real-time to increase rendering quality by abusing motion blur :)
int elems = 292;
int rect_size = 12;

void draw_planet() {
  float mx = mouseX / 1024.0;
  float my = mouseY / 1024.0;
  
  elems_step = (int)(2.0 - mx * 1.0);
  dots_step = (int)(1.0 + my * 1.0);

  // add some motion blur / brightness
  fill(0, 0, 0, 4);
  rect(0, 0, 800, 600);
  
  // here we take advantage of the motion blur to ""fill in the gap"" by adjusting each slices / frames, this increase rendering quality (altough it look hazy)
  elems = (int)(92 + sin(xmotion / 24.) * 36);
  rect_size = (int)(2 + abs(sin(xmotion / 84.)) * 4);
  
  noStroke();
  
  float xoff = 800 / 2;
  
  float sphere_radius = 292;
  float yoff = 600 / 2 - sphere_radius;
  
  for (int s = 0; s < elems; s += elems_step) {
    float de = (float)s / elems;
    
    float bd = max((0.5-abs(de - 0.5)) * 4, 0.05);
    
    float yrepeat = 1;
    int yyd = (((int)(de * (colormap.height * yrepeat))%colormap.height)) * colormap.width;
    
    float tyrepeat = 4;
    int yyd2 = (((int)(de * (funmap.height * tyrepeat) + xmotion)%funmap.height)) * funmap.width;
    
    int yydc = (((int)(de * (cyclemap.height * yrepeat))%cyclemap.height)) * cyclemap.width;
    
    // cartesian circle equation
    float sphere_radius_squared = sphere_radius * sphere_radius;
    float sh_radius = de * (sphere_radius * 2) - sphere_radius;
    float xc_off = sqrt(sphere_radius_squared - sh_radius*sh_radius);
    
    float final_x;
    float final_y = yoff + de * (sphere_radius * 2); // flabby planet bonus : + sin((de * 360 + 180) * (PI / 180) + ymotion / 24.) * 4;
    
    for (int e = 0; e <= (int)xc_off / 2; e += dots_step) {
      float dd = (float)e / xc_off;

			// uncomment the code below to add the shrinking near the center (distributing the dots equality)
      final_x = xoff - (xc_off) + (xc_off /* / (dd+0.5)*/) * abs(0.5-(dd+0.5)) * 2 ;
      
      float yc_off;
      
      // compute UV texels for the colormap
      float dd2 = 1 - dd;
        
      yc_off = 1-sqrt(1 - dd2*dd2);
      
      // apply colormaps
      float xrepeat = 0.5;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + xmotion)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      // second texture (text mask)
      float txrepeat = 1.;
      
      int xxd2 = max(0, ((funmap.width - 1) - (int)(yc_off * (funmap.width * txrepeat) + xmotion)%funmap.width));
 
      int cl2 = (int)xxd2 + yyd2;
      
      int r2 = (int)(red(funmap.pixels[cl2]) * bd);
      int g2 = (int)(green(funmap.pixels[cl2]) * bd);
      int b2 = (int)(blue(funmap.pixels[cl2]) * bd);
      
      // third texture (night version), reuse the first texture UV since they are the same width/height
      int rn = (int)(red(nightmap.pixels[cl]));
      int gn = (int)(green(nightmap.pixels[cl]));
      int bn = (int)(blue(nightmap.pixels[cl]));
      
      // fourth texture (cycle mask), only use single component since it is black/white
      int xxdc = ((cyclemap.width - 1) - (int)(yc_off * (cyclemap.width * xrepeat) + xmotion * 4)%cyclemap.width);
      int clc = (int)xxdc + yydc;
      float rc = red(cyclemap.pixels[clc]) / 255;
      
      float final_r = r * rc + rn * (1 - rc);
      float final_g = g * rc + gn * (1 - rc);
      float final_b = b * rc + bn * (1 - rc);
      
      // some compositing 
      fill(r * (r2 / 255) + final_r, g * (g2 / 255) + final_g, b * (b2 / 255) + final_b);//r * (r2 / 255) + r * bright, g * (g2 / 255) + g * bright, b * (b2 / 255) + b * bright);
      
      rect(final_x, final_y, rect_size, rect_size);
    }
    
    for (int e = 0; e <= (int)xc_off / 2; e += dots_step) {
      float dd = (float)e / xc_off;

			// uncomment the code below to add the shrinking near the center (distributing the dots equality)
      final_x = xoff - (xc_off) + (xc_off-(xc_off/* / (dd+0.5)*/) * abs(0.5-(dd+0.5))) * 2;
      
      float yc_off;
      
      // compute UV texels for the colormap
      float dd2 = 1 - dd;
        
      yc_off = sqrt(1 - dd2*dd2) + 1.270;
      
      // apply colormaps
      float xrepeat = 0.5;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + xmotion)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      // second texture (text mask)
      float txrepeat = 1.;
      
      int xxd2 = max(0, ((funmap.width - 1) - (int)(yc_off * (funmap.width * txrepeat) + xmotion)%funmap.width));
 
      int cl2 = (int)xxd2 + yyd2;
      
      int r2 = (int)(red(funmap.pixels[cl2]) * bd);
      int g2 = (int)(green(funmap.pixels[cl2]) * bd);
      int b2 = (int)(blue(funmap.pixels[cl2]) * bd);
      
      // third texture (night version), reuse the first texture UV since they are the same width/height
      int rn = (int)(red(nightmap.pixels[cl]));
      int gn = (int)(green(nightmap.pixels[cl]));
      int bn = (int)(blue(nightmap.pixels[cl]));
      
      // fourth texture (cycle mask), only use single component since it is black/white
      int xxdc = ((cyclemap.width - 1) - (int)(yc_off * (cyclemap.width * xrepeat) + xmotion * 4)%cyclemap.width);
      int clc = (int)xxdc + yydc;
      float rc = red(cyclemap.pixels[clc]) / 255;
      
      float final_r = r * rc + rn * (1 - rc);
      float final_g = g  * rc + gn * (1 - rc);
      float final_b = b * rc + bn * (1 - rc);
      
      // some compositing 
      fill(r * (r2 / 255) + final_r, g * (g2 / 255) + final_g, b * (b2 / 255) + final_b);//r * (r2 / 255) + r * bright, g * (g2 / 255) + g * bright, b * (b2 / 255) + b * bright);
      
      rect(final_x, final_y, rect_size, rect_size);
    }
  }
  
  xmotion += 0.5;
  ymotion -= 0.25;
}

void setup() {
  size(800, 600);

  frameRate(60); 
  
  colormap = loadImage(""data.jpg"");
  funmap = loadImage(""data2.jpg"");
  nightmap = loadImage(""data_night.jpg"");
  cyclemap = loadImage(""data_cycle.jpg"");
  
  background(0);
}

void draw() {
  //background(0);
 
  draw_planet();
}"
"561193","Blue Planet Billboards","mySketch","/**
  * Same approach as dots planet billboard snippet with ""correct"" rendering this time by splitting the filled circle in half and inverting the second half
  * There is one issue with gaps in the middle which if let as-is, it is fixed by increasing the dot density as they approach the center, this however make the edges more blurry.
  */

PImage colormap;
PImage funmap;
PImage nightmap;
PImage cyclemap;

float xmotion = 0;
float ymotion = 0;

// quality control
int dots_step = 2;
int elems_step = 2;

// same but look below, these are adjusted in real-time to increase rendering quality by abusing motion blur :)
int elems = 292;
int rect_size = 12;

void draw_planet() {
  float mx = mouseX / 1024.0;
  float my = mouseY / 1024.0;
  
  elems_step = (int)(2.0 - mx * 1.0);
  dots_step = (int)(1.0 + my * 1.0);

  // add some motion blur / brightness
  fill(0, 0, 0, 4);
  rect(0, 0, 800, 600);
  
  // here we take advantage of the motion blur to ""fill in the gap"" by adjusting each slices / frames, this increase rendering quality (altough it look hazy)
  elems = (int)(92 + sin(xmotion / 24.) * 36);
  rect_size = (int)(2 + abs(sin(xmotion / 84.)) * 4);
  
  noStroke();
  
  float xoff = 800 / 2;
  
  float sphere_radius = 292;
  float yoff = 600 / 2 - sphere_radius;
  
  for (int s = 0; s < elems; s += elems_step) {
    float de = (float)s / elems;
    
    float bd = max((0.5-abs(de - 0.5)) * 4, 0.05);
    
    float yrepeat = 1;
    int yyd = (((int)(de * (colormap.height * yrepeat))%colormap.height)) * colormap.width;
    
    float tyrepeat = 4;
    int yyd2 = (((int)(de * (funmap.height * tyrepeat) + xmotion)%funmap.height)) * funmap.width;
    
    int yydc = (((int)(de * (cyclemap.height * yrepeat))%cyclemap.height)) * cyclemap.width;
    
    // cartesian circle equation
    float sphere_radius_squared = sphere_radius * sphere_radius;
    float sh_radius = de * (sphere_radius * 2) - sphere_radius;
    float xc_off = sqrt(sphere_radius_squared - sh_radius*sh_radius);
    
    float final_x;
    float final_y = yoff + de * (sphere_radius * 2); // flabby planet bonus : + sin((de * 360 + 180) * (PI / 180) + ymotion / 24.) * 4;
    
    for (int e = 0; e <= (int)xc_off / 2; e += dots_step) {
      float dd = (float)e / xc_off;

			// / (dd+0.5) : shrinking near the center (otherwise : equal distribution of the dots)
      final_x = xoff - (xc_off) + (xc_off / (dd+0.5)) * abs(0.5-(dd+0.5)) * 2 ;
      
      float yc_off;
      
      // compute UV texels for the colormap
      float dd2 = 1 - dd;
        
      yc_off = 1-sqrt(1 - dd2*dd2);
      
      // apply colormaps
      float xrepeat = 0.5;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + xmotion)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      // second texture (text mask)
      float txrepeat = 1.;
      
      int xxd2 = max(0, ((funmap.width - 1) - (int)(yc_off * (funmap.width * txrepeat) + xmotion)%funmap.width));
 
      int cl2 = (int)xxd2 + yyd2;
      
      int r2 = (int)(red(funmap.pixels[cl2]) * bd);
      int g2 = (int)(green(funmap.pixels[cl2]) * bd);
      int b2 = (int)(blue(funmap.pixels[cl2]) * bd);
      
      // third texture (night version), reuse the first texture UV since they are the same width/height
      int rn = (int)(red(nightmap.pixels[cl]));
      int gn = (int)(green(nightmap.pixels[cl]));
      int bn = (int)(blue(nightmap.pixels[cl]));
      
      // fourth texture (cycle mask), only use single component since it is black/white
      int xxdc = ((cyclemap.width - 1) - (int)(yc_off * (cyclemap.width * xrepeat) + xmotion * 4)%cyclemap.width);
      int clc = (int)xxdc + yydc;
      float rc = red(cyclemap.pixels[clc]) / 255;
      
      float final_r = r * rc + rn * (1 - rc);
      float final_g = g * rc + gn * (1 - rc);
      float final_b = b * rc + bn * (1 - rc);
      
      // some compositing 
      fill(r * (r2 / 255) + final_r, g * (g2 / 255) + final_g, b * (b2 / 255) + final_b);//r * (r2 / 255) + r * bright, g * (g2 / 255) + g * bright, b * (b2 / 255) + b * bright);
      
      rect(final_x, final_y, rect_size, rect_size);
    }
    
    for (int e = 0; e <= (int)xc_off / 2; e += dots_step) {
      float dd = (float)e / xc_off;

      final_x = xoff - (xc_off) + (xc_off-(xc_off / (dd+0.5)) * abs(0.5-(dd+0.5))) * 2;
      
      float yc_off;
      
      // compute UV texels for the colormap
      float dd2 = 1 - dd;
        
      yc_off = sqrt(1 - dd2*dd2) + 1.270;
      
      // apply colormaps
      float xrepeat = 0.5;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + xmotion)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      // second texture (text mask)
      float txrepeat = 1.;
      
      int xxd2 = max(0, ((funmap.width - 1) - (int)(yc_off * (funmap.width * txrepeat) + xmotion)%funmap.width));
 
      int cl2 = (int)xxd2 + yyd2;
      
      int r2 = (int)(red(funmap.pixels[cl2]) * bd);
      int g2 = (int)(green(funmap.pixels[cl2]) * bd);
      int b2 = (int)(blue(funmap.pixels[cl2]) * bd);
      
      // third texture (night version), reuse the first texture UV since they are the same width/height
      int rn = (int)(red(nightmap.pixels[cl]));
      int gn = (int)(green(nightmap.pixels[cl]));
      int bn = (int)(blue(nightmap.pixels[cl]));
      
      // fourth texture (cycle mask), only use single component since it is black/white
      int xxdc = ((cyclemap.width - 1) - (int)(yc_off * (cyclemap.width * xrepeat) + xmotion * 4)%cyclemap.width);
      int clc = (int)xxdc + yydc;
      float rc = red(cyclemap.pixels[clc]) / 255;
      
      float final_r = r * rc + rn * (1 - rc);
      float final_g = g  * rc + gn * (1 - rc);
      float final_b = b * rc + bn * (1 - rc);
      
      // some compositing 
      fill(r * (r2 / 255) + final_r, g * (g2 / 255) + final_g, b * (b2 / 255) + final_b);//r * (r2 / 255) + r * bright, g * (g2 / 255) + g * bright, b * (b2 / 255) + b * bright);
      
      rect(final_x, final_y, rect_size, rect_size);
    }
  }
  
  xmotion += 0.5;
  ymotion -= 0.25;
}

void setup() {
  size(800, 600);

  frameRate(60); 
  
  colormap = loadImage(""data.jpg"");
  funmap = loadImage(""data2.jpg"");
  nightmap = loadImage(""data_night.jpg"");
  cyclemap = loadImage(""data_cycle.jpg"");
  
  background(0);
}

void draw() {
  //background(0);
 
  draw_planet();
}"
"561193","Blue Planet Billboards","mySketch","/**
  * Same approach as dots planet billboard snippet with ""correct"" rendering this time by splitting the filled circle in half and inverting the second half
  * There is one issue with gaps in the middle if let as-is, it is fixed by increasing the dot density as they approach the center, this however make the edges more blurry.
  */

PImage colormap;
PImage funmap;
PImage nightmap;
PImage cyclemap;

float xmotion = 0;
float ymotion = 0;

// quality control
int dots_step = 2;
int elems_step = 2;

// same but look below, these are adjusted in real-time to increase rendering quality by abusing motion blur :)
int elems = 292;
int rect_size = 12;

void draw_planet() {
  float mx = mouseX / 1024.0;
  float my = mouseY / 1024.0;
  
  elems_step = (int)(2.0 - mx * 1.0);
  dots_step = (int)(1.0 + my * 1.0);

  // add some motion blur / brightness
  fill(0, 0, 0, 4);
  rect(0, 0, 800, 600);
  
  // here we take advantage of the motion blur to ""fill in the gap"" by adjusting each slices / frames, this increase rendering quality (altough it look hazy)
  elems = (int)(92 + sin(xmotion / 24.) * 36);
  rect_size = (int)(2 + abs(sin(xmotion / 84.)) * 4);
  
  noStroke();
  
  float xoff = 800 / 2;
  
  float sphere_radius = 292;
  float yoff = 600 / 2 - sphere_radius;
  
  for (int s = 0; s < elems; s += elems_step) {
    float de = (float)s / elems;
    
    float bd = max((0.5-abs(de - 0.5)) * 4, 0.05);
    
    float yrepeat = 1;
    int yyd = (((int)(de * (colormap.height * yrepeat))%colormap.height)) * colormap.width;
    
    float tyrepeat = 4;
    int yyd2 = (((int)(de * (funmap.height * tyrepeat) + xmotion)%funmap.height)) * funmap.width;
    
    int yydc = (((int)(de * (cyclemap.height * yrepeat))%cyclemap.height)) * cyclemap.width;
    
    // cartesian circle equation
    float sphere_radius_squared = sphere_radius * sphere_radius;
    float sh_radius = de * (sphere_radius * 2) - sphere_radius;
    float xc_off = sqrt(sphere_radius_squared - sh_radius*sh_radius);
    
    float final_x;
    float final_y = yoff + de * (sphere_radius * 2); // flabby planet bonus : + sin((de * 360 + 180) * (PI / 180) + ymotion / 24.) * 4;
    
    for (int e = 0; e <= (int)xc_off / 2; e += dots_step) {
      float dd = (float)e / xc_off;

			// / (dd+0.5) : shrinking near the center (otherwise : equal distribution of the dots)
      final_x = xoff - (xc_off) + (xc_off / (dd+0.5)) * abs(0.5-(dd+0.5)) * 2 ;
      
      float yc_off;
      
      // compute UV texels for the colormap
      float dd2 = 1 - dd;
        
      yc_off = 1-sqrt(1 - dd2*dd2);
      
      // apply colormaps
      float xrepeat = 0.5;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + xmotion)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      // second texture (text mask)
      float txrepeat = 1.;
      
      int xxd2 = max(0, ((funmap.width - 1) - (int)(yc_off * (funmap.width * txrepeat) + xmotion)%funmap.width));
 
      int cl2 = (int)xxd2 + yyd2;
      
      int r2 = (int)(red(funmap.pixels[cl2]) * bd);
      int g2 = (int)(green(funmap.pixels[cl2]) * bd);
      int b2 = (int)(blue(funmap.pixels[cl2]) * bd);
      
      // third texture (night version), reuse the first texture UV since they are the same width/height
      int rn = (int)(red(nightmap.pixels[cl]));
      int gn = (int)(green(nightmap.pixels[cl]));
      int bn = (int)(blue(nightmap.pixels[cl]));
      
      // fourth texture (cycle mask), only use single component since it is black/white
      int xxdc = ((cyclemap.width - 1) - (int)(yc_off * (cyclemap.width * xrepeat) + xmotion * 4)%cyclemap.width);
      int clc = (int)xxdc + yydc;
      float rc = red(cyclemap.pixels[clc]) / 255;
      
      float final_r = r * rc + rn * (1 - rc);
      float final_g = g * rc + gn * (1 - rc);
      float final_b = b * rc + bn * (1 - rc);
      
      // some compositing 
      fill(r * (r2 / 255) + final_r, g * (g2 / 255) + final_g, b * (b2 / 255) + final_b);//r * (r2 / 255) + r * bright, g * (g2 / 255) + g * bright, b * (b2 / 255) + b * bright);
      
      rect(final_x, final_y, rect_size, rect_size);
    }
    
    for (int e = 0; e <= (int)xc_off / 2; e += dots_step) {
      float dd = (float)e / xc_off;

      final_x = xoff - (xc_off) + (xc_off-(xc_off / (dd+0.5)) * abs(0.5-(dd+0.5))) * 2;
      
      float yc_off;
      
      // compute UV texels for the colormap
      float dd2 = 1 - dd;
        
      yc_off = sqrt(1 - dd2*dd2) + 1.270;
      
      // apply colormaps
      float xrepeat = 0.5;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + xmotion)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      // second texture (text mask)
      float txrepeat = 1.;
      
      int xxd2 = max(0, ((funmap.width - 1) - (int)(yc_off * (funmap.width * txrepeat) + xmotion)%funmap.width));
 
      int cl2 = (int)xxd2 + yyd2;
      
      int r2 = (int)(red(funmap.pixels[cl2]) * bd);
      int g2 = (int)(green(funmap.pixels[cl2]) * bd);
      int b2 = (int)(blue(funmap.pixels[cl2]) * bd);
      
      // third texture (night version), reuse the first texture UV since they are the same width/height
      int rn = (int)(red(nightmap.pixels[cl]));
      int gn = (int)(green(nightmap.pixels[cl]));
      int bn = (int)(blue(nightmap.pixels[cl]));
      
      // fourth texture (cycle mask), only use single component since it is black/white
      int xxdc = ((cyclemap.width - 1) - (int)(yc_off * (cyclemap.width * xrepeat) + xmotion * 4)%cyclemap.width);
      int clc = (int)xxdc + yydc;
      float rc = red(cyclemap.pixels[clc]) / 255;
      
      float final_r = r * rc + rn * (1 - rc);
      float final_g = g  * rc + gn * (1 - rc);
      float final_b = b * rc + bn * (1 - rc);
      
      // some compositing 
      fill(r * (r2 / 255) + final_r, g * (g2 / 255) + final_g, b * (b2 / 255) + final_b);//r * (r2 / 255) + r * bright, g * (g2 / 255) + g * bright, b * (b2 / 255) + b * bright);
      
      rect(final_x, final_y, rect_size, rect_size);
    }
  }
  
  xmotion += 0.5;
  ymotion -= 0.25;
}

void setup() {
  size(800, 600);

  frameRate(60); 
  
  colormap = loadImage(""data.jpg"");
  funmap = loadImage(""data2.jpg"");
  nightmap = loadImage(""data_night.jpg"");
  cyclemap = loadImage(""data_cycle.jpg"");
  
  background(0);
}

void draw() {
  //background(0);
 
  draw_planet();
}"
"561193","Blue Planet Billboards","mySketch","/**
  * Same approach as dots planet billboard snippet with ""correct"" rendering this time by splitting the filled circle in half and inverting the second half
  * There is one issue with gaps in the middle if let as-is, it is fixed by increasing the dot density as they approach the center, this however make the edges more blurry.
	*
	* One can use quad (by computing next x,y point) instead of rect at x,y to avoid gaps as well or use lines, this also increase quality.
  */

PImage colormap;
PImage funmap;
PImage nightmap;
PImage cyclemap;

float xmotion = 0;
float ymotion = 0;

// quality control
int dots_step = 2;
int elems_step = 2;

// same but look below, these are adjusted in real-time to increase rendering quality by abusing motion blur :)
int elems = 292;
int rect_size = 12;

void draw_planet() {
  float mx = mouseX / 1024.0;
  float my = mouseY / 1024.0;
  
  elems_step = (int)(2.0 - mx * 1.0);
  dots_step = (int)(1.0 + my * 1.0);

  // add some motion blur / brightness
  fill(0, 0, 0, 4);
  rect(0, 0, 800, 600);
  
  // here we take advantage of the motion blur to ""fill in the gap"" by adjusting each slices / frames, this increase rendering quality (altough it look hazy)
  elems = (int)(92 + sin(xmotion / 24.) * 36);
  rect_size = (int)(2 + abs(sin(xmotion / 84.)) * 4);
  
  noStroke();
  
  float xoff = 800 / 2;
  
  float sphere_radius = 292;
  float yoff = 600 / 2 - sphere_radius;
  
  for (int s = 0; s < elems; s += elems_step) {
    float de = (float)s / elems;
    
    float bd = max((0.5-abs(de - 0.5)) * 4, 0.05);
    
    float yrepeat = 1;
    int yyd = (((int)(de * (colormap.height * yrepeat))%colormap.height)) * colormap.width;
    
    float tyrepeat = 4;
    int yyd2 = (((int)(de * (funmap.height * tyrepeat) + xmotion)%funmap.height)) * funmap.width;
    
    int yydc = (((int)(de * (cyclemap.height * yrepeat))%cyclemap.height)) * cyclemap.width;
    
    // cartesian circle equation
    float sphere_radius_squared = sphere_radius * sphere_radius;
    float sh_radius = de * (sphere_radius * 2) - sphere_radius;
    float xc_off = sqrt(sphere_radius_squared - sh_radius*sh_radius);
    
    float final_x;
    float final_y = yoff + de * (sphere_radius * 2); // flabby planet bonus : + sin((de * 360 + 180) * (PI / 180) + ymotion / 24.) * 4;
    
    for (int e = 0; e <= (int)xc_off / 2; e += dots_step) {
      float dd = (float)e / xc_off;

			// / (dd+0.5) : shrinking near the center (otherwise : equal distribution of the dots)
      final_x = xoff - (xc_off) + (xc_off / (dd+0.5)) * abs(0.5-(dd+0.5)) * 2 ;
      
      float yc_off;
      
      // compute UV texels for the colormap
      float dd2 = 1 - dd;
        
      yc_off = 1-sqrt(1 - dd2*dd2);
      
      // apply colormaps
      float xrepeat = 0.5;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + xmotion)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      // second texture (text mask)
      float txrepeat = 1.;
      
      int xxd2 = max(0, ((funmap.width - 1) - (int)(yc_off * (funmap.width * txrepeat) + xmotion)%funmap.width));
 
      int cl2 = (int)xxd2 + yyd2;
      
      int r2 = (int)(red(funmap.pixels[cl2]) * bd);
      int g2 = (int)(green(funmap.pixels[cl2]) * bd);
      int b2 = (int)(blue(funmap.pixels[cl2]) * bd);
      
      // third texture (night version), reuse the first texture UV since they are the same width/height
      int rn = (int)(red(nightmap.pixels[cl]));
      int gn = (int)(green(nightmap.pixels[cl]));
      int bn = (int)(blue(nightmap.pixels[cl]));
      
      // fourth texture (cycle mask), only use single component since it is black/white
      int xxdc = ((cyclemap.width - 1) - (int)(yc_off * (cyclemap.width * xrepeat) + xmotion * 4)%cyclemap.width);
      int clc = (int)xxdc + yydc;
      float rc = red(cyclemap.pixels[clc]) / 255;
      
      float final_r = r * rc + rn * (1 - rc);
      float final_g = g * rc + gn * (1 - rc);
      float final_b = b * rc + bn * (1 - rc);
      
      // some compositing 
      fill(r * (r2 / 255) + final_r, g * (g2 / 255) + final_g, b * (b2 / 255) + final_b);//r * (r2 / 255) + r * bright, g * (g2 / 255) + g * bright, b * (b2 / 255) + b * bright);
      
      rect(final_x, final_y, rect_size, rect_size);
    }
    
    for (int e = 0; e <= (int)xc_off / 2; e += dots_step) {
      float dd = (float)e / xc_off;

      final_x = xoff - (xc_off) + (xc_off-(xc_off / (dd+0.5)) * abs(0.5-(dd+0.5))) * 2;
      
      float yc_off;
      
      // compute UV texels for the colormap
      float dd2 = 1 - dd;
        
      yc_off = sqrt(1 - dd2*dd2) + 1.270;
      
      // apply colormaps
      float xrepeat = 0.5;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + xmotion)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      // second texture (text mask)
      float txrepeat = 1.;
      
      int xxd2 = max(0, ((funmap.width - 1) - (int)(yc_off * (funmap.width * txrepeat) + xmotion)%funmap.width));
 
      int cl2 = (int)xxd2 + yyd2;
      
      int r2 = (int)(red(funmap.pixels[cl2]) * bd);
      int g2 = (int)(green(funmap.pixels[cl2]) * bd);
      int b2 = (int)(blue(funmap.pixels[cl2]) * bd);
      
      // third texture (night version), reuse the first texture UV since they are the same width/height
      int rn = (int)(red(nightmap.pixels[cl]));
      int gn = (int)(green(nightmap.pixels[cl]));
      int bn = (int)(blue(nightmap.pixels[cl]));
      
      // fourth texture (cycle mask), only use single component since it is black/white
      int xxdc = ((cyclemap.width - 1) - (int)(yc_off * (cyclemap.width * xrepeat) + xmotion * 4)%cyclemap.width);
      int clc = (int)xxdc + yydc;
      float rc = red(cyclemap.pixels[clc]) / 255;
      
      float final_r = r * rc + rn * (1 - rc);
      float final_g = g  * rc + gn * (1 - rc);
      float final_b = b * rc + bn * (1 - rc);
      
      // some compositing 
      fill(r * (r2 / 255) + final_r, g * (g2 / 255) + final_g, b * (b2 / 255) + final_b);//r * (r2 / 255) + r * bright, g * (g2 / 255) + g * bright, b * (b2 / 255) + b * bright);
      
      rect(final_x, final_y, rect_size, rect_size);
    }
  }
  
  xmotion += 0.5;
  ymotion -= 0.25;
}

void setup() {
  size(800, 600);

  frameRate(60); 
  
  colormap = loadImage(""data.jpg"");
  funmap = loadImage(""data2.jpg"");
  nightmap = loadImage(""data_night.jpg"");
  cyclemap = loadImage(""data_cycle.jpg"");
  
  background(0);
}

void draw() {
  //background(0);
 
  draw_planet();
}"
"561095","Disco ball","mySketch","/**
  * Cheap pseudo 3D disco ball with billboard like text, same tech as ""earth"" snippet
  */

PImage colormap;
PImage funmap;

float xmotion = 0;
float ymotion = 0;

// quality control
int dots_step = 8;
int elems_step = 8;

int elems = 192;
int rect_size = 8;

void draw_planet() {
  float mx = mouseX / 1024.0;
	float my = mouseY / 1024.0;
	
	elems_step = 3;
	dots_step = 1;

  // add some motion blur / brightness
  fill(0, 0, 0, 4);
  rect(0, 0, 800, 600);
	
  noStroke();
  
  float xoff = 800 / 2;
  
  float sphere_radius = 292;
  float yoff = 600 / 2 - sphere_radius;
  
  for (int s = 0; s < elems; s += elems_step) {
    float de = (float)s / elems;
    
    float bd = max((0.5-abs(de - 0.5)) * 4, 0.05);
    
    float yrepeat = 0.25;
    int yyd = (((int)(de * (colormap.height * yrepeat))%colormap.height)) * colormap.width;
		
		float tyrepeat = 4;
		int yyd2 = (((int)(de * (funmap.height * tyrepeat) + sin(ymotion * 2 * de) * 12)%funmap.height)) * funmap.width;
		
    // cartesian circle equation
    float sphere_radius_squared = sphere_radius * sphere_radius;
    float sh_radius = de * (sphere_radius * 2) - sphere_radius;
    float xc_off = sqrt(sphere_radius_squared - sh_radius*sh_radius);
    
    float final_x;
    float final_y = yoff + de * (sphere_radius * 2); // flabby planet bonus : + sin((de * 360 + 180) * (PI / 180) + ymotion / 24.) * 4;
    
    for (int e = 0; e < (int)xc_off; e += dots_step) {
      float dd = (float)e / xc_off;

      final_x = xoff - xc_off + xc_off * dd * 2; // flabby planet bonus : + cos((de * 360 + 180) * (PI / 180) + xmotion / 24.) * 4
      
      float yc_off;
      
      // compute UV texels for the colormap
      if (dd > 0.5) {
        yc_off = sqrt(1 - dd*dd) + 1.270;
      } else {
        float dd2 = 1 - dd;
        
        yc_off = 1-sqrt(1 - dd2*dd2);
      }
      
      // apply colormaps
      float xrepeat = 0.25;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) - xmotion*2)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      // second texture (text mask)
      float txrepeat = 1.0;
      
      int xxd2 = ((funmap.width - 1) - (int)(yc_off * (funmap.width * txrepeat) + xmotion*12)%funmap.width);
 
      int cl2 = (int)xxd2 + yyd2;
      
      int r2 = (int)(red(funmap.pixels[cl2]) * bd);
      int g2 = (int)(green(funmap.pixels[cl2]) * bd);
      int b2 = (int)(blue(funmap.pixels[cl2]) * bd);
      
      // some compositing 
      fill(r * (1.-(r2 / 255)) + r, g * (1.-(g2 / 255)) + g, b * (1.-(b2 / 255)) + b);//r * (r2 / 255) + r * bright, g * (g2 / 255) + g * bright, b * (b2 / 255) + b * bright);
      
      rect(final_x, final_y, rect_size, rect_size);

/*
      // can improve the look with some kind of ""dithering""
      fill(r, g, b, 255);
      
      float rect_size2 = rect_size / 2;
      rect(final_x - rect_size2, final_y, rect_size2, rect_size2);
      rect(final_x + rect_size2, final_y, rect_size2, rect_size2);
      rect(final_x, final_y - rect_size2, rect_size2, rect_size2);
      rect(final_x, final_y + rect_size2, rect_size2, rect_size2);
*/
    }
  }
  
  xmotion += 0.5;
	ymotion -= 0.25;
}

void setup() {
  size(800, 600);

  frameRate(60); 
  
  colormap = loadImage(""disco.jpg"");
  funmap = loadImage(""data2.jpg"");
  
  background(0);
}

void draw() {
  //background(0);
 
  draw_planet();
}"
"561095","Disco ball","mySketch","/**
  * Cheap pseudo 3D disco ball with billboard like text, same tech as ""earth"" snippet
  */

PImage colormap;
PImage funmap;

float xmotion = 0;
float ymotion = 0;

// quality control
int dots_step = 8;
int elems_step = 8;

int elems = 192;
int rect_size = 8;

void draw_planet() {
  float mx = mouseX / 1024.0;
	float my = mouseY / 1024.0;
	
	elems_step = 3;
	dots_step = 1;

  // add some motion blur / brightness
  fill(0, 0, 0, 4);
  rect(0, 0, 800, 600);
	
  noStroke();
  
  float xoff = 800 / 2;
  
  float sphere_radius = 292;
  float yoff = 600 / 2 - sphere_radius;
  
  for (int s = 0; s < elems; s += elems_step) {
    float de = (float)s / elems;
    
    float bd = max((0.5-abs(de - 0.5)) * 4, 0.05);
    
    float yrepeat = 0.25;
    int yyd = (((int)(de * (colormap.height * yrepeat))%colormap.height)) * colormap.width;
		
		float tyrepeat = 4;
		int yyd2 = (((int)(de * (funmap.height * tyrepeat) + sin(ymotion * 2 * de) * 12)%funmap.height)) * funmap.width;
		
    // cartesian circle equation
    float sphere_radius_squared = sphere_radius * sphere_radius;
    float sh_radius = de * (sphere_radius * 2) - sphere_radius;
    float xc_off = sqrt(sphere_radius_squared - sh_radius*sh_radius);
    
    float final_x;
    float final_y = yoff + de * (sphere_radius * 2); // flabby planet bonus : + sin((de * 360 + 180) * (PI / 180) + ymotion / 24.) * 4;
    
    for (int e = 0; e < (int)xc_off; e += dots_step) {
      float dd = (float)e / xc_off;

      final_x = xoff - xc_off + xc_off * dd * 2; // flabby planet bonus : + cos((de * 360 + 180) * (PI / 180) + xmotion / 24.) * 4
      
      float yc_off;
      
      // compute UV texels for the colormap
      if (dd > 0.5) {
        yc_off = sqrt(1 - dd*dd) + 1.270;
      } else {
        float dd2 = 1 - dd;
        
        yc_off = 1-sqrt(1 - dd2*dd2);
      }
      
      // apply colormaps
      float xrepeat = 0.25;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) - xmotion*2)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      // second texture (text mask)
      float txrepeat = 1.0;
      
      int xxd2 = ((funmap.width - 1) - (int)(yc_off * (funmap.width * txrepeat) + xmotion*12)%funmap.width);
 
      int cl2 = (int)xxd2 + yyd2;
      
      int r2 = (int)(red(funmap.pixels[cl2]) * bd);
      int g2 = (int)(green(funmap.pixels[cl2]) * bd);
      int b2 = (int)(blue(funmap.pixels[cl2]) * bd);
      
      // some compositing 
      fill(r * (1.-(r2 / 255)) + r, g * (1.-(g2 / 255)) + g, b * (1.-(b2 / 255)) + b);//r * (r2 / 255) + r * bright, g * (g2 / 255) + g * bright, b * (b2 / 255) + b * bright);
      
      rect(final_x, final_y, rect_size, rect_size);

/*
      // can improve the look with some kind of ""dithering""
      fill(r, g, b, 255);
      
      float rect_size2 = rect_size / 2;
      rect(final_x - rect_size2, final_y, rect_size2, rect_size2);
      rect(final_x + rect_size2, final_y, rect_size2, rect_size2);
      rect(final_x, final_y - rect_size2, rect_size2, rect_size2);
      rect(final_x, final_y + rect_size2, rect_size2, rect_size2);
*/
    }
  }
  
  xmotion += 0.5;
	ymotion -= 0.25;
}

void setup() {
  size(800, 600);

  frameRate(60); 
  
  colormap = loadImage(""disco.jpg"");
  funmap = loadImage(""data2.jpg"");
  
  background(0);
}

void draw() {
  //background(0);
 
  draw_planet();
}"
"561095","Disco ball","mySketch","/**
  * Cheap pseudo 3D disco ball with billboard like text, same tech as ""earth"" snippet
  */

PImage colormap;
PImage funmap;

float xmotion = 0;
float ymotion = 0;

// quality control
int dots_step = 8;
int elems_step = 8;

int elems = 192;
int rect_size = 8;

void draw_planet() {
  float mx = mouseX / 1024.0;
	float my = mouseY / 1024.0;
	
	elems_step = 3;
	dots_step = 1;

  // add some motion blur / brightness
  fill(0, 0, 0, 4);
  rect(0, 0, 800, 600);
	
  noStroke();
  
  float xoff = 800 / 2;
  
  float sphere_radius = 292;
  float yoff = 600 / 2 - sphere_radius;
  
  for (int s = 0; s < elems; s += elems_step) {
    float de = (float)s / elems;
    
    float bd = max((0.5-abs(de - 0.5)) * 4, 0.05);
    
    float yrepeat = 1;
    int yyd = (((int)(de * (colormap.height * yrepeat))%colormap.height)) * colormap.width;
		
		float tyrepeat = 4;
		int yyd2 = (((int)(de * (funmap.height * tyrepeat) + sin(ymotion * 2 * de) * 12)%funmap.height)) * funmap.width;
		
    // cartesian circle equation
    float sphere_radius_squared = sphere_radius * sphere_radius;
    float sh_radius = de * (sphere_radius * 2) - sphere_radius;
    float xc_off = sqrt(sphere_radius_squared - sh_radius*sh_radius);
    
    float final_x;
    float final_y = yoff + de * (sphere_radius * 2); // flabby planet bonus : + sin((de * 360 + 180) * (PI / 180) + ymotion / 24.) * 4;
    
    for (int e = 0; e < (int)xc_off; e += dots_step) {
      float dd = (float)e / xc_off;

      final_x = xoff - xc_off + xc_off * dd * 2; // flabby planet bonus : + cos((de * 360 + 180) * (PI / 180) + xmotion / 24.) * 4
      
      float yc_off;
      
      // compute UV texels for the colormap
      if (dd > 0.5) {
        yc_off = sqrt(1 - dd*dd) + 1.270;
      } else {
        float dd2 = 1 - dd;
        
        yc_off = 1-sqrt(1 - dd2*dd2);
      }
      
      // apply colormaps
      float xrepeat = 1;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) - xmotion*2)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      // second texture (text mask)
      float txrepeat = 1.0;
      
      int xxd2 = ((funmap.width - 1) - (int)(yc_off * (funmap.width * txrepeat) + xmotion*12)%funmap.width);
 
      int cl2 = (int)xxd2 + yyd2;
      
      int r2 = (int)(red(funmap.pixels[cl2]) * bd);
      int g2 = (int)(green(funmap.pixels[cl2]) * bd);
      int b2 = (int)(blue(funmap.pixels[cl2]) * bd);
      
      // some compositing 
      fill(r * (1.-(r2 / 255)) + r, g * (1.-(g2 / 255)) + g, b * (1.-(b2 / 255)) + b);//r * (r2 / 255) + r * bright, g * (g2 / 255) + g * bright, b * (b2 / 255) + b * bright);
      
      rect(final_x, final_y, rect_size, rect_size);

/*
      // can improve the look with some kind of ""dithering""
      fill(r, g, b, 255);
      
      float rect_size2 = rect_size / 2;
      rect(final_x - rect_size2, final_y, rect_size2, rect_size2);
      rect(final_x + rect_size2, final_y, rect_size2, rect_size2);
      rect(final_x, final_y - rect_size2, rect_size2, rect_size2);
      rect(final_x, final_y + rect_size2, rect_size2, rect_size2);
*/
    }
  }
  
  xmotion += 0.5;
	ymotion -= 0.25;
}

void setup() {
  size(800, 600);

  frameRate(60); 
  
  colormap = loadImage(""disco.jpg"");
  funmap = loadImage(""data2.jpg"");
  
  background(0);
}

void draw() {
  //background(0);
 
  draw_planet();
}"
"561095","Disco ball","mySketch","/**
  * Cheap pseudo 3D disco ball with billboard like text, same tech as ""earth"" snippet
  */

PImage colormap;
PImage funmap;

float xmotion = 0;
float ymotion = 0;

// quality control
int dots_step = 8;
int elems_step = 8;

int elems = 192;
int rect_size = 8;

void draw_planet() {
  float mx = mouseX / 1024.0;
	float my = mouseY / 1024.0;
	
	elems_step = 3;
	dots_step = 1;

  // add some motion blur / brightness
  fill(0, 0, 0, 4);
  rect(0, 0, 800, 600);
	
  noStroke();
  
  float xoff = 800 / 2;
  
  float sphere_radius = 292;
  float yoff = 600 / 2 - sphere_radius;
  
  for (int s = 0; s < elems; s += elems_step) {
    float de = (float)s / elems;
    
    float bd = max((0.5-abs(de - 0.5)) * 4, 0.05);
    
    float yrepeat = 1;
    int yyd = (((int)(de * (colormap.height * yrepeat))%colormap.height)) * colormap.width;
		
		float tyrepeat = 4;
		int yyd2 = (((int)(de * (funmap.height * tyrepeat) + sin(ymotion * 2 * de) * 12)%funmap.height)) * funmap.width;
		
    // cartesian circle equation
    float sphere_radius_squared = sphere_radius * sphere_radius;
    float sh_radius = de * (sphere_radius * 2) - sphere_radius;
    float xc_off = sqrt(sphere_radius_squared - sh_radius*sh_radius);
    
    float final_x;
    float final_y = yoff + de * (sphere_radius * 2); // flabby planet bonus : + sin((de * 360 + 180) * (PI / 180) + ymotion / 24.) * 4;
    
    for (int e = 0; e < (int)xc_off; e += dots_step) {
      float dd = (float)e / xc_off;

      final_x = xoff - xc_off + xc_off * dd * 2; // flabby planet bonus : + cos((de * 360 + 180) * (PI / 180) + xmotion / 24.) * 4
      
      float yc_off;
      
      // compute UV texels for the colormap
      if (dd > 0.5) {
        yc_off = sqrt(1 - dd*dd) + 1.270;
      } else {
        float dd2 = 1 - dd;
        
        yc_off = 1-sqrt(1 - dd2*dd2);
      }
      
      // apply colormaps
      float xrepeat = 1;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) - xmotion*2)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      // second texture (text mask)
      float txrepeat = 1.0;
      
      int xxd2 = ((funmap.width - 1) - (int)(yc_off * (funmap.width * txrepeat) + xmotion*12)%funmap.width);
 
      int cl2 = (int)xxd2 + yyd2;
      
      int r2 = (int)(red(funmap.pixels[cl2]) * bd);
      int g2 = (int)(green(funmap.pixels[cl2]) * bd);
      int b2 = (int)(blue(funmap.pixels[cl2]) * bd);
      
      // some compositing 
      fill(r * (1.-(r2 / 255)) + r, g * (1.-(g2 / 255)) + g, b * (1.-(b2 / 255)) + b);//r * (r2 / 255) + r * bright, g * (g2 / 255) + g * bright, b * (b2 / 255) + b * bright);
      
      rect(final_x, final_y, rect_size, rect_size);

/*
      // can improve the look with some kind of ""dithering""
      fill(r, g, b, 255);
      
      float rect_size2 = rect_size / 2;
      rect(final_x - rect_size2, final_y, rect_size2, rect_size2);
      rect(final_x + rect_size2, final_y, rect_size2, rect_size2);
      rect(final_x, final_y - rect_size2, rect_size2, rect_size2);
      rect(final_x, final_y + rect_size2, rect_size2, rect_size2);
*/
    }
  }
  
  xmotion += 0.5;
	ymotion += 0.25;
}

void setup() {
  size(800, 600);

  frameRate(60); 
  
  colormap = loadImage(""disco.jpg"");
  funmap = loadImage(""data2.jpg"");
  
  background(0);
}

void draw() {
  //background(0);
 
  draw_planet();
}"
"561048","Droplet","mySketch","/**
  * Same tech as my Planet Earth snippet, with lots of motion blur and object made of dots (rectangles), this look like a metaball / droplet!
  */

PImage colormap;

float xmotion = 0;
float ymotion = 0;

// quality control
int dots_step = 2;
int elems_step = 1;

// same but look below, these are adjusted in real-time to increase rendering quality by abusing motion blur :)
int elems = 192;
int rect_size = 4;

void draw_planet() {
  float mx = mouseX / 1024.0;
	float my = mouseY / 1024.0;

  // add some motion blur / brightness
  fill(0, 0, 0, 16);
  rect(0, 0, 800, 600);
	
	// here we take advantage of the motion blur to ""fill in the gap"" by adjusting each slices / frames, this increase rendering quality (altough it look hazy)
	elems = 92 + sin(xmotion / 24.) * 36;
	rect_size = 2 + abs(sin(xmotion / 84.)) * 4;
  
  noStroke();
  
  float xoff = 800 / 2;
  
  float sphere_radius = 224;
  float yoff = 600 / 2 - sphere_radius;
  
  for (int s = 0; s < elems; s += elems_step) {
    float de = (float)s / elems;
    
    float bd = max((0.5-abs(de - 0.5)) * 4, 0.05);
    
    float yrepeat = 1;
    int yyd = (((int)(de * (colormap.height * yrepeat))%colormap.height)) * colormap.width;
		
    // cartesian circle equation
    float sphere_radius_squared = sphere_radius * sphere_radius;
    float sh_radius = de * (sphere_radius * 2) - sphere_radius;
    float xc_off = sqrt(sphere_radius_squared - sh_radius*sh_radius);
    
    float final_x;
    float final_y = yoff + de * (sphere_radius * 2) + sin((de * 360 + 180) * (PI / 180) + xmotion / 20.) * 24;
    
    for (int e = 0; e < (int)xc_off; e += dots_step) {
      float dd = (float)e / xc_off;

      final_x = xoff - xc_off + xc_off * dd * 2 + cos((de * 360 + 180) * (PI / 180) + ymotion / 12.) * 12;
      
      float yc_off;
      
      // compute UV texels for the colormap
      if (dd > 0.5) {
        yc_off = sqrt(1 - dd*dd) + 1.270;
      } else {
        float dd2 = 1 - dd;
        
        yc_off = 1-sqrt(1 - dd2*dd2);
      }
      
      // apply colormaps
      float xrepeat = 0.5;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + xmotion)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      // some compositing 
      fill(r, g, b, 48);//r * (r2 / 255) + r * bright, g * (g2 / 255) + g * bright, b * (b2 / 255) + b * bright);
      
      //rect(final_x, final_y, rect_size, rect_size);
      // slower but look good!
      ellipse(final_x, final_y, rect_size, rect_size);

/*
      // can improve the look with some kind of ""dithering""
      fill(r, g, b, 255);
      
      float rect_size2 = rect_size / 2;
      rect(final_x - rect_size2, final_y, rect_size2, rect_size2);
      rect(final_x + rect_size2, final_y, rect_size2, rect_size2);
      rect(final_x, final_y - rect_size2, rect_size2, rect_size2);
      rect(final_x, final_y + rect_size2, rect_size2, rect_size2);
*/
    }
  }
  
  xmotion += 0.5;
	ymotion -= 0.25;
}

void setup() {
  size(800, 600);

  frameRate(60); 
  
  colormap = loadImage(""wattex-1.jpg"");
  
  background(0);
}

void draw() {
  //background(0);
 
  draw_planet();
}"
"561048","Droplet","mySketch","/**
  * Same tech as my Planet Earth snippet, with lots of motion blur and object made of dots (rectangles), this look like a metaball / droplet!
  */

PImage colormap;

float xmotion = 0;
float ymotion = 0;

// quality control
int dots_step = 2;
int elems_step = 1;

// same but look below, these are adjusted in real-time to increase rendering quality by abusing motion blur :)
int elems = 192;
int rect_size = 4;

void draw_planet() {
  float mx = mouseX / 1024.0;
	float my = mouseY / 1024.0;

  // add some motion blur / brightness
  fill(0, 0, 0, 16);
  rect(0, 0, 800, 600);
	
	// here we take advantage of the motion blur to ""fill in the gap"" by adjusting each slices / frames, this increase rendering quality (altough it look hazy)
	elems = 92 + sin(xmotion / 24.) * 36;
	rect_size = 2 + abs(sin(xmotion / 84.)) * 4;
  
  noStroke();
  
  float xoff = 800 / 2;
  
  float sphere_radius = 224;
  float yoff = 600 / 2 - sphere_radius;
  
  for (int s = 0; s < elems; s += elems_step) {
    float de = (float)s / elems;
    
    float bd = max((0.5-abs(de - 0.5)) * 4, 0.05);
    
    float yrepeat = 1;
    int yyd = (((int)(de * (colormap.height * yrepeat))%colormap.height)) * colormap.width;
		
    // cartesian circle equation
    float sphere_radius_squared = sphere_radius * sphere_radius;
    float sh_radius = de * (sphere_radius * 2) - sphere_radius;
    float xc_off = sqrt(sphere_radius_squared - sh_radius*sh_radius);
    
    float final_x;
    float final_y = yoff + de * (sphere_radius * 2) + sin((de * 360 + 180) * (PI / 180) + xmotion / 20.) * 24;
    
    for (int e = 0; e < (int)xc_off; e += dots_step) {
      float dd = (float)e / xc_off;

      final_x = xoff - xc_off + xc_off * dd * 2 + cos((de * 360 + 180) * (PI / 180) + ymotion / 12.) * 12;
      
      float yc_off;
      
      // compute UV texels for the colormap
      if (dd > 0.5) {
        yc_off = sqrt(1 - dd*dd) + 1.270;
      } else {
        float dd2 = 1 - dd;
        
        yc_off = 1-sqrt(1 - dd2*dd2);
      }
      
      // apply colormaps
      float xrepeat = 0.5;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + xmotion)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      // some compositing 
      fill(r, g, b, 48);//r * (r2 / 255) + r * bright, g * (g2 / 255) + g * bright, b * (b2 / 255) + b * bright);
      
      //rect(final_x, final_y, rect_size, rect_size);
      // slower but look good!
      ellipse(final_x, final_y, rect_size, rect_size);

/*
      // can improve the look with some kind of ""dithering""
      fill(r, g, b, 255);
      
      float rect_size2 = rect_size / 2;
      rect(final_x - rect_size2, final_y, rect_size2, rect_size2);
      rect(final_x + rect_size2, final_y, rect_size2, rect_size2);
      rect(final_x, final_y - rect_size2, rect_size2, rect_size2);
      rect(final_x, final_y + rect_size2, rect_size2, rect_size2);
*/
    }
  }
  
  xmotion += 0.5;
	ymotion += 0.25;
}

void setup() {
  size(800, 600);

  frameRate(60); 
  
  colormap = loadImage(""wattex-1.jpg"");
  
  background(0);
}

void draw() {
  //background(0);
 
  draw_planet();
}"
"561045","Blue planet","mySketch","/**
  * Dots planet billboard.
  *
  * A weird idea, started with a cartesian way to draw a circle made of tiny blocks (aka the ""dots"") then expanded by applying a colormap then a second texture which is used as a mask to display the text and then day/night cycle from a mask.
  * Some more ideas : exploding planet (or two planet colliding etc.)
	*
	* There is some issue with the rendering (the vertical slices which should be inversed after half of the circle) but this doesn't affect much the quality
	*
	* This is rather slow on the web and could be optimized even more but run ok with better quality on Processing desktop.
  *
  * Initially wanted to recreate Star Control 2 planets rendering. (but they probably use another tech.) 
  */

PImage colormap;
PImage funmap;
PImage nightmap;
PImage cyclemap;

float xmotion = 0;
float ymotion = 0;

// quality control
int dots_step = 2;
int elems_step = 1;

// same but look below, these are adjusted in real-time to increase rendering quality by abusing motion blur :)
int elems = 192;
int rect_size = 4;

void draw_planet() {
  float mx = mouseX / 1024.0;
	float my = mouseY / 1024.0;

  // add some motion blur / brightness
  fill(0, 0, 0, 4);
  rect(0, 0, 800, 600);
	
	// here we take advantage of the motion blur to ""fill in the gap"" by adjusting each slices / frames, this increase rendering quality (altough it look hazy)
	elems = 92 + sin(xmotion / 24.) * 36;
	rect_size = 2 + abs(sin(xmotion / 84.)) * 4;
  
  noStroke();
  
  float xoff = 800 / 2;
  
  float sphere_radius = 292;
  float yoff = 600 / 2 - sphere_radius;
  
  for (int s = 0; s < elems; s += elems_step) {
    float de = (float)s / elems;
    
    float bd = max((0.5-abs(de - 0.5)) * 4, 0.05);
    
    float yrepeat = 1;
    int yyd = (((int)(de * (colormap.height * yrepeat))%colormap.height)) * colormap.width;
		
		float tyrepeat = 3;
		int yyd2 = (((int)(de * (funmap.height * tyrepeat) + ymotion)%funmap.height)) * funmap.width;
		
		int yydc = (((int)(de * (cyclemap.height * yrepeat))%cyclemap.height)) * cyclemap.width;
    
    // cartesian circle equation
    float sphere_radius_squared = sphere_radius * sphere_radius;
    float sh_radius = de * (sphere_radius * 2) - sphere_radius;
    float xc_off = sqrt(sphere_radius_squared - sh_radius*sh_radius);
    
    float final_x;
    float final_y = yoff + de * (sphere_radius * 2); //+ sin((de * 360 + 180) * (PI / 180) + xmotion / 24.) * 4;
    
    for (int e = 0; e < (int)xc_off; e += dots_step) {
      float dd = (float)e / xc_off;

      final_x = xoff - xc_off + xc_off * dd * 2;// + cos((de * 360 + 180) * (PI / 180) + xmotion / 24.) * 4;
      
      float yc_off;
      
      // compute UV texels for the colormap
      if (dd > 0.5) {
        yc_off = sqrt(1 - dd*dd) + 1.270;
      } else {
        float dd2 = 1 - dd;
        
        yc_off = 1-sqrt(1 - dd2*dd2);
      }
      
      // apply colormaps
      float xrepeat = 0.5;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + xmotion)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      
      // third texture (night version), reuse the first texture UV since they are the same width/height
      int rn = (int)(red(nightmap.pixels[cl]));
      int gn = (int)(green(nightmap.pixels[cl]));
      int bn = (int)(blue(nightmap.pixels[cl]));
      
      // fourth texture (cycle mask), only use single component since it is black/white
      int xxdc = ((cyclemap.width - 1) - (int)(yc_off * (cyclemap.width * xrepeat) + xmotion * 4)%cyclemap.width);
      int clc = (int)xxdc + yydc;
      float rc = red(cyclemap.pixels[clc]) / 255;
      
      float final_r = r * rc + rn * (1 - rc);
      float final_g = g * rc + gn * (1 - rc);
      float final_b = b * rc + bn * (1 - rc);
      
      // some compositing 
      fill(final_r, final_g, final_b, 48);//r * (r2 / 255) + r * bright, g * (g2 / 255) + g * bright, b * (b2 / 255) + b * bright);
      
      //rect(final_x, final_y, rect_size, rect_size);
      // slower but look good!
      ellipse(final_x, final_y, rect_size, rect_size);

/*
      // can improve the look with some kind of ""dithering""
      fill(r, g, b, 255);
      
      float rect_size2 = rect_size / 2;
      rect(final_x - rect_size2, final_y, rect_size2, rect_size2);
      rect(final_x + rect_size2, final_y, rect_size2, rect_size2);
      rect(final_x, final_y - rect_size2, rect_size2, rect_size2);
      rect(final_x, final_y + rect_size2, rect_size2, rect_size2);
*/
    }
  }
  
  xmotion += 0.5;
	ymotion -= 0.25;
}

void setup() {
  size(800, 600);

  frameRate(60); 
  
  colormap = loadImage(""data.jpg"");
  funmap = loadImage(""data2.jpg"");
  nightmap = loadImage(""data_night.jpg"");
  cyclemap = loadImage(""data_cycle.jpg"");
  
  background(0);
}

void draw() {
  //background(0);
 
  draw_planet();
}"
"561045","Blue planet","mySketch","/**
  * Dots planet billboard.
  *
  * A weird idea, started with a cartesian way to draw a circle made of tiny blocks (aka the ""dots"") then expanded by applying a colormap then a second texture which is used as a mask to display the text and then day/night cycle from a mask.
  * Some more ideas : exploding planet (or two planet colliding etc.)
	*
	* There is some issue with the rendering (the vertical slices which should be inversed after half of the circle) but this doesn't affect much the quality
	*
	* This is rather slow on the web and could be optimized even more but run ok with better quality on Processing desktop.
  *
  * Initially wanted to recreate Star Control 2 planets rendering. (but they probably use another tech.) 
  */

PImage colormap;
PImage funmap;
PImage nightmap;
PImage cyclemap;

float xmotion = 0;
float ymotion = 0;

// quality control
int dots_step = 2;
int elems_step = 1;

// same but look below, these are adjusted in real-time to increase rendering quality by abusing motion blur :)
int elems = 192;
int rect_size = 4;

void draw_planet() {
  float mx = mouseX / 1024.0;
	float my = mouseY / 1024.0;

  // add some motion blur / brightness
  fill(0, 0, 0, 4);
  rect(0, 0, 800, 600);
	
	// here we take advantage of the motion blur to ""fill in the gap"" by adjusting each slices / frames, this increase rendering quality (altough it look hazy)
	elems = 92 + sin(xmotion / 24.) * 36;
	rect_size = 2 + abs(sin(xmotion / 84.)) * 4;
  
  noStroke();
  
  float xoff = 800 / 2;
  
  float sphere_radius = 292;
  float yoff = 600 / 2 - sphere_radius;
  
  for (int s = 0; s < elems; s += elems_step) {
    float de = (float)s / elems;
    
    float bd = max((0.5-abs(de - 0.5)) * 4, 0.05);
    
    float yrepeat = 1;
    int yyd = (((int)(de * (colormap.height * yrepeat))%colormap.height)) * colormap.width;
		
		float tyrepeat = 3;
		int yyd2 = (((int)(de * (funmap.height * tyrepeat) + ymotion)%funmap.height)) * funmap.width;
		
		int yydc = (((int)(de * (cyclemap.height * yrepeat))%cyclemap.height)) * cyclemap.width;
    
    // cartesian circle equation
    float sphere_radius_squared = sphere_radius * sphere_radius;
    float sh_radius = de * (sphere_radius * 2) - sphere_radius;
    float xc_off = sqrt(sphere_radius_squared - sh_radius*sh_radius);
    
    float final_x;
    float final_y = yoff + de * (sphere_radius * 2); //+ sin((de * 360 + 180) * (PI / 180) + xmotion / 24.) * 4;
    
    for (int e = 0; e < (int)xc_off; e += dots_step) {
      float dd = (float)e / xc_off;

      final_x = xoff - xc_off + xc_off * dd * 2;// + cos((de * 360 + 180) * (PI / 180) + xmotion / 24.) * 4;
      
      float yc_off;
      
      // compute UV texels for the colormap
      if (dd > 0.5) {
        yc_off = sqrt(1 - dd*dd) + 1.270;
      } else {
        float dd2 = 1 - dd;
        
        yc_off = 1-sqrt(1 - dd2*dd2);
      }
      
      // apply colormaps
      float xrepeat = 0.5;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + xmotion)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      
      // third texture (night version), reuse the first texture UV since they are the same width/height
      int rn = (int)(red(nightmap.pixels[cl]));
      int gn = (int)(green(nightmap.pixels[cl]));
      int bn = (int)(blue(nightmap.pixels[cl]));
      
      // fourth texture (cycle mask), only use single component since it is black/white
      int xxdc = ((cyclemap.width - 1) - (int)(yc_off * (cyclemap.width * xrepeat) + xmotion * 4)%cyclemap.width);
      int clc = (int)xxdc + yydc;
      float rc = red(cyclemap.pixels[clc]) / 255;
      
      float final_r = r * rc + rn * (1 - rc);
      float final_g = g * rc + gn * (1 - rc);
      float final_b = b * rc + bn * (1 - rc);
      
      // some compositing 
      fill(final_r, final_g, final_b, 48);//r * (r2 / 255) + r * bright, g * (g2 / 255) + g * bright, b * (b2 / 255) + b * bright);
      
      //rect(final_x, final_y, rect_size, rect_size);
      // slower but look good!
      ellipse(final_x, final_y, rect_size, rect_size);

/*
      // can improve the look with some kind of ""dithering""
      fill(r, g, b, 255);
      
      float rect_size2 = rect_size / 2;
      rect(final_x - rect_size2, final_y, rect_size2, rect_size2);
      rect(final_x + rect_size2, final_y, rect_size2, rect_size2);
      rect(final_x, final_y - rect_size2, rect_size2, rect_size2);
      rect(final_x, final_y + rect_size2, rect_size2, rect_size2);
*/
    }
  }
  
  xmotion += 0.5;
	ymotion -= 0.25;
}

void setup() {
  size(800, 600);

  frameRate(60); 
  
  colormap = loadImage(""data.jpg"");
  funmap = loadImage(""data2.jpg"");
  nightmap = loadImage(""data_night.jpg"");
  cyclemap = loadImage(""data_cycle.jpg"");
  
  background(0);
}

void draw() {
  //background(0);
 
  draw_planet();
}"
"561045","Blue planet","mySketch","/**
  * Dots planet billboard.
  *
  * A weird idea, started with a cartesian way to draw a circle made of tiny blocks (aka the ""dots"") then expanded by applying a colormap then a second texture which is used as a mask to display the text and then day/night cycle from a mask.
  * Some more ideas : exploding planet (or two planet colliding etc.)
	*
	* There is some issue with the rendering (the vertical slices which should be inversed after half of the circle) but this doesn't affect much the quality
	*
	* This is rather slow on the web and could be optimized even more but run ok with better quality on Processing desktop.
  *
  * Initially wanted to recreate Star Control 2 planets rendering. (but they probably use another tech.) 
  */

PImage colormap;
PImage nightmap;
PImage cyclemap;

float xmotion = 0;
float ymotion = 0;

// quality control
int dots_step = 2;
int elems_step = 1;

// same but look below, these are adjusted in real-time to increase rendering quality by abusing motion blur :)
int elems = 192;
int rect_size = 4;

void draw_planet() {
  float mx = mouseX / 1024.0;
	float my = mouseY / 1024.0;

  // add some motion blur / brightness
  fill(0, 0, 0, 4);
  rect(0, 0, 800, 600);
	
	// here we take advantage of the motion blur to ""fill in the gap"" by adjusting each slices / frames, this increase rendering quality (altough it look hazy)
	elems = 92 + sin(xmotion / 24.) * 36;
	rect_size = 2 + abs(sin(xmotion / 84.)) * 4;
  
  noStroke();
  
  float xoff = 800 / 2;
  
  float sphere_radius = 292;
  float yoff = 600 / 2 - sphere_radius;
  
  for (int s = 0; s < elems; s += elems_step) {
    float de = (float)s / elems;
    
    float bd = max((0.5-abs(de - 0.5)) * 4, 0.05);
    
    float yrepeat = 1;
    int yyd = (((int)(de * (colormap.height * yrepeat))%colormap.height)) * colormap.width;
		
		float tyrepeat = 3;
		int yyd2 = (((int)(de * (nightmap.height * tyrepeat) + ymotion)%nightmap.height)) * nightmap.width;
		
		int yydc = (((int)(de * (cyclemap.height * yrepeat))%cyclemap.height)) * cyclemap.width;
    
    // cartesian circle equation
    float sphere_radius_squared = sphere_radius * sphere_radius;
    float sh_radius = de * (sphere_radius * 2) - sphere_radius;
    float xc_off = sqrt(sphere_radius_squared - sh_radius*sh_radius);
    
    float final_x;
    float final_y = yoff + de * (sphere_radius * 2); //+ sin((de * 360 + 180) * (PI / 180) + xmotion / 24.) * 4;
    
    for (int e = 0; e < (int)xc_off; e += dots_step) {
      float dd = (float)e / xc_off;

      final_x = xoff - xc_off + xc_off * dd * 2;// + cos((de * 360 + 180) * (PI / 180) + xmotion / 24.) * 4;
      
      float yc_off;
      
      // compute UV texels for the colormap
      if (dd > 0.5) {
        yc_off = sqrt(1 - dd*dd) + 1.270;
      } else {
        float dd2 = 1 - dd;
        
        yc_off = 1-sqrt(1 - dd2*dd2);
      }
      
      // apply colormaps
      float xrepeat = 0.5;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + xmotion)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      
      // third texture (night version), reuse the first texture UV since they are the same width/height
      int rn = (int)(red(nightmap.pixels[cl]));
      int gn = (int)(green(nightmap.pixels[cl]));
      int bn = (int)(blue(nightmap.pixels[cl]));
      
      // fourth texture (cycle mask), only use single component since it is black/white
      int xxdc = ((cyclemap.width - 1) - (int)(yc_off * (cyclemap.width * xrepeat) + xmotion * 4)%cyclemap.width);
      int clc = (int)xxdc + yydc;
      float rc = red(cyclemap.pixels[clc]) / 255;
      
      float final_r = r * rc + rn * (1 - rc);
      float final_g = g * rc + gn * (1 - rc);
      float final_b = b * rc + bn * (1 - rc);
      
      // some compositing 
      fill(final_r, final_g, final_b, 48);//r * (r2 / 255) + r * bright, g * (g2 / 255) + g * bright, b * (b2 / 255) + b * bright);
      
      //rect(final_x, final_y, rect_size, rect_size);
      // slower but look good!
      ellipse(final_x, final_y, rect_size, rect_size);

/*
      // can improve the look with some kind of ""dithering""
      fill(r, g, b, 255);
      
      float rect_size2 = rect_size / 2;
      rect(final_x - rect_size2, final_y, rect_size2, rect_size2);
      rect(final_x + rect_size2, final_y, rect_size2, rect_size2);
      rect(final_x, final_y - rect_size2, rect_size2, rect_size2);
      rect(final_x, final_y + rect_size2, rect_size2, rect_size2);
*/
    }
  }
  
  xmotion += 0.5;
	ymotion -= 0.25;
}

void setup() {
  size(800, 600);

  frameRate(60); 
  
  colormap = loadImage(""data.jpg"");
  nightmap = loadImage(""data_night.jpg"");
  cyclemap = loadImage(""data_cycle.jpg"");
  
  background(0);
}

void draw() {
  //background(0);
 
  draw_planet();
}"
"561045","Blue planet","mySketch","/**
  * Dots planet billboard.
  *
  * A weird idea, started with a cartesian way to draw a circle made of tiny blocks (aka the ""dots"") then expanded by applying a colormap then a second texture which is used as a mask to display the text and then day/night cycle from a mask.
  * Some more ideas : exploding planet (or two planet colliding etc.)
	*
	* There is some issue with the rendering (the vertical slices which should be inversed after half of the circle) but this doesn't affect much the quality
	*
	* This is rather slow on the web and could be optimized even more but run ok with better quality on Processing desktop.
  *
  * Initially wanted to recreate Star Control 2 planets rendering. (but they probably use another tech.) 
  */

PImage colormap;
PImage nightmap;
PImage cyclemap;

float xmotion = 0;
float ymotion = 0;

// quality control
int dots_step = 2;
int elems_step = 1;

// same but look below, these are adjusted in real-time to increase rendering quality by abusing motion blur :)
int elems = 192;
int rect_size = 4;

void draw_planet() {
  float mx = mouseX / 1024.0;
	float my = mouseY / 1024.0;

  // add some motion blur / brightness
  fill(0, 0, 0, 4);
  rect(0, 0, 800, 600);
	
	// here we take advantage of the motion blur to ""fill in the gap"" by adjusting each slices / frames, this increase rendering quality (altough it look hazy)
	elems = 92 + sin(xmotion / 24.) * 36;
	rect_size = 2 + abs(sin(xmotion / 84.)) * 4;
  
  noStroke();
  
  float xoff = 800 / 2;
  
  float sphere_radius = 292;
  float yoff = 600 / 2 - sphere_radius;
  
  for (int s = 0; s < elems; s += elems_step) {
    float de = (float)s / elems;
    
    float bd = max((0.5-abs(de - 0.5)) * 4, 0.05);
    
    float yrepeat = 1;
    int yyd = (((int)(de * (colormap.height * yrepeat))%colormap.height)) * colormap.width;
		
		float tyrepeat = 3;
		int yyd2 = (((int)(de * (nightmap.height * tyrepeat) + ymotion)%nightmap.height)) * nightmap.width;
		
		int yydc = (((int)(de * (cyclemap.height * yrepeat))%cyclemap.height)) * cyclemap.width;
    
    // cartesian circle equation
    float sphere_radius_squared = sphere_radius * sphere_radius;
    float sh_radius = de * (sphere_radius * 2) - sphere_radius;
    float xc_off = sqrt(sphere_radius_squared - sh_radius*sh_radius);
    
    float final_x;
    float final_y = yoff + de * (sphere_radius * 2); //+ sin((de * 360 + 180) * (PI / 180) + xmotion / 24.) * 4;
    
    for (int e = 0; e < (int)xc_off; e += dots_step) {
      float dd = (float)e / xc_off;

      final_x = xoff - xc_off + xc_off * dd * 2;// + cos((de * 360 + 180) * (PI / 180) + xmotion / 24.) * 4;
      
      float yc_off;
      
      // compute UV texels for the colormap
      if (dd > 0.5) {
        yc_off = sqrt(1 - dd*dd) + 1.270;
      } else {
        float dd2 = 1 - dd;
        
        yc_off = 1-sqrt(1 - dd2*dd2);
      }
      
      // apply colormaps
      float xrepeat = 0.5;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + xmotion)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      
      // third texture (night version), reuse the first texture UV since they are the same width/height
      int rn = (int)(red(nightmap.pixels[cl]));
      int gn = (int)(green(nightmap.pixels[cl]));
      int bn = (int)(blue(nightmap.pixels[cl]));
      
      // fourth texture (cycle mask), only use single component since it is black/white
      int xxdc = ((cyclemap.width - 1) - (int)(yc_off * (cyclemap.width * xrepeat) + xmotion * 4)%cyclemap.width);
      int clc = (int)xxdc + yydc;
      float rc = red(cyclemap.pixels[clc]) / 255;
      
      float final_r = r * rc + rn * (1 - rc);
      float final_g = g * rc + gn * (1 - rc);
      float final_b = b * rc + bn * (1 - rc);
      
      // some compositing 
      fill(final_r, final_g, final_b, 48);//r * (r2 / 255) + r * bright, g * (g2 / 255) + g * bright, b * (b2 / 255) + b * bright);
      
      //rect(final_x, final_y, rect_size, rect_size);
      // slower but look good!
      ellipse(final_x, final_y, rect_size, rect_size);

/*
      // can improve the look with some kind of ""dithering""
      fill(r, g, b, 255);
      
      float rect_size2 = rect_size / 2;
      rect(final_x - rect_size2, final_y, rect_size2, rect_size2);
      rect(final_x + rect_size2, final_y, rect_size2, rect_size2);
      rect(final_x, final_y - rect_size2, rect_size2, rect_size2);
      rect(final_x, final_y + rect_size2, rect_size2, rect_size2);
*/
    }
  }
  
  xmotion += 0.5;
	ymotion += 0.25;
}

void setup() {
  size(800, 600);

  frameRate(60); 
  
  colormap = loadImage(""data.jpg"");
  nightmap = loadImage(""data_night.jpg"");
  cyclemap = loadImage(""data_cycle.jpg"");
  
  background(0);
}

void draw() {
  //background(0);
 
  draw_planet();
}"
"561044","Earth blur","mySketch","/**
  * Dots planet billboard.
  *
  * A weird idea, started with a cartesian way to draw a circle made of tiny blocks (aka the ""dots"") then expanded by applying a colormap then a second texture which is used as a mask to display the text and then day/night cycle from a mask.
  * Some more ideas : exploding planet (or two planet colliding etc.)
	*
	* There is some issue with the rendering (the vertical slices which should be inversed after half of the circle) but this doesn't affect much the quality
	*
	* This is rather slow on the web and could be optimized even more but run ok with better quality on Processing desktop.
  *
  * Initially wanted to recreate Star Control 2 planets rendering. (but they probably use another tech.) 
  */

PImage colormap;
PImage funmap;
PImage nightmap;
PImage cyclemap;

float xmotion = 0;
float ymotion = 0;

// quality control
int dots_step = 2;
int elems_step = 1;

// same but look below, these are adjusted in real-time to increase rendering quality by abusing motion blur :)
int elems = 192;
int rect_size = 4;

void draw_planet() {
  float mx = mouseX / 1024.0;
	float my = mouseY / 1024.0;

  // add some motion blur / brightness
  fill(0, 0, 0, 4);
  rect(0, 0, 800, 600);
	
	// here we take advantage of the motion blur to ""fill in the gap"" by adjusting each slices / frames, this increase rendering quality (altough it look hazy)
	elems = 92 + sin(xmotion / 24.) * 36;
	rect_size = 2 + abs(sin(xmotion / 84.)) * 4;
  
  noStroke();
  
  float xoff = 800 / 2;
  
  float sphere_radius = 292;
  float yoff = 600 / 2 - sphere_radius;
  
  for (int s = 0; s < elems; s += elems_step) {
    float de = (float)s / elems;
    
    float bd = max((0.5-abs(de - 0.5)) * 4, 0.05);
    
    float yrepeat = 1;
    int yyd = (((int)(de * (colormap.height * yrepeat))%colormap.height)) * colormap.width;
		
		float tyrepeat = 3;
		int yyd2 = (((int)(de * (funmap.height * tyrepeat) + ymotion)%funmap.height)) * funmap.width;
		
		int yydc = (((int)(de * (cyclemap.height * yrepeat))%cyclemap.height)) * cyclemap.width;
    
    // cartesian circle equation
    float sphere_radius_squared = sphere_radius * sphere_radius;
    float sh_radius = de * (sphere_radius * 2) - sphere_radius;
    float xc_off = sqrt(sphere_radius_squared - sh_radius*sh_radius);
    
    float final_x;
    float final_y = yoff + de * (sphere_radius * 2); // flabby planet bonus : + sin((de * 360 + 180) * (PI / 180) + ymotion / 24.) * 4;
    
    for (int e = 0; e < (int)xc_off; e += dots_step) {
      float dd = (float)e / xc_off;

      final_x = xoff - xc_off + xc_off * dd * 2; // flabby planet bonus : + cos((de * 360 + 180) * (PI / 180) + xmotion / 24.) * 4
      
      float yc_off;
      
      // compute UV texels for the colormap
      if (dd > 0.5) {
        yc_off = sqrt(1 - dd*dd) + 1.270;
      } else {
        float dd2 = 1 - dd;
        
        yc_off = 1-sqrt(1 - dd2*dd2);
      }
      
      // apply colormaps
      float xrepeat = 0.5;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + xmotion)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      // second texture (text mask)
      float txrepeat = 1.;
      
      int xxd2 = ((funmap.width - 1) - (int)(yc_off * (funmap.width * txrepeat) + xmotion)%funmap.width);
 
      int cl2 = (int)xxd2 + yyd2;
      
      int r2 = (int)(red(funmap.pixels[cl2]) * bd);
      int g2 = (int)(green(funmap.pixels[cl2]) * bd);
      int b2 = (int)(blue(funmap.pixels[cl2]) * bd);
      
      // third texture (night version), reuse the first texture UV since they are the same width/height
      int rn = (int)(red(nightmap.pixels[cl]));
      int gn = (int)(green(nightmap.pixels[cl]));
      int bn = (int)(blue(nightmap.pixels[cl]));
      
      // fourth texture (cycle mask), only use single component since it is black/white
      int xxdc = ((cyclemap.width - 1) - (int)(yc_off * (cyclemap.width * xrepeat) + xmotion * 4)%cyclemap.width);
      int clc = (int)xxdc + yydc;
      float rc = red(cyclemap.pixels[clc]) / 255;
      
      float final_r = r * rc + rn * (1 - rc);
      float final_g = g * rc + gn * (1 - rc);
      float final_b = b * rc + bn * (1 - rc);
      
      // some compositing 
      fill(r * (r2 / 255) + final_r, g * (g2 / 255) + final_g, b * (b2 / 255) + final_b, 48);//r * (r2 / 255) + r * bright, g * (g2 / 255) + g * bright, b * (b2 / 255) + b * bright);
      
      //rect(final_x, final_y, rect_size, rect_size);
      // slower but look good!
      ellipse(final_x, final_y, rect_size, rect_size);

/*
      // can improve the look with some kind of ""dithering""
      fill(r, g, b, 255);
      
      float rect_size2 = rect_size / 2;
      rect(final_x - rect_size2, final_y, rect_size2, rect_size2);
      rect(final_x + rect_size2, final_y, rect_size2, rect_size2);
      rect(final_x, final_y - rect_size2, rect_size2, rect_size2);
      rect(final_x, final_y + rect_size2, rect_size2, rect_size2);
*/
    }
  }
  
  xmotion += 0.5;
	ymotion -= 0.25;
}

void setup() {
  size(800, 600);

  frameRate(60); 
  
  colormap = loadImage(""data.jpg"");
  funmap = loadImage(""data2.jpg"");
  nightmap = loadImage(""data_night.jpg"");
  cyclemap = loadImage(""data_cycle.jpg"");
  
  background(0);
}

void draw() {
  //background(0);
 
  draw_planet();
}"
"561044","Earth blur","mySketch","/**
  * Dots planet billboard.
  *
  * A weird idea, started with a cartesian way to draw a circle made of tiny blocks (aka the ""dots"") then expanded by applying a colormap then a second texture which is used as a mask to display the text and then day/night cycle from a mask.
  * Some more ideas : exploding planet (or two planet colliding etc.)
	*
	* There is some issue with the rendering (the vertical slices which should be inversed after half of the circle) but this doesn't affect much the quality
	*
	* This is rather slow on the web and could be optimized even more but run ok with better quality on Processing desktop.
  *
  * Initially wanted to recreate Star Control 2 planets rendering. (but they probably use another tech.) 
  */

PImage colormap;
PImage funmap;
PImage nightmap;
PImage cyclemap;

float xmotion = 0;
float ymotion = 0;

// quality control
int dots_step = 2;
int elems_step = 1;

// same but look below, these are adjusted in real-time to increase rendering quality by abusing motion blur :)
int elems = 192;
int rect_size = 4;

void draw_planet() {
  float mx = mouseX / 1024.0;
	float my = mouseY / 1024.0;

  // add some motion blur / brightness
  fill(0, 0, 0, 4);
  rect(0, 0, 800, 600);
	
	// here we take advantage of the motion blur to ""fill in the gap"" by adjusting each slices / frames, this increase rendering quality (altough it look hazy)
	elems = 92 + sin(xmotion / 24.) * 36;
	rect_size = 2 + abs(sin(xmotion / 84.)) * 4;
  
  noStroke();
  
  float xoff = 800 / 2;
  
  float sphere_radius = 292;
  float yoff = 600 / 2 - sphere_radius;
  
  for (int s = 0; s < elems; s += elems_step) {
    float de = (float)s / elems;
    
    float bd = max((0.5-abs(de - 0.5)) * 4, 0.05);
    
    float yrepeat = 1;
    int yyd = (((int)(de * (colormap.height * yrepeat))%colormap.height)) * colormap.width;
		
		float tyrepeat = 3;
		int yyd2 = (((int)(de * (funmap.height * tyrepeat) + ymotion)%funmap.height)) * funmap.width;
		
		int yydc = (((int)(de * (cyclemap.height * yrepeat))%cyclemap.height)) * cyclemap.width;
    
    // cartesian circle equation
    float sphere_radius_squared = sphere_radius * sphere_radius;
    float sh_radius = de * (sphere_radius * 2) - sphere_radius;
    float xc_off = sqrt(sphere_radius_squared - sh_radius*sh_radius);
    
    float final_x;
    float final_y = yoff + de * (sphere_radius * 2); // flabby planet bonus : + sin((de * 360 + 180) * (PI / 180) + ymotion / 24.) * 4;
    
    for (int e = 0; e < (int)xc_off; e += dots_step) {
      float dd = (float)e / xc_off;

      final_x = xoff - xc_off + xc_off * dd * 2; // flabby planet bonus : + cos((de * 360 + 180) * (PI / 180) + xmotion / 24.) * 4
      
      float yc_off;
      
      // compute UV texels for the colormap
      if (dd > 0.5) {
        yc_off = sqrt(1 - dd*dd) + 1.270;
      } else {
        float dd2 = 1 - dd;
        
        yc_off = 1-sqrt(1 - dd2*dd2);
      }
      
      // apply colormaps
      float xrepeat = 0.5;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + xmotion)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      // second texture (text mask)
      float txrepeat = 1.;
      
      int xxd2 = ((funmap.width - 1) - (int)(yc_off * (funmap.width * txrepeat) + xmotion)%funmap.width);
 
      int cl2 = (int)xxd2 + yyd2;
      
      int r2 = (int)(red(funmap.pixels[cl2]) * bd);
      int g2 = (int)(green(funmap.pixels[cl2]) * bd);
      int b2 = (int)(blue(funmap.pixels[cl2]) * bd);
      
      // third texture (night version), reuse the first texture UV since they are the same width/height
      int rn = (int)(red(nightmap.pixels[cl]));
      int gn = (int)(green(nightmap.pixels[cl]));
      int bn = (int)(blue(nightmap.pixels[cl]));
      
      // fourth texture (cycle mask), only use single component since it is black/white
      int xxdc = ((cyclemap.width - 1) - (int)(yc_off * (cyclemap.width * xrepeat) + xmotion * 4)%cyclemap.width);
      int clc = (int)xxdc + yydc;
      float rc = red(cyclemap.pixels[clc]) / 255;
      
      float final_r = r * rc + rn * (1 - rc);
      float final_g = g * rc + gn * (1 - rc);
      float final_b = b * rc + bn * (1 - rc);
      
      // some compositing 
      fill(r * (r2 / 255) + final_r, g * (g2 / 255) + final_g, b * (b2 / 255) + final_b, 48);//r * (r2 / 255) + r * bright, g * (g2 / 255) + g * bright, b * (b2 / 255) + b * bright);
      
      //rect(final_x, final_y, rect_size, rect_size);
      // slower but look good!
      ellipse(final_x, final_y, rect_size, rect_size);

/*
      // can improve the look with some kind of ""dithering""
      fill(r, g, b, 255);
      
      float rect_size2 = rect_size / 2;
      rect(final_x - rect_size2, final_y, rect_size2, rect_size2);
      rect(final_x + rect_size2, final_y, rect_size2, rect_size2);
      rect(final_x, final_y - rect_size2, rect_size2, rect_size2);
      rect(final_x, final_y + rect_size2, rect_size2, rect_size2);
*/
    }
  }
  
  xmotion += 0.5;
	ymotion -= 0.25;
}

void setup() {
  size(800, 600);

  frameRate(60); 
  
  colormap = loadImage(""data.jpg"");
  funmap = loadImage(""data2.jpg"");
  nightmap = loadImage(""data_night.jpg"");
  cyclemap = loadImage(""data_cycle.jpg"");
  
  background(0);
}

void draw() {
  //background(0);
 
  draw_planet();
}"
"561044","Earth blur","mySketch","/**
  * Dots planet billboard.
  *
  * A weird idea, started with a cartesian way to draw a circle made of tiny blocks (aka the ""dots"") then expanded by applying a colormap then a second texture which is used as a mask to display the text and then day/night cycle from a mask.
  * Some more ideas : exploding planet (or two planet colliding etc.)
	*
	* There is some issue with the rendering (the vertical slices which should be inversed after half of the circle) but this doesn't affect much the quality
	*
	* This is rather slow on the web and could be optimized even more but run ok with better quality on Processing desktop.
  *
  * Initially wanted to recreate Star Control 2 planets rendering. (but they probably use another tech.) 
  */

PImage colormap;
PImage funmap;
PImage nightmap;
PImage cyclemap;

float xmotion = 0;
float ymotion = 0;

// quality control
int dots_step = 2;
int elems_step = 1;

// same but look below, these are adjusted in real-time to increase rendering quality by abusing motion blur :)
int elems = 192;
int rect_size = 4;

void draw_planet() {
  float mx = mouseX / 1024.0;
	float my = mouseY / 1024.0;

  // add some motion blur / brightness
  fill(0, 0, 0, 4);
  rect(0, 0, 800, 600);
	
	// here we take advantage of the motion blur to ""fill in the gap"" by adjusting each slices / frames, this increase rendering quality (altough it look hazy)
	elems = 92 + sin(xmotion / 24.) * 36;
	rect_size = 2 + abs(sin(xmotion / 84.)) * 4;
  
  noStroke();
  
  float xoff = 800 / 2;
  
  float sphere_radius = 292;
  float yoff = 600 / 2 - sphere_radius;
  
  for (int s = 0; s < elems; s += elems_step) {
    float de = (float)s / elems;
    
    float bd = max((0.5-abs(de - 0.5)) * 4, 0.05);
    
    float yrepeat = 1;
    int yyd = (((int)(de * (colormap.height * yrepeat))%colormap.height)) * colormap.width;
		
		float tyrepeat = 3;
		int yyd2 = (((int)(de * (funmap.height * tyrepeat) + ymotion)%funmap.height)) * funmap.width;
		
		int yydc = (((int)(de * (cyclemap.height * yrepeat))%cyclemap.height)) * cyclemap.width;
    
    // cartesian circle equation
    float sphere_radius_squared = sphere_radius * sphere_radius;
    float sh_radius = de * (sphere_radius * 2) - sphere_radius;
    float xc_off = sqrt(sphere_radius_squared - sh_radius*sh_radius);
    
    float final_x;
    float final_y = yoff + de * (sphere_radius * 2); // flabby planet bonus : + sin((de * 360 + 180) * (PI / 180) + ymotion / 24.) * 4;
    
    for (int e = 0; e < (int)xc_off; e += dots_step) {
      float dd = (float)e / xc_off;

      final_x = xoff - xc_off + xc_off * dd * 2; // flabby planet bonus : + cos((de * 360 + 180) * (PI / 180) + xmotion / 24.) * 4
      
      float yc_off;
      
      // compute UV texels for the colormap
      if (dd > 0.5) {
        yc_off = sqrt(1 - dd*dd) + 1.270;
      } else {
        float dd2 = 1 - dd;
        
        yc_off = 1-sqrt(1 - dd2*dd2);
      }
      
      // apply colormaps
      float xrepeat = 0.5;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + xmotion)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      // second texture (text mask)
      float txrepeat = 1.;
      
      int xxd2 = ((funmap.width - 1) - (int)(yc_off * (funmap.width * txrepeat) + xmotion)%funmap.width);
 
      int cl2 = (int)xxd2 + yyd2;
      
      int r2 = (int)(red(funmap.pixels[cl2]) * bd);
      int g2 = (int)(green(funmap.pixels[cl2]) * bd);
      int b2 = (int)(blue(funmap.pixels[cl2]) * bd);
      
      // third texture (night version), reuse the first texture UV since they are the same width/height
      int rn = (int)(red(nightmap.pixels[cl]));
      int gn = (int)(green(nightmap.pixels[cl]));
      int bn = (int)(blue(nightmap.pixels[cl]));
      
      // fourth texture (cycle mask), only use single component since it is black/white
      int xxdc = ((cyclemap.width - 1) - (int)(yc_off * (cyclemap.width * xrepeat) + xmotion * 4)%cyclemap.width);
      int clc = (int)xxdc + yydc;
      float rc = red(cyclemap.pixels[clc]) / 255;
      
      float final_r = r * rc + rn * (1 - rc);
      float final_g = g * rc + gn * (1 - rc);
      float final_b = b * rc + bn * (1 - rc);
      
      // some compositing 
      fill(r * (r2 / 255) + final_r, g * (g2 / 255) + final_g, b * (b2 / 255) + final_b, 48);//r * (r2 / 255) + r * bright, g * (g2 / 255) + g * bright, b * (b2 / 255) + b * bright);
      
      //rect(final_x, final_y, rect_size, rect_size);
      // slower but look good!
      ellipse(final_x, final_y, rect_size, rect_size);

/*
      // can improve the look with some kind of ""dithering""
      fill(r, g, b, 255);
      
      float rect_size2 = rect_size / 2;
      rect(final_x - rect_size2, final_y, rect_size2, rect_size2);
      rect(final_x + rect_size2, final_y, rect_size2, rect_size2);
      rect(final_x, final_y - rect_size2, rect_size2, rect_size2);
      rect(final_x, final_y + rect_size2, rect_size2, rect_size2);
*/
    }
  }
  
  xmotion += 0.5;
	ymotion += 0.25;
}

void setup() {
  size(800, 600);

  frameRate(60); 
  
  colormap = loadImage(""data.jpg"");
  funmap = loadImage(""data2.jpg"");
  nightmap = loadImage(""data_night.jpg"");
  cyclemap = loadImage(""data_cycle.jpg"");
  
  background(0);
}

void draw() {
  //background(0);
 
  draw_planet();
}"
"561040","Dots planet billboard","mySketch","/**
  * Dots planet billboard.
  *
  * A weird idea, started with a cartesian way to draw a circle made of tiny blocks (aka the ""dots"") then expanded by applying a colormap then a second texture which is used as a mask to display the text and then day/night cycle from a mask.
  * Some more ideas : exploding planet (or two planet colliding etc.)
  *
  * Initially wanted to recreate Star Control 2 planets rendering. (but they probably use another tech.) 
  */

PImage colormap;
PImage funmap;
PImage nightmap;
PImage cyclemap;

float xmotion = 0;
float ymotion = 0;
float rmotion = 0;

int elems = 192;

int dots_step = 1;
int elems_step = 1;

void draw_planet() {
  int rect_size = 2;
  
  // add some motion blur / brightness
  fill(0, 0, 0, 4);
  rect(0, 0, 1024, 700);
  
  noStroke();
  
  float xoff = 1024 / 2;
  
  float sphere_radius = 256;
  float yoff = 700 / 2 - sphere_radius;
  
  for (int s = 0; s < elems; s += elems_step) {
    float de = (float)s / elems;
    
    float bd = max((0.5-abs(de - 0.5)) * 4, 0.05);
    
    float yrepeat = 1;
    int yyd = (((int)(de * (colormap.height * yrepeat))%colormap.height)) * colormap.width;
    
    // cartesian circle equation
    float sphere_radius_squared = sphere_radius * sphere_radius;
    float sh_radius = de * (sphere_radius * 2) - sphere_radius;
    float xc_off = sqrt(sphere_radius_squared - sh_radius*sh_radius);
    
    float final_x;
    float final_y = yoff + de * (sphere_radius * 2); // flabby planet bonus : + sin((de * 360 + 180) * (PI / 180) + ymotion / 24.) * 4;
    
    for (int e = 0; e < (int)xc_off; e += dots_step) {
      float dd = (float)e / xc_off;

      final_x = xoff - xc_off + xc_off * dd * 2; // flabby planet bonus : + cos((de * 360 + 180) * (PI / 180) + xmotion / 24.) * 4
      
      float yc_off;
      
      // compute UV texels for the colormap
      if (dd > 0.5) {
        yc_off = sqrt(1 - dd*dd) + 1.270 - (mouseX / 1024 / 25.0);
      } else {
        float dd2 = 1 - dd;
        
        yc_off = 1-sqrt(1 - dd2*dd2);
      }
      
      // apply colormaps
      float xrepeat = 0.5;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + xmotion)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      // second texture (text mask)
      float tyrepeat = 8;
      float txrepeat = 1.;
      int yyd2 = (((int)(de * (funmap.height * tyrepeat) + ymotion)%funmap.height)) * funmap.width;
      int xxd2 = ((funmap.width - 1) - (int)(yc_off * (funmap.width * txrepeat) + xmotion)%funmap.width);
 
      int cl2 = (int)xxd2 + yyd2;
      
      int r2 = (int)(red(funmap.pixels[cl2]) * bd);
      int g2 = (int)(green(funmap.pixels[cl2]) * bd);
      int b2 = (int)(blue(funmap.pixels[cl2]) * bd);
      
      // third texture (night version), reuse the first texture UV since they are the same width/height
      int rn = (int)(red(nightmap.pixels[cl]));
      int gn = (int)(green(nightmap.pixels[cl]));
      int bn = (int)(blue(nightmap.pixels[cl]));
      
      // fourth texture (cycle mask), only use single component since it is black/white
      int xxdc = ((cyclemap.width - 1) - (int)(yc_off * (cyclemap.width * xrepeat) + xmotion * 4)%cyclemap.width);
      int yydc = (((int)(de * (cyclemap.height * yrepeat))%cyclemap.height)) * cyclemap.width;
      int clc = (int)xxdc + yydc;
      float rc = red(cyclemap.pixels[clc]) / 255;
      
      float sunbright = abs(sin(xmotion / 8000 + dd));
      
      float final_r = r * rc + rn * (1 - rc);
      float final_g = g * rc + gn * (1 - rc);
      float final_b = b * rc + bn * (1 - rc);
      
      // some compositing 
      fill(r * (r2 / 255) + final_r * sunbright, g * (g2 / 255) + final_g * sunbright, b * (b2 / 255) + final_b * sunbright);//r * (r2 / 255) + r * bright, g * (g2 / 255) + g * bright, b * (b2 / 255) + b * bright);
      
      rect(final_x, final_y, rect_size, rect_size);
      // slower but look good!
      //ellipse(final_x, final_y, rect_size, rect_size);

/*
      // can improve the look with some kind of dithering
      fill(r, g, b, 255);
      
      float rect_size2 = rect_size / 2;
      rect(final_x - rect_size2, final_y, rect_size2, rect_size2);
      rect(final_x + rect_size2, final_y, rect_size2, rect_size2);
      rect(final_x, final_y - rect_size2, rect_size2, rect_size2);
      rect(final_x, final_y + rect_size2, rect_size2, rect_size2);
*/
    }
  }
  
  xmotion += 0.5;
  ymotion += 0.25;
  rmotion += 0.012;
}

void setup() {
  size(1024, 700);

  frameRate(60); 
  
  colormap = loadImage(""data.jpg"");
  funmap = loadImage(""data2.jpg"");
  nightmap = loadImage(""data_night.jpg"");
  cyclemap = loadImage(""data_cycle.jpg"");
  
  textAlign(CENTER, TOP);

  background(0);
}

void draw() {
  //background(0);
 
  draw_planet();
}"
"561040","Dots planet billboard","mySketch","/**
  * Dots planet billboard.
  *
  * A weird idea, started with a cartesian way to draw a circle made of tiny blocks (aka the ""dots"") then expanded by applying a colormap then a second texture which is used as a mask to display the text and then day/night cycle from a mask.
  * Some more ideas : exploding planet (or two planet colliding etc.)
	*
	* This is rather slow on the web and could be optimized even more but run ok with better quality on Processing desktop.
  *
  * Initially wanted to recreate Star Control 2 planets rendering. (but they probably use another tech.) 
  */

PImage colormap;
PImage funmap;
PImage nightmap;
PImage cyclemap;

float xmotion = 0;
float ymotion = 0;

int elems = 192;

// quality control
int dots_step = 2;
int elems_step = 2;
int rect_size = 4;

void draw_planet() {
  
  // add some motion blur / brightness
  fill(0, 0, 0, 4);
  rect(0, 0, 800, 600);
  
  noStroke();
  
  float xoff = 800 / 2;
  
  float sphere_radius = 256;
  float yoff = 600 / 2 - sphere_radius;
  
  for (int s = 0; s < elems; s += elems_step) {
    float de = (float)s / elems;
    
    float bd = max((0.5-abs(de - 0.5)) * 4, 0.05);
    
    float yrepeat = 1;
    int yyd = (((int)(de * (colormap.height * yrepeat))%colormap.height)) * colormap.width;
		
		float tyrepeat = 8;
		int yyd2 = (((int)(de * (funmap.height * tyrepeat) + ymotion)%funmap.height)) * funmap.width;
		
		int yydc = (((int)(de * (cyclemap.height * yrepeat))%cyclemap.height)) * cyclemap.width;
    
    // cartesian circle equation
    float sphere_radius_squared = sphere_radius * sphere_radius;
    float sh_radius = de * (sphere_radius * 2) - sphere_radius;
    float xc_off = sqrt(sphere_radius_squared - sh_radius*sh_radius);
    
    float final_x;
    float final_y = yoff + de * (sphere_radius * 2); // flabby planet bonus : + sin((de * 360 + 180) * (PI / 180) + ymotion / 24.) * 4;
    
    for (int e = 0; e < (int)xc_off; e += dots_step) {
      float dd = (float)e / xc_off;

      final_x = xoff - xc_off + xc_off * dd * 2; // flabby planet bonus : + cos((de * 360 + 180) * (PI / 180) + xmotion / 24.) * 4
      
      float yc_off;
      
      // compute UV texels for the colormap
      if (dd > 0.5) {
        yc_off = sqrt(1 - dd*dd) + 1.270;
      } else {
        float dd2 = 1 - dd;
        
        yc_off = 1-sqrt(1 - dd2*dd2);
      }
      
      // apply colormaps
      float xrepeat = 0.5;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + xmotion)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      // second texture (text mask)
      float txrepeat = 1.;
      
      int xxd2 = ((funmap.width - 1) - (int)(yc_off * (funmap.width * txrepeat) + xmotion)%funmap.width);
 
      int cl2 = (int)xxd2 + yyd2;
      
      int r2 = (int)(red(funmap.pixels[cl2]) * bd);
      int g2 = (int)(green(funmap.pixels[cl2]) * bd);
      int b2 = (int)(blue(funmap.pixels[cl2]) * bd);
      
      // third texture (night version), reuse the first texture UV since they are the same width/height
      int rn = (int)(red(nightmap.pixels[cl]));
      int gn = (int)(green(nightmap.pixels[cl]));
      int bn = (int)(blue(nightmap.pixels[cl]));
      
      // fourth texture (cycle mask), only use single component since it is black/white
      int xxdc = ((cyclemap.width - 1) - (int)(yc_off * (cyclemap.width * xrepeat) + xmotion * 4)%cyclemap.width);
      int clc = (int)xxdc + yydc;
      float rc = red(cyclemap.pixels[clc]) / 255;
      
      float final_r = r * rc + rn * (1 - rc);
      float final_g = g * rc + gn * (1 - rc);
      float final_b = b * rc + bn * (1 - rc);
      
      // some compositing 
      fill(r * (r2 / 255) + final_r, g * (g2 / 255) + final_g, b * (b2 / 255) + final_b);//r * (r2 / 255) + r * bright, g * (g2 / 255) + g * bright, b * (b2 / 255) + b * bright);
      
      rect(final_x, final_y, rect_size, rect_size);
      // slower but look good!
      //ellipse(final_x, final_y, rect_size, rect_size);

/*
      // can improve the look with some kind of ""dithering""
      fill(r, g, b, 255);
      
      float rect_size2 = rect_size / 2;
      rect(final_x - rect_size2, final_y, rect_size2, rect_size2);
      rect(final_x + rect_size2, final_y, rect_size2, rect_size2);
      rect(final_x, final_y - rect_size2, rect_size2, rect_size2);
      rect(final_x, final_y + rect_size2, rect_size2, rect_size2);
*/
    }
  }
  
  xmotion += 0.5;
	ymotion -= 0.25;
}

void setup() {
  size(800, 600);

  frameRate(60); 
  
  colormap = loadImage(""data.jpg"");
  funmap = loadImage(""data2.jpg"");
  nightmap = loadImage(""data_night.jpg"");
  cyclemap = loadImage(""data_cycle.jpg"");
  
  background(0);
}

void draw() {
  //background(0);
 
  draw_planet();
}"
"561040","Dots planet billboard","mySketch","/**
  * Dots planet billboard.
  *
  * A weird idea, started with a cartesian way to draw a circle made of tiny blocks (aka the ""dots"") then expanded by applying a colormap then a second texture which is used as a mask to display the text and then day/night cycle from a mask.
  * Some more ideas : exploding planet (or two planet colliding etc.)
	*
	* This is rather slow on the web and could be optimized even more but run ok with better quality on Processing desktop.
  *
  * Initially wanted to recreate Star Control 2 planets rendering. (but they probably use another tech.) 
  */

PImage colormap;
PImage funmap;
PImage nightmap;
PImage cyclemap;

float xmotion = 0;
float ymotion = 0;

int elems = 192;

// quality control
int dots_step = 2;
int elems_step = 2;
int rect_size = 4;

void draw_planet() {
  
  // add some motion blur / brightness
  fill(0, 0, 0, 4);
  rect(0, 0, 800, 600);
  
  noStroke();
  
  float xoff = 800 / 2;
  
  float sphere_radius = 256;
  float yoff = 600 / 2 - sphere_radius;
  
  for (int s = 0; s < elems; s += elems_step) {
    float de = (float)s / elems;
    
    float bd = max((0.5-abs(de - 0.5)) * 4, 0.05);
    
    float yrepeat = 1;
    int yyd = (((int)(de * (colormap.height * yrepeat))%colormap.height)) * colormap.width;
		
		float tyrepeat = 4;
		int yyd2 = (((int)(de * (funmap.height * tyrepeat) + ymotion)%funmap.height)) * funmap.width;
		
		int yydc = (((int)(de * (cyclemap.height * yrepeat))%cyclemap.height)) * cyclemap.width;
    
    // cartesian circle equation
    float sphere_radius_squared = sphere_radius * sphere_radius;
    float sh_radius = de * (sphere_radius * 2) - sphere_radius;
    float xc_off = sqrt(sphere_radius_squared - sh_radius*sh_radius);
    
    float final_x;
    float final_y = yoff + de * (sphere_radius * 2); // flabby planet bonus : + sin((de * 360 + 180) * (PI / 180) + ymotion / 24.) * 4;
    
    for (int e = 0; e < (int)xc_off; e += dots_step) {
      float dd = (float)e / xc_off;

      final_x = xoff - xc_off + xc_off * dd * 2; // flabby planet bonus : + cos((de * 360 + 180) * (PI / 180) + xmotion / 24.) * 4
      
      float yc_off;
      
      // compute UV texels for the colormap
      if (dd > 0.5) {
        yc_off = sqrt(1 - dd*dd) + 1.270;
      } else {
        float dd2 = 1 - dd;
        
        yc_off = 1-sqrt(1 - dd2*dd2);
      }
      
      // apply colormaps
      float xrepeat = 0.5;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + xmotion)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      // second texture (text mask)
      float txrepeat = 1.;
      
      int xxd2 = ((funmap.width - 1) - (int)(yc_off * (funmap.width * txrepeat) + xmotion)%funmap.width);
 
      int cl2 = (int)xxd2 + yyd2;
      
      int r2 = (int)(red(funmap.pixels[cl2]) * bd);
      int g2 = (int)(green(funmap.pixels[cl2]) * bd);
      int b2 = (int)(blue(funmap.pixels[cl2]) * bd);
      
      // third texture (night version), reuse the first texture UV since they are the same width/height
      int rn = (int)(red(nightmap.pixels[cl]));
      int gn = (int)(green(nightmap.pixels[cl]));
      int bn = (int)(blue(nightmap.pixels[cl]));
      
      // fourth texture (cycle mask), only use single component since it is black/white
      int xxdc = ((cyclemap.width - 1) - (int)(yc_off * (cyclemap.width * xrepeat) + xmotion * 4)%cyclemap.width);
      int clc = (int)xxdc + yydc;
      float rc = red(cyclemap.pixels[clc]) / 255;
      
      float final_r = r * rc + rn * (1 - rc);
      float final_g = g * rc + gn * (1 - rc);
      float final_b = b * rc + bn * (1 - rc);
      
      // some compositing 
      fill(r * (r2 / 255) + final_r, g * (g2 / 255) + final_g, b * (b2 / 255) + final_b);//r * (r2 / 255) + r * bright, g * (g2 / 255) + g * bright, b * (b2 / 255) + b * bright);
      
      //rect(final_x, final_y, rect_size, rect_size);
      // slower but look good!
      ellipse(final_x, final_y, rect_size, rect_size);

/*
      // can improve the look with some kind of ""dithering""
      fill(r, g, b, 255);
      
      float rect_size2 = rect_size / 2;
      rect(final_x - rect_size2, final_y, rect_size2, rect_size2);
      rect(final_x + rect_size2, final_y, rect_size2, rect_size2);
      rect(final_x, final_y - rect_size2, rect_size2, rect_size2);
      rect(final_x, final_y + rect_size2, rect_size2, rect_size2);
*/
    }
  }
  
  xmotion += 0.5;
	ymotion -= 0.25;
}

void setup() {
  size(800, 600);

  frameRate(60); 
  
  colormap = loadImage(""data.jpg"");
  funmap = loadImage(""data2.jpg"");
  nightmap = loadImage(""data_night.jpg"");
  cyclemap = loadImage(""data_cycle.jpg"");
  
  background(0);
}

void draw() {
  //background(0);
 
  draw_planet();
}"
"561040","Dots planet billboard","mySketch","/**
  * Dots planet billboard.
  *
  * A weird idea, started with a cartesian way to draw a circle made of tiny blocks (aka the ""dots"") then expanded by applying a colormap then a second texture which is used as a mask to display the text and then day/night cycle from a mask.
  * Some more ideas : exploding planet (or two planet colliding etc.)
	*
	* This is rather slow on the web and could be optimized even more but run ok with better quality on Processing desktop.
  *
  * Initially wanted to recreate Star Control 2 planets rendering. (but they probably use another tech.) 
  */

PImage colormap;
PImage funmap;
PImage nightmap;
PImage cyclemap;

float xmotion = 0;
float ymotion = 0;

int elems = 192;

// quality control
int dots_step = 2;
int elems_step = 2;
int rect_size = 4;

void draw_planet() {
  
  // add some motion blur / brightness
  fill(0, 0, 0, 4);
  rect(0, 0, 800, 600);
  
  noStroke();
  
  float xoff = 800 / 2;
  
  float sphere_radius = 292;
  float yoff = 600 / 2 - sphere_radius;
  
  for (int s = 0; s < elems; s += elems_step) {
    float de = (float)s / elems;
    
    float bd = max((0.5-abs(de - 0.5)) * 4, 0.05);
    
    float yrepeat = 1;
    int yyd = (((int)(de * (colormap.height * yrepeat))%colormap.height)) * colormap.width;
		
		float tyrepeat = 4;
		int yyd2 = (((int)(de * (funmap.height * tyrepeat) + ymotion)%funmap.height)) * funmap.width;
		
		int yydc = (((int)(de * (cyclemap.height * yrepeat))%cyclemap.height)) * cyclemap.width;
    
    // cartesian circle equation
    float sphere_radius_squared = sphere_radius * sphere_radius;
    float sh_radius = de * (sphere_radius * 2) - sphere_radius;
    float xc_off = sqrt(sphere_radius_squared - sh_radius*sh_radius);
    
    float final_x;
    float final_y = yoff + de * (sphere_radius * 2); // flabby planet bonus : + sin((de * 360 + 180) * (PI / 180) + ymotion / 24.) * 4;
    
    for (int e = 0; e < (int)xc_off; e += dots_step) {
      float dd = (float)e / xc_off;

      final_x = xoff - xc_off + xc_off * dd * 2; // flabby planet bonus : + cos((de * 360 + 180) * (PI / 180) + xmotion / 24.) * 4
      
      float yc_off;
      
      // compute UV texels for the colormap
      if (dd > 0.5) {
        yc_off = sqrt(1 - dd*dd) + 1.270;
      } else {
        float dd2 = 1 - dd;
        
        yc_off = 1-sqrt(1 - dd2*dd2);
      }
      
      // apply colormaps
      float xrepeat = 0.5;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + xmotion)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      // second texture (text mask)
      float txrepeat = 1.;
      
      int xxd2 = ((funmap.width - 1) - (int)(yc_off * (funmap.width * txrepeat) + xmotion)%funmap.width);
 
      int cl2 = (int)xxd2 + yyd2;
      
      int r2 = (int)(red(funmap.pixels[cl2]) * bd);
      int g2 = (int)(green(funmap.pixels[cl2]) * bd);
      int b2 = (int)(blue(funmap.pixels[cl2]) * bd);
      
      // third texture (night version), reuse the first texture UV since they are the same width/height
      int rn = (int)(red(nightmap.pixels[cl]));
      int gn = (int)(green(nightmap.pixels[cl]));
      int bn = (int)(blue(nightmap.pixels[cl]));
      
      // fourth texture (cycle mask), only use single component since it is black/white
      int xxdc = ((cyclemap.width - 1) - (int)(yc_off * (cyclemap.width * xrepeat) + xmotion * 4)%cyclemap.width);
      int clc = (int)xxdc + yydc;
      float rc = red(cyclemap.pixels[clc]) / 255;
      
      float final_r = r * rc + rn * (1 - rc);
      float final_g = g * rc + gn * (1 - rc);
      float final_b = b * rc + bn * (1 - rc);
      
      // some compositing 
      fill(r * (r2 / 255) + final_r, g * (g2 / 255) + final_g, b * (b2 / 255) + final_b);//r * (r2 / 255) + r * bright, g * (g2 / 255) + g * bright, b * (b2 / 255) + b * bright);
      
      //rect(final_x, final_y, rect_size, rect_size);
      // slower but look good!
      ellipse(final_x, final_y, rect_size, rect_size);

/*
      // can improve the look with some kind of ""dithering""
      fill(r, g, b, 255);
      
      float rect_size2 = rect_size / 2;
      rect(final_x - rect_size2, final_y, rect_size2, rect_size2);
      rect(final_x + rect_size2, final_y, rect_size2, rect_size2);
      rect(final_x, final_y - rect_size2, rect_size2, rect_size2);
      rect(final_x, final_y + rect_size2, rect_size2, rect_size2);
*/
    }
  }
  
  xmotion += 0.5;
	ymotion -= 0.25;
}

void setup() {
  size(800, 600);

  frameRate(60); 
  
  colormap = loadImage(""data.jpg"");
  funmap = loadImage(""data2.jpg"");
  nightmap = loadImage(""data_night.jpg"");
  cyclemap = loadImage(""data_cycle.jpg"");
  
  background(0);
}

void draw() {
  //background(0);
 
  draw_planet();
}"
"561040","Dots planet billboard","mySketch","/**
  * Dots planet billboard.
  *
  * A weird idea, started with a cartesian way to draw a circle made of tiny blocks (aka the ""dots"") then expanded by applying a colormap then a second texture which is used as a mask to display the text and then day/night cycle from a mask.
  * Some more ideas : exploding planet (or two planet colliding etc.)
	*
	* There is some issue with the rendering (the vertical slices which should be inversed after half of the circle) but this doesn't affect much the quality
	*
	* This is rather slow on the web and could be optimized even more but run ok with better quality on Processing desktop.
  *
  * Initially wanted to recreate Star Control 2 planets rendering. (but they probably use another tech.) 
  */

PImage colormap;
PImage funmap;
PImage nightmap;
PImage cyclemap;

float xmotion = 0;
float ymotion = 0;

// quality control
int dots_step = 2;
int elems_step = 2;

// same but look below, these are adjusted in real-time to increase rendering quality by abusing motion blur :)
int elems = 192;
int rect_size = 4;

void draw_planet() {
  float mx = mouseX / 1024.0;
	float my = mouseY / 1024.0;
	
	elems_step = 1 + mx * 6.0;
	dots_step = 1 + my * 2.0;

  // add some motion blur / brightness
  fill(0, 0, 0, 4);
  rect(0, 0, 800, 600);
	
	// here we take advantage of the motion blur to ""fill in the gap"" by adjusting each slices / frames, this increase rendering quality (altough it look hazy)
	elems = 92 + sin(xmotion / 24.) * 36;
	rect_size = 2 + abs(sin(xmotion / 84.)) * 4;
  
  noStroke();
  
  float xoff = 800 / 2;
  
  float sphere_radius = 292;
  float yoff = 600 / 2 - sphere_radius;
  
  for (int s = 0; s < elems; s += elems_step) {
    float de = (float)s / elems;
    
    float bd = max((0.5-abs(de - 0.5)) * 4, 0.05);
    
    float yrepeat = 1;
    int yyd = (((int)(de * (colormap.height * yrepeat))%colormap.height)) * colormap.width;
		
		float tyrepeat = 4;
		int yyd2 = (((int)(de * (funmap.height * tyrepeat) + ymotion)%funmap.height)) * funmap.width;
		
		int yydc = (((int)(de * (cyclemap.height * yrepeat))%cyclemap.height)) * cyclemap.width;
    
    // cartesian circle equation
    float sphere_radius_squared = sphere_radius * sphere_radius;
    float sh_radius = de * (sphere_radius * 2) - sphere_radius;
    float xc_off = sqrt(sphere_radius_squared - sh_radius*sh_radius);
    
    float final_x;
    float final_y = yoff + de * (sphere_radius * 2); // flabby planet bonus : + sin((de * 360 + 180) * (PI / 180) + ymotion / 24.) * 4;
    
    for (int e = 0; e < (int)xc_off; e += dots_step) {
      float dd = (float)e / xc_off;

      final_x = xoff - xc_off + xc_off * dd * 2; // flabby planet bonus : + cos((de * 360 + 180) * (PI / 180) + xmotion / 24.) * 4
      
      float yc_off;
      
      // compute UV texels for the colormap
      if (dd > 0.5) {
        yc_off = sqrt(1 - dd*dd) + 1.270;
      } else {
        float dd2 = 1 - dd;
        
        yc_off = 1-sqrt(1 - dd2*dd2);
      }
      
      // apply colormaps
      float xrepeat = 0.5;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + xmotion)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      // second texture (text mask)
      float txrepeat = 1.;
      
      int xxd2 = ((funmap.width - 1) - (int)(yc_off * (funmap.width * txrepeat) + xmotion)%funmap.width);
 
      int cl2 = (int)xxd2 + yyd2;
      
      int r2 = (int)(red(funmap.pixels[cl2]) * bd);
      int g2 = (int)(green(funmap.pixels[cl2]) * bd);
      int b2 = (int)(blue(funmap.pixels[cl2]) * bd);
      
      // third texture (night version), reuse the first texture UV since they are the same width/height
      int rn = (int)(red(nightmap.pixels[cl]));
      int gn = (int)(green(nightmap.pixels[cl]));
      int bn = (int)(blue(nightmap.pixels[cl]));
      
      // fourth texture (cycle mask), only use single component since it is black/white
      int xxdc = ((cyclemap.width - 1) - (int)(yc_off * (cyclemap.width * xrepeat) + xmotion * 4)%cyclemap.width);
      int clc = (int)xxdc + yydc;
      float rc = red(cyclemap.pixels[clc]) / 255;
      
      float final_r = r * rc + rn * (1 - rc);
      float final_g = g * rc + gn * (1 - rc);
      float final_b = b * rc + bn * (1 - rc);
      
      // some compositing 
      fill(r * (r2 / 255) + final_r, g * (g2 / 255) + final_g, b * (b2 / 255) + final_b);//r * (r2 / 255) + r * bright, g * (g2 / 255) + g * bright, b * (b2 / 255) + b * bright);
      
      //rect(final_x, final_y, rect_size, rect_size);
      // slower but look good!
      ellipse(final_x, final_y, rect_size, rect_size);

/*
      // can improve the look with some kind of ""dithering""
      fill(r, g, b, 255);
      
      float rect_size2 = rect_size / 2;
      rect(final_x - rect_size2, final_y, rect_size2, rect_size2);
      rect(final_x + rect_size2, final_y, rect_size2, rect_size2);
      rect(final_x, final_y - rect_size2, rect_size2, rect_size2);
      rect(final_x, final_y + rect_size2, rect_size2, rect_size2);
*/
    }
  }
  
  xmotion += 0.5;
	ymotion -= 0.25;
}

void setup() {
  size(800, 600);

  frameRate(60); 
  
  colormap = loadImage(""data.jpg"");
  funmap = loadImage(""data2.jpg"");
  nightmap = loadImage(""data_night.jpg"");
  cyclemap = loadImage(""data_cycle.jpg"");
  
  background(0);
}

void draw() {
  //background(0);
 
  draw_planet();
}"
"561040","Dots planet billboard","mySketch","/**
  * Dots planet billboard.
  *
  * A weird idea, started with a cartesian way to draw a circle made of tiny blocks (aka the ""dots"") then expanded by applying a colormap then a second texture which is used as a mask to display the text and then day/night cycle from a mask.
  * Some more ideas : exploding planet (or two planet colliding etc.)
	*
	* There is some issue with the rendering (the vertical slices which should be inversed after half of the circle) but this doesn't affect much the quality
	*
	* This is rather slow on the web and could be optimized even more but run ok with better quality on Processing desktop.
  *
  * Initially wanted to recreate Star Control 2 planets rendering. (but they probably use another tech.) 
  */

PImage colormap;
PImage funmap;
PImage nightmap;
PImage cyclemap;

float xmotion = 0;
float ymotion = 0;

// quality control
int dots_step = 2;
int elems_step = 2;

// same but look below, these are adjusted in real-time to increase rendering quality by abusing motion blur :)
int elems = 192;
int rect_size = 4;

void draw_planet() {
  float mx = mouseX / 1024.0;
	float my = mouseY / 1024.0;
	
	elems_step = 1 + mx * 6.0;
	dots_step = 1 + my * 2.0;

  // add some motion blur / brightness
  fill(0, 0, 0, 4);
  rect(0, 0, 800, 600);
	
	// here we take advantage of the motion blur to ""fill in the gap"" by adjusting each slices / frames, this increase rendering quality (altough it look hazy)
	elems = 92 + sin(xmotion / 24.) * 36;
	rect_size = 2 + abs(sin(xmotion / 84.)) * 4;
  
  noStroke();
  
  float xoff = 800 / 2;
  
  float sphere_radius = 292;
  float yoff = 600 / 2 - sphere_radius;
  
  for (int s = 0; s < elems; s += elems_step) {
    float de = (float)s / elems;
    
    float bd = max((0.5-abs(de - 0.5)) * 4, 0.05);
    
    float yrepeat = 1;
    int yyd = (((int)(de * (colormap.height * yrepeat))%colormap.height)) * colormap.width;
		
		float tyrepeat = 4;
		int yyd2 = (((int)(de * (funmap.height * tyrepeat) + ymotion)%funmap.height)) * funmap.width;
		
		int yydc = (((int)(de * (cyclemap.height * yrepeat))%cyclemap.height)) * cyclemap.width;
    
    // cartesian circle equation
    float sphere_radius_squared = sphere_radius * sphere_radius;
    float sh_radius = de * (sphere_radius * 2) - sphere_radius;
    float xc_off = sqrt(sphere_radius_squared - sh_radius*sh_radius);
    
    float final_x;
    float final_y = yoff + de * (sphere_radius * 2); // flabby planet bonus : + sin((de * 360 + 180) * (PI / 180) + ymotion / 24.) * 4;
    
    for (int e = 0; e < (int)xc_off; e += dots_step) {
      float dd = (float)e / xc_off;

      final_x = xoff - xc_off + xc_off * dd * 2; // flabby planet bonus : + cos((de * 360 + 180) * (PI / 180) + xmotion / 24.) * 4
      
      float yc_off;
      
      // compute UV texels for the colormap
      if (dd > 0.5) {
        yc_off = sqrt(1 - dd*dd) + 1.270;
      } else {
        float dd2 = 1 - dd;
        
        yc_off = 1-sqrt(1 - dd2*dd2);
      }
      
      // apply colormaps
      float xrepeat = 0.5;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + xmotion)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      // second texture (text mask)
      float txrepeat = 1.;
      
      int xxd2 = ((funmap.width - 1) - (int)(yc_off * (funmap.width * txrepeat) + xmotion)%funmap.width);
 
      int cl2 = (int)xxd2 + yyd2;
      
      int r2 = (int)(red(funmap.pixels[cl2]) * bd);
      int g2 = (int)(green(funmap.pixels[cl2]) * bd);
      int b2 = (int)(blue(funmap.pixels[cl2]) * bd);
      
      // third texture (night version), reuse the first texture UV since they are the same width/height
      int rn = (int)(red(nightmap.pixels[cl]));
      int gn = (int)(green(nightmap.pixels[cl]));
      int bn = (int)(blue(nightmap.pixels[cl]));
      
      // fourth texture (cycle mask), only use single component since it is black/white
      int xxdc = ((cyclemap.width - 1) - (int)(yc_off * (cyclemap.width * xrepeat) + xmotion * 4)%cyclemap.width);
      int clc = (int)xxdc + yydc;
      float rc = red(cyclemap.pixels[clc]) / 255;
      
      float final_r = r * rc + rn * (1 - rc);
      float final_g = g * rc + gn * (1 - rc);
      float final_b = b * rc + bn * (1 - rc);
      
      // some compositing 
      fill(r * (r2 / 255) + final_r, g * (g2 / 255) + final_g, b * (b2 / 255) + final_b);//r * (r2 / 255) + r * bright, g * (g2 / 255) + g * bright, b * (b2 / 255) + b * bright);
      
      //rect(final_x, final_y, rect_size, rect_size);
      // slower but look good!
      ellipse(final_x, final_y, rect_size, rect_size);

/*
      // can improve the look with some kind of ""dithering""
      fill(r, g, b, 255);
      
      float rect_size2 = rect_size / 2;
      rect(final_x - rect_size2, final_y, rect_size2, rect_size2);
      rect(final_x + rect_size2, final_y, rect_size2, rect_size2);
      rect(final_x, final_y - rect_size2, rect_size2, rect_size2);
      rect(final_x, final_y + rect_size2, rect_size2, rect_size2);
*/
    }
  }
  
  xmotion += 0.5;
	ymotion -= 0.25;
}

void setup() {
  size(800, 600);

  frameRate(60); 
  
  colormap = loadImage(""data.jpg"");
  funmap = loadImage(""data2.jpg"");
  nightmap = loadImage(""data_night.jpg"");
  cyclemap = loadImage(""data_cycle.jpg"");
  
  background(0);
}

void draw() {
  //background(0);
 
  draw_planet();
}"
"561040","Dots planet billboard","mySketch","/**
  * Dots planet billboard.
  *
  * A weird idea, started with a cartesian way to draw a circle made of tiny blocks (aka the ""dots"") then expanded by applying a colormap then a second texture which is used as a mask to display the text and then day/night cycle from a mask.
  * Some more ideas : exploding planet (or two planet colliding etc.)
	*
	* There is some issue with the rendering (the vertical slices which should be inversed after half of the circle) but this doesn't affect much the quality
	*
	* This is rather slow on the web and could be optimized even more but run ok with better quality on Processing desktop.
  *
  * Initially wanted to recreate Star Control 2 planets rendering. (but they probably use another tech.) 
  */

PImage colormap;
PImage funmap;
PImage nightmap;
PImage cyclemap;

float xmotion = 0;
float ymotion = 0;

// quality control
int dots_step = 2;
int elems_step = 2;

// same but look below, these are adjusted in real-time to increase rendering quality by abusing motion blur :)
int elems = 192;
int rect_size = 4;

void draw_planet() {
  float mx = mouseX / 1024.0;
	float my = mouseY / 1024.0;
	
	elems_step = 1 + mx * 6.0;
	dots_step = 1 + my * 2.0;

  // add some motion blur / brightness
  fill(0, 0, 0, 4);
  rect(0, 0, 800, 600);
	
	// here we take advantage of the motion blur to ""fill in the gap"" by adjusting each slices / frames, this increase rendering quality (altough it look hazy)
	elems = 92 + sin(xmotion / 24.) * 36;
	rect_size = 2 + abs(sin(xmotion / 84.)) * 4;
  
  noStroke();
  
  float xoff = 800 / 2;
  
  float sphere_radius = 292;
  float yoff = 600 / 2 - sphere_radius;
  
  for (int s = 0; s < elems; s += elems_step) {
    float de = (float)s / elems;
    
    float bd = max((0.5-abs(de - 0.5)) * 4, 0.05);
    
    float yrepeat = 1;
    int yyd = (((int)(de * (colormap.height * yrepeat))%colormap.height)) * colormap.width;
		
		float tyrepeat = 4;
		int yyd2 = (((int)(de * (funmap.height * tyrepeat) + ymotion)%funmap.height)) * funmap.width;
		
		int yydc = (((int)(de * (cyclemap.height * yrepeat))%cyclemap.height)) * cyclemap.width;
    
    // cartesian circle equation
    float sphere_radius_squared = sphere_radius * sphere_radius;
    float sh_radius = de * (sphere_radius * 2) - sphere_radius;
    float xc_off = sqrt(sphere_radius_squared - sh_radius*sh_radius);
    
    float final_x;
    float final_y = yoff + de * (sphere_radius * 2); // flabby planet bonus : + sin((de * 360 + 180) * (PI / 180) + ymotion / 24.) * 4;
    
    for (int e = 0; e < (int)xc_off; e += dots_step) {
      float dd = (float)e / xc_off;

      final_x = xoff - xc_off + xc_off * dd * 2; // flabby planet bonus : + cos((de * 360 + 180) * (PI / 180) + xmotion / 24.) * 4
      
      float yc_off;
      
      // compute UV texels for the colormap
      if (dd > 0.5) {
        yc_off = sqrt(1 - dd*dd) + 1.270;
      } else {
        float dd2 = 1 - dd;
        
        yc_off = 1-sqrt(1 - dd2*dd2);
      }
      
      // apply colormaps
      float xrepeat = 0.5;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + xmotion)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      // second texture (text mask)
      float txrepeat = 1.;
      
      int xxd2 = ((funmap.width - 1) - (int)(yc_off * (funmap.width * txrepeat) + xmotion)%funmap.width);
 
      int cl2 = (int)xxd2 + yyd2;
      
      int r2 = (int)(red(funmap.pixels[cl2]) * bd);
      int g2 = (int)(green(funmap.pixels[cl2]) * bd);
      int b2 = (int)(blue(funmap.pixels[cl2]) * bd);
      
      // third texture (night version), reuse the first texture UV since they are the same width/height
      int rn = (int)(red(nightmap.pixels[cl]));
      int gn = (int)(green(nightmap.pixels[cl]));
      int bn = (int)(blue(nightmap.pixels[cl]));
      
      // fourth texture (cycle mask), only use single component since it is black/white
      int xxdc = ((cyclemap.width - 1) - (int)(yc_off * (cyclemap.width * xrepeat) + xmotion * 4)%cyclemap.width);
      int clc = (int)xxdc + yydc;
      float rc = red(cyclemap.pixels[clc]) / 255;
      
      float final_r = r * rc + rn * (1 - rc);
      float final_g = g * rc + gn * (1 - rc);
      float final_b = b * rc + bn * (1 - rc);
      
      // some compositing 
      fill(r * (r2 / 255) + final_r, g * (g2 / 255) + final_g, b * (b2 / 255) + final_b);//r * (r2 / 255) + r * bright, g * (g2 / 255) + g * bright, b * (b2 / 255) + b * bright);
      
      //rect(final_x, final_y, rect_size, rect_size);
      // slower but look good!
      ellipse(final_x, final_y, rect_size, rect_size);

/*
      // can improve the look with some kind of ""dithering""
      fill(r, g, b, 255);
      
      float rect_size2 = rect_size / 2;
      rect(final_x - rect_size2, final_y, rect_size2, rect_size2);
      rect(final_x + rect_size2, final_y, rect_size2, rect_size2);
      rect(final_x, final_y - rect_size2, rect_size2, rect_size2);
      rect(final_x, final_y + rect_size2, rect_size2, rect_size2);
*/
    }
  }
  
  xmotion += 0.5;
	ymotion -= 0.25;
}

void setup() {
  size(800, 600);

  frameRate(60); 
  
  colormap = loadImage(""data.jpg"");
  funmap = loadImage(""data2.jpg"");
  nightmap = loadImage(""data_night.jpg"");
  cyclemap = loadImage(""data_cycle.jpg"");
  
  background(0);
}

void draw() {
  //background(0);
 
  draw_planet();
}"
"561040","Dots planet billboard","mySketch","/**
  * Dots planet billboard.
  *
  * A weird idea, started with a cartesian way to draw a circle made of tiny blocks (aka the ""dots"") then expanded by applying a colormap then a second texture which is used as a mask to display the text and then day/night cycle from a mask.
  * Some more ideas : exploding planet (or two planet colliding etc.)
	*
	* There is some issue with the rendering (the vertical slices which should be inversed after half of the circle) but this doesn't affect much the quality
	*
	* This is rather slow on the web and could be optimized even more but run ok with better quality on Processing desktop.
  *
  * Initially wanted to recreate Star Control 2 planets rendering. (but they probably use another tech.) 
  */

PImage colormap;
PImage funmap;
PImage nightmap;
PImage cyclemap;

float xmotion = 0;
float ymotion = 0;

// quality control
int dots_step = 2;
int elems_step = 2;

// same but look below, these are adjusted in real-time to increase rendering quality by abusing motion blur :)
int elems = 192;
int rect_size = 4;

void draw_planet() {
  float mx = mouseX / 1024.0;
	float my = mouseY / 1024.0;
	
	elems_step = 1 + mx * 6.0;
	dots_step = 1 + my * 2.0;

  // add some motion blur / brightness
  fill(0, 0, 0, 4);
  rect(0, 0, 800, 600);
	
	// here we take advantage of the motion blur to ""fill in the gap"" by adjusting each slices / frames, this increase rendering quality (altough it look hazy)
	elems = 92 + sin(xmotion / 24.) * 36;
	rect_size = 2 + abs(sin(xmotion / 84.)) * 4;
  
  noStroke();
  
  float xoff = 800 / 2;
  
  float sphere_radius = 292;
  float yoff = 600 / 2 - sphere_radius;
  
  for (int s = 0; s < elems; s += elems_step) {
    float de = (float)s / elems;
    
    float bd = max((0.5-abs(de - 0.5)) * 4, 0.05);
    
    float yrepeat = 1;
    int yyd = (((int)(de * (colormap.height * yrepeat))%colormap.height)) * colormap.width;
		
		float tyrepeat = 4;
		int yyd2 = (((int)(de * (funmap.height * tyrepeat) + ymotion)%funmap.height)) * funmap.width;
		
		int yydc = (((int)(de * (cyclemap.height * yrepeat))%cyclemap.height)) * cyclemap.width;
    
    // cartesian circle equation
    float sphere_radius_squared = sphere_radius * sphere_radius;
    float sh_radius = de * (sphere_radius * 2) - sphere_radius;
    float xc_off = sqrt(sphere_radius_squared - sh_radius*sh_radius);
    
    float final_x;
    float final_y = yoff + de * (sphere_radius * 2); // flabby planet bonus : + sin((de * 360 + 180) * (PI / 180) + ymotion / 24.) * 4;
    
    for (int e = 0; e < (int)xc_off; e += dots_step) {
      float dd = (float)e / xc_off;

      final_x = xoff - xc_off + xc_off * dd * 2; // flabby planet bonus : + cos((de * 360 + 180) * (PI / 180) + xmotion / 24.) * 4
      
      float yc_off;
      
      // compute UV texels for the colormap
      if (dd > 0.5) {
        yc_off = sqrt(1 - dd*dd) + 1.270;
      } else {
        float dd2 = 1 - dd;
        
        yc_off = 1-sqrt(1 - dd2*dd2);
      }
      
      // apply colormaps
      float xrepeat = 0.5;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + xmotion)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      // second texture (text mask)
      float txrepeat = 1.;
      
      int xxd2 = ((funmap.width - 1) - (int)(yc_off * (funmap.width * txrepeat) + xmotion)%funmap.width);
 
      int cl2 = (int)xxd2 + yyd2;
      
      int r2 = (int)(red(funmap.pixels[cl2]) * bd);
      int g2 = (int)(green(funmap.pixels[cl2]) * bd);
      int b2 = (int)(blue(funmap.pixels[cl2]) * bd);
      
      // third texture (night version), reuse the first texture UV since they are the same width/height
      int rn = (int)(red(nightmap.pixels[cl]));
      int gn = (int)(green(nightmap.pixels[cl]));
      int bn = (int)(blue(nightmap.pixels[cl]));
      
      // fourth texture (cycle mask), only use single component since it is black/white
      int xxdc = ((cyclemap.width - 1) - (int)(yc_off * (cyclemap.width * xrepeat) + xmotion * 4)%cyclemap.width);
      int clc = (int)xxdc + yydc;
      float rc = red(cyclemap.pixels[clc]) / 255;
      
      float final_r = r * rc + rn * (1 - rc);
      float final_g = g * rc + gn * (1 - rc);
      float final_b = b * rc + bn * (1 - rc);
      
      // some compositing 
      fill(r * (r2 / 255) + final_r, g * (g2 / 255) + final_g, b * (b2 / 255) + final_b);//r * (r2 / 255) + r * bright, g * (g2 / 255) + g * bright, b * (b2 / 255) + b * bright);
      
      //rect(final_x, final_y, rect_size, rect_size);
      // slower but look good!
      ellipse(final_x, final_y, rect_size, rect_size);

/*
      // can improve the look with some kind of ""dithering""
      fill(r, g, b, 255);
      
      float rect_size2 = rect_size / 2;
      rect(final_x - rect_size2, final_y, rect_size2, rect_size2);
      rect(final_x + rect_size2, final_y, rect_size2, rect_size2);
      rect(final_x, final_y - rect_size2, rect_size2, rect_size2);
      rect(final_x, final_y + rect_size2, rect_size2, rect_size2);
*/
    }
  }
  
  xmotion += 0.5;
	ymotion -= 0.25;
}

void setup() {
  size(800, 600);

  frameRate(60); 
  
  colormap = loadImage(""data.jpg"");
  funmap = loadImage(""data2.jpg"");
  nightmap = loadImage(""data_night.jpg"");
  cyclemap = loadImage(""data_cycle.jpg"");
  
  background(0);
}

void draw() {
  //background(0);
 
  draw_planet();
}"
"561040","Dots planet billboard","mySketch","/**
  * Dots planet billboard.
  *
  * A weird idea, started with a cartesian way to draw a circle made of tiny blocks (aka the ""dots"") then expanded by applying a colormap then a second texture which is used as a mask to display the text and then day/night cycle from a mask.
  * Some more ideas : exploding planet (or two planet colliding etc.)
	*
	* There is some issue with the rendering (the vertical slices which should be inversed after half of the circle) but this doesn't affect much the quality
	*
	* This is rather slow on the web and could be optimized even more but run ok with better quality on Processing desktop.
  *
  * Initially wanted to recreate Star Control 2 planets rendering. (but they probably use another tech.) 
  */

PImage colormap;
PImage funmap;
PImage nightmap;
PImage cyclemap;

float xmotion = 0;
float ymotion = 0;

// quality control
int dots_step = 2;
int elems_step = 2;

// same but look below, these are adjusted in real-time to increase rendering quality by abusing motion blur :)
int elems = 192;
int rect_size = 4;

void draw_planet() {
  float mx = mouseX / 1024.0;
	float my = mouseY / 1024.0;
	
	elems_step = 1 + mx * 4.0;
	dots_step = 1 + my * 2.0;

  // add some motion blur / brightness
  fill(0, 0, 0, 4);
  rect(0, 0, 800, 600);
	
	// here we take advantage of the motion blur to ""fill in the gap"" by adjusting each slices / frames, this increase rendering quality (altough it look hazy)
	elems = 92 + sin(xmotion / 24.) * 36;
	rect_size = 2 + abs(sin(xmotion / 84.)) * 4;
  
  noStroke();
  
  float xoff = 800 / 2;
  
  float sphere_radius = 292;
  float yoff = 600 / 2 - sphere_radius;
  
  for (int s = 0; s < elems; s += elems_step) {
    float de = (float)s / elems;
    
    float bd = max((0.5-abs(de - 0.5)) * 4, 0.05);
    
    float yrepeat = 1;
    int yyd = (((int)(de * (colormap.height * yrepeat))%colormap.height)) * colormap.width;
		
		float tyrepeat = 4;
		int yyd2 = (((int)(de * (funmap.height * tyrepeat) + ymotion)%funmap.height)) * funmap.width;
		
		int yydc = (((int)(de * (cyclemap.height * yrepeat))%cyclemap.height)) * cyclemap.width;
    
    // cartesian circle equation
    float sphere_radius_squared = sphere_radius * sphere_radius;
    float sh_radius = de * (sphere_radius * 2) - sphere_radius;
    float xc_off = sqrt(sphere_radius_squared - sh_radius*sh_radius);
    
    float final_x;
    float final_y = yoff + de * (sphere_radius * 2); // flabby planet bonus : + sin((de * 360 + 180) * (PI / 180) + ymotion / 24.) * 4;
    
    for (int e = 0; e < (int)xc_off; e += dots_step) {
      float dd = (float)e / xc_off;

      final_x = xoff - xc_off + xc_off * dd * 2; // flabby planet bonus : + cos((de * 360 + 180) * (PI / 180) + xmotion / 24.) * 4
      
      float yc_off;
      
      // compute UV texels for the colormap
      if (dd > 0.5) {
        yc_off = sqrt(1 - dd*dd) + 1.270;
      } else {
        float dd2 = 1 - dd;
        
        yc_off = 1-sqrt(1 - dd2*dd2);
      }
      
      // apply colormaps
      float xrepeat = 0.5;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + xmotion)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      // second texture (text mask)
      float txrepeat = 1.;
      
      int xxd2 = ((funmap.width - 1) - (int)(yc_off * (funmap.width * txrepeat) + xmotion)%funmap.width);
 
      int cl2 = (int)xxd2 + yyd2;
      
      int r2 = (int)(red(funmap.pixels[cl2]) * bd);
      int g2 = (int)(green(funmap.pixels[cl2]) * bd);
      int b2 = (int)(blue(funmap.pixels[cl2]) * bd);
      
      // third texture (night version), reuse the first texture UV since they are the same width/height
      int rn = (int)(red(nightmap.pixels[cl]));
      int gn = (int)(green(nightmap.pixels[cl]));
      int bn = (int)(blue(nightmap.pixels[cl]));
      
      // fourth texture (cycle mask), only use single component since it is black/white
      int xxdc = ((cyclemap.width - 1) - (int)(yc_off * (cyclemap.width * xrepeat) + xmotion * 4)%cyclemap.width);
      int clc = (int)xxdc + yydc;
      float rc = red(cyclemap.pixels[clc]) / 255;
      
      float final_r = r * rc + rn * (1 - rc);
      float final_g = g * rc + gn * (1 - rc);
      float final_b = b * rc + bn * (1 - rc);
      
      // some compositing 
      fill(r * (r2 / 255) + final_r, g * (g2 / 255) + final_g, b * (b2 / 255) + final_b);//r * (r2 / 255) + r * bright, g * (g2 / 255) + g * bright, b * (b2 / 255) + b * bright);
      
      //rect(final_x, final_y, rect_size, rect_size);
      // slower but look good!
      ellipse(final_x, final_y, rect_size, rect_size);

/*
      // can improve the look with some kind of ""dithering""
      fill(r, g, b, 255);
      
      float rect_size2 = rect_size / 2;
      rect(final_x - rect_size2, final_y, rect_size2, rect_size2);
      rect(final_x + rect_size2, final_y, rect_size2, rect_size2);
      rect(final_x, final_y - rect_size2, rect_size2, rect_size2);
      rect(final_x, final_y + rect_size2, rect_size2, rect_size2);
*/
    }
  }
  
  xmotion += 0.5;
	ymotion -= 0.25;
}

void setup() {
  size(800, 600);

  frameRate(60); 
  
  colormap = loadImage(""data.jpg"");
  funmap = loadImage(""data2.jpg"");
  nightmap = loadImage(""data_night.jpg"");
  cyclemap = loadImage(""data_cycle.jpg"");
  
  background(0);
}

void draw() {
  //background(0);
 
  draw_planet();
}"
"561040","Dots planet billboard","mySketch","/**
  * Dots planet billboard.
  *
  * A weird idea, started with a cartesian way to draw a circle made of tiny blocks (aka the ""dots"") then expanded by applying a colormap then a second texture which is used as a mask to display the text and then day/night cycle from a mask.
  * Some more ideas : exploding planet (or two planet colliding etc.)
	*
	* There is some issue with the rendering (the vertical slices which should be inversed after half of the circle) but this doesn't affect much the quality
	*
	* This is rather slow on the web and could be optimized even more but run ok with better quality on Processing desktop.
  *
  * Initially wanted to recreate Star Control 2 planets rendering. (but they probably use another tech.) 
  */

PImage colormap;
PImage funmap;
PImage nightmap;
PImage cyclemap;

float xmotion = 0;
float ymotion = 0;

// quality control
int dots_step = 2;
int elems_step = 2;

// same but look below, these are adjusted in real-time to increase rendering quality by abusing motion blur :)
int elems = 192;
int rect_size = 4;

void draw_planet() {
  float mx = mouseX / 1024.0;
	float my = mouseY / 1024.0;
	
	elems_step = 1 + mx * 4.0;
	dots_step = 1 + my * 2.0;

  // add some motion blur / brightness
  fill(0, 0, 0, 4);
  rect(0, 0, 800, 600);
	
	// here we take advantage of the motion blur to ""fill in the gap"" by adjusting each slices / frames, this increase rendering quality (altough it look hazy)
	elems = 92 + sin(xmotion / 24.) * 36;
	rect_size = 2 + abs(sin(xmotion / 84.)) * 4;
  
  noStroke();
  
  float xoff = 800 / 2;
  
  float sphere_radius = 292;
  float yoff = 600 / 2 - sphere_radius;
  
  for (int s = 0; s < elems; s += elems_step) {
    float de = (float)s / elems;
    
    float bd = max((0.5-abs(de - 0.5)) * 4, 0.05);
    
    float yrepeat = 1;
    int yyd = (((int)(de * (colormap.height * yrepeat))%colormap.height)) * colormap.width;
		
		float tyrepeat = 4;
		int yyd2 = (((int)(de * (funmap.height * tyrepeat) + ymotion)%funmap.height)) * funmap.width;
		
		int yydc = (((int)(de * (cyclemap.height * yrepeat))%cyclemap.height)) * cyclemap.width;
    
    // cartesian circle equation
    float sphere_radius_squared = sphere_radius * sphere_radius;
    float sh_radius = de * (sphere_radius * 2) - sphere_radius;
    float xc_off = sqrt(sphere_radius_squared - sh_radius*sh_radius);
    
    float final_x;
    float final_y = yoff + de * (sphere_radius * 2); // flabby planet bonus : + sin((de * 360 + 180) * (PI / 180) + ymotion / 24.) * 4;
    
    for (int e = 0; e < (int)xc_off; e += dots_step) {
      float dd = (float)e / xc_off;

      final_x = xoff - xc_off + xc_off * dd * 2; // flabby planet bonus : + cos((de * 360 + 180) * (PI / 180) + xmotion / 24.) * 4
      
      float yc_off;
      
      // compute UV texels for the colormap
      if (dd > 0.5) {
        yc_off = sqrt(1 - dd*dd) + 1.270;
      } else {
        float dd2 = 1 - dd;
        
        yc_off = 1-sqrt(1 - dd2*dd2);
      }
      
      // apply colormaps
      float xrepeat = 0.5;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + xmotion)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      // second texture (text mask)
      float txrepeat = 1.;
      
      int xxd2 = ((funmap.width - 1) - (int)(yc_off * (funmap.width * txrepeat) + xmotion)%funmap.width);
 
      int cl2 = (int)xxd2 + yyd2;
      
      int r2 = (int)(red(funmap.pixels[cl2]) * bd);
      int g2 = (int)(green(funmap.pixels[cl2]) * bd);
      int b2 = (int)(blue(funmap.pixels[cl2]) * bd);
      
      // third texture (night version), reuse the first texture UV since they are the same width/height
      int rn = (int)(red(nightmap.pixels[cl]));
      int gn = (int)(green(nightmap.pixels[cl]));
      int bn = (int)(blue(nightmap.pixels[cl]));
      
      // fourth texture (cycle mask), only use single component since it is black/white
      int xxdc = ((cyclemap.width - 1) - (int)(yc_off * (cyclemap.width * xrepeat) + xmotion * 4)%cyclemap.width);
      int clc = (int)xxdc + yydc;
      float rc = red(cyclemap.pixels[clc]) / 255;
      
      float final_r = r * rc + rn * (1 - rc);
      float final_g = g * rc + gn * (1 - rc);
      float final_b = b * rc + bn * (1 - rc);
      
      // some compositing 
      fill(r * (r2 / 255) + final_r, g * (g2 / 255) + final_g, b * (b2 / 255) + final_b);//r * (r2 / 255) + r * bright, g * (g2 / 255) + g * bright, b * (b2 / 255) + b * bright);
      
      rect(final_x, final_y, rect_size, rect_size);
      // slower but look good!
      //ellipse(final_x, final_y, rect_size, rect_size);

/*
      // can improve the look with some kind of ""dithering""
      fill(r, g, b, 255);
      
      float rect_size2 = rect_size / 2;
      rect(final_x - rect_size2, final_y, rect_size2, rect_size2);
      rect(final_x + rect_size2, final_y, rect_size2, rect_size2);
      rect(final_x, final_y - rect_size2, rect_size2, rect_size2);
      rect(final_x, final_y + rect_size2, rect_size2, rect_size2);
*/
    }
  }
  
  xmotion += 0.5;
	ymotion -= 0.25;
}

void setup() {
  size(800, 600);

  frameRate(60); 
  
  colormap = loadImage(""data.jpg"");
  funmap = loadImage(""data2.jpg"");
  nightmap = loadImage(""data_night.jpg"");
  cyclemap = loadImage(""data_cycle.jpg"");
  
  background(0);
}

void draw() {
  //background(0);
 
  draw_planet();
}"
"561040","Dots planet billboard","mySketch","/**
  * Dots planet billboard.
  *
  * A weird idea, started with a cartesian way to draw a circle made of tiny blocks (aka the ""dots"") then expanded by applying a colormap then a second texture which is used as a mask to display the text and then day/night cycle from a mask.
  * Some more ideas : exploding planet (or two planet colliding etc.)
	*
	* There is some issue with the rendering (the vertical slices which should be inversed after half of the circle) but this doesn't affect much the quality
	*
	* This is rather slow on the web and could be optimized even more but run ok with better quality on Processing desktop.
  *
  * Initially wanted to recreate Star Control 2 planets rendering. (but they probably use another tech.) 
  */

PImage colormap;
PImage funmap;
PImage nightmap;
PImage cyclemap;

float xmotion = 0;
float ymotion = 0;

// quality control
int dots_step = 1;
int elems_step = 1;

// same but look below, these are adjusted in real-time to increase rendering quality by abusing motion blur :)
int elems = 192;
int rect_size = 4;

void draw_planet() {
  float mx = mouseX / 1024.0;
	float my = mouseY / 1024.0;
	
	elems_step = 1 + mx * 4.0;
	dots_step = 1 + my * 2.0;

  // add some motion blur / brightness
  fill(0, 0, 0, 4);
  rect(0, 0, 800, 600);
	
	// here we take advantage of the motion blur to ""fill in the gap"" by adjusting each slices / frames, this increase rendering quality (altough it look hazy)
	elems = 92 + sin(xmotion / 24.) * 36;
	rect_size = 2 + abs(sin(xmotion / 84.)) * 4;
  
  noStroke();
  
  float xoff = 800 / 2;
  
  float sphere_radius = 292;
  float yoff = 600 / 2 - sphere_radius;
  
  for (int s = 0; s < elems; s += elems_step) {
    float de = (float)s / elems;
    
    float bd = max((0.5-abs(de - 0.5)) * 4, 0.05);
    
    float yrepeat = 1;
    int yyd = (((int)(de * (colormap.height * yrepeat))%colormap.height)) * colormap.width;
		
		float tyrepeat = 4;
		int yyd2 = (((int)(de * (funmap.height * tyrepeat) + ymotion)%funmap.height)) * funmap.width;
		
		int yydc = (((int)(de * (cyclemap.height * yrepeat))%cyclemap.height)) * cyclemap.width;
    
    // cartesian circle equation
    float sphere_radius_squared = sphere_radius * sphere_radius;
    float sh_radius = de * (sphere_radius * 2) - sphere_radius;
    float xc_off = sqrt(sphere_radius_squared - sh_radius*sh_radius);
    
    float final_x;
    float final_y = yoff + de * (sphere_radius * 2); // flabby planet bonus : + sin((de * 360 + 180) * (PI / 180) + ymotion / 24.) * 4;
    
    for (int e = 0; e < (int)xc_off; e += dots_step) {
      float dd = (float)e / xc_off;

      final_x = xoff - xc_off + xc_off * dd * 2; // flabby planet bonus : + cos((de * 360 + 180) * (PI / 180) + xmotion / 24.) * 4
      
      float yc_off;
      
      // compute UV texels for the colormap
      if (dd > 0.5) {
        yc_off = sqrt(1 - dd*dd) + 1.270;
      } else {
        float dd2 = 1 - dd;
        
        yc_off = 1-sqrt(1 - dd2*dd2);
      }
      
      // apply colormaps
      float xrepeat = 0.5;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + xmotion)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      // second texture (text mask)
      float txrepeat = 1.;
      
      int xxd2 = ((funmap.width - 1) - (int)(yc_off * (funmap.width * txrepeat) + xmotion)%funmap.width);
 
      int cl2 = (int)xxd2 + yyd2;
      
      int r2 = (int)(red(funmap.pixels[cl2]) * bd);
      int g2 = (int)(green(funmap.pixels[cl2]) * bd);
      int b2 = (int)(blue(funmap.pixels[cl2]) * bd);
      
      // third texture (night version), reuse the first texture UV since they are the same width/height
      int rn = (int)(red(nightmap.pixels[cl]));
      int gn = (int)(green(nightmap.pixels[cl]));
      int bn = (int)(blue(nightmap.pixels[cl]));
      
      // fourth texture (cycle mask), only use single component since it is black/white
      int xxdc = ((cyclemap.width - 1) - (int)(yc_off * (cyclemap.width * xrepeat) + xmotion * 4)%cyclemap.width);
      int clc = (int)xxdc + yydc;
      float rc = red(cyclemap.pixels[clc]) / 255;
      
      float final_r = r * rc + rn * (1 - rc);
      float final_g = g * rc + gn * (1 - rc);
      float final_b = b * rc + bn * (1 - rc);
      
      // some compositing 
      fill(r * (r2 / 255) + final_r, g * (g2 / 255) + final_g, b * (b2 / 255) + final_b);//r * (r2 / 255) + r * bright, g * (g2 / 255) + g * bright, b * (b2 / 255) + b * bright);
      
      rect(final_x, final_y, rect_size, rect_size);
      // slower but look good!
      //ellipse(final_x, final_y, rect_size, rect_size);

/*
      // can improve the look with some kind of ""dithering""
      fill(r, g, b, 255);
      
      float rect_size2 = rect_size / 2;
      rect(final_x - rect_size2, final_y, rect_size2, rect_size2);
      rect(final_x + rect_size2, final_y, rect_size2, rect_size2);
      rect(final_x, final_y - rect_size2, rect_size2, rect_size2);
      rect(final_x, final_y + rect_size2, rect_size2, rect_size2);
*/
    }
  }
  
  xmotion += 0.5;
	ymotion -= 0.25;
}

void setup() {
  size(800, 600);

  frameRate(60); 
  
  colormap = loadImage(""data.jpg"");
  funmap = loadImage(""data2.jpg"");
  nightmap = loadImage(""data_night.jpg"");
  cyclemap = loadImage(""data_cycle.jpg"");
  
  background(0);
}

void draw() {
  //background(0);
 
  draw_planet();
}"
"561040","Dots planet billboard","mySketch","/**
  * Dots planet billboard.
  *
  * A weird idea, started with a cartesian way to draw a circle made of tiny blocks (aka the ""dots"") then expanded by applying a colormap then a second texture which is used as a mask to display the text and then day/night cycle from a mask.
  * Some more ideas : exploding planet (or two planet colliding etc.)
	*
	* There is some issue with the rendering (the vertical slices which should be inversed after half of the circle) but this doesn't affect much the quality
	*
	* This is rather slow on the web and could be optimized even more but run ok with better quality on Processing desktop.
  *
  * Initially wanted to recreate Star Control 2 planets rendering. (but they probably use another tech.) 
  */

PImage colormap;
PImage funmap;
PImage nightmap;
PImage cyclemap;

float xmotion = 0;
float ymotion = 0;

// quality control
int dots_step = 1;
int elems_step = 1;

// same but look below, these are adjusted in real-time to increase rendering quality by abusing motion blur :)
int elems = 192;
int rect_size = 4;

void draw_planet() {
  float mx = mouseX / 1024.0;
	float my = mouseY / 1024.0;
	
	elems_step = 1 + mx * 4.0;
	dots_step = 1 + my * 2.0;

  // add some motion blur / brightness
  fill(0, 0, 0, 4);
  rect(0, 0, 800, 600);
	
	// here we take advantage of the motion blur to ""fill in the gap"" by adjusting each slices / frames, this increase rendering quality (altough it look hazy)
	elems = 92 + sin(xmotion / 24.) * 36;
	rect_size = 2 + abs(sin(xmotion / 84.)) * 4;
  
  noStroke();
  
  float xoff = 800 / 2;
  
  float sphere_radius = 292;
  float yoff = 600 / 2 - sphere_radius;
  
  for (int s = 0; s < elems; s += elems_step) {
    float de = (float)s / elems;
    
    float bd = max((0.5-abs(de - 0.5)) * 4, 0.05);
    
    float yrepeat = 1;
    int yyd = (((int)(de * (colormap.height * yrepeat))%colormap.height)) * colormap.width;
		
		float tyrepeat = 4;
		int yyd2 = (((int)(de * (funmap.height * tyrepeat) + xmotion)%funmap.height)) * funmap.width;
		
		int yydc = (((int)(de * (cyclemap.height * yrepeat))%cyclemap.height)) * cyclemap.width;
    
    // cartesian circle equation
    float sphere_radius_squared = sphere_radius * sphere_radius;
    float sh_radius = de * (sphere_radius * 2) - sphere_radius;
    float xc_off = sqrt(sphere_radius_squared - sh_radius*sh_radius);
    
    float final_x;
    float final_y = yoff + de * (sphere_radius * 2); // flabby planet bonus : + sin((de * 360 + 180) * (PI / 180) + ymotion / 24.) * 4;
    
    for (int e = 0; e < (int)xc_off; e += dots_step) {
      float dd = (float)e / xc_off;

      final_x = xoff - xc_off + xc_off * dd * 2; // flabby planet bonus : + cos((de * 360 + 180) * (PI / 180) + xmotion / 24.) * 4
      
      float yc_off;
      
      // compute UV texels for the colormap
      if (dd > 0.5) {
        yc_off = sqrt(1 - dd*dd) + 1.270;
      } else {
        float dd2 = 1 - dd;
        
        yc_off = 1-sqrt(1 - dd2*dd2);
      }
      
      // apply colormaps
      float xrepeat = 0.5;
      int xxd = ((colormap.width - 1) - (int)(yc_off * (colormap.width * xrepeat) + xmotion)%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      // second texture (text mask)
      float txrepeat = 1.;
      
      int xxd2 = ((funmap.width - 1) - (int)(yc_off * (funmap.width * txrepeat) + xmotion)%funmap.width);
 
      int cl2 = (int)xxd2 + yyd2;
      
      int r2 = (int)(red(funmap.pixels[cl2]) * bd);
      int g2 = (int)(green(funmap.pixels[cl2]) * bd);
      int b2 = (int)(blue(funmap.pixels[cl2]) * bd);
      
      // third texture (night version), reuse the first texture UV since they are the same width/height
      int rn = (int)(red(nightmap.pixels[cl]));
      int gn = (int)(green(nightmap.pixels[cl]));
      int bn = (int)(blue(nightmap.pixels[cl]));
      
      // fourth texture (cycle mask), only use single component since it is black/white
      int xxdc = ((cyclemap.width - 1) - (int)(yc_off * (cyclemap.width * xrepeat) + xmotion * 4)%cyclemap.width);
      int clc = (int)xxdc + yydc;
      float rc = red(cyclemap.pixels[clc]) / 255;
      
      float final_r = r * rc + rn * (1 - rc);
      float final_g = g * rc + gn * (1 - rc);
      float final_b = b * rc + bn * (1 - rc);
      
      // some compositing 
      fill(r * (r2 / 255) + final_r, g * (g2 / 255) + final_g, b * (b2 / 255) + final_b);//r * (r2 / 255) + r * bright, g * (g2 / 255) + g * bright, b * (b2 / 255) + b * bright);
      
      rect(final_x, final_y, rect_size, rect_size);
      // slower but look good!
      //ellipse(final_x, final_y, rect_size, rect_size);

/*
      // can improve the look with some kind of ""dithering""
      fill(r, g, b, 255);
      
      float rect_size2 = rect_size / 2;
      rect(final_x - rect_size2, final_y, rect_size2, rect_size2);
      rect(final_x + rect_size2, final_y, rect_size2, rect_size2);
      rect(final_x, final_y - rect_size2, rect_size2, rect_size2);
      rect(final_x, final_y + rect_size2, rect_size2, rect_size2);
*/
    }
  }
  
  xmotion += 0.5;
	ymotion -= 0.25;
}

void setup() {
  size(800, 600);

  frameRate(60); 
  
  colormap = loadImage(""data.jpg"");
  funmap = loadImage(""data2.jpg"");
  nightmap = loadImage(""data_night.jpg"");
  cyclemap = loadImage(""data_cycle.jpg"");
  
  background(0);
}

void draw() {
  //background(0);
 
  draw_planet();
}"
"560834","Sauron eye","mySketch","/**
  * ""Dots"" textured / fur 3D tunnel
  */

PImage colormap;
PImage colormap2;

float xmotion = 0;
float ymotion = 0;
float rmotion = 0;
float tmotion = 0;
float tmotion2 = 0;

int elems = 128; // can improve the rendering quality by increasing it
int dots = 128; // improve rendering qualiy

int dots_step = 1;
int elems_step = 1;

float []ldmotion = new float[elems * dots];

void draw_landscape() {
  float mx = 1. + mouseX / 1024.0 * 4;
  
  int rect_size = (int)mx;
  
  // apply motion blur
  fill(0, 0, 0, 12);
  rect(0, 0, 1024, 700);
  
  noStroke();
  
  float xoff = 1024 / 2.;
  float yoff = 700 / 2;
 
  float lelems = elems;
  float ldots = dots;
  
  float ws = 1;
  float hs = 700 - yoff * 2;
  
  float ow = 2.;
  
  for (int e = 0; e < lelems; e += elems_step) {
    float de = (float)e / lelems;

    float bd = max((0.5-abs(de - 0.5)) * 4, 0.05);

    ws = 256 * de + cos((de * 360 + 180) * (PI / 180) / 4 + xmotion) * 64;
    hs = 192 * de + sin((de * 360 + 180) * (PI / 180) / 2 + ymotion) * 64;
    
    float xrepeat = 4;
    float yrepeat = 4;
    int yyd = (((int)((de+tmotion) * (colormap.height * yrepeat))))%colormap.height * colormap.width;
    int xxd2 = ((int)((de+tmotion2) * (colormap2.width * xrepeat))%colormap2.width);
      
    for (int d = 0; d < ldots; d += dots_step) {
      float dd = (float)d / ldots;
      
      float final_x = xoff + ws * sin((dd * 360 + 180) * (PI / 180) * 2 - tmotion + ldmotion[d + e * dots] * de);
      float final_y = yoff + hs * cos((dd * 360 + 180) * (PI / 180) * 2 - tmotion + ldmotion[d + e * dots] * de);
      
      int xxd = ((int)((dd+tmotion) * (colormap.width * xrepeat))%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int yyd2 = (((int)((dd+tmotion2) * (colormap2.height * yrepeat))))%colormap2.height * colormap2.width;
      
      int cl2 = (int)xxd2 + yyd2;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      int r2 = (int)(red(colormap2.pixels[cl2]) * bd);
      int g2 = (int)(green(colormap2.pixels[cl2]) * bd);
      int b2 = (int)(blue(colormap2.pixels[cl2]) * bd);
      
      fill((r + r2) / 2, (g + g2)/2, (b + b2)/2, min(bd * abs(ow), 255.));

      rect(final_x, final_y, rect_size, rect_size);
      
      ow += cos(de * 360 * (PI / 180) + xmotion) / 64;
    }
    
    ow += 0.001;
  }
  
  xmotion += 0.05;
  ymotion += 0.0125;
  rmotion += 0.012;
  tmotion += 0.001;
  tmotion2 += 0.002;
}

void setup() {
  size(1024, 700);

  frameRate(60); 
  
  colormap = loadImage(""data.jpg"");
  colormap2 = loadImage(""data2.jpg"");
  
  for (int e = 0; e < elems; e += elems_step) {
    for (int d = 0; d < dots; d += dots_step) {
      ldmotion[d + e * dots] = random(0.5);
    }
  }

  background(0);
}

void draw() {
  //background(0);
 
  draw_landscape();
}"
"560834","Sauron eye","mySketch","/**
  * Sauron eye
  */

PImage colormap;
PImage colormap2;

float xmotion = 0;
float ymotion = 0;
float rmotion = 0;
float tmotion = 0;
float tmotion2 = 0;

int elems = 128; // can improve the rendering quality by increasing it
int dots = 92; // improve rendering qualiy

int dots_step = 1;
int elems_step = 1;

float []ldmotion = new float[elems * dots];

void draw_landscape() {
  float mx = 4. + mouseX / 1024.0 * 4;
  
  int rect_size = (int)mx;
  
  // apply motion blur
  fill(0, 0, 0, 12);
  rect(0, 0, 1024, 700);
  
  noStroke();
  
  float xoff = 1024 / 2.;
  float yoff = 700 / 2;
 
  float lelems = elems;
  float ldots = dots;
  
  float ws = 1;
  float hs = 700 - yoff * 2;
  
  float ow = 2.;
  
  for (int e = 0; e < lelems; e += elems_step) {
    float de = (float)e / lelems;

    float bd = max((0.5-abs(de - 0.5)) * 4, 0.05);

    ws = 256 * de + cos((de * 360 + 180) * (PI / 180) / 4 + xmotion) * 64;
    hs = 192 * de + sin((de * 360 + 180) * (PI / 180) / 2 + ymotion) * 64;
    
    float xrepeat = 4;
    float yrepeat = 4;
    int yyd = (((int)((de+tmotion) * (colormap.height * yrepeat))))%colormap.height * colormap.width;
    int xxd2 = ((int)((de+tmotion2) * (colormap2.width * xrepeat))%colormap2.width);
      
    for (int d = 0; d < ldots; d += dots_step) {
      float dd = (float)d / ldots;
      
      float final_x = xoff + ws * sin((dd * 360 + 180) * (PI / 180) * 2 - tmotion + ldmotion[d + e * dots] * de);
      float final_y = yoff + hs * cos((dd * 360 + 180) * (PI / 180) * 2 - tmotion + ldmotion[d + e * dots] * de);
      
      int xxd = ((int)((dd+tmotion) * (colormap.width * xrepeat))%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int yyd2 = (((int)((dd+tmotion2) * (colormap2.height * yrepeat))))%colormap2.height * colormap2.width;
      
      int cl2 = (int)xxd2 + yyd2;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      int r2 = (int)(red(colormap2.pixels[cl2]) * bd);
      int g2 = (int)(green(colormap2.pixels[cl2]) * bd);
      int b2 = (int)(blue(colormap2.pixels[cl2]) * bd);
      
      fill((r + r2) / 2, (g + g2)/2, (b + b2)/2, min(bd * (abs(ow) * 8), 255.));

      rect(final_x, final_y, rect_size, rect_size);
      
      ow += cos(de * 360 * (PI / 180) + xmotion) / 64;
    }
    
    ow += 0.001;
  }
  
  xmotion += 0.05;
  ymotion += 0.0125;
  rmotion += 0.012;
  tmotion += 0.001;
  tmotion2 += 0.002;
}

void setup() {
  size(1024, 700);

  frameRate(60); 
  
  colormap = loadImage(""data.jpg"");
  colormap2 = loadImage(""data2.jpg"");
  
  for (int e = 0; e < elems; e += elems_step) {
    for (int d = 0; d < dots; d += dots_step) {
      ldmotion[d + e * dots] = random(0.5);
    }
  }

  background(0);
}

void draw() {
  //background(0);
 
  draw_landscape();
}"
"560834","Sauron eye","mySketch","/**
  * Sauron eye
  */

PImage colormap;
PImage colormap2;

float xmotion = 0;
float ymotion = 0;
float rmotion = 0;
float tmotion = 0;
float tmotion2 = 0;

int elems = 128; // can improve the rendering quality by increasing it
int dots = 92; // improve rendering qualiy

int dots_step = 1;
int elems_step = 1;

float []ldmotion = new float[elems * dots];

void draw_landscape() {
  float mx = 4. + mouseX / 1024.0 * 4;
  
  int rect_size = (int)mx;
  
  // apply motion blur
  fill(0, 0, 0, 12);
  rect(0, 0, 1024, 700);
  
  noStroke();
  
  float xoff = 1024 / 2.;
  float yoff = 700 / 2;
 
  float lelems = elems;
  float ldots = dots;
  
  float ws = 1;
  float hs = 700 - yoff * 2;
  
  float ow = 2.;
  
  for (int e = 0; e < lelems; e += elems_step) {
    float de = (float)e / lelems;

    float bd = max((0.5-abs(de - 0.5)) * 4, 0.05);

    ws = 256 * de + cos((de * 360 + 180) * (PI / 180) / 4 + xmotion) * 64;
    hs = 192 * de + sin((de * 360 + 180) * (PI / 180) / 2 + ymotion) * 64;
    
    float xrepeat = 4;
    float yrepeat = 4;
    int yyd = (((int)((de+tmotion) * (colormap.height * yrepeat))))%colormap.height * colormap.width;
    int xxd2 = ((int)((de+tmotion2) * (colormap2.width * xrepeat))%colormap2.width);
      
    for (int d = 0; d < ldots; d += dots_step) {
      float dd = (float)d / ldots;
      
      float final_x = xoff + ws * sin((dd * 360 + 180) * (PI / 180) * 2 - tmotion + ldmotion[d + e * dots] * de);
      float final_y = yoff + hs * cos((dd * 360 + 180) * (PI / 180) * 2 - tmotion + ldmotion[d + e * dots] * de);
      
      int xxd = ((int)((dd+tmotion) * (colormap.width * xrepeat))%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int yyd2 = (((int)((dd+tmotion2) * (colormap2.height * yrepeat))))%colormap2.height * colormap2.width;
      
      int cl2 = (int)xxd2 + yyd2;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      int r2 = (int)(red(colormap2.pixels[cl2]) * bd);
      int g2 = (int)(green(colormap2.pixels[cl2]) * bd);
      int b2 = (int)(blue(colormap2.pixels[cl2]) * bd);
      
      fill((r + r2) / 2, (g + g2)/2, (b + b2)/2, min(bd * (abs(ow) * 8), 255.));

      rect(final_x, final_y, rect_size, rect_size);
      
      ow += cos(de * 360 * (PI / 180) + xmotion) / 64;
    }
    
    ow += 0.001;
  }
  
  xmotion += 0.05;
  ymotion += 0.0125;
  rmotion += 0.012;
  tmotion += 0.001;
  tmotion2 += 0.002;
}

void setup() {
  size(1024, 700);

  frameRate(60); 
  
  colormap = loadImage(""data.jpg"");
  colormap2 = loadImage(""data2.jpg"");
  
  for (int e = 0; e < elems; e += elems_step) {
    for (int d = 0; d < dots; d += dots_step) {
      ldmotion[d + e * dots] = random(0.5);
    }
  }

  background(0);
}

void draw() {
  //background(0);
 
  draw_landscape();
}"
"560834","Sauron eye","mySketch","/**
  * Sauron eye
  */

PImage colormap;
PImage colormap2;

float xmotion = 0;
float ymotion = 0;
float rmotion = 0;
float tmotion = 0;
float tmotion2 = 0;

int elems = 128; // can improve the rendering quality by increasing it
int dots = 92; // improve rendering qualiy

int dots_step = 1;
int elems_step = 1;

float []ldmotion = new float[elems * dots];

void draw_landscape() {
  float mx = 4. + mouseX / 1024.0 * 4;
  
  int rect_size = (int)mx;
  
  // apply motion blur
  fill(0, 0, 0, 12);
  rect(0, 0, 1024, 700);
  
  noStroke();
  
  float xoff = 1024 / 2.;
  float yoff = 700 / 2;
 
  float lelems = elems;
  float ldots = dots;
  
  float ws = 1;
  float hs = 700 - yoff * 2;
  
  float ow = 2.;
  
  for (int e = 0; e < lelems; e += elems_step) {
    float de = (float)e / lelems;

    float bd = max((0.5-abs(de - 0.5)) * 4, 0.05);

    ws = 256 * de + cos((de * 360 + 180) * (PI / 180) / 4 + xmotion) * 64;
    hs = 192 * de + sin((de * 360 + 180) * (PI / 180) / 2 + ymotion) * 64;
    
    float xrepeat = 4;
    float yrepeat = 4;
    int yyd = (((int)((de+tmotion) * (colormap.height * yrepeat))))%colormap.height * colormap.width;
    int xxd2 = ((int)((de+tmotion2) * (colormap2.width * xrepeat))%colormap2.width);
      
    for (int d = 0; d < ldots; d += dots_step) {
      float dd = (float)d / ldots;
      
      float final_x = xoff + ws * sin((dd * 360 + 180) * (PI / 180) * 2 - tmotion + ldmotion[d + e * dots] * de);
      float final_y = yoff + hs * cos((dd * 360 + 180) * (PI / 180) * 2 - tmotion + ldmotion[d + e * dots] * de);
      
      int xxd = ((int)((dd+tmotion) * (colormap.width * xrepeat))%colormap.width);
 
      int cl = (int)xxd + yyd;
      
      int yyd2 = (((int)((dd+tmotion2) * (colormap2.height * yrepeat))))%colormap2.height * colormap2.width;
      
      int cl2 = (int)xxd2 + yyd2;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      int r2 = (int)(red(colormap2.pixels[cl2]) * bd);
      int g2 = (int)(green(colormap2.pixels[cl2]) * bd);
      int b2 = (int)(blue(colormap2.pixels[cl2]) * bd);
      
      fill((r + r2) / 2, (g + g2)/2, (b + b2)/2, min(bd * (abs(ow) * 8), 255.));

      rect(final_x, final_y, rect_size, rect_size);
      
      ow += cos(de * 360 * (PI / 180) + xmotion) / 64;
    }
    
    ow += 0.001;
  }
  
  xmotion += 0.05;
  ymotion += 0.0125;
  rmotion += 0.012;
  tmotion += 0.001;
  tmotion2 += 0.002;
}

void setup() {
  size(1024, 700);

  frameRate(60); 
  
  colormap = loadImage(""data.jpg"");
  colormap2 = loadImage(""data2.jpg"");
  
  for (int e = 0; e < elems; e += elems_step) {
    for (int d = 0; d < dots; d += dots_step) {
      ldmotion[d + e * dots] = random(0.5);
    }
  }

  background(0);
}

void draw() {
  //background(0);
 
  draw_landscape();
}"
"560781","3D textured / fur tunnel","mySketch","/**
  * ""Dots"" textured / fur 3D tunnel
  */

PImage colormap;

float xmotion = 0;
float ymotion = 0;
float rmotion = 0;

int elems = 120; // can improve the rendering quality by increasing it and lowering the xrad_step / yrad_step variable
int dots = 120; // improve tunnel quality (to be used with rect_size)

int dots_step = 1;
int elems_step = 1;

float []ldmotion = new float[elems * dots];

void draw_landscape() {
  float mx = 4. + mouseX / 1024.0 * 8;
  
  int rect_size = (int)mx;
  
  // make it like ""fur"" by applying motion blur
  fill(0, 0, 0, 24);
  rect(0, 0, 1024, 700);
  
  noStroke();
  
  // initial circle size
  int bsize = 16;
  
  int xoff = 1024 / 2;
  int yoff = 700 / 2;
  
  int xrad_step = 6;
  int yrad_step = 6;
  
  int xdeform = 100;
  int ydeform = 100;
  
  float xrmotion_size = 16;
  float yrmotion_size = 16;
  
  for (int e = 0; e < elems; e += elems_step) {
    float de = (float)e / elems;
    
    float bd = de * 4;
    
    float ex = sin(de * 360 * (PI / 180) + xmotion);
    float ey = cos(de * 360 * (PI / 180) + ymotion);
    
    float xrad = e * xrad_step + bsize + sin(de * 360 * (PI / 180) + xmotion) * xrmotion_size;
    float yrad = e * yrad_step + bsize + cos(de * 360 * (PI / 180) + xmotion) * yrmotion_size;
    
    float final_ex = xoff + ex * xdeform;
    
    float xpp = (de * 360 * (PI / 180)) / 2;
    
    float xrepeat = 1;
    int xxd = ((int)(de * (colormap.width * xrepeat)))&(colormap.width-1);
    
    for (int d = 0; d < dots; d += dots_step) {
      float dd = (float)d / dots;
      
      float xp = dd * 360 * (PI / 180);
      float yp = dd * 360 * (PI / 180);
      
      // important phase to improve the rendering, offset the dots per circles so that it ""fill more space"", additionaly mess up the dots gradually
      xp += xpp + rmotion * ldmotion[d + e * dots];
      yp += xpp + rmotion * ldmotion[d + e * dots];
      
      float final_x = final_ex + sin(xp) * xrad;
      float final_y = yoff + ey * ydeform + cos(yp) * yrad;
      
      // do not compute outside boundary
      if (final_x >= 1023 || final_x < 0 || final_y >= 699 | final_y < 0) {
        continue;
      }
      
      // apply colormap / texture
      float yrepeat = 1;
      
      int yyd = (((int)(dd * (colormap.height * yrepeat)))&(colormap.height-1)) * colormap.width;
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      fill(r, g, b);
      
      rect(final_x, final_y, rect_size, rect_size);
    }
  }
  
  xmotion += 0.05;
  ymotion += 0.025;
  rmotion += 0.012;
}

void setup() {
  size(1024, 700);

  frameRate(60); 
  
  colormap = loadImage(""data.jpg"");
  
  for (int e = 0; e < elems; e += elems_step) {
    for (int d = 0; d < dots; d += dots_step) {
      ldmotion[d + e * dots] = random(0.005);
    }
  }

  background(0);
}

void draw() {
  //background(0);
 
  draw_landscape();
}"
"560781","3D textured / fur tunnel","mySketch","/**
  * ""Dots"" textured / fur 3D tunnel
  */

PImage colormap;

float xmotion = 0;
float ymotion = 0;
float rmotion = 0;

int elems = 120; // can improve the rendering quality by increasing it and lowering the xrad_step / yrad_step variable
int dots = 120; // improve tunnel quality (to be used with rect_size)

int dots_step = 1;
int elems_step = 1;

float []ldmotion = new float[elems * dots];

void draw_landscape() {
  float mx = 4. + mouseX / 1024.0 * 8;
  
  int rect_size = (int)mx;
  
  // make it like ""fur"" by applying motion blur
  fill(0, 0, 0, 24);
  rect(0, 0, 1024, 700);
  
  noStroke();
  
  // initial circle size
  int bsize = 16;
  
  int xoff = 1024 / 2;
  int yoff = 700 / 2;
  
  int xrad_step = 6;
  int yrad_step = 6;
  
  int xdeform = 100;
  int ydeform = 100;
  
  float xrmotion_size = 16;
  float yrmotion_size = 16;
  
  for (int e = 0; e < elems; e += elems_step) {
    float de = (float)e / elems;
    
    float bd = de * 4;
    
    float ex = sin(de * 360 * (PI / 180) + xmotion);
    float ey = cos(de * 360 * (PI / 180) + ymotion);
    
    float xrad = e * xrad_step + bsize + sin(de * 360 * (PI / 180) + xmotion) * xrmotion_size;
    float yrad = e * yrad_step + bsize + cos(de * 360 * (PI / 180) + xmotion) * yrmotion_size;
    
    float final_ex = xoff + ex * xdeform;
    
    float xpp = (de * 360 * (PI / 180)) / 2;
    
    float xrepeat = 1;
    int xxd = ((int)(de * (colormap.width * xrepeat)))&(colormap.width-1);
    
    for (int d = 0; d < dots; d += dots_step) {
      float dd = (float)d / dots;
      
      float xp = dd * 360 * (PI / 180);
      float yp = dd * 360 * (PI / 180);
      
      // important phase to improve the rendering, offset the dots per circles so that it ""fill more space"", additionaly mess up the dots gradually
      xp += xpp + rmotion * ldmotion[d + e * dots];
      yp += xpp + rmotion * ldmotion[d + e * dots];
      
      float final_x = final_ex + sin(xp) * xrad;
      float final_y = yoff + ey * ydeform + cos(yp) * yrad;
      
      // do not compute outside boundary
      if (final_x >= 1023 || final_x < 0 || final_y >= 699 | final_y < 0) {
        continue;
      }
      
      // apply colormap / texture
      float yrepeat = 1;
      
      int yyd = (((int)(dd * (colormap.height * yrepeat)))&(colormap.height-1)) * colormap.width;
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      fill(r, g, b);
      
      rect(final_x, final_y, rect_size, rect_size);
    }
  }
  
  xmotion += 0.05;
  ymotion += 0.025;
  rmotion += 0.012;
}

void setup() {
  size(1024, 700);

  frameRate(60); 
  
  colormap = loadImage(""data.jpg"");
  
  for (int e = 0; e < elems; e += elems_step) {
    for (int d = 0; d < dots; d += dots_step) {
      ldmotion[d + e * dots] = random(0.005);
    }
  }

  background(0);
}

void draw() {
  //background(0);
 
  draw_landscape();
}"
"560781","3D textured / fur tunnel","mySketch","/**
  * 3D textured / fur tunnel made of rectangles
  */

PImage colormap;

float xmotion = 0;
float ymotion = 0;
float rmotion = 0;

int elems = 120; // can improve the rendering quality by increasing it and lowering the xrad_step / yrad_step variable
int dots = 120; // improve tunnel quality (to be used with rect_size)

int dots_step = 1;
int elems_step = 1;

float []ldmotion = new float[elems * dots];

void draw_landscape() {
  float mx = 4. + mouseX / 1024.0 * 8;
  
  int rect_size = (int)mx;
  
  // make it like ""fur"" by applying motion blur
  fill(0, 0, 0, 24);
  rect(0, 0, 1024, 700);
  
  noStroke();
  
  // initial circle size
  int bsize = 16;
  
  int xoff = 1024 / 2;
  int yoff = 700 / 2;
  
  int xrad_step = 6;
  int yrad_step = 6;
  
  int xdeform = 100;
  int ydeform = 100;
  
  float xrmotion_size = 16;
  float yrmotion_size = 16;
  
  for (int e = 0; e < elems; e += elems_step) {
    float de = (float)e / elems;
    
    float bd = de * 4;
    
    float ex = sin(de * 360 * (PI / 180) + xmotion);
    float ey = cos(de * 360 * (PI / 180) + ymotion);
    
    float xrad = e * xrad_step + bsize + sin(de * 360 * (PI / 180) + xmotion) * xrmotion_size;
    float yrad = e * yrad_step + bsize + cos(de * 360 * (PI / 180) + xmotion) * yrmotion_size;
    
    float final_ex = xoff + ex * xdeform;
    
    float xpp = (de * 360 * (PI / 180)) / 2;
    
    float xrepeat = 1;
    int xxd = ((int)(de * (colormap.width * xrepeat)))&(colormap.width-1);
    
    for (int d = 0; d < dots; d += dots_step) {
      float dd = (float)d / dots;
      
      float xp = dd * 360 * (PI / 180);
      float yp = dd * 360 * (PI / 180);
      
      // important phase to improve the rendering, offset the dots per circles so that it ""fill more space"", additionaly mess up the dots gradually
      xp += xpp + rmotion * ldmotion[d + e * dots];
      yp += xpp + rmotion * ldmotion[d + e * dots];
      
      float final_x = final_ex + sin(xp) * xrad;
      float final_y = yoff + ey * ydeform + cos(yp) * yrad;
      
      // do not compute outside boundary
      if (final_x >= 1023 || final_x < 0 || final_y >= 699 | final_y < 0) {
        continue;
      }
      
      // apply colormap / texture
      float yrepeat = 1;
      
      int yyd = (((int)(dd * (colormap.height * yrepeat)))&(colormap.height-1)) * colormap.width;
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      fill(r, g, b);
      
      rect(final_x, final_y, rect_size, rect_size);
    }
  }
  
  xmotion += 0.05;
  ymotion += 0.025;
  rmotion += 0.012;
}

void setup() {
  size(1024, 700);

  frameRate(60); 
  
  colormap = loadImage(""data.jpg"");
  
  for (int e = 0; e < elems; e += elems_step) {
    for (int d = 0; d < dots; d += dots_step) {
      ldmotion[d + e * dots] = random(0.005);
    }
  }

  background(0);
}

void draw() {
  //background(0);
 
  draw_landscape();
}"
"560781","3D textured / fur tunnel","mySketch","/**
  * 3D textured / fur tunnel made of rectangles
  */

PImage colormap;

float xmotion = 0;
float ymotion = 0;
float rmotion = 0;

int elems = 120; // can improve the rendering quality by increasing it and lowering the xrad_step / yrad_step variable
int dots = 120; // improve tunnel quality (to be used with rect_size)

int dots_step = 1;
int elems_step = 1;

float []ldmotion = new float[elems * dots];

void draw_landscape() {
  float mx = 4. + mouseX / 1024.0 * 8;
  
  int rect_size = (int)mx;
  
  // make it like ""fur"" by applying motion blur
  fill(0, 0, 0, 24);
  rect(0, 0, 1024, 700);
  
  noStroke();
  
  // initial circle size
  int bsize = 16;
  
  int xoff = 1024 / 2;
  int yoff = 700 / 2;
  
  int xrad_step = 6;
  int yrad_step = 6;
  
  int xdeform = 100;
  int ydeform = 100;
  
  float xrmotion_size = 16;
  float yrmotion_size = 16;
  
  for (int e = 0; e < elems; e += elems_step) {
    float de = (float)e / elems;
    
    float bd = de * 4;
    
    float ex = sin(de * 360 * (PI / 180) + xmotion);
    float ey = cos(de * 360 * (PI / 180) + ymotion);
    
    float xrad = e * xrad_step + bsize + sin(de * 360 * (PI / 180) + xmotion) * xrmotion_size;
    float yrad = e * yrad_step + bsize + cos(de * 360 * (PI / 180) + xmotion) * yrmotion_size;
    
    float final_ex = xoff + ex * xdeform;
    
    float xpp = (de * 360 * (PI / 180)) / 2;
    
    float xrepeat = 1;
    int xxd = ((int)(de * (colormap.width * xrepeat)))&(colormap.width-1);
    
    for (int d = 0; d < dots; d += dots_step) {
      float dd = (float)d / dots;
      
      float xp = dd * 360 * (PI / 180);
      float yp = dd * 360 * (PI / 180);
      
      // important phase to improve the rendering, offset the dots per circles so that it ""fill more space"", additionaly mess up the dots gradually
      xp += xpp + rmotion * ldmotion[d + e * dots];
      yp += xpp + rmotion * ldmotion[d + e * dots];
      
      float final_x = final_ex + sin(xp) * xrad;
      float final_y = yoff + ey * ydeform + cos(yp) * yrad;
      
      // do not compute outside boundary
      if (final_x >= 1023 || final_x < 0 || final_y >= 699 | final_y < 0) {
        continue;
      }
      
      // apply colormap / texture
      float yrepeat = 1;
      
      int yyd = (((int)(dd * (colormap.height * yrepeat)))&(colormap.height-1)) * colormap.width;
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      fill(r, g, b);
      
      rect(final_x, final_y, rect_size, rect_size);
    }
  }
  
  xmotion += 0.05;
  ymotion += 0.025;
  rmotion += 0.012;
}

void setup() {
  size(1024, 700);

  frameRate(60); 
  
  colormap = loadImage(""data.jpg"");
  
  for (int e = 0; e < elems; e += elems_step) {
    for (int d = 0; d < dots; d += dots_step) {
      ldmotion[d + e * dots] = random(0.005);
    }
  }

  background(0);
}

void draw() {
  //background(0);
 
  draw_landscape();
}"
"560781","3D textured / fur tunnel","mySketch","/**
  * 3D textured / fur tunnel made of rectangles
  */

PImage colormap;

float xmotion = 0;
float ymotion = 0;
float rmotion = 0;

int elems = 120; // can improve the rendering quality by increasing it and lowering the xrad_step / yrad_step variable
int dots = 120; // improve tunnel quality (to be used with rect_size)

int dots_step = 1;
int elems_step = 1;

float []ldmotion = new float[elems * dots];

void draw_landscape() {
  float mx = 4. + mouseX / 1024.0 * 8;
  
  int rect_size = (int)mx;
  
  // make it like ""fur"" by applying motion blur
  fill(0, 0, 0, 24);
  rect(0, 0, 1024, 700);
  
  noStroke();
  
  // initial circle size
  int bsize = 16;
  
  int xoff = 1024 / 2;
  int yoff = 700 / 2;
  
  int xrad_step = 6;
  int yrad_step = 6;
  
  int xdeform = 100;
  int ydeform = 100;
  
  float xrmotion_size = 16;
  float yrmotion_size = 16;
  
  for (int e = 0; e < elems; e += elems_step) {
    float de = (float)e / elems;
    
    float bd = de * 4;
    
    float ex = sin(de * 360 * (PI / 180) + xmotion);
    float ey = cos(de * 360 * (PI / 180) + ymotion);
    
    float xrad = e * xrad_step + bsize + sin(de * 360 * (PI / 180) + xmotion) * xrmotion_size;
    float yrad = e * yrad_step + bsize + cos(de * 360 * (PI / 180) + xmotion) * yrmotion_size;
    
    float final_ex = xoff + ex * xdeform;
    
    float xpp = (de * 360 * (PI / 180)) / 2;
    
    float xrepeat = 1;
    int xxd = ((int)(de * (colormap.width * xrepeat)));
    
    for (int d = 0; d < dots; d += dots_step) {
      float dd = (float)d / dots;
      
      float xp = dd * 360 * (PI / 180);
      float yp = dd * 360 * (PI / 180);
      
      // important phase to improve the rendering, offset the dots per circles so that it ""fill more space"", additionaly mess up the dots gradually
      xp += xpp + rmotion * ldmotion[d + e * dots];
      yp += xpp + rmotion * ldmotion[d + e * dots];
      
      float final_x = final_ex + sin(xp) * xrad;
      float final_y = yoff + ey * ydeform + cos(yp) * yrad;
      
      // do not compute outside boundary
      if (final_x >= 1023 || final_x < 0 || final_y >= 699 | final_y < 0) {
        continue;
      }
      
      // apply colormap / texture
      float yrepeat = 1;
      
      int yyd = (((int)(dd * (colormap.height * yrepeat)))) * colormap.width;
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      fill(r, g, b);
      
      rect(final_x, final_y, rect_size, rect_size);
    }
  }
  
  xmotion += 0.05;
  ymotion += 0.025;
  rmotion += 0.012;
}

void setup() {
  size(1024, 700);

  frameRate(60); 
  
  colormap = loadImage(""data.jpg"");
  
  for (int e = 0; e < elems; e += elems_step) {
    for (int d = 0; d < dots; d += dots_step) {
      ldmotion[d + e * dots] = random(0.005);
    }
  }

  background(0);
}

void draw() {
  //background(0);
 
  draw_landscape();
}"
"560781","3D textured / fur tunnel","mySketch","/**
  * 3D textured / fur tunnel made of rectangles
  */

PImage colormap;

float xmotion = 0;
float ymotion = 0;
float rmotion = 0;

int elems = 120; // can improve the rendering quality by increasing it and lowering the xrad_step / yrad_step variable
int dots = 120; // improve tunnel quality (to be used with rect_size)

int dots_step = 1;
int elems_step = 1;

float []ldmotion = new float[elems * dots];

void draw_landscape() {
  float mx = 4. + mouseX / 1024.0 * 8;
  
  int rect_size = (int)mx;
  
  // make it like ""fur"" by applying motion blur
  fill(0, 0, 0, 24);
  rect(0, 0, 1024, 700);
  
  noStroke();
  
  // initial circle size
  int bsize = 16;
  
  int xoff = 1024 / 2;
  int yoff = 700 / 2;
  
  int xrad_step = 6;
  int yrad_step = 6;
  
  int xdeform = 100;
  int ydeform = 100;
  
  float xrmotion_size = 16;
  float yrmotion_size = 16;
  
  for (int e = 0; e < elems; e += elems_step) {
    float de = (float)e / elems;
    
    float bd = de * 4;
    
    float ex = sin(de * 360 * (PI / 180) + xmotion);
    float ey = cos(de * 360 * (PI / 180) + ymotion);
    
    float xrad = e * xrad_step + bsize + sin(de * 360 * (PI / 180) + xmotion) * xrmotion_size;
    float yrad = e * yrad_step + bsize + cos(de * 360 * (PI / 180) + xmotion) * yrmotion_size;
    
    float final_ex = xoff + ex * xdeform;
    
    float xpp = (de * 360 * (PI / 180)) / 2;
  
    float xrepeat = 1; // this doesn't work as expected ? if you increase this you must add ""&(colormap.width-1)"" to xxd below (after ""xrepeat)"") and ""&(colormap.height-1)"" to yyd
    int xxd = ((int)(de * (colormap.width * xrepeat)));
    
    for (int d = 0; d < dots; d += dots_step) {
      float dd = (float)d / dots;
      
      float xp = dd * 360 * (PI / 180);
      float yp = dd * 360 * (PI / 180);
      
      // important phase to improve the rendering, offset the dots per circles so that it ""fill more space"", additionaly mess up the dots gradually
      xp += xpp + rmotion * ldmotion[d + e * dots];
      yp += xpp + rmotion * ldmotion[d + e * dots];
      
      float final_x = final_ex + sin(xp) * xrad;
      float final_y = yoff + ey * ydeform + cos(yp) * yrad;
      
      // do not compute outside boundary
      if (final_x >= 1040 || final_x < -16 || final_y >= 716 | final_y < -16) {
        continue;
      }
      
      // apply colormap / texture
      float yrepeat = 1;
      
      int yyd = (((int)(dd * (colormap.height * yrepeat)))) * colormap.width;
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      fill(r, g, b);
      
      rect(final_x, final_y, rect_size, rect_size);
			
/*
			// alternative take which make snake-like texturing with star pattern, also very good for low-quality texturing when increasing rect_size
      rect(final_x + rect_size, final_y, rect_size, rect_size);
      rect(final_x - rect_size, final_y, rect_size, rect_size);
      rect(final_x, final_y + rect_size, rect_size, rect_size);
      rect(final_x, final_y - rect_size, rect_size, rect_size);
*/
    }
  }
  
  xmotion += 0.05;
  ymotion += 0.025;
  rmotion += 0.012;
}

void setup() {
  size(1024, 700);

  frameRate(60); 
  
  colormap = loadImage(""data.jpg"");
  
  for (int e = 0; e < elems; e += elems_step) {
    for (int d = 0; d < dots; d += dots_step) {
      ldmotion[d + e * dots] = random(0.005);
    }
  }

  background(0);
}

void draw() {
  //background(0);
 
  draw_landscape();
}"
"560781","3D textured / fur tunnel","mySketch","/**
  * 3D textured / fur tunnel made of rectangles
  */

PImage colormap;

float xmotion = 0;
float ymotion = 0;
float rmotion = 0;

int elems = 120; // can improve the rendering quality by increasing it and lowering the xrad_step / yrad_step variable
int dots = 120; // improve tunnel quality (to be used with rect_size)

int dots_step = 1;
int elems_step = 1;

float []ldmotion = new float[elems * dots];

void draw_landscape() {
  float mx = 4. + mouseX / 1024.0 * 8;
  
  int rect_size = (int)mx;
  
  // make it like ""fur"" by applying motion blur
  fill(0, 0, 0, 24);
  rect(0, 0, 1024, 700);
  
  noStroke();
  
  // initial circle size
  int bsize = 16;
  
  int xoff = 1024 / 2;
  int yoff = 700 / 2;
  
  int xrad_step = 6;
  int yrad_step = 6;
  
  int xdeform = 100;
  int ydeform = 100;
  
  float xrmotion_size = 16;
  float yrmotion_size = 16;
  
  for (int e = 0; e < elems; e += elems_step) {
    float de = (float)e / elems;
    
    float bd = de * 4;
    
    float ex = sin(de * 360 * (PI / 180) + xmotion);
    float ey = cos(de * 360 * (PI / 180) + ymotion);
    
    float xrad = e * xrad_step + bsize + sin(de * 360 * (PI / 180) + xmotion) * xrmotion_size;
    float yrad = e * yrad_step + bsize + cos(de * 360 * (PI / 180) + xmotion) * yrmotion_size;
    
    float final_ex = xoff + ex * xdeform;
    
    float xpp = (de * 360 * (PI / 180)) / 2;
  
    float xrepeat = 1; // this doesn't work as expected ? if you increase this you must add ""&(colormap.width-1)"" to xxd below (after ""xrepeat)"") and ""&(colormap.height-1)"" to yyd
    int xxd = ((int)(de * (colormap.width * xrepeat)));
    
    for (int d = 0; d < dots; d += dots_step) {
      float dd = (float)d / dots;
      
      float xp = dd * 360 * (PI / 180);
      float yp = dd * 360 * (PI / 180);
      
      // important phase to improve the rendering, offset the dots per circles so that it ""fill more space"", additionaly mess up the dots gradually
      xp += xpp + rmotion * ldmotion[d + e * dots];
      yp += xpp + rmotion * ldmotion[d + e * dots];
      
      float final_x = final_ex + sin(xp) * xrad;
      float final_y = yoff + ey * ydeform + cos(yp) * yrad;
      
      // do not compute outside boundary
      if (final_x >= 1040 || final_x < -16 || final_y >= 716 | final_y < -16) {
        continue;
      }
      
      // apply colormap / texture
      float yrepeat = 1;
      
      int yyd = (((int)(dd * (colormap.height * yrepeat)))) * colormap.width;
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      fill(r, g, b);
      
      rect(final_x, final_y, rect_size, rect_size);
			
/*
			// alternative take which make snake-like texture pattern with ""star pattern"", also very good for low-quality texturing when increasing / lowering rect_size
      rect(final_x + rect_size, final_y, rect_size, rect_size);
      rect(final_x - rect_size, final_y, rect_size, rect_size);
      rect(final_x, final_y + rect_size, rect_size, rect_size);
      rect(final_x, final_y - rect_size, rect_size, rect_size);
*/
    }
  }
  
  xmotion += 0.05;
  ymotion += 0.025;
  rmotion += 0.012;
}

void setup() {
  size(1024, 700);

  frameRate(60); 
  
  colormap = loadImage(""data.jpg"");
  
  for (int e = 0; e < elems; e += elems_step) {
    for (int d = 0; d < dots; d += dots_step) {
      ldmotion[d + e * dots] = random(0.005);
    }
  }

  background(0);
}

void draw() {
  //background(0);
 
  draw_landscape();
}"
"560781","3D textured / fur tunnel","mySketch","/**
  * 3D textured / fur tunnel made of rectangles
  */

PImage colormap;

float xmotion = 0;
float ymotion = 0;
float rmotion = 0;

int elems = 120; // can improve the rendering quality by increasing it and lowering the xrad_step / yrad_step variable
int dots = 120; // improve tunnel quality (to be used with rect_size)

int dots_step = 1;
int elems_step = 1;

float []ldmotion = new float[elems * dots];

void draw_landscape() {
  float mx = 4. + mouseX / 1024.0 * 8;
  
  int rect_size = (int)mx;
  
  // make it like ""fur"" by applying motion blur
  fill(0, 0, 0, 24);
  rect(0, 0, 1024, 700);
  
  noStroke();
  
  // initial circle size
  int bsize = 16;
  
  int xoff = 1024 / 2;
  int yoff = 700 / 2;
  
  int xrad_step = 6;
  int yrad_step = 6;
  
  int xdeform = 100;
  int ydeform = 100;
  
  float xrmotion_size = 16;
  float yrmotion_size = 16;
  
  for (int e = 0; e < elems; e += elems_step) {
    float de = (float)e / elems;
    
    float bd = de * 4;
    
    float ex = sin(de * 360 * (PI / 180) + xmotion);
    float ey = cos(de * 360 * (PI / 180) + ymotion);
    
    float xrad = e * xrad_step + bsize + sin(de * 360 * (PI / 180) + xmotion) * xrmotion_size;
    float yrad = e * yrad_step + bsize + cos(de * 360 * (PI / 180) + xmotion) * yrmotion_size;
    
    float final_ex = xoff + ex * xdeform;
    
    float xpp = (de * 360 * (PI / 180)) / 2;
  
    float xrepeat = 1; // this doesn't work as expected ? if you increase this you must add ""&(colormap.width-1)"" to xxd below (after ""xrepeat)"") and ""&(colormap.height-1)"" to yyd
    int xxd = ((int)(de * (colormap.width * xrepeat)));
    
    for (int d = 0; d < dots; d += dots_step) {
      float dd = (float)d / dots;
      
      float xp = dd * 360 * (PI / 180);
      float yp = dd * 360 * (PI / 180);
      
      // important phase to improve the rendering, offset the dots per circles so that it ""fill more space"", additionaly mess up the dots gradually
      xp += xpp + rmotion * ldmotion[d + e * dots];
      yp += xpp + rmotion * ldmotion[d + e * dots];
      
      float final_x = final_ex + sin(xp) * xrad;
      float final_y = yoff + ey * ydeform + cos(yp) * yrad;
      
      // do not compute outside boundary
      if (final_x >= 1040 || final_x < -16 || final_y >= 716 | final_y < -16) {
        continue;
      }
      
      // apply colormap / texture
      float yrepeat = 1;
      
      int yyd = (((int)(dd * (colormap.height * yrepeat)))) * colormap.width;
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      fill(r, g, b);
      
      rect(final_x, final_y, rect_size, rect_size);
			
/*
			// alternative take which make snake-like texture pattern with ""star pattern"", also very good for low-quality texturing when increasing / lowering rect_size
			// fill(0, 0, 255 * bd); // you can also build up a sub-pattern / fog to the inside wall of the tunnel by playing with colors
      rect(final_x + rect_size, final_y, rect_size, rect_size);
      rect(final_x - rect_size, final_y, rect_size, rect_size);
      rect(final_x, final_y + rect_size, rect_size, rect_size);
      rect(final_x, final_y - rect_size, rect_size, rect_size);
*/
    }
  }
  
  xmotion += 0.05;
  ymotion += 0.025;
  rmotion += 0.012;
}

void setup() {
  size(1024, 700);

  frameRate(60); 
  
  colormap = loadImage(""data.jpg"");
  
  for (int e = 0; e < elems; e += elems_step) {
    for (int d = 0; d < dots; d += dots_step) {
      ldmotion[d + e * dots] = random(0.005);
    }
  }

  background(0);
}

void draw() {
  //background(0);
 
  draw_landscape();
}"
"560781","3D textured / fur tunnel","mySketch","/**
  * 3D textured / fur tunnel made of rectangles
  */

PImage colormap;

float xmotion = 0;
float ymotion = 0;
float rmotion = 0;

int elems = 120; // can improve the rendering quality by increasing it and lowering the xrad_step / yrad_step variable
int dots = 120; // improve tunnel quality (to be used with rect_size)

int dots_step = 1;
int elems_step = 1;

float []ldmotion = new float[elems * dots];

void draw_landscape() {
  float mx = 4. + mouseX / 1024.0 * 8;
  
  int rect_size = (int)mx;
  
  // make it like ""fur"" by applying motion blur
  fill(0, 0, 0, 24);
  rect(0, 0, 1024, 700);
  
  noStroke();
  
  // initial circle size
  int bsize = 16;
  
  int xoff = 1024 / 2;
  int yoff = 700 / 2;
  
  int xrad_step = 6;
  int yrad_step = 6;
  
  int xdeform = 100;
  int ydeform = 100;
  
  float xrmotion_size = 16;
  float yrmotion_size = 16;
  
  for (int e = 0; e < elems; e += elems_step) {
    float de = (float)e / elems;
    
    float bd = de * 4;
    
    float ex = sin(de * 360 * (PI / 180) + xmotion);
    float ey = cos(de * 360 * (PI / 180) + ymotion);
    
    float xrad = e * xrad_step + bsize + sin(de * 360 * (PI / 180) + xmotion) * xrmotion_size;
    float yrad = e * yrad_step + bsize + cos(de * 360 * (PI / 180) + xmotion) * yrmotion_size;
    
    float final_ex = xoff + ex * xdeform;
    
    float xpp = (de * 360 * (PI / 180)) / 2;
  
    float xrepeat = 1; // if you increase this you must add ""%colormap.width"" to xxd below (after ""xrepeat)"") and ""%colormap.height"" to yyd
    int xxd = ((int)(de * (colormap.width * xrepeat)));
    
    for (int d = 0; d < dots; d += dots_step) {
      float dd = (float)d / dots;
      
      float xp = dd * 360 * (PI / 180);
      float yp = dd * 360 * (PI / 180);
      
      // important phase to improve the rendering, offset the dots per circles so that it ""fill more space"", additionaly mess up the dots gradually
      xp += xpp + rmotion * ldmotion[d + e * dots];
      yp += xpp + rmotion * ldmotion[d + e * dots];
      
      float final_x = final_ex + sin(xp) * xrad;
      float final_y = yoff + ey * ydeform + cos(yp) * yrad;
      
      // do not compute outside boundary
      if (final_x >= 1040 || final_x < -16 || final_y >= 716 | final_y < -16) {
        continue;
      }
      
      // apply colormap / texture
      float yrepeat = 1;
      
      int yyd = (((int)(dd * (colormap.height * yrepeat)))) * colormap.width;
 
      int cl = (int)xxd + yyd;
      
      int r = (int)(red(colormap.pixels[cl]) * bd);
      int g = (int)(green(colormap.pixels[cl]) * bd);
      int b = (int)(blue(colormap.pixels[cl]) * bd);
      
      fill(r, g, b);
      
      rect(final_x, final_y, rect_size, rect_size);
			
/*
			// alternative take which make snake-like texture pattern with ""star pattern"", also very good for low-quality texturing when increasing / lowering rect_size
			// fill(0, 0, 255 * bd); // you can also build up a sub-pattern / fog to the inside wall of the tunnel by playing with colors
      rect(final_x + rect_size, final_y, rect_size, rect_size);
      rect(final_x - rect_size, final_y, rect_size, rect_size);
      rect(final_x, final_y + rect_size, rect_size, rect_size);
      rect(final_x, final_y - rect_size, rect_size, rect_size);
*/
    }
  }
  
  xmotion += 0.05;
  ymotion += 0.025;
  rmotion += 0.012;
}

void setup() {
  size(1024, 700);

  frameRate(60); 
  
  colormap = loadImage(""data.jpg"");
  
  for (int e = 0; e < elems; e += elems_step) {
    for (int d = 0; d < dots; d += dots_step) {
      ldmotion[d + e * dots] = random(0.005);
    }
  }

  background(0);
}

void draw() {
  //background(0);
 
  draw_landscape();
}"
"560394","Waving flags of the World","mySketch","/**
  * Flags of the world made of discrete rectangles.
  */

PImage heightmap;

float xmotion = 0;
float ymotion = 0;

void draw_landscape() {
  int xoff = 64;
  int yoff = 128;
  
  float mx = mouseX / 1024.0 * 4;
  float my = mouseY / 1024.0 * 2;
  
  // change the flag discrete resolution = quality
  int rect_size = 1 + (int)mx;
  float x_step_size = 4 + (int)my;
  float y_step_size = 4 + (int)my;
  //
  
  float x_end = 1024 - xoff;
  float y_end = 700 - yoff;
  
  fill(0, 0, 0, 32);
  rect(0, 0, 1024, 700);
  
  noStroke();
  for (int y = yoff; y < y_end; y += y_step_size) {
      float ys = (y_end - yoff);
      float yo = (y - yoff);
      float yy = yo / ys;
      int yyd = (int)(yy * heightmap.height) * heightmap.width;
      float yyy = yy - 0.5;
      
      for (int x = xoff; x < x_end; x += x_step_size) {
        float xs = (x_end - xoff);
        float xo = (x - xoff);
        float xx = xo / xs;
        
        float xxd = xx * heightmap.width;
        
        int cl = (int)xxd + yyd;
        
        int r = (int)red(heightmap.pixels[cl]);
        int g = (int)green(heightmap.pixels[cl]);
        int b = (int)blue(heightmap.pixels[cl]);
        
        fill(r, g , b);
        
        float xxx = xx - 0.5;

        rect(x + cos(xxx*yyy * PI * 4 + xmotion) * 24, y + sin(xxx*yyy * PI * 7 + ymotion) * 24, rect_size, rect_size);
      }
  }
  
  xmotion += 0.0075;
  ymotion += 0.05;
}

void setup() {
  size(1024, 700);

  frameRate(60); 
  
  heightmap = loadImage(""flags.png"");

  background(0);
}

void draw() {
  //background(0);
 
  draw_landscape();
}"
"560394","Waving flags of the World","mySketch","/**
  * Flags of the world made of discrete rectangles.
  */

PImage heightmap;

float xmotion = 0;
float ymotion = 0;

void draw_landscape() {
  int xoff = 64;
  int yoff = 128;
  
  float mx = mouseX / 1024.0 * 4;
  float my = mouseY / 1024.0 * 2;
  
  // change the flag discrete resolution = quality
  int rect_size = 1 + (int)mx;
  float x_step_size = 6 + (int)my;
  float y_step_size = 6 + (int)my;
  //
  
  float x_end = 1024 - xoff;
  float y_end = 700 - yoff;
  
	// some blur
  fill(0, 0, 0, 64);
  rect(0, 0, 1024, 700);
  
  noStroke();
  for (int y = yoff; y < y_end; y += y_step_size) {
      float ys = (y_end - yoff);
      float yo = (y - yoff);
      float yy = yo / ys;
      int yyd = (int)(yy * heightmap.height) * heightmap.width;
      float yyy = yy - 0.5;
      
      for (int x = xoff; x < x_end; x += x_step_size) {
        float xs = (x_end - xoff);
        float xo = (x - xoff);
        float xx = xo / xs;
        
        float xxd = xx * heightmap.width;
        
        int cl = (int)xxd + yyd;
        
        int r = (int)red(heightmap.pixels[cl]);
        int g = (int)green(heightmap.pixels[cl]);
        int b = (int)blue(heightmap.pixels[cl]);
        
        fill(r, g , b);
        
        float xxx = xx - 0.5;

        rect(x + cos(xxx*yyy * PI * 4 + xmotion) * 24, y + sin(xxx*yyy * PI * 7 + ymotion) * 24, rect_size, rect_size);
      }
  }
  
  xmotion += 0.0075;
  ymotion += 0.05;
}

void setup() {
  size(1024, 700);

  frameRate(60); 
  
  heightmap = loadImage(""flags.png"");

  background(0);
}

void draw() {
  //background(0);
 
  draw_landscape();
}"
"560394","Waving flags of the World","mySketch","/**
  * Flags of the world made of discrete rectangles.
  */

PImage heightmap;

float xmotion = 0;
float ymotion = 0;

void draw_landscape() {
  int xoff = 64;
  int yoff = 128;
  
  float mx = mouseX / 1024.0 * 4;
  float my = mouseY / 1024.0 * 2;
  
  // change the flag discrete resolution = quality
  int rect_size = 1 + (int)mx;
  float x_step_size = 6 + (int)my;
  float y_step_size = 6 + (int)my;
  //
  
  float x_end = 1024 - xoff;
  float y_end = 700 - yoff;
  
	// some blur
  fill(0, 0, 0, 64);
  rect(0, 0, 1024, 700);
  
  noStroke();
  for (int y = yoff; y < y_end; y += y_step_size) {
      float ys = (y_end - yoff);
      float yo = (y - yoff);
      float yy = yo / ys;
      int yyd = (int)(yy * heightmap.height) * heightmap.width;
      float yyy = yy - 0.5;
      
      for (int x = xoff; x < x_end; x += x_step_size) {
        float xs = (x_end - xoff);
        float xo = (x - xoff);
        float xx = xo / xs;
        
        float xxd = xx * heightmap.width;
        
        int cl = (int)xxd + yyd;
        
        int r = (int)red(heightmap.pixels[cl]);
        int g = (int)green(heightmap.pixels[cl]);
        int b = (int)blue(heightmap.pixels[cl]);
        
        fill(r, g , b);
        
        float xxx = xx - 0.5;

        rect(x + cos(xxx*yyy * PI * 4 + xmotion) * 24, y + sin(xxx*yyy * PI * 7 + ymotion) * 24, rect_size, rect_size);
      }
  }
  
  xmotion += 0.0075;
  ymotion += 0.05;
}

void setup() {
  size(1024, 700);

  frameRate(60); 
  
  heightmap = loadImage(""flags.png"");

  background(0);
}

void draw() {
  //background(0);
 
  draw_landscape();
}"
"558818","Sea Shore","mySketch","var points = 100;
var rr = [];

function setup() {
	createCanvas(windowWidth, windowHeight);
	background(0);

	for (var i = 0; i < points; i += 1) {
		rr[i] = random() / 8;
	}
}

function draw() {
	background(0);
	fill(255, 255, 255 ,255);
	
	for (var i = 0; i < points-1; i += 1) {
		var dot_size = 4;
		var spacing = windowWidth / points;
		var spacing_y = windowHeight / 2 / 2;
		var px1 = windowWidth/2 - (points / 2) * spacing + i * spacing;
		var py1 = windowHeight/2 + sin(rr[i] * PI) * spacing_y;
		var px2 = windowWidth/2 - (points / 2) * spacing + (i+1) * spacing;
		var py2 = windowHeight/2 + sin(rr[i+1] * PI) * spacing_y;		
		stroke(255, 255, 0,255);
		rect(px1-dot_size/2, py1-dot_size/2, dot_size, dot_size);
		stroke(144);
		line(px1, py1, px2, py2);
	}
}"
"558818","Sea Shore","mySketch","var points = 12;
var lines = 50;
var rr = [];
var rr2 = [];
var t = [];
var tstep = [];

function setup() {
	createCanvas(windowWidth, windowHeight);
	background(0);

	for (var i = 0; i < points; i += 1) {
		rr[i] = random() / 4;
		rr2[i] = random() / 4;
		t[i] = 0;
		tstep[i] = random() / 16;
	}
}

function draw() {
	//background(0);
	//fill(255, 255, 255 ,255);
	
	for (var i = 0; i < points; i += 1) {	
		var dot_size = 8 - i / 8;
		if (abs(dot_size) < 1) {
			dot_size = 8;
		}
		
		var spacing = windowWidth / (points-2);
		var spacing_y = windowHeight / 2 / 2;
		var px1 = windowWidth/2 - (points / 2) * spacing + i * spacing;
		var py1 = windowHeight/2 + sin(rr[i] * PI) * spacing_y;
		var px2 = windowWidth/2 - (points / 2) * spacing + (i+1) * spacing;
		var py2 = windowHeight/2 + sin(rr[i+1] * PI) * spacing_y;	
		
		for (var d = -lines; d < lines; d += 1) {
			var dabs = abs(d);
			var id = dabs%points;
			
			var dcx = cos(d / lines / PI) - d/16;
			var dcy = sin(d / lines / PI) - d/16;
			
			var r = 255 - pow(dabs * 4, 1.25) + cos(t[i]) * 255;
			var g = 255 - pow(dabs * 3, 1.25) + cos(t[i]) * 255;
			var b = 255 - pow(dabs * 2, 1.25) + sin(t[i]) * 255;
			
			var x1 = px1+dcx*dot_size;
			var y1 = py1+dcy*dot_size;
			var x2 = px2+dcx*dot_size;
			var y2 = py2+dcy*dot_size;
			
			stroke(r, g, b);
			line(x1, y1, x2, y2);
		}
		
		for (var j = 0; j < points; j += 1) {	
			var sx = windowWidth / points;
			var sy = windowHeight / points;
			var x = sx * i;
			var y = sy * j;
			stroke(8, 8, 8);
			fill(0, 0, 8 + 255 * (rr[i] + rr2[j]), 8);
			rect(x, y, sx, sy);
		}
	}
	
	for (var i = 0; i < lines; i += 1) {
		rr[i] = rr[i] + (rr2[i] - rr[i]) * t[i];
		
		if (abs(rr[i]-rr2[i]) < 0.0005) {
			rr2[i] = random() / 4;
			t[i] = 0;
			tstep[i] = random() / 16;
		}
		
		t[i] += tstep[i];
	}
}"
"558818","Sea Shore","mySketch","var points = 12;
var lines = 50;
var rr = [];
var rr2 = [];
var t = [];
var tstep = [];

function setup() {
	createCanvas(windowWidth, windowHeight);
	background(0);

	for (var i = 0; i < points; i += 1) {
		rr[i] = random() / 4;
		rr2[i] = random() / 4;
		t[i] = 0;
		tstep[i] = random() / 16;
	}
}

function draw() {
	//background(0);
	//fill(255, 255, 255 ,255);
	
	for (var i = 0; i < points; i += 1) {	
		var dot_size = 8 - i / 8;
		if (abs(dot_size) < 1) {
			dot_size = 8;
		}
		
		var spacing = windowWidth / (points-2);
		var spacing_y = windowHeight / 2 / 2;
		var px1 = windowWidth/2 - (points / 2) * spacing + i * spacing;
		var py1 = windowHeight/2 + sin(rr[i] * PI) * spacing_y;
		var px2 = windowWidth/2 - (points / 2) * spacing + (i+1) * spacing;
		var py2 = windowHeight/2 + sin(rr[i+1] * PI) * spacing_y;	
		
		for (var d = -lines; d < lines; d += 1) {
			var dabs = abs(d);
			var id = dabs%points;
			
			var dcx = cos(d / lines / PI) - d/16;
			var dcy = sin(d / lines / PI) - d/16;
			
			var r = 255 - pow(dabs * 4, 1.25) + cos(t[i]) * 255;
			var g = 255 - pow(dabs * 3, 1.25) + cos(t[i]) * 255;
			var b = 255 - pow(dabs * 2, 1.25) + sin(t[i]) * 255;
			
			var x1 = px1+dcx*dot_size;
			var y1 = py1+dcy*dot_size;
			var x2 = px2+dcx*dot_size;
			var y2 = py2+dcy*dot_size;
			
			stroke(r, g, b);
			line(x1, y1, x2, y2);
		}
		
		for (var j = 0; j < points; j += 1) {	
			var sx = windowWidth / points;
			var sy = windowHeight / points;
			var x = sx * i;
			var y = sy * j;
			noStroke();
			fill(0, 0, 8 + 255 * (rr[i] + rr2[j]), 8);
			rect(x, y, sx, sy);
		}
	}
	
	for (var i = 0; i < lines; i += 1) {
		rr[i] = rr[i] + (rr2[i] - rr[i]) * t[i];
		
		if (abs(rr[i]-rr2[i]) < 0.0005) {
			rr2[i] = random() / 4;
			t[i] = 0;
			tstep[i] = random() / 16;
		}
		
		t[i] += tstep[i];
	}
}"
"558818","Sea Shore","mySketch","var points = 16;
var lines = 32;
var rr = [];
var rr2 = [];
var t = [];
var tstep = [];
var c = 0;

function setup() {
	createCanvas(windowWidth, windowHeight);
	background(0);

	for (var i = 0; i < points; i += 1) {
		rr[i] = cos(i / points * PI) / 16;
		rr2[i] = cos((i + 1) / points * PI) / 16;
		t[i] = 0;
		c[i] = i / points;
		tstep[i] = random() / 16;
	}
}

function draw() {
	//background(0);
	//fill(255, 255, 255 ,255);

	fill(0, 0, 0, 1);
	rect(0, 0, windowWidth, windowHeight);
	
	for (var i = 0; i < points; i += 1) {	
		var dot_size = 16 - i / 8;
		if (abs(dot_size) < 1) {
			dot_size = 8;
		}
		
		var spacing = windowWidth / (points-2);
		var spacing_y = windowHeight / 2 / 2;
		var px1 = windowWidth/2 - (points / 2) * spacing + i * spacing + 32;
		var py1 = windowHeight/2 + sin(rr[i] * PI) * spacing_y;
		var px2 = windowWidth/2 - (points / 2) * spacing + (i+1) * spacing + 32;
		var py2 = windowHeight/2 + sin(rr[i+1] * PI) * spacing_y;	
		
		for (var d = -lines; d < lines; d += 0.5) {
			var dabs = abs(d);
			var id = dabs%points;
			
			var dcx = cos(dabs / lines / PI) - d/8;
			var dcy = sin(dabs / lines / PI) - d/16;
			
			var x1 = px1+dcx*dot_size;
			var y1 = py1+dcy*dot_size;
			var x2 = px2+dcx*dot_size;
			var y2 = py2+dcy*dot_size;
			
			var r = 255 - pow(dabs * 8, 1.25) + cos(x1) * 8;
			var g = 255 - pow(dabs * 3, 1.25) + cos(dcy) * 8;
			var b = 255 - pow(dabs * 2, 1.25) + sin(dcy) * 255;
			
			stroke(r, g, b);
			line(x1, y1, x2, y2);
		}
	}
	
	for (var i = 0; i < lines; i += 1) {
		rr[i] = rr[i] + (rr2[i] - rr[i]) * t[i];
		
		if (abs(rr[i]-rr2[i]) < 0.005) {
			rr2[i] = cos((i + c) / points * PI) / 24;
			if (rr2[i] > PI * 2) {
				rr2[i] = 0;
			}
			
			t[i] = 0;
			tstep[i] = random() / 16;
		}
		
		t[i] += tstep[i];
	}
	
	c += 0.1;
}"
"558818","Sea Shore","mySketch","var points = 16;
var lines = 32;
var rr = [];
var rr2 = [];
var t = [];
var tstep = [];
var c = 0;

function setup() {
	createCanvas(windowWidth, windowHeight);
	background(0);

	for (var i = 0; i < points; i += 1) {
		rr[i] = cos(i / points * PI) / 16;
		rr2[i] = cos((i + 1) / points * PI) / 16;
		t[i] = 0;
		c[i] = i / points;
		tstep[i] = random() / 16;
	}
}

function draw() {
	//background(0);
	//fill(255, 255, 255 ,255);

	fill(0, 0, 0, 1);
	rect(0, 0, windowWidth, windowHeight);
	
	for (var i = 0; i < points; i += 1) {	
		var dot_size = 16 - i / 8;
		if (abs(dot_size) < 1) {
			dot_size = 8;
		}
		
		var spacing = windowWidth / (points-2);
		var spacing_y = windowHeight / 2 / 2;
		var px1 = windowWidth/2 - (points / 2) * spacing + i * spacing + 32;
		var py1 = windowHeight/2 + sin(rr[i] * PI) * spacing_y;
		var px2 = windowWidth/2 - (points / 2) * spacing + (i+1) * spacing + 32;
		var py2 = windowHeight/2 + sin(rr[i+1] * PI) * spacing_y;	
		
		for (var d = -lines; d < lines; d += 0.5) {
			var dabs = abs(d);
			var id = dabs%points;
			
			var dcx = cos(dabs / lines / PI) - d/8;
			var dcy = sin(dabs / lines / PI) - d/16;
			
			var x1 = px1+dcx*dot_size;
			var y1 = py1+dcy*dot_size;
			var x2 = px2+dcx*dot_size;
			var y2 = py2+dcy*dot_size;
			
			var r = 255 - pow(dabs * 8, 1.25) + cos(x1) * 8;
			var g = 255 - pow(dabs * 3, 1.25) + cos(dcy) * 8;
			var b = 255 - pow(dabs * 2, 1.25) + sin(dcy) * 255;
			
			stroke(r, g, b);
			line(x1, y1, x2, y2);
		}
	}
	
	for (var i = 0; i < lines; i += 1) {
		rr[i] = rr[i] + (rr2[i] - rr[i]) * t[i];
		
		if (abs(rr[i]-rr2[i]) < 0.005) {
			rr2[i] = cos((i + c) / points * PI) / 24;
			if (rr2[i] > PI * 2) {
				rr2[i] = 0;
			}
			
			t[i] = 0;
			tstep[i] = random() / 16;
		}
		
		t[i] += tstep[i];
	}
	
	c += 0.1;
}"
"558818","Sea Shore","mySketch","var points = 16;
var lines = 32;
var rr = [];
var rr2 = [];
var t = [];
var tstep = [];
var c = 0;

function setup() {
	createCanvas(windowWidth, windowHeight);
	background(0);

	for (var i = 0; i < points; i += 1) {
		rr[i] = cos(i / points * PI) / 16;
		rr2[i] = cos((i + 1) / points * PI) / 16;
		t[i] = 0;
		c[i] = i / points;
		tstep[i] = random() / 16;
	}
}

function draw() {
	//background(0);
	//fill(255, 255, 255 ,255);

	fill(0, 0, 0, 1);
	rect(0, 0, windowWidth, windowHeight);
	
	for (var i = 0; i < points; i += 1) {	
		var dot_size = 16 - i / 8;
		if (abs(dot_size) < 1) {
			dot_size = 8;
		}
		
		var spacing = windowWidth / (points-2);
		var spacing_y = windowHeight / 2 / 2;
		var px1 = windowWidth/2 - (points / 2) * spacing + i * spacing + 32;
		var py1 = windowHeight/2 + sin(rr[i] * PI) * spacing_y;
		var px2 = windowWidth/2 - (points / 2) * spacing + (i+1) * spacing + 32;
		var py2 = windowHeight/2 + sin(rr[i+1] * PI) * spacing_y;	
		
		for (var d = -lines; d < lines; d += 0.5) {
			var dabs = abs(d);
			var id = dabs%points;
			
			var dcx = cos(dabs / lines / PI) - d/8;
			var dcy = sin(dabs / lines / PI) - d/16;
			
			var x1 = px1+dcx*dot_size;
			var y1 = py1+dcy*dot_size;
			var x2 = px2+dcx*dot_size;
			var y2 = py2+dcy*dot_size;
			
			var r = 255 - pow(dabs * 8, 1.25) + cos(x1) * 8;
			var g = 255 - pow(dabs * 3, 1.25) + cos(dcy) * 8;
			var b = 255 - pow(dabs * 2, 1.25) + sin(dcy) * 255;
			
			stroke(r, g, b);
			line(x1, y1, x2, y2);
		}
	}
	
	for (var i = 0; i < lines; i += 1) {
		rr[i] = rr[i] + (rr2[i] - rr[i]) * t[i];
		
		if (abs(rr[i]-rr2[i]) < 0.005) {
			rr2[i] = cos((i + c) / points * PI) / 24;
			if (rr2[i] > PI * 2) {
				rr2[i] = 0;
			}
			
			t[i] = 0;
			tstep[i] = random() / 16;
		}
		
		t[i] += tstep[i];
	}
	
	c += 0.1;
}"
"555398","8-bit color-cycling Chessboard","mySketch","/*
  8-bit color-cycling chessboard effect
	
  A demo and a tool to build old-school color cycling chessboard with image mask support, initially done as a tool for a Sega Master System demo.
  
  The image mask is only black/white and should be the size of the screen, it can be improved quite easily if you want a detailed texture.
	
  The drawing code just draw half the checkerboard, the other half is mirrored.
  
  Can be used to generate many patterns by playing with sin/cos for the strip size and the others constants.
  
  To save the chessboard uncomment saveCheckerboard(); in the setup function, it will output a .bmp
  
  Note: For compatibility with processingjs, the color function is used instead of the RGB24 value, 
        otherwise the code is portable
  
  The generated background was added for fun (could be better with 3D stars)
*/

/* @pjs preload=""gns.png,moon.jpg""; */

final int SCREEN_WIDTH       = 256;
final int SCREEN_HEIGHT      = 192;
final int SCREEN_WIDTH_D2    = SCREEN_WIDTH/2;
final int Y_START            = (int)(SCREEN_HEIGHT/1.6); // the y position of the checkerboard
final int PALETTE_SIZE       = 8;
final int PALETTE_SIZE_D2    = PALETTE_SIZE/2;
final int PALETTE_STEP       = 1; // this shift the patterns around, 1 could be used to generate wavy pattern
final int INITIAL_STEP_Y     = 0; // initial block height
final int INITIAL_STRIP_SIZE = 48;
final float SMOOTH_EDGE      = 0.75; // this smooth blocks a bit so they don't appear aliased with y stepping > 1

PImage output_image;
PImage logo;
PImage background_image;
PImage background_stars;

float background_rot = 0;

int []palette = new int[PALETTE_SIZE*2+2];

float cycling_index, cycling_index2;

int RGB24(int r, int g, int b) {
  if (r < 0) r = 0;
  if (g < 0) g = 0;
  if (b < 0) b = 0;
  
  return b|(g<<8)|(r<<16);
}

int []lala = new int[PALETTE_SIZE*2+2];
void color_cycling() {
  int mxc = (int)((float)mouseX/SCREEN_WIDTH  * 360);
  int myc = (int)((float)mouseY/SCREEN_HEIGHT * 360);
  
  colorMode(HSB, 360);
  
   // quantize the hsb to a 64 colors palette similar to the one used on the Sega Master System
  color hsb1 = color(((int)mxc/20)*20, 360, 360);
  color hsb2 = color(((int)myc/20)*20, 360, 360);
  color hsb3 = color((int)(100+abs(mxc-100)/20*20), 360, 360);
  color hsb4 = color((int)(100+abs(myc-100)/20*20), 360, 360);
  color hsb5 = color((((int)mxc/20)*20+180)%360, 360, 360);
  color hsb6 = color((((int)myc/20)*20+180)%360, 360, 360);
  color hsb7 = color(((int)(100+abs(mxc-100)/20*20)+180)%360, 360, 360);
  color hsb8 = color(((int)(100+abs(myc-100)/20*20)+180)%360, 360, 360);
  
  colorMode(RGB, 255);
  /**
  hsb1 = color(104, 104, 104);
  hsb2 = color(152, 152, 152);
  hsb3 = color(0, 104, 104);
  hsb4 = color(0, 152, 152);
  */
  int c1 = RGB24((int)red(hsb1), (int)green(hsb1), (int)blue(hsb1));
  int c2 = RGB24((int)red(hsb1), (int)green(hsb1), (int)blue(hsb1));
  int c3 = RGB24((int)red(hsb3), (int)green(hsb3), (int)blue(hsb3));
  int c4 = RGB24((int)red(hsb3), (int)green(hsb3), (int)blue(hsb3));
  int c5 = RGB24((int)red(hsb2), (int)green(hsb2), (int)blue(hsb2));
  int c6 = RGB24((int)red(hsb2), (int)green(hsb2), (int)blue(hsb2));
  int c7 = RGB24((int)red(hsb4), (int)green(hsb4), (int)blue(hsb4));
  int c8 = RGB24((int)red(hsb4), (int)green(hsb4), (int)blue(hsb4));
  int c9 = RGB24((int)red(hsb1), (int)green(hsb1), (int)blue(hsb1));
  int c10 = RGB24((int)red(hsb1), (int)green(hsb1), (int)blue(hsb1));
  int c11 = RGB24((int)red(hsb3), (int)green(hsb3), (int)blue(hsb3));
  int c12 = RGB24((int)red(hsb3), (int)green(hsb3), (int)blue(hsb3));
  int c13 = RGB24((int)red(hsb2), (int)green(hsb2), (int)blue(hsb2));
  int c14 = RGB24((int)red(hsb2), (int)green(hsb2), (int)blue(hsb2));
  int c15 = RGB24((int)red(hsb4), (int)green(hsb4), (int)blue(hsb4));
  int c16 = RGB24((int)red(hsb4), (int)green(hsb4), (int)blue(hsb4));
  
  palette[0] = c1;
  palette[1] = c2;
  palette[2] = c3;
  palette[3] = c4;
  palette[4] = c5;
  palette[5] = c6;
  palette[6] = c7;
  palette[7] = c8;
  palette[8] = c9;
  palette[9] = c10;
  palette[10] = c11;
  palette[11] = c12;
  palette[12] = c13;
  palette[13] = c14;
  palette[14] = c15;
  palette[15] = c16;
  
/*  palette[14] = RGB24(170, 0, 0);
  palette[15] = RGB24(170, 0, 0);
  */
  arrayCopy(palette, lala);
  
  for (int i = (int)cycling_index; i < (int)cycling_index+PALETTE_SIZE; i++) {
    int cc = lala[i-(int)cycling_index];
    
    palette[i%PALETTE_SIZE] = cc;
  }
  
  for (int i = (int)cycling_index2; i < (int)cycling_index2+PALETTE_SIZE; i++) {
    int cc = lala[PALETTE_SIZE+i-(int)cycling_index2];
    
    palette[PALETTE_SIZE+(i%(PALETTE_SIZE))] = cc;
  }
  
/*
  colorMode(HSB, 360);
  for (int i = 1; i <= PALETTE_SIZE; i++) {
    color hsb = color(((int)(((float)i/PALETTE_SIZE * 360)/20))*20, 360, 360);
    palette[i%PALETTE_SIZE] = RGB24((int)red(hsb),(int)green(hsb),(int)blue(hsb));
  }
  colorMode(RGB, 255);
  */
  
  /*
  for (int i = (int)cycling_index; i < (int)cycling_index+2; i++) {
    palette[i%PALETTE_SIZE] = c1;
  }
  
  for (int i = (int)cycling_index+2; i < (int)cycling_index+4; i++) {
    palette[i%PALETTE_SIZE] = c2;
  }
  
  for (int i = (int)cycling_index+4; i < (int)cycling_index+6; i++) {
    palette[i%PALETTE_SIZE] = c3;
  }
  
  for (int i = (int)cycling_index+6; i < (int)cycling_index+8; i++) {
    palette[i%PALETTE_SIZE] = c3;
  }
  
  for (int i = (int)cycling_index+8; i < (int)cycling_index+10; i++) {
    palette[i%PALETTE_SIZE] = c4;
  }
  
  for (int i = (int)cycling_index+10; i < (int)cycling_index+12; i++) {
    palette[i%PALETTE_SIZE] = c5;
  }
  
  for (int i = (int)cycling_index+12; i < (int)cycling_index+14; i++) {
    palette[i%PALETTE_SIZE] = c6;
  }
  
  for (int i = (int)cycling_index+14; i < (int)cycling_index+16; i++) {
    palette[i%PALETTE_SIZE] = c7;
  }*/
  
  cycling_index += 0.4;
  cycling_index2 += 0.4;
}

void draw_fx() {
  color_cycling();
   
  float STEP_Y = INITIAL_STEP_Y;
  
  int pal_index  = 0;
  float strip_size = INITIAL_STRIP_SIZE;
  
  output_image.loadPixels();

  float add_size = 0;
  for (int y = Y_START; y < SCREEN_HEIGHT; y+=(int)STEP_Y) {
    int pal_index_ = pal_index;
    
    int off_x = SCREEN_WIDTH_D2;
    int id_x = SCREEN_WIDTH_D2/(int)strip_size;
    
    //for (int x = SCREEN_WIDTH_D2; x > 0; x -= (int)strip_size) {
    for (int x = id_x; x >= 0; x--) {
      int col = palette[pal_index];
      if (((x-id_x)&1) == 0) {
        col = palette[pal_index+8];
      }
      
      int col2 = palette[(pal_index+PALETTE_SIZE_D2)%PALETTE_SIZE];
      int col3 = 0;//palette[14+(pal_index)%2];
      int col4 = 0;//palette[14+(pal_index)%2];
      
      color c1, c2, c3, c4;
      if (y < Y_START+2) {
        c1 = color(((col>>16)&0xFF)-170, ((col>>8)&0xFF)-170, (col&0xFF)-170);
        c2 = color(((col2>>16)&0xFF)-170, ((col2>>8)&0xFF)-170, (col2&0xFF)-170);
      } else if (y < Y_START+8) {
        c1 = color(((col>>16)&0xFF)-85, ((col>>8)&0xFF)-85, (col&0xFF)-85);
        c2 = color(((col2>>16)&0xFF)-85, ((col2>>8)&0xFF)-85, (col2&0xFF)-85);
      } else {
        c1 = color((col>>16)&0xFF, (col>>8)&0xFF, col&0xFF);
        c2 = color((col2>>16)&0xFF, (col2>>8)&0xFF, col2&0xFF);
      }
  
      c3 = color((col3>>16)&0xFF, (col3>>8)&0xFF, col3&0xFF);
      c4 = color((col4>>16)&0xFF, (col4>>8)&0xFF, col4&0xFF);
      
      float off_x_ = off_x;
      
      int start = -2;

      for (int i = 0; i <= (int)STEP_Y; i++) {
        // the code in the if block is cloned from the main strip drawing code
        // you can remove this part to get a standard Space Harrier like checkerboard
        // it draw a small strip in the middle so it look much better
        if (x > id_x-1) {
          start = (int)((float)(y-Y_START)/4)+8;
          
          for (int j = -32; j < start+32; j++) {
            int xx = (int)off_x - j;
            
            int yy = y + i;
  
            if (xx < 0 ) break;
            if (yy >= SCREEN_HEIGHT ) break;
            
            int line_index = yy * SCREEN_WIDTH;
            
            int index  = xx + line_index;
            int index2 = SCREEN_WIDTH_D2+abs(SCREEN_WIDTH_D2-xx-1) + line_index;
  if (index > logo.pixels.length) {
    output_image.pixels[index] = c2;
  } else {
            if (((logo.pixels[index]>>16)&0xFF) > 0) {
              output_image.pixels[index] = c4;
            } else {
              output_image.pixels[index] = c2;
            }
  }
  if (index2 > logo.pixels.length) {
    output_image.pixels[index] = c2;
  } else { 
            if (((logo.pixels[index2]>>16)&0xFF) > 0) {
              output_image.pixels[index2] = c4;
            } else {
              output_image.pixels[index2] = c2;
            }
  }
          }
        }
        
        // this is the main strip drawing function
        for (int j = start; j < (int)strip_size+(int)add_size; j++) {
          int xx = (int)off_x_ - j;
          
          int yy = y + i;

          if (xx < 0 ) break;
          if (yy >= SCREEN_HEIGHT ) break;
          
          int line_index = yy * SCREEN_WIDTH;
          
          int index  = xx + line_index;
          int index2 = SCREEN_WIDTH_D2+abs(SCREEN_WIDTH_D2-xx-1) + line_index;

if(index > logo.pixels.length) {
  output_image.pixels[index] = c1;
} else {
          if (((logo.pixels[index]>>16)&0xFF) > 0) {
            output_image.pixels[index] = c4;
          } else {
            output_image.pixels[index] = c1;
          }
}
if(index2 > logo.pixels.length) {
  output_image.pixels[index2] = c1;
} else {
          if (((logo.pixels[index2]>>16)&0xFF) > 0) {
            output_image.pixels[index2] = c4;
          } else {
            output_image.pixels[index2] = c1;
          }
}
        }
        off_x_ -= SMOOTH_EDGE;
      }
      
      //if (off_x > SCREEN_HEIGHT-(y+8)) { // comment this off for a Space Harrier like checkerboard (with no strips on the side)
        pal_index += PALETTE_STEP;
        pal_index %= PALETTE_SIZE;
      //}
      
      off_x -= (int)strip_size+add_size;
    }
    
    add_size+=SMOOTH_EDGE*STEP_Y/1.8;

    // this give a better look and can be used to generate others effects (like waterfall if strip_size is modified)
    if (y < 158) {
      STEP_Y += sqrt((y+1))/64;
    }
    else {
      STEP_Y += sqrt((y+1))/24;
    }
  
    //strip_size += sqrt((y+1))/64;
    strip_size += 0.5;

    pal_index = pal_index_ + 1;
    pal_index %= PALETTE_SIZE;
  }
  output_image.updatePixels();
}

// build a background for fun!!
void generateBackground() {
  PImage moon = loadImage(""moon.jpg"");
  moon.loadPixels();
  
  final int gradient_height = 16; // horizon gradient height
  final int gradient_color  = 200; // horizon color (hsv)
  
  color col  =  color(255, 255, 255);
  
  background_stars = createImage((int)(SCREEN_WIDTH), (int)(SCREEN_HEIGHT), RGB);
  background_stars.loadPixels();
  
  background_image = createImage(SCREEN_WIDTH, Y_START, ARGB);
  background_image.loadPixels();
  
  for (int i = 2; i < background_stars.width; i += 4) {
    int x = (int)random(i, i+2);
    int y = (int)random(1, background_stars.height-4);
    
    int index = x + y * background_stars.width;
    
    background_stars.pixels[index] = col;
  }
  
  for (int i = 8; i < background_stars.width-4; i+=4) {
    int x = (int)random(i, i+4);
    int y = (int)random(8, background_stars.height-4);
    
    int index = x + y * background_stars.width;

    int r = (int)random(0, 255);
    int g = (int)random(0, 255);
    int b = (int)random(0, 255);
    /*if (random(0.0, 1.0) >= 0.5) { // random/yellow
      col =  color(random(210, 255), random(220, 255), 0);
    } else {
      col =  color(random(100, 200), random(150, 200), random(210, 255));
    }*/
    
    int star_brightness = (int)random(2, 3);
    
    background_stars.pixels[index] = col;
    
    for (int j = 1; j < star_brightness; j++) {
      color c1 = color(r / (j+1), g / (j+1), b / (j+1));
      color c2 = color(r / (j+3), g / (j+3), b / (j+3));
      
      background_stars.pixels[index+j] = c1;
      background_stars.pixels[index-j] = c1;
      background_stars.pixels[index+(j*background_stars.width)] = c1;
      background_stars.pixels[index+(j*background_stars.width)+1] = c2;
      background_stars.pixels[index+(j*background_stars.width)-1] = c2;
      background_stars.pixels[index-(j*background_stars.width)] = c1;
      background_stars.pixels[index-(j*background_stars.width)+1] = c2;
      background_stars.pixels[index-(j*background_stars.width)-1] = c2;
    }
  }
  background_stars.updatePixels();
  
  // moon
  for (int y = 0; y < background_image.height; y++) {
    for (int x = 0; x < moon.width; x++) {
      int index = x + y * moon.width;
      
      if ((moon.pixels[index]&0xFF) > 10) {
        background_image.pixels[index] = moon.pixels[index];
      }
    }
  }
  background_image.updatePixels();
  
  // build a slightly curved gradient/horizon
  PImage gradient_image = createImage(SCREEN_WIDTH, gradient_height, RGB);
  gradient_image.loadPixels();
  
  colorMode(HSB, 360);
  for (int y = 0; y < gradient_height; y++) {
    int y_index = y * SCREEN_WIDTH;
    for (int x = 0; x < SCREEN_WIDTH; x++) {
      int index = x + y_index;
      
      color gradient = color(gradient_color+sin(radians((float)abs(x-SCREEN_WIDTH_D2)/SCREEN_WIDTH*180))*10, 
                              360, 
                              ((float)y/gradient_height*360)*((sin(radians(((float)x/SCREEN_WIDTH*130)+25)))+0.4));

      gradient_image.pixels[index] = gradient;
    }
  }

  // blend gradient
  background_image.blend(gradient_image, 0, 0, gradient_image.width, gradient_image.height, 0, Y_START-gradient_height, background_image.width, gradient_image.height, LIGHTEST);
}

void setup() {
  size(256, 192);
  //size(1024, 768); // because of processingjs, resolution is fixed

  frameRate(60);

  output_image = createImage(SCREEN_WIDTH, SCREEN_HEIGHT, ARGB);
  
  logo = loadImage(""processing.png"");

  saveCheckerboard();
  
  generateBackground();
}

void saveCheckerboard() {
  draw_fx();
  output_image.save(""output.bmp"");
}

void draw() {
  background(0);

  draw_fx();
  
/*
  translate(background_stars.width/2, background_stars.height/2);
  rotate(background_rot);
  */
  //image(background_stars, -(background_stars.width/2), -(background_stars.height/2));
  image(background_stars, 0, 0);
  
  resetMatrix();
  
  image(background_image, 0, 0);
  
  image(output_image, 0, 0);
  
  background_rot += 0.001;
}"
"555398","8-bit color-cycling Chessboard","mySketch","/*
  8-bit color-cycling chessboard effect
	
  A demo and a tool to build old-school color cycling chessboard with image mask support, initially done as a tool for a Sega Master System demo.
  
  The image mask is only black/white and should be the size of the screen, it can be improved quite easily if you want a detailed texture.
	
  The drawing code just draw half the checkerboard, the other half is mirrored.
  
  Can be used to generate many patterns by playing with sin/cos for the strip size and the others constants.
  
  To save the chessboard uncomment saveCheckerboard(); in the setup function, it will output a .bmp
  
  Note: For compatibility with processingjs, the color function is used instead of the RGB24 value, 
        otherwise the code is portable
  
  The generated background was added for fun (could be better with 3D stars)
	
	The moon picture was taken from a Skylux Bresser 70/700 telescope, the horizon is hardcoded within the image. 
*/

/* @pjs preload=""gns.png,moon.jpg""; */

final int SCREEN_WIDTH       = 256;
final int SCREEN_HEIGHT      = 192;
final int SCREEN_WIDTH_D2    = SCREEN_WIDTH/2;
final int Y_START            = (int)(SCREEN_HEIGHT/1.6); // the y position of the chessboard
final int PALETTE_SIZE       = 8;
final int PALETTE_SIZE_D2    = PALETTE_SIZE/2;
final int PALETTE_STEP       = 1; // this shift the patterns around, 1 could be used to generate wavy pattern
final int INITIAL_STEP_Y     = 0; // initial block height
final int INITIAL_STRIP_SIZE = 48;
final float SMOOTH_EDGE      = 0.75; // this smooth blocks a bit so they don't appear aliased with y stepping > 1

PImage output_image;
PImage logo;
PImage background_image;
PImage background_stars;

float background_rot = 0;

int []palette = new int[PALETTE_SIZE*2+2];

float cycling_index, cycling_index2;

int RGB24(int r, int g, int b) {
  if (r < 0) r = 0;
  if (g < 0) g = 0;
  if (b < 0) b = 0;
  
  return b|(g<<8)|(r<<16);
}

int []lala = new int[PALETTE_SIZE*2+2];
void color_cycling() {
  int mxc = (int)((float)mouseX/SCREEN_WIDTH  * 360);
  int myc = (int)((float)mouseY/SCREEN_HEIGHT * 360);
  
  colorMode(HSB, 360);
  
   // quantize the hsb to a 64 colors palette similar to the one used on the Sega Master System
  color hsb1 = color(((int)mxc/20)*20, 360, 360);
  color hsb2 = color(((int)myc/20)*20, 360, 360);
  color hsb3 = color((int)(100+abs(mxc-100)/20*20), 360, 360);
  color hsb4 = color((int)(100+abs(myc-100)/20*20), 360, 360);
  color hsb5 = color((((int)mxc/20)*20+180)%360, 360, 360);
  color hsb6 = color((((int)myc/20)*20+180)%360, 360, 360);
  color hsb7 = color(((int)(100+abs(mxc-100)/20*20)+180)%360, 360, 360);
  color hsb8 = color(((int)(100+abs(myc-100)/20*20)+180)%360, 360, 360);
  
  colorMode(RGB, 255);
  /**
  hsb1 = color(104, 104, 104);
  hsb2 = color(152, 152, 152);
  hsb3 = color(0, 104, 104);
  hsb4 = color(0, 152, 152);
  */
  int c1 = RGB24((int)red(hsb1), (int)green(hsb1), (int)blue(hsb1));
  int c2 = RGB24((int)red(hsb1), (int)green(hsb1), (int)blue(hsb1));
  int c3 = RGB24((int)red(hsb3), (int)green(hsb3), (int)blue(hsb3));
  int c4 = RGB24((int)red(hsb3), (int)green(hsb3), (int)blue(hsb3));
  int c5 = RGB24((int)red(hsb2), (int)green(hsb2), (int)blue(hsb2));
  int c6 = RGB24((int)red(hsb2), (int)green(hsb2), (int)blue(hsb2));
  int c7 = RGB24((int)red(hsb4), (int)green(hsb4), (int)blue(hsb4));
  int c8 = RGB24((int)red(hsb4), (int)green(hsb4), (int)blue(hsb4));
  int c9 = RGB24((int)red(hsb1), (int)green(hsb1), (int)blue(hsb1));
  int c10 = RGB24((int)red(hsb1), (int)green(hsb1), (int)blue(hsb1));
  int c11 = RGB24((int)red(hsb3), (int)green(hsb3), (int)blue(hsb3));
  int c12 = RGB24((int)red(hsb3), (int)green(hsb3), (int)blue(hsb3));
  int c13 = RGB24((int)red(hsb2), (int)green(hsb2), (int)blue(hsb2));
  int c14 = RGB24((int)red(hsb2), (int)green(hsb2), (int)blue(hsb2));
  int c15 = RGB24((int)red(hsb4), (int)green(hsb4), (int)blue(hsb4));
  int c16 = RGB24((int)red(hsb4), (int)green(hsb4), (int)blue(hsb4));
  
  palette[0] = c1;
  palette[1] = c2;
  palette[2] = c3;
  palette[3] = c4;
  palette[4] = c5;
  palette[5] = c6;
  palette[6] = c7;
  palette[7] = c8;
  palette[8] = c9;
  palette[9] = c10;
  palette[10] = c11;
  palette[11] = c12;
  palette[12] = c13;
  palette[13] = c14;
  palette[14] = c15;
  palette[15] = c16;
  
/*  palette[14] = RGB24(170, 0, 0);
  palette[15] = RGB24(170, 0, 0);
  */
  arrayCopy(palette, lala);
  
  for (int i = (int)cycling_index; i < (int)cycling_index+PALETTE_SIZE; i++) {
    int cc = lala[i-(int)cycling_index];
    
    palette[i%PALETTE_SIZE] = cc;
  }
  
  for (int i = (int)cycling_index2; i < (int)cycling_index2+PALETTE_SIZE; i++) {
    int cc = lala[PALETTE_SIZE+i-(int)cycling_index2];
    
    palette[PALETTE_SIZE+(i%(PALETTE_SIZE))] = cc;
  }
  
/*
  colorMode(HSB, 360);
  for (int i = 1; i <= PALETTE_SIZE; i++) {
    color hsb = color(((int)(((float)i/PALETTE_SIZE * 360)/20))*20, 360, 360);
    palette[i%PALETTE_SIZE] = RGB24((int)red(hsb),(int)green(hsb),(int)blue(hsb));
  }
  colorMode(RGB, 255);
  */
  
  /*
  for (int i = (int)cycling_index; i < (int)cycling_index+2; i++) {
    palette[i%PALETTE_SIZE] = c1;
  }
  
  for (int i = (int)cycling_index+2; i < (int)cycling_index+4; i++) {
    palette[i%PALETTE_SIZE] = c2;
  }
  
  for (int i = (int)cycling_index+4; i < (int)cycling_index+6; i++) {
    palette[i%PALETTE_SIZE] = c3;
  }
  
  for (int i = (int)cycling_index+6; i < (int)cycling_index+8; i++) {
    palette[i%PALETTE_SIZE] = c3;
  }
  
  for (int i = (int)cycling_index+8; i < (int)cycling_index+10; i++) {
    palette[i%PALETTE_SIZE] = c4;
  }
  
  for (int i = (int)cycling_index+10; i < (int)cycling_index+12; i++) {
    palette[i%PALETTE_SIZE] = c5;
  }
  
  for (int i = (int)cycling_index+12; i < (int)cycling_index+14; i++) {
    palette[i%PALETTE_SIZE] = c6;
  }
  
  for (int i = (int)cycling_index+14; i < (int)cycling_index+16; i++) {
    palette[i%PALETTE_SIZE] = c7;
  }*/
  
  cycling_index += 0.4;
  cycling_index2 += 0.4;
}

void draw_fx() {
  color_cycling();
   
  float STEP_Y = INITIAL_STEP_Y;
  
  int pal_index  = 0;
  float strip_size = INITIAL_STRIP_SIZE;
  
  output_image.loadPixels();

  float add_size = 0;
  for (int y = Y_START; y < SCREEN_HEIGHT; y+=(int)STEP_Y) {
    int pal_index_ = pal_index;
    
    int off_x = SCREEN_WIDTH_D2;
    int id_x = SCREEN_WIDTH_D2/(int)strip_size;
    
    //for (int x = SCREEN_WIDTH_D2; x > 0; x -= (int)strip_size) {
    for (int x = id_x; x >= 0; x--) {
      int col = palette[pal_index];
      if (((x-id_x)&1) == 0) {
        col = palette[pal_index+8];
      }
      
      int col2 = palette[(pal_index+PALETTE_SIZE_D2)%PALETTE_SIZE];
      int col3 = 0;//palette[14+(pal_index)%2];
      int col4 = 0;//palette[14+(pal_index)%2];
      
      color c1, c2, c3, c4;
      if (y < Y_START+2) {
        c1 = color(((col>>16)&0xFF)-170, ((col>>8)&0xFF)-170, (col&0xFF)-170);
        c2 = color(((col2>>16)&0xFF)-170, ((col2>>8)&0xFF)-170, (col2&0xFF)-170);
      } else if (y < Y_START+8) {
        c1 = color(((col>>16)&0xFF)-85, ((col>>8)&0xFF)-85, (col&0xFF)-85);
        c2 = color(((col2>>16)&0xFF)-85, ((col2>>8)&0xFF)-85, (col2&0xFF)-85);
      } else {
        c1 = color((col>>16)&0xFF, (col>>8)&0xFF, col&0xFF);
        c2 = color((col2>>16)&0xFF, (col2>>8)&0xFF, col2&0xFF);
      }
  
      c3 = color((col3>>16)&0xFF, (col3>>8)&0xFF, col3&0xFF);
      c4 = color((col4>>16)&0xFF, (col4>>8)&0xFF, col4&0xFF);
      
      float off_x_ = off_x;
      
      int start = -2;

      for (int i = 0; i <= (int)STEP_Y; i++) {
        // the code in the if block is cloned from the main strip drawing code
        // you can remove this part to get a standard Space Harrier like checkerboard
        // it draw a small strip in the middle so it look much better
        if (x > id_x-1) {
          start = (int)((float)(y-Y_START)/4)+8;
          
          for (int j = -32; j < start+32; j++) {
            int xx = (int)off_x - j;
            
            int yy = y + i;
  
            if (xx < 0 ) break;
            if (yy >= SCREEN_HEIGHT ) break;
            
            int line_index = yy * SCREEN_WIDTH;
            
            int index  = xx + line_index;
            int index2 = SCREEN_WIDTH_D2+abs(SCREEN_WIDTH_D2-xx-1) + line_index;
  if (index > logo.pixels.length) {
    output_image.pixels[index] = c2;
  } else {
            if (((logo.pixels[index]>>16)&0xFF) > 0) {
              output_image.pixels[index] = c4;
            } else {
              output_image.pixels[index] = c2;
            }
  }
  if (index2 > logo.pixels.length) {
    output_image.pixels[index] = c2;
  } else { 
            if (((logo.pixels[index2]>>16)&0xFF) > 0) {
              output_image.pixels[index2] = c4;
            } else {
              output_image.pixels[index2] = c2;
            }
  }
          }
        }
        
        // this is the main strip drawing function
        for (int j = start; j < (int)strip_size+(int)add_size; j++) {
          int xx = (int)off_x_ - j;
          
          int yy = y + i;

          if (xx < 0 ) break;
          if (yy >= SCREEN_HEIGHT ) break;
          
          int line_index = yy * SCREEN_WIDTH;
          
          int index  = xx + line_index;
          int index2 = SCREEN_WIDTH_D2+abs(SCREEN_WIDTH_D2-xx-1) + line_index;

if(index > logo.pixels.length) {
  output_image.pixels[index] = c1;
} else {
          if (((logo.pixels[index]>>16)&0xFF) > 0) {
            output_image.pixels[index] = c4;
          } else {
            output_image.pixels[index] = c1;
          }
}
if(index2 > logo.pixels.length) {
  output_image.pixels[index2] = c1;
} else {
          if (((logo.pixels[index2]>>16)&0xFF) > 0) {
            output_image.pixels[index2] = c4;
          } else {
            output_image.pixels[index2] = c1;
          }
}
        }
        off_x_ -= SMOOTH_EDGE;
      }
      
      //if (off_x > SCREEN_HEIGHT-(y+8)) { // comment this off for a Space Harrier like checkerboard (with no strips on the side)
        pal_index += PALETTE_STEP;
        pal_index %= PALETTE_SIZE;
      //}
      
      off_x -= (int)strip_size+add_size;
    }
    
    add_size+=SMOOTH_EDGE*STEP_Y/1.8;

    // this give a better look and can be used to generate others effects (like waterfall if strip_size is modified)
    if (y < 158) {
      STEP_Y += sqrt((y+1))/64;
    }
    else {
      STEP_Y += sqrt((y+1))/24;
    }
  
    //strip_size += sqrt((y+1))/64;
    strip_size += 0.5;

    pal_index = pal_index_ + 1;
    pal_index %= PALETTE_SIZE;
  }
  output_image.updatePixels();
}

// build a background for fun!!
void generateBackground() {
  PImage moon = loadImage(""moon.jpg"");
  moon.loadPixels();
  
  final int gradient_height = 16; // horizon gradient height
  final int gradient_color  = 200; // horizon color (hsv)
  
  color col  =  color(255, 255, 255);
  
  background_stars = createImage((int)(SCREEN_WIDTH), (int)(SCREEN_HEIGHT), RGB);
  background_stars.loadPixels();
  
  background_image = createImage(SCREEN_WIDTH, Y_START, ARGB);
  background_image.loadPixels();
  
  for (int i = 2; i < background_stars.width; i += 4) {
    int x = (int)random(i, i+2);
    int y = (int)random(1, background_stars.height-4);
    
    int index = x + y * background_stars.width;
    
    background_stars.pixels[index] = col;
  }
  
  for (int i = 8; i < background_stars.width-4; i+=4) {
    int x = (int)random(i, i+4);
    int y = (int)random(8, background_stars.height-4);
    
    int index = x + y * background_stars.width;

    int r = (int)random(0, 255);
    int g = (int)random(0, 255);
    int b = (int)random(0, 255);
    /*if (random(0.0, 1.0) >= 0.5) { // random/yellow
      col =  color(random(210, 255), random(220, 255), 0);
    } else {
      col =  color(random(100, 200), random(150, 200), random(210, 255));
    }*/
    
    int star_brightness = (int)random(2, 3);
    
    background_stars.pixels[index] = col;
    
    for (int j = 1; j < star_brightness; j++) {
      color c1 = color(r / (j+1), g / (j+1), b / (j+1));
      color c2 = color(r / (j+3), g / (j+3), b / (j+3));
      
      background_stars.pixels[index+j] = c1;
      background_stars.pixels[index-j] = c1;
      background_stars.pixels[index+(j*background_stars.width)] = c1;
      background_stars.pixels[index+(j*background_stars.width)+1] = c2;
      background_stars.pixels[index+(j*background_stars.width)-1] = c2;
      background_stars.pixels[index-(j*background_stars.width)] = c1;
      background_stars.pixels[index-(j*background_stars.width)+1] = c2;
      background_stars.pixels[index-(j*background_stars.width)-1] = c2;
    }
  }
  background_stars.updatePixels();
  
  // moon
  for (int y = 0; y < background_image.height; y++) {
    for (int x = 0; x < moon.width; x++) {
      int index = x + y * moon.width;
      
      if ((moon.pixels[index]&0xFF) > 10) {
        background_image.pixels[index] = moon.pixels[index];
      }
    }
  }
  background_image.updatePixels();
  
  // build a slightly curved gradient/horizon
  PImage gradient_image = createImage(SCREEN_WIDTH, gradient_height, RGB);
  gradient_image.loadPixels();
  
  colorMode(HSB, 360);
  for (int y = 0; y < gradient_height; y++) {
    int y_index = y * SCREEN_WIDTH;
    for (int x = 0; x < SCREEN_WIDTH; x++) {
      int index = x + y_index;
      
      color gradient = color(gradient_color+sin(radians((float)abs(x-SCREEN_WIDTH_D2)/SCREEN_WIDTH*180))*10, 
                              360, 
                              ((float)y/gradient_height*360)*((sin(radians(((float)x/SCREEN_WIDTH*130)+25)))+0.4));

      gradient_image.pixels[index] = gradient;
    }
  }

  // blend gradient
  background_image.blend(gradient_image, 0, 0, gradient_image.width, gradient_image.height, 0, Y_START-gradient_height, background_image.width, gradient_image.height, LIGHTEST);
}

void setup() {
  size(256, 192);
	
  frameRate(60);

  output_image = createImage(SCREEN_WIDTH, SCREEN_HEIGHT, ARGB);
  
  logo = loadImage(""processing.png"");

  saveCheckerboard();
  
  generateBackground();
}

void saveCheckerboard() {
  draw_fx();
  output_image.save(""output.bmp"");
}

void draw() {
  background(0);

  draw_fx();
  
/*
  translate(background_stars.width/2, background_stars.height/2);
  rotate(background_rot);
  */
  //image(background_stars, -(background_stars.width/2), -(background_stars.height/2));
  image(background_stars, 0, 0);
  
  //resetMatrix();
  
  image(background_image, 0, 0);
  
  image(output_image, 0, 0);
  
  background_rot += 0.001;
}"
"555398","8-bit color-cycling Chessboard","mySketch","/*
  8-bit color-cycling chessboard effect
	
  A demo and a tool to build old-school color cycling chessboard with image mask support, initially done as a tool for a Sega Master System demo.
  
  The image mask is only black/white and should be the size of the screen, it can be improved quite easily if you want a detailed texture.
	
  The drawing code just draw half the checkerboard, the other half is mirrored.
  
  Can be used to generate many patterns by playing with sin/cos for the strip size and the others constants.
  
  To save the chessboard uncomment saveCheckerboard(); in the setup function, it will output a .bmp of the chessboard
  
  Note: For compatibility with processingjs, the color function is used instead of the RGB24 value, 
        otherwise the code is portable
  
  The generated background was added for fun (could be better with 3D stars)
	
	The moon picture was taken from a Skylux Bresser 70/700 telescope, the horizon is hardcoded within the image. 
*/

/* @pjs preload=""processing.png,moon.jpg""; */

final int SCREEN_WIDTH       = 256;
final int SCREEN_HEIGHT      = 192;
final int SCREEN_WIDTH_D2    = SCREEN_WIDTH/2;
final int Y_START            = (int)(SCREEN_HEIGHT/1.6); // the y position of the chessboard
final int PALETTE_SIZE       = 8;
final int PALETTE_SIZE_D2    = PALETTE_SIZE/2;
final int PALETTE_STEP       = 1; // this shift the patterns around, 1 could be used to generate wavy pattern
final int INITIAL_STEP_Y     = 0; // initial block height
final int INITIAL_STRIP_SIZE = 48;
final float SMOOTH_EDGE      = 0.75; // this smooth blocks a bit so they don't appear aliased with y stepping > 1

PImage output_image;
PImage logo;
PImage background_image;
PImage background_stars;

float background_rot = 0;

int []palette = new int[PALETTE_SIZE*2+2];

float cycling_index, cycling_index2;

int RGB24(int r, int g, int b) {
  if (r < 0) r = 0;
  if (g < 0) g = 0;
  if (b < 0) b = 0;
  
  return b|(g<<8)|(r<<16);
}

int []lala = new int[PALETTE_SIZE*2+2];
void color_cycling() {
  int mxc = (int)((float)mouseX/SCREEN_WIDTH  * 360);
  int myc = (int)((float)mouseY/SCREEN_HEIGHT * 360);
  
  colorMode(HSB, 360);
  
   // quantize the hsb to a 64 colors palette similar to the one used on the Sega Master System
  color hsb1 = color(((int)mxc/20)*20, 360, 360);
  color hsb2 = color(((int)myc/20)*20, 360, 360);
  color hsb3 = color((int)(100+abs(mxc-100)/20*20), 360, 360);
  color hsb4 = color((int)(100+abs(myc-100)/20*20), 360, 360);
  color hsb5 = color((((int)mxc/20)*20+180)%360, 360, 360);
  color hsb6 = color((((int)myc/20)*20+180)%360, 360, 360);
  color hsb7 = color(((int)(100+abs(mxc-100)/20*20)+180)%360, 360, 360);
  color hsb8 = color(((int)(100+abs(myc-100)/20*20)+180)%360, 360, 360);
  
  colorMode(RGB, 255);
  /**
  hsb1 = color(104, 104, 104);
  hsb2 = color(152, 152, 152);
  hsb3 = color(0, 104, 104);
  hsb4 = color(0, 152, 152);
  */
  int c1 = RGB24((int)red(hsb1), (int)green(hsb1), (int)blue(hsb1));
  int c2 = RGB24((int)red(hsb1), (int)green(hsb1), (int)blue(hsb1));
  int c3 = RGB24((int)red(hsb3), (int)green(hsb3), (int)blue(hsb3));
  int c4 = RGB24((int)red(hsb3), (int)green(hsb3), (int)blue(hsb3));
  int c5 = RGB24((int)red(hsb2), (int)green(hsb2), (int)blue(hsb2));
  int c6 = RGB24((int)red(hsb2), (int)green(hsb2), (int)blue(hsb2));
  int c7 = RGB24((int)red(hsb4), (int)green(hsb4), (int)blue(hsb4));
  int c8 = RGB24((int)red(hsb4), (int)green(hsb4), (int)blue(hsb4));
  int c9 = RGB24((int)red(hsb1), (int)green(hsb1), (int)blue(hsb1));
  int c10 = RGB24((int)red(hsb1), (int)green(hsb1), (int)blue(hsb1));
  int c11 = RGB24((int)red(hsb3), (int)green(hsb3), (int)blue(hsb3));
  int c12 = RGB24((int)red(hsb3), (int)green(hsb3), (int)blue(hsb3));
  int c13 = RGB24((int)red(hsb2), (int)green(hsb2), (int)blue(hsb2));
  int c14 = RGB24((int)red(hsb2), (int)green(hsb2), (int)blue(hsb2));
  int c15 = RGB24((int)red(hsb4), (int)green(hsb4), (int)blue(hsb4));
  int c16 = RGB24((int)red(hsb4), (int)green(hsb4), (int)blue(hsb4));
  
  palette[0] = c1;
  palette[1] = c2;
  palette[2] = c3;
  palette[3] = c4;
  palette[4] = c5;
  palette[5] = c6;
  palette[6] = c7;
  palette[7] = c8;
  palette[8] = c9;
  palette[9] = c10;
  palette[10] = c11;
  palette[11] = c12;
  palette[12] = c13;
  palette[13] = c14;
  palette[14] = c15;
  palette[15] = c16;
  
/*  palette[14] = RGB24(170, 0, 0);
  palette[15] = RGB24(170, 0, 0);
  */
  arrayCopy(palette, lala);
  
  for (int i = (int)cycling_index; i < (int)cycling_index+PALETTE_SIZE; i++) {
    int cc = lala[i-(int)cycling_index];
    
    palette[i%PALETTE_SIZE] = cc;
  }
  
  for (int i = (int)cycling_index2; i < (int)cycling_index2+PALETTE_SIZE; i++) {
    int cc = lala[PALETTE_SIZE+i-(int)cycling_index2];
    
    palette[PALETTE_SIZE+(i%(PALETTE_SIZE))] = cc;
  }
  
/*
  colorMode(HSB, 360);
  for (int i = 1; i <= PALETTE_SIZE; i++) {
    color hsb = color(((int)(((float)i/PALETTE_SIZE * 360)/20))*20, 360, 360);
    palette[i%PALETTE_SIZE] = RGB24((int)red(hsb),(int)green(hsb),(int)blue(hsb));
  }
  colorMode(RGB, 255);
  */
  
  /*
  for (int i = (int)cycling_index; i < (int)cycling_index+2; i++) {
    palette[i%PALETTE_SIZE] = c1;
  }
  
  for (int i = (int)cycling_index+2; i < (int)cycling_index+4; i++) {
    palette[i%PALETTE_SIZE] = c2;
  }
  
  for (int i = (int)cycling_index+4; i < (int)cycling_index+6; i++) {
    palette[i%PALETTE_SIZE] = c3;
  }
  
  for (int i = (int)cycling_index+6; i < (int)cycling_index+8; i++) {
    palette[i%PALETTE_SIZE] = c3;
  }
  
  for (int i = (int)cycling_index+8; i < (int)cycling_index+10; i++) {
    palette[i%PALETTE_SIZE] = c4;
  }
  
  for (int i = (int)cycling_index+10; i < (int)cycling_index+12; i++) {
    palette[i%PALETTE_SIZE] = c5;
  }
  
  for (int i = (int)cycling_index+12; i < (int)cycling_index+14; i++) {
    palette[i%PALETTE_SIZE] = c6;
  }
  
  for (int i = (int)cycling_index+14; i < (int)cycling_index+16; i++) {
    palette[i%PALETTE_SIZE] = c7;
  }*/
  
  cycling_index += 0.4;
  cycling_index2 += 0.4;
}

void draw_fx() {
  color_cycling();
   
  float STEP_Y = INITIAL_STEP_Y;
  
  int pal_index  = 0;
  float strip_size = INITIAL_STRIP_SIZE;
  
  output_image.loadPixels();

  float add_size = 0;
  for (int y = Y_START; y < SCREEN_HEIGHT; y+=(int)STEP_Y) {
    int pal_index_ = pal_index;
    
    int off_x = SCREEN_WIDTH_D2;
    int id_x = SCREEN_WIDTH_D2/(int)strip_size;
    
    //for (int x = SCREEN_WIDTH_D2; x > 0; x -= (int)strip_size) {
    for (int x = id_x; x >= 0; x--) {
      int col = palette[pal_index];
      if (((x-id_x)&1) == 0) {
        col = palette[pal_index+8];
      }
      
      int col2 = palette[(pal_index+PALETTE_SIZE_D2)%PALETTE_SIZE];
      int col3 = 0;//palette[14+(pal_index)%2];
      int col4 = 0;//palette[14+(pal_index)%2];
      
      color c1, c2, c3, c4;
      if (y < Y_START+2) {
        c1 = color(((col>>16)&0xFF)-170, ((col>>8)&0xFF)-170, (col&0xFF)-170);
        c2 = color(((col2>>16)&0xFF)-170, ((col2>>8)&0xFF)-170, (col2&0xFF)-170);
      } else if (y < Y_START+8) {
        c1 = color(((col>>16)&0xFF)-85, ((col>>8)&0xFF)-85, (col&0xFF)-85);
        c2 = color(((col2>>16)&0xFF)-85, ((col2>>8)&0xFF)-85, (col2&0xFF)-85);
      } else {
        c1 = color((col>>16)&0xFF, (col>>8)&0xFF, col&0xFF);
        c2 = color((col2>>16)&0xFF, (col2>>8)&0xFF, col2&0xFF);
      }
  
      c3 = color((col3>>16)&0xFF, (col3>>8)&0xFF, col3&0xFF);
      c4 = color((col4>>16)&0xFF, (col4>>8)&0xFF, col4&0xFF);
      
      float off_x_ = off_x;
      
      int start = -2;

      for (int i = 0; i <= (int)STEP_Y; i++) {
        // the code in the if block is cloned from the main strip drawing code
        // you can remove this part to get a standard Space Harrier like checkerboard
        // it draw a small strip in the middle so it look much better
        if (x > id_x-1) {
          start = (int)((float)(y-Y_START)/4)+8;
          
          for (int j = -32; j < start+32; j++) {
            int xx = (int)off_x - j;
            
            int yy = y + i;
  
            if (xx < 0 ) break;
            if (yy >= SCREEN_HEIGHT ) break;
            
            int line_index = yy * SCREEN_WIDTH;
            
            int index  = xx + line_index;
            int index2 = SCREEN_WIDTH_D2+abs(SCREEN_WIDTH_D2-xx-1) + line_index;
  if (index > logo.pixels.length) {
    output_image.pixels[index] = c2;
  } else {
            if (((logo.pixels[index]>>16)&0xFF) > 0) {
              output_image.pixels[index] = c4;
            } else {
              output_image.pixels[index] = c2;
            }
  }
  if (index2 > logo.pixels.length) {
    output_image.pixels[index] = c2;
  } else { 
            if (((logo.pixels[index2]>>16)&0xFF) > 0) {
              output_image.pixels[index2] = c4;
            } else {
              output_image.pixels[index2] = c2;
            }
  }
          }
        }
        
        // this is the main strip drawing function
        for (int j = start; j < (int)strip_size+(int)add_size; j++) {
          int xx = (int)off_x_ - j;
          
          int yy = y + i;

          if (xx < 0 ) break;
          if (yy >= SCREEN_HEIGHT ) break;
          
          int line_index = yy * SCREEN_WIDTH;
          
          int index  = xx + line_index;
          int index2 = SCREEN_WIDTH_D2+abs(SCREEN_WIDTH_D2-xx-1) + line_index;

if(index > logo.pixels.length) {
  output_image.pixels[index] = c1;
} else {
          if (((logo.pixels[index]>>16)&0xFF) > 0) {
            output_image.pixels[index] = c4;
          } else {
            output_image.pixels[index] = c1;
          }
}
if(index2 > logo.pixels.length) {
  output_image.pixels[index2] = c1;
} else {
          if (((logo.pixels[index2]>>16)&0xFF) > 0) {
            output_image.pixels[index2] = c4;
          } else {
            output_image.pixels[index2] = c1;
          }
}
        }
        off_x_ -= SMOOTH_EDGE;
      }
      
      //if (off_x > SCREEN_HEIGHT-(y+8)) { // comment this off for a Space Harrier like checkerboard (with no strips on the side)
        pal_index += PALETTE_STEP;
        pal_index %= PALETTE_SIZE;
      //}
      
      off_x -= (int)strip_size+add_size;
    }
    
    add_size+=SMOOTH_EDGE*STEP_Y/1.8;

    // this give a better look and can be used to generate others effects (like waterfall if strip_size is modified)
    if (y < 158) {
      STEP_Y += sqrt((y+1))/64;
    }
    else {
      STEP_Y += sqrt((y+1))/24;
    }
  
    //strip_size += sqrt((y+1))/64;
    strip_size += 0.5;

    pal_index = pal_index_ + 1;
    pal_index %= PALETTE_SIZE;
  }
  output_image.updatePixels();
}

// build a background for fun!!
void generateBackground() {
  PImage moon = loadImage(""moon.jpg"");
  moon.loadPixels();
  
  final int gradient_height = 16; // horizon gradient height
  final int gradient_color  = 200; // horizon color (hsv)
  
  color col  =  color(255, 255, 255);
  
  background_stars = createImage((int)(SCREEN_WIDTH), (int)(SCREEN_HEIGHT), RGB);
  background_stars.loadPixels();
  
  background_image = createImage(SCREEN_WIDTH, Y_START, ARGB);
  background_image.loadPixels();
  
  for (int i = 2; i < background_stars.width; i += 4) {
    int x = (int)random(i, i+2);
    int y = (int)random(1, background_stars.height-4);
    
    int index = x + y * background_stars.width;
    
    background_stars.pixels[index] = col;
  }
  
  for (int i = 8; i < background_stars.width-4; i+=4) {
    int x = (int)random(i, i+4);
    int y = (int)random(8, background_stars.height-4);
    
    int index = x + y * background_stars.width;

    int r = (int)random(0, 255);
    int g = (int)random(0, 255);
    int b = (int)random(0, 255);
    /*if (random(0.0, 1.0) >= 0.5) { // random/yellow
      col =  color(random(210, 255), random(220, 255), 0);
    } else {
      col =  color(random(100, 200), random(150, 200), random(210, 255));
    }*/
    
    int star_brightness = (int)random(2, 3);
    
    background_stars.pixels[index] = col;
    
    for (int j = 1; j < star_brightness; j++) {
      color c1 = color(r / (j+1), g / (j+1), b / (j+1));
      color c2 = color(r / (j+3), g / (j+3), b / (j+3));
      
      background_stars.pixels[index+j] = c1;
      background_stars.pixels[index-j] = c1;
      background_stars.pixels[index+(j*background_stars.width)] = c1;
      background_stars.pixels[index+(j*background_stars.width)+1] = c2;
      background_stars.pixels[index+(j*background_stars.width)-1] = c2;
      background_stars.pixels[index-(j*background_stars.width)] = c1;
      background_stars.pixels[index-(j*background_stars.width)+1] = c2;
      background_stars.pixels[index-(j*background_stars.width)-1] = c2;
    }
  }
  background_stars.updatePixels();
  
  // moon
  for (int y = 0; y < background_image.height; y++) {
    for (int x = 0; x < moon.width; x++) {
      int index = x + y * moon.width;
      
      if ((moon.pixels[index]&0xFF) > 10) {
        background_image.pixels[index] = moon.pixels[index];
      }
    }
  }
  background_image.updatePixels();
  
  // build a slightly curved gradient/horizon
  PImage gradient_image = createImage(SCREEN_WIDTH, gradient_height, RGB);
  gradient_image.loadPixels();
  
  colorMode(HSB, 360);
  for (int y = 0; y < gradient_height; y++) {
    int y_index = y * SCREEN_WIDTH;
    for (int x = 0; x < SCREEN_WIDTH; x++) {
      int index = x + y_index;
      
      color gradient = color(gradient_color+sin(radians((float)abs(x-SCREEN_WIDTH_D2)/SCREEN_WIDTH*180))*10, 
                              360, 
                              ((float)y/gradient_height*360)*((sin(radians(((float)x/SCREEN_WIDTH*130)+25)))+0.4));

      gradient_image.pixels[index] = gradient;
    }
  }

  // blend gradient
  background_image.blend(gradient_image, 0, 0, gradient_image.width, gradient_image.height, 0, Y_START-gradient_height, background_image.width, gradient_image.height, LIGHTEST);
}

void setup() {
  size(256, 192);
	
  frameRate(60);

	// uncomment for saveCheckerboard
  //output_image = createImage(SCREEN_WIDTH, SCREEN_HEIGHT, ARGB);
  
  logo = loadImage(""processing.png"");

  //saveCheckerboard();
  
  generateBackground();
}

/*
void saveCheckerboard() {
  draw_fx();
  output_image.save(""output.bmp"");
}
*/

void draw() {
  background(0);

  draw_fx();
  
/*
  translate(background_stars.width/2, background_stars.height/2);
  rotate(background_rot);
  */
  //image(background_stars, -(background_stars.width/2), -(background_stars.height/2));
  image(background_stars, 0, 0);
  
  //resetMatrix();
  
  image(background_image, 0, 0);
  
	// uncomment for saveCheckerboard
  //image(output_image, 0, 0);
  
  background_rot += 0.001;
}"
"555398","8-bit color-cycling Chessboard","mySketch","/*
  8-bit color-cycling chessboard effect
	
	Mouse cursor axis change the pattern color.
	
  A demo and a tool to build old-school color cycling chessboard with image mask support, initially done as a tool for a Sega Master System demo.
  
  The image mask is only black/white and should be the size of the screen, it can be improved quite easily if you want a detailed texture.
	
  The drawing code just draw half the chessboard, the other half is mirrored.
	
	The initial idea with the chessboard algorithm was to build a generic tool to build Space Harrier like chessboard, it is entirely pixels-based.
  
  Can be used to generate many patterns by playing with sin/cos for the strip size and the others constants.
	
	Not perfect as there is some rough edges issues on the center band.
  
  To save the chessboard uncomment saveCheckerboard(); in the setup function, it will output a .bmp of the chessboard
  
  Note: For compatibility with processingjs, the color function is used instead of the RGB24 value, 
        otherwise the code is portable
  
  The generated background was added for fun (could be better with 3D stars)
	
	The moon picture was taken from a Skylux Bresser 70/700 telescope, the horizon is hardcoded within the image. 
*/

/* @pjs preload=""processing.png,moon.jpg""; */

final int SCREEN_WIDTH       = 256;
final int SCREEN_HEIGHT      = 192;
final int SCREEN_WIDTH_D2    = SCREEN_WIDTH/2;
final int Y_START            = (int)(SCREEN_HEIGHT/1.6); // the y position of the chessboard
final int PALETTE_SIZE       = 8;
final int PALETTE_SIZE_D2    = PALETTE_SIZE/2;
final int PALETTE_STEP       = 4; // this shift the chessboard patterns around, 1 could be used to generate wavy pattern
final int INITIAL_STEP_Y     = 0; // initial block height
final int INITIAL_STRIP_SIZE = 48;
final float SMOOTH_EDGE      = 0.75; // this smooth blocks a bit so they don't appear aliased with y stepping > 1

PImage output_image;
PImage logo;
PImage background_image;
PImage background_stars;

float background_rot = 0;

int []palette = new int[PALETTE_SIZE*2+2];

float cycling_index, cycling_index2;

int RGB24(int r, int g, int b) {
  if (r < 0) r = 0;
  if (g < 0) g = 0;
  if (b < 0) b = 0;
  
  return b|(g<<8)|(r<<16);
}

// color cycling stuff
int []cycling = new int[PALETTE_SIZE*2+2];
void color_cycling() {
  int mxc = (int)((float)mouseX/SCREEN_WIDTH  * 360);
  int myc = (int)((float)mouseY/SCREEN_HEIGHT * 360);
  
  colorMode(HSB, 360);
  
   // quantize the hsb to a 64 colors palette similar to the one used on the Sega Master System
  color hsb1 = color(((int)mxc/20)*20, 360, 360);
  color hsb2 = color(((int)myc/20)*20, 360, 360);
  color hsb3 = color((int)(100+abs(mxc-100)/20*20), 360, 360);
  color hsb4 = color((int)(100+abs(myc-100)/20*20), 360, 360);
  color hsb5 = color((((int)mxc/20)*20+180)%360, 360, 360);
  color hsb6 = color((((int)myc/20)*20+180)%360, 360, 360);
  color hsb7 = color(((int)(100+abs(mxc-100)/20*20)+180)%360, 360, 360);
  color hsb8 = color(((int)(100+abs(myc-100)/20*20)+180)%360, 360, 360);
  
  colorMode(RGB, 255);

  int c1 = RGB24((int)red(hsb1), (int)green(hsb1), (int)blue(hsb1));
  int c2 = RGB24((int)red(hsb1), (int)green(hsb1), (int)blue(hsb1));
  int c3 = RGB24((int)red(hsb3), (int)green(hsb3), (int)blue(hsb3));
  int c4 = RGB24((int)red(hsb3), (int)green(hsb3), (int)blue(hsb3));
  int c5 = RGB24((int)red(hsb2), (int)green(hsb2), (int)blue(hsb2));
  int c6 = RGB24((int)red(hsb2), (int)green(hsb2), (int)blue(hsb2));
  int c7 = RGB24((int)red(hsb4), (int)green(hsb4), (int)blue(hsb4));
  int c8 = RGB24((int)red(hsb4), (int)green(hsb4), (int)blue(hsb4));
  int c9 = RGB24((int)red(hsb1), (int)green(hsb1), (int)blue(hsb1));
  int c10 = RGB24((int)red(hsb1), (int)green(hsb1), (int)blue(hsb1));
  int c11 = RGB24((int)red(hsb3), (int)green(hsb3), (int)blue(hsb3));
  int c12 = RGB24((int)red(hsb3), (int)green(hsb3), (int)blue(hsb3));
  int c13 = RGB24((int)red(hsb2), (int)green(hsb2), (int)blue(hsb2));
  int c14 = RGB24((int)red(hsb2), (int)green(hsb2), (int)blue(hsb2));
  int c15 = RGB24((int)red(hsb4), (int)green(hsb4), (int)blue(hsb4));
  int c16 = RGB24((int)red(hsb4), (int)green(hsb4), (int)blue(hsb4));
  
  palette[0] = c1;
  palette[1] = c2;
  palette[2] = c3;
  palette[3] = c4;
  palette[4] = c5;
  palette[5] = c6;
  palette[6] = c7;
  palette[7] = c8;
  palette[8] = c9;
  palette[9] = c10;
  palette[10] = c11;
  palette[11] = c12;
  palette[12] = c13;
  palette[13] = c14;
  palette[14] = c15;
  palette[15] = c16;

  arrayCopy(palette, cycling);
  
  for (int i = (int)cycling_index; i < (int)cycling_index+PALETTE_SIZE; i++) {
    int cc = cycling[i-(int)cycling_index];
    
    palette[i%PALETTE_SIZE] = cc;
  }
  
  for (int i = (int)cycling_index2; i < (int)cycling_index2+PALETTE_SIZE; i++) {
    int cc = cycling[PALETTE_SIZE+i-(int)cycling_index2];
    
    palette[PALETTE_SIZE+(i%(PALETTE_SIZE))] = cc;
  }
  
  cycling_index += 0.4;
  cycling_index2 += 0.4;
}

// chessboard core
void draw_fx() {
  color_cycling();
   
  float STEP_Y = INITIAL_STEP_Y;
  
  int pal_index  = 0;
  float strip_size = INITIAL_STRIP_SIZE;
  
  output_image.loadPixels();

  float add_size = 0;
  for (int y = Y_START; y < SCREEN_HEIGHT; y+=(int)STEP_Y) {
    int pal_index_ = pal_index;
    
    int off_x = SCREEN_WIDTH_D2;
    int id_x = SCREEN_WIDTH_D2/(int)strip_size;
    
    for (int x = id_x; x >= 0; x--) {
      int col = palette[pal_index];
      if (((x-id_x)&1) == 0) {
        col = palette[pal_index+8];
      }
      
      int col2 = palette[(pal_index+PALETTE_SIZE_D2)%PALETTE_SIZE];
      int col3 = 0;//palette[14+(pal_index)%2];
      int col4 = 0;//palette[14+(pal_index)%2];
      
      color c1, c2, c3, c4;
      if (y < Y_START+2) {
        c1 = color(((col>>16)&0xFF)-170, ((col>>8)&0xFF)-170, (col&0xFF)-170);
        c2 = color(((col2>>16)&0xFF)-170, ((col2>>8)&0xFF)-170, (col2&0xFF)-170);
      } else if (y < Y_START+8) {
        c1 = color(((col>>16)&0xFF)-85, ((col>>8)&0xFF)-85, (col&0xFF)-85);
        c2 = color(((col2>>16)&0xFF)-85, ((col2>>8)&0xFF)-85, (col2&0xFF)-85);
      } else {
        c1 = color((col>>16)&0xFF, (col>>8)&0xFF, col&0xFF);
        c2 = color((col2>>16)&0xFF, (col2>>8)&0xFF, col2&0xFF);
      }
  
      c3 = color((col3>>16)&0xFF, (col3>>8)&0xFF, col3&0xFF);
      c4 = color((col4>>16)&0xFF, (col4>>8)&0xFF, col4&0xFF);
      
      float off_x_ = off_x;
      
      int start = -2;

      for (int i = 0; i <= (int)STEP_Y; i++) {
        // the code in the if block is cloned from the main strip drawing code
        // you can remove this part to get a standard Space Harrier like checkerboard
        // this draw a small strip in the middle so it look much better
        if (x > id_x-1) {
          start = (int)((float)(y-Y_START)/4)+8;
          
          for (int j = -32; j < start+32; j++) {
            int xx = (int)off_x - j;
            
            int yy = y + i;
  
            if (xx < 0 ) break;
            if (yy >= SCREEN_HEIGHT ) break;
            
            int line_index = yy * SCREEN_WIDTH;
            
            int index  = xx + line_index;
            int index2 = SCREEN_WIDTH_D2+abs(SCREEN_WIDTH_D2-xx-1) + line_index;
  					
						if (index > logo.pixels.length) {
    					output_image.pixels[index] = c2;
  					} else {
							if (((logo.pixels[index]>>16)&0xFF) > 0) {
								output_image.pixels[index] = c4;
							} else {
								output_image.pixels[index] = c2;
							}
  					}
						
						if (index2 > logo.pixels.length) {
							output_image.pixels[index] = c2;
						} else { 
							if (((logo.pixels[index2]>>16)&0xFF) > 0) {
								output_image.pixels[index2] = c4;
							} else {
								output_image.pixels[index2] = c2;
							}
						}
          }
        }
        
        // this is the main strip drawing code
        for (int j = start; j < (int)strip_size+(int)add_size; j++) {
          int xx = (int)off_x_ - j;
          
          int yy = y + i;

          if (xx < 0 ) break;
          if (yy >= SCREEN_HEIGHT ) break;
          
          int line_index = yy * SCREEN_WIDTH;
          
          int index  = xx + line_index;
          int index2 = SCREEN_WIDTH_D2+abs(SCREEN_WIDTH_D2-xx-1) + line_index;

					if(index > logo.pixels.length) {
  					output_image.pixels[index] = c1;
					} else {
						if (((logo.pixels[index]>>16)&0xFF) > 0) {
							output_image.pixels[index] = c4;
						} else {
							output_image.pixels[index] = c1;
						}
					}
					
					if(index2 > logo.pixels.length) {
						output_image.pixels[index2] = c1;
					} else {
						if (((logo.pixels[index2]>>16)&0xFF) > 0) {
							output_image.pixels[index2] = c4;
						} else {
							output_image.pixels[index2] = c1;
						}
					}
        }
        off_x_ -= SMOOTH_EDGE;
      }
      
      //if (off_x > SCREEN_HEIGHT-(y+8)) { // comment this off for a Space Harrier like checkerboard (with no strips on the side)
        pal_index += PALETTE_STEP;
        pal_index %= PALETTE_SIZE;
      //}
      
      off_x -= (int)strip_size+add_size;
    }
    
    add_size+=SMOOTH_EDGE*STEP_Y/1.8;

    // this give a better look and can be used to generate others effects (like waterfall if strip_size is modified)
    if (y < 158) {
      STEP_Y += sqrt((y+1))/64;
    }
    else {
      STEP_Y += sqrt((y+1))/24;
    }
  
    //strip_size += sqrt((y+1))/64;
    strip_size += 0.5;

    pal_index = pal_index_ + 1;
    pal_index %= PALETTE_SIZE;
  }
  output_image.updatePixels();
}

// build a background for fun!!
void generateBackground() {
  PImage moon = loadImage(""moon.jpg"");
  moon.loadPixels();
  
  final int gradient_height = 16; // horizon gradient height
  final int gradient_color  = 200; // horizon color (hsv)
  
  color col  =  color(255, 255, 255);
  
  background_stars = createImage((int)(SCREEN_WIDTH), (int)(SCREEN_HEIGHT), RGB);
  background_stars.loadPixels();
  
  background_image = createImage(SCREEN_WIDTH, Y_START, ARGB);
  background_image.loadPixels();
  
  for (int i = 2; i < background_stars.width; i += 4) {
    int x = (int)random(i, i+2);
    int y = (int)random(1, background_stars.height-4);
    
    int index = x + y * background_stars.width;
    
    background_stars.pixels[index] = col;
  }
  
  for (int i = 8; i < background_stars.width-4; i+=4) {
    int x = (int)random(i, i+4);
    int y = (int)random(8, background_stars.height-4);
    
    int index = x + y * background_stars.width;

    int r = (int)random(0, 255);
    int g = (int)random(0, 255);
    int b = (int)random(0, 255);
    
    int star_brightness = (int)random(2, 3);
    
    background_stars.pixels[index] = col;
    
    for (int j = 1; j < star_brightness; j++) {
      color c1 = color(r / (j+1), g / (j+1), b / (j+1));
      color c2 = color(r / (j+3), g / (j+3), b / (j+3));
      
      background_stars.pixels[index+j] = c1;
      background_stars.pixels[index-j] = c1;
      background_stars.pixels[index+(j*background_stars.width)] = c1;
      background_stars.pixels[index+(j*background_stars.width)+1] = c2;
      background_stars.pixels[index+(j*background_stars.width)-1] = c2;
      background_stars.pixels[index-(j*background_stars.width)] = c1;
      background_stars.pixels[index-(j*background_stars.width)+1] = c2;
      background_stars.pixels[index-(j*background_stars.width)-1] = c2;
    }
  }
  background_stars.updatePixels();
  
  // moon
  for (int y = 0; y < background_image.height; y++) {
    for (int x = 0; x < moon.width; x++) {
      int index = x + y * moon.width;
      
      if ((moon.pixels[index]&0xFF) > 10) {
        background_image.pixels[index] = moon.pixels[index];
      }
    }
  }
  background_image.updatePixels();
  
  // build a slightly curved gradient/horizon
  PImage gradient_image = createImage(SCREEN_WIDTH, gradient_height, RGB);
  gradient_image.loadPixels();
  
  colorMode(HSB, 360);
  for (int y = 0; y < gradient_height; y++) {
    int y_index = y * SCREEN_WIDTH;
    for (int x = 0; x < SCREEN_WIDTH; x++) {
      int index = x + y_index;
      
      color gradient = color(gradient_color+sin(radians((float)abs(x-SCREEN_WIDTH_D2)/SCREEN_WIDTH*180))*10, 
                              360, 
                              ((float)y/gradient_height*360)*((sin(radians(((float)x/SCREEN_WIDTH*130)+25)))+0.4));

      gradient_image.pixels[index] = gradient;
    }
  }

  // blend gradient
  background_image.blend(gradient_image, 0, 0, gradient_image.width, gradient_image.height, 0, Y_START-gradient_height, background_image.width, gradient_image.height, LIGHTEST);
}

void setup() {
  size(256, 192);
	
  frameRate(60);

  output_image = createImage(SCREEN_WIDTH, SCREEN_HEIGHT, ARGB);
  
  logo = loadImage(""processing.png"");

  //saveCheckerboard();
  
  generateBackground();
}

/*
void saveCheckerboard() {
  draw_fx();
  output_image.save(""output.bmp"");
}
*/

void draw() {
  background(0);

  draw_fx();
  
  // add some funky background rotation
  translate(background_stars.width/2, background_stars.height/2);
  rotate(background_rot);
  image(background_stars, -(background_stars.width/2), -(background_stars.height/2));
  resetMatrix();
  
	// draw the chessboard
  image(background_image, 0, 0);
  
  image(output_image, 0, 0);
  
  background_rot += 0.001;
}"
"555398","8-bit color-cycling Chessboard","mySketch","/*
  8-bit color-cycling chessboard effect
	
	Mouse cursor axis change the pattern color.
	
  A demo and a tool to build old-school color cycling chessboard with image mask support, initially done as a tool for a Sega Master System demo.
  
  The image mask is only black/white and should be the size of the screen, it can be improved quite easily if you want a detailed texture.
	
  The drawing code just draw half the chessboard, the other half is mirrored.
	
	The initial idea with the chessboard algorithm was to build a generic tool to build Space Harrier like chessboard, it is entirely pixels-based.
  
  Can be used to generate many patterns by playing with sin/cos for the strip size and the others constants.
	
	Not perfect as there is some rough edges issues on the center band.
  
  To save the chessboard uncomment saveCheckerboard(); in the setup function, it will output a .bmp of the chessboard
  
  Note: For compatibility with processingjs, the color function is used instead of the RGB24 value, 
        otherwise the code is portable
  
  The generated background was added for fun (could be better with 3D stars)
	
	The moon picture was taken from a Skylux Bresser 70/700 telescope, the horizon is hardcoded within the image. 
*/

/* @pjs preload=""processing.png,moon.jpg""; */

final int SCREEN_WIDTH       = 256;
final int SCREEN_HEIGHT      = 192;
final int SCREEN_WIDTH_D2    = SCREEN_WIDTH/2;
final int Y_START            = (int)(SCREEN_HEIGHT/1.6); // the y position of the chessboard
final int PALETTE_SIZE       = 8;
final int PALETTE_SIZE_D2    = PALETTE_SIZE/2;
final int PALETTE_STEP       = 4; // this shift the chessboard patterns around, 1 could be used to generate wavy pattern
final int INITIAL_STEP_Y     = 0; // initial block height
final int INITIAL_STRIP_SIZE = 48;
final float SMOOTH_EDGE      = 0.75; // this smooth blocks a bit so they don't appear aliased with y stepping > 1

PImage output_image;
PImage logo;
PImage background_image;
PImage background_stars;

float background_rot = 0;

int []palette = new int[PALETTE_SIZE*2+2];

float cycling_index, cycling_index2;

int RGB24(int r, int g, int b) {
  if (r < 0) r = 0;
  if (g < 0) g = 0;
  if (b < 0) b = 0;
  
  return b|(g<<8)|(r<<16);
}

// color cycling stuff
int []cycling = new int[PALETTE_SIZE*2+2];
void color_cycling() {
  int mxc = (int)((float)mouseX/SCREEN_WIDTH  * 360);
  int myc = (int)((float)mouseY/SCREEN_HEIGHT * 360);
  
  colorMode(HSB, 360);
  
   // quantize the hsb to a 64 colors palette similar to the one used on the Sega Master System
  color hsb1 = color(((int)mxc/20)*20, 360, 360);
  color hsb2 = color(((int)myc/20)*20, 360, 360);
  color hsb3 = color((int)(100+abs(mxc-100)/20*20), 360, 360);
  color hsb4 = color((int)(100+abs(myc-100)/20*20), 360, 360);
  color hsb5 = color((((int)mxc/20)*20+180)%360, 360, 360);
  color hsb6 = color((((int)myc/20)*20+180)%360, 360, 360);
  color hsb7 = color(((int)(100+abs(mxc-100)/20*20)+180)%360, 360, 360);
  color hsb8 = color(((int)(100+abs(myc-100)/20*20)+180)%360, 360, 360);
  
  colorMode(RGB, 255);

  int c1 = RGB24((int)red(hsb1), (int)green(hsb1), (int)blue(hsb1));
  int c2 = RGB24((int)red(hsb1), (int)green(hsb1), (int)blue(hsb1));
  int c3 = RGB24((int)red(hsb3), (int)green(hsb3), (int)blue(hsb3));
  int c4 = RGB24((int)red(hsb3), (int)green(hsb3), (int)blue(hsb3));
  int c5 = RGB24((int)red(hsb2), (int)green(hsb2), (int)blue(hsb2));
  int c6 = RGB24((int)red(hsb2), (int)green(hsb2), (int)blue(hsb2));
  int c7 = RGB24((int)red(hsb4), (int)green(hsb4), (int)blue(hsb4));
  int c8 = RGB24((int)red(hsb4), (int)green(hsb4), (int)blue(hsb4));
  int c9 = RGB24((int)red(hsb1), (int)green(hsb1), (int)blue(hsb1));
  int c10 = RGB24((int)red(hsb1), (int)green(hsb1), (int)blue(hsb1));
  int c11 = RGB24((int)red(hsb3), (int)green(hsb3), (int)blue(hsb3));
  int c12 = RGB24((int)red(hsb3), (int)green(hsb3), (int)blue(hsb3));
  int c13 = RGB24((int)red(hsb2), (int)green(hsb2), (int)blue(hsb2));
  int c14 = RGB24((int)red(hsb2), (int)green(hsb2), (int)blue(hsb2));
  int c15 = RGB24((int)red(hsb4), (int)green(hsb4), (int)blue(hsb4));
  int c16 = RGB24((int)red(hsb4), (int)green(hsb4), (int)blue(hsb4));
  
  palette[0] = c1;
  palette[1] = c2;
  palette[2] = c3;
  palette[3] = c4;
  palette[4] = c5;
  palette[5] = c6;
  palette[6] = c7;
  palette[7] = c8;
  palette[8] = c9;
  palette[9] = c10;
  palette[10] = c11;
  palette[11] = c12;
  palette[12] = c13;
  palette[13] = c14;
  palette[14] = c15;
  palette[15] = c16;

  arrayCopy(palette, cycling);
  
  for (int i = (int)cycling_index; i < (int)cycling_index+PALETTE_SIZE; i++) {
    int cc = cycling[i-(int)cycling_index];
    
    palette[i%PALETTE_SIZE] = cc;
  }
  
  for (int i = (int)cycling_index2; i < (int)cycling_index2+PALETTE_SIZE; i++) {
    int cc = cycling[PALETTE_SIZE+i-(int)cycling_index2];
    
    palette[PALETTE_SIZE+(i%(PALETTE_SIZE))] = cc;
  }
  
  cycling_index += 0.4;
  cycling_index2 += 0.4;
}

// chessboard core
void draw_fx() {
  color_cycling();
   
  float STEP_Y = INITIAL_STEP_Y;
  
  int pal_index  = 0;
  float strip_size = INITIAL_STRIP_SIZE;
  
  output_image.loadPixels();

  float add_size = 0;
  for (int y = Y_START; y < SCREEN_HEIGHT; y+=(int)STEP_Y) {
    int pal_index_ = pal_index;
    
    int off_x = SCREEN_WIDTH_D2;
    int id_x = SCREEN_WIDTH_D2/(int)strip_size;
    
    for (int x = id_x; x >= 0; x--) {
      int col = palette[pal_index];
      if (((x-id_x)&1) == 0) {
        col = palette[pal_index+8];
      }
      
      int col2 = palette[(pal_index+PALETTE_SIZE_D2)%PALETTE_SIZE];
      int col3 = 0;//palette[14+(pal_index)%2];
      int col4 = 0;//palette[14+(pal_index)%2];
      
      color c1, c2, c3, c4;
      if (y < Y_START+2) {
        c1 = color(((col>>16)&0xFF)-170, ((col>>8)&0xFF)-170, (col&0xFF)-170);
        c2 = color(((col2>>16)&0xFF)-170, ((col2>>8)&0xFF)-170, (col2&0xFF)-170);
      } else if (y < Y_START+8) {
        c1 = color(((col>>16)&0xFF)-85, ((col>>8)&0xFF)-85, (col&0xFF)-85);
        c2 = color(((col2>>16)&0xFF)-85, ((col2>>8)&0xFF)-85, (col2&0xFF)-85);
      } else {
        c1 = color((col>>16)&0xFF, (col>>8)&0xFF, col&0xFF);
        c2 = color((col2>>16)&0xFF, (col2>>8)&0xFF, col2&0xFF);
      }
  
      c3 = color((col3>>16)&0xFF, (col3>>8)&0xFF, col3&0xFF);
      c4 = color((col4>>16)&0xFF, (col4>>8)&0xFF, col4&0xFF);
      
      float off_x_ = off_x;
      
      int start = -2;

      for (int i = 0; i <= (int)STEP_Y; i++) {
        // the code in the if block is cloned from the main strip drawing code
        // you can remove this part to get a standard Space Harrier like checkerboard
        // this draw a small strip in the middle so it look much better
        if (x > id_x-1) {
          start = (int)((float)(y-Y_START)/4)+8;
          
          for (int j = -32; j < start+32; j++) {
            int xx = (int)off_x - j;
            
            int yy = y + i;
  
            if (xx < 0 ) break;
            if (yy >= SCREEN_HEIGHT ) break;
            
            int line_index = yy * SCREEN_WIDTH;
            
            int index  = xx + line_index;
            int index2 = SCREEN_WIDTH_D2+abs(SCREEN_WIDTH_D2-xx-1) + line_index;
  					
						if (index > logo.pixels.length) {
    					output_image.pixels[index] = c2;
  					} else {
							if (((logo.pixels[index]>>16)&0xFF) > 0) {
								output_image.pixels[index] = c4;
							} else {
								output_image.pixels[index] = c2;
							}
  					}
						
						if (index2 > logo.pixels.length) {
							output_image.pixels[index] = c2;
						} else { 
							if (((logo.pixels[index2]>>16)&0xFF) > 0) {
								output_image.pixels[index2] = c4;
							} else {
								output_image.pixels[index2] = c2;
							}
						}
          }
        }
        
        // this is the main strip drawing code
        for (int j = start; j < (int)strip_size+(int)add_size; j++) {
          int xx = (int)off_x_ - j;
          
          int yy = y + i;

          if (xx < 0 ) break;
          if (yy >= SCREEN_HEIGHT ) break;
          
          int line_index = yy * SCREEN_WIDTH;
          
          int index  = xx + line_index;
          int index2 = SCREEN_WIDTH_D2+abs(SCREEN_WIDTH_D2-xx-1) + line_index;

					if(index > logo.pixels.length) {
  					output_image.pixels[index] = c1;
					} else {
						if (((logo.pixels[index]>>16)&0xFF) > 0) {
							output_image.pixels[index] = c4;
						} else {
							output_image.pixels[index] = c1;
						}
					}
					
					if(index2 > logo.pixels.length) {
						output_image.pixels[index2] = c1;
					} else {
						if (((logo.pixels[index2]>>16)&0xFF) > 0) {
							output_image.pixels[index2] = c4;
						} else {
							output_image.pixels[index2] = c1;
						}
					}
        }
        off_x_ -= SMOOTH_EDGE;
      }
      
      //if (off_x > SCREEN_HEIGHT-(y+8)) { // comment this off for a Space Harrier like checkerboard (with no strips on the side)
        pal_index += PALETTE_STEP;
        pal_index %= PALETTE_SIZE;
      //}
      
      off_x -= (int)strip_size+add_size;
    }
    
    add_size+=SMOOTH_EDGE*STEP_Y/1.8;

    // this give a better look and can be used to generate others effects (like waterfall if strip_size is modified)
    if (y < 158) {
      STEP_Y += sqrt((y+1))/64;
    }
    else {
      STEP_Y += sqrt((y+1))/24;
    }
  
    //strip_size += sqrt((y+1))/64;
    strip_size += 0.5;

    pal_index = pal_index_ + 1;
    pal_index %= PALETTE_SIZE;
  }
  output_image.updatePixels();
}

// build a background for fun!!
void generateBackground() {
  PImage moon = loadImage(""moon.jpg"");
  moon.loadPixels();
  
  final int gradient_height = 16; // horizon gradient height
  final int gradient_color  = 200; // horizon color (hsv)
  
  color col  =  color(255, 255, 255);
  
  background_stars = createImage((int)(SCREEN_WIDTH), (int)(SCREEN_HEIGHT), RGB);
  background_stars.loadPixels();
  
  background_image = createImage(SCREEN_WIDTH, Y_START, ARGB);
  background_image.loadPixels();
  
  for (int i = 2; i < background_stars.width; i += 4) {
    int x = (int)random(i, i+2);
    int y = (int)random(1, background_stars.height-4);
    
    int index = x + y * background_stars.width;
    
    background_stars.pixels[index] = col;
  }
  
  for (int i = 8; i < background_stars.width-4; i+=4) {
    int x = (int)random(i, i+4);
    int y = (int)random(8, background_stars.height-4);
    
    int index = x + y * background_stars.width;

    int r = (int)random(0, 255);
    int g = (int)random(0, 255);
    int b = (int)random(0, 255);
    
    int star_brightness = (int)random(2, 3);
    
    background_stars.pixels[index] = col;
    
    for (int j = 1; j < star_brightness; j++) {
      color c1 = color(r / (j+1), g / (j+1), b / (j+1));
      color c2 = color(r / (j+3), g / (j+3), b / (j+3));
      
      background_stars.pixels[index+j] = c1;
      background_stars.pixels[index-j] = c1;
      background_stars.pixels[index+(j*background_stars.width)] = c1;
      background_stars.pixels[index+(j*background_stars.width)+1] = c2;
      background_stars.pixels[index+(j*background_stars.width)-1] = c2;
      background_stars.pixels[index-(j*background_stars.width)] = c1;
      background_stars.pixels[index-(j*background_stars.width)+1] = c2;
      background_stars.pixels[index-(j*background_stars.width)-1] = c2;
    }
  }
  background_stars.updatePixels();
  
  // moon
  for (int y = 0; y < background_image.height; y++) {
    for (int x = 0; x < moon.width; x++) {
      int index = x + y * moon.width;
      
      if ((moon.pixels[index]&0xFF) > 10) {
        background_image.pixels[index] = moon.pixels[index];
      }
    }
  }
  background_image.updatePixels();
  
  // build a slightly curved gradient/horizon
  PImage gradient_image = createImage(SCREEN_WIDTH, gradient_height, RGB);
  gradient_image.loadPixels();
  
  colorMode(HSB, 360);
  for (int y = 0; y < gradient_height; y++) {
    int y_index = y * SCREEN_WIDTH;
    for (int x = 0; x < SCREEN_WIDTH; x++) {
      int index = x + y_index;
      
      color gradient = color(gradient_color+sin(radians((float)abs(x-SCREEN_WIDTH_D2)/SCREEN_WIDTH*180))*10, 
                              360, 
                              ((float)y/gradient_height*360)*((sin(radians(((float)x/SCREEN_WIDTH*130)+25)))+0.4));

      gradient_image.pixels[index] = gradient;
    }
  }

  // blend gradient
  background_image.blend(gradient_image, 0, 0, gradient_image.width, gradient_image.height, 0, Y_START-gradient_height, background_image.width, gradient_image.height, LIGHTEST);
}

void setup() {
  size(256, 192);
	
  frameRate(60);

  output_image = createImage(SCREEN_WIDTH, SCREEN_HEIGHT, ARGB);
  
  logo = loadImage(""processing.png"");

  //saveCheckerboard();
  
  generateBackground();
}

/*
void saveCheckerboard() {
  draw_fx();
  output_image.save(""output.bmp"");
}
*/

void draw() {
  background(0);

  draw_fx();
  
  // add some funky background rotation
  translate(background_stars.width/2, background_stars.height/2);
  rotate(background_rot);
  image(background_stars, -(background_stars.width/2), -(background_stars.height/2));
  resetMatrix();
  
	// draw the chessboard
  image(background_image, 0, 0);
  
  image(output_image, 0, 0);
  
  background_rot += 0.001;
}"
"555398","8-bit color-cycling Chessboard","mySketch","/*
  8-bit color-cycling chessboard effect
	
	Mouse cursor axis change the pattern color.
	
  A demo and a tool to build old-school color cycling chessboard with image mask support, initially done as a tool for a Sega Master System demo.
  
  The image mask is only black/white and should be the size of the screen, it can be improved quite easily if you want a detailed texture.
	
  The drawing code just draw half the chessboard, the other half is mirrored.
	
	The initial idea with the chessboard algorithm was to build a generic tool to build Space Harrier like chessboard, it is entirely pixels-based.
  
  Can be used to generate many patterns by playing with sin/cos for the strip size and the others constants.
	
	Not perfect as there is some rough edges issues on the center band.
  
  To save the chessboard uncomment saveCheckerboard(); in the setup function, it will output a .bmp of the chessboard
  
  Note: For compatibility with processingjs, the color function is used instead of the RGB24 value, 
        otherwise the code is portable
  
  The generated background was added for fun (could be better with 3D stars)
	
	The moon picture was taken from a Skylux Bresser 70/700 telescope, the horizon is hardcoded within the image. 
*/

/* @pjs preload=""processing.png,moon.jpg""; */

final int SCREEN_WIDTH       = 256;
final int SCREEN_HEIGHT      = 192;
final int SCREEN_WIDTH_D2    = SCREEN_WIDTH/2;
final int Y_START            = (int)(SCREEN_HEIGHT/1.6); // the y position of the chessboard
final int PALETTE_SIZE       = 8;
final int PALETTE_SIZE_D2    = PALETTE_SIZE/2;
final int PALETTE_STEP       = 4; // this shift the chessboard patterns around, 1 could be used to generate wavy pattern
final int INITIAL_STEP_Y     = 0; // initial block height
final int INITIAL_STRIP_SIZE = 48;
final float SMOOTH_EDGE      = 0.75; // this smooth blocks a bit so they don't appear aliased with y stepping > 1

PImage output_image;
PImage logo;
PImage background_image;
PImage background_stars;

float background_rot = 0;

int []palette = new int[PALETTE_SIZE*2+2];

float cycling_index, cycling_index2;

int RGB24(int r, int g, int b) {
  if (r < 0) r = 0;
  if (g < 0) g = 0;
  if (b < 0) b = 0;
  
  return b|(g<<8)|(r<<16);
}

// color cycling stuff
int []cycling = new int[PALETTE_SIZE*2+2];
void color_cycling() {
  int mxc = (int)((float)mouseX/SCREEN_WIDTH  * 360);
  int myc = (int)((float)mouseY/SCREEN_HEIGHT * 360);
  
  colorMode(HSB, 360);
  
   // quantize the hsb to a 64 colors palette similar to the one used on the Sega Master System
  color hsb1 = color(((int)mxc/20)*20, 360, 360);
  color hsb2 = color(((int)myc/20)*20, 360, 360);
  color hsb3 = color((int)(100+abs(mxc-100)/20*20), 360, 360);
  color hsb4 = color((int)(100+abs(myc-100)/20*20), 360, 360);
  color hsb5 = color((((int)mxc/20)*20+180)%360, 360, 360);
  color hsb6 = color((((int)myc/20)*20+180)%360, 360, 360);
  color hsb7 = color(((int)(100+abs(mxc-100)/20*20)+180)%360, 360, 360);
  color hsb8 = color(((int)(100+abs(myc-100)/20*20)+180)%360, 360, 360);
  
  colorMode(RGB, 255);

  int c1 = RGB24((int)red(hsb1), (int)green(hsb1), (int)blue(hsb1));
  int c2 = RGB24((int)red(hsb1), (int)green(hsb1), (int)blue(hsb1));
  int c3 = RGB24((int)red(hsb3), (int)green(hsb3), (int)blue(hsb3));
  int c4 = RGB24((int)red(hsb3), (int)green(hsb3), (int)blue(hsb3));
  int c5 = RGB24((int)red(hsb2), (int)green(hsb2), (int)blue(hsb2));
  int c6 = RGB24((int)red(hsb2), (int)green(hsb2), (int)blue(hsb2));
  int c7 = RGB24((int)red(hsb4), (int)green(hsb4), (int)blue(hsb4));
  int c8 = RGB24((int)red(hsb4), (int)green(hsb4), (int)blue(hsb4));
  int c9 = RGB24((int)red(hsb1), (int)green(hsb1), (int)blue(hsb1));
  int c10 = RGB24((int)red(hsb1), (int)green(hsb1), (int)blue(hsb1));
  int c11 = RGB24((int)red(hsb3), (int)green(hsb3), (int)blue(hsb3));
  int c12 = RGB24((int)red(hsb3), (int)green(hsb3), (int)blue(hsb3));
  int c13 = RGB24((int)red(hsb2), (int)green(hsb2), (int)blue(hsb2));
  int c14 = RGB24((int)red(hsb2), (int)green(hsb2), (int)blue(hsb2));
  int c15 = RGB24((int)red(hsb4), (int)green(hsb4), (int)blue(hsb4));
  int c16 = RGB24((int)red(hsb4), (int)green(hsb4), (int)blue(hsb4));
  
  palette[0] = c1;
  palette[1] = c2;
  palette[2] = c3;
  palette[3] = c4;
  palette[4] = c5;
  palette[5] = c6;
  palette[6] = c7;
  palette[7] = c8;
  palette[8] = c9;
  palette[9] = c10;
  palette[10] = c11;
  palette[11] = c12;
  palette[12] = c13;
  palette[13] = c14;
  palette[14] = c15;
  palette[15] = c16;

  arrayCopy(palette, cycling);
  
  for (int i = (int)cycling_index; i < (int)cycling_index+PALETTE_SIZE; i++) {
    int cc = cycling[i-(int)cycling_index];
    
    palette[i%PALETTE_SIZE] = cc;
  }
  
  for (int i = (int)cycling_index2; i < (int)cycling_index2+PALETTE_SIZE; i++) {
    int cc = cycling[PALETTE_SIZE+i-(int)cycling_index2];
    
    palette[PALETTE_SIZE+(i%(PALETTE_SIZE))] = cc;
  }
  
  cycling_index += 0.4;
  cycling_index2 += 0.4;
}

// chessboard core
void draw_fx() {
  color_cycling();
   
  float STEP_Y = INITIAL_STEP_Y;
  
  int pal_index  = 0;
  float strip_size = INITIAL_STRIP_SIZE;
  
  output_image.loadPixels();

  float add_size = 0;
  for (int y = Y_START; y < SCREEN_HEIGHT; y+=(int)STEP_Y) {
    int pal_index_ = pal_index;
    
    int off_x = SCREEN_WIDTH_D2;
    int id_x = SCREEN_WIDTH_D2/(int)strip_size;
    
    for (int x = id_x; x >= 0; x--) {
      int col = palette[pal_index];
      if (((x-id_x)&1) == 0) {
        col = palette[pal_index+8];
      }
      
      int col2 = palette[(pal_index+PALETTE_SIZE_D2)%PALETTE_SIZE];
      int col3 = 0;//palette[14+(pal_index)%2];
      int col4 = 0;//palette[14+(pal_index)%2];
      
      color c1, c2, c3, c4;
      if (y < Y_START+2) {
        c1 = color(((col>>16)&0xFF)-170, ((col>>8)&0xFF)-170, (col&0xFF)-170);
        c2 = color(((col2>>16)&0xFF)-170, ((col2>>8)&0xFF)-170, (col2&0xFF)-170);
      } else if (y < Y_START+8) {
        c1 = color(((col>>16)&0xFF)-85, ((col>>8)&0xFF)-85, (col&0xFF)-85);
        c2 = color(((col2>>16)&0xFF)-85, ((col2>>8)&0xFF)-85, (col2&0xFF)-85);
      } else {
        c1 = color((col>>16)&0xFF, (col>>8)&0xFF, col&0xFF);
        c2 = color((col2>>16)&0xFF, (col2>>8)&0xFF, col2&0xFF);
      }
  
      c3 = color((col3>>16)&0xFF, (col3>>8)&0xFF, col3&0xFF);
      c4 = color((col4>>16)&0xFF, (col4>>8)&0xFF, col4&0xFF);
      
      float off_x_ = off_x;
      
      int start = -2;

      for (int i = 0; i <= (int)STEP_Y; i++) {
        // the code in the if block is cloned from the main strip drawing code
        // you can remove this part to get a standard Space Harrier like checkerboard
        // this draw a small strip in the middle so it look much better
        if (x > id_x-1) {
          start = (int)((float)(y-Y_START)/4)+8;
          
          for (int j = -32; j < start+32; j++) {
            int xx = (int)off_x - j;
            
            int yy = y + i;
  
            if (xx < 0 ) break;
            if (yy >= SCREEN_HEIGHT ) break;
            
            int line_index = yy * SCREEN_WIDTH;
            
            int index  = xx + line_index;
            int index2 = SCREEN_WIDTH_D2+abs(SCREEN_WIDTH_D2-xx-1) + line_index;
  					
						if (index > logo.pixels.length) {
    					output_image.pixels[index] = c2;
  					} else {
							if (((logo.pixels[index]>>16)&0xFF) > 0) {
								output_image.pixels[index] = c4;
							} else {
								output_image.pixels[index] = c2;
							}
  					}
						
						if (index2 > logo.pixels.length) {
							output_image.pixels[index] = c2;
						} else { 
							if (((logo.pixels[index2]>>16)&0xFF) > 0) {
								output_image.pixels[index2] = c4;
							} else {
								output_image.pixels[index2] = c2;
							}
						}
          }
        }
        
        // this is the main strip drawing code
        for (int j = start; j < (int)strip_size+(int)add_size; j++) {
          int xx = (int)off_x_ - j;
          
          int yy = y + i;

          if (xx < 0 ) break;
          if (yy >= SCREEN_HEIGHT ) break;
          
          int line_index = yy * SCREEN_WIDTH;
          
          int index  = xx + line_index;
          int index2 = SCREEN_WIDTH_D2+abs(SCREEN_WIDTH_D2-xx-1) + line_index;

					if(index > logo.pixels.length) {
  					output_image.pixels[index] = c1;
					} else {
						if (((logo.pixels[index]>>16)&0xFF) > 0) {
							output_image.pixels[index] = c4;
						} else {
							output_image.pixels[index] = c1;
						}
					}
					
					if(index2 > logo.pixels.length) {
						output_image.pixels[index2] = c1;
					} else {
						if (((logo.pixels[index2]>>16)&0xFF) > 0) {
							output_image.pixels[index2] = c4;
						} else {
							output_image.pixels[index2] = c1;
						}
					}
        }
        off_x_ -= SMOOTH_EDGE;
      }
      
      //if (off_x > SCREEN_HEIGHT-(y+8)) { // comment this off for a Space Harrier like checkerboard (with no strips on the side)
        pal_index += PALETTE_STEP;
        pal_index %= PALETTE_SIZE;
      //}
      
      off_x -= (int)strip_size+add_size;
    }
    
    add_size+=SMOOTH_EDGE*STEP_Y/1.8;

    // this give a better look and can be used to generate others effects (like waterfall if strip_size is modified)
    if (y < 158) {
      STEP_Y += sqrt((y+1))/64;
    }
    else {
      STEP_Y += sqrt((y+1))/24;
    }
  
    //strip_size += sqrt((y+1))/64;
    strip_size += 0.5;

    pal_index = pal_index_ + 1;
    pal_index %= PALETTE_SIZE;
  }
  output_image.updatePixels();
}

// build a background for fun!!
void generateBackground() {
  PImage moon = loadImage(""moon.jpg"");
  moon.loadPixels();
  
  final int gradient_height = 16; // horizon gradient height
  final int gradient_color  = 200; // horizon color (hsv)
  
  color col  =  color(255, 255, 255);
  
  background_stars = createImage((int)(SCREEN_WIDTH), (int)(SCREEN_HEIGHT), RGB);
  background_stars.loadPixels();
  
  background_image = createImage(SCREEN_WIDTH, Y_START, ARGB);
  background_image.loadPixels();
  
  for (int i = 2; i < background_stars.width; i += 4) {
    int x = (int)random(i, i+2);
    int y = (int)random(1, background_stars.height-4);
    
    int index = x + y * background_stars.width;
    
    background_stars.pixels[index] = col;
  }
  
  for (int i = 8; i < background_stars.width-4; i+=4) {
    int x = (int)random(i, i+4);
    int y = (int)random(8, background_stars.height-4);
    
    int index = x + y * background_stars.width;

    int r = (int)random(0, 255);
    int g = (int)random(0, 255);
    int b = (int)random(0, 255);
    
    int star_brightness = (int)random(2, 3);
    
    background_stars.pixels[index] = col;
    
    for (int j = 1; j < star_brightness; j++) {
      color c1 = color(r / (j+1), g / (j+1), b / (j+1));
      color c2 = color(r / (j+3), g / (j+3), b / (j+3));
      
      background_stars.pixels[index+j] = c1;
      background_stars.pixels[index-j] = c1;
      background_stars.pixels[index+(j*background_stars.width)] = c1;
      background_stars.pixels[index+(j*background_stars.width)+1] = c2;
      background_stars.pixels[index+(j*background_stars.width)-1] = c2;
      background_stars.pixels[index-(j*background_stars.width)] = c1;
      background_stars.pixels[index-(j*background_stars.width)+1] = c2;
      background_stars.pixels[index-(j*background_stars.width)-1] = c2;
    }
  }
  background_stars.updatePixels();
  
  // moon
  for (int y = 0; y < background_image.height; y++) {
    for (int x = 0; x < moon.width; x++) {
      int index = x + y * moon.width;
      
      if ((moon.pixels[index]&0xFF) > 10) {
        background_image.pixels[index] = moon.pixels[index];
      }
    }
  }
  background_image.updatePixels();
  
  // build a slightly curved gradient/horizon
  PImage gradient_image = createImage(SCREEN_WIDTH, gradient_height, RGB);
  gradient_image.loadPixels();
  
  colorMode(HSB, 360);
  for (int y = 0; y < gradient_height; y++) {
    int y_index = y * SCREEN_WIDTH;
    for (int x = 0; x < SCREEN_WIDTH; x++) {
      int index = x + y_index;
      
      color gradient = color(gradient_color+sin(radians((float)abs(x-SCREEN_WIDTH_D2)/SCREEN_WIDTH*180))*10, 
                              360, 
                              ((float)y/gradient_height*360)*((sin(radians(((float)x/SCREEN_WIDTH*130)+25)))+0.4));

      gradient_image.pixels[index] = gradient;
    }
  }

  // blend gradient
  background_image.blend(gradient_image, 0, 0, gradient_image.width, gradient_image.height, 0, Y_START-gradient_height, background_image.width, gradient_image.height, LIGHTEST);
}

void setup() {
  size(256, 192);
	
  frameRate(60);

  output_image = createImage(SCREEN_WIDTH, SCREEN_HEIGHT, ARGB);
  
  logo = loadImage(""processing.png"");

  //saveCheckerboard();
  
  generateBackground();
}

/*
void saveCheckerboard() {
  draw_fx();
  output_image.save(""output.bmp"");
}
*/

void draw() {
  background(0);

  draw_fx();
  
  // add some funky background rotation
  translate(background_stars.width/2, background_stars.height/2);
  rotate(background_rot);
  image(background_stars, -(background_stars.width/2), -(background_stars.height/2));
  resetMatrix();
  
	// draw the chessboard
  image(background_image, 0, 0);
  
  image(output_image, 0, 0);
  
  background_rot += 0.001;
}"
"555375","8-bit Dots/Voxel Terrain","mySketch","/**
  * 8-bit Voxel/dots Terrain
	* 
	* Cursor X axis control the dot size.
	*
	* Initially done as a prototype for a Sega Master System demo,
	* started out as a points landscape with a hardcoded perspective (through trials & errors),
	* then expanded to a voxel-like terrain by increasing the dot size and adding height-based color,
	* there is some graphical errors due to the way it is done.
	* 
	* This could be done on a 8-bit tile-based hardware pretty easily!
	*/

PImage heightmap;

int []palette = new int[8];

int RGB24(int r, int g, int b) {
  return b|(g<<8)|(r<<16);
}

float scrollx = 0;
float scrolly = 0;

void draw_landscape() {
	// these change the landscape perspective
  float xoff = 0;
  float y_start = 128;
  float spacing = 8;

  int c = 0;
  noStroke();
  for (int y = 0; y < 28; y++) {
    for (int x = 0; x < 30; x++) {
			// height & color handling
      int h = (int)red(heightmap.pixels[(((int)scrollx + x)&(heightmap.width-1)) + ((y - (int)scrolly)&(heightmap.height-1)) * heightmap.width])/4;
      int pal_index = (int)(((float)h / (64/10))-1);
			pal_index = min(max(pal_index, 0), 7);
      
      int h2 = (int)red(heightmap.pixels[(((int)scrollx + x+1)&(heightmap.width-1)) + ((y - (int)scrolly)&(heightmap.height-1)) * heightmap.width])/4;
      int pal_index2 = (int)(((float)h2 / (64/10))-1);
      pal_index2 = min(max(pal_index2, 0), 7);
      int rgb24_color2 = palette[pal_index2];
      
      int h3 = (int)red(heightmap.pixels[(((int)scrollx + x)&(heightmap.width-1)) + ((y - (int)scrolly+1)&(heightmap.height-1)) * heightmap.width])/4;
      int pal_index3 = (int)(((float)h3 / (64/10))-1);
      pal_index3 = min(max(pal_index3, 0), 7);
      int rgb24_color3 = palette[pal_index3];
      
      int rgb24_color = palette[pal_index];
      
			// the terrain components size, low value is just a landscape made of points (the initial form)
      float rect_size = max(1, mouseX/32);
			
			// distance fog & terrain lighting (note : could be smoother)
      int terrain_distance_color = (28 - y) * 3;
			
      if (y < 3) terrain_distance_color = -25;
      if (y < 1) terrain_distance_color = -85;
      
			// landscape core
      int xx = (int)((xoff+(x*spacing))/4)*4;
      int xx2 = (int)((xoff+((x+1)*spacing))/4)*4;
      int yy = ((int)(y_start+((y*1.5)*(spacing/8)) - h)/4)*4;
      int yy2 = ((int)(y_start+(((y+1)*1.5)*(spacing/8)) - h3)/4)*4;
      int diff = xx2-xx;
      int diffy = yy2-yy;
      for (int m = 0; m <= diffy; m+=4) {
				for (int o = 0; o <= diff; o+=4) {
					fill(((rgb24_color>>16)&0xFF)+terrain_distance_color, ((rgb24_color>>8)&0xFF)+terrain_distance_color, (rgb24_color&0xFF)+terrain_distance_color);
					rect(xx+o, yy+m, rect_size, rect_size);
				}

        fill(((rgb24_color>>16)&0xFF)+terrain_distance_color, ((rgb24_color>>8)&0xFF)+terrain_distance_color, (rgb24_color&0xFF)+terrain_distance_color);
        rect(xx, yy+m, rect_size, rect_size);
      }

			// height debug
/*
			fill(255);
			text(str(y), (int)((xoff+(x*spacing))/4)*4, ((int)(y_start+((y*1.5)*(spacing/8)) - h)/4)*4);
*/
    }
		
    xoff -= 7.5;
    spacing += 0.475;
  }

	// camera movement
	scrollx = 32 + sin(scrolly / 16) / 2 * heightmap.width;
  scrolly += 0.25;
}

void setup() {
  size(256, 192);

  frameRate(60); 
  
	// load height data based on pixels brightness
  heightmap = loadImage(""heightmap.png"");
  heightmap.loadPixels();
  
  int []heightdata = new int[64*64];
  for (int y = 0; y < 64; y++) {
    for (int x = 0; x < 64; x++) {
      int h = (int)red(heightmap.pixels[(((int) x)&(heightmap.width-1)) + (y&(heightmap.height-1)) * heightmap.width]) / 4;

      heightdata[x + y * 64] = h;
    }
  }
  
	// setup a basic palette for height level
  palette[0] = RGB24(0, 0, 85);
  palette[1] = RGB24(0, 0, 255);
  palette[2] = RGB24(170, 170, 0);
  palette[3] = RGB24(85, 170, 0);
  palette[4] = RGB24(0, 170, 0);
  palette[5] = RGB24(170, 85, 0);
  palette[6] = RGB24(170, 85, 0);
  palette[7] = RGB24(255, 255, 255);
}

void draw() {
  background(0);
 
  draw_landscape();
}"
"555366","8-bit RotoZoom","mySketch","// Animated oldschool rotozoom by Grz-

final int SCREEN_WIDTH  = 256;
final int SCREEN_HEIGHT = 192;
// if you want to use the tiling thing, divide the area by a power of two
final int AREA_WIDTH    = SCREEN_WIDTH;
final int AREA_HEIGHT   = SCREEN_HEIGHT;
final int TILE_SIZE     = 2;   // rotozoom blocks size, 1 = best quality
final int LUT_SIZE      = 256; // increasing this permit smoother/richer rotozoom
final int FRAMES_COUNT  = 3;   // number of anim. frames (1 = single image)
final int FRAMES_DELAY  = 30;  // delay between frame switch in milliseconds

PImage []images; // hold all frames

int []roto_x, roto_y;

int image_size;
int anim_timer, curr_frame = 0;

void setup() {
  size(256, 192);

  background(0);
  frameRate(30);
  
  // load all images of our anim
  images = new PImage[FRAMES_COUNT];
  for (int i = 0; i < FRAMES_COUNT; i++) {
    images[i] = loadImage(""roto""+str(i)+"".png"");
    
    if (images[i].width != images[i].height) {
      print(""Image frame number '""+str(i)+""' must be square and a power of two in dimension."");
      exit();
    }
  }

  image_size = images[0].width-1;
  
  anim_timer = millis();

  // lut setup
  roto_x = new int[LUT_SIZE];
  roto_y = new int[LUT_SIZE];
  
  for (int i = 0; i < LUT_SIZE; i++)
  {
    float angle = radians(i);
    float c = cos(angle + sin(angle + 0.31575)*3.5 - 1.0);
    
    roto_x[i] = (int)((c+0.3) * 4096.0);
    roto_y[i] = (int)((c+0.2) * 4096.0);
  }
}

int path = 0, zpath = 0;

void draw() {
  background(0);
  
  int i, j, xd, yd, a, b, sx, sy;

  sx = sy = 0;
  xd = (roto_x[(path) & (LUT_SIZE-1)] * 2048) >> 13;
  yd = (roto_y[(path+64) & (LUT_SIZE-1)] * 2048) >> 13;
  
  if (millis()-anim_timer > FRAMES_DELAY) {
    curr_frame++;
    curr_frame %= FRAMES_COUNT;
    anim_timer = millis();
  }
  
  PImage image = images[curr_frame];
   
  // rotozoom!
  loadPixels();
  image.loadPixels();
  
  for (int y = 0; y < AREA_HEIGHT; y+=TILE_SIZE) {
    i = sx;
    j = sy;
    
    for (int x = 0; x < AREA_WIDTH; x+=TILE_SIZE) {
      a = i >> 12 & image_size;
      b = j >> 12 & image_size;
      
      int iindex = a + b * image.width;
       
      for (int yy = 0; yy < TILE_SIZE; yy++) {
        int yrow = (y+yy) * SCREEN_WIDTH;
        for (int xx = 0; xx < TILE_SIZE; xx++) {
          int index = x+xx + yrow;
          
          pixels[index] += image.pixels[iindex];
        }
      }
      
      i += xd;
      j += yd;
    }
    
    sx -= yd;
    sy += xd;
  }

  updatePixels();
  
  path = (path - 1) & (LUT_SIZE-1);
}"
"555366","8-bit RotoZoom","mySketch","/**
 * 8-bit oldschool blocks-based animated rotozoom
 *
 * Initially made as a prototype for a Sega Master System demo,
 * it is blocks based which mean that it is built out of pixel blocks, emulating the tiling hardware in early video game hardware.
 */

final int SCREEN_WIDTH  = 256;
final int SCREEN_HEIGHT = 192;
// if you want to use the tiling thing, divide the area by a power of two
final int AREA_WIDTH    = SCREEN_WIDTH;
final int AREA_HEIGHT   = SCREEN_HEIGHT;
final int TILE_SIZE     = 8;   // rotozoom blocks size, 1 = best resolution / quality
final int LUT_SIZE      = 256;
final int FRAMES_COUNT  = 3;   // number of anim. frames (1 = single image)
final int FRAMES_DELAY  = 30;  // delay between frame switch (milliseconds)

PImage []images; // hold all frames

int []roto_x, roto_y;

int image_size;
int anim_timer, curr_frame = 0;

void setup() {
  size(256, 192);

  background(0);
  frameRate(30);
  
  // load all images of the animation
  images = new PImage[FRAMES_COUNT];
  for (int i = 0; i < FRAMES_COUNT; i++) {
    images[i] = loadImage(""roto""+str(i)+"".png"");
    
    if (images[i].width != images[i].height) {
      print(""Image frame number '""+str(i)+""' must be square and a power of two in dimension."");
      exit();
    }
  }

  image_size = images[0].width-1;
  
  anim_timer = millis();

  // lut setup
  roto_x = new int[LUT_SIZE];
  roto_y = new int[LUT_SIZE];
  
  for (int i = 0; i < LUT_SIZE; i++) {
    float angle = radians(i);
    float c = cos(angle + sin(angle + 0.31575)*3.5 - 1.0);
    
    roto_x[i] = (int)((c+0.3) * 4096.0);
    roto_y[i] = (int)((c+0.2) * 4096.0);
  }
}

int path = 0, zpath = 0;

void draw() {
  background(0);
  
  int i, j, xd, yd, a, b, sx, sy;

  sx = sy = 0;
  xd = (roto_x[(path) & (LUT_SIZE-1)] * 4096) >> 13;
  yd = (roto_y[(path+64) & (LUT_SIZE-1)] * 4096) >> 13;
  
	// animate by switching images
  if (millis()-anim_timer > FRAMES_DELAY) {
    curr_frame++;
    curr_frame %= FRAMES_COUNT;
    anim_timer = millis();
  }
  
  PImage image = images[curr_frame];
  
  loadPixels();
  image.loadPixels();
  
  for (int y = 0; y < AREA_HEIGHT; y+=TILE_SIZE) {
    i = sx;
    j = sy;
    
    for (int x = 0; x < AREA_WIDTH; x+=TILE_SIZE) {
      a = i >> 12 & image_size;
      b = j >> 12 & image_size;
      
      int iindex = a + b * image.width;
       
      for (int yy = 0; yy < TILE_SIZE; yy++) {
        int yrow = (y+yy) * SCREEN_WIDTH;
        for (int xx = 0; xx < TILE_SIZE; xx++) {
          int index = x+xx + yrow;
          
          pixels[index] += image.pixels[iindex];
        }
      }
      
      i += xd;
      j += yd;
    }
    
    sx -= yd;
    sy += xd;
  }

  updatePixels();
  
  path = (path - 1) & (LUT_SIZE-1);
}"
"555366","8-bit RotoZoom","mySketch","/**
 * 8-bit oldschool blocks-based and animated rotozoom
 *
 * Initially made as a prototype for a Sega Master System demo,
 * it is built out of pixel blocks, emulating the tiling hardware in early video game console.
 */

final int SCREEN_WIDTH  = 256;
final int SCREEN_HEIGHT = 192;
final int AREA_WIDTH    = SCREEN_WIDTH;
final int AREA_HEIGHT   = SCREEN_HEIGHT;
final int TILE_SIZE     = 8;   // rotozoom blocks size, 1 = best resolution / quality
final int LUT_SIZE      = 256;
final int FRAMES_COUNT  = 3;   // number of anim. frames (1 = single image)
final int FRAMES_DELAY  = 30;  // delay between frame switch (milliseconds)

PImage []images; // hold all frames

int []roto_x, roto_y;

int image_size;
int anim_timer, curr_frame = 0;

void setup() {
  size(256, 192);

  background(0);
  frameRate(30);
  
  // load all the animation images
  images = new PImage[FRAMES_COUNT];
  for (int i = 0; i < FRAMES_COUNT; i++) {
    images[i] = loadImage(""roto""+str(i)+"".png"");
  }

  image_size = 31; // hardcoded but should be ""images[0].width-1""
  
  anim_timer = millis();

  // lut setup for rotation path
  roto_x = new int[LUT_SIZE];
  roto_y = new int[LUT_SIZE];
  
  for (int i = 0; i < LUT_SIZE; i++) {
    float angle = radians(i);
    float c = cos(angle + sin(angle + 0.31575)*3.5 - 1.0);
    
    roto_x[i] = (int)((c+0.3) * 4096.0);
    roto_y[i] = (int)((c+0.2) * 4096.0);
  }
}

int path = 0, zpath = 0;

void draw() {
  background(0);
  
  int i, j, xd, yd, a, b, sx, sy;
	int zoom = roto_y[(path + 32) & (LUT_SIZE-1)] * 4;
  sx = sy = 0;
  
	// animate by switching images
  if (millis()-anim_timer > FRAMES_DELAY) {
    curr_frame++;
    curr_frame %= FRAMES_COUNT;
    anim_timer = millis();
  }
  
  PImage image = images[curr_frame];
  
	// rotozoom core
  xd = (roto_x[(path) & (LUT_SIZE-1)] * zoom) >> 13;
  yd = (roto_y[(path+64) & (LUT_SIZE-1)] * zoom) >> 13;
	
  loadPixels();
  image.loadPixels();
  
  for (int y = 0; y < AREA_HEIGHT; y+=TILE_SIZE) {
    i = sx;
    j = sy;
    
    for (int x = 0; x < AREA_WIDTH; x+=TILE_SIZE) {
      a = i >> 12 & image_size;
      b = j >> 12 & image_size;
      
      int iindex = a + b * image.width;
       
      for (int yy = 0; yy < TILE_SIZE; yy++) {
        int yrow = (y+yy) * SCREEN_WIDTH;
        for (int xx = 0; xx < TILE_SIZE; xx++) {
          int index = x+xx + yrow;
          
          pixels[index] = pixels[index]+image.pixels[iindex];
        }
      }
      
      i += xd;
      j += yd;
    }
    
    sx -= yd;
    sy += xd;
  }
	
  updatePixels();
  
  path = (path - 1) & (LUT_SIZE-1);
}"
"555366","8-bit RotoZoom","mySketch","/**
 * 8-bit oldschool blocks-based and animated rotozoom
 *
 * Initially made as a prototype for a Sega Master System demo,
 * it is built out of pixel blocks, emulating the tiling hardware in early video game console.
 */

final int SCREEN_WIDTH  = 256 * 2;
final int SCREEN_HEIGHT = 192 * 2;
final int AREA_WIDTH    = SCREEN_WIDTH;
final int AREA_HEIGHT   = SCREEN_HEIGHT;
final int TILE_SIZE     = 8;   // rotozoom blocks size (pixels), 1 = best resolution / quality
final int LUT_SIZE      = 256;
final int FRAMES_COUNT  = 3;   // number of anim. frames (1 = single image)
final int FRAMES_DELAY  = 20;  // delay between frame switch (milliseconds)

PImage []images; // hold all frames

int []roto_x, roto_y;

int image_size;
int anim_timer, curr_frame = 0;

void setup() {
  size(256 * 2, 192 * 2);

  background(0);
  frameRate(30);
  
  // load all the animation images
  images = new PImage[FRAMES_COUNT];
  for (int i = 0; i < FRAMES_COUNT; i++) {
    images[i] = loadImage(""roto""+str(i)+"".png"");
  }

  image_size = 31; // hardcoded but should be ""images[0].width-1""
  
  anim_timer = millis();

  // lut setup for rotation path
  roto_x = new int[LUT_SIZE];
  roto_y = new int[LUT_SIZE];
  
  for (int i = 0; i < LUT_SIZE; i++) {
    float angle = radians(i);
    float c = cos(angle + sin(angle + 0.31575)*3.5 - 1.0);
    
    roto_x[i] = (int)((c+0.3) * 4096.0);
    roto_y[i] = (int)((c+0.2) * 4096.0);
  }
}

int path = 0, zpath = 0;

void draw() {
  int i, j, xd, yd, a, b, sx, sy;
	int zoom = 10000;
  sx = sy = 0;
  
	// animate by switching images
  if (millis()-anim_timer > FRAMES_DELAY) {
    curr_frame++;
    curr_frame %= FRAMES_COUNT;
    anim_timer = millis();
  }
  
  PImage image = images[curr_frame];
  
	// rotozoom core
  xd = (roto_x[(path) & (LUT_SIZE-1)] * zoom) >> 13;
  yd = (roto_y[(path+64) & (LUT_SIZE-1)] * zoom) >> 13;
	
  loadPixels();
  image.loadPixels();
  
  for (int y = 0; y < AREA_HEIGHT; y+=TILE_SIZE) {
    i = sx;
    j = sy;
    
    for (int x = 0; x < AREA_WIDTH; x+=TILE_SIZE) {
      a = i >> 12 & image_size;
      b = j >> 12 & image_size;
      
      int iindex = a + b * image.width;
       
      for (int yy = 0; yy < TILE_SIZE; yy++) {
        int yrow = (y+yy) * SCREEN_WIDTH;
        for (int xx = 0; xx < TILE_SIZE; xx++) {
          int index = x+xx + yrow;
          
          pixels[index] = image.pixels[iindex];
        }
      }
      
      i += xd;
      j += yd;
    }
    
    sx -= yd;
    sy += xd;
  }
	
  updatePixels();
  
  path = (path - 1) & (LUT_SIZE-1);
}"
"555366","8-bit RotoZoom","mySketch","/**
 * 8-bit oldschool blocks-based and animated rotozoom
 *
 * Initially made as a prototype for a Sega Master System demo,
 * it is built out of pixel blocks, emulating the tiling hardware in early video game console.
 */

final int SCREEN_WIDTH  = 256 * 2;
final int SCREEN_HEIGHT = 192 * 2;
final int AREA_WIDTH    = SCREEN_WIDTH;
final int AREA_HEIGHT   = SCREEN_HEIGHT;
final int TILE_SIZE     = 8;   // rotozoom blocks size (pixels), 1 = best resolution / quality
final int LUT_SIZE      = 256;
final int FRAMES_COUNT  = 3;   // number of anim. frames (1 = single image)
final int FRAMES_DELAY  = 20;  // delay between frame switch (milliseconds)

PImage []images; // hold all frames

int []roto_x, roto_y;

int image_size;
int anim_timer, curr_frame = 0;

void setup() {
  size(256 * 2, 192 * 2);

  background(0);
  frameRate(30);
  
  // load all the animation images
  images = new PImage[FRAMES_COUNT];
  for (int i = 0; i < FRAMES_COUNT; i++) {
    images[i] = loadImage(""roto""+str(i)+"".png"");
  }

  image_size = 31; // hardcoded but should be ""images[0].width-1""
  
  anim_timer = millis();

  // lut setup for rotation path
  roto_x = new int[LUT_SIZE];
  roto_y = new int[LUT_SIZE];
  
  for (int i = 0; i < LUT_SIZE; i++) {
    float angle = radians(i);
    float c = cos(angle + sin(angle + 0.31575)*3.5 - 1.0);
    
    roto_x[i] = (int)((c+0.3) * 4096.0);
    roto_y[i] = (int)((c+0.2) * 4096.0);
  }
}

int path = 0, zpath = 0;

void draw() {
  int i, j, xd, yd, a, b, sx, sy;
	int zoom = 10000;
  sx = sy = 0;
  
	// animate by switching images
  if (millis()-anim_timer > FRAMES_DELAY) {
    curr_frame++;
    curr_frame %= FRAMES_COUNT;
    anim_timer = millis();
  }
  
  PImage image = images[curr_frame];
  
	// rotozoom core
  xd = (roto_x[(path) & (LUT_SIZE-1)] * zoom) >> 13;
  yd = (roto_y[(path+64) & (LUT_SIZE-1)] * zoom) >> 13;
	
  loadPixels();
  image.loadPixels();
  
  for (int y = 0; y < AREA_HEIGHT; y+=TILE_SIZE) {
    i = sx;
    j = sy;
    
    for (int x = 0; x < AREA_WIDTH; x+=TILE_SIZE) {
      a = i >> 12 & image_size;
      b = j >> 12 & image_size;
      
      int iindex = a + b * image.width;
       
      for (int yy = 0; yy < TILE_SIZE; yy++) {
        int yrow = (y+yy) * SCREEN_WIDTH;
        for (int xx = 0; xx < TILE_SIZE; xx++) {
          int index = x+xx + yrow;
          
          pixels[index] = image.pixels[iindex];
        }
      }
      
      i += xd;
      j += yd;
    }
    
    sx -= yd;
    sy += xd;
  }
	
  updatePixels();
  
  path = (path - 1) & (LUT_SIZE-1);
}"
